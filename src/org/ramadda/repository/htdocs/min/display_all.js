/**
   Copyright 2008-2021 Geode Systems LLC
*/

function AreaWidget(display) {
    const ID_CONTAINS = "mapcontains";
    const ID_NORTH = "north";
    const ID_SOUTH = "south";
    const ID_EAST = "east";
    const ID_WEST = "west";
    const ID_SETTINGS = "mapsettings";
    const ID_AREA_LINK = "arealink";
    const ID_MAP_SHOW = "showmap";
    const ID_MAP_POPUP_WRAPPER = "mappopupwrapper";    
    const ID_MAP_POPUP = "mappopup";    
    const ID_CLEAR = "mapclear";    
    const ID_SET_LOCATION="mapsetlocation";



    $.extend(this, {
	areaContains: HU.getUrlArgument("map_contains")=="true",
        display: display,
        initHtml: function() {
	    this.display.jq(ID_SETTINGS).click(()=>{
		this.showSettings();
	    });
	    this.display.jq(ID_MAP_SHOW).click(()=>{
		this.showMap();
	    });

	    let params = {};
	    this.map =  new RepositoryMap(this.display.domId(ID_MAP_POPUP), params);
	    this.map.setSelection(this.display.getId(),true,1);
	},
        showSettings: function() {
	    let _this = this;
	    let html = "";
	    html+= HU.div([CLASS,"ramadda-clickable",TITLE, "Use my location",ID,this.display.domId(ID_SET_LOCATION)],
			  HU.getIconImage("fas fa-compass") + SPACE + "Use my location");
            html += HU.div([CLASS,"ramadda-clickable",TITLE, "Clear form",ID,this.display.domId(ID_CLEAR)],
			  HU.getIconImage("fas fa-eraser") + SPACE + "Clear form");
	    html+= HU.div([TITLE, "Search mode: checked - contains, unchecked - overlaps"],
			  HtmlUtils.checkbox("",[ID, this.display.getDomId(ID_CONTAINS)], this.areaContains) +HU.tag("label",[CLASS,"ramadda-clickable","for",this.display.getDomId(ID_CONTAINS)], SPACE + "Contains"));
	    html = HU.div([STYLE,"margin:5px;"], html);
	    this.settingsDialog = HU.makeDialog({content:html,anchor:this.display.jq(ID_SETTINGS),draggable:false,header:true});
	    this.display.jq(ID_CONTAINS).change(function(e) {
		_this.areaContains = $(this).is(':checked');
	    });
	    this.display.jq(ID_SET_LOCATION).click(()=>{
		this.settingsDialog.remove();
		this.useMyLocation();
	    });
	    this.display.jq(ID_CLEAR).click(()=>{
		this.settingsDialog.remove();
		this.areaClear();
	    });	    
	},
        getHtml: function() {
	    let bounds =  HU.getUrlArgument("map_bounds");
	    let n="",w="",s="",e="";
	    if(bounds) {
		[n,w,s,e]  = bounds.split(",");
	    }
            let callback = this.display.getGet();
            let settings = HU.div([TITLE,"Settings",CLASS,"ramadda-clickable",ID,this.display.domId(ID_SETTINGS)],HU.getIconImage("fas fa-cog"));
	    let showMap = HU.div([CLASS,"ramadda-clickable",ID,this.display.domId(ID_MAP_SHOW),TITLE,"Show map selector"], HtmlUtils.getIconImage("fas fa-globe"));

	    let input = (id,place,title,v)=>{
		return HtmlUtils.input(id, v, ["placeholder", place, ATTR_CLASS, "input display-area-input", "size", "5", ATTR_ID,
						this.display.getDomId(id), ATTR_TITLE, title]);
	    };
            let areaForm = HtmlUtils.openTag(TAG_TABLE, [ATTR_CLASS, "display-area"]);
            areaForm += HtmlUtils.tr([],
				     HtmlUtils.td(["align", "center"],
						  HtmlUtils.leftCenterRight("",
									    input(ID_NORTH, " N","North",n),showMap, "20%", "60%", "20%")));

            areaForm += HtmlUtils.tr([], HtmlUtils.td([],
						      input(ID_WEST, " W", "West",w) +
						      input(ID_EAST, " E", "East",e)));

            areaForm += HtmlUtils.tr([],
				     HtmlUtils.td(["align", "center"],
						  HtmlUtils.leftCenterRight("", input(ID_SOUTH,  " S", "South",s), settings, "20%", "60%", "20%")));


            areaForm += HtmlUtils.closeTag(TAG_TABLE);
            areaForm += HU.div([ID,this.display.domId(ID_MAP_POPUP_WRAPPER),STYLE,HU.css("display","none")],SPACE+"Shift-drag: select region. Cmd-drag: move region" +
				HU.div([ID,this.display.domId(ID_MAP_POPUP),STYLE,HU.css("width","400px","height","300px")]));
            return areaForm;
        },
	showMap: function() {
	    let anchor = this.display.jq(ID_MAP_SHOW);
	    this.dialog = HU.makeDialog({contentId:this.display.domId(ID_MAP_POPUP_WRAPPER),anchor:anchor,draggable:true,header:true});
	    this.map.selectionPopupInit();
	    this.map.getMap().updateSize();
	},
        areaClear: function() {
            $("#" + this.display.getDomId(ID_NORTH)).val("");
            $("#" + this.display.getDomId(ID_WEST)).val("");
            $("#" + this.display.getDomId(ID_SOUTH)).val("");
            $("#" + this.display.getDomId(ID_EAST)).val("");
            this.display.areaClear();
        },
        useMyLocation: function() {
            if (navigator.geolocation) {
                let _this = this;
                navigator.geolocation.getCurrentPosition(function(position) {
                    _this.setUseMyLocation(position);
                });
            } else {}
        },
        setUseMyLocation: function(position) {
            let lat = position.coords.latitude;
            let lon = position.coords.longitude;
            let offset = 5.0;
            if (this.display.myLocationOffset)
                offset = parseFloat(this.display.myLocationOffset);

            $("#" + this.display.getDomId(ID_NORTH)).val(lat + offset);
            $("#" + this.display.getDomId(ID_WEST)).val(lon - offset);
            $("#" + this.display.getDomId(ID_SOUTH)).val(lat - offset);
            $("#" + this.display.getDomId(ID_EAST)).val(lon + offset);
            if (this.display.submitSearchForm)
                this.display.submitSearchForm();
        },
        areaLinkClick: function() {
            this.linkArea = !this.linkArea;
            let image = root + (this.linkArea ? "/icons/link.png" : "/icons/link_break.png");
            $("#" + this.display.getDomId(ID_AREA_LINK)).attr("src", image);
            if (this.linkArea && this.lastBounds) {
                let b = this.lastBounds;
                $("#" + this.display.getDomId(ID_NORTH)).val(MapUtils.formatLocationValue(b.top));
                $("#" + this.display.getDomId(ID_WEST)).val(MapUtils.formatLocationValue(b.left));
                $("#" + this.display.getDomId(ID_SOUTH)).val(MapUtils.formatLocationValue(b.bottom));
                $("#" + this.display.getDomId(ID_EAST)).val(MapUtils.formatLocationValue(b.right));
            }
        },
        linkArea: false,
        lastBounds: null,
        handleEventMapBoundsChanged: function(source, args) {
            bounds = args.bounds;
            this.lastBounds = bounds;
            if (!args.force && !this.linkArea) return;
            $("#" + this.display.getDomId(ID_NORTH)).val(MapUtils.formatLocationValue(bounds.top));
            $("#" + this.display.getDomId(ID_WEST)).val(MapUtils.formatLocationValue(bounds.left));
            $("#" + this.display.getDomId(ID_SOUTH)).val(MapUtils.formatLocationValue(bounds.bottom));
            $("#" + this.display.getDomId(ID_EAST)).val(MapUtils.formatLocationValue(bounds.right));
        },
        setSearchSettings: function(settings) {
	    let n = this.display.getFieldValue(this.display.getDomId(ID_NORTH), null);
	    let w = this.display.getFieldValue(this.display.getDomId(ID_WEST), null);	    
	    let s = this.display.getFieldValue(this.display.getDomId(ID_SOUTH), null);
	    let e = this.display.getFieldValue(this.display.getDomId(ID_EAST), null);
            settings.setAreaContains(this.areaContains);
	    HU.addToDocumentUrl("map_contains",this.areaContains);
            settings.setBounds(n,w,s,e);
	    HU.addToDocumentUrl("map_bounds",[n||"",w||"",s||"",e||""].join(","));
        },
    });
}



function DateRangeWidget(display, what) {
    const ID_DATE_START = "date_start";
    const ID_DATE_END = "date_end";
    let startLabel, endLabel;
    this.what = what||"date";
    if(what == "createdate") {
	startLabel = "Create start";
	endLabel = "Create end";	
    } else {
	startLabel = "Start date";
	endLabel = "End date";	
    }

    this.baseId = this.what;
    RamaddaUtil.inherit(this, {
        display: display,
        initHtml: function() {
            $("#" + this.baseId +ID_DATE_START).datepicker({
		dateFormat: "yy-mm-dd"
	    });
            $("#" + this.baseId +ID_DATE_END).datepicker({
		dateFormat: "yy-mm-dd"
	    });	    
        },
        setSearchSettings: function(settings) {
            let start = $("#"+ this.baseId +ID_DATE_START).val();
            let end =  $("#"+ this.baseId +ID_DATE_END).val();
	    HU.addToDocumentUrl(this.baseId+ID_DATE_START,Utils.stringDefined(start)?start:null);
	    HU.addToDocumentUrl(this.baseId+ID_DATE_END,Utils.stringDefined(end)?end:null);		    	    
	    if(this.what=="createdate")
		settings.setCreateDateRange(start, end);
	    else
		settings.setDateRange(start, end);
        },
        getHtml: function() {
	    let start = HU.getUrlArgument(this.baseId+ID_DATE_START);
	    let end = HU.getUrlArgument(this.baseId+ID_DATE_END);	    
            let html = HtmlUtils.input(this.baseId +ID_DATE_START, start||"", [CLASS, "display-date-input", "placeholder", " " +startLabel, TITLE, startLabel, ATTR_ID,
									this.baseId +ID_DATE_START, 
							  ]) + " - " +
                HtmlUtils.input(this.baseId +ID_DATE_END, end||"", [CLASS, "display-date-input", "placeholder",  " " +endLabel, TITLE,endLabel,ATTR_ID,
							       this.baseId +ID_DATE_END, 
						 ]);
            return html;
        }
    });
}



function DisplayAnimation(display, enabled,attrs) {
    let dflt = {
    };
    attrs = attrs||{};
    $.extend(dflt,attrs);
    const ID_RUN = "animrun";
    const ID_NEXT = "animnext";
    const ID_PREV= "animprev";
    const ID_BEGIN= "animbegin";
    const ID_END= "animend";
    const ID_SLIDER = "slider";
    const ID_TICKS = "ticks";
    const ID_TOOLTIP = "tooltip";    
    const ID_SHOWALL = "showall";
    const ID_WINDOW = "window";
    const ID_STEP = "step";        
    const ID_SETTINGS = "settings";
    const ID_FASTER = "faster";
    const ID_SLOWER = "slower";
    const ID_RESET = "reset";    
    const ID_ANIMATION_LABEL = "animationlabel";
    const MODE_FRAME = "frame";
    const MODE_SLIDING = "sliding";
    $.extend(this,{
	display:display,
	enabled: enabled,
	targetDiv:attrs.targetDiv,
	baseDomId:attrs.baseDomId,
	labelSize:display.getProperty("animationLabelSize","12pt"),
	labelStyle:display.getProperty("animationLabelStyle",""),
        running: false,
        inAnimation: false,
        begin: null,
        end: null,
        dateMin: null,
        dateMax: null,
        dateRange: 0,
        dateFormat: display.getProperty("animationDateFormat", display.getProperty("dateFormat", "yyyymmdd")),
        mode: display.getProperty("animationMode", "cumulative"),
        startAtBeginning: display.getProperty("animationStartAtBeginning", true),	
        startAtEnd: display.getProperty("animationStartAtEnd", false),
        speed: parseInt(display.getProperty("animationSpeed", 500)),
        dwell: parseInt(display.getProperty("animationDwell", 1000)),	
	getEnabled: function() {
	    return this.enabled;
	},
        toggleAnimation: function() {
	    this.running = !this.running;
	    if(this.btnRun)
		this.btnRun.html(HtmlUtils.getIconImage(this.running ? "fa-stop" : "fa-play"));
	    if (this.running)
		this.startAnimation();
	},
        getDomId: function(id) {
	    return this.domId(id);
	},
        domId: function(id) {
	    return this.display.getDomId(id+(this.baseDomId?this.baseDomId:""));
	},
	jq: function(id) {
	    return this.display.jq(id+(this.baseDomId?this.baseDomId:""));
	},
	init: function(dateMin, dateMax, records) {
	    let debug = false;
	    if(debug)
		console.log("animation.init:" +dateMin +" " + dateMax +" " +(records?"#records:" + records.length: "no records") );
	    let _this = this;
	    this.records = records;
	    this.dateMin = dateMin;
	    this.dateMax = dateMax;
	    this.begin = this.dateMin;
	    this.end = this.dateMax;
	    if(!this.dateMin) return;
	    this.dates=[];
	    let seen = {};
	    records.every(r=>{
		if(!seen[r.getDate()]) {
		    seen[r.getDate()] = true;
		    this.dates.push(r.getDate());
		}
		return true;
	    });
	    this.dates.sort(function(a,b) {
		return a.getTime() - b.getTime();
	    });
	    
            this.dateRange = this.dateMax.getTime() - this.dateMin.getTime();
	    this.steps= parseFloat(this.display.getProperty("animationSteps", 60));
	    this.setWindow();
	    this.frameIndex = 0;
	    if(!this.display.getProperty("animationStartShowAll",false)) { 
		this.resetRange();
	    }
	    let sliderValues = this.mode != MODE_FRAME?[this.begin.getTime(),this.end.getTime()]:[this.begin.getTime()];
	    let tooltipFunc = {
		    mouseleave: function(e) {
			if(_this.tooltip)
			    _this.tooltip.hide();
		    },
		    mousemove: function(e) {
			if(!_this.tooltip) return;
			if(e.offsetX>=0) {
			    let parentWidth = _this.tooltip.parent().width();
			    let parentLeft = _this.tooltip.parent().offset().left; 
			    let percent = (e.pageX-parentLeft)/parentWidth;
			    let dttm = new Date(_this.dateMin.getTime() + percent*_this.dateRange);
			    dttm = _this.formatAnimationDate(dttm,_this.tooltipDateFormat);
			    if(!_this.makeSlider) {
				dttm+="<br>+/-:zoom";
			    }
			    _this.tooltip.html(dttm);
			    _this.tooltip.show();
			    _this.tooltip.position({
				of: e.target,
				my: "left top",
				at: "left+" + e.offsetX +" bottom",
				collision: "fit fit"
			    });
			}
		    }};

	    if(this.makeSlider) {
		let slider = this.jq(ID_SLIDER).slider({
		    range: _this.mode != MODE_FRAME,
		    min: _this.dateMin.getTime(),
		    max: _this.dateMax.getTime(),
		    values: sliderValues,
		    slide: function( event, ui ) {
			_this.stopAnimation();
			_this.setSliderValues(ui.values);
			_this.updateLabels();
		    },
		    stop: function(event,ui) {
			_this.stopAnimation();
			_this.setSliderValues(ui.values);
			_this.dateRangeChanged(true);
		    }
		});
		this.jq(ID_SLIDER).on(tooltipFunc);
	    } else {
		this.jq(ID_TICKS).on(tooltipFunc);
	    }

	    this.updateTicks();
	    if(debug)console.log("animation.init-3");
	    this.updateLabels();
	    if(debug)console.log("animation.init-done");
	},
	resetRange: function() {
	    if(this.startAtEnd) {
		this.begin = this.dateMax;
		this.end = this.dateMax;
		if (this.mode == MODE_FRAME) {
		    this.frameIndex = this.dates.length-1;
		}		    
	    } else   if(this.startAtBeginning) {
		this.begin = this.dateMin;
		this.end = new Date(this.begin.getTime()+this.window);
	    }
	    if (this.mode == MODE_FRAME) {
		this.end = this.begin;
	    }
	},
	setWindow: function() {
	    let window = this.display.getProperty("animationWindow");
	    let step = this.display.getProperty("animationStep", window);
	    if (window) {
		this.window = this.getMillis(window);
	    } else if(this.steps>0){
		this.window = this.dateRange / this.steps;
	    }
	    if (step) {
		this.step = this.getMillis(step);
	    } else {
		this.step = this.window;
	    }
	},
	timeMap: {
	    century: 1000 * 60 * 60 * 24 * 365 * 100,
	    centuries: 1000 * 60 * 60 * 24 * 365 * 100,	    
	    decade: 1000 * 60 * 60 * 24 * 365 * 10,
	    halfdecade: 1000 * 60 * 60 * 24 * 365 * 5,
	    year: 1000 * 60 * 60 * 24 * 365 * 1,
	    years: 1000 * 60 * 60 * 24 * 365 * 1,	    
	    month: 1000 * 60 * 60 * 24 * 31,
	    months: 1000 * 60 * 60 * 24 * 31,	    
	    week: 1000 * 60 * 60 * 24 * 7,
	    weeks: 1000 * 60 * 60 * 24 * 7,	    
	    day: 1000 * 60 * 60 * 24 * 1,
	    days: 1000 * 60 * 60 * 24 * 1,		    	    
	    hour: 1000 * 60 * 60,
	    hours: 1000 * 60 * 60,
	    minute: 1000 * 60,
	    minutes: 1000 * 60,	    
	    second: 1000,
	    seconds: 1000		    
	},
	getMillis:function(window) {
	    window =(""+window).trim();
	    let cnt = 1;
	    let unit = "day";
	    let toks = window.match("^([0-9]+)(.*)");
	    if(toks) {
		cnt = +toks[1];
		unit  = toks[2].trim();
	    } else {
		toks = window.match("(^[0-9]+)$");
		if(toks) {
		    unit = "minute";
		    cnt = +toks[1];
		} else {
		    unit = window;
		}
	    }
	    let scale = 1;
	    unit = unit.toLowerCase().trim();
	    if(this.timeMap[unit]) {
		scale = this.timeMap[unit];
	    } else {
		if(unit.endsWith("s"))
		    unit = unit.substring(0, unit.length-1);
		if(this.timeMap[unit]) {
		    scale = this.timeMap[unit];
		} else {
		    console.log("Unknown unit:" + unit);
		}
	    }
	    return  cnt*scale;
	},
	getIndex: function() {
	    return this.frameIndex;
	},
	getBeginTime: function() {
	    return this.begin;
	},
	handleEventAnimationChanged(args) {
	    this.begin = args.begin;
	    this.end = args.end;
	    this.stopAnimation();
	    this.applyAnimation();
	},
	setSliderValues: function(v) {
	    let debug = false;
	    if(debug)
		console.log(this.display.type+" animation.setSliderValues");
	    if(this.mode != MODE_FRAME) {
		this.begin = new Date(v[0]);
		this.end = new Date(v[1]);
	    } else {
		let sliderDate = new Date(v[0]);
		let closest = this.dates[0];
		let dist = 0;
		let closestIdx=0;
		this.dates.forEach((d,idx)=>{
		    if(Math.abs(d.getTime()-sliderDate.getTime()) < Math.abs(closest.getTime()-sliderDate.getTime())) {
			closest = d;
			closestIdx = idx;
		    }
		});
		this.begin = this.end = closest;
		this.frameIndex = closestIdx;
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    let element = $("#" + this.display.getId()+"-"+args.record.getId());
	    if(this.ticks)
		this.ticks.removeClass("display-animation-tick-highlight");
	    if(args.highlight) {
		element.addClass("display-animation-tick-highlight");
	    } else {
		element.removeClass("display-animation-tick-highlight");
	    }
	},
	makeControls:function() {
	    this.tickHeight = this.display.getProperty("animationHeight","15px");
	    this.makeSlider = this.display.getProperty("animationMakeSlider",true);
            let buttons =  "";
	    let showButtons  = this.display.getProperty("animationShowButtons",true);
	    let showSlider = display.getProperty("animationShowSlider",true);
	    let showLabel = display.getProperty("animationShowLabel",true);	    
	    if(showButtons) {
		let short = display.getProperty("animationWidgetShort",false);
		buttons +=   HtmlUtils.span([ID, this.getDomId(ID_SETTINGS),TITLE,"Settings"], HtmlUtils.getIconImage("fas fa-cog")); 
		if(!short)
		    buttons +=   HtmlUtils.span([ID, this.getDomId(ID_BEGIN),TITLE,"Go to beginning"], HtmlUtils.getIconImage("fa-fast-backward")); 
		buttons += HtmlUtils.span([ID, this.getDomId(ID_PREV), TITLE,"Previous"], HtmlUtils.getIconImage("fa-step-backward")); 
		if(!short)
		    buttons +=HtmlUtils.span([ID, this.getDomId(ID_RUN),  TITLE,"Run/Stop"], HtmlUtils.getIconImage("fa-play")); 
		buttons +=HtmlUtils.span([ID, this.getDomId(ID_NEXT), TITLE,"Next"], HtmlUtils.getIconImage("fa-step-forward"));
		if(!short)
		    buttons +=HtmlUtils.span([ID, this.getDomId(ID_END), TITLE,"Go to end"], HtmlUtils.getIconImage("fa-fast-forward"));
	    }

	    if(showLabel) {
		if(showButtons) {
		    buttons+=HtmlUtils.span([ID, this.getDomId(ID_ANIMATION_LABEL), CLASS, "display-animation-label",STYLE,this.labelStyle+HU.css("font-size",this.labelSize)]);
		} else {
		    buttons+=HtmlUtils.div([ID, this.getDomId(ID_ANIMATION_LABEL), CLASS, "display-animation-label",STYLE,this.labelStyle+HU.css("text-align","center","font-size",this.labelSize)]);
		}
	    }
            buttons = HtmlUtils.div([ CLASS,"display-animation-buttons"], buttons);
	    if(showSlider) {
		let style= HU.css("height",this.tickHeight) +display.getProperty("animationSliderStyle","");
		let tooltip  = HU.div([ID,this.getDomId(ID_TOOLTIP),CLASS,"display-animation-tooltip"],"");
		let tickContainerStyle = HU.css("height",this.tickHeight);
		if(!this.makeSlider) {
		    tickContainerStyle += HU.css("background","efefef","border","1px solid #aaa");
		}
		if(!this.makeSlider) {
		    style+=HU.css("cursor","move");
		}
		buttons +=   HtmlUtils.div([CLASS,"display-animation-slider",STYLE,style,ID,this.getDomId(ID_SLIDER)],
					   tooltip + HtmlUtils.div([STYLE, tickContainerStyle,CLASS,"display-animation-ticks","tabindex","0",ID,this.getDomId(ID_TICKS)]));
	    }
	    this.html = HtmlUtils.div([STYLE,this.display.getProperty("animationStyle")], buttons);
	    if(this.display.getProperty("animationShow",true)) {
		if(this.targetDiv) this.targetDiv.append(this.html);
		else this.jq(ID_TOP_LEFT).append(this.html);
	    }
	    if(!this.makeSlider) {
		let _this = this;
		this.jq(ID_TICKS).mouseenter(function(event) {
		    $(this).focus();
		});
		this.lastKeyTime = 0;
		let ticks = this.jq(ID_TICKS);
		ticks.mousedown(function(e) {
		    _this.mouseIsDown = true;
		    let parentOffset = $(this).parent().offset(); 
		    _this.mouseX = e.pageX - parentOffset.left;
		});

		ticks.mousemove(function(e) {
		    if(!_this.mouseIsDown) return;
		    var parentOffset = $(this).parent().offset(); 
		    var relX = e.pageX - parentOffset.left;
		    let range = _this.dateMax.getTime() - _this.dateMin.getTime();
		    let width = $(this).width();
		    let dx = (_this.mouseX-relX);
		    var parentOffset = $(this).parent().offset(); 
		    _this.mouseX = e.pageX - parentOffset.left;
		    if(dx==0) return;
		    let dt = range*dx/width 
		    if(!_this.originaDateMin) {
			_this.originaDateMin = _this.dateMin;
			_this.originaDateMax = _this.dateMax;		
		    }
		    _this.dateMin = new Date(_this.dateMin.getTime()+dt);
		    _this.dateMax = new Date(_this.dateMax.getTime()+dt);			
		    let t1 = new Date();
		    _this.updateTicks();
		    let t2 = new Date();
//		    Utils.displayTimes("update ticks",[t1,t2],true);
		    _this.updateLabels();

		});
		ticks.mouseup(function(e) {
		    _this.mouseIsDown = false;
		});
		ticks.keypress(function(event) {
		    let now = new Date();
		    let diff = now.getTime()-_this.lastKeyTime;
		    _this.lastKeyTime = now.getTime();
		    if(event.which==43)
			_this.zoom(true);
		    else if(event.which==45)
			_this.zoom(false);		    
		    else if(event.which==61)
			_this.zoomReset();

		});

		this.jq(ID_TICKS).bind('xwheel', function(e){		    
		    $(this).focus();
		    if(e.originalEvent.deltaY<0) {
			let range = _this.dateMax.getTime() - _this.dateMin.getTime();
			let newRange = range*0.9;
			let diff = range-newRange;
			_this.dateMin = new Date(_this.dateMin.getTime()+diff);
			_this.dateMax = new Date(_this.dateMax.getTime()-diff);			
			_this.updateTicks();
			_this.updateLabels();
		    } else if(e.originalEvent.deltaY>0) {
			//zoom out 
		    } else {
		    }
		    e.stopPropagation();
		    e.stopImmediatePropagation();
		    e.preventDefault();
		});

	    }

	    if(this.display.getProperty("animationTooltipShow",false)) {
		this.tooltip = this.jq(ID_TOOLTIP);
		this.tooltipDateFormat = this.display.getProperty("animationTooltipDateFormat");
	    }


	    let _this  =this;
            this.jq(ID_SETTINGS).button().click(function(){
		let window = _this.display.getProperty("animationWindow");
		let step = _this.display.getProperty("animationStep", window);		
		let clazz = "ramadda-hoverable ramadda-clickable";
		let html = HU.div([ID,_this.domId(ID_FASTER),TITLE, "Faster", CLASS,clazz], "Faster") +	
	    HU.div([ID,_this.domId(ID_SLOWER),TITLE, "Slower", CLASS,clazz], "Slower")		+
		    HU.div([ID,_this.domId(ID_RESET),TITLE, "Reset", CLASS,clazz], "Reset") +
		    HU.div([ID,_this.domId(ID_SHOWALL),TITLE, "Show all", CLASS,clazz], "Show all");
		if(window) {
		    html+=HU.div([TITLE, "Window, e.g., 1 week, 2 months, 3 days, 2 weeks, etc"], "Window:<br>" +SPACE2 + HU.input("",window,[ID,_this.domId(ID_WINDOW),"size","10"]));
		    html+=HU.div([TITLE, "Step, e.g., 1 week, 2 months, 3 days, 2 weeks, etc"], "Step:<br>" +SPACE2+ HU.input("",step,[ID,_this.domId(ID_STEP),"size","10"]));
		}
		html=HU.div([STYLE,HU.css("margin","4px")], html);
		_this.dialog = HU.makeDialog({content:html,anchor:$(this),draggable:false,header:false});

		let key = (e)=>{
		    if(Utils.isReturnKey(e)) {
			_this.dialog.hide();
			_this.display.setProperty("animationWindow",_this.jq(ID_WINDOW).val());
			_this.display.setProperty("animationStep",_this.jq(ID_STEP).val());			
			_this.setWindow();
			_this.resetRange();
			_this.dateRangeChanged();
		    }
		};
		_this.jq(ID_WINDOW).keyup(key);
		_this.jq(ID_STEP).keyup(key);
		_this.jq(ID_FASTER).click(()=>{
		    _this.dialog.hide();
		    _this.speed = _this.speed*0.75;
		});
		_this.jq(ID_SLOWER).click(()=>{
		    _this.dialog.hide();
		    _this.speed = _this.speed*1.5;
		});

		_this.jq(ID_RESET).click(()=>{
		    _this.dialog.hide();
		    _this.speed =  parseInt(_this.display.getProperty("animationSpeed", 500));
		    _this.resetRange();
		    _this.inAnimation = false;
		    _this.stopAnimation();
		    _this.dateRangeChanged();
		});		
		_this.jq(ID_SHOWALL).click(()=>{
		    _this.dialog.hide();
		    _this.begin = _this.dateMin;
		    _this.end = _this.dateMax;
		    _this.inAnimation = false;
		    _this.stopAnimation();
		    _this.dateRangeChanged();
		});		

	    });
            this.btnRun = this.jq(ID_RUN);
            this.btnPrev = this.jq(ID_PREV);
            this.btnNext = this.jq(ID_NEXT);
            this.btnBegin = this.jq(ID_BEGIN);
            this.btnEnd = this.jq(ID_END);
            this.label = this.jq(ID_ANIMATION_LABEL);
            this.btnRun.button().click(() => {
                this.toggleAnimation();
            });
            this.btnBegin.button().click(() => {
		let diff = this.getDiff();
		let fullRange = this.fullRange();
		this.begin = this.dateMin;
		if (this.mode == MODE_SLIDING) {
		    this.end = new Date(this.begin.getTime()+(fullRange?this.window:diff));
		} else if (this.mode == MODE_FRAME) {
		    this.frameIndex = 0;
		    this.begin = this.end = this.deltaFrame(0);
		} else {
		    this.end = new Date(this.dateMin.getTime()+this.window);
		}
		this.stopAnimation();
		this.dateRangeChanged();
            });
            this.btnEnd.button().click(() => {
		let diff = this.getDiff();
		let fullRange = this.fullRange();
		this.end = this.dateMax;
		if (this.mode == MODE_SLIDING) {
		    this.begin = new Date(this.end.getTime()-(fullRange?this.window:diff));
		} else if (this.mode == MODE_FRAME) {
		    this.frameIndex = this.dates.length+1;
		    this.begin = this.end = this.deltaFrame(0);
		} else {
		    this.end =this.dateMax;
		}
		this.stopAnimation();
		this.dateRangeChanged();
            });
            this.btnPrev.button().click(() => {
		this.stopAnimation();
		this.doPrev();
            });
            this.btnNext.button().click(() => {
		this.stopAnimation();
		this.doNext();
            });

        },
	fullRange: function() {
	    return this.atBegin() && this.atEnd();
	},
	atEnd: function() {
	    return this.end.getTime()>=this.dateMax.getTime();
	},
	atBegin: function() {
	    return this.begin.getTime()<=this.dateMin.getTime();
	},	
	getDiff: function() {
	    return  this.end.getTime()-this.begin.getTime();
	},
	doPrev: function()  {
	    let diff = this.getDiff()||this.window;
	    diff = this.window||this.getDiff();
	    if (this.mode == MODE_SLIDING) {
		this.begin = new Date(this.begin.getTime()-diff);
		if(this.begin.getTime()<this.dateMin.getTime())
		    this.begin = this.dateMin;
		this.end = new Date(this.begin.getTime()+diff);
	    } else if (this.mode == MODE_FRAME) {
		this.begin = this.end = this.deltaFrame(-1);
	    } else {
		this.end = new Date(this.end.getTime()-this.window);
		if(this.end.getTime()<=this.begin.getTime()) {
		    this.end = new Date(this.begin.getTime()+this.window);
		}
	    }
	    this.dateRangeChanged();
	},
	doNext: function() {
	    let debug = false;
	    let wasAtEnd = this.atEnd();
	    if(debug) console.log("animation.doNext:" + this.mode +" atEnd=" + wasAtEnd);
	    if (this.mode == MODE_SLIDING) {
		let window = this.window||this.getDiff();
		this.begin = new Date(this.begin.getTime()+this.step);
		this.end = new Date(this.end.getTime()+this.step);
		//this.end.getTime()+this.window);		
		if(this.atEnd()) {
		    this.end = this.dateMax;
		    this.begin = new Date(this.end.getTime()-window);
		    this.inAnimation = false;
		    this.stopAnimation();
		}
	    } else if (this.mode == MODE_FRAME) {
		this.begin = this.end = this.deltaFrame(1);
		if(this.running) {
		    if(wasAtEnd) {
			if(this.display.getProperty("animationLoop",true)) {
			    setTimeout(()=>{
				this.begin = this.end = this.dateMin;
				this.frameIndex=0;
				this.updateUI();
			    },this.dwell);
			    return;
			} else {
			    this.stopAnimation();
			}
		    }
		}
	    } else {
		this.end = new Date(this.end.getTime()+this.window);
		if(this.atEnd()) {
		    this.end = this.dateMax;
		    this.inAnimation = false;
		    this.stopAnimation();
		}
	    }
	    this.dateRangeChanged();
	},
	deltaFrame: function(delta) {
	    this.frameIndex+=delta;
	    if(!this.dates) return;
	    if(this.frameIndex>= this.dates.length)
		this.frameIndex = this.dates.length-1;
	    else if(this.frameIndex<0)
		this.frameIndex = 0;
	    return this.dates[this.frameIndex];
	},
	startAnimation: function() {
            if (!this.dateMax) return;
	    if (!this.inAnimation) {
                this.inAnimation = true;
                this.label.html("");
		if (this.mode == MODE_FRAME) {
		    this.frameIndex =0;
		    this.begin = this.end = this.deltaFrame(0);
		    this.display.animationStart();
		    this.doNext();
		    return;
		}
                if(this.fullRange()) {
		    this.end = new Date(this.begin.getTime()+this.window);
		}
		this.display.animationStart();
            }
	    this.doNext();
        },
	stopAnimation:function() {
	    if(this.btnRun)
		this.btnRun.html(HtmlUtils.getIconImage("fa-play"));
            this.running = false;
	},
	setDateRange: function(begin,end) {
	    this.begin = begin;
	    this.end = end;
	    this.stopAnimation();
	    this.updateUI();
	},
	dateRangeChanged: function(skipSlider) {
	    this.applyAnimation(skipSlider);
	    this.display.getDisplayManager().notifyEvent(DisplayEvent.animationChanged, this.display, {
		begin:this.begin,
		end: this.end
	    });
	},
	applyAnimation: function(skipSlider) {
	    this.display.animationApply(this);
	    this.updateUI();
	},
	setRecordListHighlight: function(recordList) {
	    this.recordListHighlight = recordList;
	    this.updateTicks();
	},
	zoomReset: function() {
	    if(this.originaDateMin) {
		this.dateMax = this.originaDateMax;		
		this.dateMin = this.originaDateMin;
		this.updateTicks();
		this.updateLabels();
	    }
	},
	zoom: function(zoomin) {
	    let range = this.dateMax.getTime() - this.dateMin.getTime();
	    let newRange = range*(zoomin?0.9:1.1);
	    let diff = range-newRange;
	    if(!this.originaDateMin) {
		this.originaDateMin = this.dateMin;
		this.originaDateMax = this.dateMax;		
	    }
	    this.dateMin = new Date(this.dateMin.getTime()+diff);
	    this.dateMax = new Date(this.dateMax.getTime()-diff);			
	    this.updateTicks();
	    this.updateLabels();
	},
	updateTicks: function() {
	    let debug = false;
	    this.tickCount = 0;
	    if(!this.records || !this.display.getProperty("animationShowTicks",true)) return;
	    this.highlightRecords = {};
	    if(this.recordListHighlight) {
		this.recordListHighlight.forEach(r=>{
		    this.highlightRecords[r.getId()] = true;
		});
	    }
	    if(debug)console.log("animation.init making ticks: #records=" + records.length +" date:" + this.dateMin + " " + this.dateMax);
	    let tickStyle = this.display.getProperty("animationTickStyle","");
	    let ticks = "";
	    let min = this.dateMin.getTime();
	    let max = this.dateMax.getTime();
	    let p = 0;
	    let seenDate={};
	    let t1 = new Date();
	    for(let i=0;i<this.records.length;i++) {
		let record = this.records[i];
		let date = record.getDate().getTime();
		if(seenDate[date]) continue;
		seenDate[date] = true;
		if(debug)console.log("\ttick:" + record.getDate());
		if(date<min) continue;
		if(date>max) continue;
		this.tickCount++;
		let perc = (date-min)/(max-min)*100;
		let tt = this.formatAnimationDate(record.getDate());
		let clazz = "display-animation-tick";
		if(this.highlightRecords[record.getId()]) {
		    clazz+=" display-animation-tick-highlight-base ";
		}
		ticks+=HtmlUtils.div([TITLE,"",ID,this.display.getId()+"-"+record.getId(), CLASS,clazz,STYLE,HU.css("height",this.tickHeight,'left', perc+'%')+tickStyle,TITLE,tt,RECORD_ID,record.getId()],"");
	    }
	    let t2 = new Date();
	    this.jq(ID_TICKS).html(ticks);
	    let t3 = new Date();
	    if(debug)console.log("animation.init done making ticks");
	    let propagateHighlight = display.getProperty("animationHighlightRecord",false);
	    let propagateSelect = display.getProperty("animationSelectRecord",true);
	    this.ticks = this.jq(ID_TICKS).find(".display-animation-tick");
	    let _this = this;
	    this.display.makeTooltips(this.ticks, this.records,(open,record) =>{
		if(_this.display.animationLastRecordSelectTime) {
		    let now = new Date();
		    //If we recently selected a recordwith a click then don't do the highlight record from the mouse overs
		    //for a couple more seconds
		    if(now.getTime()-_this.display.animationLastRecordSelectTime.getTime()<1500) {
			return false;
		    }
		}
		if(record && propagateHighlight) {
		    if(propagateSelect) {
			_this.display.propagateEventRecordSelection({select:false,record: null});
		    }
		    this.display.handleEventRecordHighlight(this, {highlight: open,record:record, skipAnimation:true});
		}
		return true;
	    },null,propagateHighlight);
	    if(propagateSelect) {
		this.display.makeRecordSelect(this.ticks,this.display.makeIdToRecords(this.records),record=>{
		    _this.display.animationLastRecordSelectTime = new Date();
		});
	    }

	    let t4 = new Date();
//	    Utils.displayTimes("",[t1,t2,t3,t4],true);
	},
	updateUI: function(skipSlider) {
	    if(!skipSlider) {
		if(this.makeSlider) {
		    this.jq(ID_SLIDER).slider('values',0,this.begin.getTime());
		    this.jq(ID_SLIDER).slider('values',1,this.end.getTime());
		}
	    }
	    this.updateLabels();
            let windowEnd = this.end.getTime();
            if (windowEnd <= this.dateMax.getTime()) {
                if (this.running) {
                    setTimeout(() => {
			if(!this.running) return;
			this.doNext();
		    }, this.speed);
                }
            } else {
                this.running = false;
                this.inAnimation = false;
		if(this.btnRun)
                    this.btnRun.html(HtmlUtils.getIconImage("fa-play"));
            }
	},
	makeLabel: function(label) {
	    return HU.span([STYLE,HU.css("font-size",this.labelSize)+this.labelStyle],label);
	},

	updateLabels: function() {
	    if(this.label) {
		if(!this.makeSlider) {
		    this.label.html(HU.leftCenterRight(this.makeLabel(this.formatAnimationDate(this.dateMin)),this.makeLabel("# " +this.tickCount), this.makeLabel(this.formatAnimationDate(this.dateMax))));
		} else {
		    if (this.mode == MODE_FRAME && this.begin == this.end) {
			this.label.html(this.makeLabel(this.formatAnimationDate(this.begin)));
		    } else {
			this.label.html(this.makeLabel(this.formatAnimationDate(this.begin) + " - " + this.formatAnimationDate(this.end)));
		    }
		}
	    }
	},
        formatAnimationDate: function(date,format,debug) {
	    let timeZoneOffset =this.display.getProperty("timeZoneOffset");
	    let timeZone =this.display.getProperty("timeZone");	    
	    if(timeZoneOffset) {
		if(debug) console.log("date before:" + date.toUTCString());
		date = Utils.createDate(date, -timeZoneOffset);
		if(debug) console.log("date after:" + date.toUTCString());
	    }
	    let fmt =  Utils.formatDateWithFormat(date,format||this.dateFormat,true);
	    if(timeZone) return fmt +" " + timeZone;
	    return fmt;
        },

    });
}



function ColorByInfo(display, fields, records, prop,colorByMapProp, defaultColorTable, propPrefix, theField, props,lastColorBy) {
    this.properties = props || {};
    if(!prop) prop = "colorBy";
    if ( !propPrefix ) {
	propPrefix = ["colorBy",""];
    } else if( !Array.isArray(propPrefix) ) {
	propPrefix = [propPrefix];
    }
    $.extend(this, {
	display:display,
	fieldProp: prop,
	fieldValue:display.getProperty(prop),
	propPrefix: propPrefix,
	colorHistory:{}
    });

    let colorByAttr = this.getProperty(prop||"colorBy", null);
    if(theField==null) {
	if(prop.getId) {
	    theField = prop;
	} else {
	    theField = display.getFieldById(null, colorByAttr);
	}
    }

    if(theField) {
	this.field = theField;
	propPrefix = [theField.getId()+".",""];
	colorByAttr =theField.getId();
	this.propPrefix.unshift(theField.getId()+".colorBy");
	this.propPrefix.push("colorBy");
    }

    $.extend(this, {
	display:display,
        id: colorByAttr,
	fields:fields,
        field: theField,
	colorThresholdField:display.getFieldById(null, display.getProperty("colorThresholdField")),
	aboveColor: display.getProperty("colorThresholdAbove","red"),
	belowColor:display.getProperty("colorThresholdBelow","blue"),
	nullColor:display.getProperty("nullColor"),	
	excludeZero:this.getProperty(PROP_EXCLUDE_ZERO, false),
	overrideRange: this.getProperty("overrideColorRange",false),
	inverse: this.getProperty("Inverse",false),
	origRange:null,
	origMinValue:0,
	origMaxValue:0,
        minValue: 0,
        maxValue: 0,
	toMinValue: 0,
        toMaxValue: 100,
        isString: false,
        stringMap: null,
	colorByMap: {},
	colorByValues:[],
	colorByMinPerc: this.getProperty("MinPercentile", -1),
	colorByMaxPerc: this.getProperty("MaxPercentile", -1),
	colorByOffset: 0,
        pctFields:null,
	compareFields: display.getFieldsByIds(null, this.getProperty("CompareFields", "")),
    });
    //Reuse the last color map if there is one so the string->color stays the same
    if(lastColorBy && !lastColorBy.colorOverflow) {
//	this.lastColorByMap= lastColorBy.colorByMap;
    }
    
    if(this.fieldValue == "year") {
	let seen= {};
	this.dates = [];
	records.forEach(r=>{
	    let year = r.getDate().getUTCFullYear();
	    if(!seen[year]) {
		seen[year] = true;
		this.dates.push(year);
	    }
	});
	this.dates.sort();
	this.setRange(this.dates[0],this.dates[this.dates.length-1]);
    }


    this.convertAlpha = this.getProperty("convertColorAlpha",false);
    if(this.convertAlpha) {
	if(!Utils.isDefined(this.getProperty("alphaSourceMin"))) {
	    var min = 0, max=0;
	    records.forEach((record,idx)=>{
		var tuple = record.getData();
		if(this.compareFields.length>0) {
		    this.compareFields.map((f,idx2)=>{
			var v = tuple[f.getIndex()];
			if(isNaN(v)) return;
			min = idx==0 && idx2==0?v:Math.min(min,v);
			max = idx==0 && idx2==0?v:Math.max(max,v);
		    });
		} else if (this.index=0) {
		    var v = tuple[this.index];
		    if(isNaN(v)) return;
		    min = idx==0?v:Math.min(min,v);
		    max = idx==0?v:Math.max(max,v);
		}
	    });
	    this.alphaSourceMin = min;
	    this.alphaSourceMax = max;
	} else {
	    this.alphaSourceMin = +this.getProperty("alphaSourceMin",40);
	    this.alphaSourceMax = +this.getProperty("alphaSourceMax",80);
	}
	this.alphaTargetMin = +this.getProperty("alphaTargetMin",0); 
	this.alphaTargetMax = +this.getProperty("alphaTargetMax",1); 
    }

    this.convertIntensity = this.getProperty("convertColorIntensity",false);
    if(this.convertIntensity) {
	if(!Utils.isDefined(this.getProperty("intensitySourceMin"))) {
	    var min = 0, max=0;
	    records.forEach((record,idx)=>{
		var tuple = record.getData();
		if(this.compareFields.length>0) {
		    this.compareFields.map((f,idx2)=>{
			var v = tuple[f.getIndex()];
			if(isNaN(v)) return;
			min = idx==0 && idx2==0?v:Math.min(min,v);
			max = idx==0 && idx2==0?v:Math.max(max,v);
		    });
		} else if (this.index=0) {
		    var v = tuple[this.index];
		    if(isNaN(v)) return;
		    min = idx==0?v:Math.min(min,v);
		    max = idx==0?v:Math.max(max,v);
		}
	    });
	    this.intensitySourceMin = min;
	    this.intensitySourceMax = max;
	} else {
	    this.intensitySourceMin = +this.getProperty("intensitySourceMin",80);
	    this.intensitySourceMax = +this.getProperty("intensitySourceMax",40);
	}
	this.intensityTargetMin = +this.getProperty("intensityTargetMin",1); 
	this.intensityTargetMax = +this.getProperty("intensityTargetMax",0); 
    }

    if (this.display.percentFields != null) {
        this.pctFields = this.display.percentFields.split(",");
    }

    let colors = defaultColorTable || this.display.getColorTable(true,[colorByAttr +".colorTable","colorTable"]);
    if(!colors && colorByAttr) {
	let c = this.display.getProperty(colorByAttr +".colors");
	if(c) colors = c.split(",");
    }
    
//    if(!colors && this.hasField()) {
//	colors = this.display.getColorTable(true,"colorTable");
//    }

    if(!colors) {
	var c = this.getProperty(colorByAttr +".colors");
	if(c)
	    colors = c.split(",");
    }


    if(!colors)
	colors = this.display.getColorTable(true);
    this.colors = colors;


    if(this.hasField() && !colors) {
//	this.index = -1;
//	return;
    }



    if (!this.colors && this.display.colors && this.display.colors.length > 0) {
        this.colors = source.colors;
        if (this.colors.length == 1 && Utils.ColorTables[this.colors[0]]) {
            this.colors = Utils.ColorTables[this.colors[0]].colors;
        }
    }

    if (this.colors == null) {
        this.colors = Utils.ColorTables.grayscale.colors;
    }


    if(!this.field) {
	for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            if (field.getId() == this.id || ("#" + (i + 1)) == this.id) {
		this.field = field;
            }
	}
    }

    if(!this.field) {
	if(this.id == "hour")
	    this.timeField="hour";
	else if(this.id == "day")
	    this.timeField="day";	
    }


    if(this.field && this.field.isString()) this.isString = true;
    this.index = this.field != null ? this.field.getIndex() : -1;
    this.stringMap = this.display.getColorByMap(colorByMapProp);
    let uniqueValues = [];
    let seenValue = {};
    if(this.index>=0 || this.timeField) {
	let min = NaN;
	let max = NaN;
	records.forEach((record,idx)=>{
            let tuple = record.getData();
	    let v;
            if(this.timeField) {
		if(this.timeField=="hour")
		    v = record.getTime().getHours();
		else
		    v = record.getTime().getTime();
	    } else {
		v = tuple[this.index];		
	    }
            if (this.isString) {
		if(!seenValue[v]) {
		    seenValue[v] = true;
		    uniqueValues.push(v);
		}
		return;
	    }
            if (this.excludeZero && v === 0) {
		return;
            }
	    min = Utils.min(min,v);
	    max = Utils.max(max,v);
	});
//	console.log("minmax:" + min +" " + max);
	this.minValue =min;
	this.maxValue =max;	
	this.origRange = [min,max];
    }

    if(uniqueValues.length>0) {
	uniqueValues.sort((a,b)=>{
	    return a.toString().localeCompare(b.toString());
	});
	uniqueValues.forEach(v=>{
	    if (!Utils.isDefined(this.colorByMap[v])) {
		let index = this.colorByValues.length;
                let color;
		if(this.lastColorByMap && this.lastColorByMap[v]) {
		    color = this.lastColorByMap[v];
		    //			console.log("\tlast v:" + v +" c:" + color);
		} 	else {
		    if(index>=this.colors.length) {
			this.colorOverflow = true;
			index = index%this.colors.length;
			//			    console.log("\tmod index:" + index +" l:" + this.colors.length);
		    }
		    color = this.colors[index];
		    //			console.log("\tindex:" + index +" v:" + v +" c:" + color);
		}
                this.colorByValues.push({value:v,color:color});
		this.colorByMap[v] = color;
                this.setRange(1,  this.colorByValues.length, true);
	    }
	});
    }

    if (this.display.showPercent) {
        this.setRange(0, 100,true);
    }

    var steps = this.getProperty("Steps");

    if(steps) {
	this.steps = steps.split(",");
    }



    this.colorByLog = this.getProperty("Log", false);
    this.colorByLog10 = this.getProperty("Log10", false);
    this.colorByLog2 = this.getProperty("Log2", false);
    if(this.colorByLog) {
	this.colorByFunc = Math.log;
    }   else if(this.colorByLog10) {
	this.colorByFunc = Math.log10;
    }   else if(this.colorByLog2) {
	this.colorByFunc = Math.log2;
    }

    this.setRange(this.getProperty("Min", this.minValue),
		  this.getProperty("Max", this.maxValue), true);

    this.range = this.maxValue - this.minValue;
    this.toMinValue = this.getProperty("ToMin", this.toMinValue);
    this.toMaxValue = this.getProperty("ToMax", this.toMaxValue);
    this.enabled = this.timeField!=null || (this.getProperty("doColorBy",true) && this.index>=0);
    this.initDisplayCalled = false;
}



ColorByInfo.prototype = {
    initDisplay: function() {
	this.filterHighlight = this.display.getFilterHighlight();
	this.initDisplayCalled = true;
    },
    getProperty: function(prop, dflt, debug) {
	if(this.properties[prop]) return this.properties[prop];
	if(this.debug) console.log("getProperty:" + prop);
	for(let i=0;i<this.propPrefix.length;i++) {
	    this.display.debugGetProperty = debug;
	    if(this.debug) console.log("\t" + this.propPrefix[i]+prop);
	    let v = this.display.getProperty(this.propPrefix[i]+prop);
	    this.display.debugGetProperty = false;
	    if(Utils.isDefined(v)) return v;
	}
	return dflt;
    },
    isEnabled: function() {
	return this.enabled;
    },
    displayColorTable: function(width,force, domId) {
	if(!this.getProperty("showColorTable",true)) return;
	if(this.compareFields.length>0) {
	    var legend = "";
	    this.compareFields.map((f,idx)=>{
		legend += HtmlUtils.div([STYLE,HU.css('display','inline-block','width','15px','height','15px','background', this.colors[idx])]) +" " +
		    f.getLabel() +" ";
	    });
	    let dom = this.display.jq(domId || ID_COLORTABLE);
	    dom.html(HtmlUtils.div([STYLE,HU.css('text-align','center','margin-top','5px')], legend));
	}
	if(!force && this.index<0) return;
	if(this.stringMap) {
	    let colors = [];
	    this.colorByValues= [];
	    for (var i in this.stringMap) {
		let color = this.stringMap[i];
		this.colorByValues.push({value:i,color:color});
		colors.push(color);
	    }
	    this.display.displayColorTable(colors, domId || ID_COLORTABLE, this.origMinValue, this.origMaxValue, {
		field: this.field,
		colorByInfo:this,
		width:width,
		stringValues: this.colorByValues});
	} else {
	    let colors = this.colors;
	    if(this.getProperty("clipColorTable",true) && this.colorByValues.length) {
		var tmp = [];
		for(var i=0;i<this.colorByValues.length && i<colors.length;i++) 
		    tmp.push(this.colors[i]);
		colors = tmp;
	    }
	    let cbs = this.colorByValues.map(v=>{return v;});
	    cbs.sort((a,b)=>{
		return a.value.toString().localeCompare(b.value.toString());
	    });
	    this.display.displayColorTable(colors, domId || ID_COLORTABLE, this.origMinValue, this.origMaxValue, {
		field: this.field,
		colorByInfo:this,
		width:width,
		stringValues: cbs
	    });
	}
    },
    resetRange: function() {
	if(this.origRange) {
	    this.setRange(this.origRange[0],this.origRange[1]);
	}
    },
    setRange: function(minValue,maxValue, force) {
//	console.log(" setRange: min:" + minValue + " max:" + maxValue);
	if(!force && this.overrideRange) return;
	this.origMinValue = minValue;
	this.origMaxValue = maxValue;
	if (this.colorByFunc) {
	    if (minValue < 0) {
		this.colorByOffset =  -minValue;
	    } else if(minValue == 0) {
		this.colorByOffset =  1;
	    }
//	    if(minValue>0)
		minValue = this.colorByFunc(minValue + this.colorByOffset);
//	    if(maxValue>0)
		maxValue = this.colorByFunc(maxValue + this.colorByOffset);
	}
	this.minValue = minValue;
	this.maxValue = maxValue;
	this.range = maxValue - minValue;
	if(!this.origRange) {
	    this.origRange = [minValue, maxValue];
	}
//	console.log("min/max:" + this.minValue +" " + this.maxValue);
    },
    getValuePercent: function(v) {
	let perc =   (v - this.minValue) / this.range;
	if(this.inverse) perc = 1-perc;
	return perc;
    },
    scaleToValue: function(v) {
	let perc = this.getValuePercent(v);
	return this.toMinValue + (perc*(this.toMaxValue-this.toMinValue));
    },
    getColorFromRecord: function(record, dflt, checkHistory) {
	if(!this.initDisplayCalled)   this.initDisplay();

	if(this.filterHighlight && !record.isHighlight(this.display)) {
	    return this.display.getProperty("unhighlightColor","#eee");
	}

	if(this.colorThresholdField && this.display.selectedRecord) {
	    let v=this.display.selectedRecord.getValue(this.colorThresholdField.getIndex());
	    let v2=record.getValue(this.colorThresholdField.getIndex());
	    if(v2>v) return this.aboveColor;
	    else return this.belowColor;
	}

	if (this.index >= 0) {
	    let value = record.getData()[this.index];
	    return  this.getColor(value, record,checkHistory);
	} else if(this.timeField) {
	    let value;
	    if(this.timeField=="hour") {
		value = record.getTime().getHours();
	    }  else {
		value = record.getTime().getTime();
	    }
//	    console.log(value);
	    return  this.getColor(value, record,checkHistory);
	} 
	if(this.fieldValue == "year") {
	    let value = record.getDate().getUTCFullYear();
	    return this.getColor(value, record);
	}
	return dflt;
    },
    hasField: function() {
	return this.index>=0;
    },
    getColor: function(value, pointRecord, checkHistory) {
//	if(checkHistory) {
//	    if(this.colorHistory[value]) return this.colorHistory[value];
//	}
	let c = this.getColorInner(value, pointRecord);
	if(c==null) c=this.nullColor;
//	if(checkHistory) {
//	    this.colorHistory[value] = c;
//	}
	return c;
    },

    getColorInner: function(value, pointRecord) {
	if(!this.initDisplayCalled)   this.initDisplay();

	if(this.filterHighlight && pointRecord && !pointRecord.isHighlight(this.display)) {
	    return this.display.getUnhighlightColor();
	}

	let percent = 0.5;
        if (this.showPercent) {
            let total = 0;
            let data = pointRecord.getData();
            for (let j = 0; j < data.length; j++) {
                let ok = this.fields[j].isNumeric() && !this.fields[j].isFieldGeo();
                if (ok && this.pctFields != null) {
                    ok = this.pctFields.indexOf(this.fields[j].getId()) >= 0 ||
                        this.pctFields.indexOf("#" + (j + 1)) >= 0;
                }
                if (ok) {
                    total += data[j];
                }
            }
            if (total != 0) {
                percent =  value / total * 100;
                percent = (percent - this.minValue) / (this.maxValue - this.minValue);
            }
        } else {
            let v = value;
	    if(this.stringMap) {
		let color = this.stringMap[value];
		if(!Utils.isDefined(color)) {
		    return this.stringMap["default"];
		}
		return color;
	    }
            if (this.isString) {
                color = this.colorByMap[v];
		if(color) return color;
            }
	    let tmp = v;
            v += this.colorByOffset;
            if (this.colorByFunc && v>0) {
                v = this.colorByFunc(v);
            }
            percent = this.range?(v - this.minValue) / this.range:0.5;
//	    if(tmp>3 && tmp<6)
//		console.log("ov:" + tmp  +" v:" + v + " perc:" + percent);
        }


	let index=0;
	if(this.steps) {
	    for(;index<this.steps.length;index++) {
		if(value<=this.steps[index]) {
		    break;
		}
	    }
	} else {
	    index = parseInt(percent * this.colors.length);
	}
//	console.log("v:" + value +" index:" + index +" colors:" + this.colors);
        if (index >= this.colors.length) index = this.colors.length - 1;
        else if (index < 0) index = 0;
	if(this.stringMap) {
	    let color = this.stringMap[value];
	    if(!Utils.isDefined(color)) {
		return this.stringMap["default"];
	    }
	    return color;
	} else {
	    return this.colors[index];
	}
	return null;
    },
    convertColor: function(color, colorByValue) {
	color = this.convertColorIntensity(color, colorByValue);
	color = this.convertColorAlpha(color, colorByValue);
	return color;
    },
    convertColorIntensity: function(color, colorByValue) {
	if(!this.convertIntensity) return color;
	percent = (colorByValue-this.intensitySourceMin)/(this.intensitySourceMax-this.intensitySourceMin);
	intensity=this.intensityTargetMin+percent*(this.intensityTargetMax-this.intensityTargetMin);
	let result =  Utils.pSBC(intensity,color);
	//		    console.log(color +" " + result +" intensity:" + intensity +" min:" + this.intensityTargetM
	return result || color;
    },
    convertColorAlpha: function(color, colorByValue) {
	if(!this.convertAlpha) return color;
	percent = (colorByValue-this.alphaSourceMin)/(this.alphaSourceMax-this.alphaSourceMin);
	alpha=this.alphaTargetMin+percent*(this.alphaTargetMax-this.alphaTargetMin);
	let result =  Utils.addAlphaToColor(color, alpha);
	return result || color;
    }
}

function drawSparkLine(display, dom,w,h,data, records,min,max,colorBy,attrs, margin) {
    if(!attrs) attrs = {};
    if(!margin)
	margin = { top: 0, right: 0, bottom: 0, left: 0 };
    const INNER_WIDTH  = w - margin.left - margin.right;
    const INNER_HEIGHT = h - margin.top - margin.bottom;
    const BAR_WIDTH  = w / data.length;
    const x    = d3.scaleLinear().domain([0, data.length]).range([0, INNER_WIDTH]);
    const y    = d3.scaleLinear().domain([min, max]).range([INNER_HEIGHT, 0]);
    const recty    = d3.scaleLinear().domain([min, max]).range([0,INNER_HEIGHT]);

    let tt = d3.select("body").append("div")	
	.attr(CLASS, "sparkline-tooltip")				
	.style("opacity", 0);

    const svg = d3.select(dom).append('svg')
	  .attr('width', w)
	  .attr('height', h)
	  .append('g')
	  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
    const line = d3.line()
	  .x((d, i) => x(i))
	  .y(d => y(d));

    let lineColor = attrs.lineColor||display.getProperty("sparklineLineColor","#000");
    let barColor = attrs.barColor ||display.getProperty("sparklineBarColor","MediumSeaGreen");	    
    let circleColor = attrs.circleColor ||display.getProperty("sparklineCircleColor","#000");
    let circleRadius = attrs.circleRadius ||display.getProperty("sparklineCircleRadius",1);
    let lineWidth = attrs.lineWidth ||display.getProperty("sparklineLineWidth",1);
    let defaultShowEndPoints = true;
    let getColor = (d,i,dflt)=>{
	return colorBy?colorBy.getColorFromRecord(records[i], dflt):dflt;
    };
    let showBars = attrs.showBars|| display.getProperty("sparklineShowBars",false);

    

    svg.append('line')
	.attr('x1',0)
	.attr('y1', 0)
	.attr('x2', 0)
	.attr('y2', h)    
	.attr("stroke-width", 1)
    	.attr("stroke", '#ccc');

    svg.append('line')
	.attr('x1',0)
	.attr('y1', h)
	.attr('x2', w)
	.attr('y2', h)    
	.attr("stroke-width", 1)
    	.attr("stroke", '#ccc');
    



    let getNum = n=>{
	if(isNaN(n)) return 0;
	return n;
    };

    if(showBars) {
	defaultShowEndPoints = false;
	svg.selectAll('.bar').data(data)
	    .enter()
	    .append('rect')
	    .attr('class', 'bar')
	    .attr('x', (d, i) => getNum(x(i)))
	    .attr('y', d => getNum(y(d)))
	    .attr('width', BAR_WIDTH)
	    .attr('height', d => getNum(h-y(d)))
	    .attr('fill', (d,i)=>getColor(d,i,barColor))
	    .style("cursor", "pointer")
    }


    if(attrs.showLines|| display.getProperty("sparklineShowLines",true)) {
	svg.selectAll('line').data(data).enter().append("line")
	    .attr('x1', (d,i)=>{return x(i)})
	    .attr('y1', (d,i)=>{return y(d)})
	    .attr('x2', (d,i)=>{return x(i+1)})
	    .attr('y2', (d,i)=>{return y(i<data.length-1?data[i+1]:data[i])})
	    .attr("stroke-width", lineWidth)
            .attr("stroke", (d,i)=>{
		if(isNaN(d)) return "rgba(0,0,0,0)";
		return getColor(d,i,lineColor)
	    })
	    .style("cursor", "pointer");
    }


    if(attrs.showCircles || display.getProperty("sparklineShowCircles",false)) {
	svg.selectAll('circle').data(data).enter().append("circle")
	    .attr('r', (d,i)=>{return isNaN(d)?0:circleRadius})
	    .attr('cx', (d,i)=>{return getNum(x(i))})
	    .attr('cy', (d,i)=>{return getNum(y(d))})
	    .attr('fill', (d,i)=>getColor(d,i,circleColor))
	    .style("cursor", "pointer");
    }



    if(attrs.showEndpoints || display.getProperty("sparklineShowEndPoints",defaultShowEndPoints)) {
	let fidx=0;
	while(isNaN(data[fidx]) && fidx<data.length) fidx++;
	let lidx=data.length-1;
	while(isNaN(data[lidx]) && lidx>=0) lidx--;	
	svg.append('circle')
	    .attr('r', attrs.endPointRadius|| display.getProperty("sparklineEndPointRadius",2))
	    .attr('cx', x(fidx))
	    .attr('cy', y(data[fidx]))
	    .attr('fill', attrs.endPoint1Color || display.getProperty("sparklineEndPoint1Color") || getColor(data[0],0,display.getProperty("sparklineEndPoint1Color",'steelblue')));
	svg.append('circle')
	    .attr('r', attrs.endPointRadius|| display.getProperty("sparklineEndPointRadius",2))
	    .attr('cx', x(lidx))
	    .attr('cy', y(data[lidx]))
	    .attr('fill', attrs.endPoint2Color || display.getProperty("sparklineEndPoint2Color")|| getColor(data[data.length-1],data.length-1,display.getProperty("sparklineEndPoint2Color",'tomato')));
    }
    let _display = display;
    let doTooltip = display.getProperty("sparklineDoTooltip", true)  || attrs.doTooltip;
    svg.on("click", function() {
	let coords = d3.mouse(this);
	if(records) {
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(record)
		_display.propagateEventRecordSelection({select:true,record: record});
	}
    });



    if(doTooltip) {
	svg.on("mouseover", function() {
	    if(!records) return;
	    let coords = d3.mouse(this);
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(!record) return;
	    let html = _display.getRecordHtml(record);
	    let ele = $(dom);
	    let offset = ele.offset().top + ele.height();
	    let left = ele.offset().left;
	    tt.transition().duration(200).style("opacity", .9);		
	    tt.html(html)
		.style("left", left + "px")		
		.style("top", offset + "px");	
	})
	    .on("mouseout", function(d) {		
		tt.transition()		
		    .duration(500)		
		    .style("opacity", 0);
	    });
    }
}



function drawDots(display, dom,w,h,data, range, colorBy,attrs, margin) {
    attrs = attrs ||  {};
    margin = margin || { top: 0, right: 0, bottom: 0, left: 0 };
    const INNER_WIDTH  = w - margin.left - margin.right;
    const INNER_HEIGHT = h - margin.top - margin.bottom;
    const x    = d3.scaleLinear().domain([range.minx, range.maxx]).range([0, INNER_WIDTH]);
    const y    = d3.scaleLinear().domain([range.miny, range.maxy]).range([INNER_HEIGHT, 0]);
    let tt = d3.select("body").append("div").attr(CLASS, "sparkline-tooltip").style("opacity", 0);
    const svg = d3.select(dom).append('svg')
	  .attr('width', w)
	  .attr('height', h)
	  .append('g')
//	  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    let circleColor = attrs.circleColor ||display.getProperty("sparklineCircleColor","#000");
    let circleRadius = attrs.circleRadius ||display.getProperty("sparklineCircleRadius",1);
    let getColor = (d,i,dflt)=>{
	return "#000"
//	return colorBy?colorBy.getColorFromRecord(records[i], dflt):dflt;
    };
    console.log(JSON.stringify(range));

    let getNum = n=>{
	if(isNaN(n)) return 0;
	return n;
    };

    
    let recordMap = {};
    
    svg.selectAll('circle').data(data).enter().append("circle")
	.attr('r', (d,i)=>{return circleRadius})
	.attr('cx', (d,i)=>{return getNum(x(d.x))})
	.attr('cy', (d,i)=>{return getNum(y(d.y))})
	.attr('fill', (d,i)=>{return getColor(d,i,circleColor)})
	.attr(RECORD_ID, (d,i)=>{
	    recordMap[d.record.getId()] =d.record;
	    return d.record.getId()})
	.style("cursor", "pointer");

    let _display = display;
    let doTooltip = display.getProperty("sparklineDoTooltip", true)  || attrs.doTooltip;
    svg.on("click", function() {
	let coords = d3.mouse(this);
	if(records) {
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(record)
		_display.propagateEventRecordSelection({select:true,record: record});
	}
    });


    if(doTooltip) {
	svg.on("mouseover", function() {
	    d3.select(this).attr("r", 10).style("fill", "red");
	    let ele = $(dom);
	    ele.attr('r', 20);
	    console.log("mouse over:" + d3.select(this).attr(RECORD_ID));
	    if(true) return
	    let record = recordMap[ele.attr(RECORD_ID)];
	    console.log(ele.attr(RECORD_ID) +" " + record);
	    let coords = d3.mouse(this);
	    if(!record) return;
	    let html = _display.getRecordHtml(record);
	    let offset = ele.offset().top + ele.height();
	    let left = ele.offset().left;
	    tt.transition().duration(200).style("opacity", .9);		
	    tt.html(html)
		.style("left", left + "px")		
		.style("top", offset + "px");	
	})
	    .on("mouseout", function(d) {		
		tt.transition()		
		    .duration(500)		
		    .style("opacity", 0);
	    });
    }
}




function drawPieChart(display, dom,width,height,array,min,max,colorBy,attrs) {
    if(!attrs) attrs = {};
    let margin = Utils.isDefined(attrs.margin)?attrs.margin:4;
    let colors = attrs.pieColors||Utils.ColorTables.cats.colors;

    let radius = Math.min(width, height) / 2 - margin
    let svg = d3.select(dom)
	.append("svg")
	.attr("width", width)
	.attr("height", height)
	.append("g")
	.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    let data = {};
    array.forEach(tuple=>{
	data[tuple[0]] = tuple[1];
    })

    // set the color scale
    let color = d3.scaleOrdinal()
	.domain(data)
	.range(colors)

    // Compute the position of each group on the pie:
    let pie = d3.pie()
	.value(function(d) {return d.value; })
    let data_ready = pie(d3.entries(data))

    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svg
	.selectAll('whatever')
	.data(data_ready)
	.enter()
	.append('path')
	.attr('d', d3.arc()
	      .innerRadius(0)
	      .outerRadius(radius)
	     )
	.attr('fill', function(d){ return(color(d.data.key)) })
	.attr("stroke", "black")
	.style("stroke-width", "1px")
	.style("opacity", 0.7)
}


function SizeBy(display,records,fieldProperty) {
    this.display = display;
    if(!records) records = display.filterData();
    let pointData = this.display.getPointData();
    let fields = pointData.getRecordFields();
    $.extend(this, {
        id: this.display.getProperty(fieldProperty|| "sizeBy"),
        minValue: 0,
        maxValue: 0,
        field: null,
        index: -1,
        isString: false,
        stringMap: {},
    });


    let sizeByMap = this.display.getProperty("sizeByMap");
    if (sizeByMap) {
        let toks = sizeByMap.split(",");
        for (let i = 0; i < toks.length; i++) {
            let toks2 = toks[i].split(":");
            if (toks2.length > 1) {
                this.stringMap[toks2[0]] = toks2[1];
            }
        }
    }

    for (let i = 0; i < fields.length; i++) {
        let field = fields[i];
        if (field.getId() == this.id || ("#" + (i + 1)) == this.id) {
            this.field = field;
	    if (field.isString()) this.isString = true;
        }
    }

    this.index = this.field != null ? this.field.getIndex() : -1;
    if (!this.isString && this.field) {
	let col = this.display.getColumnValues(records, this.field);
	this.minValue = col.min;
	this.maxValue =  col.max;
	if(Utils.isDefined(this.display.getProperty("sizeByMin"))) {
	    this.minValue = +this.display.getProperty("sizeByMin",0)
	}
	if(Utils.isDefined(this.display.getProperty("sizeByMax"))) {
	    this.maxValue = +this.display.getProperty("sizeByMax",0)
	}
    }

    if(this.display.getProperty("sizeBySteps")) {
	this.steps = [];
	this.display.getProperty("sizeBySteps").split(",").forEach(tuple=>{
	    let [value,size] = tuple.split(":");
	    this.steps.push({value:+value,size:+size});
	});
    }
    this.radiusMin = parseFloat(this.display.getProperty("sizeByRadiusMin", -1));
    this.radiusMax = parseFloat(this.display.getProperty("sizeByRadiusMax", -1));
    this.offset = 0;
    this.sizeByLog = this.display.getProperty("sizeByLog", false);
    this.origMinValue =   this.minValue;
    this.origMaxValue =   this.maxValue; 

    this.maxValue = Math.max(this.minValue,this.maxValue);
    if (this.sizeByLog) {
	this.func = Math.log;
        if (this.minValue < 1) {
            this.offset = 1 - this.minValue;
        }
        this.minValue = this.func(this.minValue + this.offset);
        this.maxValue = this.func(this.maxValue + this.offset);
    }
}

SizeBy.prototype = {
    getMaxSize:function() {
	return this.getSizeFromValue(this.origMaxValue);
    },
    getSize: function(values, dflt, func) {
        if (this.index <= 0) {
	    return dflt;
	}
        let value = values[this.index];
	let size = this.getSizeFromValue(value,func,false);
	return size;
    },

    getSizeFromValue: function(value,func, debug) {	
	if(this.steps) {
	    if(value<=this.steps[0].value) return this.steps[0].size;
	    for(let i=1;i<this.steps.length;i++) {
		if(value>this.steps[i-1].value && value<=this.steps[i].value ) return this.steps[i].size;
	    }
	    return this.steps[this.steps.length-1].size;
	}
        if (this.isString) {
	    let size;
            if (Utils.isDefined(this.stringMap[value])) {
                let v = parseInt(this.stringMap[value]);
                size = v;
            } else if (Utils.isDefined(this.stringMap["*"])) {
                let v = parseInt(this.stringMap["*"]);
                size = v;
            } 
	    if(isNaN(size)) size =  this.radiusMin;
	    if(func) func(NaN,size);
	    return size;
        } else {
            let denom = this.maxValue - this.minValue;
            let v = value + this.offset;
            if (this.func) v = this.func(v);
            let percent = (denom == 0 ? NaN : (v - this.minValue) / denom);
	    let size;
            if (this.radiusMax >= 0 && this.radiusMin >= 0) {
                size =  Math.round(this.radiusMin + percent * (this.radiusMax - this.radiusMin));
            } else {
                size = 6 + parseInt(15 * percent);
            }
	    if(debug) console.log("min:" + this.minValue +" max:" + this.maxValue+ " value:" + value +" percent:" + percent +" v:" + v +" size:" + size);
	    if(isNaN(size)) size =  this.radiusMin;
	    if(func) func(percent, size);
	    return size;
        }
    },
    getLegend: function(cnt,bg,vert) {
	let html = "";
	if(this.index<0) return "";
	if(this.steps) {
	    this.steps.forEach(step=>{
		let dim = step.size*2+"px";
		let v = step.value;
		html += HU.div([CLASS,"display-size-legend-item"], HU.center(HU.div([STYLE,HU.css("height", dim,"width",dim,
												  "background-color",bg||"#bbb",
												  "border-radius","50%"
												 )])) + v);

		if(vert) html+="<br>";
	    });
	} else {
	    for(let i=0;i<=cnt;i++) {
		let v = this.origMinValue+ i/cnt*(this.origMaxValue-this.origMinValue);
		let size  =this.getSizeFromValue(v,null,false);
		if(isNaN(size) || size==0) continue;
		v = this.display.formatNumber(v);
		let dim = size*2+"px";
		html += HU.div([CLASS,"display-size-legend-item"], HU.center(HU.div([STYLE,HU.css("height", dim,"width",dim,
												  "background-color",bg||"#bbb",
												  "border-radius","50%"
												 )])) + v);

		if(vert) html+="<br>";
	    }
	}
	return HU.div([CLASS,"display-size-legend"], html);
    }

}


function Annotations(display,records) {
    this.display = display;
    if(!records) records = this.display.filterData();
    let pointData = this.display.getPointData();
    let fields = pointData.getRecordFields();
    this.labelField = this.display.getFieldById(null,this.display.getProperty("annotationLabelField"));
    this.fields = this.display.getFieldsByIds(null,this.display.getProperty("annotationFields"));
    let prop = this.display.getProperty("annotations");
    if(prop) this.fields = [];
    this.map = {}
    let add = (record,index,annotation)=>{
	annotation.record = record;
	if(!this.map[index])
	    this.map[index] = [];
	this.map[index].push(annotation);
	if(!this.map[record.getId()])
	    this.map[record.getId()] = [];
	this.map[record.getId()].push(annotation);	
    }
    if(prop) {
	this.annotations=[];
	this.legend = "";
	let labelCnt = 0;
	let toks = prop.split(";");
	this.hasRange = false;
	for(let i=0;i<toks.length;i++) {
	    let toks2 = toks[i].split(",");
	    //index,label,description,url
	    if(toks2.length<2) continue;
	    let index = toks2[0].trim();
	    let label = toks2[1];
	    if(label.trim() == "") {
		labelCnt++;
		label  =""+labelCnt;
	    }
	    let desc = toks2.length<2?"":toks2[2];
	    let url = toks2.length<3?null:toks2[3];
	    let isDate = false;
	    let annotation = {label: label,description: desc,toString:function() {return this.label+" " + this.description;}   };
	    this.annotations.push(annotation);
	    if(index.match(/^[0-9]+$/)) {
		index = parseFloat(index);
	    } else {
		let index2 = null;
		if(index.indexOf(":")>=0) {
		    index2 = index.split(":")[1];
		    index = index.split(":")[0];
		}
		let desc2=null;
		
		if(index=="today") {
		    index = new Date();
		} else {
		    index = Utils.parseDate(index,false);
		}
		if(index2) {
		    this.hasRange = true;
 		    if(index2=="today") {
			index2 = Utils.formatDateYYYYMMDD(new Date());
		    } else {
			index2 = Utils.parseDate(index2,false);
		    }
		    desc  = desc||(this.display.formatDate(index)+"-"+ this.display.formatDate(index2));
		    annotation.index2 = index2.getTime();
		} else {
		    desc  = desc||this.display.formatDate(index)
		}
		isDate = true;
	    }
	    annotation.index = isDate?index.getTime():index;
	    let legendLabel = desc;

	    if(url!=null) {
		legendLabel = HU.href(url, legendLabel,["target","_annotation"]);
	    }
	    this.legend+= HU.b(label)+":" + legendLabel+" ";
	}
	for(let aidx=0;aidx<this.annotations.length;aidx++) {
	    let annotation = this.annotations[aidx];
	    let minIndex = null;
	    let minRecord = null;
	    let minDistance = null;
	    for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
		let ele = records[rowIdx];
		let record = ele.record?ele.record:ele;
		let row = this.display.getDataValues(records[rowIdx]);
		let index = row[0];
		if(index.v) index=  index.v;
		if(record) index = record.getTime();
		let distance =  Number.MAX_VALUE;
		if(annotation.index2) {
		    //range
 		    if(index>=annotation.index && index<=annotation.index2) {
			distance = 0;
		    } else {
			distance = Math.min(Math.abs(annotation.index-index),Math.abs(annotation.index2-index));
		    }
		    if(distance==0) {
			add(record,rowIdx,annotation);
		    }
		} else {
		    distance = Math.abs(annotation.index-index);
		}
		if(minIndex == null) {
		    minIndex = rowIdx;
		    minDistance = distance;
		    minRecord = record;
		} else {
		    if(distance<minDistance) {
			minIndex = rowIdx;
			minDistance = distance;
			minRecord = record;
		    }
		}
	    }
	    if(minIndex!=null) {
		add(minRecord,minIndex,annotation);

	    }
	}
    }
}

Annotations.prototype = {
    isEnabled: function() {
	return this.annotations!=null;
    },
    getAnnotations: function() {
	return this.annotations;
    },

    getAnnotationsFor: function(rowIdx) {
	return this.map[rowIdx];
    },
    getAnnotationFromDate: function(date) {
	let distance =  Number.MAX_VALUE;
	let minAnnotation = null;
	let minDistance = null;
	let time = date.getTime();
	for(let aidx=0;aidx<this.annotations.length;aidx++) {
	    let annotation = this.annotations[aidx];
	    if(annotation.index2) {
 		if(time>=annotation.index && time<=annotation.index2) {
		    return annotation;
		}
	    } else {
		distance = Math.abs(annotation.index-time);
		if(minAnnotation == null) {
		    minAnnotation = annotation;
		    minDistance = distance;
		} else {
		    if(distance<minDistance) {
			minAnnotation = annotation;
			minDistance = distance;
		    }
		}
	    }
	}
	return minAnnotation;
    },
    getLegend: function() {
	return this.legend;
    },
    getShowLegend: function() {
	return 	this.display.getProperty("showAnnotationsLegend");
    },
    hasFields: function() {
	return this.fields && this.fields.length>0;
    },
    getFields: function() {
	return this.fields;
    }
    

}



let Gfx = {
    gridData: function(gridId,fields, records,args) {
	if(!args) args = {};
	if(isNaN(args.cellSize) || args.cellSize == null)
	    args.cellSize = args.cellSizeX;

	if(isNaN(args.cellSizeX) || args.cellSizeX == null)
	    args.cellSizeX= args.cellSize;
	if(isNaN(args.cellSizeY) || args.cellSizeY == null)
	    args.cellSizeY= args.cellSizeX;
	let opts = {
	    shape:"circle",
	    color:"blue",
	    w:800,
	    h:400,
	    scale:1,
	    cellSize:2,
	    cellSizeX:2,
	    cellSizeY:2,
	    operator:"average"
	}
	$.extend(opts,args);
	//	console.log(JSON.stringify(opts,null,2));
	let id = HtmlUtils.getUniqueId();
	opts.scale=+opts.scale;
	let scale = opts.scale;
//	scale=1;
	opts.w*=opts.scale;
	opts.h*=opts.scale;
	$(document.body).append('<canvas style="display:none;" id="' + id +'" width="' + opts.w+'" height="' + opts.h +'"></canvas>');
	let canvas = document.getElementById(id);
	let ctx = canvas.getContext("2d");
	//	ctx.strokeStyle= "#000";
//	ctx.fillStyle= "rgba(255,0,0,0.25)";	
//	ctx.fillRect(0,0,canvas.width,canvas.height);

	let cnt = 0;
	let earthWidth = args.bounds.east-args.bounds.west;
	let earthHeight= args.bounds.north-args.bounds.south;
	ctx.font = opts.cellFont || "8pt Arial;"
	let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
	gradient.addColorStop(0,'white');
	gradient.addColorStop(1,'red');

	let scaleX = (lat,lon)=>{
	    return Math.floor(opts.w*(lon-args.bounds.west)/earthWidth);
	};
	let scaleY;
	if(opts.display && opts.display.map) {
	    //Get the global bounds so we can map down to the image
	    let n1 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,85));
	    let s1 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,-85));
	    let n2 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,opts.bounds.north));
	    let s2 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,opts.bounds.south));
//	    console.log("n1:" + n1 +" s2:" + s1 +" n2:" + n2 +" s2:" + s2 +" bounds:" + JSON.stringify(opts.bounds));
	    scaleY = (lat,lon)=> {
		let pt = opts.display.map.transformLLPoint(MapUtils.createLonLat(lon,lat));
		let dy = n2.lat-pt.lat;
		let perc = dy/(n2.lat-s2.lat)
		return Math.floor(perc*opts.h);
	    };
	} else {
	    scaleY= (lat,lon)=> {
		return Math.floor(opts.h*(args.bounds.north-lat)/earthHeight);		
	    }
	}
	ctx.lineStyle = "#000";
	if(opts.doHeatmap) {
	    let cols = Math.floor(opts.w/opts.cellSizeX);
	    let rows = Math.floor(opts.h/opts.cellSizeY);
	    let points = [];
	    records.forEach((record,idx)=>{
		let lat = record.getLatitude();
		let lon = record.getLongitude();
		let x = scaleX(lat,lon);
		let y = scaleY(lat,lon);
//		console.log("x:" + x +" " + y +" lat:" + lat +" " + lon);
		record[gridId+"_coordinates"] = {x:x,y:y};
		let colorValue = 0;
		if(opts.colorBy && opts.colorBy.index>=0) {
		    colorValue = record.getValue(opts.colorBy.index);
		}
		let lengthValue = 0;
		if(opts.lengthBy && opts.lengthBy.index>=0) {
		    lengthValue = record.getValue(opts.lengthBy.index);
		}		
		x =Math.floor(x/opts.cellSizeX);
		y =Math.floor(y/opts.cellSizeY);
		if(x<0) x=0;
		if(y<0) y=0;
		if(x>=cols) x=cols-1;
		if(y>=rows) y=rows-1;
		points.push({x:x,y:y,colorValue:colorValue,r:record});
//		console.log(x+" " + y +" " + colorValue);
	    });


	    let grid = Gfx.gridPoints(rows,cols,points,args);
	    opts.cellSizeX = +opts.cellSizeX;
	    opts.cellSizeY = +opts.cellSizeY;
	    this.applyFilter(opts,grid);
	    //get the new min/max from the filtered grid
	    let mm = this.getMinMaxGrid(grid,v=>v.v);
	    if(opts.colorBy) {
		if(!Utils.isDefined(opts.display.getProperty("colorByMin")))  {
		    opts.colorBy.setRange(mm.min,mm.max);
		}  
		opts.colorBy.index=0;
	    }

	    let countThreshold = opts.display.getProperty("hmCountThreshold",opts.operator=="count"?1:0);
	    let glyph = new Glyph(opts.display,
				  scale,
				  fields,
				  records,
				  {type:"rect",
				   canvasWidth:canvas.width,
				   canvasHeight: canvas.height,
				   colorByInfo:opts.colorBy,
				   width: opts.cellSizeX,
				   height: opts.cellSizeY,
				   stroke:false,
				   pos:"c",
				   dx:opts.cellSizeX/2,
				   dy:opts.cellSizeY/2,				   
				  },
				  "");
	    opts.shape = "rect";
	    for(let rowIdx=0;rowIdx<rows;rowIdx++)  {
		let row = grid[rowIdx];
		for(let colIdx=0;colIdx<cols;colIdx++)  {
		    let cell = row[colIdx];
		    let v = cell.v;
		    if(isNaN(v)) continue;
		    let x = colIdx*opts.cellSizeX;
		    let y = rowIdx*opts.cellSizeY;
		    if(cell.count>=countThreshold)
			glyph.draw(opts, canvas, ctx, x,y,{
			    colorValue:cell.v,
			    col:colIdx,row:rowIdx,cell:cell, grid:grid});
		}
	    }
	} else {
	    records.sort((a,b)=>{return b.getLatitude()-a.getLatitude()});
	    let glyphs=[];
	    let cnt = 1;
	    while(cnt<11) {
		let attr = opts.display.getProperty("glyph" + (cnt++));
		if(!attr)
		    continue;
		glyphs.push(new Glyph(opts.display,scale, fields,records,{
		    canvasWidth:canvas.width,
		    canvasHeight: canvas.height
		},attr));
	    }
	    glyphs.forEach(glyph=>{
		records.forEach((record,idx)=>{
		    let lat = record.getLatitude();
		    let lon = record.getLongitude();
		    let x = scaleX(lat,lon);
		    let y = scaleY(lat,lon);
		    record[gridId+"_coordinates"] = {x:x,y:y};
		    let colorValue = opts.colorBy? record.getData()[opts.colorBy.index]:null;
		    let lengthValue = opts.lengthBy? record.getData()[opts.lengthBy.index]:null;
		    glyph.draw(opts, canvas, ctx, x,y,{colorValue:colorValue, lengthValue:lengthValue,record:record},idx<10);
		});
	    });
	}

	let alpha = opts.display.getProperty("colorTableAlpha",-1);
	//add in the color table alpha
	if(alpha>0) {
	    let image = ctx.getImageData(0, 0, opts.w, opts.h);
	    let imageData = image.data,
		length = imageData.length;
	    for(let i=3; i < length; i+=4){  
		if(imageData[i]) {
		    imageData[i] = alpha*255;
		}
	    }
	    image.data = imageData;
	    ctx.putImageData(image, 0, 0);
	}

	let img =  canvas.toDataURL("image/png");
	canvas.parentNode.removeChild(canvas);
	return img;
    },
    gridPoints: function(rows,cols,points,args) {
	let debug = displayDebug.gridPoints;
	let values = [];
	for(let rowIdx=0;rowIdx<rows;rowIdx++)  {
	    let row = [];
	    values.push(row);
	    for(let colIdx=0;colIdx<cols;colIdx++)  {
		row.push({v:NaN,count:0,total:0,min:NaN,max:NaN,t:""});
	    }
	}

	points.forEach((p,idx)=>{
	    let cell = values[p.y][p.x];
	    cell.min = cell.count==0?p.colorValue:Math.min(cell.min,p.colorValue);
	    cell.max = cell.count==0?p.colorValue:Math.max(cell.max,p.colorValue);
	    cell.count++;
	    cell.total += p.colorValue;
	});


	let minValue = NaN;
	let maxValue = NaN;
	let maxCount=0;
	let minCount=0;

	for(let rowIdx=0;rowIdx<rows;rowIdx++)  {
	    for(let colIdx=0;colIdx<cols;colIdx++)  {
		let cell = values[rowIdx][colIdx];
		if(cell.count==0) continue;
		let v;
		if(args.operator=="count")
		    v = cell.count;
		else if(args.operator=="min")
		    v =  cell.min;
		else if(args.operator=="max")
		    v =  cell.max;
		else if(args.operator=="total")
		    v =  cell.total;
		else
		    v =  cell.total/cell.count;
		cell.v = v;
		if(!isNaN(v)) {
		    minValue = isNaN(minValue)?v:Math.min(minValue,v);
		    maxValue = isNaN(maxValue)?v:Math.max(maxValue,v);
		}
		maxCount = Math.max(maxCount, cell.count);
		minCount = minCount==0?cell.count:Math.min(minCount, cell.count);
	    }
	}	
	if(debug)
	    console.log("operator:" + args.operator +" values:" + minValue +" - " + maxValue +" counts:" + minCount +" - " + maxCount);
	values.minValue = minValue;
	values.maxValue = maxValue;
	values.minCount = minCount;
	values.maxCount = maxCount;
	return values;
    },


    
    //This gets the value at row/col if its defined. else 0
    //    sum+=this.getGridValue(src,rowIdx,colIdx,t[0],t[1],t[2],cnt); 
    getGridValue:function(src,row,col,mult,total,goodones) {
	if(row>=0 && row<src.length && col>=0 && col<src[row].length) {
	    if(isNaN(src[row][col])) return 0;
	    total[0]+=mult;
	    goodones[0]++;
	    return src[row][col]*mult;
	}
	return 0;
    },
    applyKernel: function(src, kernel) {
	let result = this.cloneGrid(src,null,0);
	for(let rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = result[rowIdx];
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		//		if(isNaN(row[colIdx])) continue;
		if(isNaN(row[colIdx])) row[colIdx] = 0;
		let total =[0];
		let goodones =[0];
		let sum = 0;
		kernel.every(t=>{
		    sum+=this.getGridValue(src,rowIdx+t[0],colIdx+t[1],t[2],total,goodones); 
		    return true;
		});
		if(goodones[0]>0)
		    row[colIdx] = sum/total[0];
		else
		    row[colIdx] = NaN;
	    }
	}
	return result;
    },
    blurGrid: function(type, src) {
	let kernels = {
	    average5: [
		[0,1,0],
		[1,1,1],
		[0,1,0],
	    ],
	    average9: [
		[1,1,1],
		[1,1,1],
		[1,1,1],
	    ],
	    average25:[
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
	    ],
	    average49:[
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
	    ],
	    gauss9:[
		[0.077847,0.123317,0.077847],
		[0.123317,0.195346,0.123317],
		[0.077847,0.123317,0.077847]
	    ],
	    gauss25:[
		[0.003765,0.015019,0.023792,0.015019,0.003765],
		[0.015019,0.059912,0.094907,0.059912,0.015019],
		[0.023792,0.094907,0.150342,0.094907,0.023792],
		[0.015019,0.059912,0.094907,0.059912,0.015019],
		[0.003765,0.015019,0.023792,0.015019,0.003765],
	    ],
	    gauss49: [
		[0.00000067 ,0.00002292 ,0.00019117 ,0.00038771 ,0.00019117 ,0.00002292 ,0.00000067],
		[0.00002292 ,0.00078633 ,0.00655965 ,0.01330373 ,0.00655965 ,0.00078633 ,0.00002292],
		[0.00019117 ,0.00655965 ,0.05472157 ,0.11098164 ,0.05472157 ,0.00655965 ,0.00019117],
		[0.00038771 ,0.01330373 ,0.11098164 ,0.22508352 ,0.11098164 ,0.01330373 ,0.00038771],
		[0.00019117 ,0.00655965 ,0.05472157 ,0.11098164 ,0.05472157 ,0.00655965 ,0.00019117],
		[0.00002292 ,0.00078633 ,0.00655965 ,0.01330373 ,0.00655965 ,0.00078633 ,0.00002292],
		[0.00000067 ,0.00002292 ,0.00019117 ,0.00038771 ,0.00019117 ,0.00002292 ,0.00000067]
	    ]
	}
	let a = kernels[type];
	if(!a) {
	    if(type.startsWith("average"))
		a=kernels.average5;
	    else if(type.startsWith("gauss"))
		a=kernels.gauss9;
	}
	if(!a) return src;
	return this.applyKernel(src, this.makeKernel(a));
    },
    makeKernel: function(kernel) {
	let a = [];
	let mid = (kernel.length-1)/2;
	for(let rowIdx=0;rowIdx<kernel.length;rowIdx++) {
	    let row = kernel[rowIdx];
	    let rowOffset = rowIdx-mid;
	    for(let colIdx=0;colIdx<row.length;colIdx++) {
		let colOffset = colIdx-mid;
		a.push([rowOffset,colOffset,kernel[rowIdx][colIdx]]);
	    }
	}
	return a;
    },
    printGrid: function(grid) {
	console.log("grid:");
	for(let rowIdx=0;rowIdx<grid.length;rowIdx++)  {
	    let row = grid[rowIdx];
	    let h = "";
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		if(Utils.isDefined(row[colIdx].v))
		    h+=row[colIdx].v+",";
		else
		    h+=row[colIdx]+",";
	    }
	    console.log(h);
	}
    },
    applyFilter(opts, grid) {
	if(!opts.filter || opts.filter=="" || opts.filter=="none") {
	    return;
	}

	let copy = this.cloneGrid(grid,v=>v.v);
	let filtered = copy;
	let filterPasses = opts.display.getProperty("hmFilterPasses",1);
	for(let i=0;i<filterPasses;i++) {
	    filtered = this.blurGrid(opts.filter,filtered);
	}
	let filterThreshold = opts.display.getProperty("hmFilterThreshold",-999);
	for(let rowIdx=0;rowIdx<grid.length;rowIdx++)  {
	    let row = grid[rowIdx];
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		let cell = row[colIdx];
		let filterValue = filtered[rowIdx][colIdx];
		if(filterThreshold!=-999) {
		    if(filterValue<filterThreshold)
			filterValue = cell.v;
		}
		cell.v = filterValue;
	    }
	}
    },
    getMinMaxGrid: function(src,valueGetter) {
	let min = NaN;
	let max = NaN;
	for(let rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = src[rowIdx];
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		let v = row[colIdx]
		if(valueGetter) v = valueGetter(v,rowIdx,colIdx);
		if(isNaN(v)) continue;
		min = isNaN(min)?v:Math.min(min,v);
		max = isNaN(max)?v:Math.max(max,v);
	    }
	}
	return {min:min,max:max};
    },



    cloneGrid: function(src,valueGetter,dflt) {
	let dest = [];
	let hasDflt = Utils.isDefined(dflt);
	for(let rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = src[rowIdx];
	    let nrow=[];
	    dest.push(nrow);
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		let v = row[colIdx]
		if(valueGetter) v = valueGetter(v,rowIdx,colIdx);
		if(hasDflt)
		    nrow.push(dflt);
		else
		    nrow.push(v);
	    }
	}
	return dest;
    },
    convertGeoToPixel:function(lat, lon,bounds,mapWidth,mapHeight) {
	let mapLonLeft = bounds.west;
	let mapLonRight = bounds.east;
	let mapLonDelta = mapLonRight - mapLonLeft;
	let mapLatBottom = bounds.south;
	let mapLatBottomDegree = mapLatBottom * Math.PI / 180;
	let x = (lon - mapLonLeft) * (mapWidth / mapLonDelta);
	lat = lat * Math.PI / 180;
	let worldMapWidth = ((mapWidth / mapLonDelta) * 360) / (2 * Math.PI);
	let mapOffsetY = (worldMapWidth / 2 * Math.log((1 + Math.sin(mapLatBottomDegree)) / (1 - Math.sin(mapLatBottomDegree))));
	let y = mapHeight - ((worldMapWidth / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat)))) - mapOffsetY);
	return [x, y];
    },
}


function Glyph(display, scale, fields, records, args, attrs) {
    args = args||{};
    $.extend(this,{
	display: display,
	type:"label",
	dx:0,
	dy:0,
	label:"",
	baseHeight:0,
	baseWidth:0,
	width:8,
	fill:true,
	stroke:true,
	toString: function() {
	    return this.type;
	}
    });
    $.extend(this,args);
    attrs.split(",").forEach(attr=>{
	let toks = attr.split(":");
	let name = toks[0];
	let value="";
	for(let i=1;i<toks.length;i++) {
	    if(i>1) value+=":";
	    value+=toks[i];
	}
	value = value.replace(/_nl_/g,"\n").replace(/_colon_/g,":").replace(/_comma_/g,",");
	if(value=="true") value=true;
	else if(value=="false") value=false;
	this[name] = value;
//	console.log("attr:" + name+"=" + value);
    });

    if(this.labelBy) {
	this.labelField=display.getFieldById(fields,this.labelBy);
	if(!this.labelField) {
	    console.log("Could not find label field: " + this.labelBy);
	}
    }

    if(this.type=="image") {
	this.imageField=display.getFieldById(fields,this.imageField);
	this.myImage= new Image();
    }
    this.scale = scale;
    if(this.height==null) {
	if(this.type == "3dbar")
	    this.height=20;
	else
	    this.height=8;
    }
    if(this.pos==null) {
	if(this.type == "3dbar")
	    this.color = "blue";
	else if(this.type == "rect") {
	    this.pos = "c";
	}
	else
	    this.pos = "nw";
    }	
    
    this.width = (+this.width);
    this.height = (+this.height);
    if(this.dx=="canvasWidth") this.dx=this.canvasWidth;
    else if(this.dx=="-canvasWidth") this.dx=-this.canvasWidth;
    else if(this.dx=="canvasWidth2") this.dx=this.canvasWidth/2;
    else if(this.dx=="-canvasWidth2") this.dx=-this.canvasWidth/2;    
    else if(this.dx=="width") this.dx=this.width;
    else if(this.dx=="-width") this.dx=-this.width;
    else if(this.dx=="width2") this.dx=this.width/2;
    else if(this.dx=="-width2") this.dx=-this.width/2;
    if(this.dy=="canvasHeight") this.dy=this.canvasHeight;
    else if(this.dy=="-canvasHeight") this.dy=-this.canvasHeight;
    else if(this.dy=="canvasHeight2") this.dy=this.canvasHeight/2;
    else if(this.dy=="-canvasHeight2") this.dy=-this.canvasHeight/2;    
    else if(this.dy=="height") this.dy=this.height;
    else if(this.dy=="-height") this.dy=-this.height;
    else if(this.dy=="height2") this.dy=this.height/2;
    else if(this.dy=="-height2") this.dy=-this.height/2;

    this.baseWidth = +this.baseWidth;
    this.width = (+this.width)*scale;
    this.height = (+this.height)*scale;
    this.dx = (+this.dx)*scale;
    this.dy = (+this.dy)*scale;
    if(this.sizeBy) {
	this.sizeByField=display.getFieldById(fields,this.sizeBy);
	if(!this.sizeByField) {
	    console.log("Could not find sizeBy field:" + this.sizeBy);
	} else  {
	    let props = {
		Min:this.sizeByMin,
		Max:this.sizeByMax,
	    };
	    this.sizeByInfo =  new ColorByInfo(display, fields, records, this.sizeBy,this.sizeBy, null, this.sizeBy,this.sizeByField,props);
	}
    }
    if(!this.colorByInfo && this.colorBy) {
	this.colorByField=display.getFieldById(fields,this.colorBy);
	let ct = this.colorTable?display.getColorTableInner(true, this.colorTable):null;
	if(!this.colorByField) {
	    console.log("Could not find colorBy field:" + this.colorBy);
	} else {
	    let props = {
		Min:this.colorByMin,
		Max:this.colorByMax,
	    };	    
	    this.colorByInfo =  new ColorByInfo(display, fields, records, this.colorBy,this.colorBy+".colorByMap", ct, this.colorBy,this.colorByField, props);
	}
    }


}







Glyph.prototype = {
    draw: function(opts, canvas, ctx, x,y,args,debug) {
	let color =   null;
	if(this.colorByInfo) {
	    if(this.colorByField) {
		let v = args.record.getValue(this.colorByField.getIndex());
		color=  this.colorByInfo.getColor(v);
	    } else if(args.colorValue) {
		color=  this.colorByInfo.getColor(args.colorValue);
	    }
	}
	let lengthPercent = 1.0;
	if(this.sizeByInfo) {
	    let v = args.record.getValue(this.sizeByField.getIndex());
	    lengthPercent = this.sizeByInfo.getValuePercent(v);
	}

	if(args.alphaByCount && args.cell && args.grid) {
	    if(args.grid.maxCount!=args.grid.minCount) {
		let countPerc = (args.cell.count-args.grid.minCount)/(args.grid.maxCount-args.grid.minCount);
		color = Utils.addAlphaToColor(c,countPerc);
	    }
	}
	ctx.fillStyle =color || this.fillStyle || this.color || "blue";
	ctx.strokeStyle =this.strokeStyle || this.color || "#000";
	ctx.lineWidth=this.lineWidth||1;
	if(this.type=="label" || this.label) {
	    let label = this.labelField?args.record.getValue(this.labelField.getIndex()):this.label;
	    if(label===null) {
		console.log("No label value");
		return;
	    }
	    if(typeof label=="number") {
		if(this.valueScale) {
		    label = label* +this.valueScale;
		}

		if(this.decimals)
		    label = number_format(label,+this.decimals);
	    }
	    if(this.template) {
		label = this.template.replace("${value}",label);
	    }
	    ctx.font = this.font || "12pt arial"
	    ctx.fillStyle = ctx.strokeStyle =    color || this.color|| "#000";
	    let text = String(label);
	    if(args.record) {
		args.record.fields.forEach(f=>{
		    text = text.replace("\${" + f.getId()+"}",args.record.getValue(f.getIndex()));
		});
	    }
	    text = text.split("\n");
	    let h = 0;
	    let hgap = 3;
	    let maxw = 0;
	    text.forEach((t,idx)=>{
		let dim = ctx.measureText(t);
		if(idx>0) h+=hgap;
		maxw=Math.max(maxw,dim.width);
		h +=dim.actualBoundingBoxAscent+dim.actualBoundingBoxDescent;
	    });
	    let pt = Utils.translatePoint(x, y, maxw,  h, this.pos,{dx:this.dx,dy:this.dy});
	    text.forEach(t=>{
		let dim = ctx.measureText(t);
//		console.log(pt.x +" " + pt.y +" " + t);
		ctx.fillText(t,pt.x,pt.y);
		pt.y += dim.actualBoundingBoxAscent + dim.actualBoundingBoxDescent + hgap;
	    });
	} else 	if(this.type == "circle") {
	    /*
	    ctx.beginPath();
	    ctx.moveTo(0,y);
	    ctx.lineTo(100,y);
	    ctx.stroke();
	    ctx.moveTo(x,0);
	    ctx.lineTo(x,100);
	    ctx.stroke();
	    */
	    ctx.beginPath();
	    let w = this.width*lengthPercent+ this.baseWidth;
//	    this.dx=0; 
//	    this.dy=-50;
//	    this.pos="n"; 
	    let pt = Utils.translatePoint(x, y, w,  w, this.pos,{dx:this.dx,dy:this.dy});
	    let cx = pt.x+w/2;
	    let cy = pt.y+w/2;
	    ctx.arc(cx,cy, w/2, 0, 2 * Math.PI);
//	    console.log(pt.x +" " + pt.y +" " + cx +" " + cy  +" " + this.width);
	    if(this.fill)  {
		ctx.fill();
	    }
	    if(this.stroke) 
		ctx.stroke();
	} else if(this.type=="rect") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    if(this.fill)  
		ctx.fillRect(pt.x,pt.y, this.width, this.height);
	    if(this.stroke) 
		ctx.strokeRect(pt.x,pt.y, this.width, this.height);
	} else if(this.type=="image") {
	    if(this.imageField) {
		let img = args.record.getValue(this.imageField.getIndex());
		let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
		let i = new Image();
		i.src = img;
		setTimeout(()=>{
		    ctx.drawImage(i,pt.x,pt.y,40,40);
		},1000);
//		ctx.drawImage(this.myImage,pt.x,pt.y);
//		ctx.drawImage(this.myImage,0,0);
	    }
	} else 	if(this.type == "gauge") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    ctx.fillStyle =  this.fillColor || "#F7F7F7";
	    ctx.beginPath();
	    let cx= pt.x+this.width/2;
	    let cy = pt.y+this.height;
	    ctx.arc(cx,cy, this.width/2,  1 * Math.PI,0);
	    ctx.fill();
	    ctx.strokeStyle =   "#000";
	    ctx.stroke();
	    ctx.beginPath();
//	    ctx.moveTo(cx-this.width/2,cy);
//	    ctx.lineTo(cx+this.width/2,cy);
//	    ctx.stroke();

	    ctx.beginPath();
	    let length = this.width/2*0.75;
            let degrees = (180*lengthPercent);
	    let ex = cx-this.width*0.4;
	    let ey = cy;
	    let ep = Utils.rotate(cx,cy,ex,ey,degrees);
	    ctx.strokeStyle =  this.color || "#000";
	    ctx.lineWidth=this.lineWidth||2;
	    ctx.moveTo(cx,cy);
	    ctx.lineTo(ep.x,ep.y);
	    ctx.stroke();
	    ctx.lineWidth=1;
	    this.showLabel = true;
	    if(this.showLabel && this.sizeByInfo) {
		ctx.fillStyle="#000";
		let label = String(this.sizeByInfo.minValue);
		ctx.font = this.font || "9pt arial"
		let dim = ctx.measureText(label);
		ctx.fillText(label,cx-this.width/2-dim.width-2,cy);
		ctx.fillText(this.sizeByInfo.maxValue,cx+this.width/2+2,cy);
	    }
	} else if(this.type=="3dbar") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    let height = lengthPercent*(this.height) + parseFloat(this.baseHeight);
	    ctx.fillStyle =   color || this.color;
	    ctx.strokeStyle = this.strokeStyle||"#000";
	    this.draw3DRect(canvas,ctx,pt.x, 
			    canvas.height-pt.y-this.height,
			    +this.width,height,+this.width);
	    
	} else if(this.type=="axis") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    let height = lengthPercent*(this.height) + parseFloat(this.baseHeight);
	    ctx.strokeStyle = this.strokeStyle||"#000";
	    ctx.beginPath();
	    ctx.moveTo(pt.x,pt.y);
	    ctx.lineTo(pt.x,pt.y+this.height);
	    ctx.lineTo(pt.x+this.width,pt.y+this.height);
	    ctx.stroke();
//	    this.draw3DRect(canvas,ctx,x+this.dx, canvas.height-y-this.dy,+this.width,height,+this.width);	    
	} else if(this.type == "vector") {
	    if(!this.sizeByInfo) {
		console.log("make Vector: no sizeByInfo");
		return;
	    }
	    ctx.strokeStyle =   color || this.color;
	    let v = args.record.getValue(this.sizeByField.getIndex());
	    lengthPercent = this.sizeByInfo.getValuePercent(v);
	    let length = opts.cellSizeH;
	    if(opts.lengthBy && opts.lengthBy.index>=0) {
		length = opts.lengthBy.scaleToValue(v);
	    }
	    let x2=x+length;
	    let y2=y;
	    let arrowLength = opts.display.getProperty("arrowLength",-1);
	    /*
	      if(opts.angleBy && opts.angleBy.index>=0) {
	      let perc = opts.angleBy.getValuePercent(v);
	      let degrees = (360*perc);
	      let rads = degrees * (Math.PI/360);
	      x2 = length*Math.cos(rads)-0* Math.sin(rads);
	      y2 = 0*Math.cos(rads)-length* Math.sin(rads);
	      x2+=x;
	      y2+=y;
	      }
	    */
	    if(opts.colorBy && opts.colorBy.index>=0) {
                let perc = opts.colorBy.getValuePercent(v);
                let degrees = (180*perc)+90;
		degrees = degrees*(Math.PI / 360)
                x2 = length*Math.cos(degrees)-0* Math.sin(degrees);
		y2 = 0*Math.cos(degrees)-length* Math.sin(degrees);
                x2+=x;
                y2+=y;
            }
	    //Draw the circle if no arrow
	    if(arrowLength<=0) {
		ctx.save();
		ctx.fillStyle="#000";
		ctx.beginPath();
		ctx.arc(x,y, 1, 0, 2 * Math.PI);
		ctx.fill();
		ctx.restore();
	    }
	    ctx.beginPath();
	    ctx.moveTo(x,y);
	    ctx.lineTo(x2,y2);
	    ctx.lineWidth=opts.display.getProperty("lineWidth",1);
	    ctx.stroke();
	    if(arrowLength>0) {
		ctx.beginPath();
		this.drawArrow(ctx, x,y,x2,y2,arrowLength);
		ctx.stroke();
	    }
	} else if(this.type=="tile"){
	    let crx = x+opts.cellSizeX/2;
	    let cry = y+opts.cellSizeY/2;
 	    if((args.row%2)==0)  {
		crx = crx+opts.cellSizeX/2;
		cry = cry-opts.cellSizeY/2;
	    }
	    let sizex = opts.cellSizeX/2;
	    let sizey = opts.cellSizeY/2;
	    ctx.beginPath();
	    let quarter = Math.PI/2;
	    ctx.moveTo(crx + sizex * Math.cos(quarter), cry + sizey * Math.sin(quarter));
	    for (let side=0; side < 7; side++) {
		ctx.lineTo(crx + sizex * Math.cos(quarter+side * 2 * Math.PI / 6), cry + sizey * Math.sin(quarter+side * 2 * Math.PI / 6));
	    }
	    ctx.strokeStyle = "#000";
	    //	    ctx.fill();
	    ctx.stroke();
	} else {
	    console.log("Unknwon cell shape:" + this.type);
	}
    },
    draw3DRect:function(canvas,ctx,x,y,width, height, depth) {
	// Dimetric projection functions
	let dimetricTx = function(x,y,z) { return x + z/2; };
	let dimetricTy = function(x,y,z) { return y + z/4; };
	
	// Isometric projection functions
	let isometricTx = function(x,y,z) { return (x -z) * Math.cos(Math.PI/6); };
	let isometricTy = function(x,y,z) { return y + (x+z) * Math.sin(Math.PI/6); };
	
	let drawPoly = (function(ctx,tx,ty) {
	    return function() {
		let args = Array.prototype.slice.call(arguments, 0);
		// Begin the path
		ctx.beginPath();
		// Move to the first point
		let p = args.pop();
		if(p) {
		    ctx.moveTo(tx.apply(undefined, p), ty.apply(undefined, p));
		}
		// Draw to the next point
		while((p = args.pop()) !== undefined) {
		    ctx.lineTo(tx.apply(undefined, p), ty.apply(undefined, p));
		}
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
	    };
	})(ctx, dimetricTx, dimetricTy);
	
	// Set some context
	ctx.save();
	ctx.scale(1,-1);
	ctx.translate(0,-canvas.height);
	ctx.save();
	
	// Move our graph
	ctx.translate(x,y);  
	// Draw the "container"
	//back
	let  baseColor = ctx.fillStyle;
	//		drawPoly([0,0,depth],[0,height,depth],[width,height,depth],[width,0,depth]);
	//left
	//		drawPoly([0,0,0],[0,0,depth],[0,height,depth],[0,height,0]);
	//right
	ctx.fillStyle =    Utils.pSBC(-0.5,baseColor);
	drawPoly([width,0,0],[width,0,depth],[width,height,depth],[width,height,0]);
	ctx.fillStyle =    baseColor;
	//front
	drawPoly([0,0,0],[0,height,0],[width,height,0],[width,0,0]);
	//top		
	ctx.fillStyle =    Utils.pSBC(0.5,baseColor);
	drawPoly([0,height,0],[0,height,depth],[width,height,depth],[width,height,0]);
	ctx.fillStyle =    baseColor;
	ctx.restore();
	ctx.restore();
    },

    drawArrow:function(context, fromx, fromy, tox, toy,headlen) {
	let dx = tox - fromx;
	let dy = toy - fromy;
	let angle = Math.atan2(dy, dx);
	context.moveTo(fromx, fromy);
	context.lineTo(tox, toy);
	context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
	context.moveTo(tox, toy);
	context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
    },

}
/**
   Copyright 2008-2021 Geode Systems LLC
*/



var xcnt=0;

const displayDebug = {
    getProperty:false,
    notifyEvent:false,
    handleEventPropertyChanged:false,
    getSelectedFields:false,
    filterData:false,
    getStandardData:false,
    makeDataTable:false,
    checkSearchBar:false,
    handleNoData:false,
    pointDataLoaded:false,
    displayMapUpdateUI:false,
    displayMapCreateMap:false,
    displayMapAddPoints:false,
    loadPointJson:false,
    groupBy:false,
    gridPoints:false,
    setEntry:false

}


const CATEGORY_CHARTS = "Basic Charts";
const CATEGORY_TABLE = "Tables";
const CATEGORY_MISC = "Misc Charts";
const CATEGORY_MAPS = "Maps";
const CATEGORY_IMAGES = "Images";
const CATEGORY_RADIAL_ETC = "Trees, etc";
const CATEGORY_TEXT = "Text";
const CATEGORY_ENTRIES = "Entries";
const CATEGORY_CONTROLS = "Controls";
const DISPLAY_CATEGORIES = [CATEGORY_CHARTS,CATEGORY_TABLE,CATEGORY_MAPS,CATEGORY_IMAGES,CATEGORY_MISC,CATEGORY_TEXT,CATEGORY_RADIAL_ETC,CATEGORY_CONTROLS,CATEGORY_ENTRIES];



//Ids of DOM components
const ID_BOTTOM = "bottom";
const ID_COLORTABLE = "colortable";
const ID_LEGEND = "legend";
const ID_FIELDS = "fields";
const ID_HEADER = "header";
const ID_HEADER1 = "header1";
const ID_HEADER2 = "header2";
const ID_HEADER2_PREFIX = "header2prefix";
const ID_HEADER2_PREPREFIX = "header2preprefix";
const ID_HEADER2_PREPREPREFIX = "header2prepreprefix";
const ID_HEADER2_SUFFIX = "header2suffix";
const ID_FILTERBAR = "filterbar";
const ID_TAGBAR = "tagbar";
const ID_TITLE = ATTR_TITLE;
const ID_TITLE_EDIT = "title_edit";
const ID_LEFT = "left";
const ID_RIGHT = "right";
const ID_TITLE_FIELD="titlefield";
const ID_TOP = "top";
const ID_TOP_RIGHT = "topright";
const ID_TOP_LEFT = "topleft";
const ID_DETAILS = "details";
const ID_DETAILS_SNIPPET = "snippet";
const ID_DISPLAY_CONTENTS = "contents";
const ID_DISPLAY_TOP = "top";
const ID_DISPLAY_BOTTOM = "bottom";
const ID_GROUP_CONTENTS = "group_contents";
const ID_DETAILS_MAIN = "detailsmain";
const ID_GROUPBY_FIELDS= "groupdbyfields";
const ID_TOOLBAR = "toolbar";
const ID_TOOLBAR_INNER = "toolbarinner";
const ID_LIST = "list";
const ID_DISPLAY_MESSAGE = "displaymessage";
const ID_DIALOG = "dialog";
const ID_DIALOG_TABS = "dialog_tabs";
const ID_FOOTER = "footer";
const ID_FOOTER_LEFT = "footer_left";
const ID_FOOTER_RIGHT = "footer_right";
const ID_MENU_BUTTON = "menu_button";
const ID_MENU_OUTER = "menu_outer";
const ID_MENU_INNER = "menu_inner";
const ID_DISPLAY_PROGRESS = "display_progress";
const ID_REPOSITORY = "repository";
const ID_REQUEST_PROPERTIES = "request_properties";
const ID_PAGE_COUNT = "pagecount";
const ID_PAGE_PREV = "pageprev";
const ID_PAGE_NEXT = "pagenext";
const ID_PAGE_LABEL = "pagelabel";
const ID_PAGE_BUTTONS = "pagebuttons";
const ID_FILTER_HIGHLIGHT = "filterhighlight";
const ID_FILTER_DATE = "filterdate";
const ID_FILTER_COUNT = "filtercount";
const ID_ENTRIES_MENU = "entries_menu";
const ID_ENTRIES_PREV = "entries_prev";
const ID_ENTRIES_NEXT = "entries_next";
const PROP_DISPLAY_FILTER = "displayFilter";
const PROP_EXCLUDE_ZERO = "excludeZero";
const PROP_EXCLUDE_NAN = "excludeUndefined";
const PROP_DIVID = "divid";
const PROP_FIELDS = "fields";
const PROP_LAYOUT_HERE = "layoutHere";
const PROP_HEIGHT = "height";
const PROP_WIDTH = "width";

const RECORD_INDEX = "recordindex";
const RECORD_ID = "recordid";
const TEXT_HIGHLIGHT_COLOR = "yellow";
const HIGHLIGHT_COLOR = "#436EEE";

const VALUE_NONE = "--none--";



const DisplayEvent = {
};

function displayDefineEvent(event,dflt) {
    if(!(dflt===false)) dflt=true;
    DisplayEvent[event] = {
	name:event,
	share: event+".share",
	accept: event+".accept",
	shareGroup: event+".shareGroup",
	acceptGroup: event+".acceptGroup",
	default:dflt,
	handler:"handleEvent" + event[0].toUpperCase() + event.substring(1),
	toString:function() {
	    return this.name;
	}
    }
}


displayDefineEvent("setEntry");
displayDefineEvent("recordSelection");
displayDefineEvent("recordList");
displayDefineEvent("recordHighlight");
displayDefineEvent("propertyChanged");
displayDefineEvent("pointDataLoaded");
displayDefineEvent("dataSelection");
displayDefineEvent("fieldsSelected");
displayDefineEvent("filterFieldsSelected");
displayDefineEvent("fieldsChanged");
displayDefineEvent("fieldValueSelected");
displayDefineEvent("entrySelection");
displayDefineEvent("entriesChanged");
displayDefineEvent("mapBoundsChanged",false);
displayDefineEvent("animationChanged");
displayDefineEvent("entryMouseOver");
displayDefineEvent("entryMouseOut");
displayDefineEvent("removeDisplay");
displayDefineEvent("filterChanged");


let globalDisplayCount = 0;
function addGlobalDisplayProperty(name, value) {
    if (window.globalDisplayProperties == null) {
        window.globalDisplayProperties = {};
    }
    if(value==="true") value = true;
    else if(value==="false") value=false;
    window.globalDisplayProperties[name] = value;
}


function addGlobalDisplayType(type, front) {
    if (window.globalDisplayTypes == null) {
        window.globalDisplayTypes = [];
	window.globalDisplayTypesMap = {};
    }

    if(type.type) {
	window.globalDisplayTypesMap[type.type] = type;
    }

    if(front) {
	window.globalDisplayTypes.unshift(type);
    } else {
	window.globalDisplayTypes.push(type);
    }
}


function makeDisplayTooltip(header,imgs,text) {
    let h =  "";
    if(header!=null) h +=HU.b(header);
    if(imgs) {
        if(!Array.isArray(imgs)) {
	    imgs  = [imgs];
	}
	let imgHtml = imgs.reduce((acc,img)=>{
	    if(!img.startsWith("/")) {
		img = ramaddaBaseUrl +"/help/display/" + img;
	    }
	    return acc+"<td><img src="+ img +" width=250px></td>";
	},"<table><tr valign=top>");
	imgHtml+="</tr></table>";
	if(h!="") h+="<br>";
	h+=imgHtml;
    }
    if(text) h+="<br>"+text;
    h  = h.replace(/"/g,"&quot;");
    return h;
}

function getGlobalDisplayProperty(name) {
    if (window.globalDisplayProperties == null) {
        return null;
    }
    return window.globalDisplayProperties[name];
}


function addRamaddaDisplay(display) {
    Utils.addDisplay(display);
    display.displayCount=globalDisplayCount++;
    return display;
}

async function ramaddaDisplaySetSelectedEntry(entryId, displays) {
    await getGlobalRamadda().getEntry(entryId, e => {
	displays = displays||Utils.displaysList;
	if(displays) {
		displays.forEach(d=>{
		    if(d.setEntry) d.setEntry(e);
		});
	}
    });
}


function ramaddaDisplayCheckLayout() {
    Utils.displaysList.forEach(d=>{
        if (d.checkLayout) {
	    let t1= new Date();
//	    console.log("before:" + d.type);
            d.checkLayout();
	    let t2= new Date();
//	    Utils.displayTimes("after:" + d.type,[t1,t2],true);
        }
    });
}


function getRamaddaDisplay(id) {
    let display =  Utils.displaysMap[id];
    if(display) return display;
    //Lazily set up the display map as when they are first created they don't have their getId() function defined yet
    Utils.displaysList.forEach(display=>{
	if(display.getId) {
	    Utils.displaysMap[display.getId()] = display;
	}
	if (display.displayId) {
            Utils.displaysMap[display.displayId] = display;
	}
    });
    return Utils.displaysMap[id];
}

function removeRamaddaDisplay(id) {
    var display = getRamaddaDisplay(id);
    if (display) {
        display.removeDisplay();
	Utils.removeDisplay(display);
    }
}

function displayGetFunctionValue(v) {
    if(v.getTime) {
	return v.getTime();
    }
    if(isNaN(v)) {
	if((typeof v) == "string")return v;
	return 0;
    }
    return v;
}

function ramaddaDisplayStepAnimation() {
    Utils.displaysList.forEach(d=>{
	if(d.getProperty && d.getAnimation)  {
	    if(d.getProperty("doAnimation")) {
		d.getAnimation().doNext();
	    }
	}
    });
}



function displayDefineMembers(display, props, members) {
    RamaddaUtil.defineMembers(display, members);
    if(props && display.defineProperties) display.defineProperties(props);
    return display;
}


function defineDisplay(display, SUPER, props, members) {
    RamaddaUtil.inherit(display, SUPER);
    displayDefineMembers(display, props, members);
    if(members.ctor) {
	display.ctor();
    }
    return display;
}



addGlobalDisplayType({
    type: "group",
    label: "Group",
    requiresData: false,
    forUser: true,
    category: "Basic Charts",
    tooltip: makeDisplayTooltip("Create a collection of displays",null,"This allows you to layout displays and share common attributes"),
    helpUrl:true

},true);






/**
   Base class for all displays oriented things
*/
function DisplayThing(argId, argProperties) {
    
    if (argProperties == null) {
        argProperties = {};
    }


    //check for booleans as strings
    for (var i in argProperties) {
        if (typeof argProperties[i] == "string") {
            if (argProperties[i] == "true") argProperties[i] = true;
            else if (argProperties[i] == "false") argProperties[i] = false;
        }
    }


    //Now look for the structured foo.bar=value
    for (var key in argProperties) {
        var toks = key.split(".");
        if (toks.length <= 1) {
            continue;
        }
	//var map = argProperties;
	// Don't this for now as it screws up doing something like colorTable.field=...
	let map = {};
        //graph.axis.foo=bar
        var v = argProperties[key];
        if (v == "true") v = true;
        else if (v == "false") v = false;
        for (var i = 0; i < toks.length; i++) {
            var tok = toks[i];
            if (i == toks.length - 1) {
                map[tok] = v;
                break;
            }
            var nextMap = map[tok];
            if (nextMap == null) {
                map[tok] = {};
                map = map[tok];
            } else {
                map = nextMap;
            }
        }
    }

    this.ignoreGlobals = argProperties.ignoreGlobals;

    this.displayId = null;

    displayDefineMembers(this,null, {
        objectId: argId,
        properties: argProperties,
        displayParent: null,
        getId: function() {
            return this.objectId;
        },
        setId: function(id) {
            this.objectId = id;
        },
        removeDisplay: function() {
	    if(this.dialogElement)  this.dialogElement.remove();
        },
	setEntry: function(entry) {
	},
	handleEntryMenu: async function(entryId) {
            await getGlobalRamadda().getEntry(entryId, e => {
		this.setEntry(e);
	    });

	},
	getEntriesMenu: function(argProperties) {
	    if(argProperties && argProperties.entryCollection) {
		let entries  = argProperties.entryCollection.split(",");
		this.changeEntries = [];
		let enums = [];
		entries.forEach(t=>{
		    var toks = t.split(":");
		    this.changeEntries.push(toks[0]);
		    enums.push([toks[0],toks[1]]);
		});
		let noun = this.getProperty("noun", "Data");
		let prev = HU.span([CLASS,"display-changeentries-button", TITLE,"Previous " +noun, ID, this.getDomId(ID_ENTRIES_PREV), TITLE,"Previous"], HU.getIconImage("fa-chevron-left"));
 		let next = HU.span([CLASS, "display-changeentries-button", TITLE,"Next " + noun, ID, this.getDomId(ID_ENTRIES_NEXT), TITLE,"Next"], HU.getIconImage("fa-chevron-right")); 
		let label = argProperties.changeEntriesLabel||"Select " + noun;
		if(label!="") label = label+"<br>";

		return  HU.center(HU.div([CLASS,"display-filter"], label + prev +" " + HU.select("",[ATTR_ID, this.getDomId(ID_ENTRIES_MENU)],enums) +" " + next));
	    }
	    return "";
	},
        initializeEntriesMenu: function() {
	    this.jq(ID_ENTRIES_PREV).click(e=>{
		let index = this.jq(ID_ENTRIES_MENU)[0].selectedIndex;
		if(index<=0) {
		    index = this.changeEntries.length;
		}
		let entry  =this.changeEntries[index-1];
		this.jq(ID_ENTRIES_MENU).val(entry);
		this.handleEntryMenu(entry);
	    });
	    this.jq(ID_ENTRIES_NEXT).click(e=>{
		let index = this.jq(ID_ENTRIES_MENU)[0].selectedIndex;
		if(index>=this.changeEntries.length-1) {
		    index = 0;
		}
		let entry  =this.changeEntries[index+1];
		this.jq(ID_ENTRIES_MENU).val(entry);
		this.handleEntryMenu(entry);
	    });
	    this.jq(ID_ENTRIES_MENU).change(e=>{
		let entry = this.jq(ID_ENTRIES_MENU).val();
		this.handleEntryMenu(entry);
	    });
	},


        popup: function(srcId, popupId, srcObj, popup) {
            popup = popup || $("#"+popupId);
            var src = srcObj || $("#"+srcId);
            var myalign = 'left top';
            var atalign = 'left bottom';
            popup.show();
	    //	    console.log(srcObj +" " + srcId + " " + "pop:" + popup.length +" src:" + src.length);
            popup.position({
                of: src,
                my: myalign,
                at: atalign,
                collision: "none none"
            });
            //Do it again to fix a bug on safari
            popup.position({
                of: src,
                my: myalign,
                at: atalign,
                collision: "none none"
            });
            popup.draggable();
            popup.show();	    
        },

	initDialog: function() {
	},
        showDialog: function(text, from, initDialog) {
	    if(!this.dialogElement) {
		$(document.body).append(HU.div([ATTR_CLASS, "display-dialog",ID,this.getDomId(ID_DIALOG)]));
		this.dialogElement = this.jq(ID_DIALOG);
	    }
	    this.dialogElement.html(this.makeDialog(text));
            this.popup(from || this.getDomId(ID_MENU_BUTTON), null,null, this.dialogElement);
	    if(initDialog) initDialog();
            else this.initDialog();
        },
        getShowMenu: function() {
            if (Utils.isDefined(this.showMenu)) {
		return this.showMenu;
	    }
	    var dflt = false;
            if (this.displayParent != null) {
		dflt = this.displayParent.getProperty("showChildMenu",dflt);
	    }
	    var v = this.getProperty(PROP_SHOW_MENU, dflt);
	    return v;
        },
        getShowTitle: function() {
            if (this.getProperty("showTitle")) {
		return this.getProperty("showTitle");
	    }
	    var dflt = false;
            if (this.displayParent != null) {
		dflt = this.displayParent.getProperty("showChildTitle",dflt);
	    }
	    return this.getProperty("showTitle", dflt);
        },

        getTimeZone: function() {
            return this.getProperty("timeZone");
        },
        formatDate: function(date, args, useToStringIfNeeded) {
	    if(!date || !date.getTime) return "";
            try {
                return this.formatDateInner(date, args, useToStringIfNeeded);
            } catch (e) {
		console.log(e.stack);
                console.error("Error formatting date:\"" + date +"\" error:" +e);
                if (!date.getTime && date.v) date = date.v;
                return "" + date;
            }
        },
	dateFormat:null,
        formatDateInner: function(date, args,useToStringIfNeeded) {
	    if(!this.dateFormat)
		this.dateFormat =  this.getProperty("dateFormat", this.getProperty("dateFormat2"));
	    if(!this.dateFormat && useToStringIfNeeded) {
		return String(date);
	    }
            //Check for date object from charts
            if (!date.getTime && date.v) date = date.v;
	    if(date.getTime && isNaN(date.getTime())) return "Invalid date";
	    if(this.dateFormat) {
		let dttm = Utils.formatDateWithFormat(date,this.dateFormat,true);
		if(dttm) {
		    return String(dttm);
		}
	    }
            if (!date.toLocaleDateString) {
                return String(date);
            }
            var suffix;
            if (args && !Utils.isDefined(args.suffix))
                suffix = args.suffix;
            else
                suffix = this.getProperty("dateSuffix");
            var timeZone = this.getTimeZone();
            if (!suffix && timeZone) suffix = timeZone;
	    return Utils.formatDate(date, args?args.options:null, {
                timeZone: timeZone,
                suffix: suffix
	    });
        },
        getUniqueId: function(base) {
            return HU.getUniqueId(base);
        },
        toString: function() {
            return "DisplayThing:" + this.getId();
        },
        domId: function(suffix) {
	    return this.getDomId(suffix);
	},
        getDomId: function(suffix) {
            return this.getId() + "_" + suffix;
        },
	gid: function(suffix) {
            return this.getId() + "_" + suffix;
        },
	find: function(selector) {
	    return this.getContents().find(selector);
	},
	getContents: function() {
	    return this.jq(ID_DISPLAY_CONTENTS);
	},	
        jq: function(componentId) {
            return $("#" + this.getDomId(componentId));
        },
	selectboxit: function(selector, args) {
	    let opts = {
		showEffect: "fadeIn",
		showEffectSpeed: 400,
		hideEffect: "fadeOut",
		hideEffectSpeed: 400,
	    };
	    if(args) $.extend(opts,args);
            selector.selectBoxIt(opts);
	},
        writeHtml: function(idSuffix, html) {
            $("#" + this.getDomId(idSuffix)).html(html);
        },
	getTemplateProps: function(fields) {
	    return {
		iconField: this.getFieldById(fields, this.getProperty("iconField")),
		iconSize: parseFloat(this.getProperty("iconSize",16)),
		iconMap: this.getIconMap(),
		colorBy:this.getProperty("colorBy"),
		colorByMap: this.getColorByMap()
	    }
	},
	macroHook: function(token,value) {
	    return null;
	},
	applyRecordTemplate: function(record, row, fields, template, props,macros, debug) {
	    fields = this.getFields(fields);
	    if(!props) {
		props = this.getTemplateProps(fields);
	    }
	    if(!macros) macros = Utils.tokenizeMacros(template,{hook:(token,value)=>{return this.macroHook(record, token,value)},dateFormat:this.getProperty("dateFormat")});
	    let attrs = {};
	    if(props.iconMap && props.iconField) {
		var value = row[props.iconField.getIndex()];
		var icon = props.iconMap[value];
		if(icon) {
		    attrs[props.iconField.getId() +"_icon"] =  HU.image(icon,["width",props.iconSize]);
		}
	    }

	    let makeImage = (f, value) =>{
		let tokenAttrs  = macros.getAttributes(f.getId()+"_image");
		let imageAttrs = [];
		let width = tokenAttrs?tokenAttrs["width"]:null;
		if(width) {
		    imageAttrs.push("width");
		    imageAttrs.push(width);
		} else if(this.getProperty("imageWidth")) {
		    imageAttrs.push("width");
		    imageAttrs.push(this.getProperty("imageWidth")); 
		} else  {
		    imageAttrs.push("width");
		    imageAttrs.push("300");
		}
		imageAttrs.push("style");
		imageAttrs.push("vertical-align:top");
		return HU.image(value, imageAttrs);
	    };



	    let idToField = {}
	    fields.forEach(f=>idToField[f.getId()] = f);
	    //Look for a list
	    macros.tokens.forEach(t=>{
		if(!t.attrs) return;
		if(t.tag=="default") {
		    attrs[t.tag] =  this.getRecordHtml(record, fields, "${default}");
		} else 	if(t.attrs["type"]=="list" && t.attrs["fields"]) {
		    let html = "<table class=display-table>";
		    t.attrs.fields.split(",").forEach(fieldName=>{
			let f = idToField[fieldName];
			let value = row[f.getIndex()];
			if(f.getType()=="image") {
			    value = makeImage(f,value);
			} else  if(f.getType()=="url") {
			    if(value!="") 
				value =  HU.href(value,value);
			}
			html+="<tr><td align=right><b>" +f.getLabel()+"</b>:</td><td>  " + value+"</td></tr>";
		    });
		    html +="</table>";
		    attrs[t.tag] = html;
		}
	    });


//	    debug = true;
	    for (let col = 0; col < fields.length; col++) {
		let f = fields[col];
		let value = row[f.getIndex()];
		if(debug) console.log("macro:" + col +" field:" + f.getId() +" type:" +f.getType() + " value:" + value);
		if(props.iconMap) {
		    var icon = props.iconMap[f.getId()+"."+value];
		    if(icon) {
			s = s.replace("${" + f.getId() +"_icon}", HU.image(icon,["size",props.iconSize]));
		    }
		}
		if(f.getType()=="image") {
		    if(value && value.trim().length>1) {
			let tokenAttrs  = macros.getAttributes(f.getId()+"_image");
			let imageAttrs = [];
			let width = tokenAttrs?tokenAttrs["width"]:null;
			if(width) {
			    imageAttrs.push("width");
			    imageAttrs.push(width);
			} else if(this.getProperty("imageWidth")) {
			    imageAttrs.push("width");
			    imageAttrs.push(this.getProperty("imageWidth")); 
			} else  {
			    imageAttrs.push("width");
			    imageAttrs.push("100%");
			}
			imageAttrs.push("style");
			imageAttrs.push("vertical-align:top");
			var img =  HU.image(value, imageAttrs);

			attrs[f.getId() +"_image"] =  img;
			attrs[f.getId() +"_url"] =  value;
		    } else {
			attrs[f.getId() +"_url"] =  ramaddaCdn+"/icons/blank.gif";
			attrs[f.getId() +"_image"] =  "";
		    }
		} else if(f.getType()=="movie") {
		    if(value && value.trim().length>0) {
			let movieAttrs = [];
			if(this.getProperty("movieWidth")) {
			    movieAttrs.push("width");
			    movieAttrs.push(this.getProperty("movieWidth"));
			}
			let movie =  HU.movie(value,movieAttrs);
			attrs[f.getId() +"_movie"] =  movie;
			attrs[f.getId() +"_url"] =  value;
		    }
		} else if(f.getType()=="url") {
		    if(value && value.trim().length>1) {
			let tokenAttrs  = macros.getAttributes(f.getId()+"_href");
			let label = tokenAttrs?tokenAttrs["label"]:null;
			attrs[f.getId() +"_href"] =  HU.href(value,label||value);
			attrs[f.getId()]=  value;
		    } else {
			attrs[f.getId() +"_href"] =  "";
			attrs[f.getId()] =  "";
		    }
		    continue;
		} else if(f.isDate) {

		    if(value) {
			attrs[f.getId()]= value;
		    }
		    continue;
		}
		var color;
		if(props.colorByMap) {
		    if(props.colorBy && props.colorBy == f.getId()) {
			color = props.colorByMap[value];
		    } else {
			color = props.colorByMap[f.getId()+"."+value];				    
		    }
		}
		if(color) {
		    attrs[f.getId()+"_color"] =  color;
		}
		attrs[f.getId()]=  value;
		if(f.isNumeric()) {
		    //TODO: nuke this
		    attrs[f.getId() +"_format"] = Utils.formatNumberComma(value);
		}
	    }
	    this.addMacroAttributes(macros,row,attrs);
	    let handler = (tag,value) =>{
		if(tag.attrs["display"] =="tags") {
		    let type = tag.tag;
		    let filter = this.filterMap[type];
		    let color = Utils.getEnumColor(type);
		    let result = "";
		    value = String(value).trim();
		    if(value=="") return "";
		    value.split(",").forEach(tagValue=>{
			result+= HU.div(["metadata-type",type,"metadata-value",tagValue,TITLE,tagValue, STYLE, HU.css("background", color),CLASS,"display-search-tag"],tagValue);
		    });
		    if(filter) result = filter.getLabel()+": " + result+"<br>";
		    return result;
		}
		return "Unknown tag handler:" + tag.attrs["handle"];
	    };
	    attrs.recordIndex = record.rowIndex+1;
	    return macros.apply(attrs,debug,handler);
	},
	addMacroAttributes:function(macros,row,attrs) {
	},
	getFields: function(fields) {
            if (!fields) {
                var pointData = this.pointData || this.getData();
                if (pointData == null) {
		    return null;
		}
                fields = pointData.getRecordFields();
	    }
	    return fields;
	},
	getFieldLabel:function(field) {
	    return  this.getProperty(field.getId()+".label",field.getLabel());
	},
	getRecordUrlHtml: function(attrs, field, record) {
	    let value = record.getValue(field.getIndex());
	    let label = attrs[field.getId()+".label"] || attrs["url.label"] ||attrs["label"] || "Link";
	    return  HU.href(value,label,["target","_link"]);
	},

	getSortedFields: function(fields) {
	    let anyGroups = fields.filter(f=>{
		if(f==null) return true;
		return f.getGroup()!=null;
	    }).length>0;

	    if(!anyGroups) return fields;
	    let groups = [];
	    let map = {};
	    for(let i=0;i<fields.length;i++) {
		let field = fields[i];
		if(field==null) continue;
		group = field.getGroup();
		if(group==null) {
		    group = group+"_"+ i;
		}
		if(!map[group]) {
		    map[group] = [];
		    groups.push(group);
		}
		map[group].push(field);
	    }
	    fields = [];
	    groups.forEach(group=>{
		fields = Utils.mergeLists(fields,map[group]);
	    });
	    return fields;
	},
        getRecordHtml: function(record, fields, template, debug) {
	    fields = this.getFields(fields);
	    if(!fields) return "";
            let urlField = this.getFieldById(null, this.getProperty("urlField", "url"));
	    let linkField = this.getFieldById(null,this.getProperty("linkField"))|| urlField;
	    let titleField = this.getFieldById(null,this.getProperty("titleField"));
	    let titleTemplate = this.getProperty("titleTemplate");	    
	    let descField = this.getFieldById(null,this.getProperty("descriptionField"));
	    let link  = linkField?record.getValue(linkField.getIndex()):null;
	    let showDate = this.getProperty("showDate", true);
	    let showImage = this.getProperty("showImage", true);
	    let showMovie = this.getProperty("showMovie", true);	    
            let showGeo = false;
            let showElevation = this.getProperty("showElevation",false);
            if (Utils.isDefined(this.showGeo)) {
                showGeo = ("" + this.showGeo) == "true";
            }
	    if(template=="") return "";
	    if(!Utils.stringDefined(template))
		template = this.getProperty("recordTemplate");

	    if(Utils.stringDefined(template)) {
		if(!template.startsWith("${default") && template!="${fields}") {
		    return this.applyRecordTemplate(record,this.getDataValues(record), fields, template, null, null,debug);
		}
	    }
	    if(template=="${fields}") {
		fields = this.getFieldsByIds(null,this.getProperty("tooltipFields",this.getPropertyFields()));
	    } else {
		let ttf = this.getProperty("tooltipFields");
		if(ttf) {
		    fields = this.getFieldsByIds(null,ttf);
		}
	    }

	    let templateProps = {};
	    let itemsPerColumn=this.getProperty("itemsPerColumn",50);

	    let attrs={};
	    if(template) {
		attrs = Utils.tokenizeMacros(template,{hook:(token,value)=>{return this.macroHook(record, token,value)},dateFormat:this.getProperty("dateFormat")}).getAttributes("default")||{};
	    }
	    itemsPerColumn = attrs["itemsPerColumn"] || itemsPerColumn;
	    let values = "";
	    if(titleField || titleTemplate) {
		let title="";
		if(titleTemplate) {
		    if(!titleTemplate.startsWith("${default")) {
			title = this.getRecordHtml(record, fields, titleTemplate, debug);
		    }
		} else {
		    title = record.getValue(titleField.getIndex());
		    if(title.getTime)
			title = this.formatDate(title);
		    title = HU.center(HU.h3(title));
		}
		if(link)
		    title = HU.href(link,title,["target","_target"]);
		values+=title;
		link = null;
	    }

	    if(descField) {
		let desc = record.getValue(descField.getIndex());
		values+=desc;
	    }

	    let tooltipNots = {};
	    this.getProperty("tooltipNotFields","").split(",").forEach(f=>{
		tooltipNots[f] = true;
	    });

	    let rows = [];
	    let hadDate = false;
	    let labelColAttrs = [];
	    if(this.getProperty("labelColumnAttrs")) {
		labelColAttrs = this.getProperty("labelColumnAttrs").split(",");
	    } else {
		labelColAttrs = ["align","right"];
	    }
	    let labelWidth = this.getProperty("labelWidth");
	    fields= this.getSortedFields(fields);

	    let group = null;
            for (let doDerived = 0; doDerived < 2; doDerived++) {
                for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
		    if(tooltipNots[field.getId()]) continue;
		    if(attrs[field.getId()+".hide"]) {
			continue;
		    }
		    if(field==titleField || field==descField) continue;
                    if (doDerived == 0 && !field.derived) continue;
                    else if (doDerived == 1 && field.derived) continue;
                    if (!field.getForDisplay()) {
			continue;
		    }
		    if(field.isRecordDate()) {
			if(!showDate) {
			    continue;
			}
			hadDate = true;
		    }
                    if (!showGeo) {
                        if (field.isFieldGeo()) {
                            continue;
                        }
                    }
		    if(group!=field.getGroup()) {
			group = field.getGroup();
			if(Utils.isDefined(group)) {
			    rows.push(HU.tr([],HU.td(["colspan","2"],HU.div([CLASS,"ramadda-header-small"],group))));
			}
		    }
                    let initValue = record.getValue(field.getIndex());
                    let value = initValue;
		    let fieldValue = value;
                    if (typeof value == "number") {
			value = this.formatNumber(value, field.getId());
		    } 
                    if (field.isFieldDate()) {
			value = this.formatDate(value);
		    }
		    if(field.getType() == "image" && value!="") {
			if(!showImage) continue;
			let imageAttrs = [];
			if(this.getProperty("imageWidth")) {
			    imageAttrs.push("width");
			    imageAttrs.push(this.getProperty("imageWidth")); 
			} else  {
			    imageAttrs.push("width");
			    imageAttrs.push("200");
			}
			imageAttrs.push("align");
			imageAttrs.push("top");
			value = HU.image(value,imageAttrs);
		    }
		    if(field.getType() == "movie" && value!="") {
			if(!showMovie) continue;
			var movieAttrs = [];
			movieAttrs.push("width");
			movieAttrs.push("200");
			value = HU.movie(value,movieAttrs);
		    }		    
		    if(field.getType() == "url") {
			value = this.getRecordUrlHtml(attrs, field, record);
		    }
		    let labelValue = field.getLabel();
		    value = value + field.getUnitSuffix();
		    let tt = labelValue+"=" + initValue;
		    if(value.length>100) {
			value  = HU.div([STYLE,HU.css("max-height","100px","overflow-y","auto")],value);
		    }
		    let label = this.formatRecordLabel(labelValue)+":";
		    if(labelWidth) {
			label = HU.div([STYLE,HU.css("max-width" ,HU.getDimension(labelWidth),"overflow-x","auto")], label); 
		    } 
		    label  = HU.div([TITLE,tt],label);
                    let row = HU.open(TR,['valign','top']);
		    row += HU.td(labelColAttrs,HU.div([CLASS,"display-record-table-label"], label));
		    row += HU.td(["field-id",field.getId(),"field-value",fieldValue, "align","left"], HU.div([STYLE,HU.css('margin-left','5px')], value));
		    row += HU.close(TR);
		    rows.push(row);
                }
            }
	    if(!hadDate && showDate) {
		if(record.hasDate()) {
                    let row = HU.open(TR,['valign','top']);
		    let label = this.formatRecordLabel("Date");
		    row += HU.td([],HU.b(label+":"));
		    row += HU.td(["align","left"], HU.div([STYLE,HU.css('margin-left','5px')],
							  this.formatDate(record.getDate())));
		    row += HU.close(TR);
		    rows.push(row);
		}
	    }
            if (showElevation && record.hasElevation()) {
                rows.push(HU.tr([],HU.td([ALIGN,'right'],HU.b('Elevation:')) +
			       HU.td([ALIGN,'left'], number_format(record.getElevation(), 4, '.', ''))));
            }
	    let rowCnt = 0;
	    values += "<table><tr valign=top>";
	    let		lists   = Utils.splitList(rows,itemsPerColumn);
	    let tdStyle =lists.length>1?"margin-right:5px;":"";
	    lists.forEach(list=>{
		values += "<td><div style='" + tdStyle+"'><table>" + Utils.join(list,"") +"</table></div></td>";
	    });
            values += "</tr><table>";
	    if(this.getProperty("recordHtmlStyle")){
		values = HU.div([CLASS,"ramadda-shadow-box display-tooltip", STYLE,this.getProperty("recordHtmlStyle")], values);
	    }
            return values;
        },
        formatRecordLabel: function(label) {
            label = label.replace(/!!/g, " -- ");
	    label = label.replace(/ /g,"&nbsp;");
            return label;
        },
        getFormValue: function(what, dflt) {
            var fromForm = $("#" + this.getDomId(what)).val();
            if (fromForm != null) {
                if (fromForm.length > 0) {
                    this.setProperty(what, fromForm);
                }
                if (fromForm == "none") {
                    this.setProperty(what, null);
                }
                return fromForm;
            }
            return this.getProperty(what, dflt);
        },

        getName: function() {
            return this.getFormValue("name", this.getId());
        },
        getEventSource: function() {
            return this.getFormValue("eventSource", "");
        },
        setDisplayParent: function(parent) {
            this.displayParent = parent;
        },
        getDisplayParent: function() {
            if (this.displayParent == null) {
                this.displayParent = this.getLayoutManager();
            }
            return this.displayParent;
        },
        removeProperty: function(key) {
            this.properties[key] = null;
        },
        setProperty: function(key, value) {
	    //            this[key] = value;
            this.properties[key] = value;
	    this.transientProperties[key]  = value;
        },
        getSelfProperty: function(key, dflt) {
            if (this[key] != null) {
                return this[key];
            }
            return this.getProperty(key, dflt);
        },
        initTooltip: function() {
            //don't do this for now                $( document ).tooltip();
        },
        formatNumber: function(number, propPrefix,debug) {
	    if(!this.getProperty(propPrefix?[propPrefix+".doFormatNumber","doFormatNumber"]:"doFormatNumber",true)) {
		return number;
	    }
	    if(isNaN(number)) {
                return this.getProperty("nanValue", "--");
	    }
	    let f = this.formatNumberInner(number, propPrefix,debug);
	    let fmt = this.getProperty(propPrefix?[propPrefix+".numberTemplate","numberTemplate"]:"numberTemplate");
	    if(fmt) f = fmt.replace("${number}", f);
	    f = String(f);
	    if(f.endsWith(".")) f = f.substring(0,f.length-1);
	    return f;
	},
        formatNumberInner: function(number,propPrefix,debug) {
	    number = +number;
	    let scale = this.getProperty(propPrefix?[propPrefix+".formatNumberScale","formatNumberScale"]:"formatNumberScale");
            if (Utils.isDefined(scale))
		number = number*scale;
	    let decimals = this.getProperty(propPrefix?[propPrefix+".formatNumberDecimals","formatNumberDecimals"]:"formatNumberDecimals");
            if (Utils.isDefined(decimals)) {
		return number_format(number, decimals);
	    }
            if (this.getProperty(propPrefix?[propPrefix+".formatNumberComma","formatNumberComma"]:"formatNumberComma", false)) {
		return Utils.formatNumberComma(number);
	    }
            return Utils.formatNumber(number,false,debug);

        },
        propertyDefined: function(key) {
            return Utils.isDefined(this.getProperty(key));
        },
        setPropertyOn: function(object, myProperty, objectProperty, dflt) {
            var prop = this.getProperty(myProperty, dflt);
            if (Utils.isDefined(prop) && prop != null) {
                object[objectProperty] = prop;
            }
        },
        getDisplayProp: function(source, prop, dflt) {
            if (Utils.isDefined(this[prop])) {
                return this[prop];
            }
            let prop2 = "map-" + prop;
            if (Utils.isDefined(source[prop2])) {
                return source[prop2];
            }
	    if(source.getProperty) {
		return source.getProperty(prop, dflt);
	    }
	    return null;
        },
        getPropertyFromUrl: function(key, dflt) {
	    let fromUrl = HU.getUrlArgument("display"+ this.displayCount+"." + key);
	    if(fromUrl) return fromUrl;
	    return this.getProperty(key,dflt);
	},
	getPropertyFields: function(dflt) {
	    return this.getPropertyFromUrl(PROP_FIELDS,dflt);
	},
	transientProperties:{},
	getPropertyCounts:{},
	priorProps:{},
        getProperty: function(key, dflt, skipThis, skipParent) {
	    let debug = false;
	    if(!this.getPropertyCounts[key]) {
		this.getPropertyCounts[key]=0;
//		debug = true;
	    }
//	    if(key=="gridlines.color") debug = true;
	    if(typeof this.transientProperties[key]!='undefined') {
		if(debug) {
		    console.log("getProperty:" + key +"  dflt:"+ dflt +" transient:" + this.transientProperties[key]);
		}
		let value =  this.transientProperties[key];
		/*
		if(this.priorProps[key]) {
		    if(this.priorProps[key]  !=dflt)	console.log("prior:" + key +"  dflt:"+ dflt +" transient:" + this.transientProperties[key]);
		} 
		*/
		return value;
	    }

	    debug|=this.debugGetProperty;
	    this.getPropertyCount++;
	    this.getPropertyCounts[key]++;
//	    debug = this.getPropertyCounts[key]==1;
//	    if(debug)
//		console.log("getProperty:" + key +"  dflt:"+ dflt);
	    let value =  this.getPropertyInner(key,null,skipThis, skipParent);
	    if(debug) 
		console.log("getProperty:" + key +"  dflt:"+ dflt +" got:" + value);
	    if(this.writePropertyDef!=null) {
		if(!this.seenWriteProperty) this.seenWriteProperty = {};
		if(!this.seenWriteProperty[key]) {
		    let f = (v)=>{
			return v?"'" + v+"'":"null";
		    };
		    this.writePropertyDef+="{p:'" + key +"',d:" + f(dflt)+",wikiValue:" + f(value||dflt)+"},\n"
		    this.seenWriteProperty[key] = true;
		}
	    }
	    if(!Utils.isDefined(value)) {
//		if(debug)  console.log("\treturning dflt:" + dflt);
		value= dflt;
	    }
	    if(this.getPropertyCounts[key]>10) {
		//If we keep calling getProperty then set the transient property so on the next call we don't take the full hit
		this.transientProperties[key]  = Utils.isDefined(value)?value:null;
	    }
//	    if(debug)console.log("\treturning value:" + value);
//	    this.priorProps[key] = value;
	    return value;
	},
        getPropertyInner: function(keys, dflt,skipThis, skipParent) {	    
	    let debug = displayDebug.getProperty;
	    debug = this.debugGetProperty;
	    if(!Array.isArray(keys)) keys = [keys];
	    for(let i=0;i<keys.length;i++) {
		let key = keys[i];
		if(debug) console.log("getProperty:" + key +" dflt:" + dflt);
		if(this.dynamicProperties) {
		    if(Utils.isDefined(this.dynamicProperties[key])) {
			return this.dynamicProperties[key];
		    }
		}
		var value = this.properties[key];
		if (value != null) {
		    if(debug) console.log("\tgot property from this.properties:" + value);
                    return value;
		}
	    }
	    if(!skipParent) {
		for(let i=0;i<keys.length;i++) {
		    let key = keys[i];
		    var fromParent=null;
		    if (this.displayParent != null) {
			fromParent =  this.displayParent.getPropertyInner("inherit."+key, skipThis);
		    }
		    if (!fromParent && this.getDisplayManager) {
			fromParent=  this.getDisplayManager().getPropertyInner("inherit."+key);
		    }
		    if(fromParent) {
			if(debug) console.log("\tgetProperty-3");
			return fromParent;
		    }
		}
	    }
	    if(!this.ignoreGlobals) {
		if(!skipParent) {
		    if (this.displayParent != null) {
			if(debug) console.log("\tgetProperty calling parent");
			return this.displayParent.getPropertyInner(keys, skipThis);
		    }
		    if (this.getDisplayManager) {
			if(debug) console.log("\tgetProperty-5");
			return   this.getDisplayManager().getPropertyInner(keys);
		    }
		}
		for(let i=0;i<keys.length;i++) {
		    let key = keys[i];
		    value = getGlobalDisplayProperty(key);
		    if (Utils.isDefined(value)) {
			if(debug) console.log("\tgetProperty-6:" + value);
			return value;
		    }
		}
	    }
	    if(debug) console.log("\tgetProperty-6 dflt:" + dflt);
            return dflt;
        },
    });
}




/**
   Base class for all displays 
*/
function RamaddaDisplay(argDisplayManager, argId, argType, argProperties) {

    const SUPER  = new DisplayThing(argId, argProperties);
    RamaddaUtil.inherit(this, SUPER);


    if(window.globalDisplayTypesMap) {
	this.typeDef = window.globalDisplayTypesMap[argType];
    }

    this._wikiTags  = [];
    
    this.defineProperties = function(props) {
	let tagList = [];
	props.forEach(prop=>{
	    tagList.push(prop);
	    if(!prop.p) {
		return;
	    }
	    if(prop.p.indexOf("&")<0) {
		if(!Utils.isDefined(prop.doGetter) || prop.doGetter) {
		    let getFunc = (dflt,debug)=>{
			if(!Utils.isDefined(dflt)) dflt = prop.d;
			return this.getProperty(prop.p,dflt);
		    };
		    let funcName =  'getProperty' + prop.p.substring(0, 1).toUpperCase() + prop.p.substring(1);
		    if(!this[funcName])
			this[funcName] = getFunc;
		    funcName =  'get' + prop.p.substring(0, 1).toUpperCase() + prop.p.substring(1);
		    if(!this[funcName])
			this[funcName] = getFunc;
		}
	    }
	    prop.wikiValue = prop.wikiValue||prop.w;
	});
	this._wikiTags  = Utils.mergeLists(tagList,this._wikiTags);
    }

    let myProps = [
	{label:'Display'},
	{p:'fields',doGetter:false,ex:'comma separated list of field ids or indices - e.g. #1,#2,#4-#7,etc or *'},
	{p:'notFields',ex:'regexp',tt:'regexp to not include fields'},		
	{p:'fieldsPatterns',ex:'comma separated list of regexp patterns to match on fields to display'},
	{p:'showMenu',ex:true},	      
	{p:'showTitle',ex:true},
	{p:'showEntryIcon',ex:true},
	{p:'layoutHere',ex:true},
	{p:'width',doGetter:false,ex:'100%'},
	{p:'height',doGetter:false,ex:'400'},
	{p:'tooltip',doGetter:false,ex:'${default}'},
	{p:'tooltipPositionMy',ex:'left top'},
	{p:'tooltipPositionAt',ex:'left bottom+2'},		
	{p:'recordTemplate',doGetter:false,ex:'${default}',tt:'Template for popups etc. Can be ${default attrs} or \'${field} .. ${fieldn}...\''},
	{p:'titleTemplate',doGetter:false,ex:'${field1}',tt:'Template for title in ${default} template display'},	
	{p:'itemsPerColumn',ex:10,tt:'How many items to show in each column in a tooltip'},
	{p:'labelColumnAttrs',ex:'align,right',tt:'Attributes of the label column in the record templates'},
	{p:'labelWidth',ex:'10',tt:'Width of labels the record templates'},	
	{p:'displayStyle',ex:'css styles',tt:'Specify styles for display'},
	{p:'title',ex:''},
	{p:'titleBackground',ex:'color'},
	{p:'linkField',ex:''},
	{p:'titleField',ex:''},
	{p:'descriptionField',ex:''},
	{p:'textColor',ex:'color'},
	{p:'backgroundImage',ex:'',tt:'Image url to display in background'},
	{p:'background',ex:'color'},
	{p:'showProgress',ex:true},
	{p:'loadingMessage',ex:'',tt:'Message to show when loading data'},	
	{p:'doEntries',ex:true,tt:'Make the children entries be data'},
	{p:'addAttributes',ex:true,tt:'Include the extra attributes of the children'},
	{p:'sortFields',tt:'Comma separated list of fields to sort the data on'},
	{p:'sortAscending',ex:'true|false',d:true},
	{p:'showSortDirection',ex:true},		
	{p:'sortByFields',ex:'',tt:'Show sort by fields in a menu'},
	{p:'sortHighlight',ex:true,tt:'Sort based on highlight from the filters'},
	{p:'showDisplayFieldsMenu',ex:true},
	{p:'displayFieldsMenuMultiple',ex:true},
	{p:'displayFieldsMenuSide',ex:'left'},
	{p:'displayHeaderSide',ex:'left'},
	{p:'leftSideWidth',ex:'150px'},		
	{label:'Formatting'},
	{p:'dateFormat',ex:'yyyy|yyyymmdd|yyyymmddhh|yyyymmddhhmm|yyyymm|yearmonth|monthdayyear|monthday|mon_day|mdy|hhmm'},
	{p:'dateFormatDaysAgo',ex:true},
	{p:'doFormatNumber',ex:false},
 	{p:'formatNumberDecimals',ex:0},
	{p:'formatNumberScale',ex:100},
	{p:'numberTemplate',ex:'${number}%'},
	{p:'&lt;field_id&gt;.&lt;format&gt;',ex:'...'},
	{label:'Data Requests'},
	{p:'requestFields',tt:'Comma separated list of fields for querying server side data'},
	{p:'requestPrefix',ex:'search.', tt:'Prefix to prepend to the url argument'},
	{p:'request.&lt;request field&gt;.multiple',ex:'true',tt:'Support multiple enumerated selections'},
	{label:'Filter Data'},
	{p:'fieldsNumeric',ex:true,tt:'Only get numeric fields'},
	{p:'filterFields',ex:''},
	{p:'filterFieldsToPropagate'},
	{p:'hideFilterWidget',ex:true},
	{p:'filterHighlight',d:false,ex:true,tt:'Highlight the records'},
        {p:'showFilterTags',d: false},
        {p:'tagDiv',tt:'Div id to show tags in'},		
	{p:'showFilterHighlight',ex:false,tt:'show/hide the filter highlight widget'},


	{p:'headerOrientation',ex:'vertical'},
	{p:'filterSliderImmediate',ex:true,tt:'Apply the change while sliding'},
	{p:'filterLogic',ex:'and|or',tt:'Specify logic to apply filters'},		
	{p:'&lt;field&gt;.filterValue'},
	{p:'&lt;field&gt;.filterValueMin'},
	{p:'&lt;field&gt;.filterValueMax'},
	{p:'&lt;field&gt;.filterValues'},
	{p:'&lt;field&gt;.filterMultiple',ex:true},
	{p:'&lt;field&gt;.filterMultipleSize',ex:5},
	{p:'filterShowCount',ex:false},
	{p:'filterShowTotal',ex:true},		
	{p:'&lt;field&gt;.filterLabel'},
	{p:'&lt;field&gt;.showFilterLabel'},
	{p:'&lt;field&gt;.filterLabelVertical',ex:true},
	{p:'filterLabelVertical',ex:true},				
	{p:'&lt;field&gt;.filterByStyle',ex:'background:white;'},
	{p:'&lt;field&gt;.includeAll',ex:false},
	{p:'&lt;field&gt;.filterSort',ex:false},
	{p:'&lt;field&gt;.filterSortCount',ex:false},		
	{p:'&lt;field&gt;.filterStartsWith',ex:true},
	{p:'&lt;field&gt;.filterDisplay',ex:'menu|tab|button|image'},
	{p:'&lt;field&gt;.filterOps',ex:'<,5000000,label1;>,5000000',tt:'Add menu with fixed filters'},
	{p:'excludeUndefined',ex:true,tt:'Exclude any records with an undefined value'},
	{p:'excludeZero',ex:true,tt:'Exclude any records with a 0 value'},
	{p:'filterPaginate',ex:'true',tt:'Show the record pagination'},
	{p:'recordSelectFilterFields',tt:'Set the value of other displays filter fields'},
	{p:'selectFields',ex:'prop:label:field1,...fieldN;prop:....'},
	{p:'match value', ex:"dataFilters=\"match(field=field,value=value,label=,enabled=);\"",tt:"Only show records that match"}, 		
	{p:"not match value",ex:"dataFilters=\"notmatch(field=field,value=value,label=,enabled=);\"",tt:"Only show records that dont match"},
	{p:'no missing values',ex:'dataFilters=\"nomissing(field=field,label=,enabled=);\"',tt:'Dont show missing values'},
	{p:'less than',ex:'dataFilters=\"lessthan(field=field,value=value,label=,enabled=);\"'},
	{p:'greater than',ex:'dataFilters=\"greaterthan(field=field,value=value,label=,enabled=);\"'},
	{p:'equals',ex:'dataFilters=\"equals(field=field,value=value,label=,enabled=);\"'},
	{p:'not equals',ex:'dataFilters=\"notequals(field=field,value=value,label=,enabled=);\"'},
	{p:'filterLatest',ex:'fields',tt:'Only show the latest records grouped by fields'},		
	{p:'filterDate',ex:'year',tt:'Show a simple pull down menu to select a year to display'},
	{p:'filterDateIncludeAll',ex:true,tt:'Include all years'},
	{p:'startDate',ex:'yyyy,MM,dd,hh,mm,ss',tt:'Filter data on date'},
	{p:'endDate',ex:'yyyy,MM,dd,hh,mm,ss',tt:'Filter data on date'},

	{label:'Events'},

	{p:DisplayEvent.filterChanged.share,ex:true,tt:'Share filter changed'},
	{p:DisplayEvent.filterChanged.accept,ex:true,tt:'Accept filter changed'},
	{p:DisplayEvent.filterChanged.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.filterChanged.acceptGroup,tt:'Only share in this group'},		

	{p:DisplayEvent.recordSelection.share,ex:true,tt:'Share record selection'},
	{p:DisplayEvent.recordSelection.accept,ex:true,tt:'Accept record selection'},
	{p:DisplayEvent.recordSelection.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.recordSelection.acceptGroup,tt:'Only share in this group'},

	{p:DisplayEvent.recordHighlight.share,ex:true,tt:'Share record highlight'},
	{p:DisplayEvent.recordHighlight.accept,ex:true,tt:'Accept record highlight'},
	{p:DisplayEvent.recordHighlight.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.recordHighlight.acceptGroup,tt:'Only share in this group'},			

	{p:DisplayEvent.recordList.share,ex:true,tt:'Share record list'},
	{p:DisplayEvent.recordList.accept,ex:true,tt:'Accept record list'},
	{p:DisplayEvent.recordList.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.recordList.acceptGroup,tt:'Only share in this group'},


	{p:DisplayEvent.fieldsChanged.share,ex:true,tt:'Share fields changed'},
	{p:DisplayEvent.fieldsChanged.accept,ex:true,tt:'Accept fields changed'},
	{p:DisplayEvent.fieldsChanged.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.fieldsChanged.acceptGroup,tt:'Only share in this group'},		

	{p:DisplayEvent.setEntry.share,ex:true,tt:'When displaying entries as data this shares the selected entry with other displays'},
	{p:DisplayEvent.setEntry.accept,ex:true,tt:'When displaying entries as data this accepts the new entry'},
	{p:DisplayEvent.setEntry.shareGroup,tt:'When sharing the entry this groups what displays to share with'},
	{p:DisplayEvent.setEntry.acceptGroup,tt:'When sharing the entry this must match with the shareGroup'},		

	{p:'acceptEventDataSelection',ex:true,tt:'accept new data coming from other displays'},

	{label:'Convert Data'},
	{p:'binDate',ex:'day|month|year',tt:'Bin the dates'},
	{p:'binType',ex:'count|average|total'},
	{p:'groupBy',ex:'field',tt:'Group the data'},
	{p:'aggregateBy',tt:'Add an extra row for the aggregated rows'},
	{p:'aggregateOperator',ex:'sum|percent',tt:'Operator to apply on the aggregated rows'},
	{p:'aggregateOperator.fieldName',ex:'sum|percent',tt:'Operator to apply on the aggregated rows for the given field'},	
	{p:'convertData', label:'derived data', ex:'derived(field=new_field_id, function=foo*bar);',tt:'Add derived field'},
	{p:'convertData',label:'merge rows',ex:'mergeRows(keyFields=f1\\\\,f2, operator=count|sum|average, valueFields=);',tt:'Merge rows together'},
	{p:'convertData',label:'percent increase',ex:'addPercentIncrease(replaceValues=false);',tt:'Add percent increase'},
	{p:'convertData',label:'doubling rate',ex:'doublingRate(fields=f1\\\\,f2, keyFields=f3);',tt:'Calculate # days to double'},
	{p:'convertData',label:'add fixed',ex:'addFixed(id=max_pool_elevation\\\\,value=3700,type=double);"',tt:'add fixed value'},	
	{p:'convertData',label:'unfurl',ex:'unfurl(headerField=field to get header from,uniqueField=e.g. date,valueFields=);',tt:'Unfurl'},
	{p:'convertData',label:'Accumulate data',ex:'accum(fields=);',tt:'Accumulate'},
	{p:'convertData',label:'Add an average field',ex:'mean(fields=);',tt:'Mean'},
	{p:'convertData',label:'Count uniques',ex:'count(field=,sort=true,label=Count);',tt:'Count uniques'},
	{p:'convertData',label:'rotate data', ex:'rotateData(includeFields=true,includeDate=true,flipColumns=true);',tt:'Rotate data'},
	{p:'convertData',label:'Prune where fields are all NaN',ex:'prune(fields=);',tt:'Prune'},		
	{p:'convertData',label:'Scale and offset',ex:'accum(scale=1,offset1=0,offset2=0,unit=,fields=);',tt:'(d + offset1) * scale + offset2'},		
	{p:'convertDataPost',label:'Same as above but after filtering is done',tt:'Same as above but after filtering is done'},		
	{label:'Color'},
	{p:'colors',ex:'color1,...,colorN',tt:'Comma separated array of colors'},
	{p:'colorBy',ex:'',tt:'Field id to color by'},
	{p:'colorByFields',ex:'',tt:'Show color by fields in a menu'},
	{p:'colorByLog',ex:'true',tt:'Use a log scale for the color by'},
	{p:'colorByMap',ex:'value1:color1,...,valueN:colorN',tt:'Specify colors for color by text values'},
	{p:'colorTableAlpha',ex:0.5,tt:'Set transparency on color table values'},
	{p:'colorTableInverse',ex:true,tt:'Inverse the color table'},
	{p:'colorTablePruneLeft',ex:'N',tt:'Prune first N colors'},
	{p:'colorTablePruneRight',ex:'N',tt:'Prune last N colors'},
	{p:'colorByMin',ex:'value',tt:'Min scale value'},
	{p:'colorByMax',ex:'value',tt:'Max scale value'},
	{p:'nullColor',ex:'transparent'},
	{p:'showColorTable',ex:'false',tt:'Display the color table'},
	{p:'colorTableLabel',ex:''},
	{p:'showColorTableDots',ex:true},
	{p:'colorTableDotsDecimals',ex:'0'},
	{p:'colorTableSide',ex:'bottom|right|left|top'},
	{p:'showColorTableStride',ex:1,tt:'How many colors should be shown'},
	{p:'colorByAllRecords',ex:true,tt:'use all records for color range'},
	{p:'convertColorIntensity',ex:true},
	{p:'intensitySourceMin',ex:'0'},
	{p:'intensitySourceMax',ex:100},
	{p:'intensityTargetMin',ex:1},
	{p:'intensityTargetMax',ex:0},
	{p:'convertColorAlpha',ex:true},
	{p:'alphaSourceMin',ex:0},
	{p:'alphaSourceMax',ex:100},
	{p:'alphaTargetMin',ex:0},
	{p:'alphaTargetMax',ex:1},
	{label:'Animation'},
	{p:'doAnimation',ex:true},
	{p:'animationHighlightRecord',ex:true},
	{p:'animationHighlightRecordList',ex:true},
	{p:'acceptEventAnimationChange',ex:false},
	{p:'acceptDateRangeChange',ex:true},
	{p:'animationDateFormat',ex:'yyyy'},
	{p:'animationLabelSize',ex:'12pt'},
	{p:'animationStyle'},				
	{p:'animationTooltipShow',ex:'true'},
	{p:'animationTooltipDateFormat',ex:'yyyymmddhhmm'},		
	{p:'animationMode',ex:'sliding|frame|cumulative'},
	{p:'animationWindow',ex:'1 day|2 weeks|3 months|1 year|2 decades|etc'},
	{p:'animationStep',ex:'1 day|2 weeks|3 months|1 year|2 decades|etc'},
	{p:'animationSpeed',ex:500},
	{p:'animationLoop',ex:true},
	{p:'animationDwell',ex:1000},
	{p:'animationStartShowAll',ex:true,tt:'Show full range at start'},
	{p:'animationShowButtons',ex:false},
	{p:'animationShowLabel',ex:false},
	{p:'animationShowSlider',ex:false},
	{p:'animationWidgetShort',ex:true},
	{p:'selectFirst',ex:true,tt:'Select the first record when animating so other displays will hilight it'},
	{p:'selectLast',ex:true,tt:'Select the last record when animating so other displays will hilight it'},
    ];

    displayDefineMembers(this,myProps, {
        displayReady: Utils.getPageLoaded(),
        type: argType,
        displayManager: argDisplayManager,
        filters: [],
        dataCollection: new DataCollection(),
        selectedCbx: [],
        entries: [],
        wikiAttrs: [TITLE, "showTitle", "showDetails", "minDate", "maxDate"],
	_properties:[],
	callHook:function(func,arg1,arg2,arg3,arg4) {
	    func = "hook_" + func;
	    func = this.getProperty(func,func);
	    if(func=="none") return null;
	    if(!window[func]) {
		func = this.type+"_"+func;
	    }
	    if(window[func]) {
//		console.log("calling:" + func);
		return window[func](this,arg1,arg2,arg3,arg4);
	    } else {
//		console.log("no hook:" + func);
	    }

	},

	getWikiEditorTags: function() {
	    return this._wikiTags;
	},
	getTypeDef: function() {
	    return this.typeDef;
	},
	getTypeLabel: function() {
	    if(!this.typeDef) return null;
	    return this.typeDef.label;
	},
	getTypeHelpUrl: function() {
	    if(!this.typeDef) return null;
	    let helpUrl = this.typeDef.helpUrl;
	    if(!helpUrl) return null;
	    if(helpUrl===true) {
		return "https://ramadda.org/repository/alias/help_" + this.typeDef.type;
	    }
	    return helpUrl;
	},
	defineSizeByProperties: function() {
	    this.defineProperties([
		{inlineLabel:'Size By'},
	    	{p:'sizeBy',ex:'field',tt:'Field to size points by'},
		{p:'sizeByLog',ex:true,tt:'Use log scale for size by'},
		{p:'sizeByMap', ex:'value1:size,...,valueN:size',tt:'Define sizes if sizeBy is text'},
		{p:'sizeByRadiusMin',ex:'2',tt:'Scale size by'},
		{p:'sizeByRadiusMax',ex:'20',tt:'Scale size by'},
		{p:'sizeByLegendSide',ex:'bottom|top|left|right'},,
		{p:'sizeByLegendStyle'},
		{p:'sizeBySteps',ex:'value1:size1,v2:s2,...',tt:'Use steps for sizes'},
	    ]);
	},

        getDisplayManager: function() {
            return this.displayManager;
        },
        getLayoutManager: function() {
            return this.getDisplayManager().getLayoutManager();
        },
        addToDocumentUrl: function(key, value) {
	    HU.addToDocumentUrl("display"+ this.displayCount+"." + key,value);
	},

	createTagDialog: function(cbxs,  anchor,cbxChange, type,label) { 
	    let cbxInner = HU.div([STYLE,HU.css("margin","5px", "width","600px;","max-height","300px","overflow-y","auto")],    Utils.wrap(cbxs,"",""));
	    let inputId = HU.getUniqueId("input_");
	    let input = HU.input("","",[STYLE,HU.css("width","300px;"), 'placeholder','Search for ' + label.toLowerCase(),ID,inputId]);
	    let contents = HU.div([STYLE,HU.css("margin","10px")], HU.center(input) + cbxInner);
	    if(!this.tagDialogs) this.tagDialogs = {};
	    if(this.tagDialogs[type]) this.tagDialogs[type].remove();
	    let dialog = HU.makeDialog({content:contents,anchor:anchor,title:label,
					draggable:true,header:true});
	    this.tagDialogs[type] = dialog;
	    dialog.find(":checkbox").change(cbxChange);
	    let tags = dialog.find(".display-search-tag");
	    $("#"+inputId).keyup(function(event) {
		let text = $(this).val().trim().toLowerCase();
		tags.each(function() {
		    if(text=="")
			$(this).show();
		    else {
			let tag = $(this).attr("tag");
			if(tag) {
			    tag = tag.toLowerCase();
			    if(tag.indexOf(text)>=0)
				$(this).show();
			    else
				$(this).hide();
			}
		    }
		});
	    });
	    return dialog;
	},
	getAnimationEnabled: function() {
	    return this.getProperty("doAnimation", false);
	},
	getAnimation: function() {
	    if(!this.animationControl) {
		this.animationControl = new DisplayAnimation(this,this.getAnimationEnabled());
	    }
	    return this.animationControl;
	},
        propagateEvent: function(event, data) {
	    this.getDisplayManager().notifyEvent(event,this,data);
        },
        displayError: function(msg) {
            this.displayHtml(HU.getErrorDialog(msg));
        },
        clearHtml: function() {
            this.displayHtml("");
        },
        displayHtml: function(html) {
            this.setContents(html);
        },
	getEventHandler:function(event) {
	    return this[event.handler];
	},
        notifyEvent: function(event, source, data) { 
	    let func = this.getEventHandler(event);
            if (func==null) {
		if(displayDebug.notifyEvent)
		    console.log(this.type+".notifyEvent no event handler function:" + event.name  +" " + event.handler);
                return;
            }
	    if(displayDebug.notifyEvent)
		console.log(this.type+".notifyEvent calling function:" + func.name);
            func.apply(this, [source, data]);
        },
	getColorTableHorizontal: function() {
	    return this.getProperty("colorTableSide","bottom") == "bottom" || this.getProperty("colorTableSide","bottom") == "top";
	},
        displayColorTable: function(ct, domId, min, max, args) {
	    if(!args) args = {};
	    args.showColorTableDots = this.getProperty("showColorTableDots");
	    args.decimals = this.getProperty("colorTableDotsDecimals",-1);
	    args.showRange = this.getProperty("colorTableShowRange");
	    let labels = this.getProperty("colorTableLabels");
	    args.labels = labels?labels.split(","):null;
	    args.labelStyle=this.getProperty("colorTableLabelStyle","font-size:12pt;");
	    args.horizontal= this.getColorTableHorizontal();
	    args.stride = this.getProperty("showColorTableStride",1);
            Utils.displayColorTable(ct, this.getDomId(domId), min, max, args);
	    let label = this.getColorTableLabel();
	    if(label) {
		if(args.field) label = label.replace("${field}", args.field.getLabel());
		this.jq(domId).prepend(HU.center(label));
	    }
	    if(!args || !args.colorByInfo) return;
	    this.jq(domId).find(".display-colortable-slice").css("cursor","pointer");
	    let _this = this;
	    if(!this.originalColorRange) {
		this.originalColorRange = [min,max];
	    }		
	    this.jq(domId).find(".display-colortable-slice").click(function(e) {
		let val = $(this).attr("data-value");
		let popup = HtmlUtils.getTooltip();
		HtmlUtils.setPopupObject(popup);
		let html = "";
		html += HU.div([CLASS,"ramadda-menu-item","what","setmin"],"Set range min to " + Utils.formatNumber(val));
		html += HU.div([CLASS,"ramadda-menu-item","what","setmax"],"Set range max to " + Utils.formatNumber(val));
		html += HU.div([CLASS,"ramadda-menu-item","what","reset"],"Reset range");
		if(_this.getProperty("colorByLog")) {
		    html += HU.div([CLASS,"ramadda-menu-item","what","togglelog"],"Use linear scale");
		} else {
		    html += HU.div([CLASS,"ramadda-menu-item","what","togglelog"],"Use log scale");
		}
		html += Utils.getColorTablePopup();
		popup.html(html);
		$(popup).find(".ramadda-colortable-select").click(function() {
		    let ct = $(this).attr("colortable");
		    if(ct) {
			console.log("color table:" + ct);
			_this.setProperty("colorTable",ct);
			_this.forceUpdateUI();
		    }		    
		});
		popup.show();
		popup.position({
                    of: $(this),
                    my: 'left top',
                    at: 'left bottom',
                    collision: "none none"
		});
		popup.find(".ramadda-menu-item").click(function() {
		    let what = $(this).attr("what");
		    if(what == "reset") {
			_this.setProperty("colorByMin",_this.getProperty("colorByMinOrig"));
			_this.setProperty("colorByMax",_this.getProperty("colorByMaxOrig"));
			_this.setProperty("overrideColorRange", false);
		    } else if(what == "togglelog") {
			if(!_this.getProperty("colorByLog")) 
			    _this.setProperty("colorByLog",true);
			else
			    _this.setProperty("colorByLog",false);
 		    } else if(what == "setmin") {
			if(!Utils.isDefined(_this.getProperty("colorByMinOrig"))) {
			    _this.setProperty("colorByMinOrig",_this.getProperty("colorByMin"));
			}
			_this.setProperty("colorByMin",val);
			_this.setProperty("overrideColorRange", true);
		    } else {
			if(!Utils.isDefined(_this.getProperty("colorByMaxOrig"))) {
			    _this.setProperty("colorByMaxOrig",_this.getProperty("colorByMax"));
			}
			_this.setProperty("colorByMax",val);
			_this.setProperty("overrideColorRange", true);
		    }
		    _this.forceUpdateUI();
		});
	    });
        },
	getUnhighlightColor: function() {
	    return this.getProperty("unhighlightColor","#eee");
	},
	getColorList:function() {
	    if(this.colorList && this.colorList.length>0) {
		return this.colorList;
	    }
	    if (this.getProperty("colors") && this.getProperty("colors")!="default") {
		var v = this.getProperty("colors");
		if(!Array.isArray(v)) {
		    v = v.split(",");
		}
		this.colorList =  v;
	    }
	    if(!this.colorList || this.colorList.length==0) {
		this.colorList= ['blue', 'red', 'green', 'orange', 'fuchsia', 'aqua',   'navy', 'brown','cadetblue','blueviolet','coral','cornflowerblue','darkcyan','darkgoldenrod','darkorange','darkseagreen'];
	    }
	    return this.colorList;
	},
        getColorTableName: function(names) {
	    if(names && !Array.isArray(names)) {
		names  = [names];
	    }
            let ct = null;
            if (names) {
		names.every(name=>{
                    ct = this.getProperty(name);
		    if(ct) return false;
		    return true;
		});
            } else {
		var colorBy = this.getProperty("colorBy");
		if(colorBy) {
                    ct = this.getProperty("colorTable." + colorBy);
		}
		if(!ct) {
                    ct = this.getProperty("colorBar", this.getProperty("colorTable"));
		}
            }
            if (ct == "none") return null;
            return ct;
        },
	getColorTable: function(justColors, name, dflt) {
            let colorTable = this.getColorTableName(name);
            if (!colorTable) {
                colorTable = dflt;
            }
	    return this.getColorTableInner(justColors, colorTable);
	},
	getColorTableInner: function(justColors, colorTable) {
	    let list;
            if (colorTable) {
                let ct = null;
 		if(colorTable.startsWith("colors:")) {
		    list = colorTable.substring("colors:".length).split(",");
                    return this.convertColors(list);
		}
                ct = Utils.ColorTables[colorTable];
                if (ct && justColors) {
		    return this.convertColors(ct.colors);
		}
                if (!ct && name) {
                    return this.convertColors(colorTable.split(","));
                }
                return ct;
            }
            if (this.getProperty("colors") && this.getProperty("colors")!="default") {
                var colors = this.getProperty("colors");
                if ((typeof colors) != "object") colors = colors.split(",");
		return this.convertColors(colors);
            }
            return null;
        },
	addAlpha: function(colors, alpha) {
	    if(!colors) return null;
	    alpha = Utils.isDefined(alpha)?alpha:this.getProperty("colorTableAlpha");
	    if(!alpha) return colors;
	    colors=  Utils.cloneList(colors);
	    var ac = [];
	    colors.forEach((c)=>{
		ac.push(Utils.addAlphaToColor(c,alpha));
	    });
	    return ac;
        },
        convertColors: function(colors) {
	    colors = this.addAlpha(colors);
	    if(this.getColorTableInverse()) {
		let tmp = [];
		for(let i=colors.length-1;i>=0;i--)
		    tmp.push(colors[i]);
		colors = tmp;
	    }
	    if(this.getProperty("colorTablePruneLeft")) {
		let tmp = [];
		for(let i=+this.getProperty("colorTablePruneLeft");i<colors.length;i++) {
		    tmp.push(colors[i]);
		}
		colors = tmp;
	    }
	    if(this.getProperty("colorTablePruneRight")) {
		let tmp = [];
		let d = +this.getProperty("colorTablePruneRight");
		for(let i=0;i<colors.length-d;i++) {
		    tmp.push(colors[i]);
		}
		colors = tmp;
	    }
	    return colors;
	},

        getColorByColors: function(records, dfltColorTable) {
            var colorBy = this.getProperty("colorBy");
            if (!colorBy) {
                return null;
            }
            var colorByField = this.getFieldById(fields, colorBy);
            if (!colorByField) {
                return null;
            }
            var obj = this.getColumnValues(records, colorByField);
            var colors = this.getColorTable();
            if (!colors) colors = Utils.getColorTable(dfltColorTable || "blue_white_red");
            if (!colors) return null;
            var min = parseFloat(this.getProperty("colorByMin", obj.min));
            var max = parseFloat(this.getProperty("colorByMax", obj.max));
            if (colors.colors) colors = colors.colors;
            var range = max - min;
            var colorValues = [];
            for (var i = 0; i < obj.values.length; i++) {
                var value = obj.values[i];
                var percent = (value - min) / range;
                var index = parseInt(percent * colors.length);
                if (index >= colors.length) index = colors.length - 1;
                else if (index < 0) index = 0;
                colorValues.push(colors[index]);
            }
            return {
                colors: colorValues,
                min: min,
                max: max
            };
        },
	getDefaultGridByArgs: function() {
	    let doHeatmap=this.getProperty("doHeatmap",false);
	    let args =  {
		display:this,
		shape:this.getProperty("cellShape","rect"),
		color: this.getProperty("cellColor","blue"),
		stroke: !this.getProperty("cellFilled",true),
		cellSize: this.getProperty("cellSize",doHeatmap?0:4),
		cellSizeH: this.getProperty("cellSizeH",20),
		cellSizeHBase: this.getProperty("cellSizeHBase",0),
		cell3D:this.getProperty("cell3D",false),
		cellShowText:this.getProperty("cellShowText",false),
		cellLabels:Utils.split(this.getProperty("cellLabels")),
		cellFonts:Utils.split(this.getProperty("cellFonts")),
		cellLabelColors:Utils.split(this.getProperty("cellLabelColor")),
		cellLabelPositions:Utils.split(this.getProperty("cellLabelPositions")),
		cellLabelOffsetsX:Utils.split(this.getProperty("cellLabelOffsetsX")),
		cellLabelOffsetsY:Utils.split(this.getProperty("cellLabelOffsetsY")),
		doHeatmap:doHeatmap,
		operator:this.getProperty("hm.operator",this.getProperty("hmOperator","count")),
		filter:this.getProperty("hm.filter",this.getProperty("hmFilter"))
	    };
	    args.cellSizeX = +this.getProperty("cellSizeX",args.cellSize);
	    args.cellSizeY = +this.getProperty("cellSizeY",args.cellSize);
	    return args;
	},
	getIconMap: function() {
	    var iconMap;
	    var iconMapProp = this.getProperty("iconMap");
	    if (iconMapProp) {
                var toks = iconMapProp.split(",");
		iconMap = {};
                for (var i = 0; i < toks.length; i++) {
		    var toks2 = toks[i].split(":");
		    if (toks2.length > 1) {
                        iconMap[toks2[0]] = toks2[1];
		    }
		}
            }
	    return iconMap;
	},
	getColorByInfo: function(records, prop,colorByMapProp, defaultColorTable,propPrefix,lastColorBy) {
            let pointData = this.getData();
            if (pointData == null) return null;
	    if(this.getProperty("colorByAllRecords")) {
		records = pointData.getRecords();
	    }
	    let fields = pointData.getRecordFields();
	    return new ColorByInfo(this, fields, records, prop,colorByMapProp, defaultColorTable, propPrefix,null,null,lastColorBy);
	},
	getColorByMap: function(prop) {
	    prop = this.getProperty(prop||"colorByMap");
	    this.debugGetProperty=false;
	    return Utils.parseMap(prop);
        },
        toString: function() {
            return  this.type + " - " + this.getId();
        },
        getType: function() {
            return this.type;
        },
        getClass: function(suffix) {
            if (suffix == null) {
                return this.getBaseClass();
            }
            return this.getBaseClass() + "-" + suffix;
        },
        getBaseClass: function() {
            return "display-" + this.getType();
        },
        setDisplayManager: function(cm) {
            this.displayManager = cm;
            this.setDisplayParent(cm.getLayoutManager());
        },
        setContents: function(contents,dontWrap) {
            this.clearDisplayMessage();
            if(!dontWrap)
		contents = HU.div([ATTR_CLASS, "display-contents-inner display-" + this.getType() + "-inner"], contents);
            this.writeHtml(ID_DISPLAY_CONTENTS, contents);
        },
        addEntry: function(entry) {
            this.entries.push(entry);
        },
        clearCachedData: function() {},
        setEntry: function(entry) {
	    if(displayDebug.setEntry)
		console.log(this.type+".setEntry:" + entry);
            this.entries = [];
            this.addEntry(entry);
            this.entry = entry;
            this.entryId = entry.getId();
            this.clearCachedData();
            if (this.properties.theData) {
                this.dataCollection = new DataCollection();
                let attrs = {
                    entryId: this.entryId,
                    lat: this.getProperty("latitude"),
                    lon: this.getProperty("longitude"),
                };
		let oldUrl=  this.properties.theData.url;
		if(!oldUrl) {
		    oldUrl = this.getRamadda().getRoot() + "/entry/show?entryid=" + entry.getId() + "&output=points.product&product=points.json&max=5000";
		} else {
		    //this should work
		    oldUrl = oldUrl.replace(/entryid=.*?&/,"entryid=" + entry.getId()+"&");
		}
                this.properties.theData = this.data = new PointData(entry.getName(), null, null, oldUrl, attrs);
		this.startProgress();
                this.data.loadData(this);
            } else {
		this.callUpdateUI();
	    }
            var title = "";
            if (this.getShowTitle()) {
                this.jq(ID_TITLE).html(entry.getName());
            }
        },
        getTextColor: function(property, dflt) {
            if (property) return this.getProperty(property, this.getProperty("textColor",dflt));
            return this.getProperty("textColor", "#000");
        },
        getTitleHtml: function(title) {
            var titleToShow = "";
            if (this.getShowTitle()) {
                var titleStyle = HU.css("color" , this.getTextColor("titleColor","#000"));
                var bg = this.getProperty("titleBackground");
                if (bg) titleStyle += HU.css('background', bg,'padding','2px','padding-right','6px','padding-left','6px');
                titleToShow = this.getShowTitle() ? this.getDisplayTitle(title) : "";
		let entryId = this.getProperty("entryId") || this.entryId;
                if (entryId) {
                    titleToShow = HU.href(this.getRamadda().getEntryUrl(entryId), titleToShow, [ATTR_CLASS, "display-title",  STYLE, titleStyle]);
		}
		titleToShow =HU.span([ID,this.domId(ID_TITLE)],titleToShow);
            }

	    if(this.getProperty("showEntryIcon")) {
		let icon = this.getProperty("entryIcon");
		if(icon) titleToShow  = HU.image(icon) +" " + titleToShow;
	    }
            return titleToShow;
        },
        handleEventMapClick: function(source, args) {
            if (!this.dataCollection) return;
            var pointData = this.dataCollection.getList();
            for (var i = 0; i < pointData.length; i++) {
                pointData[i].handleEventMapClick(this, source, args.lon, args.lat);
            }
        },
	acceptEvent:function(event,dflt) {
	    return this.getProperty(event.accept,dflt);
	},
	shareEvent:function(event,dflt) {
	    return this.getProperty(event.share,dflt);
	},	
        handleEventMapBoundsChanged: function(source, args) {
	    if(this.acceptEvent(DisplayEvent.mapBoundsChanged,this.getProperty("acceptBoundsChange"))) {
		this.filterBounds  = args.bounds;
		this.callUpdateUI();
            }
        },

        handleEventFilterFieldsSelected: function(source, fields) {
	    if(fields.length>0 && (typeof fields[0] =="string")) {
		var tmp = [];
		fields.forEach(f=>{
		    f = this.getFieldById(null, f);
		    if(f) tmp.push(f);
		});
		fields=tmp;
	    }
	    let prop = "";
	    fields.forEach(f=>{
		if(prop!="") prop+=",";
		prop+=f.getId();
	    });

	    this.setProperty("filterFields",prop);
	    this.haveCalledUpdateUI = false;
            this.checkSearchBar();
        },


        handleEventFieldValueSelected: function(source, args) {
            this.setProperty("filterPattern", args.value);
            this.setProperty("patternFilterField", args.field.getId());
            this.callUpdateUI();
        },
        setDateRange: function(min, max, doDay) {
	    this.minDateObj = min;
	    this.maxDateObj = max;
	    this.dateRangeDoDay = doDay;
//	    console.log("setDateRange: " + this.minDateObj +" " + this.maxDateObj);
	},
        handleDateRangeChanged: function(source, prop) {
	    this.setDateRange(prop.minDate, prop.maxDate);
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().setDateRange(prop.minDate, prop.maxDate);
	    }
	    this.haveCalledUpdateUI = false;
	    this.dataFilterChanged();
	},
	displayFieldsChanged:  function(val, fromElsewhere) {
	    this.addToDocumentUrl(PROP_FIELDS,val);
	    this.setProperty(PROP_FIELDS,val);
	    this.callUpdateUI();
    
	    if(this.displayFieldsMenuEnums && fromElsewhere && this.getProperty("showDisplayFieldsMenu")) {
		let selected = [];
		this.jq("displayfields").val(val);
	    }
	},
        handleEventFilterChanged: function(source, prop) {
	    if(!this.acceptEvent(DisplayEvent.filterChanged, this.getProperty("acceptEventFilter",true))) {
		return;
	    }
	    this.haveCalledUpdateUI = false;
	    let properties = prop.properties;
	    if(!properties) {
		properties=[];
		properties.push(prop);
	    }
	    this.settingFilterValue = true;
	    properties.forEach(prop=> {
		let filter = this.filterMap?this.filterMap[prop.fieldId]:null;
		if(!filter) return;
		let widgetId = this.getFilterId(prop.fieldId);
		if(prop.id && prop.id.endsWith("date1")) {
		    widgetId+="_date1";
		} else 	if(prop.id && prop.id.endsWith("date2")) {
		    widgetId+="_date2";
		}
		if(prop.fieldId == "_highlight") {
		    this.jq(ID_FILTER_HIGHLIGHT).val(prop.value);
		    this.setProperty("filterHighlight", prop.value=="highlight");
		} else 	if(Utils.isDefined(prop.value2)) {
		    $("#" +widgetId+"_min").val(prop.value);
		    $("#" +widgetId+"_min").attr("data-value", prop.value);
		    $("#" +widgetId+"_max").val(prop.value2);
		    $("#" +widgetId+"_max").attr("data-value", prop.value2);
		} else {
		    filter.handleEventPropertyChanged(prop);
		}
	    });
	    this.settingFilterValue = false;
	    this.dataFilterChanged();
	},
        handleEventPropertyChanged: function(source, prop) {
	    let debug = displayDebug.handleEventPropertyChanged;
	    if(prop.property == "dateRange") {
		if(this.getProperty("acceptDateRangeChange")) {
		    this.handleDateRangeChanged(source, prop);
		}
		return;
	    }
	    
	    if(prop.property == "displayFields") {
		if(!this.acceptEvent(DisplayEvent.fieldsChanged,!this.getProperty("acceptEventDisplayFieldsChange",false))) {
		    return;
		}
		this.displayFieldsChanged(prop.value, true);
		return
	    }

	    if(prop.property == "macroValue") {
		if(prop.entryId!= this.entryId) return;
		if(!this.getProperty("acceptRequestChangeEvent",true)) {
		    return;
		}
		let macros = this.getRequestMacros();
		let macro = null;
		macros.every(m=>{
		    if(m.isMacro(prop.id)) {
			macro = m;
			return false;
		    }
		    return true;
		});

		if(!macro) {
		    return;
		}

		if(!this.getProperty("request." + macro.name + ".acceptChangeEvent",true)) {
		    return;
		}

		macro.setValue(prop);



		if(debug)
		    console.log(this.getId() +" event-reloading");
		this.reloadData();
		return;
	    }

            this.setProperty(prop.property, prop.value);
            this.callUpdateUI();
        },
        handleEventRecordList: function(source, args) {
	    if(this.getAnimationEnabled() && this.getProperty("animationHighlightRecordList")) {
		this.getAnimation().setRecordListHighlight(args.recordList);
	    }
	    if(this.getProperty("acceptEventRecordList",false)) {
		this.recordListOverride = args.recordList;
		this.haveCalledUpdateUI = false;
		this.callUpdateUI();
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    if(this.getAnimation().getEnabled() &&  !args.skipAnimation) {
		this.getAnimation().handleEventRecordHighlight(source, args);
	    }
	},
        handleEventAnimationChanged: function(source, args) {
	    if(!this.getProperty("acceptEventAnimationChange",true)) return;
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().handleEventAnimationChanged(args);
	    }
	},
        handleEventSetEntry: function(source, args) {
	    if(this.acceptEvent(DisplayEvent.setEntry,this.getProperty(DisplayEvent.setEntry.acceptGroup,this.getProperty("acceptShareSelectedEntry",false)))) {
		if(displayDebug.setEntry)
		    console.log(this.type+".handleEventSetEntry calling setEntry:" + args.entry);
		this.setEntry(args.entry);
	    } else {
		if(displayDebug.setEntry)
		    console.log(this.type+".handleEventSetEntry not calling setEntry:" + args.entry);
	    }
	},
        propagateEventRecordSelection: function(args) {
	    if(displayDebug.notifyEvent)
		console.log(this.type+".propagateEventRecordSelection");
	    if(this.shareEvent(DisplayEvent.setEntry,this.getProperty(DisplayEvent.setEntry.shareGroup,this.getProperty("shareSelectedEntry")))) {
		let entryId = args.record.getValueFromField("id");
		if(displayDebug.setEntry)
		    console.log(this.type+" sharing entry:" + entryId);
		if(entryId) {
		    let _this = this;
		    setTimeout(async function(){
			await getGlobalRamadda().getEntry(entryId, entry => {
			    if(displayDebug.setEntry)
				console.log(_this.type+" calling notifyEvent with entry:" + entry);
			    _this.getDisplayManager().notifyEvent(DisplayEvent.setEntry, _this, {entry:entry});
			});
		    });
		}
	    }
	    if(this.shareEvent(DisplayEvent.recordSelection,true)) {
		this.getDisplayManager().notifyEvent(DisplayEvent.recordSelection, this, args);
	    }
	    if(this.getProperty("recordSelectFilterFields")) {
		let fields = this.getFieldsByIds(null,this.getProperty("recordSelectFilterFields"));
		if(fields && fields.length>0) {
		    let props = {
			properties:[]
		    };
		    fields.forEach(field=>{
			props.properties.push({
			    id:field.getId(),
			    fieldId: field.getId(),
			    value: args.record.getValue(field.getIndex())
			});
		    })
		    this.propagateEvent(DisplayEvent.filterChanged, props);
		}
	    }
	},
        handleEventRecordSelection: function(source, args) {
	    this.selectedRecord= args.record;
	    if(this.selectedRecord) {
		if(this.getProperty("colorThresholdField")) {
		    this.haveCalledUpdateUI = false;
		    this.callUpdateUI();
		}
	    }
            if (!source.getEntries) {
                return;
            }
            let entries = source.getEntries();
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let containsEntry = this.getEntries().indexOf(entry) >= 0;
                if (containsEntry) {
                    this.highlightEntry(entry);
                    break;
                }
            }
        },
        areaClear: function() {
            this.getDisplayManager().notifyEvent("areaClear", this);
        },
        handleEventEntryMouseover: function(source, args) {},
        handleEventEntryMouseout: function(source, args) {},
        handleEventEntrySelection: function(source, args) {
            var containsEntry = this.getEntries().indexOf(args.entry) >= 0;
            if (!containsEntry) {
                return;
            }
            if (args.selected) {
                this.jq(ID_TITLE).addClass("display-title-select");
            } else {
                this.jq(ID_TITLE).removeClass("display-title-select");
            }
        },
        highlightEntry: function(entry) {
            this.jq(ID_TITLE).addClass("display-title-select");
        },
        getEntries: function() {
            return this.entries;
        },
        getDisplayEntry: async function(callback) {
            var entries = this.getEntries();
            if (entries != null && entries.length > 0) {
                return Utils.call(callback, entries[0]);
            }
	    let entryId = this.entryId|| this.getProperty("entryId");
            if (entryId) {
                var entry;
                await this.getRamadda().getEntry(entryId, e => {
                    entry = e
                    Utils.call(callback, entry);
                });
            } else {
		Utils.call(callback, null);
	    }
        },
        hasEntries: function() {
            return this.entries != null && this.entries.length > 0;
        },
        getWaitImage: function() {
            return HU.image(ramaddaCdn + "/icons/progress.gif");
        },
	useDisplayMessage:function() {
	    return true;
	},
	setDisplayMessage:function(msg) {
	    if(!Utils.stringDefined(msg)) {
		this.jq(ID_DISPLAY_MESSAGE).html("").hide();
		return;
	    }
	    let contents =  this.jq(ID_DISPLAY_CONTENTS);
	    let minHeight = contents.css("min-height");
	    if(!minHeight || minHeight=="0px") {
		contents.css("min-height","75px");
		contents.attr("display-set-minheight","true");
	    }
	    this.jq(ID_DISPLAY_MESSAGE).html(msg).show();
	},
	clearDisplayMessage:function() {
	    let contents =  this.jq(ID_DISPLAY_CONTENTS);
	    this.jq(ID_DISPLAY_MESSAGE).hide();
	    if(contents.attr("display-set-minheight")!=null) {
		contents.css("min-height","");
	    }
	},	
        getLoadingMessage: function(msg) {
	    if(this.getAcceptEventDataSelection()) {
		return "";
	    }

	    //Check if we didn't have any data specified
	    if(!msg && !this.getProperty("theData")) {
		msg = "No data specified"
	    }
	    if (!msg) msg = this.getProperty("loadingMessage", "icon_progress Loading data...");
	    if(msg=="") return "";
	    msg = msg.replace("icon_progress",HU.image(icon_progress));
	    if(this.useDisplayMessage()) {
		return SPACE+msg;
	    } 
            return HU.div([STYLE, HU.css("text-align","center")], this.getMessage(SPACE + msg));
        },
	reloadData: function() {
	    this.startProgress();
	    this.haveCalledUpdateUI = false;
	    if(this.getProperty("okToLoadData",true))  {
		let pointData = this.dataCollection.getList()[0];
		pointData.loadData(this,true);
	    }
	},
        getMessage: function(msg) {
            return HU.div([ATTR_CLASS, "display-output-message"], msg);
        },
	getNoDataMessage: function() {
	    return this.getProperty("noDataMessage","No data available");
	},
        getFieldValue: function(id, dflt) {
            var jq = $("#" + id);
            if (jq.length > 0) {
                return jq.val();
            }
            return dflt;
        },
        getFieldValues: function(id, dflt) {
            var jq = $("#" + id);
            if (jq.length > 0) {
		let v = [];
		jq.each(function(){
		    v.push($(this).val());
		});
		return v;
            }
            return dflt;
        },

        getFooter: function() {
            return HU.div([ATTR_ID, this.getDomId(ID_FOOTER), ATTR_CLASS, "display-footer"],
			  HU.leftRight(HU.div([ATTR_ID, this.getDomId(ID_FOOTER_LEFT), ATTR_CLASS, "display-footer-left"], ""),
				       HU.div([ATTR_ID, this.getDomId(ID_FOOTER_RIGHT), ATTR_CLASS, "display-footer-right"], "")));
        },
        shouldSkipField: function(field) {
            if (this.skipFields && !this.skipFieldsList) {
                this.skipFieldsList = this.skipFields.split(",");
            }

            if (this.skipFieldsList) {
                return this.skipFieldsList.indexOf(field.getId()) >= 0;
            }
            return false;
        },
        fieldSelected: function(event) {
            this.userHasSelectedAField = true;
            this.selectedFields = null;
            this.overrideFields = null;
            this.removeProperty(PROP_FIELDS);
            this.fieldSelectionChanged();
            if (event.shiftKey) {
                let fields = this.getSelectedFields();
                this.propagateEvent(DisplayEvent.fieldsSelected, fields);
            }
        },
        addFieldsCheckboxes: function(argFields) {
            if (!this.hasData()) {
                return;
            }
            var fixedFields = this.getPropertyFields()
            if (fixedFields != null) {
                if (fixedFields.length == 0) {
                    fixedFields = null;
                }
            }

	    let fieldsMap = null;
	    if(fixedFields!=null) {
		if(!Array.isArray(fixedFields)) fixedFields=fixedFields.split(",");
		fieldsMap = {};
		fixedFields.forEach(id=>{
		    if(id.startsWith("#")) {
			let toks = id.split("-");
			if(toks.length==2) {
			    let idx1 = +toks[0].replace("#","");
			    let idx2 = +toks[1].replace("#","");			
			    for(let i=idx1;i<=idx2;i++) {
				fieldsMap["#"+i] = true;
			    }
			}
		    }
		    fieldsMap[id]  = true;
		});
	    }

            var html = "";
            var checkboxClass = this.getId() + "_checkbox";
            var groupByClass = this.getId() + "_groupby";
            var dataList = this.dataCollection.getList();

            if (argFields != null) {
                this.overrideFields = [];
            }
            var seenLabels = {};


            let badFields = {};
            let flags = null;
            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                let pointData = dataList[collectionIdx];
                let fields = this.getFieldsToSelect(pointData);
                if (this.canDoGroupBy()) {
                    let allFields = pointData.getRecordFields();
                    let cnt = 0;
                    for (i = 0; i < allFields.length; i++) {
                        let field = allFields[i];
                        if (field.getType() != "string") continue;
                        if (cnt == 0) {
                            html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Group By");
                            html += HU.open(TAG_DIV, [ATTR_CLASS, "display-fields"]);
                            var on = this.groupBy == null || this.groupBy == "";
                            html += HU.tag(TAG_DIV, [ATTR_TITLE, "none"],
					   HU.radio("none", this.getDomId("groupby"), groupByClass, "none", !on) + " None");
                        }
                        cnt++;
                        var on = this.groupBy == field.getId();
                        var idBase = "groupby_" + collectionIdx + "_" + i;
                        field.radioId = this.getDomId(idBase);
                        html += HU.tag(TAG_DIV, [ATTR_TITLE, field.getId()],
				       HU.radio(field.radioId, this.getDomId("groupby"), groupByClass, field.getId(), on) + " " + field.getUnitLabel() + " (" + field.getId() + ")"
				      );
                    }
                    if (cnt > 0) {
                        html += HU.close(TAG_DIV);
                    }
                }

                let disabledFields = "";
                if ( /*this.canDoMultiFields() && */ fields.length > 0) {
                    let selected = this.getSelectedFields([]);
                    let selectedIds = [];
                    for (let i = 0; i < selected.length; i++) {
                        selectedIds.push(selected[i].getId());
                    }
                    html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Displayed Fields");
                    html += HU.open(TAG_DIV, [ATTR_CLASS, "display-fields"]);
                    for (let tupleIdx = 0; tupleIdx < fields.length; tupleIdx++) {
                        let field = fields[tupleIdx];
                        let idBase = "cbx_" + collectionIdx + "_" + tupleIdx;
                        field.checkboxId = this.getDomId(idBase);
                        let on = false;
                        let hasValues = (flags ? flags[field.getIndex()] : true);
                        //                            console.log(tupleIdx + " field: " + field.getId() + "has values:" + hasValues);
                        if (argFields != null) {
                            //                                console.log("argFields:" + argFields);
                            for (var fIdx = 0; fIdx < argFields.length; fIdx++) {
                                if (argFields[fIdx].getId() == field.getId()) {
                                    on = true;
                                    //                                        console.log("argField:"+ argFields[fIdx].getId()+ " field.id:" + field.getId() +" on:" +on);
                                    this.overrideFields.push(field.getId());
                                    break;
                                }
                            }
                        } else if (selectedIds.length > 0) {
                            on = selectedIds.indexOf(field.getId()) >= 0;
                            //                                console.log("selected ids   on:" + on +" " + field.getId());
                        } else if (fieldsMap != null) {
                            on = fixedFields[field.getId()];
                            if (!on) {
                                on = fixedFields["#" + (tupleIdx + 1)];
                            }
                            //                                console.log("fixed fields  on:" + on +" " + field.getId());
                        } else if (this.overrideFields != null) {
                            on = this.overrideFields.indexOf(field.getId()) >= 0;
                            if (!on) {
                                on = (this.overrideFields.indexOf("#" + (tupleIdx + 1)) >= 0);
                            }
                            //                                console.log("override fields  on:" + on +" " + field.getId());
                        } else {
                            if (this.selectedCbx.indexOf(field.getId()) >= 0) {
                                on = true;
                            } else if (this.selectedCbx.length == 0) {
                                on = (i == 0);
                            }
                            //                                console.log("cbx fields:" + on + " " + field.getId());
                        }
                        let label = field.getUnitLabel();
                        if (seenLabels[label]) {
                            label = label + " " + seenLabels[label];
                            seenLabels[label]++;
                        } else {
                            seenLabels[label] = 1;
                        }

                        if (!hasValues) {
                            disabledFields += HU.div([], label);
                        } else {
                            if (field.derived) {
                                label += " (derived)";
                            }
                            var widget;
                            if (this.canDoMultiFields()) {
                                widget = HU.checkbox(field.checkboxId, [CLASS, checkboxClass], on);
                            } else {
                                widget = HU.radio(field.checkboxId, "field_radio", checkboxClass, "", on);
                            }

                            html += HU.tag(TAG_DIV, [ATTR_TITLE, field.getId()],
					   widget + " " + label
					  );
                        }
                        //                        html+= "<br>";
                    }
                }
                if (disabledFields != "") {
                    html += HU.div([STYLE, HU.css("border-top","1px #888  solid")], "<b>No Data Available</b>" + disabledFields);
                }
                html += HU.close(TAG_DIV);
            }


            this.writeHtml(ID_FIELDS, html);

            this.userHasSelectedAField = false;
            let theDisplay = this;
            //Listen for changes to the checkboxes
            $("." + checkboxClass).click(function(event) {
                theDisplay.fieldSelected(event);
            });

            $("." + groupByClass).change(function(event) {
                theDisplay.groupBy = $(this).val();
                if (theDisplay.displayData) {
                    theDisplay.displayData();
                }
            });
        },
        fieldSelectionChanged: function() {
            this.setDisplayTitle();
            if (this.displayData) {
                this.clearCachedData();
                this.displayData();
            }
        },
        defaultSelectedToAll: function() {
            return true;
        },
        setSelectedFields: function(fields) {
            this.clearCachedData();
            this.selectedFields = fields;
            this.addFieldsCheckboxes(fields);
        },
        getSelectedFields: function(dfltList) {
	    let debug = displayDebug.getSelectedFields;
	    if(debug)
		console.log(this.type +".getSelectedFields");
	    if(this.getBinDate()) {
		var binType = this.getBinType("total");
		var binCount = binType=="count";
		if(binCount) {
		    var fields = [];
		    fields.push(new RecordField({
			id:binType,
			label:this.getProperty("binDateLabel", this.getProperty("binCountLabel","Count")),
			type:"double",
			chartable:true
		    }));		    
		    return fields;
		} 
	    }

            this.debugSelected = debug;
            this.lastSelectedFields = this.getSelectedFieldsInner(dfltList);
	    let notFields = this.getProperty("notFields");
	    if(notFields) {
		let tmp = [];
		this.lastSelectedFields.forEach(f=>{
		    if(f.getId().match(notFields) || f.getLabel().match(notFields)) return;
		    tmp.push(f);
		});
		this.lastSelectedFields = tmp;
	    }


	    if(debug)
		console.log("\tsetting lastSelectedFields:" + this.lastSelectedFields);
            let fixedFields = this.getPropertyFields();

	    //NOT NOW as this nukes the fields property
            //if (fixedFields) fixedFields.length = 0;

            this.setDisplayTitle();
	    if(this.getBinDate()) {
		var binType = this.getProperty("binType","total");
		let fields = [];
		this.lastSelectedFields.forEach(field=>{
		    if(!field.isNumeric()) {
			fields.push(field);
		    } else {
			const prefix = binType;
			if(field.getId().startsWith(prefix)) {
			    fields.push(field);
			} else {
			    fields.push(new RecordField({
				id:prefix +"_"+ field.getId(),
				index:  field.getIndex(),
				label:this.getProperty("binDateLabel", Utils.camelCase(binType) +" of " + field.getLabel()),
				type:"double",
				chartable:field.isChartable()
			    }));
			}
		    }
		});
		this.lastSelectedFields = fields;
//		console.log("BIN DATE:" + this.lastSelectedFields);
	    }
	    //	    console.log("fields:" + this.lastSelectedFields);
	    return Utils.cloneList(this.lastSelectedFields);
        },
        getSelectedFieldsInner: function(dfltList) {
            if (this.debugSelected) {
                console.log("getSelectedFieldsInner dflt:" + (dfltList ? dfltList : "null"));
                console.log("\tlast selected = " + this.lastSelectedFields);
	    }
            if (this.selectedFields) {
                if (this.debugSelected)
                    console.log("\treturning this.selectedFields:" + this.selectedFields);
                return this.selectedFields;
            }
            var df = [];
            var dataList = this.dataCollection.getList();
            //If we have fixed fields then clear them after the first time
            var fixedFields = this.getPropertyFields();
            if (fixedFields && (typeof fixedFields) == "string") {
                fixedFields  = fixedFields.split(",");
	    }
	    if(fixedFields) {
		let tmpFields  = [];
		fixedFields.forEach(tok=>{
		    if(!tok.match("-")) {
			tmpFields.push(tok);
			return;
		    }
		    let pair = tok.split("-");
		    let i1 = parseFloat(pair[0].trim().substring(1));
		    let i2 = parseFloat(pair[1].trim().substring(1));
		    for(let i=i1;i<=i2;i++) tmpFields.push("#" + i);
		    
		});
		fixedFields = tmpFields;
	    }


	    let aliases= {};
	    var tmp = this.getProperty("fieldAliases");
	    if(tmp) {
		tmp.split(",").forEach(tok=>{
		    [name,alias] =   tok.split(":");
		    aliases[alias] = name;
		});
	    }
            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                var pointData = dataList[collectionIdx];
		//A hack in case we already have a pointData set (e.g., in the case of a convertDataPost)
		if(this.pointData) pointData = this.pointData;
                var fields = this.getFieldsToSelect(pointData);
                if (fixedFields != null && fixedFields.length > 0) {
                    if (this.debugSelected)
                        console.log("\thave fixed fields:" + fixedFields.length);
		    let selected = [];
                    for (var i = 0; i < fixedFields.length; i++) {
                        var sfield = fixedFields[i];
			if(sfield =="*") {
			    selected  =fields;
			    break;
			}
			var field = this.getFieldById(fields, sfield);
                        if(field) {
			    selected.push(field);
			}
                    }
		    if(this.getProperty("fieldsNumeric")) {
			selected = selected.filter(f=>f.isNumeric());
		    }		    
		    df = selected;
		}
	    }

	    
            if (!this.userHasSelectedAField && fixedFields != null && fixedFields.length > 0) {
                if (this.debugSelected)
                    console.log("\tfrom fixed:" + df.length);
                return df;
            }

	    this.userHasSelectedAField = false;
            var fieldsToSelect = null;
            var firstField = null;
            this.selectedCbx = [];
            var cbxExists = false;


            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                var pointData = dataList[collectionIdx];
                fieldsToSelect = this.getFieldsToSelect(pointData);
                for (i = 0; i < fieldsToSelect.length; i++) {
                    var field = fieldsToSelect[i];
                    if (firstField == null && field.isNumeric()) firstField = field;
                    var idBase = "cbx_" + collectionIdx + "_" + i;
                    var cbxId = this.getDomId(idBase);
                    var cbx = $("#" + cbxId);
                    if (cbx.length>0) {
                        cbxExists = true;
                    } else {
                        continue;
                    }
                    if (cbx.is(':checked')) {
                        this.selectedCbx.push(field.getId());
                        df.push(field);
                    }
                }
            }

            if (df.length == 0 && !cbxExists) {
                if (this.lastSelectedFields && this.lastSelectedFields.length > 0) {
                    if (this.debugSelected)
                        console.log("\tlastSelectedFields:" + this.lastSelectedFields);
                    return this.lastSelectedFields;
                }
            }
            if (df.length == 0) {
                df = this.getDefaultSelectedFields(fieldsToSelect, dfltList,this.debugSelected);
                if (this.debugSelected)
                    console.log("\tusing default selected:" + df);
            }
            return df;
        },
        getDefaultSelectedFields: function(fields, dfltList,debugArg) {
	    let debug = debugArg||displayDebug.getDefaultSelectedFields;
	    if(debug)
		console.log("getDefaultSelectedFields");
	    let patterns = this.getProperty("fieldsPatterns");
	    if(patterns) {
		let allFields = this.getFields();
		if(allFields) {
		    let debugPatterns = false;
		    let matched=[];
		    if(debugPatterns)
			console.log("fields:" +allFields);
		    patterns.split(",").forEach(pattern=>{
			if(debugPatterns)
			    console.log("\tpattern:" + pattern);
			allFields.every(f=>{
			    if(!f.isFieldNumeric()) return true;
			    let id = f.getId().toLowerCase();
			    if(debugPatterns)
				console.log("\t\tid:" + id);
			    if(id.match(pattern)) {
				if(debugPatterns)
				    console.log("\t\tmatch");
				if(!matched.includes(f)) {
				    if(debugPatterns)
					console.log("\t\tadd to matched");
				    //				    console.log("\tmatches:"+ id);
				    matched.push(f);
				    return false;
				}
			    }
			    return true;
			});
		    });
		    if(debugPatterns)
			console.log("returning:" + matched);
		    if(matched.length)
			return matched;
		}
	    }
            if (this.defaultSelectedToAll()) {
		let allFields = this.getFields();
		if(allFields) {
                    var tmp = [];
                    for (i = 0; i < allFields.length; i++) {
			var field = allFields[i];
			if (!field.isFieldGeo()) {
                            tmp.push(field);
			}
                    }
		}
		if(debug)
		    console.log("\treturning allFields:" + tmp);
                return tmp;
            }

            if (dfltList != null) {
		if(debug)
		    console.log("\treturning dfltList:" + dfltList);
                return dfltList;
            }
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (field.isNumeric() && !field.isFieldGeo()) return [field];
            }
            return [];
	},
	sortRecords: function(records, sortFields) {
	    if(!sortFields) {
		let f = this.getProperty("sortFields", "", true);
		if(f=="${fields}") f = this.getProperty("fields", "", true);
		sortFields = this.getFieldsByIds(null, f);
		if(sortFields.length==0 && this.sortByFields && this.sortByFields.length>0) {
		    sortFields = [this.sortByFields[0]];
		}
	    }

	    if(sortFields.length>0) {
		records = Utils.cloneList(records);
		let sortAscending = this.getSortAscending();
		let cnt = 0;
		records.sort((a,b)=>{
		    let row1 = this.getDataValues(a);
		    let row2 = this.getDataValues(b);
		    let result = 0;
		    for(let i=0;i<sortFields.length;i++) {
			let sortField = sortFields[i];
			let v1 = row1[sortField.getIndex()];
			let v2 = row2[sortField.getIndex()];
			if(sortField.isNumeric() || sortField.isFieldDate()) {
			    if(isNaN(v1) && isNaN(v2)) {
				result= 0;
			    } else if(isNaN(v1)) {
				result = sortAscending?-1:1;
			    } else if(isNaN(v2)) {
				result = sortAscending?1:-1;
			    } else {
				if(v1<v2) result = sortAscending?-1:1;
				else if(v1>v2) result = sortAscending?1:-1;
				else result = 0;
			    }
			} else {
			    result = String(v1).localeCompare(String(v2));
			    if(!sortAscending) result=-result;
			}
			if(result!=0) break;
		    }
		    return result;
		});
	    }


	    if(this.getProperty("sortHighlight")) {
		records = Utils.cloneList(records);
		records.sort((a,b)=>{
		    let h1 = a.isHighlight(this);
		    let h2 = b.isHighlight(this);
		    if(h1 && !h2)
			return -1;		    
		    if(!h1 && h2)
			return 1;		    
		    return 0;
		});
	    }

	    if(this.getProperty("reverse",false)) {
		records = Utils.cloneList(records);
		let tmp = [];
		for(let i=records.length-1;i>=0;i--)
		    tmp.push(records[i]);
		records = tmp;
	    }

	    return records;
	},
        getFieldById: function(fields, id,debug) {
	    //Support one arg
	    if(debug)
		console.log("getFieldById:" + id);
	    if(fields!=null && id==null) {
		if(typeof fields!="string") {
		    if(debug)
			console.log("\tbadfields:" + fields);
		    return null;
		}
		id = fields;
		fields=null;
	    }
            if (!id) {
		if(debug)
		    console.log("\tno id");
		return null;
	    }
	    id = String(id).trim();
	    if (!fields) {
                let pointData = this.getData();
                if (pointData == null) {
		    if(debug)
			console.log("\tno data");
		    return null;
		}
                fields = pointData.getRecordFields();
		if(debug) {
		    console.log("\tusing  fields:" + fields);
		}
            }
	    let aliases= {};
	    let tmp = this.getProperty("fieldAliases");
	    if(tmp) {
		tmp.split(",").forEach(tok=>{
		    [name,alias] =   tok.split(":");
		    aliases[alias] = name;
		});
	    }
	    let theField = null;
	    id.split("|").every(fieldId=>{
		let alias = aliases[fieldId];
		let hasRegexp = fieldId.indexOf("*")>=0;
		for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
		    if(debug)	{
			console.log("\tField:" + field.getId());
		    }
		    
                    if (field.getId() == fieldId || fieldId == ("#" + (i+1)) || field.getId()==alias) {
			theField =  field;
			if(debug)
			    console.log("\tgot it:" + theField);
			return false;
                    }
		    if(hasRegexp) {
			if(field.getId().match(fieldId)) {
			    theField =  field;
			    if(debug)
				console.log("\tgot it from pattern:" + theField);
			    return false;
			}
		    }
		}
		return true;
	    });
	    if(debug)
		console.log("\tgot:" + theField);
            return theField;
        },

        getFieldsByIds: function(fields, ids) {
	    if (!fields) {
                let pointData = this.getData();
                if (pointData != null) 
                    fields = pointData.getRecordFields();
            }

            let result = [];
            if (!ids) {
		return result;
	    }
	    if(ids=="*") return fields;
            if ((typeof ids) == "string")
                ids = ids.split(",");
            if (!fields) {
                var pointData = this.getData();
                if (pointData == null) {
		    return null;
		}
                fields = pointData.getRecordFields();
            }


            for (let i = 0; i < ids.length; i++) {
		let id = ids[i];
		//Check for numeric range
		if(id.startsWith("#")) {
		    let toks = id.split("-");
		    if(toks.length==2) {
			let idx1 = +toks[0].replace("#","");
			let idx2 = +toks[1].replace("#","");			
			console.log(idx1 +" " + idx2);
			for(let j=idx1;j<=idx2;j++) {
			    let f = this.getFieldById(fields, "#" + idx1);
			    if (f) result.push(f);
			}
			continue;
		    }
		}
                let f = this.getFieldById(fields, ids[i]);
                if (f) result.push(f);
            }
            return result;
        },

        getFieldByType: function(fields, type) {
            fields = this.getFieldsByType(fields, type);
            if (fields.length == 0) return null;
            return fields[0];
        },
        getFieldsByType: function(fields, type) {
            if (!fields) {
                let pointData = this.getData();
                if (pointData == null) return null;
                fields = pointData.getRecordFields();
            }
            let list = [];
            let numeric = (type == "numeric");
            let isString = (type == "string");
            for (a in fields) {
                let field = fields[a];
		if(field.isRecordDate()) continue;
                if (type == null) return field;
                if (numeric) {
                    if (field.isFieldNumeric()) {
                        list.push(field);
                    }
                } else if(isString) {
                    if (field.isFieldString()) {
                        list.push(field);
                    }
                    
                } else if (field.getType() == type) {
                    list.push(field);
                }
            }
            return list;
        },
	getDateValues: function(records) {
	    let dates = [];
	    records.forEach(r=>{
		dates.push(r.getDate());
	    });
	    return dates;
	},
        getColumnValues: function(records, field) {
            var values = [];
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var record = records[rowIdx];
                var row = record.getData();
                var value = row[field.getIndex()];
                values.push(value);
                if (Utils.isNumber(value) && !isNaN(value)) {
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
            return {
                values: values,
                min: min,
                max: max
            };
        },
        requiresGrouping:  function() {
            return false;
        },
	makeTree: function(records) {
	    if(records==null)  {
		let pointData = this.getData();
                if (pointData == null) return null;
                records = pointData.getRecords();
            }
	    let treeTemplate = this.getProperty("treeTemplate");
	    let treeTooltip = this.getProperty("treeTooltip");
	    let roots = [];
	    let idToNode = {};
	    let nodes=[];
	    let idToRoot = {};
	    var labelField = this.getFieldById(null, this.getProperty("labelField"));
	    var nodeFields = this.getFieldsByIds(null, this.getProperty("nodeFields"));
	    let treeRootLabel = this.getProperty("treeRoot");
	    let treeRoot = null;
	    if(treeRootLabel) {
		treeRoot = {id:treeRootLabel,label:treeRootLabel,children:[],parent:null};
		roots.push(treeRoot);
	    }
	    if(nodeFields.length>0) {
		let cnt = 0;
		let valueToNode = {};
		let parentId = "";
		records.forEach(r=>{
		    var label= labelField==null?id:r.getValue(labelField.getIndex());		
		    let parentId = null;
		    let parentNode= null;
		    //		    console.log("record:" + label);

		    nodeFields.forEach(nodeField=>{
			let id = r.getValue(nodeField.getIndex());
			let nodeId = parentId?parentId+"-"+id:id;
			let tmpNode = idToNode[nodeId];
			if(!tmpNode) {
			    tmpNode = {id:nodeId,label:id,children:[],parent:parentNode};
			    idToNode[nodeId] = tmpNode;
			    if(!parentNode) {
				if(treeRoot) {
				    tmpNode.parent = treeRoot;
				    treeRoot.children.push(tmpNode);
				} else {
				    roots.push(tmpNode);
				}
			    }
			    if(parentNode) {
				parentNode.children.push(tmpNode);
			    }
			}
			parentId = nodeId;
			parentNode = tmpNode;
		    });
		    var id= "leaf" + (cnt++);
		    var node = {id:id,label:label,children:[],record:r, parent:parentNode};
		    parentNode.children.push(node);
		    idToNode[id] = node;
		    nodes.push(node);
		});
		return roots;
	    }

	    //{label:..., id:...., record:...,	    children:[]}
            let parentField = this.getFieldById(null, this.getProperty("parentField"));
	    let idField = this.getFieldById(null, this.getProperty("idField"));
	    if(!parentField) {
		throw new Error("No parent field specified");
	    }
	    if(!idField) {
                throw new Error("No id field specified");
	    }
	    records.forEach(r=>{
		var parent = r.getValue(parentField.getIndex());
		var id = r.getValue(idField.getIndex());
		var label= labelField==null?id:r.getValue(labelField.getIndex());		
		var node = {id:id,label:label,children:[],record:r,parentId:parent, parent:null};
		if(treeTemplate) {
		    node.display = this.getRecordHtml(r, null, treeTemplate);
		}
		if(treeTooltip) {
		    node.tooltip = this.getRecordHtml(r, null, treeTooltip);
		}
		idToNode[id] = node;
		nodes.push(node);
		if(parent=="") {
		    //is a root
		    idToRoot[id]=node;
		    if(treeRoot) {
			node.parent = treeRoot;
			node.parentId = treeRoot.id;
			treeRoot.children.push(node);
		    } else {
			roots.push(node);
		    }
		}
	    });
	    nodes.forEach(node=>{
		let parentNode = idToNode[node.parentId];
		if(!parentNode) {
		    if(!idToRoot[node.id]) {
			throw new Error("No parent :" + node.parentId +" for node:" + node.label);
		    }
		    return;
		}
		node.parent= parentNode;
		parentNode.children.push(node);
	    });

	    return roots;
	},
	getSegments: function() {
	    var segments = this.getProperty("timeSegments");
	    if(!segments) return null;
	    var result = [];
	    var segmentList = segments.split(",");
	    segmentList.forEach((tok,segmentIdx)=>{
		var toks = tok.split(";");
		var name = toks[0];
		var start = Utils.parseDate(toks[1],false);
		var end = Utils.parseDate(toks[2],false);
		result.push({name: name, start:start,end:end});
	    });
	    return  result;
	},
	convertPointData: function(pointData) {
	    let originalPointData = pointData;
	    let segments = this.getSegments();
	    if(segments) {
                let dataList = pointData.getRecords();
		let newData  =[];
		let header = [];
		newData.push(header);
		var rowIdx = 0; 
		//timeSegments="Obama;2008-02-01;2016-01-31,Trump;2016-02-01;2020-01-31"
		segments.forEach((segment,segmentIdx)=>{
		    var name = segment.name;
		    header.push(name);
		    var start = segment.start;
		    var end = segment.end;
		    var cnt = 1;
	    	    for (; rowIdx <dataList.length; rowIdx++) {
			var record = dataList[rowIdx];
			if(record.getTime()<start.getTime()) {
			    continue;
			}
			if(record.getTime()>end.getTime()) {
			    break;
			}
			var value = record.getValue(1);
			let row=null;
			if(cnt>=newData.length) {
			    row = [];
			    for(let sidx=0;sidx<segments.length;sidx++) row.push(NaN);
			    newData.push(row);
			} else {
			    row = newData[cnt];
			}
			row[segmentIdx] = value;
			cnt++;
		    }
		});
		pointData = convertToPointData(newData);
		pointData.entryId = originalPointData.entryId;
	    }

	    try {
		pointData = new CsvUtil().process(this, pointData, this.getProperty("convertData"));
	    } catch(exc) {
		this.handleError("Error:" + exc, exc);
		return null;
	    }


	    return pointData;
	},
	requiresGeoLocation: function() {
	    return false;
	},
	checkDataFilters: function(dataFilters, record) {
	    if(!dataFilters) {return true;}
	    for(let i=0;i<dataFilters.length;i++) {
		if(!dataFilters[i].isRecordOk(record)) return false;
	    }
	    return true;
	},
	getDataFilters: function(v) {
	    return DataUtils.getDataFilters(this, v || this.getProperty("dataFilters"));
	},
	getFilterHighlight: function() {
	    return this.getProperty("filterHighlight",false);
	},
	getFilterTextMatchers: function() {
	    let highlight  = [];
	    if(this.filters) {
		for(var filterIdx=0;filterIdx<this.filters.length;filterIdx++) {
		    let filter = this.filters[filterIdx];
		    if(!filter.field)continue;
		    var widget =$("#" + this.getDomId("filterby_" + filter.field.getId())); 
		    if(!widget.val || widget.val()==null) continue;
		    var value = widget.val()||"";
		    if(value.trim()=="") continue;
		    highlight.push(new TextMatcher(value));
		}
	    }
	    return highlight;
	},

	filterDataPhase2:function(records) {
	    return records;
	},
	filterData: function(records, fields, args) {
	    if(this.recordListOverride) return this.recordListOverride;
	    let opts = {
		doGroup:false,
		skipFirst:false,
		applyDateRange: true
	    }
	    if(args)
		$.extend(opts,args);
	    let debug =  displayDebug.filterData;

	    if(this.getAnimationEnabled()) {
		if(this.getProperty("animationFilter", true)) {
		    this.setDateRange(this.getAnimation().begin, this.getAnimation().end);
		}
	    }


	    let highlight =  this.getFilterHighlight();
	    let startDate = this.getProperty("startDate");
	    let endDate = this.getProperty("endDate");
	    if(startDate) {
		this.startDateObject = Utils.createDate(startDate,+this.getProperty("timeZoneOffset",0));
		if(debug)
		    console.log(this.type +" start date:" + startDate + " dttm:" + this.startDateObject.toUTCString());
	    } 
	    if(endDate) {
		this.endDateObject = Utils.createDate(endDate,+this.getProperty("timeZoneOffset",0));
		if(debug)
		    console.log(this.type +"end date:" +this.endDateObject.toUTCString());
	    } 


	    let filterDate = this.getProperty("filterDate");
	    if(filterDate) {
		let date = $("#"+ this.getFilterId(ID_FILTER_DATE)).val();
		if(date) {
		    if(date=="all") {
			this.setDateRange(null,null);
		    } else {
			date = new Date(date);
			if(filterDate == "year") {
			    this.setDateRange(new Date(date.getFullYear()+"-01-01"),
					      new Date(date.getFullYear()+"-12-31"));
			} else if(filterDate == "day") {
			    let f = date.getUTCFullYear() + "-" + (date.getUTCMonth() + 1) +"-" + date.getUTCDate();
			    let dttm = new Date(f);
			    this.setDateRange(dttm,dttm, true);
			} else {
			    //TODO month and day
			}
		    }
		}
	    }

            let pointData = this.getData();
            if (!records) {
                if (pointData == null) return null;
                records = pointData.getRecords();
            }
            if (!fields) {
                fields = pointData.getRecordFields();
            }
            if(opts.doGroup || this.requiresGrouping()) {
                records = pointData.extractGroup(this.dataGroup, records);
            }

	    if(debug)   console.log("fitler #records:" + records.length);
	    if(this.getProperty("filterLatest")) {
		let fields = this.getFieldsByIds(null,this.getProperty("filterLatest"));
		let max = {};
		let keyToRecord = {};
		let tmp = [];
		let keys = [];
		records.forEach(record=>{
		    if(!record.getTime()) return;
		    let key = "";
		    fields.forEach(f=>{
			key+="_" + record.getValue(f.getIndex());
		    });
		    let maxRecord = keyToRecord[key];
		    if(!maxRecord) {
			keyToRecord[key] = record;
			keys.push(key);
		    } else {
			if(record.getDate().getTime()>maxRecord.getDate().getTime()) keyToRecord[key] = record;
		    }
		});


		keys.forEach(key=>{
		    tmp.push(keyToRecord[key]);
		});
		records  =tmp;
	    }


	    records.forEach(r=>{
		r.clearHighlight(this);
	    });

//	    if(debug)   console.log("checking dates");
	    records = records.filter((record,idx)=>{
                let date = record.getDate();
		if(!date) return true;
		return this.dateInRange(date,idx<5 && debug);
	    });
	    if(debug)   console.log("filter Fields:" + this.filters.length +" #records:" + records.length);

	    if(this.filters.length) {
		let newData = [];
		let logic = this.getProperty("filterLogic","and");
		this.filters.forEach(f=>f.prepareToFilter(debug));
		if(debug)
		    console.log("filter:" + this.filters.length);
		records.forEach((record,rowIdx)=>{
		    let allOk = true;
		    let anyOk = false;		    
		    this.filters.forEach(filter=>{
			if(!filter.isEnabled()) return;
			let filterOk = filter.isRecordOk(record, rowIdx<5&&debug);
			if(!filterOk) allOk = false;
			else anyOk = true;
		    });
		    let ok = logic=="and"?allOk:anyOk;
		    if(opts.skipFirst && rowIdx==0) {
			ok = true;
		    }
		    if(highlight) {
			newData.push(record);
			record.setHighlight(this, ok);
		    } else {
			record.clearHighlight(this);
			if(ok) {
			    newData.push(record);
			}
		    }
		});
		debug = false;
		records = newData;
	    }

	    if(debug)   console.log("filterData-2 #records:" + records.length);

            var stride = parseInt(this.getProperty("stride", -1));
            if (stride < 0) {
		var maxSize = parseInt(this.getProperty("maxDisplayedPoints", -1));		
		if(maxSize>0 && records.length>0) {
		    stride = 1;
		    while(records.length/stride>maxSize) {
			stride++;
		    }
		}
	    }

            if (stride > 0) {
                var list = [];
                var cnt = 0;
                for (var i = 0; i < records.length; i += (stride + 1)) {
                    list.push(records[i]);
                }
                records = list;
		//		console.log("stride: " + stride +"  size:" + list.length);
		if(debug)   console.log("R-3:" + records.length);
            }

	    records = this.filterDataPhase2(records);

	    let filterPaginate = this.getProperty("filterPaginate");
	    if(filterPaginate) {
		let skip = this.pageSkip||0;
		let count = +this.getProperty("pageCount",1000);
		if(skip>0 || count<records.length) {
		    let tmp = [];
		    let newSkip = skip;
		    count = Utils.max(count, 1000);
		    while(true) {
			if(newSkip<records.length) break;
			newSkip-=count;
			if(newSkip<0) {
			    break;
			}
		    }
		    if(newSkip<0) newSkip=0;
		    if(newSkip!=skip)
			this.updatePaginateLabel(skip,count,records.length);
		    skip = newSkip;
		    console.log("skip:" + skip +" count:" + count +" " + records.length);
		    for(let i=skip;i<records.length;i++) {
			tmp.push(records[i]);
			if(tmp.length>=count) break;
		    }
		    records=tmp;
		}
	    }


	    if(this.getProperty("binDate")) {
		let what = this.getProperty("binDate");
		let binType = this.getProperty("binType","total");
		let binCount = binType=="count";
		let binned = [];
		let record = records[0];
		let map ={};
		let counts ={};
		this.binRecordToRecords = {};
		let keyToRecord={};
		for (var i = 0; i < records.length; i++) {
		    let record = records[i];
		    var tuple = this.getDataValues(record);
		    var key;
		    var baseDate=null
		    if(what=="month") {
			key = record.getDate().getUTCFullYear() + "-" + (record.getDate().getUTCMonth() + 1);
		    } else if(what=="day") {
			key = record.getDate().getUTCFullYear() + "-" + (record.getDate().getUTCMonth() + 1) +"-" + record.getDate().getUTCDate();
		    } else if(what=="week") {
			var week = +Utils.formatDateWeek(record.getDate());
			key = record.getDate().getUTCFullYear()+"-"+week;
			var d =  (1 + (week - 1) * 7);
			baseDate = new Date(record.getDate().getUTCFullYear(), 0, d);			
		    } else {
			key = record.getDate().getUTCFullYear()+"";
		    }
		    if(!Utils.isDefined(map[key])) {
			counts[key]=1;
			var date = baseDate;
			if(!baseDate) {
			    date = Utils.parseDate(key);
			}
			var data = Utils.cloneList(record.getData());
			if(binCount) {
			    for(k=0;k<data.length;k++) data[k]=1;
			}
			var newRecord = new  PointRecord(fields, record.getLatitude(),record.getLongitude(),
							 record.getElevation(),date,data);

			keyToRecord[key] = newRecord;
			this.binRecordToRecords[newRecord.getId()] = {
			    records:[record],
			}

			map[key] = data;
			binned.push(newRecord);
		    } else {
			let newRecord = keyToRecord[key];
			this.binRecordToRecords[newRecord.getId()].records.push(record);
			counts[key]++;
			var tuple1 = map[key];
			if(binCount) {
			    for(k=0;k<tuple1.length;k++) tuple1[k]++;
			    continue;
			} 
			var tuple2 = record.getData();
			for(var j=0;j<tuple2.length;j++) {
			    var v = tuple2[j];
			    if((typeof v) !="number") continue;
			    if(isNaN(v)) continue;
			    if(isNaN(tuple1[j])) tuple1[j] = v;
			    else tuple1[j] +=v;
			}
		    }
		}
		if(binType == "average") {
		    for(key in counts) {
			var tuple = map[key];
			for(var j=0;j<tuple.length;j++) {
			    var v = tuple[j];
			    if((typeof v) !="number") continue;
			    if(isNaN(v)) continue;
			    tuple[j] = v/counts[key];
			}
		    }
		}

		records = binned;
	    }

	    if(this.requiresGeoLocation()) {
		records = records.filter(r=>{return r.hasLocation();});
	    }
	    let dataFilters = this.getDataFilters();
	    if(dataFilters.length) {
		records = records.filter((r,idx)=> {
		    if(!this.checkDataFilters(dataFilters, r)) {
			return false;
		    } 
		    return true;
		});
	    }
	    //	    var t2=  new Date();
	    //	    Utils.displayTimes("filterData",[t1,t2]);
	    records = this.sortRecords(records);

	    if(this.getProperty("uniqueField")) {
		let ufield =  this.getFieldById(null, this.getProperty("uniqueField"));
		let umap = {};
		let ulist = [];
		for(var i=records.length-1;i>=0;i--) {
		    var record = records[i];
		    var v = record.getValue(ufield.getIndex());
		    if(!Utils.isDefined(umap[v])) {
			umap[v] = true;
			ulist.push(record);
		    }
		}
		records  = ulist;
	    }

	    this.recordToIndex = {};
	    this.indexToRecord = {};
	    for(var i=0;i<records.length;i++) {
		var record = records[i];
		this.recordToIndex[record.getId()] = i;
		this.indexToRecord[i] = record;
	    }


	    let convertPost = this.getProperty("convertDataPost");
	    if(convertPost) {
		let newPointData = new  PointData("pointdata", pointData.getRecordFields(), records,null,{parent:pointData});
		this.pointData =  new CsvUtil().process(this, newPointData, convertPost);
		records = this.pointData.getRecords();
//		console.log("post:" + this.pointData.getRecordFields());
	    }
	    if(debug)
		console.log("filtered:" + records.length);
	    this.jq(ID_FILTER_COUNT).html("Count: " + records.length);
	    this.filteredRecords = records;
	    if(this.getSelectFirst()) {
		this.propagateEventRecordSelection({record:records[0]});
	    } else if(this.getSelectLast()) {
		this.propagateEventRecordSelection({record:records[records.length-1]});
	    }
            return this.handleResult("filterData",records);
        },
	//TODO: this will support a handler pattern that allows for insertion
	//of custom functionality
	handleResult: function(type,data) {
	    return data;
	},
	getBinnedRecords: function(record) {
	    if(this.binRecordToRecords)
		return this.binRecordToRecords[record.getId()].records;
	    return record.parentRecords;
	},
        canDoGroupBy: function() {
            return false;
        },
        canDoMultiFields: function() {
            return true;
        },
        useChartableFields: function() {
            return false;
        },
        getFieldsToSelect: function(pointData) {
            if (this.useChartableFields())
                return pointData.getChartableFields(this);
            return pointData.getRecordFields();
        },
        getGet: function() {
            return "getRamaddaDisplay('" + this.getId() + "')";
        },
	assembleWikiText: function(type) {
	    var wiki =  "";
	    if(window.globalDisplayProperties) {
		for(key in window.globalDisplayProperties) {
		    wiki += '{{displayProperty name="' + key +'" value="' + window.globalDisplayProperties[key]+'"}}\n';

		}
	    }
            wiki += this.getWikiText();
            for (var i = 0; i < this.displays.length; i++) {
                var display = this.displays[i];
                if (display.getIsLayoutFixed()) {
                    continue;
                }
                wiki += display.getWikiText();
            }
	    return wiki;
	},
        showWikiText: function(type) {
	    var wiki =  this.assembleWikiText();
	    HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
	    wiki = wiki.replace(/</g,"&lt;").replace(/>/g,"&gt;");
	    wiki = HU.pre([STYLE,HU.css("max-width","500px","max-height","400px","overflow-x","auto","overflow-y","auto")], wiki);
	    this.showDialog(wiki);
	},
        copyWikiText: function(type) {
	    Utils.copyText(this.assembleWikiText());
	    alert("Wiki text has been copied to the clipboard");
	},
        publish: function(type) {
            if (type == null) type = "wikipage";
            var args = [];
            var name = prompt("Name", "");
            if (name == null) return;
            args.push("name");
            args.push(name);

            args.push("type");
            args.push(type);


            var desc = "";
            //                var desc = prompt("Description", "");
            //                if(desc == null) return;

            var wiki = "";
            if (type == "wikipage") {
                wiki += "+section label=\"{{name}}\"\n${extra}\n";
            } else if (type == "blogentry") {
                wiki = "<wiki>\n";
            }
            wiki += desc;
	    wiki += this.assembleWikiText();
            if (type == "wikipage") {
                wiki += "-section\n\n";
            } else if (type == "blogentry") {}
            var from = "";
            var entries = this.getChildEntries();
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                from += entry.getId() + ",";
            }

            if (entries.length > 0) {
                args.push("entries");
                args.push(from);
            }

            if (type == "media_photoalbum") {
                wiki = "";
            }

            args.push("description_encoded");
	    console.log(wiki);
            args.push(window.btoa(wiki));
            var url = HU.getUrl(ramaddaBaseUrl + "/entry/publish", args);
            window.open(url, '_blank');
        },
        getChildEntries: function(includeFixed) {
            var seen = {};
            var allEntries = [];
            for (var i = 0; i < this.displays.length; i++) {
                var display = this.displays[i];
                if (!includeFixed && display.getIsLayoutFixed()) {
                    continue;
                }
                if (display.getEntries) {
                    var entries = display.getEntries();
                    if (entries) {
                        for (var entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                            if (seen[entries[entryIdx].getId()] != null) {
                                continue;
                            }
                            seen[entries[entryIdx].getId()] = true;
                            allEntries.push(entries[entryIdx]);
                        }
                    }
                }
            }
            return allEntries;
        },
        copyDisplayedEntries: function() {
            var allEntries = [];
            for (var i = 0; i < this.displays.length; i++) {
                var display = this.displays[i];
                if (display.getIsLayoutFixed()) {
                    continue;
                }
                if (display.getEntries) {
                    var entries = display.getEntries();
                    if (entries) {
                        for (var entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                            allEntries.push(entries[entryIdx]);
                        }
                    }
                }
            }
            return this.copyEntries(allEntries);
        },
        defineWikiAttributes: function(list) {
            for (var i = 0; i < list.length; i++) {
                if (this.wikiAttrs.indexOf(list[i]) < 0) {
                    this.wikiAttrs.push(list[i]);
                }
            }
        },
        getWikiAttributes: function(attrs) {
            for (var i = 0; i < this.wikiAttrs.length; i++) {
                var v = this[this.wikiAttrs[i]];
                if (Utils.isDefined(v)) {
                    attrs.push(this.wikiAttrs[i]);
                    attrs.push(v);
                }
            }
        },
        getWikiText: function() {
            var attrs = [
			 "layoutHere", "false",
			 "type", this.type,
			 "column", this.getColumn(),
			 "row", this.getRow()
			];
	    if(this.getProperty("entryId")) {
		attrs.push("entry");
		attrs.push(this.getProperty("entryId"));
	    }
            this.getWikiAttributes(attrs);
            var entryId = null;
            if (this.getEntries) {
                var entries = this.getEntries();
                if (entries && entries.length > 0) {
                    entryId = entries[0].getId();
                }
            }
            if (!entryId) {
                entryId = this.entryId;
            }
            if (entryId) {
                attrs.push("entry");
                attrs.push(entryId);
            }
            var wiki = "{{display " + HU.attrs(attrs) + "}}\n\n"

            return wiki;
        },
        copyEntries: function(entries) {
            var allEntries = [];
            var seen = {};
            for (var entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                var entry = entries[entryIdx];
                if (seen[entry.getId()] != null) continue;
                seen[entry.getId()] = entry;
                allEntries.push(entry);
            }
            var from = "";
            for (var i = 0; i < allEntries.length; i++) {
                var entry = allEntries[i];
                from += entry.getId() + ",";
            }


            var url = ramaddaBaseUrl + "/entry/copy?action.force=copy&from=" + from;
            window.open(url, '_blank');

        },
        entryHtmlHasBeenDisplayed: async function(entry) {
            if (entry.getIsGroup() /* && !entry.isRemote*/ ) {
                var theDisplay = this;
                var callback = function(entries) {
                    var html = HU.open(TAG_OL, [ATTR_CLASS, "display-entrylist-list", ATTR_ID, theDisplay.getDomId(ID_LIST)]);
                    html += theDisplay.getEntriesTree(entries);
                    html += HU.close(TAG_OL);
                    theDisplay.jq(ID_GROUP_CONTENTS + entry.getIdForDom()).html(html);
                    theDisplay.addEntrySelect();
                };
                await entry.getChildrenEntries(callback);
            }
        },
        getEntryHtml: function(entry, props) {
            let dfltProps = {
                showHeader: true,
                headerRight: false,
                showDetails: this.getShowDetails(),
		showImage:true,
            };
            $.extend(dfltProps, props);

            props = dfltProps;
            let menu = this.getEntryMenuButton(entry);
            let html = "";
            if (props.showHeader) {
                let left = menu + SPACE + entry.getLink(null, true, ["target","_entries"]);
                if (props.headerRight) html += HU.leftRight(left, props.headerRight);
                else html += left;
            }

            let divid = HU.getUniqueId("entry_");
            html += HU.div([ID, divid], "");
            let metadata = entry.getMetadata();
	    if(dfltProps.showImage) {
		if (entry.isImage()) {
                    let img = HU.tag(TAG_IMG, ["src", entry.getImageUrl(), /*ATTR_WIDTH,"100%",*/
					       ATTR_CLASS, "display-entry-image"
					      ]);

                    html += HU.href(entry.getResourceUrl(), img,["download",null]) + "<br>";
		} else {
                    for (var i = 0; i < metadata.length; i++) {
			if (metadata[i].type == "content.thumbnail") {
                            let image = metadata[i].value.attr1;
                            let url;
                            if (image.indexOf("http") == 0) {
				url = image;
                            } else {
				url = ramaddaBaseUrl + "/metadata/view/" + image + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + metadata[i].id + "&thumbnail=false";
                            }
                            html += HU.image(url, [ATTR_CLASS, "display-entry-thumbnail"]);
			}
                    }
		}
	    }
            if (entry.getIsGroup() /* && !entry.isRemote*/ ) {
                html += HU.div([ATTR_ID, this.getDomId(ID_GROUP_CONTENTS + entry.getIdForDom())], "" /*this.getWaitImage()*/ );
            }


            html += HU.formTable();

            if (props.showDetails) {
                if (entry.url) {
                    html += HU.formEntry("URL:", HU.href(entry.url, entry.url));
                }

                if (entry.remoteUrl) {
                    html += HU.formEntry("URL:", HU.href(entry.remoteUrl, entry.remoteUrl));
                }
                if (entry.remoteRepository) {
                    html += HU.formEntry("From:", HU.href(entry.remoteRepository.url, entry.remoteRepository.name));
                }
            }

            var columns = entry.getAttributes();

            if (entry.getFilesize() > 0) {
                html += HU.formEntry("File:", entry.getFilename() + " " +
				     HU.href(entry.getResourceUrl(), HU.image(ramaddaCdn + "/icons/download.png"),["download",null]) + " " +
				     entry.getFormattedFilesize());
            }
            for (var colIdx = 0; colIdx < columns.length; colIdx++) {
                var column = columns[colIdx];
                var columnValue = column.value;
                if (column.getCanShow && !column.getCanShow()) {
                    continue;
                }
                if (Utils.isFalse(column.canshow)) {
                    continue;
                }

                if (column.isUrl && column.isUrl()) {
                    var tmp = "";
                    var toks = columnValue.split("\n");
                    for (var i = 0; i < toks.length; i++) {
                        var url = toks[i].trim();
                        if (url.length == 0) continue;
                        tmp += HU.href(url, url);
                        tmp += "<br>";
                    }
                    columnValue = tmp;
                }
                html += HU.formEntry(column.label + ":", columnValue);
            }

            html += HU.close(TAG_TABLE);
            return html;
        },

        getEntriesTree: function(entries, props) {
            if (!props) props = {};
            let columns = this.getProperty("entryColumns", null);
            if (columns != null) {
                let columnNames = this.getProperty("columnNames", null);
                if (columnNames != null) {
                    columnNames = columnNames.split(",");
                }
                columns = columns.split(",");
                let ids = [];
                let names = [];
                for (let i = 0; i < columns.length; i++) {
                    let toks = columns[i].split(":");
                    let id = null,
                        name = null;
                    if (toks.length > 1) {
                        if (toks[0] == "property") {
                            name = "property";
                            id = columns[i];
                        } else {
                            id = toks[0];
                            name = toks[1];
                        }
                    } else {
                        id = columns[i];
                        name = id;
                    }
                    ids.push(id);
                    names.push(name);
                }
                columns = ids;
                if (columnNames == null) {
                    columnNames = names;
                }
                return this.getEntriesTable(entries, columns, columnNames);
            }

            let suffix = props.suffix;
            let domIdSuffix = "";
            if (!suffix) {
                suffix = "null";
            } else {
                domIdSuffix = suffix;
                suffix = "'" + suffix + "'";
            }

            let handler = getHandler(props.handlerId);
            let showIndex = props.showIndex;
            let html = "";
            let rowClass = "entryrow_" + this.getId();
            let even = true;
            if (this.entriesMap == null)
                this.entriesMap = {};
	    let doWorkbench = this.getProperty("doWorkbench");
            for (let i = 0; i < entries.length; i++) {
                even = !even;
                let entry = entries[i];
                this.entriesMap[entry.getId()] = entry;
                let toolbar = this.makeEntryToolbar(entry, handler, props.handlerId);
                let entryMenuButton = doWorkbench?this.getEntryMenuButton(entry):"";

                let entryName = entry.getDisplayName();
                if (entryName.length > 100) {
                    entryName = entryName.substring(0, 99) + "...";
                }
                let icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
                let link = HU.tag(TAG_A, ["target","_entries",ATTR_HREF, entry.getEntryUrl()], icon + " " + entryName);
                entryName = "";
                let entryIdForDom = entry.getIdForDom() + domIdSuffix;
                let entryId = entry.getId();
                let arrow = HU.image(icon_tree_closed, [ATTR_BORDER, "0",
							"tree-open", "false",
							ATTR_ID,
							this.getDomId(ID_TREE_LINK + entryIdForDom)
						       ]);
                let toggleCall = this.getGet() + ".toggleEntryDetails(event, '" + entryId + "'," + suffix + ",'" + props.handlerId + "');";
                let toggleCall2 = this.getGet() + ".entryHeaderClick(event, '" + entryId + "'," + suffix + "); ";
                let open = HU.onClick(toggleCall, arrow);
                let extra = "";

                if (showIndex) {
                    extra = "#" + (i + 1) + " ";
                }
                if (handler && handler.getEntryPrefix) {
                    extra += handler.getEntryPrefix(props.handlerId, entry);
                }


                let left = HU.div([ATTR_CLASS, "display-entrylist-name"], entryMenuButton + " " + open + " " + extra + link + " " + entryName);
		let snippet = "";
		snippet = HU.div([ATTR_CLASS, "display-entrylist-details-snippet", ATTR_ID, this.getDomId(ID_DETAILS_SNIPPET + entryIdForDom)], entry.getSnippet()||"");
		if(this.getProperty("showSnippetInList")) {
		    left+=snippet;
		    snippet = "";
		}
		let inner = HU.div([ATTR_CLASS, "display-entrylist-details-inner", ATTR_ID, this.getDomId(ID_DETAILS_INNER + entryIdForDom)], "");
                let details = HU.div([ATTR_ID, this.getDomId(ID_DETAILS + entryIdForDom), ATTR_CLASS, "display-entrylist-details"], 
				     HU.div([ATTR_CLASS, "display-entrylist-details-ancestors", ATTR_ID, this.getDomId(ID_DETAILS_ANCESTORS + entryIdForDom)], "") +
				     snippet +
				     HU.div([ATTR_CLASS, "display-entrylist-details-tags", ATTR_ID, this.getDomId(ID_DETAILS_TAGS + entryIdForDom)], "")+
				     inner
				    );

                //                    console.log("details:" + details);
                let line;
                if (doWorkbench && this.getProperty("showToolbar", true)) {
                    line = HU.leftCenterRight(left, "", toolbar, "80%", "1%", "19%");
                } else {
                    line = left;
                }
                //                    line = HU.leftRight(left,toolbar,"60%","30%");


                let mainLine = HU.div(["onclick", toggleCall2, ATTR_ID, this.getDomId(ID_DETAILS_MAIN + entryIdForDom), ATTR_CLASS, "display-entrylist-entry-main" + " " + "entry-main-display-entrylist-" + (even ? "even" : "odd"), ATTR_ENTRYID, entryId], line);
                line = HU.div([CLASS, (even ? "ramadda-row-even" : "ramadda-row-odd"), ATTR_ID, this.getDomId("entryinner_" + entryIdForDom)], mainLine + details);
                html += HU.div([ATTR_ID,
				this.getDomId("entry_" + entryIdForDom),
				ATTR_ENTRYID, entryId, ATTR_CLASS, "display-entrylist-entry" + rowClass
			       ], line);
                html += "\n";
            }
            return html;
        },
        addEntrySelect: function() {
            var theDisplay = this;
            var entryRows = $("#" + this.getDomId(ID_DISPLAY_CONTENTS) + "  ." + this.getClass("entry-main"));

            entryRows.unbind();
            entryRows.mouseover(async function(event) {
                //TOOLBAR
                var entryId = $(this).attr(ATTR_ENTRYID);
                var entry;
                await theDisplay.getEntry(entryId, e => {
                    entry = e
                });
                if (!entry) {
                    console.log("no entry:" + entryId);
                    return;
                }
                theDisplay.propagateEvent("entryMouseover", {
                    entry: entry
                });


                if (true) return;
                var domEntryId = Utils.cleanId(entryId);
                var toolbarId = theDisplay.getEntryToolbarId(domEntryId);

                var toolbar = $("#" + toolbarId);
                toolbar.show();
                var myalign = 'right top+1';
                var atalign = 'right top';
                var srcId = theDisplay.getDomId(ID_DETAILS_MAIN + domEntryId);
                toolbar.position({
                    of: $("#" + srcId),
                    my: myalign,
                    at: atalign,
                    collision: "none none"
                });

            });
            entryRows.mouseout(async function(event) {
                let entryId = $(this).attr(ATTR_ENTRYID);
                let entry;
                await theDisplay.getEntry(entryId, e => {
                    entry = e
                });
                if (!entry) return;
                theDisplay.propagateEvent("entryMouseout", {
                    entry: entry
                });
                let domEntryId = Utils.cleanId(entryId);
                let toolbarId = theDisplay.getEntryToolbarId(entryId);
                let toolbar = $("#" + toolbarId);
                //TOOLBAR                        toolbar.hide();
            });

            if (this.madeList) {
                //                    this.jq(ID_LIST).selectable( "destroy" );
            }
            this.madeList = true;
            if (false) {
                this.jq(ID_LIST).selectable({
                    //                        delay: 0,
                    //                        filter: 'li',
                    cancel: 'a',
                    selected: async function(event, ui) {
                        var entryId = ui.selected.getAttribute(ATTR_ENTRYID);
                        theDisplay.toggleEntryDetails(event, entryId);
                        if (true) return;

                        theDisplay.hideEntryDetails(entryId);
                        var entry;
                        await this.getEntry(entryId, e => {
                            entry = e
                        });
                        if (entry == null) return;

                        var zoom = null;
                        if (event.shiftKey) {
                            zoom = {
                                zoomIn: true
                            };
                        }
                        theDisplay.selectedEntries.push(entry);
                        theDisplay.propagateEvent(DisplayEvent.entrySelection, {
                            entry: entry,
                            selected: true,
                            zoom: zoom
                        });
                        theDisplay.lastSelectedEntry = entry;
                    },
                    unselected: async function(event, ui) {
                        if (true) return;
                        var entryId = ui.unselected.getAttribute(ATTR_ENTRYID);
                        var entry;
                        await this.getEntry(entryId, e => {
                            entry = e
                        });
                        var index = theDisplay.selectedEntries.indexOf(entry);
                        //                            console.log("remove:" +  index + " " + theDisplay.selectedEntries);
                        if (index > -1) {
                            theDisplay.selectedEntries.splice(index, 1);
                            theDisplay.propagateEvent(DisplayEvent.entrySelection, {
                                entry: entry,
                                selected: false
                            });
                        }
                    },

                });
            }

        },
        getEntriesTable: function(entries, columns, columnNames) {
            if (this.entriesMap == null)
                this.entriesMap = {};
            var columnWidths = this.getProperty("columnWidths", null);
            if (columnWidths != null) {
                columnWidths = columnWidths.split(",");
            }
            var html = HU.open(TAG_TABLE, [ATTR_WIDTH, "100%", "cellpadding", "0", "cellspacing", "0"]);
            html += HU.open(TAG_TR, ["valign", "top"]);
            for (var i = 0; i < columnNames.length; i++) {
                html += HU.td([ATTR_ALIGN, "center", ATTR_CLASS, "display-entrytable-header"], columnNames[i]);
            }
            html += HU.close(TAG_TR);

            for (var i = 0; i < entries.length; i++) {
                html += HU.open(TAG_TR, ["valign", "top"]);
                var entry = entries[i];
                this.entriesMap[entry.getId()] = entry;
                for (var j = 0; j < columns.length; j++) {
                    var columnWidth = null;
                    if (columnWidths != null) {
                        columnWidth = columnWidths[j];
                    }
                    var column = columns[j];
                    var value = "";
                    if (column == "name") {
                        value = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], entry.getName());
                    } else if (column.match(".*property:.*")) {
                        var type = column.substring("property:".length);
                        var metadata = entry.getMetadata();
                        value = "";
                        for (var j = 0; j < metadata.length; j++) {
                            var m = metadata[j];
                            if (m.type == type) {
                                if (value != "") {
                                    value += "<br>";
                                }
                                value += m.value.attr1;
                            }
                        }
                    } else if (column == "description") {
                        value = entry.getDescription();
                    } else if (column == "date") {
                        value = entry.ymd;
                        if (value == null) {
                            value = entry.startDate;
                        }

                    } else {
                        value = entry.getAttributeValue(column);
                    }
                    var attrs = [ATTR_CLASS, "display-entrytable-cell"];
                    if (columnWidth != null) {
                        attrs.push(ATTR_WIDTH);
                        attrs.push(columnWidth);
                    }

                    html += HU.td(attrs, value);
                }
                html += HU.close(TAG_TR);
            }
            html += HU.close(TAG_TABLE);
            return html;
        },

        makeEntryToolbar: function(entry, handler, handlerId) {
            var get = this.getGet();
            var toolbarItems = [];
	    var props = "{showMenu:true,showTitle:true}";
            //                 toolbarItems.push(HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl(),"target","_"], 
            //                                                HU.image(ramaddaCdn +"/icons/application-home.png",["border",0,ATTR_TITLE,"View Entry"])));
            if (entry.getType().getId() == "type_wms_layer") {
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".addMapLayer(" + HU.sqt(entry.getId()) + ");"],
					 HU.image(ramaddaCdn + "/icons/map.png", ["border", 0, ATTR_TITLE, "Add Map Layer"])));

            }
            if (entry.getType().getId() == "geo_shapefile" || entry.getType().getId() == "geo_geojson") {
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".addMapLayer(" + HU.sqt(entry.getId()) + ");"],
					 HU.image(ramaddaCdn + "/icons/map.png", ["border", 0, ATTR_TITLE, "Add Map Layer"])));

            }

            var jsonUrl = this.getPointUrl(entry);
            if (jsonUrl != null) {
                jsonUrl = jsonUrl.replace(/\'/g, "_");
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
						 HU.sqt("table") + "," + HU.sqt(jsonUrl) + "," + props+");"
						],
					 HU.getIconImage("fa-table", [ATTR_TITLE, "Create Tabular Display"])));

                var x;
                toolbarItems.push(x = HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
 						     HU.sqt("linechart") + "," + HU.sqt(jsonUrl) + "," + props +");"
						    ],
					     HU.getIconImage("fa-chart-line", [ATTR_TITLE, "Create Chart"])));
		//		console.log("X:" + x);
            }
            toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
					     HU.sqt("entrydisplay") + "," + HU.sqt(jsonUrl) + "," + props +");"
					    ],
				     HU.getIconImage("fa-file", ["border", 0, ATTR_TITLE, "Show Entry"])));
            if (entry.getFilesize() > 0) {
                toolbarItems.push(HU.tag(TAG_A, [ATTR_HREF, entry.getResourceUrl(),"download",null],
					 HU.image(ramaddaCdn + "/icons/download.png", ["border", 0, ATTR_TITLE, "Download (" + entry.getFormattedFilesize() + ")"])));

            }


            var entryMenuButton = this.getEntryMenuButton(entry);
            var tmp = [];



            if (handler && handler.addToToolbar) {
                handler.addToToolbar(handlerId, entry, toolbarItems);
            }

            for (var i = 0; i < toolbarItems.length; i++) {
                tmp.push(HU.div([ATTR_CLASS, "display-entry-toolbar-item"], toolbarItems[i]));
            }
            toolbarItems = tmp;
            return HU.div([ATTR_CLASS, "display-entry-toolbar", ATTR_ID,
			   this.getEntryToolbarId(entry.getIdForDom())
			  ],
			  HU.join(toolbarItems, ""));
        },
        getEntryToolbarId: function(entryId) {
            var id = entryId.replace(/:/g, "_").replace(/\//g,"_").replace(/[\(\)]/g,"_");
            id = id.replace(/=/g, "_");
            return this.getDomId(ID_TOOLBAR + "_" + id);
        },

        hideEntryDetails: function(entryId) {
            //                var popupId = "#"+ this.getDomId(ID_DETAILS + entryId);
            //                $(popupId).hide();
            //                this.currentPopupEntry = null;
        },
        entryHeaderClick: function(event, entryId, suffix) {
            var target = event.target;
            //A hack to see if this was the div clicked on or a link in the div
            if (target.outerHTML) {
                if (target.outerHTML.indexOf("<div") != 0) {
                    return;
                }
            }
            this.toggleEntryDetails(event, entryId);
        },
	makeEntryTags:function(entry,groupThem,prefix,metadataMap) {
	    prefix = prefix||"";
	    let metadata = "";
	    let map = {};
	    let list = [];
	    entry.getMetadata().forEach(m=>{
		//Check for exclusions
		if(["content.pagestyle", "content.pagetemplate","content.thumbnail","content.attachment"].includes(m.type)) return;
		if(m.type.startsWith("map")) return;
		if(m.type.startsWith("spatial")) return;		
                let tt = m.label+": " + m.value.attr1;
                let label =String(m.value.attr1);
		if(m.type=="property") {
		    tt +=":" + m.value.attr2;
		    label +=":" + m.value.attr2;
		}
		if(label.length>20) label = label.substring(0,19) +"...";
		label = prefix +label;
		let id = Utils.getUniqueId("metadata_");
		let tag = HU.div(["metadata-type",m.type,"metadata-value", m.value.attr1,ID,id,CLASS,"display-search-tag",TITLE, tt,STYLE, HU.css("background", getMetadataColor(m.type))],label);
		if(!groupThem)
		    metadata+= tag;
		else {
		    if(!map[m.type]) {
			map[m.type] = [];
			list.push(m);
		    }
		    map[m.type].push(tag);
		}
		if(metadataMap)
		    metadataMap[id] = m;
	    });
	    if(groupThem) {
		list.forEach(m=>{
		    metadata+=m.label +": " +map[m.type].join(" ");
		    metadata+="<br>";
		});
	    }

	    return metadata;
	},
        toggleEntryDetails: async function(event, entryId, suffix, handlerId, entry) {
	    if(!entry) {
		await this.getEntry(entryId, e => {
		    this.toggleEntryDetails(event, entryId, suffix, handlerId, e);
		});
		return;
	    }

            //                console.log("toggleEntryDetails:" + entry.getName() +" " + entry.getId());
            if (suffix == null) suffix = "";
            let link = this.jq(ID_TREE_LINK + entry.getIdForDom() + suffix);
            let id = ID_DETAILS + entry.getIdForDom() + suffix;
            let details = this.jq(id);
            if (event && event.shiftKey) {
                let id = Utils.cleanId(entryId);
                let line = this.jq(ID_DETAILS_MAIN + id);
                if (!this.selectedEntriesFromTree) {
                    this.selectedEntriesFromTree = {};
                }
                let selected = line.attr("ramadda-selected") == "true";
                if (selected) {
                    line.removeClass("display-entrylist-entry-main-selected");
                    line.attr("ramadda-selected", "false");
                    this.selectedEntriesFromTree[entry.getId()] = null;
                } else {
                    line.addClass("display-entrylist-entry-main-selected");
                    line.attr("ramadda-selected", "true");
                    this.selectedEntriesFromTree[entry.getId()] = entry;
                }
                this.propagateEvent(DisplayEvent.entrySelection, {
                    "entry": entry,
                    "selected": !selected
                });
                return;
            }

            let open = link.attr("tree-open") == "true";
            if (open) {
                link.attr("src", icon_tree_closed);
            } else {
                link.attr("src", icon_tree_open);
            }
            link.attr("tree-open", open ? "false" : "true");

	    let handleContent = ()=>{
		if (open) {
                    details.hide();
		} else {
                    details.show();
		}
		if (event && event.stopPropagation) {
                    event.stopPropagation();
		}
	    }

            let _this = this;
            let hereBefore = details.attr("has-content") != null;
            details.attr("has-content", "true");
            if (hereBefore) {
		handleContent();
		return;
            } 
	    let detailsInner = this.jq(ID_DETAILS_INNER + entry.getIdForDom() + suffix);
            if (!entry.isSynth() && entry.getIsGroup() /* && !entry.isRemote*/ ) {
                detailsInner.html(HU.image(icon_progress));
                let callback = function(entries) {
                    _this.displayChildren(entry, entries, suffix, handlerId);
                };
                let entries = entry.getChildrenEntries(callback);
            } else {
                detailsInner.html(this.getEntryHtml(entry, {
                    showHeader: false
                }));
            }
	    handleContent();



	    let metadataMap  = {};
	    let prefix = entry.isSynth()?"":HU.getIconImage("fas fa-search") + SPACE;
	    let metadata = this.makeEntryTags(entry,false,prefix,metadataMap);

	    let bar = this.jq(ID_DETAILS_TAGS + entry.getIdForDom() + suffix);
	    let typeTag = $(HU.span([CLASS,"display-search-tag"],prefix + "Type: " + entry.getType().getLabel())).appendTo(bar);
	    if(!entry.isSynth()) {
		typeTag.click(function() {
		    _this.typeTagClicked(entry.getType());
		});
	    }
	    let tags = $(metadata).appendTo(bar);
	    if(!entry.isSynth()) {
		tags.click(function() {
		    _this.metadataTagClicked(metadataMap[$(this).attr("id")]);
		});
	    }


	    if(!entry.isSynth() && this.getProperty("showEntryBreadcrumbs",true)) {
		let ancestorContent = "";
		let handleAncestor = ancestor=>{
		    if(!ancestor) {
			this.jq(ID_DETAILS_ANCESTORS + entry.getIdForDom() + suffix).html(ancestorContent);
		    } else {
			let href= ancestor.getLink(null, false,["target","_entries"]);
			if(ancestorContent!="")
			    href = href + HU.div([CLASS,"breadcrumb-delimiter"]);
			ancestorContent = href +  ancestorContent;
			ancestor.getParentEntry(handleAncestor);
		    }
		};
		entry.getParentEntry(handleAncestor);
	    }
        },
	metadataTagClicked:function(metadata) {
	},
	typeTagClicked:function(metadata) {
	},	
        getSelectedEntriesFromTree: function() {
            var selected = [];
            if (this.selectedEntriesFromTree) {
                for (var id in this.selectedEntriesFromTree) {
                    var entry = this.selectedEntriesFromTree[id];
                    if (entry != null) {
                        selected.push(entry);
                    }
                }
            }
            return selected;
        },
        displayChildren: function(entry, entries, suffix, handlerId) {
            if (!suffix) suffix = "";
            let detailsInner = this.jq(ID_DETAILS_INNER + entry.getIdForDom() + suffix);
            let details = this.getEntryHtml(entry, {
                showHeader: false,
		showImage:entries.length==0
            });
            if (entries.length == 0) {
                detailsInner.html(details);
            } else {
                let entriesHtml = details;
                if (this.showDetailsForGroup) {
                    entriesHtml += details;
                }
                entriesHtml += this.getEntriesTree(entries, {
                    handlerId: handlerId
                });
                detailsInner.html(entriesHtml);
                this.addEntrySelect();
            }
        },


        getEntryMenuButton: function(entry) {
            var menuButton = HU.onClick(this.getGet() + ".showEntryMenu(event, '" + entry.getId() + "');",
					HU.image(ramaddaCdn + "/icons/menu.png",
						 [ATTR_CLASS, "display-entry-toolbar-item", ATTR_ID, this.getDomId(ID_MENU_BUTTON + entry.getIdForDom())]));
            return menuButton;
        },
        setOriginalRamadda: function(e) {
            this.originalRamadda = e;
        },
        setRamadda: function(e) {
            this.ramadda = e;
        },	
        getRamadda: function() {
            if (this.ramadda != null) {
                return this.ramadda;
            }
            if (this.ramaddaBaseUrl != null) {
                this.ramadda = getRamadda(this.ramaddaBaseUrl);
                return this.ramadda;
            }
            return getGlobalRamadda();
        },
        getEntry: async function(entryId, callback) {
            if (this.entriesMap && this.entriesMap[entryId]) {
                return Utils.call(callback, this.entriesMap[entryId]);
            }
            var ramadda = this.getRamadda();
            var toks = entryId.split(",");
            if (toks.length == 2) {
                entryId = toks[1];
                ramadda = getRamadda(toks[0]);
            }
            var entry = null;
            if (this.entryList != null) {
                await this.entryList.getEntry(entryId, e => entry = e);
            }
            if (entry == null) {
                await ramadda.getEntry(entryId, e => entry = e);
            }

            if (entry == null) {
                await this.getRamadda().getEntry(entryId, e => entry = e);
            }
            return Utils.call(callback, entry);
        },
        addMapLayer: async function(entryId) {
            var entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                console.log("No entry:" + entryId);
                return;
            }
            this.getDisplayManager().addMapLayer(this, entry);
        },
        doit: function() {
            console.log("doit");
        },
        createDisplay: async function(entryId, displayType, jsonUrl, displayProps) {
            var entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                console.log("No entry:" + entryId);
                return null;
            }
            var props = {
                sourceEntry: entry,
                entryId: entry.getId(),
		//                showMenu: false,
		//                showTitle: false,
                showDetails: true,
                title: entry.getName(),
		layoutHere:false,
            };
            if (displayProps) {
		$.extend(props, displayProps);
	    }

            //TODO: figure out when to create data, check for grids, etc
            if (displayType != DISPLAY_ENTRYLIST) {
                if (jsonUrl == null) {
                    jsonUrl = this.getPointUrl(entry);
                }
                var pointDataProps = {
                    entry: entry,
                    entryId: entry.getId()
                };
                props.data = new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
            }
            if (this.lastDisplay != null) {
                props.column = this.lastDisplay.getColumn();
                props.row = this.lastDisplay.getRow();
            } else {
                props.column = this.getProperty("newColumn", this.getColumn());
                props.row = this.getProperty("newRow", this.getRow());
            }
            this.lastDisplay = this.getDisplayManager().createDisplay(displayType, props);
        },
        getPointUrl: function(entry) {
            //check if it has point data
            let service = entry.getService("points.json");
            if (service != null) {
                return service.url;
            }
            service = entry.getService("grid.point.json");
            if (service != null) {
                return service.url;
            }
            return null;
        },
        getEntryMenu: async function(entryId, callback) {
            var entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                return Utils.call(callback, "null entry");
            }

            var get = this.getGet();
            var menus = [];
            var fileMenuItems = [];
            var viewMenuItems = [];
            var newMenuItems = [];
            viewMenuItems.push(HU.tag(TAG_LI, [], HU.tag(TAG_A, ["href", entry.getEntryUrl(), "target", "_"], "View Entry")));
            if (entry.getFilesize() > 0) {
                fileMenuItems.push(HU.tag(TAG_LI, [], HU.tag(TAG_A, ["download",null, "href", entry.getResourceUrl()], "Download " + entry.getFilename() + " (" + entry.getFormattedFilesize() + ")")));
            }

            if (this.jsonUrl != null) {
                fileMenuItems.push(HU.tag(TAG_LI, [], "Data: " + HU.onClick(get + ".fetchUrl('json');", "JSON") +
					  HU.onClick(get + ".fetchUrl('csv');", "CSV")));
            }

	    var props = "{showMenu:true,showTitle:true}";
            var newMenu = "<a>New</a><ul>";
            newMenu += HU.tag(TAG_LI, [], HU.onClick(get + ".createDisplay('" + entry.getFullId() + "','entrydisplay',null,null," + props+");", "New Entry Display"));
            newMenuItems.push(HU.tag(TAG_LI, [], HU.onClick(get + ".createDisplay('" + entry.getFullId() + "','entrydisplay',null,null," + props+");", "New Entry Display")));

            //check if it has point data
            var pointUrl = this.getPointUrl(entry);
            //            console.log("entry:" + entry.getName() + " url:" + pointUrl);

            if (pointUrl != null) {
                var types = window.globalDisplayTypes;
                var catMap = {};
                if (types) {
                    for (var i = 0; i < types.length; i++) {
                        var type = types[i];

                        if (!type.requiresData || !type.forUser) continue;
                        if (!Utils.isDefined(catMap[type.category])) {
                            catMap[type.category] = "<li> <a>" + type.category + "</a><ul>\n";
                        }
                        pointUrl = pointUrl.replace(/\'/g, "_");
                        var call = get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," + HU.sqt(type.type) + "," + HU.sqt(pointUrl) + ",null," + props +");";
                        var li = HU.tag(TAG_LI, [], HU.tag(TAG_A, ["onclick", call], type.label));
                        catMap[type.category] += li + "\n";
                        newMenuItems.push(li);
                    }
                }

                for (a in catMap) {
                    newMenu += catMap[a] + "</li></ul>";
                }
            }


            if (fileMenuItems.length > 0)
                menus.push("<a>File</a>" + HU.tag(TAG_UL, [], HU.join(fileMenuItems)));
            if (viewMenuItems.length > 0)
                menus.push("<a>View</a>" + HU.tag(TAG_UL, [], HU.join(viewMenuItems)));
            if (newMenuItems.length > 0)
                menus.push(newMenu);

            var topMenus = "";
            for (var i = 0; i < menus.length; i++) {
                topMenus += HU.tag(TAG_LI, [], menus[i]);
            }

            var menu = HU.tag(TAG_UL, [ATTR_ID, this.getDomId(ID_MENU_INNER + entry.getIdForDom()), ATTR_CLASS, "sf-menu"],
			      topMenus);
            callback(menu);
        },
        showEntryMenu: async function(event, entryId) {
            var menu;
            await this.getEntryMenu(entryId, m => {
                menu = m
            });
            this.writeHtml(ID_MENU_OUTER, menu);
            var srcId = this.getDomId(ID_MENU_BUTTON + Utils.cleanId(entryId));
	    this.dialog = HU.makeDialog({content:menu,anchor:srcId,draggable:false,header:false});
            $("#" + this.getDomId(ID_MENU_INNER + Utils.cleanId(entryId))).superfish({
                speed: 'fast',
                delay: 300
            });
        },
        fetchUrl: function(as, url) {
            if (url == null) {
                url = this.jsonUrl;
            }
            url = this.getDisplayManager().getJsonUrl(url, this);
            if (url == null) return;
            if (as != null && as != "json") {
                url = url.replace("points.json", "points." + as);
            }
            window.open(url, '_blank');
        },
        getMenuItems: function(menuItems) {

        },
        getDisplayMenuSettings: function() {
            var get = "getRamaddaDisplay('" + this.getId() + "')";
            var moveRight = HU.onClick(get + ".moveDisplayRight();", "Right");
            var moveLeft = HU.onClick(get + ".moveDisplayLeft();", "Left");
            var moveTop = HU.onClick(get + ".moveDisplayTop();", "Top");
            var moveUp = HU.onClick(get + ".moveDisplayUp();", "Up");
            var moveDown = HU.onClick(get + ".moveDisplayDown();", "Down");


            var menu = HU.open(TABLE,[CLASS,'formtable']) +
                "<tr><td align=right><b>Move:</b></td><td>" + moveTop + " " + moveUp + " " + moveDown + " " + moveRight + " " + moveLeft + "</td></tr>" +
                "<tr><td align=right><b>Row:</b></td><td> " + HU.input("", this.getProperty("row", ""), ["size", "7", ATTR_ID, this.getDomId("row")]) + " &nbsp;&nbsp;<b>Col:</b> " + HU.input("", this.getProperty("column", ""), ["size", "7", ATTR_ID, this.getDomId("column")]) + "</td></tr>" +
                "<tr><td align=right><b>Width:</b></td><td> " + HU.input("", this.getProperty("width", ""), ["size", "7", ATTR_ID, this.getDomId("width")]) + "  " + "<b>Height:</b> " + HU.input("", this.getProperty("height", ""), ["size", "7", ATTR_ID, this.getDomId("height")]) + "</td></tr>" +
                "</table>";
            var tmp =
                HU.checkbox(this.getDomId("showtitle"), [], this.getProperty("showTitle")) + " Title  " +
                HU.checkbox(this.getDomId("showdetails"), [], this.getProperty("showDetails")) + " Details " +
                "&nbsp;&nbsp;&nbsp;" +
                HU.onClick(get + ".askSetTitle();", "Set Title");
            menu += HU.formTable() + HU.formEntry("Show:", tmp) + HU.close(TABLE);
            return menu;
        },
        loadInitialData: function() {
	    if(!this.getProperty("okToLoadData",true)) return;
            if (!this.needsData() || this.properties.theData == null) {
                return;
            }
            if (this.getProperty("latitude")) {
                this.properties.theData.lat = this.getProperty("latitude");
                this.properties.theData.lon = this.getProperty("longitude", "-105");
            }


            if (this.properties.theData.hasData()) {
                this.addData(this.properties.theData);
                return;
            }
            this.properties.theData.loadData(this);
        },
        getData: function() {
            if (!this.hasData()) {
		//Inline data
		if(this.properties.dataSrc) {
		    this.addData(makeInlineData(this,this.properties.dataSrc));
		} else {
		    return null;
		}
	    }
            var dataList = this.dataCollection.getList();
            return dataList[0];
        },
        hasData: function() {
            if (this.dataCollection == null) return false;
            return this.dataCollection.hasData();
        },
        getCreatedInteractively: function() {
            return this.createdInteractively == true;
        },
        needsData: function() {
            return false;
        },
        askSetTitle: function() {
            var t = this.getTitle(false);
            var v = prompt(TITLE, t);
            if (v != null) {
                this.title = v;
                this.setProperty(ATTR_TITLE, v);
                this.setDisplayTitle(this.title);
            }
        },
        getShowDetails: function() {
            return this.getSelfProperty("showDetails", true);
        },
        setShowDetails: function(v) {
            this.showDetails = v;
            if (this.showDetails) {
                this.jq(ID_DETAILS).show();
            } else {
                this.jq(ID_DETAILS).hide();
            }
        },
        setShowTitle: function(v) {
	    if(v==="true") v = true;
	    else if(v==="false") v = true;	    
            this.setProperty("showTitle", v);
            if (v) {
                this.jq(ID_TITLE).show();
            } else {
                this.jq(ID_TITLE).hide();
            }
        },
        setDisplayProperty: function(key, value) {
            this.setProperty(key, value);
            $("#" + this.getDomId(key)).val(value);
        },
        deltaColumn: function(delta) {
            var column = parseInt(this.getProperty("column", 0));
            column += delta;
            if (column < 0) column = 0;
            this.setDisplayProperty("column", column);
            this.getLayoutManager().layoutChanged(this);
	    this.jq("col").val(column);
        },
        deltaRow: function(delta) {
            var row = parseInt(this.getProperty("row", 0));
	    if(isNaN(row)) row = 0;
            row += delta;
            if (row < 0) row = 0;
            this.setDisplayProperty("row", row);
            this.getLayoutManager().layoutChanged(this);
	    this.jq("row").val(row);
        },
        moveDisplayRight: function() {
            if (this.getLayoutManager().isLayoutColumns()) {
                this.deltaColumn(1);
            } else {
                this.getLayoutManager().moveDisplayDown(this);
            }
        },
        moveDisplayLeft: function() {
            if (this.getLayoutManager().isLayoutColumns()) {
                this.deltaColumn(-1);
            } else {
                this.getLayoutManager().moveDisplayUp(this);
            }
        },
        moveDisplayUp: function() {
            if (this.getLayoutManager().isLayoutRows()) {
                this.deltaRow(-1);
            } else {
                this.getLayoutManager().moveDisplayUp(this);
            }
        },
        moveDisplayDown: function() {
            if (this.getLayoutManager().isLayoutRows()) {
                this.deltaRow(1);
            } else {
                this.getLayoutManager().moveDisplayDown(this);
            }
        },
        moveDisplayTop: function() {
            this.getLayoutManager().moveDisplayTop(this);
        },
        getDialogContents: function(tabTitles, tabContents) {
	    this.getDisplayDialogContents(tabTitles, tabContents);
        },
        getDisplayDialogContents: function(tabTitles, tabContents) {
            var get = this.getGet();
            var menuItems = [];
            this.getMenuItems(menuItems);
            var form = "<form>";

            form += this.getDisplayMenuSettings();
            for (var i = 0; i < menuItems.length; i++) {
                form += HU.div([ATTR_CLASS, "display-menu-item"], menuItems[i]);
            }
            form += "</form>";
            tabTitles.push("Display"); 
            tabContents.push(form);
        },	
        checkLayout: function() {
	},
        displayData: function() {},
        setDisplayReady: function() {
//	    console.log("setDisplayReady");
	    var callUpdate = !this.displayReady;
            this.displayReady = true;
	    if(callUpdate) {
		this.callUpdateUI({force:true});
	    }
        },
        getDisplayReady: function() {
            return this.displayReady;
        },
        pageHasLoaded: function() {
	    if(!this.displayReady) {
		this.setDisplayReady(true);
	    }
        },
	checkFinished: function() {
	    return false;
	},
	getIsFinished() {
	    return this.isFinished;
	},
	setIsFinished() {
//	    console.log(this.type+" isFinished");
	    this.isFinished = true;
	},	
	isDisplayFinished: function() {
	    if(this.checkFinished()) {
		return this.getIsFinished();
	    }
            if (!this.hasData()) {
		if(this.needsData()) {
		    return false;
		}
	    }
	    return true;
	},
	doFinalInitialization:function() {
	},
        initDisplay: function() {
	    if(this.inError) return
            this.createUI();
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().makeControls();
            }
            this.checkSearchBar();
	    this.callUpdateUI({force:true});
	    if(this.getProperty("reloadSeconds")) {
		this.runReload();
	    }
        },
	runReload: function() {
	    setTimeout(() =>{
		this.reloadData();
		this.runReload();
	    }, this.getProperty("reloadSeconds")*1000);
	},
        getMainDiv: function() {
	    //Don't check the parent for the targetDiv
	    let divId = this.getProperty("targetDiv",this.getProperty(PROP_DIVID,null,null,true),null,true);
	    return $("#" + divid); 
	},
        getGroupDiv: function() {
	    return $("#" + this.getProperty("groupDiv"));
	},	
        createUI: function() {
	    let divId = this.getProperty("targetDiv",this.getProperty(PROP_DIVID,null,null,true),null,true);
            if (divId != null) {
                var html = this.getHtml();
		let div = $("#" + divId);
		let inline = this.getProperty("displayInline");
		if(inline) {
		    div.css("display","inline-block");
		    div.css("vertical-align","bottom");
		} 
		let width = this.getWidth("100%");
		if(width && width!="-1") {
                    div.css("width",HU.getDimension(width));
		}
		div.html(html);
            } else {
                console.log("error: no div defined for display:" + this.getType());
            }
        },
        /*
          This creates the default layout for a display
          Its a table:
          <td>title id=ID_HEADER</td><td>align-right popup menu</td>
          <td colspan=2><div id=ID_DISPLAY_CONTENTS></div></td>
          the getDisplayContents method by default returns:
          <div id=ID_DISPLAY_CONTENTS></div>
          but can be overwritten by sub classes

          After getHtml is called the DisplayManager will add the html to the DOM then call
          initDisplay
          That needs to call setContents with the html contents of the display
        */
        getHtml: function() {
            let get = this.getGet();
            let button = "";

            if (this.getShowMenu()) {
                button = HU.onClick(get + ".showDialog();",
				    HU.image(ramaddaCdn + "/icons/downdart.png",
					     [ATTR_CLASS, "display-dialog-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)]));
		button+=" ";
            }
	    if(this.getShowProgress(false)) {
		//		button += HU.image(icon_progress,[ID,this.getDomId(ID_DISPLAY_PROGRESS)]);
	    }
            let title = "";
            if (this.getShowTitle()) {
                title = this.getTitle(false).trim();
            }

            let topLeft = "";
            if (button != "" || title != "") {
                let titleDiv = this.getTitleHtml(title);
                if (button == "") {
                    topLeft = titleDiv;
                } else {
                    topLeft = HU.div(["class","display-header"], button + SPACE + titleDiv);
                }
		
            }
            topLeft = HU.div([ID, this.getDomId(ID_TOP_LEFT),CLASS,"display-header-block"], topLeft);

	    let h2Separate = this.getAnimationEnabled();
	    let h1 = 	HU.div([ID,this.getDomId(ID_HEADER1),CLASS,"display-header-block display-header1"], "");
	    let h2 = HU.div([ID,this.getDomId(ID_HEADER2),CLASS,"display-header-block display-header2"], "");
            let topCenter = HU.div([ID, this.getDomId(ID_TOP),CLASS,"display-header-block"], h2Separate?"":h2);
            let topRight = HU.div([ID, this.getDomId(ID_TOP_RIGHT)], "");
	    let top =  this.getProperty("showHeader",true)?HU.leftCenterRight(topLeft, topCenter, topRight, null, null, null,{
                valign: "bottom"
            }):"";
            let header = h1;
	    if(h2Separate) header+=h2;
	    top =  header +  top;	    


	    let colorTable = HU.div([ID,this.getDomId(ID_COLORTABLE)]);
	    let rightInner="";
	    let leftInner="";

	    let bottom = HU.div([ATTR_CLASS, "", ATTR_ID, this.getDomId(ID_BOTTOM)]);
	    let legend = HU.div([ID,this.getDomId(ID_LEGEND)]);

	    let ctSide = this.getProperty("colorTableSide","bottom");
	    if(ctSide=="top") {
		top+=colorTable;
	    } else if(ctSide=="right") {
		rightInner += colorTable;
	    } else if(ctSide=="left") {
		leftInner += colorTable;
	    } else {
		bottom+=colorTable;
	    }
	    bottom+=legend;
	    let leftStyle = "";
	    if(this.getProperty("leftSideWidth"))
		leftStyle = HU.css("width",HU.getDimension(this.getProperty("leftSideWidth")));
	    let left = HU.div([ATTR_ID, this.getDomId(ID_LEFT),STYLE,leftStyle],leftInner);
	    let right = HU.div([ATTR_ID, this.getDomId(ID_RIGHT)],rightInner);
	    let sideWidth = "1%";
	    let centerWidth = "98%";	    
            let contents = this.getContentsDiv();
	    //display table
	    //We set a transparent 1px border here because for some reason the google charts will have a little bit of scroll in them if we don't set a border
            let table =   HU.open('table', [STYLE,"border:1px solid transparent;",CLASS, 'display-ui-table', 'width','100%','border','0','cellpadding','0','cellspacing','0']);
	    if(this.getProperty('showDisplayTop',true)) {
		table+= HU.tr([],HU.td(['width',sideWidth]) + HU.td(['width',centerWidth],top) +HU.td(['width',sideWidth]));
	    }
	    table+= HU.tr(["valign","top"],HU.td(['width',sideWidth],left) + HU.td(['width',centerWidth],contents) +HU.td(['width',sideWidth],right));
	    if(this.getProperty('showDisplayBottom',true)) {
		table+= HU.tr([],HU.td(['width',sideWidth]) + HU.td(['width',centerWidth],bottom) +HU.td(['width',sideWidth]));
	    }
	    table+=HU.close('table');
	    let message= HU.div([ID,this.domId(ID_DISPLAY_MESSAGE),CLASS,"display-output-message", STYLE,HU.css("display","none","position","absolute","top","10px","left","50%",
									"-webkit-transform","translateX(-50%)","transform","translateX(-50%)")],"message");
            let html =  HU.div([ATTR_CLASS, 'ramadda-popup', STYLE,"display:none;", ATTR_ID, this.getDomId(ID_MENU_OUTER)], '');
            let style = this.getProperty('displayStyle', '');
            html += HU.div([CLASS, 'display-contents display-' + this.type +'-contents', STYLE, HU.css('position','relative') + style],table + message);
            return html;
        },
        getWidthForStyle: function(dflt) {
            var width = this.getProperty("width", -1);
            if (width == -1) return dflt;
	    return HU.getDimension(width);
        },
        getHeightForStyle: function(dflt) {
            let height = this.getProperty("height", -1);
            if (height == -1) return dflt;
            if (new String(height).match("^[0-9]+$")) {
                height = height + "px";
	    }
            return height;
        },
        getContentsStyle: function() {
            let style = "";
            let height = this.getHeightForStyle();
            if (height) {
                style += HU.css(HEIGHT, height);
            }
            let maxheight = this.getProperty("maxHeight");
            if (maxheight) {
                style += HU.css("max-height", HU.getDimension(maxheight),"overflow-y","auto");
            }	    
            return style;
        },
	getContentsClass: function() {
	    return "ramadda-expandable-target display-contents-inner display-" + this.type;
	},
        getContentsDiv: function() {
            let style = this.getContentsStyle();
            style += this.getProperty("contentsStyle", "");
            let image = this.getProperty("backgroundImage");
            if (image) {
                image = HU.getEntryImage(this.entryId, image);
                style += HU.css("background-attachment","auto","background-size","100% auto","background-image","url('" + image + "')");
            }
            let background = this.getProperty("background");
            if (background)
                style += HU.css("background", background);
            let topBottomStyle = "";
	    //            let width = this.getWidthForStyle();
	    //            if (width) {
	    //                topBottomStyle += HU.css("width", width);
	    //            }
            let top = HU.div([STYLE, topBottomStyle, ATTR_ID, this.getDomId(ID_DISPLAY_TOP)], "");
            let bottom = HU.div([STYLE, topBottomStyle, ATTR_ID, this.getDomId(ID_DISPLAY_BOTTOM)], "");
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(expandedHeight)
		style+=HU.css(HEIGHT,expandedHeight);
	    let contentsAttrs =[ATTR_CLASS, this.getContentsClass(), STYLE, style, ATTR_ID, this.getDomId(ID_DISPLAY_CONTENTS)];
	    if(this.getProperty("expandableHeight")) {
		contentsAttrs.push("expandable-height");
		contentsAttrs.push(this.getProperty("expandableHeight"));
	    }
	    let contents =  top + "\n" +HU.div(contentsAttrs, "") + "\n" +bottom;
            return contents;
        },

        //Gets called before the displays are laid out
        prepareToLayout: function() {
            //Force setting the property from the input dom (which is about to go away)
            this.getColumn();
            this.getWidth();
            this.getHeight();
            this.getName();
            this.getEventSource();
        },
        getColumn: function() {
            return this.getFormValue("column", 0);
        },
        getRow: function() {
            return this.getFormValue("row", 0);
        },
        getWidth: function(dflt) {
            return this.getFormValue("width", dflt);
        },
        getHeight: function() {
            return this.getFormValue("height", 0);
        },
        getDisplayTitle: function(title) {
            if (!title) title = this.title != null ? this.title : "";
            var text = title;
            var fields = this.lastSelectedFields;
            if (fields && fields.length > 0)
                text = text.replace("{field}", fields[0].getLabel());
            else
                text = text.replace("{field}", HU.span([ID,this.getDomId(ID_TITLE_FIELD)],"&nbsp;"));
            return text;
        },

        setDisplayTitle: function(title) {
            if (!Utils.stringDefined(title)) {
                title = this.getTitle(false).trim();
            }
            var text = this.getTitleHtml(title);
            if (this.getShowTitle()) {
                this.jq(ID_TITLE).show();
            } else {
                this.jq(ID_TITLE).hide();
            }
            this.writeHtml(ID_TITLE, text);
        },
        getTitle: function(showMenuButton) {
            var prefix = "";
            if (showMenuButton && this.hasEntries()) {
                prefix = this.getEntryMenuButton(this.getEntries()[0]) + " ";
            }
            var title = this.getProperty(ATTR_TITLE);
            if (title != null) {
                return prefix + title;
            }
            if (this.dataCollection == null) {
                return prefix;
            }
            var dataList = this.dataCollection.getList();
            title = "";
            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                var pointData = dataList[collectionIdx];
                if (collectionIdx > 0) title += "/";
                title += pointData.getName();
            }

            return prefix + title;
        },
        getIsLayoutFixed: function() {
            return this.getProperty(PROP_LAYOUT_HERE, true);
        },

        makeToolbar: function(props) {
            var toolbar = "";
            var get = this.getGet();
            var addLabel = props.addLabel;
            var images = [];
            var calls = [];
            var labels = [];
            if (!this.getIsLayoutFixed()) {
                calls.push("removeRamaddaDisplay('" + this.getId() + "')");
                images.push("fa-cut");
		labels.push("Delete display");
            }
            calls.push(get + ".copyDisplay();");
	    images.push("fa-copy");
            labels.push("Copy Display");
            if (this.jsonUrl != null) {
                calls.push(get + ".fetchUrl('json');");
                images.push(ramaddaCdn + "/icons/json.png");
                labels.push("Download JSON");

                calls.push(get + ".fetchUrl('csv');");
                images.push(ramaddaCdn + "/icons/csv.png");
                labels.push("Download CSV");
            }
            for (var i = 0; i < calls.length; i++) {
                var inner = HU.getIconImage(images[i], [ATTR_TITLE, labels[i], ATTR_CLASS, "display-dialog-header-icon"]);
                if (addLabel) inner += " " + labels[i] + "<br>";
                toolbar += HU.onClick(calls[i], inner);
            }
            return toolbar;
        },

	getHeader2:function() {
	    return "";
	},
	initHeader2:function() {
	},
	writeHeader:function(header,html) {
	    if(html=="") {
		this.jq(header).css("display","none");
	    } else {
		this.jq(header).css("display","inline-block");
	    }
	    this.jq(header).html(html);
	},

        //This keeps checking the width of the chart element if its zero
        //we do this for displaying in tabs
        checkLayout: function() {
            let d = this.jq(ID_DISPLAY_CONTENTS);
	    let w= d.width();
            if (this.lastWidth != w) {
		this.lastWidth = w;
                this.displayData();
            }
	},


        forceUpdateUI: function() {
	    this.haveCalledUpdateUI = false;
	    this.callUpdateUI();
	},
	callUpdateUI: function(args) {
	    args = args || {};
	    try {
		if(args.force)
		    this.haveCalledUpdateUI = false;
		this.updateUI(args);
	    } catch(err) {
		this.handleError("Error:" + err,err);
	    }
	},
        updateUI: function(args) {
	},
	getFilterId: function(id) {
	    return  this.getDomId("filterby_" + id);
	},
	getRequestMacros: function() {
	    if(!this.requestMacros) {
		this.requestMacros  = this.getRequestMacrosInner();
	    }
	    return this.requestMacros;
	},
	getRequestMacrosInner: function() {
	    let macros =[];
	    let p = this.getProperty("requestFields","");
	    let e1 = this.getProperty("extraFields1","");
	    let e2 = this.getProperty("extraFields2","");
	    let list = Utils.mergeLists(e1.split(","),p.split(","),e2.split(","));
//	    if(p!="")console.log("requestFields=" + p);
	    list.forEach(macro=>{
		if(macro=="") return;
		macros.push(new RequestMacro(this, macro));
	    });
	    return macros;
	},
	applyRequestProperties: function(props) {
	    if(!props) return;
	    this.requestMacros = null;
	    this.dynamicProperties = props;
	    this.createRequestProperties();
	},
	createRequestProperties: function() {
	    let requestProps = "";
	    let macros = this.getRequestMacros();
	    let macroDateIds = [];
	    macros.forEach(macro=>{
		requestProps+=macro.getWidget(macroDateIds) +"&nbsp;&nbsp;";
		if(macro.isVisible()) {
		    requestProps+=SPACE2;
		}
	    });
	    this.writeHeader(ID_REQUEST_PROPERTIES, requestProps);
	    let macroChange = (macro,value,what)=>{
		if(this.settingMacroValue) return;
		if(macro.triggerReload) {
		    this.macroChanged();
		    this.reloadData();
		}
		if(!macro.name) return;
		this.settingMacroValue = true;
		let args = {
		    entryId:this.entryId,
		    property: "macroValue",
		    id:macro.name,
		    what:what,
		    value: value
		};
		this.propagateEvent(DisplayEvent.propertyChanged, args);
		this.settingMacroValue = false;
	    };

	    let sliderFunc = function() {
		//		macroChangeinputFunc
	    };

	    macroDateIds.forEach(id=>{
		HU.datePickerInit(id);
	    });
	    this.jq(ID_HEADER2).find(".display-request-reload").click(()=>{
		macroChange({triggerReload:true});
	    });
	    macros.every(macro=>{
		$("#" + this.getDomId(macro.getId())+"," +
		  "#" + this.getDomId(macro.getId()+"_min")+ "," +
		  "#" + this.getDomId(macro.getId()+"_max")+ "," +
		  "#" + this.getDomId(macro.getId()+"_from")+ "," +
		  "#" + this.getDomId(macro.getId()+"_to")).keyup(function(e) {
		      var keyCode = e.keyCode || e.which;
		      if (keyCode == 13) {
			  macroChange(macro, $(this).val());
		      }
		  });
		if(macro.type == "bounds") {
		    this.jq(macro.getId()).change(function(e) {
			macroChange(macro,$(this).is(':checked'));
		    });
		}
		if(macro.type=="enumeration") {
		    this.jq(macro.getId()).change(function(e) {
			macroChange(macro, $(this).val());
		    });
		}
		this.jq(macro.getId()+"_min").change(function(e) {
		    //		    macroChange(macro, $(this).val(),"min");
		});
		this.jq(macro.getId()+"_max").change(function(e) {
		    //		    macroChange(macro, $(this).val(),"max");
		});
		this.jq(macro.getId()+"_from").change(function(e) {
		    macroChange(macro, $(this).val(),"from");
		});
		this.jq(macro.getId()+"_to").change(function(e) {
		    macroChange(macro, $(this).val(),"to");
		});		

		return true;
	    });
	},
	makeFilterWidget:function(label, widget, title) {
	    if(!label)
		return HU.div([CLASS,"display-filter-widget"],widget);
	    return HU.div([CLASS,"display-filter-widget"],this.makeFilterLabel(label,title)+(label.trim().length==0?" ":": ") +
			  widget);
	},
	makeFilterLabel: function(label,tt,vertical) {
	    let clazz = "display-filter-label";
	    if(vertical)
		clazz+= " display-filter-label-vertical ";
	    let attrs = [CLASS,clazz];
	    if(tt)  {
		attrs.push(TITLE);
		attrs.push(tt);
	    }
	    return HU.span(attrs,label);
	},

	stepFilterDateAnimation: function(inputFunc, dir){
	    let select = $("#" +this.getFilterId(ID_FILTER_DATE));
	    let index = select[0].selectedIndex;
	    let length = select.find('option').length;
	    index+=dir;
	    if(index>=length) {
		return;
//		index =0;
	    } else if(index<0) {
		return;
//		index = length-1;
	    }
	    select[0].selectedIndex = index;
	    inputFunc(select);
	    if(this.filterDatePlayingAnimation) {
		setTimeout(()=>{
		    this.stepFilterDateAnimation(inputFunc,1);
		},this.getProperty("filterDateAnimationSleep",1000));
	    }
	},

	addFilters: function(filters) {
	},
	initializeRangeSlider:function(jq, inputFunc, immediate) {
	    let _this = this;
	    jq.mousedown(function(){
		let id = $(this).attr(ID);
		//Do these like this in case we have a field that ends with _max
		if(id.endsWith("_min")) {
		    id = id.replace(/_min$/,"");
		} else if(id.endsWith("_max")) {
			id = id.replace(/_max$/,"");
		}
		let min = $("#" + id+"_min");
		let max = $("#" + id+"_max");
		let range = {
		    min: parseFloat(min.attr("data-min")),
		    max: parseFloat(max.attr("data-max"))};
		let smin =  String(min.attr("data-min")).replace(/.*\./,"");
		let smax =  String(max.attr("data-max")).replace(/.*\./,"");		
		let numDecimals = Math.max(smin.length,smax.length);
		let minValue = parseFloat(min.val());
		let maxValue = parseFloat(max.val());
		let html = HU.div([ID,"filter-range",STYLE,HU.css("width","200px")],"");
		let popup = HtmlUtils.getTooltip();
		popup.html(html);
		popup.show();

		popup.position({
		    of: min,
		    my: "left top",
		    at: "left bottom+2",
		    collision: "fit fit"
                });

		if(isNaN(minValue)) minValue = range.min;	
		if(isNaN(maxValue)) maxValue = range.max;
		var step = 1;
		if(parseInt(range.max)!=range.max || parseInt(range.min) != range.min) 
		    step = (range.max-range.min)/100000;
		$( "#filter-range" ).slider({
		    range: true,
		    min: range.min,
		    max: range.max,
		    step: step,
		    values: [minValue, maxValue],
		    slide: function( event, ui ) {
			let minv = String(Utils.roundDecimals(ui.values[0], numDecimals));
			let maxv = String(Utils.roundDecimals(ui.values[1], numDecimals));
			if(minv.endsWith(".")) minv = minv.replace(/\./,"");
			if(maxv.endsWith(".")) maxv = maxv.replace(/\./,"");			
			min.val(minv);
			max.val(maxv);
			min.attr("data-value",min.val());
			max.attr("data-value",max.val());
			if(immediate) {
			    inputFunc(min,max);
			}
		    },
		    stop: function() {
			var popup = HtmlUtils.getTooltip();
			popup.hide();
			_this.checkFilterField(max);
			inputFunc(min,max);
		    }
		});
	    });
	},
	getRecordFilter: function(fieldId) {
	    if(this.filters) {
		for(let i=0;i<this.filters.length;i++) {
		    let filter = this.filters[i];
		    if(filter.field && filter.field.getId() == fieldId) return this.filters[i];
		}
	    }
	    return null;
	},
        checkSearchBar: function() {
	    let hideFilterWidget = this.getProperty("hideFilterWidget",false, true);
	    let vertical =  this.getProperty("headerOrientation","horizontal") == "vertical";
	    let filterClass = "display-filter";
	    let debug = displayDebug.checkSearchBar;
	    if(debug) console.log("checkSearchBar");
            let _this = this;

            let colorBy = this.getFieldById(null, this.getProperty("colorBy",""));
            this.colorByFields = this.getFieldsByIds(null, this.getProperty("colorByFields", "", true));
            this.sizeByFields = this.getFieldsByIds(null, this.getProperty("sizeByFields", "", true));
            this.sortByFields = this.getFieldsByIds(null, this.getProperty("sortByFields", "", true));	    

	    let pointData = this.getData();
            if (pointData == null) return;
            let fields= pointData.getRecordFields();
            let records = pointData.getRecords();
	    records = this.sortRecords(records);
	    let header2="";
	    //	    header2 +=HU.div([ID,this.getDomId("test")],"test");
	    if(this.getShowProgress(false)) {
		header2 += HU.div([ID,this.getDomId(ID_DISPLAY_PROGRESS), STYLE,HU.css("display","inline-block","margin-right","4px","min-width","20px")]);
	    }
	    header2 += HU.div([CLASS,"display-header-span"],"");
	    header2 += HU.div([ID,this.getDomId(ID_HEADER2_PREPREPREFIX),CLASS,"display-header-span"],"");
	    header2 += HU.div([ID,this.getDomId(ID_HEADER2_PREPREFIX),CLASS,"display-header-span"],"");
	    header2 += HU.div([ID,this.getDomId(ID_HEADER2_PREFIX),CLASS,"display-header-span"],"");

	    header2 +=  this.getHeader2();
	    if(this.getProperty("pageRequest",false) || this.getProperty("filterPaginate")) {
		
		header2 += HU.div([CLASS,"display-header-span display-filter",ID,this.getDomId(ID_PAGE_COUNT)]);
	    }
	    header2+=HU.div([ID,this.getDomId(ID_REQUEST_PROPERTIES),CLASS,"display-header-span"],"");
	    if(this.getProperty("legendFields") || this.getProperty("showFieldLegend",false)) {
		let colors = this.getColorList();
		let fields =  this.getFieldsByIds(null, this.getProperty("legendFields", this.getPropertyFields(this.getProperty("sumFields"))));
		let html = "";
		let colorCnt = 0;
		fields.forEach((f)=>{
		    if(colorCnt>=colors.length) colorCnt = 0;
		    let color  = colors[colorCnt];
		    html += HU.div([STYLE,HU.css("display","inline-block","width","8px","height","8px","background",color)]) +" " + f.getLabel() +"&nbsp;&nbsp; ";
		    colorCnt++;
		});
		header2+= html;

	    }

	    if(this.getProperty("showDisplayFieldsMenu",false)) {
		let displayFields =  pointData.getChartableFields();
		if(displayFields.length) {
		    let fields = this.getSelectedFields();
		    let selected =[];
		    fields.forEach(f=>selected.push(f.getId()));
		    let enums = [];
		    displayFields.forEach(field=>{
			if(field.isFieldGeo()) return;
			enums.push([field.getId(),field.getLabel()]);
		    });
		    let attrs = [ID,this.getDomId("displayfields")];
		    if(this.getProperty("displayFieldsMenuMultiple",false)) {
			attrs.push("multiple");
			attrs.push("true");
			attrs.push("size");
			attrs.push("4");
		    }
		    this.displayFieldsMenuEnums = enums;
		    let html =  HU.span([CLASS,filterClass],
				       this.makeFilterLabel("Display: ") + HU.select("",attrs,enums,selected))+SPACE;
		    let side = this.getProperty("displayFieldsMenuSide","top");
		    if(side == "left") {
			this.jq(ID_LEFT).append(html);
		    } else {
			//TODO: do the other sides
			header2+=html;
		    }
		}
	    }


	    let selectFields = this.getProperty("selectFields");
	    let selectFieldProps = [];
	    if(selectFields) {
		selectFields.split(";").forEach(t=>{
		    //htmlLayerField:Sparkline Field:field1,field2
		    let [prop,label,fields]  = t.split(":");
		    if(fields==null) {
			fields = label;
			label = Utils.makeLabel(prop);
		    }
		    let selectFields = this.getFieldsByIds(null,fields);
		    let enums = [];
		    selectFields.forEach(field=>{
			if(field.isFieldGeo()) return;
			enums.push([field.getId(),field.getLabel()]);
		    });
		    header2 += HU.span([CLASS,filterClass],
				       (label==""?"":this.makeFilterLabel(label+": ")) + 
				       HU.select("",[ID,this.getDomId("fieldselect_" + prop)],enums,this.getProperty(prop,"")))+SPACE;

		    selectFieldProps.push(prop);
		});
	    }


	    if(this.colorByFields.length>0) {
		let enums = [];
		this.colorByFields.forEach(field=>{
		    if(field.isFieldGeo()) return;
		    enums.push([field.getId(),field.getLabel()]);
		});
		let selected = colorBy?colorBy.getId():"";
		header2 += HU.span([CLASS,filterClass],
				   this.makeFilterLabel(this.getProperty("colorByLabel", "Color by: ")) + HU.select("",[ID,this.getDomId("colorbyselect")],enums,selected))+SPACE;
	    }
	    let sortAscending = this.getProperty("sortAscending",true);
	    if(this.sortByFields.length>0) {
		let enums = [];
		this.sortByFields.forEach(field=>{
		    if(field.isFieldGeo()) return;
		    let id = field.getId();
		    let label = field.getLabel();
		    if(Utils.stringDefined(field.getGroup())) {
			label = field.getGroup()+"-" + label;
		    }
		    let suffix1=" &uarr;";
		    let suffix2=" &darr;";
		    if(field.isFieldString()) {
			suffix1 = "A-Z";
			suffix2 = "Z-A";
		    }
		    if(sortAscending || field.isFieldString()) {
			enums.push([id+"_up",label + " " + suffix1]);
			enums.push([id+"_down",label + " " + suffix2]);
		    } else {
			enums.push([id+"_down",label + " " + suffix2]);
			enums.push([id+"_up",label + " " + suffix1]);
		    }
		});
		header2 += HU.span([CLASS,filterClass],
				   this.makeFilterLabel("Order: ") + HU.select("",[ID,this.getDomId("sortbyselect")],enums,this.getProperty("sortFields","")))+SPACE;
	    }

	    if(this.getProperty("showSortDirection")) {
		header2 +=HU.select("",[ID,this.getDomId("sortdirection")],[["up", "Sort Up"],["down","Sort Down"]],
				    sortAscending?"up":"down") + SPACE;
	    }


	    if(this.sizeByFields.length>0) {
		let enums = [];
		this.sizeByFields.forEach(field=>{
		    enums.push([field.getId(),field.getLabel()]);
		});
		header2 += HU.span([CLASS,filterClass],
				   this.makeFilterLabel("Size by: ") + HU.select("",[ID,this.getDomId("sizebyselect")],enums,this.getProperty("sizeBy","")))+SPACE;
	    }


	    let  highlight = this.getFilterHighlight();
	    if(this.getProperty("showFilterHighlight")) {

		let enums =[["filter","Filter"],["highlight","Highlight"]];
		let select =  HU.select("",["fieldId","_highlight", ID,this.getDomId(ID_FILTER_HIGHLIGHT)],enums,!highlight?"filter":"highlight") + SPACE2;
		if(hideFilterWidget) {
		    select = HU.div([STYLE,HU.css("display","none")], select);
		}
		header2+=select;
	    }


	    let dataFilterIds = [];
	    this.getDataFilters().forEach(f=>{
		if(!f.label) return;
		let cbxid = this.getDomId("datafilterenabled_" + f.id);
		dataFilterIds.push(cbxid);
		header2 +=  HU.checkbox("",[ID,cbxid],f.enabled) +" " +
		    this.makeFilterLabel(f.label +"&nbsp;&nbsp;")
	    });

	    if(this.getProperty("filterDate")) { 
		let type = this.getProperty("filterDate");
		//get dates
		let enums = [];
		if(this.getProperty("filterDateIncludeAll")) {
		    enums.push(["all","All"]);
		}
		let selected = null;
		let seen  = {};
		let dates  = [];
		records.forEach(record=>dates.push(record.getDate()));
		dates.sort(function(a,b) {
		    return a.getTime()-b.getTime();
		});
		dates.forEach(dttm=>{
		    let value = null;
		    if(type == "year") {
			value = dttm.getFullYear();
		    } else if(type== "day") {
			value = Utils.formatDateMonthDayYear(dttm);
		    }
		    if(!seen[value]) {
			selected = String(dttm);
			enums.push([String(dttm), value]);
			seen[value] = true;
		    }
		});

		let label = type=="year"?"Year":type=="month"?"Month":type=="day"?"Day":type;
		let style="";
		if(!this.getProperty("filterDateShow",true))
		    style +="display:none;";
		let selectId = this.getFilterId(ID_FILTER_DATE);
		
		label =  this.makeFilterLabel("Select " + label+": ");
		let prefix="";
		prefix += HU.div([ID,this.getDomId("filterDateStepBackward"),STYLE,HU.css("display","inline-block"),TITLE,"Step Back"],
 				 HU.getIconImage("fa-step-backward",[STYLE,HU.css("cursor","pointer")])) +SPACE1;
		prefix+=HU.div([ID,this.getDomId("filterDatePlay"),STYLE,HU.css("display","inline-block"),TITLE,"Play/Stop Animation"],
			       HU.getIconImage("fa-play",[STYLE,HU.css("cursor","pointer")])) + SPACE1;
		prefix += HU.div([ID,this.getDomId("filterDateStepForward"),STYLE,HU.css("display","inline-block"),TITLE,"Step Forward"],
 				 HU.getIconImage("fa-step-forward",[STYLE,HU.css("cursor","pointer")])) +SPACE1;

		let widget =  HU.span([CLASS,filterClass,STYLE,style],
				      prefix +
				      HU.select("",["fieldId","filterDate", ATTR_ID,selectId],enums,selected))+SPACE;
		if(hideFilterWidget) {
		    widget = HU.div([STYLE,HU.css("display","none")], widget);
		}
		header2+=widget;

	    }
	    


            let filterBy = this.getProperty("filterFields","").split(",").map(tok=>{return tok.trim();}); 
	    let fieldMap = {};
	    //Have this here so it can be used in the menu change events later. May cause problems if more than  one
	    let displayType = "";
	    this.filters = [];
	    this.filterMap = {};
	    this.addFilters(this.filters);
            if(filterBy.length>0) {
		let group = null;
                for(let i=0;i<filterBy.length;i++) {
		    if(filterBy[i]=="") continue;
		    if(filterBy[i].startsWith("group:")) {
			group = filterBy[i].substring(6);
			if(group=="none") group = null;
			continue;
		    }
		    let filter = new RecordFilter(this, filterBy[i]);
		    filter.group = group;
		    this.filters.push(filter);
		    this.filterMap[filter.getId()] = filter;
		}
		let searchBar = "";
		let bottom = [""];
		group = null;
		groupHtml = null;
		this.filters.forEach(filter=>{
		    let widget = filter.getWidget(fieldMap, bottom,records, vertical);
		    if(!vertical)
			widget = HU.span([ID,this.domId("filtercontainer_" + filter.id)], widget);
		    if(filter.group!=null) {
			if(filter.group!=group && groupHtml!=null) {
			    searchBar+=HU.toggleBlock(group,groupHtml,false);
			    groupHtml = null;
			}
			group = filter.group;
			if(groupHtml==null) {
			    groupHtml= "";
			}
			groupHtml+=widget;
			return;
		    }
		    if(groupHtml!=null) {
			searchBar+=HU.toggleBlock(group,groupHtml,false);
			groupHtml=null;
		    }
		    searchBar +=widget;
		});
		if(groupHtml!=null) searchBar+=HU.toggleBlock(group,groupHtml,false);
		style = (hideFilterWidget?"display:none;":"") + this.getProperty("filterByStyle","");
		if(this.getProperty("showFilterTotal",false)) {
		    searchBar+= HU.span([CLASS,"display-filter-label",ID,this.getDomId(ID_FILTER_COUNT)],"");
		}
		let filterBar = searchBar+bottom[0] + HU.div([ID,this.domId(ID_TAGBAR)],"");
		header2+=HU.div([CLASS,"display-header-span " +  filterClass,STYLE,style,ID,this.getDomId(ID_FILTERBAR)],filterBar);
	    }

	    if(vertical) {
		header2 = HU.div([CLASS,"display-header-vertical"],header2);
	    } else {
		header2=HU.div([STYLE,"line-height:0;"],
			       header2);
	    }


	    let headerSide = this.getDisplayHeaderSide();
	    if(headerSide == "left") 
		this.jq(ID_LEFT).html(header2);
	    else if(headerSide == "right") 
		this.jq(ID_RIGHT).html(header2);	    	    
	    else
		this.jq(ID_HEADER2).html(header2);

	    this.initHeader2();
	    this.jq("test").button().click(()=>{
		this.haveCalledUpdateUI = false;
		this.callUpdateUI();
	    });
	    this.createRequestProperties();
 	    let inputFunc = (input, input2, value) =>{
		let debug = false;
		if(this.ignoreFilterChange) return;
                let id = input.attr(ID);
		if(!id) {
		    console.log("No ID attribute");
		    return;
		}
		if(debug)
		    console.log(this.type+" filter change");


		let changedFilter;
		let changedFilterId;
		this.filters.every(filter=>{
		    if(filter.widgetId == id) {
			changedFilter = filter;
			changedFilterId = filter.id;
			return false;
		    }
		    return true;
		});

		if(debug)
		    console.log("changed filter:" + changedFilter)
		let dependentFilters =[];
		if(changedFilter) {
		    this.filters.forEach(filter=>{
			if(filter.depends == changedFilter.id) {
			    dependentFilters.push(filter);
			    let widget = $("#" + filter.widgetId);
			    this.ignoreFilterChange = true; 
			    filter.lastValue = widget.val();
			    widget.val(FILTER_ALL);
			    this.ignoreFilterChange = false; 
			}
		    });
		}


		if(!input2) {
		    if(id.endsWith("_min")) {
			input2 = $("#" + id.replace(/_min$/,"_max"));
		    } else if(id.endsWith("_max")) {
			let tmp = input;
			input =$("#" + id.replace(/_max$/,"_min"));
			input2 = tmp;
		    }
		}
		if(input.attr("isCheckbox")) {
		    let on = input.attr("onValue")||true;
		    let off = input.attr("offValue")||false;
		    if (input.is(':checked')) {
			value = on;
			console.log(_this.type +" cbx is checked value:" + value +" on:" + on +" off:" + off);
		    } else {
			value=off;
			console.log(_this.type +" cbx is not checked value:" + value +" on:" + on +" off:" + off);
		    }
		}
		if(!value) {
		    value = input.val();
		} 
		if(value===null || value==="") {
		    value = input.attr("data-value")  || input.val();
		}
		
		if(value==null) {
		    if(debug)
			console.log("no value:" + value);
		    return;
		}
		if(!Array.isArray(value) && input.attr("isButton")) {
		    //			console.log(_this.type +" " +Array.isArray(value));
		    var tmp = [];
		    value.split(",").forEach(v=>{
			tmp.push(v.replace(/_comma_/g,","));
		    });
		    value = tmp;
		}

                let fieldId = input.attr("fieldId");
		_this.checkFilterField(input);
		_this.haveCalledUpdateUI = false;
		if(_this.settingFilterValue) {
		    return;
		}
		_this.settingFilterValue = true;
		this.filteredRecords = null;
		if(debug)
		    console.log("calling dataFilterChanged");
		_this.dataFilterChanged();

		let records =[];
		let predecessorChanged = false;
		dependentFilters.forEach(filter=>{
		    if(this.filteredRecords == null )
			this.filteredRecords =  this.filterRecords();
		    let widget = filter.getWidget({}, [],this.filteredRecords);
		    this.jq("filtercontainer_" + filter.id).html(widget);
		    if(filter.initWidget)
			filter.initWidget(inputFunc);
		    if(filter.widgetId) {
			let widget = $("#" + filter.widgetId);
			if(!widget.length) {
			    console.log("Could not find dependent widget:" + filter.id);
			    return;
			}
			if(filter.lastValue) {
			    if(widget[0].options) {
				let values= $.map(widget[0].options,(option)=>{return option.value});
				if(!values.includes(filter.lastValue)) filter.lastValue = FILTER_ALL;
			    }
			    widget.val(filter.lastValue);
			}
			widget.change(function() {
			    inputFunc($(this));
			});
		    }
		    return true;
		});

		this.addToDocumentUrl(fieldId+".filterValue",value);
		let args = {
		    id:id,
		    fieldId: fieldId,
		    value: value
		};
		if(input2) {
		    args.value2 = input2.val();
		}
		_this.propagateEvent(DisplayEvent.filterChanged, args);
		_this.settingFilterValue = false;
            };

	    dataFilterIds.forEach(id=>{
		$("#" + id).click(function(e){
		    inputFunc($(this));
		});
	    });

	    
	    this.filters.forEach(f=>{
		if(f.initWidget)
		    f.initWidget(inputFunc);
	    });

	    this.jq(ID_FILTERBAR).find(".display-filter-items").each(function(){
		let parent = $(this);
		$(this).find(".display-filter-item").click(function(event){
		    var isAll = $(this).hasClass("display-filter-item-all");
		    var selectClazz = "display-filter-item-" + displayType +"-selected"
		    var wasSelected = $(this).hasClass(selectClazz);
		    var fieldId = $(this).attr("fieldId");
		    var multiples = _this.getProperty(fieldId +".filterMultiple",false);
		    if(!event.metaKey || isAll || !multiples) {
			parent.find(".display-filter-item").removeClass(selectClazz);
		    } else {
			parent.find(".display-filter-item-all").removeClass(selectClazz);
		    }
		    if(wasSelected  && event.metaKey) {
			$(this).removeClass(selectClazz);
		    } else {
			$(this).addClass(selectClazz);
		    }
		    var values = [];
		    parent.find("." + selectClazz).each(function() {
			values.push($(this).attr("data-value").replace(/,/g,"_comma_"));
		    });
		    if(values.length==0) {
			parent.find(".display-filter-item-all").addClass(selectClazz);
			values.push(FILTER_ALL);
		    }
		    var value =  Utils.join(values,",");
		    parent.attr("data-value", value);
		    $("#"+parent.attr(ID) +"_label").html(values.includes(FILTER_ALL)?SPACE:value);
		    inputFunc(parent,null, values);
		});

	    });
	    this.jq(ID_FILTERBAR).find(".display-filter-input").keyup(function(e) {
		let keyCode = e.keyCode || e.which;
		if (keyCode == 13) {return;}
		HtmlUtils.hidePopupObject();
		let input = $(this);
		let val = $(this).val().trim();
		if(val=="") return;
                let fieldId = $(this).attr("fieldId");
		let field = fieldMap[fieldId].field;
		let values = fieldMap[fieldId].values;
		let items=[];
		let regexp=null;
		try {
		    val = val.replace(/\./g,"\\.");
		    regexp = new RegExp("(" + val+")",'i');
		} catch(ignore) {
		    //todo
		}
		for(let i=0;i<values.length;i++) {
		    let text= values[i].toString();
		    let match  = regexp?text.match(regexp):text.indexOf(val)>=0;
		    if(match) {
			items.push([match[1], values[i]]);
		    }
		    if(items.length>30) break;
		}
		if(items.length>0) {
		    let html = "";
		    let itemCnt = 0;
		    items.forEach(item=>{
			let match = item[0];
			item =  item[1];
//			if(item.length>50) return;
			let label = item.replace(regexp,"<span style='background:" + TEXT_HIGHLIGHT_COLOR +";'>" + match +"</span>");
			item = item.replace(/\'/g,"\'");
			html+=HU.div([TITLE,item,CLASS,"ramadda-hoverable ramadda-clickable display-filter-popup-item","item",item],label)+"\n";
			itemCnt++;
		    });	
		    if(itemCnt>0) {
			let popup =HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
			popup.html(HU.div([STYLE,HU.css("margin","5px"), CLASS, "ramadda-popup-inner ramadda-snippet-popup"], html));
			popup.show();
			popup.position({
			    of: $(this),
			    my: "left top",
			    at: "left bottom",
			});
			$(".display-filter-popup-item").click(function(){
			    HtmlUtils.hidePopupObject();
			    input.val($(this).attr("item"));
			    inputFunc(input);
			});
		    }
		}

	    });



	    this.initializeRangeSlider(this.jq(ID_FILTERBAR).find(".display-filter-range"), inputFunc, this.getProperty("filterSliderImmediate"));

	    this.jq(ID_FILTER_HIGHLIGHT).change(function() {
		_this.setProperty("filterHighlight", $(this).val()=="highlight");
		_this.haveCalledUpdateUI = false;
		inputFunc($(this));
	    });


	    $("#" + this.getFilterId(ID_FILTER_DATE)).change(function() {
		inputFunc($(this));
	    });
	    this.jq("filterDatePlay").click(function() {
		_this.filterDatePlayingAnimation = !_this.filterDatePlayingAnimation;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		$(this).html(HU.getIconImage(icon,[STYLE,HU.css("cursor","pointer")]));
		if(_this.filterDatePlayingAnimation) {
		    _this.stepFilterDateAnimation(inputFunc,1);
		}
	    });
	    this.jq("filterDateStepBackward").click(function() {
		_this.filterDatePlayingAnimation = false;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		_this.jq("filterDatePlay").html(HU.getIconImage(icon,[STYLE,HU.css("cursor","pointer")]));
		_this.stepFilterDateAnimation(inputFunc,-1);
	    });
	    this.jq("filterDateStepForward").click(function() {
		_this.filterDatePlayingAnimation = false;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		_this.jq("filterDatePlay").html(HU.getIconImage(icon,[STYLE,HU.css("cursor","pointer")]));
		_this.stepFilterDateAnimation(inputFunc,1);
	    });

            this.jq("displayfields").change(function(){
		let val = $(this).val();
		if(Array.isArray(val)) {
		    val = val.join(",");
		}
		_this.displayFieldsChanged(val);
		_this.propagateEvent(DisplayEvent.propertyChanged, {
		    property:'displayFields',
		    value: val
		});
	    });


	    selectFieldProps.forEach(prop=>{
                this.jq("fieldselect_" + prop).change(function(){
		    _this.fieldSelectedChanged(prop,$(this).val());
		});
	    });


            this.jq("colorbyselect").change(function(){
		_this.colorByFieldChanged($(this).val());
	    });
            this.jq("sortbyselect").change(function(){
		let val = $(this).val();
		if(val.endsWith("_up")) {
		    _this.setProperty("sortAscending",true);
		    val = val.replace(/_up$/,"");
		} else {
		    val = val.replace(/_down$/,"");
		    _this.setProperty("sortAscending",false);
		}
		_this.sortByFieldChanged(val);
	    });
	    this.jq("sortdirection").change(function(){
		let val = $(this).val();
		_this.setProperty("sortAscending",val=="up");
		_this.forceUpdateUI();
	    });
            this.jq("sizebyselect").change(function(){
		_this.sizeByFieldChanged($(this).val());
	    });

            this.jq(ID_FILTERBAR).find("input").keyup(function(e){
		let keyCode = e.keyCode || e.which;
		if (keyCode == 13) {
		    inputFunc($(this));
		}
	    });
	    this.jq(ID_FILTERBAR).find("input:radio,select").change(function() {
		inputFunc($(this));
	    });
	    this.jq(ID_FILTERBAR).find("input:checkbox").change(function() {
		inputFunc($(this));
	    });
	    

	    let dates = [];
	    if(debug) console.log("checkSearchBar-getting filtered data");
	    let filteredRecords  = this.filterData();
	    if(debug) console.log("checkSearchBar-done getting filtered data");
	    let dateInfo = this.getDateInfo(filteredRecords);
	    if(debug) console.log("checkSearchBar-11");
            if (dateInfo.dateMax) {
		if(debug) console.log("checkSearchBar-getAnimation");
		let animation = this.getAnimation();
		if(animation.getEnabled()) {
		    if(debug) console.log("checkSearchBar-calling animation.init");
//		    console.log("dateMin:" + dateMin.toUTCString());
		    animation.init(dateInfo.dateMin, dateInfo.dateMax,filteredRecords);
		    if(debug) console.log("checkSearchBar-done calling animation.init");
		    if(!this.minDateObj) {
			if(debug) console.log("checkSearchBar-calling setDateRange");
			if(this.getProperty("animationFilter", true)) {
			    this.setDateRange(animation.begin, animation.end);
			}
			if(debug) console.log("checkSearchBar-done calling setDateRange");
		    }
		}
            }
	    if(debug) console.log("checkSearchBar-done");
        },
	getDateInfo:function(records) {
	    let dateMin = null;
	    let dateMax = null;
	    let dates =[];
	    records.every(record=>{
		if (dateMin == null) {
		    dateMin = record.getDate();
		    dateMax = record.getDate();
		} else {
		    let date = record.getDate();
		    if (date) {
			dates.push(date);
			if (date.getTime() < dateMin.getTime())
			    dateMin = date;
			if (date.getTime() > dateMax.getTime())
			    dateMax = date;
		    }
		}
		return true;
	    });
	    return { dateMin:dateMin, dateMax:dateMax, dates:dates};
	},
	    
	getHighlightColor: function() {
	    return this.getProperty("highlightColor", HIGHLIGHT_COLOR);
	},
	checkFilterField: function(f) {
	    let min = f.attr("data-min");
	    let max = f.attr("data-max");
	    let value = f.val();
	    if(Utils.isDefined(min)) {
		if(value != min) {
		    f.css("background",TEXT_HIGHLIGHT_COLOR);
		} else {
		    f.css("background","white");
		}
	    } else if(Utils.isDefined(max)) {
		if(value != max) {
		    f.css("background",TEXT_HIGHLIGHT_COLOR);
		} else {
		    f.css("background","white");
		}
	    }

	},
	fieldSelectedChanged: function(prop,val) {
	    this.setProperty(prop,val);
	    this.haveCalledUpdateUI = false;
	    this.callUpdateUI();
	},
	colorByFieldChanged:function(field) {
	    this.setProperty("colorBy", field);
	    this.callUpdateUI();
	},
	sortByFieldChanged:function(field) {
	    this.setProperty("sortFields", field);
	    this.callUpdateUI();
	},
	sizeByFieldChanged:function(field) {
	},
	someFieldChanged:function(type,field) {
	},	
	macroChanged: function() {
	    this.pageSkip = 0;
	},
	dataFilterChanged: function(args) {
	    args = args||{};
	    args.dataFilterChanged = true;
	    this.callUpdateUI(args);
	},
	addFieldClickHandler: function(jq, records, addHighlight) {
	    let _this = this;
	    if(records) {
		if(!jq) jq = this.jq(ID_DISPLAY_CONTENTS);
		let map = this.makeIdToRecords(records);
		let func = function() {
		    if(addHighlight) {
			$(this).parent().find(".display-row-highlight").removeClass("display-row-highlight");
			$(this).addClass("display-row-highlight");
		    }
		    let record = records[$(this).attr(RECORD_INDEX)];
		    if(!record) record = map[$(this).attr(RECORD_ID)];
		    if(record)
			_this.propagateEventRecordSelection({record:record});
		};
		let children = jq.find("[" +RECORD_INDEX+"]");
		if(!children.length) children = jq.find("[" +RECORD_ID+"]");
		if(!children.length) children = jq;
		children.click(func);
	    }

	    if(this.getProperty("propagateValueClick",true)) {
		let _this = this;
		if(!jq) jq = this.jq(ID_DISPLAY_CONTENTS);
		jq.find("[field-id]").click(function() {
		    let args = {
			id:$(this).attr("field-id"),
			fieldId: fieldId,
			value: $(this).attr("field-value")
		    };
		    _this.propagateEvent(DisplayEvent.filterChanged, args);
		});
	    }

	},
	makeIdToRecords: function(records) {
	    let idToRecord = {};
	    records.forEach(r=>idToRecord[r.getId()] = r);	    
	    return idToRecord;
	},
	makeTooltipClick: function(selector, records) {
	    let tooltipClick = this.getProperty("tooltipClick");
	    if(!tooltipClick) return;
	    selector.css("cursor","pointer");
	    let idToRecord = this.makeIdToRecords(records);
	    let _this = this;
	    selector.click(function() {
		let record = idToRecord[$(this).attr(RECORD_ID)];
		if(!record) return;
		if(_this.tooltipDialog) {
		    _this.tooltipDialog.remove();
		    _this.tooltipDialog = null;
		} 
		let tt =  _this.getRecordHtml(record,null,tooltipClick);
		tt = HU.div([STYLE,HU.css("width","600px")], tt);
		_this.tooltipDialog =  HU.makeDialog({content:tt,anchor:$(this),
						      draggable:true,header:true});
		if(_this.getProperty("dialogListener"))
		    _this.getProperty("dialogListener")(this, _this.tooltipDialog);
		_this.initTemplatePopup(_this.tooltipDialog);
	    });
	},

	initTemplatePopup: function(dialog) {
	    let _this = this;
	    dialog.find(".display-search-tag").click(function() {
		let type = $(this).attr("metadata-type");
		if(type==null) return;
		let filter = _this.filterMap[type];
		if(filter==null) return;
		let value = $(this).attr("metadata-value");
		filter.toggleTag(value,true,null, true);
	    });

	},

	//Make sure to set the title attribute on the elements
	makeTooltips: function(selector, records, callback, tooltipArg,propagateHighlight) {		
	    let tooltipClick = this.getProperty("tooltipClick");
	    if(tooltipClick) {
		this.makeTooltipClick(selector,records);
	    }
	    if(!Utils.isDefined(propagateHighlight) || propagateHighlight==null)
		propagateHighlight = this.shareEvent(DisplayEvent.recordHighlight, this.getProperty("propagateEventRecordHighlight",false));
	    if(!this.getProperty("showTooltips",true)) {
		return;
	    }
	    let tooltip = tooltipArg || this.getProperty("tooltip");
	    if(tooltip==null) {
		return;
	    }
	    let _this = this;
	    let idToRecord = this.makeIdToRecords(records);
	    let tooltipFunc = {
		content: function() {
		    let record = idToRecord[$(this).attr(RECORD_ID)];
		    if(!record)  record = records[parseFloat($(this).attr(RECORD_INDEX))];
		    if(!record) return null;
		    let propagateOk = true;
		    if(callback && callback(true, record) === false) {
			propagateOk = false;
		    }
		    if(propagateOk && propagateHighlight) {
			_this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, _this, {highlight:true,record: record});
		    }
		    if(tooltip=="" || tooltip=="none") return null;
		    let style = _this.getProperty("tooltipStyle");
		    let tt =  _this.getRecordHtml(record,null,tooltip);
		    if(style) tt=HU.div([STYLE,style],tt);
		    return tt;
		},
		close: function(event,ui) {
		    let record = idToRecord[$(this).attr(RECORD_ID)];
		    if(!record)
			record = records[parseFloat($(this).attr(RECORD_INDEX))];
		    let propagateOk = true;
		    if(callback && callback(false, record) === false) {
			propagateOk = false;
		    }
		    if(propagateOk && propagateHighlight)
			_this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, _this, {highlight:false,record: record});
		},
		position: {
		    my: _this.getProperty("tooltipPositionMy", "left top"),
		    at: _this.getProperty("tooltipPositionAt", "left bottom+2"),
		    collision: _this.getProperty("tooltipCollision", "flip")
		},
		show: {
		    delay: parseFloat(_this.getProperty("tooltipDelay",1000)),
		    duration: parseFloat(_this.getProperty("tooltipDuration",500)),
	    
		},
		classes: {
		    "ui-tooltip": _this.getProperty("tooltipClass", "ramadda-shadow-box  display-tooltip")
		}
	    };
	    if(selector.length>500) {
		//A hack to fix really slow tooltip calls when there are lots of elements
		selector.mouseenter(function() {
		    let tooltip = $(this).tooltip(tooltipFunc);
		    tooltip.tooltip('open');
		});
		selector.mouseleave(function() {
		    let tooltip = $(this).tooltip({});
		    tooltip.tooltip('close');
		});
	    } else {
		selector.tooltip(tooltipFunc);
	    }
	},
	makeRecordSelect: function(selector,idToRecords, callback) {
	    let _this = this;
	    selector.click(function(event){
		let record = idToRecords[$(this).attr(RECORD_ID)];
		if(!record) return;
		if(callback) callback(record);
		_this.propagateEventRecordSelection({select:true,record: record});
	    });
	},
	makePopups: function(selector, records, callback, popupTemplate) {
	    if(!popupTemplate)
		popupTemplate = this.getProperty("popupTemplate");
	    if(!popupTemplate) return;
	    let _this = this;
	    selector.click(function(event){
		let record = records[parseFloat($(this).attr(RECORD_INDEX))];
		if(!record) return;
		if(callback) callback(record);
		_this.propagateEventRecordSelection({select:true,record: record});
		_this.showRecordPopup($(this),record, callback,popupTemplate);
	    });
	},
	showRecordPopup: function(element, record, popupTemplate) {
	    if(!record) return;
	    if(!popupTemplate)
		popupTemplate = this.getProperty("popupTemplate");
	    if(!popupTemplate) return;
	    let _this = this;
	    HtmlUtils.hidePopupObject();
	    let html =  _this.getRecordHtml(record,null,popupTemplate);
	    html = HU.div([CLASS, "display-popup " + _this.getProperty("popupClass",""),STYLE, _this.getProperty("popupStyle","")],html);
	    let popup = HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
	    popup.html(html);
	    popup.show();
	    popup.position({
		of: element,
		my: _this.getProperty("popupPositionMy", "left top"),
		at: _this.getProperty("popupPositionAt", "left bottom+2"),
		collision: _this.getProperty("popupCollision", "none none")
	    });
	},
	animationStart: function(animation) {
	},
	animationApply: function(animation, skipUpdateUI) {
	    if(this.getProperty("animationFilter", true))
		this.setDateRange(animation.begin, animation.end);
	    if(!skipUpdateUI) {
		this.haveCalledUpdateUI = false;
		//		var t1 = new Date();
		this.dataFilterChanged({source:"animation"});
		//		var t2 = new Date();
		//		Utils.displayTimes("timeChanged",[t1,t2]);
	    }
	    this.propagateEvent(DisplayEvent.propertyChanged, {
		property: "dateRange",
		minDate: animation.begin,
		maxDate: animation.end
	    });
	},
        makeDialog: function(text) {
            var html = "";
	    if(!text) {
		var tabTitles = [];
		var tabContents = [];
		this.getDialogContents(tabTitles, tabContents);
		tabTitles.push("Edit");
		tabContents.push(this.makeToolbar({
                    addLabel: true
		}));
		var tabLinks = "<ul>";
		var tabs = "";
		for (var i = 0; i < tabTitles.length; i++) {
                    var id = this.getDomId("tabs") + i;
                    tabLinks += HU.tag("li", [], HU.tag("a", ["href", "#" + id],
							tabTitles[i]));
                    tabLinks += "\n";
                    var contents = HU.div([ATTR_CLASS, "display-dialog-tab"], tabContents[i]);
                    tabs += HU.div([ID, id], contents);
                    tabs += "\n";
		}
		tabLinks += "</ul>\n";
		text =  HU.div([ID, this.getDomId(ID_DIALOG_TABS)], tabLinks + tabs);
	    }
	    return text;
        },
        initDialog: function() {
            var _this = this;
            var updateFunc = function(e) {
                if (e && e.which != 13 && e.which!=0) {
                    return;
                }
		var changed = false;
		["column","row","width","height"].forEach(f=>{
                    if(_this[f] != _this.jq(f).val() && (_this[f] || _this.jq(f).val().trim()!="")) {
			changed = true;
			_this[f] = _this.jq(f).val();
		    }});
		

                if(changed) {
		    _this.getLayoutManager().doLayout();
		}
            };
	    ["column","row","width","height"].forEach(f=>{
		this.jq(f).blur(updateFunc);
		this.jq(f).keypress(updateFunc);
	    });

            this.jq("showtitle").change(function() {
                _this.setShowTitle(_this.jq("showtitle").is(':checked'));
            });
            this.jq("showdetails").change(function() {
                _this.setShowDetails(_this.jq("showdetails").is(':checked'));
            });
            this.jq(ID_DIALOG_TABS).tabs();

        },
        showDialog: function(text, from, initDialog, title) {
	    if(this.dialog) this.dialog.remove();
	    if(!this.dialogElement) {
//		$(document.body).append(HU.div([ATTR_CLASS, "display-dialog",ID,this.getDomId(ID_DIALOG)]));
//		this.dialogElement = this.jq(ID_DIALOG);
	    }
	    let html = this.makeDialog(text);
	    this.dialog = HU.makeDialog({content:html,title:title||this.getTitle(),anchor:from||this.jq(ID_MENU_BUTTON),draggable:true,header:true});
	    if(initDialog) initDialog();
            else this.initDialog();
	    return this.dialog;
        },
        copyDisplay: function() {
            let newOne = {};
            $.extend(true, newOne, this);
            newOne.setId(newOne.getId() + this.getUniqueId("display"));
            addRamaddaDisplay(newOne);
            this.getDisplayManager().addDisplay(newOne);
        },
        removeDisplay: function() {
            this.getDisplayManager().removeDisplay(this);
	    if(this.dialogElement)  this.dialogElement.remove();
        },
        doingQuickEntrySearch: false,
        doQuickEntrySearch: function(request, callback) {
            if (this.doingQuickEntrySearch) return;
            var text = request.term;
            if (text == null || text.length <= 1) return;
            this.doingQuickEntrySearch = true;
            var searchSettings = new EntrySearchSettings({
                name: text,
                max: 10,
            });
            if (this.searchSettings) {
                searchSettings.clearAndAddType(this.searchSettings.entryType);
            }
	    let _this = this;
            var jsonUrl = this.getRamadda().getSearchUrl(searchSettings, OUTPUT_JSON);
            var handler = {
                entryListChanged: function(entryList) {
                    _this.doneQuickEntrySearch(entryList, callback);
                }
            };
            var entryList = new EntryList(this.getRamadda(), jsonUrl, handler, true);
        },
        doneQuickEntrySearch: function(entryList, callback) {
            var names = [];
            var entries = entryList.getEntries();
            for (var i = 0; i < entries.length; i++) {
                names.push(entries[i].getName());
            }
            callback(names);
            this.doingQuickEntrySearch = false;

        },
        addData: async function(pointData) {
            var records = pointData.getRecords();
            if (records && records.length > 0) {
                this.hasElevation = records[0].hasElevation();
            } else {
                this.hasElevation = false;
            }
	    pointData = this.convertPointData(pointData);
            this.dataCollection.addData (pointData);
            var entry = pointData.entry;
            if (entry == null && pointData.entryId) {
                await this.getRamadda().getEntry(pointData.entryId, e => {
                    entry = e
                });
            }
            if (entry) {
                pointData.entry = entry;
                this.addEntry(entry);
            }
        },
        handleWarning: function(message) {
	    if(!window.location.hash  || window.location.hash!="#fortest") {
		console.warn(message);
	    }
	},
        handleLog: function(message) {
	    if(!window.location.hash  || window.location.hash!="#fortest") {
		console.log(message);
	    }
	},
        handleError: function(message, exc) {
	    this.setErrorMessage(message);
            console.error(this.type +" " + message);
	    if(exc && exc.stack) {
		let err = "";
		let limit=15;
		exc.stack.split("\n").every(line=>{
		    if(limit--<0) {
			err+="...\n";
			return false;
		    }
		    err+=line+"\n";
		    return true;
		});
		console.error(err);
	    }
        },
	setErrorMessage: function(msg) {
            this.setContents(this.getMessage(msg));
	},
	clearProgress: function() {
	    this.jq(ID_DISPLAY_PROGRESS).html("");
	},
	startProgress: function() {
	    if(this.jq(ID_DISPLAY_PROGRESS).length>0) 
		this.jq(ID_DISPLAY_PROGRESS).html(HU.image(icon_progress));
	    else {
		if(this.useDisplayMessage()) {
                    this.setDisplayMessage(this.getLoadingMessage());
		} else {
		    this.setContents(this.getLoadingMessage());
		}
	    }
	},
	handleNoData: function(pointData,reload) {
	    let debug = displayDebug.handleNoData;
	    this.jq(ID_PAGE_COUNT).html("");
            if (!reload) {
		if(debug) console.log("\tno reload");
                this.addData(pointData);
                this.checkSearchBar();
            } else {
		if(!this.dataCollection)
		    this.dataCollection = new DataCollection();
		this.dataCollection.setData(pointData);
	    }
            this.setContents(this.getMessage(this.getNoDataMessage()));
	},
        pointDataLoadFailed: function(data) {
	    this.clearProgress();
            this.inError = true;
            errorMessage = this.getProperty("errorMessage", null);
            if (errorMessage != null) {
                this.setContents(errorMessage);
                return;
            }
            var msg = "";
	    if(data && data.error) {
		msg = data.error;
	    } else   if (data && data.errorcode && data.errorcode == "warning") {
                msg = data.error;
            } else {
                msg = "<b>An error has occurred:</b>";
                if (!data) data = this.getNoDataMessage();
                var error = data.error ? data.error : data;
                error = error.replace(/<[^>]*>/g, "");
                var tmp = "";
                var lines = error.split("\n");
                var seen = {};
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line == "") continue;
                    if (seen[line]) continue;
                    seen[line] = true;
                    tmp += line + "\n";
                }
                error = tmp;
                error = HU.tag("pre", [STYLE, HU.css("max-height","300px","overflow-y","auto","max-width","100%","overflow-x","auto")], error);
                msg += error;
            }
	    
	    msg = msg.replace(/\n/g,"<br>");
	    this.setErrorMessage(msg);
        },
        //callback from the pointData.loadData call
        clearCache: function() {},
	handleEventDataSelection: function(source, args) {
	    if(this.getAcceptEventDataSelection()) {
		this.pointDataLoaded(args.data,"",true);
	    }
	},
	getRequirement:function() {
	    return null;
	},
	updatePaginateLabel:function(skip, count,max) {
	    let paginate = this.getProperty("filterPaginate");
	    let label = count;
	    if(skip!=null && skip>0)
		label = String(skip+1)+"-"+(count+skip);
	    else if(count<max)
		label = "1" +"-"+count;
	    label = this.getProperty("pageRequestLabel","Showing: ${count}").replace("${count}",label);
	    this.jq(ID_PAGE_LABEL).html(label);
	    let gotAll=false;
	    if(paginate) {
	    } else {
	    }
	    let buttons = "";
	    if(skip!=null && skip>0) {
		buttons+= HU.getIconImage("fa-step-backward",[ID,this.getDomId(ID_PAGE_PREV),CLASS,"display-page-button",TITLE,"View previous"])
	    }  else if(!gotAll) {
		buttons+= HU.getIconImage("fa-step-backward",[CLASS,"display-page-button fa-disabled"])
	    }
	    if(count<max) {
		buttons+= HU.getIconImage("fa-step-forward",[ID,this.getDomId(ID_PAGE_NEXT),CLASS,"display-page-button",TITLE,"View next"])
	    }  else if(!gotAll) {
		buttons+= HU.getIconImage("fa-step-forward",[CLASS,"display-page-button fa-disabled"])
	    }
	    this.jq(ID_PAGE_BUTTONS).html(buttons);
	    let _this = this;
	    this.jq(ID_PAGE_NEXT).click(()=>{
		if(!this.pageSkip)
		    this.pageSkip=0;
		if(paginate) {
		    this.pageSkip+= +this.getProperty("pageCount",1000);
		    _this.haveCalledUpdateUI = false;
		    _this.dataFilterChanged();
		    _this.updatePaginateLabel(this.pageSkip, count,max);			
		} else {
		    this.pageSkip+=max;
		    this.reloadData();
		}
	    });
	    this.jq(ID_PAGE_PREV).click(()=>{
		if(!this.pageSkip)
		    this.pageSkip=0;
		if(paginate) {
		    this.pageSkip-= +this.getProperty("pageCount",1000);
		    if(this.pageSkip<0) this.pageSkip=0;
		    _this.haveCalledUpdateUI = false;
		    _this.updatePaginateLabel(this.pageSkip, count,max);			
		    _this.dataFilterChanged();
		} else {
		    this.pageSkip-=max;
		    if(this.pageSkip<0) this.pageSkip=0;
		    this.reloadData();
		}
	    });		
	},

        pointDataLoaded: function(pointData, url, reload) {
//	    console.log(this.type +".pointDataLoaded");
	    let debug = displayDebug.pointDataLoaded;

	    this.clearProgress();
            this.inError = false;
            this.clearCache();
	    if(debug) console.log(this.type+" pointDataLoad:" + this.getId() + " " + this.type +" #records:" + pointData.getRecords().length);
	    if(debug)
		console.log("\tclearing last selected fields");
	    let records = pointData.getRecords();
	    
	    this.lastSelectedFields = null;
            if (!reload) {
		if(debug) console.log("\tcalling addData");
                this.addData(pointData);
		//		if(debug) console.log("\tcalling checkSearchBar");
                this.checkSearchBar();
		//		if(debug) console.log("\done calling checkSearchBar");
            } else {
		pointData = this.convertPointData(pointData);
		if(!this.dataCollection)
		    this.dataCollection = new DataCollection();
		if(debug) console.log("\tcalling setData");
		this.dataCollection.setData(pointData);
	    }

	    let paginate = this.getProperty("filterPaginate");
	    if(this.getProperty("pageRequest") || paginate) {
		if(debug) console.log("\tupdating pageRequest");
		let count = pointData.getRecords().length;
		let skip = null;
		let skipToks = url?url.match(/skip=([0-9]+)/):null;
		if(skipToks) skip = +skipToks[1];
		let max = +this.getProperty("max",5000);
		//		console.log("max:" +max +" count:" + count +" skip:" + skip);
		let label = count;
		if(skip!=null && skip>0)
		    label = String(skip+1)+"-"+(count+skip);
		else if(count==max)
		    label = "1" +"-"+count;
		let pageInfo = this.getProperty("pageRequestLabel","Showing: ${count}").replace("${count}",label) +" ";
		let gotAll = !skip &&  count<max;

		if(skip!=null && skip>0) {
		    pageInfo+= HU.getIconImage("fa-step-backward",[ID,this.getDomId(ID_PAGE_PREV),CLASS,"display-page-button",TITLE,"View previous"])
		}  else if(!gotAll) {
		    pageInfo+= HU.getIconImage("fa-step-backward",[CLASS,"display-page-button fa-disabled"])
		}
		if(count==max) {
		    pageInfo+= HU.getIconImage("fa-step-forward",[ID,this.getDomId(ID_PAGE_NEXT),CLASS,"display-page-button",TITLE,"View next"])
		}  else if(!gotAll) {
		    pageInfo+= HU.getIconImage("fa-step-forward",[CLASS,"display-page-button fa-disabled"])
		}
		this.jq(ID_PAGE_COUNT).html(pageInfo+"&nbsp;&nbsp;");
		this.jq(ID_PAGE_NEXT).click(()=>{
		    if(!this.pageSkip)
			this.pageSkip=0;
		    this.pageSkip+=max;
		    this.reloadData();
		});
		this.jq(ID_PAGE_PREV).click(()=>{
		    if(!this.pageSkip)
			this.pageSkip=0;
		    this.pageSkip-=max;
		    if(this.pageSkip<0) this.pageSkip=0;
		    this.reloadData();
		});		
	    }

            if (url != null) {
                this.jsonUrl = url;
            } else {
                this.jsonUrl = null;
            }
            if (!this.getDisplayReady()) {
		if(debug)console.log("pointDataLoaded: display not ready");
                return;
            }

	    if(!this.getProperty("dateFormat")) {
                pointData.getRecordFields().forEach(f=>{
		    if(f.isFieldDate() && f.getId() == "year") {
			this.setProperty("dateFormat","yyyy");
		    }
		});
	    }
	    
	    this.haveCalledUpdateUI = false;
	    if(debug) console.log("\tcalling updateUI");
	    try {
		let requirement = this.getRequirement();
		if(requirement) {
//		    console.log("waiting on:" + requirement);
		    HU.waitForIt(requirement,()=>{
			this.updateUI({reload:reload});
		    });
		} else {
		    this.updateUI({reload:reload});
		}
	    } catch(err) {
		this.handleError("Error creating display:<br>" + err,err);
		return;
	    }
            if (!reload) {
                this.lastPointData = pointData;
                this.propagateEvent(DisplayEvent.pointDataLoaded, pointData);
            }
        },
        getHasDate: function(records) {
            var lastDate = null;
            this.hasDate = false;
            for (j = 0; j < records.length; j++) {
                var record = records[j];
                var date = record.getDate();
                if (date == null) {
                    continue;
                }
                if (lastDate != null && lastDate.getTime() != date.getTime()) {
                    this.hasDate = true;
                    break
                }
                lastDate = date;
            }
            return this.hasDate;
        },
        dateInRange: function(date, debug) {
	    if(debug) {
		console.log("dateInRange: date:" + date +" minDate:" + this.minDateObj +" maxDate:" + this.maxDateObj);
	    }

            if (date != null) {
		if(this.dateRangeDoDay && this.minDateObj) {
		    if(date.getUTCFullYear()!=this.minDateObj.getUTCFullYear() ||
		       date.getUTCMonth()!=this.minDateObj.getUTCMonth() ||
 		       date.getUTCDate()!=this.minDateObj.getUTCDate())  {
			return false;
		    }
		    
		} else {
                    if (this.minDateObj != null && date.getTime() < this.minDateObj.getTime()) {
			if(debug) {
			    console.log("    minDate:\n\t" + date.getTime() +"\n\t" + this.minDateObj.getTime());
			}
			return false;
                    }
                    if (this.maxDateObj != null && date.getTime() > this.maxDateObj.getTime()) {
			if(debug) {
			    console.log("    maxDate:\n\t" + date.getTime() +"\n\t" + this.minDateObj.getTime());
			}
			return false;
		    }
                }
		
//		let str =  date.toUTCString() +" " +(date.getTime() < this.startDateObject.getTime());
		if (this.startDateObject != null && date.getTime() < this.startDateObject.getTime()) {
		    if(debug) {
//			console.log("    startDate:\n\t" + date.getTime() +"\n\t" + this.startDateObject.getTime());
		    }
//		    console.log("skip " + str);
                    return false;
                }
//		console.log("no skip " + str +" " + date);
                if (this.endDateObject != null && date.getTime() > this.endDateObject.getTime()) {
		    if(debug) {
			console.log("    endDate:\n\t" + date.getTime() +"\n\t" + this.endDateObject.getTime());
		    }
                    return false;
                }
            }
            return true;
        },
        getPointData: function() {
	    if(this.pointData) return this.pointData;
            if (this.dataCollection.getList().length == 0) return null;
            return this.dataCollection.getList()[0];
        },
	getRecords: function() {
            let pointData = this.getData();
            if (pointData == null) return null;
            return  pointData.getRecords();
        },
        //get an array of arrays of data 
        getDataValues: function(obj) {
            if (obj.tuple) return obj.tuple;
            else if (obj.getData) return obj.getData();
            return obj;
        },
	indexToRecord: {},
	recordToIndex: {},
	findMatchingDates: function(date, records, within) {
	    if(!Utils.isDefined(within)) within=0;
	    let good = [];
	    let millis = date.getTime();
	    records.forEach(r=>{
		let rd = r.getDate();
		if(!rd) return;
		let diff = Math.abs(rd.getTime()-millis);
		if(diff<=within) {
		    good.push(r);
		}
	    });
	    return good;
	},
	findMatchingIndex: function(record) {
	    if(!record) return {index:-1,record:null};
	    var index = this.recordToIndex[record.getId()];
	    if(Utils.isDefined(index)) {
		return {index:index, record:this.indexToRecord[index]}
	    }
	    if(!record.hasDate()) return -1;
	    let records =this.filteredRecords;
	    if(!records) {
		records = [];
		for(i in this.indexToRecord) {
		    records.push(this.indexToRecord[i]);
		}
	    }
	    var closest;
	    var min  =0;
	    records.forEach(r=>{
		if(!r.hasDate()) {
		    return -1;
		}
		var diff = Math.abs(record.getDate().getTime()-r.getDate().getTime());
		if(!closest) {
		    min = diff;
		    closest = r;
		} else {
		    if(diff<min) {
			min = diff;
			closest = r;
		    }
		}
	    });
	    if(!closest) 
		return {index:-1, record:null}
	    return {index:this.recordToIndex[closest.getId()], record:closest};
	},
        makeDataArray: function(dataList) {
            if (dataList.length == 0) return dataList;
            var data = [];
            if (dataList[0].getData) {
                for (var i = 0; i < dataList.length; i++) {
		    data.push(dataList[i].getData()[0]);
		}
            } else if (dataList[0].tuple) {
                for (var i = 0; i < dataList.length; i++) {
                    data.push(dataList[i].tuple);
		}
            } else {
                data = dataList;
            }
            return data;
        },

        printFields: function(label, fields) {
            console.log(label);
            if (!fields) {
                console.log("   null fields");
                return;
            }

            for (a in fields)
                console.log("   " + fields[a].getId());
        },
	makeIndexValue: function(indexField, value, offset) {
	    return value+offset;
	},
        getStandardData: function(fields, args) {
	    if(!args) args = {};
	    let debug = displayDebug.getStandardData;
	    if(debug) console.log("getStandardData:" + this.type +"  fields:" + fields);
	    let showUnit  = this.getProperty("showUnit",this.getProperty("showUnitInSeries",true));
	    this.recordToIndex = {};
	    this.indexToRecord = {};
            var pointData = this.getPointData();
            var excludeZero = this.getProperty(PROP_EXCLUDE_ZERO, false);
            var excludeNan = this.getProperty(PROP_EXCLUDE_NAN, false);	    
            if (fields == null) {
                fields = pointData.getRecordFields();
		if(debug) console.log("\tgetRecordFields: " + fields.length);
            } else {
		//		if(debug) console.log("\tfields 2: " + fields.length);
	    }
            props = {
                makeObject: true,
                includeIndex: true,
                includeIndexIfDate: false,
                groupByIndex: -1,
                raw: false,
            };
            if (args != null) {
                $.extend(props, args);
            }



            let groupByIndex = props.groupByIndex;
            let groupByList = [];
 	    let groupByValues = {};

	    let groupByRecords = [];
	    let groupByDate = this.getProperty("groupByDate");
	    let groupByFill = this.getProperty("groupByFill");
	    let groupByDateMap = {};
	    let groupByDates = [];

            var dataList = [];
            //The first entry in the dataList is the array of names
            //The first field is the domain, e.g., time or index
            var fieldNames = [];
            var fieldsForTuple = [];	    
	    if(this.getProperty("binDate")) {
		if(debug)
		    console.log("binning date");
		var binType = this.getProperty("binType","total");
		var binCount = binType=="count";
		if(binCount) {
		    var f = [];
		    fields.forEach((field)=>{
			f.push(new RecordField({
			    index:0,
			    id:field.getId(),
			    label:this.getProperty("binDateLabel", this.getProperty("binCountLabel","Count")),
			    type:"double",
			    chartable:true
			}));
		    });
		    fields=f;
		}
	    }

	    let seenDate = false;
	    fields  = fields.filter(f=>{
		if(f.isFieldDate()) {
		    if(seenDate  && f.isRecordDate()) return null;
		    seenDate = true;
		}
		return f;
	    });
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (field.isFieldNumeric() && field.isFieldDate()) {
                    //                        console.log("Skipping:" + field.getLabel());
                    //                        continue;
                }
                var name = field.getLabel();
                if (showUnit && field.getUnit() != null) {
                    name += " (" + field.getUnit() + ")";
                }
                //                    name = name.replace(/!!/g,"<br><hr>&nbsp;&nbsp;&nbsp;")
                name = name.replace(/!!/g, " -- ")
                fieldNames.push(name);
		fieldsForTuple.push(field);
            }
            if (props.makeObject) {
                dataList.push({
                    tuple: fieldNames,
		    fields:fieldsForTuple,
                    record: null
                });
            } else {
                dataList.push(fieldNames);
            }
            //console.log(fieldNames);



            groupByList.push("");
	    groupByRecords.push(null);
	    if(!this.minDateObj) {
		this.minDateObj = Utils.parseDate(this.minDate, false);
		if(debug)
		    console.log("getStandardData setting min date:" + this.minDateObj);
	    }
	    if(!this.minDateObj) {
		this.maxDateObj = Utils.parseDate(this.maxDate, true, this.minDateObj);
		if(debug)
		    console.log("getStandardData setting max date:" + this.maxDateObj);
	    }

            if (this.minDateObj == null && this.maxDateObj != null) {
                this.minDateObj = Utils.parseDate(this.minDate, false, this.maxDateObj);
            }



            let offset = 0;
            if (Utils.isDefined(this.offset)) {
                offset = parseFloat(this.offset);
            }

            let nonNullRecords = 0;
            let records = args.records?args.records:this.filterData();
	    if(debug)
		console.log("getStandardData #fields:" + fields.length +" #records:" + records.length);
            let allFields = pointData.getRecordFields();

            //Check if there are dates and if they are different
            this.hasDate = this.getHasDate(records);
            let date_formatter = null;
            let rowCnt = -1;
            let indexField = this.getFieldById(null,this.getProperty("indexField"));
	    var t1 = new Date();
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let record = records[rowIdx];
                let date = record.getDate();
                if (!this.dateInRange(date)) {
		    continue;
		}
                rowCnt++;
		this.recordToIndex[record.getId()] = rowCnt;
		this.indexToRecord[rowCnt] = record;
                let values = [];


                if (props && (props.includeIndex || props.includeIndexIfDate)) {
                    var indexName = null;
                    if (indexField) {
			let value = this.makeIndexValue(indexField,record.getValue(indexField.getIndex()),rowIdx);
                        values.push(value);
                        indexName = indexField.getLabel();
                    } else {
                        if (this.hasDate) {
			    let dttm = this.getDateValue(date, date_formatter);
                            values.push(dttm);
                            indexName = "Date";
                        } else {
                            if (!props.includeIndexIfDate) {
                                values.push(rowIdx);
				indexName = this.getProperty("indexName", "Index");
                            }
                        }
                    }
                    if (indexName != null && rowCnt == 0) {
                        fieldNames.unshift(indexName);
                    }
                }

                let allNull = true;
                let allZero = true;
                let hasNumber = false;
		let hasNan = false;
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    if (field.isFieldNumeric() && field.isFieldDate()) {
                        //                            continue;
                    }
                    var value = record.getValue(field.getIndex());
                    if (offset != 0) {
                        value += offset;
                    }

		    //		    if(debug&& rowIdx<10)
		    //			console.log("   v:"+ value);
                    if (value != null) {
                        allNull = false;
                    }
                    if (typeof value == 'number') {
			if(excludeNan &&  isNaN(value))  {
			    hasNan=true;
			}
                        hasNumber = true;
                        if (value != 0) {
                            allZero = false;
                        }
                    }
                    if (field.isFieldDate()) {
                        value = this.getDateValue(value, date_formatter);
                    }
                    values.push(value);
		}


		if(hasNan) {
		    continue;
		}
                if (hasNumber && allZero && excludeZero) {
		    //		    console.log(" skipping due to zero: " + values);
                    continue;
                }
                //TODO: when its all null values we get some errors
                if (groupByIndex >= 0) {
		    var value = record.getValue(groupByIndex);
		    if(!groupByValues[value]) groupByValues[value] = true;
		    if(groupByDate)
			groupByList.push(record.getDate() +"-"+value);
		    else
			groupByList.push(value);
		    groupByRecords.push(record);
                }
                if (props.makeObject)
                    dataList.push({
                        tuple: values,
                        record: record
                    });
                else
                    dataList.push(values);
                if (!allNull) {
                    nonNullRecords++;
                }
	    }

	    var t2= new Date();
//	    console.log("#records:" + records.length);
//	    Utils.displayTimes("chart.standardData loop:",[t1,t2], true);
            if (nonNullRecords == 0) {
		//		console.log("Num non null:" + nonNullRecords);
		console.log(this.type+" no nonNull records");
		return [];
            }

            if (groupByIndex >= 0) {
                var groupToTuple = {};
                var groups = [];
                var agg = [];
                var title = [];
		let groupByCount = this.getProperty("groupByCount");
                title.push(props.groupByField.getLabel());
		if(groupByCount) {
		    title.push(this.getProperty("groupByCountLabel", "Count"));
		} else {
                    for (var fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
			var field = fields[fieldIdx];
			if (field.getIndex() != groupByIndex) {
                            title.push(field.getLabel());
			}
                    }
		}
		//                agg.push(title);
		let groupByValueTuples = {};
                for (var rowIdx = 0; rowIdx < dataList.length; rowIdx++) {
                    var data = this.getDataValues(dataList[rowIdx]);
                    if (rowIdx == 0) {
                        continue;
                    }
                    var groupBy = groupByList[rowIdx];
		    var record = groupByRecords[rowIdx];
		    var groupByValue = record.getValue(groupByIndex);
                    var tuple = groupToTuple[groupBy];
                    if (tuple == null) {
                        tuple = new Array();
                        groups.push(groupBy);
			if(groupByDate) {
			    let dateList = groupByDateMap[record.getDate()];
			    if(dateList == null) {
				groupByDateMap[record.getDate()] = dateList = [];
				groupByDates.push(record.getDate());
			    }
			    dateList.push(tuple);
			}
			if(!groupByValueTuples[groupByValue]) groupByValueTuples[groupByValue] = [];
			groupByValueTuples[groupByValue].push(tuple)
			tuple.record = record;
                        agg.push(tuple);
                        tuple.push(groupByValue);
			if(groupByCount) {
			    tuple.push(0);
			} else {
                            for (var fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
				var field = fields[fieldIdx];
				if (field.getIndex() == groupByIndex) {
                                    continue;
				}
				tuple.push(0);
                            }
			}
                        groupToTuple[groupBy] = tuple;
                    }
                    var index = 0;
		    if(groupByCount) {
			tuple[1]++;
			continue;
		    }
                    for (var fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                        var field = fields[fieldIdx];
                        if (field.getIndex() == groupByIndex) {
                            continue;
                        }
                        var dataValue = data[fieldIdx];
                        index++;
                        if (Utils.isNumber(dataValue)) {
                            if (typeof tuple[index] == "string") {
                                tuple[index] = 0;
                            }
                            tuple[index] += parseFloat(dataValue);
                        } else {
                            if (tuple[index] == 0) {
                                tuple[index] = "";
                            }
                            var s = tuple[index];
                            if (!Utils.isDefined(s)) {
                                s = "";
                            }
                            //Only concat string values for a bit
                            if (s.length < 150) {
                                if (!Utils.isDefined(dataValue)) {
                                    dataValue = "";
                                }
                                var sv = ("" + dataValue);
                                if (s.indexOf(sv) < 0) {
                                    if (s != "") {
                                        s += ", ";
                                    }
                                    s += sv;
                                    tuple[index] = s;
                                }
                            }

                        }
                    }
		}

		if(groupByFill) {
		    groupByDates.forEach(date=>{
			let dateList = groupByDateMap[date];
			let seen = {};
			dateList.forEach(tuple =>{
			    seen[tuple[0]] = true;
			});
			for(v in groupByValues) {
			    if(!seen[v]) {
				seen[v] = true;
				let tuple = [v,0];
				tuple.date = date;
				agg.push(tuple);
			    }
			}
		    });
		}

		if(this.getProperty("groupBySort")) {
		    agg.sort(function(a,b) {return b[1]-a[1]});
		}
		if(this.getProperty("groupByMaxNumber")) {
		    let cnt = +this.getProperty("groupByMaxNumber");
		    agg = agg.filter((t,idx)=>{
			return idx<cnt;
			
		    });

		}
		let tmp = [];
		tmp.push(title);
		agg.forEach(t=>tmp.push(t));
                return tmp;
            }

	    //	    console.log("display.getStandardData returning "+ dataList.length);
	    if(this.getProperty("movingAverageSteps")) {
		let steps = +this.getProperty("movingAverageSteps");
		let tmp = [dataList[i]];
		let isNumeric = dataList[1].tuple.map((v,idx)=>{return Utils.isNumber(v);});
		dataList.forEach((o,rowIdx)=>{
		    if(rowIdx==0) return;
		    let tuple = Utils.mergeLists(o.tuple);
		    tmp.push({
			record:o.record,
			tuple:tuple});
		    tuple[0] = "x"; tuple[1] = 5;
		    tuple.forEach((v,colIdx)=>{
			if(!isNumeric[colIdx]) return;
			tuple[colIdx]=5;
		    });
		});
		dataList = tmp;
	    }
            return dataList;
        },
        isGoogleLoaded: function() {
            if ((typeof google === 'undefined') || (typeof google.visualization === 'undefined') || (typeof google.visualization.DateFormat === 'undefined')) {
                return false;
            }
            return true;
        },
        initDateFormats: function() {
            if (!this.isGoogleLoaded()) {
                //                    console.log("google hasn't loaded");
                return false;
            }
            if (this.fmt_yyyy) return true;
            var tz = 0;
            this.timezone = this.getProperty("timezone");
            if (Utils.isDefined(this.timezone)) {
                tz = parseFloat(this.timezone);
            }
            this.fmt_yyyymmddhhmm = new google.visualization.DateFormat({
                pattern: "yyyy-MM-dd HH:mm Z",
                timeZone: tz
            });
            this.fmt_yyyymmdd = new google.visualization.DateFormat({
                pattern: "yyyy-MM-dd",
                timeZone: tz
            });
            this.fmt_yyyy = new google.visualization.DateFormat({
                pattern: "yyyy",
                timeZone: tz
            });
            return true;
        },
        getDateValue: function(arg) {
            if (!this.initDateFormats()) {
                return arg;
            }
            if (!(typeof arg == "object")) {
                date = new Date(arg);
            } else {
                date = arg;
            }
	    if(isNaN(date.getUTCFullYear())) return {v:date,f:"NA"};
	    if(this.getProperty("dateFormatDaysAgo",false)) {
		let now = new Date();
		let diff = Math.round((now.getTime()-date.getTime())/1000/60/60/24);
		return {v:date,f:diff+" days ago"};
	    }

            return  {
                v: date,
                f: this.formatDate(date)
            };
        },
        applyFilters: function(record, values) {
            for (var i = 0; i < this.filters.length; i++) {
                if (!this.filters[i].isRecordOk(record)) {
                    return false;
                }
            }
            return true;
        }
    });

    let filter = this.getProperty(PROP_DISPLAY_FILTER);
    if (filter != null) {
        //semi-colon delimited list of filter definitions
        //display.filter="filtertype:params;filtertype:params;
        //display.filter="month:0-11;
        var filters = filter.split(";");
        for (var i = 0; i < filters.length; i++) {
            filter = filters[i];
            var toks = filter.split(":");
            var type = toks[0];
            if (type == "month") {
                this.filters.push(new MonthFilter(toks[1]));
            } else {
                this.handleError("Unknown filter:" + type);
            }
        }
    }
}




function DisplayGroup(argDisplayManager, argId, argProperties, type) {
    const LAYOUT_TABLE = "table";
    const LAYOUT_HTABLE = "htable";
    const LAYOUT_TABS = "tabs";
    const LAYOUT_COLUMNS = "columns";
    const LAYOUT_ROWS = "rows";
    const SUPER = new RamaddaDisplay(argDisplayManager, argId, type||"group", argProperties);
    RamaddaUtil.inherit(this, SUPER);
    let myProps = [
	{label:'Group Properties'},
	{p:PROP_LAYOUT_TYPE,ex:Utils.join([LAYOUT_TABLE,LAYOUT_HTABLE,LAYOUT_TABS,LAYOUT_COLUMNS,LAYOUT_ROWS],",")},
	{p:PROP_LAYOUT_COLUMNS,d:1},
	]

    displayDefineMembers(this, myProps, {
        displays: [],
        layout: this.getProperty(PROP_LAYOUT_TYPE, LAYOUT_TABLE),
        columns: this.getProperty(PROP_LAYOUT_COLUMNS, 1),
        isLayoutColumns: function() {
            return this.layout == LAYOUT_COLUMNS;
        },
        getWikiText: function() {
            var attrs = ["layoutType", this.layout,
			 "layoutColumns",
			 this.columns,
			 "showMenu",
			 "false",
			 "groupDiv",			 
			 "$entryid_maindiv"
			];
            let wiki = "";
            wiki += "<div id=\"{{entryid}}_maindiv\"></div>\n";
            wiki += "{{group " + HU.attrs(attrs) + "}}\n"
            return wiki;
        },

        walkTree: function(func, data) {
            for (var i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.walkTree != null) {
                    display.walkTree(func, data);
                } else {
                    func.call(data, display);
                }
            }
        },
        collectEntries: function(entries) {
            if (entries == null) entries = [];
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.collectEntries != null) {
                    display.collectEntries(entries);
                } else {
                    let displayEntries = display.getEntries();
                    if (displayEntries != null && displayEntries.length > 0) {
                        entries.push({
                            source: display,
                            entries: displayEntries
                        });
                    }
                }
            }
            return entries;
        },
        isLayoutRows: function() {
            return this.layout == LAYOUT_ROWS;
        },

        getPosition: function() {
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.getPosition) {
                    return display.getPosition();
                }
            }
        },
        getDisplays: function() {
            return this.displays;
        },
        notifyEvent: function(event, source, data) {
            let displays = this.getDisplays();
	    let group = (source!=null&&source.getProperty?source.getProperty(event+".shareGroup"):"");
	    if(displayDebug.notifyEvent)
		console.log("displayManager.notifyEvent:" + event);

            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display == source) {
                    continue;
                }
		let acceptGroup = (display!=null&&display.getProperty?display.getProperty(event.acceptGroup):"");
		if(group) {
		    if(acceptGroup!=group)  {
			if(displayDebug.notifyEvent)
			    console.log("\t" + display.type+" not in group:" + group);
			continue;
		    }
		} else if(acceptGroup) {
		    if(displayDebug.notifyEvent)
			console.log("\t" + display.type+" incoming not in accept group:" + acceptGroup);
		    continue;
		}
		if(!display.acceptEvent(event,  event.default)) {
		    if(displayDebug.notifyEvent)
			console.log("\t" + display.type+" not accepting");
		    continue;
		}
//		console.log("notifyEvent:" + display.type+" " + event +" group:" + group);
                let eventSource = display.getEventSource();
                if (eventSource != null && eventSource.length > 0) {
                    if (eventSource != source.getId() && eventSource != source.getName()) {
                        continue;
                    }
                }
//		if(displayDebug.notifyEvent)
//		console.log("\t" + display.type+" calling notifyEvent:" + event);
                display.notifyEvent(event, source, data);
            }
        },
        getDisplaysToLayout: function() {
            let result = [];
            for (let i = 0; i < this.displays.length; i++) {
                if (this.displays[i].getIsLayoutFixed()) {
		    continue;
		}
                result.push(this.displays[i]);
            }
            return result;
        },
        pageHasLoaded: function(display) {
	    //Maybe we don't need to do this since the displays get called globally
	    //            for (let i = 0; i < this.displays.length; i++) {
	    //                this.displays[i].setDisplayReady(true);
	    //            }
            this.doLayout();
        },
        addDisplay: function(display) {
            this.displays.push(display);
            if (display.getIsLayoutFixed()) {
		display.initDisplay();
	    } else {
		if (Utils.getPageLoaded()) {
                    this.doLayout();
		}
	    }
        },
        layoutChanged: function(display) {
            this.doLayout();
        },
        removeDisplay: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= 0) {
                this.displays.splice(index, 1);
            }
            this.doLayout();
        },
        doLayout: function() {
	    let html = "";
            let colCnt = 100;
            let displaysToLayout = this.getDisplaysToLayout();
            let displaysToPrepare = this.displays;
	    displaysToPrepare.forEach(display=>{
                if (display.prepareToLayout != null) {
                    display.prepareToLayout();
                }
            });

            let weightIdx = 0;
            let weights = null;
            if (typeof this.weights != "undefined") {
                weights = this.weights.split(",");
            }

            for (let i=0; i < displaysToLayout.length; i++) {
                let divId = HU.getUniqueId("divid_");
                let div =  HU.div([CLASS, " display-wrapper",ID,divId],"");
                displaysToLayout[i].setProperty(PROP_DIVID,divId);
                displaysToLayout[i].layoutDiv=div;
            }
            let tabId = HU.getUniqueId("tabs_");
            if (this.layout == LAYOUT_TABLE) {
                if  (displaysToLayout.length== 1) {
                    html += displaysToLayout[0].layoutDiv;
                } else {
                    let weight = 12 / this.columns;
                    let i = 0;
                    let map = {};
                    for (; i < displaysToLayout.length; i++) {
                        let d = displaysToLayout[i];
                        if (Utils.isDefined(d.column) && Utils.isDefined(d.row) && d.columns >= 0 && d.row >= 0) {
                            let key = d.column + "_" + d.row;
                            if (map[key] == null) map[key] = [];
                            map[key].push(d);
                        }
                    }

                    i = 0;
                    for (; i < displaysToLayout.length; i++) {
                        colCnt++;
                        if (colCnt >= this.columns) {
                            if (i > 0) {
                                html += HU.close(TAG_DIV);
                            }
                            html += HU.open("div", [CLASS, "row"]);
                            colCnt = 0;
                        }
                        let weightToUse = weight;
                        if (weights != null) {
                            if (weightIdx >= weights.length) {
                                weightIdx = 0;
                            }
                            weightToUse = weights[weightIdx];
                            weightIdx++;
                        }
                        html += HU.div([CLASS, "col-md-" + weightToUse + " display-wrapper display-cell"], displaysToLayout[i].layoutDiv);
			html+="\n";
		    }

                    if (i > 0) {
                        html += HU.close(TAG_DIV);
                    }
                }
	    } else if (this.layout == LAYOUT_HTABLE) {
                if  (displaysToLayout.length== 1) {
                    html += displaysToLayout[0].layoutDiv;
                } else {
                    let percent = Math.round((100 / this.columns))+"%";
                    let i = 0;
		    html+=HU.open(TABLE,[WIDTH,'100%']);
		    let colCnt = 100;
                    for (let i =0;i < displaysToLayout.length; i++) {
                        colCnt++;
                        if (colCnt >= this.columns) {
                            if (i > 0) {
                                html += HU.close(TAG_TR);
                            }
                            html += HU.open("tr", ["valign", "top"]);
			    html+="\n";
                            colCnt = 0; 
                        }
                        html += HU.td(["width",percent], displaysToLayout[i].layoutDiv);
			html+="\n";
		    }
                    if (i > 0) {
                        html += HU.close(TAG_TR);
                    }
                }
            } else if (this.layout == LAYOUT_TABS) {
                html += HU.open(TAG_DIV, [ID, tabId, CLASS, "ui-tabs"]);
                html += HU.open(TAG_UL, []);
                let hidden = "";
                let cnt = 0;
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let label = display.getTitle(false);
                    if (label.length > 20) {
                        label = label.substring(0, 19) + "...";
                    }
                    html += HU.tag(TAG_LI, [], HU.tag(TAG_A, ["href", "#" + tabId + "-" + cnt], label));
                    hidden += HU.div([ID, tabId + "-" + cnt, CLASS, "ui-tabs-hide"], display.layoutDiv);
                    cnt++;
                }
                html += HU.close(TAG_UL);
                html += hidden;
                html += HU.close(TAG_DIV);
            } else if (this.layout == LAYOUT_ROWS) {
                let rows = [];
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let row = display.getRow();
                    if (("" + row).length == 0) row = 0;
                    while (rows.length <= row) {
                        rows.push([]);
                    }
                    rows[row].push(display.layoutDiv);
                }
                for (let i = 0; i < rows.length; i++) {
                    let cols = rows[i];
                    let width = Math.round(100 / cols.length) + "%";
                    html += HU.open(TAG_TABLE, ["border", "0", "width", "100%", "cellpadding", "0", "cellspacing", "0"]);
                    html += HU.open(TAG_TR, ["valign", "top"]);
                    for (let col = 0; col < cols.length; col++) {
                        let cell = cols[col];
                        cell = HU.div([CLASS, "display-cell"], cell);
                        html += HU.tag(TAG_TD, ["width", width], cell);
                    }
                    html += HU.close(TAG_TR);
                    html += HU.close(TAG_TABLE);
                }
            } else if (this.layout == LAYOUT_COLUMNS) {
                let cols = [];
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let column = display.getColumn();
                    //                        console.log("COL:" + column);
                    if (("" + column).length == 0) column = 0;
                    while (cols.length <= column) {
                        cols.push([]);
                    }
                    cols[column].push(display.layoutDiv);
                    //                        cols[column].push("HTML");
                }
                html += HU.open(TAG_DIV, [CLASS, "row"]);
                let width = Math.round(100 / cols.length) + "%";
                let weight = 12 / cols.length;
                for (let i = 0; i < cols.length; i++) {
                    let rows = cols[i];
                    let contents = "";
                    for (let j = 0; j < rows.length; j++) {
                        contents += rows[j];
                    }
                    let weightToUse = weight;
                    if (weights != null) {
                        if (weightIdx >= weights.length) {
                            weightIdx = 0;
                        }
                        weightToUse = weights[weightIdx];
                        weightIdx++;
                    }
                    html += HU.div([CLASS, "col-md-" + weightToUse], contents);
                }
                html += HU.close(TAG_DIV);
            } else {
                html += "Unknown layout:" + this.layout;
            }

	    //If we don't  have any displays to show then hide us
	    if(!this.getShowMenu() && displaysToLayout.length==0) {
		//TODO: This hides the change entry group menu 
//		$("#" + this.getId()).hide();
	    } else {
		$("#" + this.getId()).show();
	    }
	    let div = this.getGroupDiv();
	    if(div.length>0) {
		div.html(html);
	    } else {
		this.writeHtml(ID_DISPLAYS, html);
	    }
            if (this.layout == LAYOUT_TABS) {
                $("#" + tabId).tabs({activate: HtmlUtil.tabLoaded});
            }
            this.initDisplays();
        }, 
	initDisplays: function() {
	    this.getDisplaysToLayout().forEach(display=>{
		try {
                    display.initDisplay();
		} catch (e) {
		    display.handleError("Error creating display:<br>" + e,e);
		}
            });
	},
        displayData: function() {},
        setLayout: function(layout, columns) {
            this.layout = layout;
            if (columns) {
                this.columns = columns;
            }
            this.doLayout();
        },
        askMinZAxis: function() {
            let v = prompt("Minimum axis value", "0");
            if (v != null) {
                v = parseFloat(v);
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMinZAxis) {
                        display.setMinZAxis(v);
                    }
                }
            }
        },

        askMaxZAxis: function() {
            let v = prompt("Maximum axis value", "0");
            if (v != null) {
                v = parseFloat(v);
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMaxZAxis) {
                        display.setMaxZAxis(v);
                    }
                }
            }
        },

        askMinDate: function() {
            let d = this.minDate;
            if (!d) d = "1950-0-0";
            this.minDate = prompt("Minimum date", d);
            if (this.minDate != null) {
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMinDate) {
                        display.setMinDate(this.minDate);
                    }
                }
            }
        },

        askMaxDate: function() {
            let d = this.maxDate;
            if (!d) d = "2020-0-0";
            this.maxDate = prompt("Maximum date", d);
            if (this.maxDate != null) {
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMaxDate) {
                        display.setMaxDate(this.maxDate);
                    }
                }
            }
        },


        titlesOff: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowTitle(false);
            }
        },
        titlesOn: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowTitle(true);
            }
        },
        detailsOff: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowDetails(false);
            }
            this.doLayout();
        },
        detailsOn: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowDetails(true);
            }
            this.doLayout();
        },

        deleteAllDisplays: function() {
            this.displays = [];
            this.doLayout();
        },
        moveDisplayUp: function(display) {
            let index = this.displays.indexOf(display);
            if (index <= 0) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(index - 1, 0, display);
            this.doLayout();
        },
        moveDisplayDown: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= this.displays.length) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(index + 1, 0, display);
            this.doLayout();
        },

        moveDisplayTop: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= this.displays.length) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(0, 0, display);
            this.doLayout();
        },


    });

}



/*
 */
function RamaddaFieldsDisplay(displayManager, id, type, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    defineDisplay(this, SUPER, [], {
        needsData: function() {
            return true;
        },
        initDisplay: function() {
            SUPER.initDisplay.call(this);
            if (this.needsData()) {
		if(this.useDisplayMessage()) {
                    this.setDisplayMessage(this.getLoadingMessage());
		} else {
                    this.setContents(this.getLoadingMessage());
		}
            }
            this.callUpdateUI();
        },
        updateUI: function(args) {
            this.addFieldsCheckboxes();
        },
        getWikiAttributes: function(attrs) {
            SUPER.getWikiAttributes.call(this, attrs);
            if (this.lastSelectedFields) {
                attrs.push(PROP_FIELDS);
                var v = "";
                for (var i = 0; i < this.lastSelectedFields.length; i++) {
                    v += this.lastSelectedFields[i].getId();
                    v += ",";
                }
                attrs.push(v);
            }
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            this.addFieldsCheckboxes();
        },
        getDialogContents: function(tabTitles, tabContents) {
            var height = "600";
//            var html = HU.div([ATTR_ID, this.getDomId(ID_FIELDS), STYLE, HU.css("overflow-y","auto","max-height", height + "px")], "");
//            tabTitles.push("Fields");
//            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },
        handleEventFieldsSelected: function(source, fields) {
	    var tmp = [];
	    fields.forEach(f=>{
		let fieldId = f.getId?f.getId():f;
		f = this.getFieldById(null, fieldId);
		if(f) tmp.push(f);
	    });
	    fields=tmp;
//	    console.log("fields before:" + this.getSelectedFields());
//	    console.log("fields after:" + fields);

            this.userHasSelectedAField = true;
            this.overrideFields = null;
            this.removeProperty(PROP_FIELDS);
            this.setSelectedFields(fields);
            this.fieldSelectionChanged();
        },

        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        canDoMultiFields: function() {
            return true;
        }
    })
}


/*
let foo={bar:{}};
let key = "";
let times = [];
let z=0;
times.push(new Date());
for(let i=0;i<100000;i++) {
    if(typeof foo.bar[key]!='undefined') {
	z++;
    }
}
times.push(new Date());
Utils.displayTimes("time",times);
<*/
/**
   Copyright 2008-2021 Geode Systems LLC
*/


//Properties
const PROP_LAYOUT_TYPE = "layoutType";
const PROP_LAYOUT_COLUMNS = "layoutColumns";
const PROP_SHOW_MAP = "showMap";
const PROP_SHOW_MENU = "showMenu";
const PROP_FROMDATE = "fromDate";
const PROP_TODATE = "toDate";
const DISPLAY_MULTI = "multi";



//
//adds the display manager to the list of global display managers
//
function addDisplayManager(displayManager) {
    if (window.globalDisplayManagers == null) {
        window.globalDisplayManagers = {};
        // window.globalDisplayManager = null;
    }
    window.globalDisplayManagers[displayManager.getId()] = displayManager;
    window.globalDisplayManager = displayManager;
}




addGlobalDisplayType({
    type: DISPLAY_MULTI,
    label: "Multi Chart",
    requiresData: true,
    forUser: false,
    category: "Misc"
});





//
//This will get the currently created global displaymanager or will create a new one
//
function getOrCreateDisplayManager(id, properties, force) {
    if (!force) {
        var displayManager = getDisplayManager(id);
        if (displayManager != null) {
            return displayManager;
        }
        if (window.globalDisplayManager != null) {
            return window.globalDisplayManager;
        }
    }
    var displayManager = new DisplayManager(id, properties);
    if (window.globalDisplayManager == null) {
        window.globalDisplayManager = displayManager;
    }
    return displayManager;
}

//
//return the global display manager with the given id, null if not found
//
function getDisplayManager(id) {
    if (window.globalDisplayManagers == null) {
        return null;
    }
    var manager = window.globalDisplayManagers[id];
    return manager;
}



var ID_DISPLAYS = "displays";

//
//DisplayManager constructor
//

function DisplayManager(argId, argProperties) {

    var ID_MENU_BUTTON = "menu_button";
    var ID_MENU_CONTAINER = "menu_container";
    var ID_MENU_OUTER = "menu_outer";
    var ID_MENU_INNER = "menu_inner";


    RamaddaUtil.inherit(this, this.SUPER = new DisplayThing(argId, argProperties));
    addRamaddaDisplay(this);

    RamaddaUtil.initMembers(this, {
        dataList: [],
        displayTypes: [],
        initMapBounds: null,
    });


    RamaddaUtil.defineMembers(this, {
        group: new DisplayGroup(this, argId, argProperties),
        showmap: this.getProperty(PROP_SHOW_MAP, null),
        setDisplayReady: function() {
            SUPER.setDisplayReadyCall(this);
            this.getLayoutManager().setDisplayReady();
        },
        getLayoutManager: function() {
            return this.group;
        },
        collectEntries: function() {
            return  this.getLayoutManager().collectEntries();
        },
        getData: function() {
            return this.dataList;
        },
        handleEventFieldValueSelect: function(source, args) {
            this.notifyEvent(DisplayEvent.fieldValueSelected, source, args);
        },
        handleEventFieldsSelected: function(source, fields) {
            this.notifyEvent(DisplayEvent.fieldsSelected, source, fields);
        },
        handleEventPropertyChanged: function(source, prop) {
            this.notifyEvent(DisplayEvent.propertyChanged, source, prop);
        },
        handleEventEntriesChanged: function(source, entries) {
            this.notifyEvent(DisplayEvent.entriesChanged, source, entries);
        },
        handleEventMapBoundsChanged: function(source, bounds, forceSet) {
            var args = {
                "bounds": bounds,
                "force": forceSet
            };
            this.notifyEvent(DisplayEvent.mapBoundsChanged, source, args);
        },
        addMapLayer: function(source, entry) {
            this.notifyEvent("addMapLayer", source, {
                entry: entry
            });
        },
        propagateEventRecordSelection: function(source, pointData, args) {
            var index = args.index;
            if (pointData == null && this.dataList.length > 0) {
                pointData = this.dataList[0];
            }
            var fields = pointData.getRecordFields();
            var records = pointData.getRecords();
            if (records == null) {
                return;
            }
            if (index < 0 || index >= records.length) {
                console.log("propagateEventRecordSelection: bad index= " + index);
                return;
            }
            var record = records[index];
            if (record == null) return;
            var values = source?source.getRecordHtml(record, fields):"";
            if (source.recordSelectionCallback) {
                var func = source.recordSelectionCallback;
                if ((typeof func) == "string") {
                    func = window[func];
                }
                func({
                    display: source,
                    pointData: pointData,
                    index: index,
                    pointRecord: record
                });
            }
            var params = {
                index: index,
                record: record,
                html: values,
                data: pointData
            };
            this.notifyEvent(DisplayEvent.recordSelection, source, params);
            var entries = source.getEntries();
            if (entries != null && entries.length > 0) {
                this.handleEventEntrySelection(source, {
                    entry: entries[0],
                    selected: true
                });
            }
        },
        handleEventEntrySelection: function(source, props) {
            this.notifyEvent(DisplayEvent.entrySelection, source, props);
        },
        handleEventEntryMouseover: function(source, props) {
            this.notifyEvent(DisplayEvent.entryMouseover, source, props);
        },
        handleEventEntryMouseout: function(source, props) {
            this.notifyEvent(DisplayEvent.entryMouseout, source, props);
        },
        handleEventPointDataLoaded: function(source, pointData) {
            this.notifyEvent(DisplayEvent.pointDataLoaded, source, pointData);
        },
        ranges: {
            //               "TRF": [0,100],
        },
        setRange: function(field, range) {
            if (this.ranges[field.getId()] == null) {
                this.ranges[field.getId()] = range;
            }
        },
        getRange: function(field) {
            return this.ranges[field.getId()];
        },
        makeMainMenu: function() {
	    if(!this.getShowMenu()) {
		return "";
	    }
            //How else do I refer to this object in the html that I add 
            var get = "getDisplayManager('" + this.getId() + "')";
            var layout = "getDisplayManager('" + this.getId() + "').getLayoutManager()";
            var html = "";

            var newMenus = {};
            var cats = [];
            var displayTypes = [];
            if (window.globalDisplayTypes != null) {
                displayTypes = window.globalDisplayTypes;
            }
	    DISPLAY_CATEGORIES.forEach(category=>{
                newMenus[category] = [];
                cats.push(category);
	    });
            for (var i = 0; i < displayTypes.length; i++) {
                //The ids (.e.g., 'linechart' have to match up with some class function with the name 
                var type = displayTypes[i];
                if (Utils.isDefined(type.forUser) && !type.forUser) {
                    continue;
                }
		var category = type.category;
                if (!category) {
                    category = CATEGORY_MISC;
                }
                if (newMenus[category] == null) {
                    newMenus[category] = [];
                    cats.push(category);
                }
		let menuAttrs = ["onclick", get + ".userCreateDisplay('" + type.type + "');"];
		if(type.desc) {
		    menuAttrs.push(TITLE);
		    menuAttrs.push(type.desc);
		}
                newMenus[category].push(HU.tag(TAG_LI, [], HU.tag(TAG_A, menuAttrs, type.label)));
            }
            let newMenu = "";
            for (var i = 0; i < cats.length; i++) {
                var cat = cats[i];
		var menu = Utils.join(newMenus[cat],"");
                var subMenu = HU.tag("ul", [], menu);
                var catLabel = HU.tag(TAG_A, [], cat);
                newMenu += HU.tag(TAG_LI, [], catLabel + subMenu);
            }


            var publishMenu =
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('media_photoalbum');", "New Photo Album")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('wikipage');", "New Wiki Page")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('blogentry');", "New Blog Post")) + "\n";


            var fileMenu =
                HU.tag(TAG_LI, [], "<a>Publish</a>" + HU.tag("ul", [], publishMenu)) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".showWikiText();", "Show Text")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".copyWikiText();", "Copy Text")) + "\n" +		
                HU.tag(TAG_LI, [], HU.onClick(layout + ".copyDisplayedEntries();", "Save entries")) + "\n";


            var titles = HU.tag(TAG_DIV, ["class", "ramadda-menu-block"], "Titles: " + HU.onClick(layout + ".titlesOn();", "On") + "/" + HU.onClick(layout + ".titlesOff();", "Off"));
            var dates = HU.tag(TAG_DIV, ["class", "ramadda-menu-block"],
				      "Set date range: " +
				      HU.onClick(layout + ".askMinDate();", "Min") + "/" +
				      HU.onClick(layout + ".askMaxDate();", "Max"));
            var editMenu =
                HU.tag(TAG_LI, [], HU.tag(TAG_DIV, ["class", "ramadda-menu-block"],
							"Set axis range :" +
							HU.onClick(layout + ".askMinZAxis();", "Min") + "/" +
							HU.onClick(layout + ".askMaxZAxis();", "Max"))) +
                HU.tag(TAG_LI, [], dates) +
                HU.tag(TAG_LI, [], titles) + "\n" +
                HU.tag(TAG_LI, [], HU.tag(TAG_DIV, ["class", "ramadda-menu-block"], "Details: " + HU.onClick(layout + ".detailsOn();", "On", []) + "/" +
							HU.onClick(layout + ".detailsOff();", "Off", []))) +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".deleteAllDisplays();", "Delete all displays")) + "\n" +
                "";


            var table = HU.tag(TAG_DIV, ["class", "ramadda-menu-block"], "Table: " +
				      HU.onClick(layout + ".setLayout('table',1);", "1 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',2);", "2 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',3);", "3 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',4);", "4 column"));
            var layoutMenu =
                HU.tag(TAG_LI, [], table) +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('rows');", "Rows")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('columns');", "Columns")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('tabs');", "Tabs"));


            var menuBar = HU.tag(TAG_LI, [], "<a>File</a>" + HU.tag("ul", [], fileMenu));
            menuBar += HU.tag(TAG_LI, [], "<a>Edit</a>" + HU.tag("ul", [], editMenu)) +
                HU.tag(TAG_LI, [], "<a>New</a>" + HU.tag("ul", [], newMenu)) +
                HU.tag(TAG_LI, [], "<a>Layout</a>" + HU.tag("ul", [], layoutMenu));


            var menu = HU.div([STYLE,"background:#fff;z-index:1000;", ATTR_CLASS, "xramadda-popup", ATTR_ID, this.getDomId(ID_MENU_OUTER)],
			      HU.tag("ul", [ATTR_ID, this.getDomId(ID_MENU_INNER), ATTR_CLASS, "sf-menu"], menuBar));

            html += menu;
            //                html += HU.tag(TAG_A, [ATTR_CLASS, "display-menu-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)],"&nbsp;");
            //                html+="<br>";
            return html;
        },
        hasGeoMacro: function(jsonUrl) {
	    if(!jsonUrl) return false;
            return jsonUrl.match(/(\${latitude})/g) != null;
        },
        getJsonUrl: function(jsonUrl, display, props) {
	    display.getRequestMacros().forEach(m=>{
		jsonUrl = m.apply(jsonUrl);
	    });
	    if(display.getAnimationEnabled()) {
		//Not now. Once was needed for gridded data
		//jsonUrl +='&doAnimation=true'
	    }
	    if(display.getProperty('dbSelect')) {
		jsonUrl +="&" + "dbSelect" +"=" +display.getProperty("select");
	    }
	    if(display.getProperty("requestArgs")) {
		let args = display.getProperty("requestArgs").split(",");
		for(let i=0;i<args.length;i+=2) {
		    jsonUrl +="&" + args[i] +"=" + args[i+1];
		}
	    }

	    if(display.pageSkip) {
		jsonUrl+="&skip=" + display.pageSkip;
	    }


            var fromDate = display.getProperty(PROP_FROMDATE);
            if (fromDate != null) {
                jsonUrl += "&fromdate=" + fromDate;
            }
            var toDate = display.getProperty(PROP_TODATE);
            if (toDate != null) {
                jsonUrl += "&todate=" + toDate;
            }

            if (this.hasGeoMacro(jsonUrl)) {
                var lon = props.lon;
                var lat = props.lat;

                if ((lon == null || lat == null) && this.map != null) {
                    var tuple = this.getPosition();
                    if (tuple != null) {
                        lat = tuple[0];
                        lon = tuple[1];
                    }
                }
                if (lon != null && lat != null) {
                    jsonUrl = jsonUrl.replace("${latitude}", lat.toString());
                    jsonUrl = jsonUrl.replace("${longitude}", lon.toString());
                }
            }
            jsonUrl = jsonUrl.replace("${numpoints}", 1000);
            return jsonUrl;
        },
        getDefaultData: function() {
            for (var i in this.dataList) {
                var data = this.dataList[i];
                var records = data.getRecords();
                if (records != null) {
                    return data;
                }
            }
            if (this.dataList.length > 0) {
                return this.dataList[0];
            }
            return null;
        },

        writeDisplay: function() {
            if (this.originalLocation == null) {
                this.originalLocation = document.location;
            }
            var url = this.originalLocation + "#";
            url += "&display0=linechart";
            for (var attr in document) {
                //                   if(attr.toString().contains("location")) 
                //                       console.log(attr +"=" + document[attr]);
            }
            document.location = url;

        },
        userCreateDisplay: function(type, props) {
            if (props == null) {
                props = {};
            }
            props.editMode = true;
            props.layoutHere = false;
            if (type == DISPLAY_LABEL && props.text == null) {
                var text = prompt("Text");
                if (text == null) return;
                props.text = text;
            }
            return this.createDisplay(type, props);
        },
        createDisplay: function(type, props) {

            if (props == null) {
                props = {};
            }

            if (props.data != null) {
		props.theData = props.data;
		props.data = null;
	    }

            if (props.theData != null && !props.theData.hasData()) {
                let haveItAlready = false;
                for (var i = 0; i < this.dataList.length; i++) {
                    let existingData = this.dataList[i];
                    if (existingData.equals(props.theData)) {
                        props.theData = existingData;
                        haveItAlready = true;
                        break;
                    }
                }
                if (!haveItAlready) {
                    this.dataList.push(props.theData);
                }
                //                console.log("data:" + haveItAlready);
            }

	    if(type==null || type.trim().length==0) return null;
            //            console.log("props:" + JSON.stringify(props));
            //Upper case the type name, e.g., linechart->Linechart
            var proc = type.substring(0, 1).toUpperCase() + type.substring(1);


            //Look for global functions  Ramadda<Type>Display, <Type>Display, <Type> 
            //e.g. - RamaddaLinechartDisplay, LinechartDisplay, Linechart 
            var classname = null;
            var names = ["Ramadda" + proc + "Display",
			 proc + "Display",
			 "Display"+ proc,
			 proc
			];
            var func = null;
            var funcName = null;
            var msg = "";
            for (var i = 0; i < names.length; i++) {
                msg += ("trying:" + names[i] + "\n");
                if (window[names[i]] != null) {
                    funcName = names[i];
                    func = window[names[i]];
                    break;
                }

            }

            if (func == null) {
                console.log("Error: could not find display function:" + type);
                //                    alert("Error: could not find display function:" + type);
                alert("Error: could not find display function:" + type + " msg: " + msg);
                return;
            }
            let displayId = props.displayId;
	    if(!displayId)  {
		displayId = this.getUniqueId("display");
	    }
            if (props.theData == null && this.dataList.length > 0) {
                props.theData = this.dataList[0];
            }
            props.createdInteractively = true;
            if (!props.entryId) {
                props.entryId = this.group.entryId;
            }
            let display = eval(" new " + funcName + "(this,'" + displayId + "', props);");
            if (display == null) {
                console.log("Error: could not create display using:" + funcName);
                alert("Error: could not create display using:" + funcName);
                return;
            }
	    if(props.dummy) return display;
            this.addDisplay(display);
	    display.doFinalInitialization();
            return display;
        },
        pageHasLoaded: function(display) {
            this.getLayoutManager().pageHasLoaded();
        },
        addDisplay: function(display) {
            display.setDisplayManager(this);
            display.loadInitialData();
            this.getLayoutManager().addDisplay(display);
        },
	getDisplays: function() {
	    return this.getLayoutManager().getDisplays();
	},
        notifyEvent: function(event, source, data) {
            this.getLayoutManager().notifyEvent(event, source, data);
        },
        removeDisplay: function(display) {
            this.getLayoutManager().removeDisplay(display);
            this.notifyEvent(DisplayEvent.removeDisplay, this, display);
        },
	setEntry: function(entry) {
	    this.getLayoutManager().getDisplays().forEach(display=>{
		display.setEntry(entry);
	    });
	},
    });

    addDisplayManager(this);

    let displaysHtml = HU.div([ATTR_ID, this.getDomId(ID_DISPLAYS), ATTR_CLASS, "display-container",STYLE,HU.css("display","block")]);
    let html = HU.openTag(TAG_DIV,["style","position:relative;"]);
    html += HU.div(["id", this.getDomId(ID_MENU_CONTAINER)]);
    html +=  this.getEntriesMenu(argProperties);

    if(this.getShowMenu()) {
        html += HU.tag(TAG_A, [ATTR_CLASS, "display-menu-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)], SPACE);
    }
    let targetDiv = this.getProperty("target",this.getProperty("targetDiv"));
    let _this = this;
    if (targetDiv != null) {
	if($("#" + targetDiv).length==0) {
	    console.log("Error: display group could not find targetDiv:" + targetDiv);
	    targetDiv=null;
	}
    }

    if (targetDiv != null) {
        $(document).ready(function() {
            $("#" + targetDiv).html(displaysHtml);
            _this.getLayoutManager().doLayout();
	});
    } else {
        html += displaysHtml;
    }
    html += HU.closeTag(TAG_DIV);
    let divid = this.getProperty("divId",this.getId());
    $("#" + divid).html(html)
    this.initializeEntriesMenu();

    this.jq(ID_MENU_BUTTON).html(HU.getIconImage("fa-cog",[TITLE,"Display menu"] )).button({
	classes: {
	    "ui-button": "display-manager-button",
	}	
    }).click(function(event) {
	if(this.dialog) {
	    this.dialog.remove();
	}
        let html = _this.makeMainMenu();
	this.dialog = HU.makeDialog({content:html,title:"Displays",my:"left top",at:"left bottom",anchor:_this.jq(ID_MENU_BUTTON)});
        _this.jq(ID_MENU_INNER).superfish({
            //Don't set animation - it is broke on safari
            //                    animation: {height:'show'},
            speed: 'fast',
            delay: 300
        });


    });

}


function RamaddaMultiDisplay(displayManager, id, properties) {
    this.props = properties;
    let SUPER = new DisplayGroup(displayManager, id, properties, DISPLAY_MULTI);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        inInitDisplay: false,
        haveInited: false,
        needsData: function() {
            return true;
        },
        pointDataLoaded: function(pointData, url, reload) {
            SUPER.pointDataLoaded.call(this, pointData, url, reload);
            this.initDisplay();
        },
        processMacros: function(selectedFields, value, makeList) {
            if ((typeof value) != "string") return null;
            var toks = [];
            if (value.includes("${fieldLabel}")) {
                for (i = 0; i < selectedFields.length; i++) {
                    var v = value.replace("\${fieldLabel}", selectedFields[i].getLabel());
                    toks.push(v);
                }
            } else if (value.includes("${fieldId}")) {
                for (i = 0; i < selectedFields.length; i++) { 
                   var v = value.replace("\${fieldId}", selectedFields[i].getId());
                    toks.push(v);
                }
            } else if (value.includes("${fieldCnt}")) {
                var v = value.replace("\${fieldCnt}", selectedFields.length);
                toks.push(v);
            } else if (value.includes("${")) {

            } else {
                return null;
            }
            if (makeList) return toks;
            return Utils.join(toks, ",");
        },
        initDisplay: function() {
            try {
                this.initDisplayInner();
            } catch (e) {
                this.setContents(this.getMessage("An error occurred:" + e));
                console.log("An error occurred:" + e);
                console.log(e.stack);
            }
        },
        useChartableFields: function() {
            return false;
        },
        initDisplayInner: function() {
            SUPER.initDisplay.call(this);
            let records = this.filterData();
            if (!records) {
                this.setDisplayMessage(this.getLoadingMessage());
                return null;
            }

            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0) {
                this.setContents(this.getMessage("no fields"));
                return;
            }

            if (this.inInitDisplay) return;
            if (this.haveInited) return;
            this.haveInited = true;
            this.inInitDisplay = true;

            var props = {};
            var foreachMap = {};
            var foreachList = [];
            var cnt = 0;
            for (a in this.props) {
                if (a.startsWith("foreach_")) {
                    var value = this.props[a];
                    var toks;
                    var tmp = this.processMacros(fields, value, true);
                    if (tmp) {
                        toks = tmp;
                    } else {
                        toks = value.split(",");
                    }
                    a = a.substring(8);
                    if (toks.length > cnt) cnt = toks.length;
                    foreachMap[a] = toks;
                    foreachList.push({
                        attr: a,
                        toks: toks
                    });
                }
                if (a.startsWith("sub_")) {
                    var value = this.props[a];
                    a = a.substring(4);
                    var tmp = this.processMacros(fields, value, false);
                    if (tmp) {
                        value = tmp;
                    }
                    props[a] = value;
                }
            }
            var html = HU.div([ATTR_ID, this.getDomId(ID_DISPLAYS), ATTR_CLASS, "display-container"]);
            this.setContents(html);
            var groupProps = {
                target: this.getDomId(ID_DISPLAYS),
            }
            groupProps[PROP_LAYOUT_TYPE] = 'table';
            groupProps[PROP_LAYOUT_COLUMNS] = this.getProperty(PROP_LAYOUT_COLUMNS, "2");
            this.displayManager = new DisplayManager(this.getId() + "_manager", groupProps);


            props.layoutHere = false;
            if (this.props['data'])
                props['data'] = this.props['data'];
            var subType = this.getProperty("subType", "table");
            if (cnt == 0) cnt = 1;
            for (var i = 0; i < cnt; i++) {
                var dprops = {};
                $.extend(dprops, props);
                for (var j = 0; j < foreachList.length; j++) {
                    if (i < foreachList[j].toks.length) {
                        dprops[foreachList[j].attr] = foreachList[j].toks[i];
                    }
                }
                if (dprops['fields']) dprops['fields'] = dprops['fields'].split(",");
                this.displayManager.createDisplay(subType, dprops);
            }
            this.inInitDisplay = false;
        }
    });
}

/**
   Copyright 2008-2020 Geode Systems LLC
*/

const FILTER_ALL = "-all-";
let pointDataCache = {};

function DataCollection() {
    RamaddaUtil.defineMembers(this, {
        data: [],
        hasData: function() {
            for (var i = 0; i < this.data.length; i++) {
		if(this.data[i])
                    if (this.data[i].hasData()) return true;
            }
            return false;
        },
        getList: function() {
            return this.data;
        },
	setData: function(data) {
	    this.data = [data];
	},
        addData: function(data) {
            this.data.push(data);
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
            var anyHandled = false;
            for (var i = 0; i < this.data.length; i++) {
                if (this.data[i].handleEventMapClick(myDisplay, source, lon, lat)) {
                    anyHandled = true;
                }
            }
            return anyHandled;

        },


    });

}

function BasePointData(name, properties) {
    if (properties == null) properties = {};

    RamaddaUtil.defineMembers(this, {
        recordFields: null,
        records: null,
        entryId: null,
        entry: null
    });

    $.extend(this, properties);

    RamaddaUtil.defineMembers(this, {
        name: name,
        properties: properties,
        initWith: function(thatPointData) {
            this.recordFields = thatPointData.recordFields;
            this.records = thatPointData.records;
            this.setGroupField();
	    return this;
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
            return false;
        },
        hasData: function() {
            return this.records != null && this.records.length>0;
        },
        clear: function() {
            this.records = null;
            this.recordFields = null;
        },
        getProperties: function() {
            return this.properties;
        },
        getProperty: function(key, dflt) {
            var value = this.properties[key];
            if (value == null) return dflt;
            return value;
        },

        getRecordFields: function() {
            return this.recordFields;
        },
        addRecordField: function(field) {
            this.recordFields.push(field);
        },
        getRecords: function() {
            return this.records;
        },
        getNumericFields: function() {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (field.isNumeric()) numericFields.push(field);
            }
            return numericFields;
        },
        getChartableFields: function(display) {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            var skip = /(TIME|HOUR|MINUTE|SECOND|YEAR|MONTH|DAY|LATITUDE|LONGITUDE|^ELEVATION$)/g;
            var skip = /(xxxnoskip)/g;
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (!field.isNumeric() || !field.isChartable()) {
                    continue;
                }
                var ID = field.getId().toUpperCase();
                if (ID.match(skip)) {
                    continue;
                }
                numericFields.push(field);
            }

            return RecordUtil.sort(numericFields);
        },
        getNonGeoFields: function(display) {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            //                var skip = /(TIME|HOUR|MINUTE|SECOND|YEAR|MONTH|DAY|LATITUDE|LONGITUDE|ELEVATION)/g;
            var hadDate = false;
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (field.isFieldGeo()) {
                    continue;
                }
		//		console.log("F:" + field.getId());
                if (field.isFieldDate()) {
                    if (hadDate && field.getId() == "recordDate") {
                        continue;
                    }
                    hadDate = true;
                }

                //                    var ID = field.getId().toUpperCase() ;
                //                    if(ID.match(skip)) {
                //                        continue;
                //                    }
                numericFields.push(field);
            }
            return numericFields;
            //                return RecordUtil.sort(numericFields);
        },

        loadData: function(display) {},
        getName: function() {
            return this.name;
        },
        getTitle: function() {
            if (this.records != null && this.records.length > 0)
                return this.name + " - " + this.records.length + " points";
            return this.name;
        }
    });
}





function convertToPointData(array) {
    var fields = [];
    var records = [];
    var header = array[0];
    var samples = array[1];
    for(var i=0;i<header.length;i++) {
        let label = String(header[i]);
	let id = label.toLowerCase().replace(/[ ., ]+/g,"_");
        let sample =samples[i];
        let tof= typeof sample;
        let type;
        if(tof=="string")
            type = "string";
        else if(tof=="number")
            type = "double";
        else if(sample.getTime)
            type = "date";
        else 
            console.log("Unknown type:" + tof);
        fields.push(new RecordField({
            id:id,
	    index:i,
            label:label,
            type:type,
            chartable:true
        }));
    }
    for(var i=1;i<array.length;i++) {
        records.push(new  PointRecord(fields,NaN, NaN, NaN, null, array[i]));
    }
    return new  PointData("pointdata", fields, records,null,null);
}


/*
  This encapsulates some instance of point data. 
  name - the name of this data
  recordFields - array of RecordField objects that define the metadata
  data - array of Record objects holding the data
*/
function PointData(name, recordFields, records, url, properties) {
    RamaddaUtil.inherit(this, new BasePointData(name, properties));
    this.parentPointData = properties?properties.parent:null;
    RamaddaUtil.defineMembers(this, {
        recordFields: recordFields,
        records: records,
        url: url,
	baseUrl:url,
        loadingCnt: 0,
	getRootPointData: function() {
	    if(this.parentPointData)
		return this.parentPointData.getRootPointData();
	    return this;
	},
        getUrl: function() {
	    if(this.url) return this.url;
	    if(this.parentPointData) return this.parentPointData.getUrl();
	    return null;
	},
        getCacheUrl: function() {
	    if(this.baseUrl) return this.baseUrl;
	    if(this.parentPointData) return this.parentPointData.getCacheUrl();
	    return null;
	},	
        equals: function(that) {
	    if(this.jsonUrl) {
		return this.jsonUrl == that.jsonUrl;
	    }
            return this.url == that.url;
        },
        getIsLoading: function() {
            return this.loadingCnt > 0;
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
	    let url = this.getUrl();
            let cacheObject = pointDataCache[url];
            this.lon = lon;
            this.lat = lat;
	    ///repository/grid/json?entryid=3715ca8e-3c42-4105-96b1-da63e3813b3a&location.latitude=0&location.longitude=179.5
	    //	    initiallatitude=40&location.latitude=0&location.longitude=179.5
            if (myDisplay.getDisplayManager().hasGeoMacro(url)) {
		this.loadData(myDisplay, true);
                return true;
            }
            return false;
        },
        startLoading: function() {
            this.loadingCnt++;
        },
        stopLoading: function() {
            this.loadingCnt--;
        },
        setGroupField: function() {
            if(this.recordFields) {
                for(var i=0;i<this.recordFields.length;i++) {
                    var field = this.recordFields[i];
                    if(field.isFieldGroup()) {
                        this.groupField = field;
                        break;
                    }
                }
            }
        },
        extractGroup: function(group, records) {
            if(!this.groupField) return records;
            var groupData = this.getDataGroups(records);
            if(groupData.length==0) return records;
            if(!group) group = groupData[0];
            return records;
        },
        getDataGroups: function(records) {
            if(!this.groupData) {
                if(!records) return [];
                this.groupData= [];
                var groupField = this.getGroupField();
                if(!groupField) return this.groupData;
                var seen = {};
                for(var i=0;i<records.length;i++) {
                    var record = records[i];
                    var data;
                    if(record.tuple) 
                        data = record.tuple;
                    else if(record.record)
                        data = record.record.getData();
                    console.log("data:" + data);
                    var value = groupField.getValue(record);
                    if(!seen[value]) {
                        seen[value] = true;
                        this.groupData.push(value);
                    }
                }
            }
            console.log(this.groupData);
            return this.groupData;
        },
        getGroupField: function() {
            return this.groupField;
        },
        isGroup: function() {
            return this.getGroupField()!=null;
        },
        loadData: function(display, reload) {
	    let root = this.getRootPointData();
            if (root.url == null) {
                console.log("No URL");
                return;
            }
            let props = {
                lat: this.lat,
                lon: this.lon,
            };
            let jsonUrl = display.displayManager.getJsonUrl(root.url, display, props);
	    root.jsonUrl = jsonUrl;
            root.loadPointJson(jsonUrl, display, reload);
        },
	getCacheObject: function() {
            let cacheObject = pointDataCache[this.getUrl()];
	    if(!cacheObject) {
		let cacheUrl = this.getCacheUrl();
		if(cacheUrl) cacheObject = pointDataCache[cacheUrl];
	    }
	    return cacheObject;
	},

	propagateEventDataChanged:function(source) {
            let cacheObject = this.getCacheObject();
            if(cacheObject) {
		let displays = cacheObject.displays;
		if(displays) {
		    displays.forEach(display=>{
			if(display==source) return;
			display.pointDataLoaded(this, this.url, true);
		    });
                }
	    }
	},

        loadPointJson: function(url, display, reload) {
	    let debug =  displayDebug.loadPointJson;
	    let debug2 = false;
            let pointData = this;
            this.startLoading();
            let _this = this;
	    if(debug) {
		console.log("loadPointJson: "+ display.type +" " + display.getId() +" url:" + url);
	    } 
	    let cacheId = this.getCacheUrl();
            let cacheObject = pointDataCache[cacheId];
            if (cacheObject == null) {
                cacheObject = {
                    pointData: null,
                    pending: [],
		    displays:[],
		    size:0,
		    url:url,
		    toString:function() {
			return "cache:" + (this.pointData==null?" no data ":" data:" +this.pointData.pdcnt +" " + this.pointData.getRecords().length) +" url:" + this.url;
		    }

                };
		if(debug)
                    console.log("\tcreated cache object: " +cacheId);
                pointDataCache[cacheId] = cacheObject;
            } else {
		if(cacheObject.pending.indexOf(display)>=0) {
		    if(debug)
			console.log("\tcache hit - display in pending list");
		    return;
		} else {
		    if(debug)
			console.log("\tcache hit - display not in pending list");
		}
	    }		
	    if(cacheObject.displays.indexOf(display)<0) {
		if(debug2)
		    console.log("adding to displays-1:" + display);
		cacheObject.displays.push(display);
	    }
	    //If we are reloading then clear the data
	    //Don't do this for now
	    if(reload) {
		//If its a reload then add all dependent displays to the pending list
		cacheObject.pointData = null;
		cacheObject.pending = [];
		if(debug)
		    console.log("\treloading adding to pending:" + cacheObject.displays);
		cacheObject.displays.forEach(d=>{
		    if(debug)
			console.log("\tdisplay:" + d.type +" " + d.getId());
		    cacheObject.pending.push(d);
		});
	    } else {
		if(cacheObject.displays.indexOf(display)<0) {
		    if(debug2)
			console.log("adding to displays-2:" + display);
		    cacheObject.displays.push(display);
		}
		if (cacheObject.pointData != null) {
		    if(debug)
			console.log("\tdata was in cache:" +cacheObject.pointData.getRecords().length+" url:" + url);
                    display.pointDataLoaded(cacheObject.pointData, url, reload);
                    return;
		}
		cacheObject.pending.push(display);
		if (cacheObject.pending.length > 1) {
		    if(debug)
			console.log("\tWaiting on callback:" + cacheObject.pending.length +" " + url +" d:" + display);
                    return;
		}
	    }
            let fail = function(jqxhr, textStatus, error) {
		console.log("Point data load error:" + textStatus +" " + error);
                var err = textStatus;
		if(err) {
		    if(error)
			err += ": " + error;
		} else {
		    err = error;
		}
		console.log("Point data load error:" + (err?err:""));
		cacheObject.pending.map(display=>{
                    display.pointDataLoadFailed(err);
		});
		delete pointDataCache[url];
                pointData.stopLoading();
            }

            let success=function(data) {
		if(typeof data == "string") {
		    try {
//			if(displayDebug.setEntry)
//			    console.log("pointdata got data:"+ data.substring(0,2000));
			data = JSON.parse(data);

		    } catch(exc) {
			console.log("Error:" + exc);
			if(data.length>1000) data = data.substring(0,999);
			console.log("data:" + data);
			display.displayError("Error loading data:" + exc+"<br>URL:"+ url);
			return;
		    }
		}
		if(debug) console.log("pointDataLoaded");
                if (GuiUtils.isJsonError(data)) {
		    if(debug)
			console.log("\tloadPointData failed");
		    console.log("loadPointData failed:" + data);
                    display.pointDataLoadFailed(data);
                    return;
                }
		if(data.errorcode == "nodata" || !data.fields) {
		    if(debug)
			console.log("\tno data:" + url);
		    let dummy = new PointData("", [],[]);
                    let pending = cacheObject.pending;
                    cacheObject.pending = [];
		    pending.forEach(d=>{
			d.handleNoData(dummy);
		    });
		    return;
		}
		if(debug)
		    console.log("\tmaking point data");
		let t1 = new Date();
                var newData = makePointData(data, _this.derived, display,_this.url);
		let t2 = new Date();
		if(debug)
		    Utils.displayTimes("makePointData",[t1,t2],true);

		if(debug)
		    console.log("\tdone making point data #records:" + newData.getRecords().length);
                pointData = cacheObject.pointData = newData;
		//                cacheObject.pointData = pointData.initWith(newData);
		if(data.properties) {
		    display.applyRequestProperties(data.properties);
		}
                let tmp = cacheObject.pending;
		if(debug) {
		    console.log("\tcalling pointDataLoaded on  " + tmp.length + " pending displays");
		    if(cacheObject.displays)
			console.log("\tcacheObject.displays:" + cacheObject.displays.length)
		}
                cacheObject.pending = [];
                for (let i = 0; i < tmp.length; i++) {
		    if(debug)
			console.log("\tcalling pointDataLoaded:" + tmp[i] +" #:" + pointData.getRecords().length);
                    tmp[i].pointDataLoaded(pointData, url, reload);
                }

		if(cacheObject.pointData.records && cacheObject.pointData.records.length) {
		    cacheObject.size = cacheObject.pointData.records.length*cacheObject.pointData.records[0].getData().length;
		}

		let size = 0;
		Object.keys(pointDataCache).map(key=>{
		    size+=pointDataCache[key].size;
		});
		if(debug)
		    console.log("\tcache size:" + size);
		//Size is just the number of rows*columns
		if(size>1000000) {
		    Object.keys(pointDataCache).map(key=>{
			if(pointDataCache[key].pending.length==0) {
			    if(debug)
				console.log("\tDeleting from cache:" + key);
			    delete pointDataCache[key];
			}
		    });
		}
                pointData.stopLoading();
	    }
	    let fullUrl = url;
	    if(!fullUrl.startsWith("http")) {
		var base = window.location.protocol + "//" + window.location.host;
		fullUrl = base+fullUrl;
	    }

	    //            Utils.doFetch(url, success,fail,"json");
	    //Handle the snapshot relative file
	    if(!url.startsWith("/") && !url.startsWith("http")) {
		let root = String(window.location).replace(/\/[^\/]+$/,"");
		url = root + "/" + url;
	    }
	    display.handleLog(display.type+" load point data:" + url);
            Utils.doFetch(url, success,fail,null);	    
//            var jqxhr = $.getJSON(url, success,{crossDomain:true}).fail(fail);
        }

    });
    this.setGroupField();
}


function DerivedPointData(displayManager, name, pointDataList, operation) {
    RamaddaUtil.inherit(this, new BasePointData(name));
    RamaddaUtil.defineMembers(this, {
        displayManager: displayManager,
        operation: operation,
        pointDataList: pointDataList,
        loadDataCalls: 0,
        display: null,
        pointDataLoaded: function(pointData) {
            this.loadDataCalls--;
            if (this.loadDataCalls <= 0) {
                this.initData();
            }
        },
        equals: function(that) {
            if (that.pointDataList == null) return false;
            if (this.pointDataList.length != that.pointDataList.length) return false;
            for (var i in this.pointDataList) {
                if (!this.pointDataList[i].equals(that.pointDataList[i])) {
                    return false;
                }
            }
            return true;
        },
        initData: function() {
            var pointData1 = this.pointDataList[0];
            if (this.pointDataList.length == 1) {
                this.records = pointData1.getRecords();
                this.recordFields = pointData1.getRecordFields();
		console.log("initData:" + this.recordFields.length);
            } else if (this.pointDataList.length > 1) {
                var results = this.combineData(pointData1, this.pointDataList[1]);
                this.records = results.records;
                this.recordFields = results.recordFields;
		console.log("initData 2:" + this.recordFields.length);
            }
            this.setGroupField();
            this.display.pointDataLoaded(this);
        },

        combineData: function(pointData1, pointData2) {
            var records1 = pointData1.getRecords();
            var records2 = pointData2.getRecords();
            var newRecords = [];
            var newRecordFields;

            //TODO:  we really need visad here to sample

            if (records1.length != records2.length) {
                console.log("bad records:" + records1.length + " " + records2.length);
            }

            if (this.operation == "average") {
                for (var recordIdx = 0; recordIdx < records1.length; recordIdx++) {
                    var record1 = records1[recordIdx];
                    var record2 = records2[recordIdx];
                    if (record1.getDate() != record2.getDate()) {
                        console.log("Bad record date:" + record1.getDate() + " " + record2.getDate());
                        break;
                    }
                    var newRecord = $.extend(true, {}, record1);
                    var data1 = newRecord.getData();
                    var data2 = record2.getData();
                    for (var colIdx = 0; colIdx < data1.length; colIdx++) {
                        data1[colIdx] = (data1[colIdx] + data2[colIdx]) / 2;
                    }
                    newRecords.push(newRecord);
                }
                newRecordFields = pointData1.getRecordFields();
            } else if (this.operation == "other func") {}
            if (newRecordFields == null) {
                //for now just use the first operand
                newRecords = records1;
                newRecordFields = pointData1.getRecordFields();
            }
            return {
                records: newRecords,
                recordFields: newRecordFields
            };
        },
        loadData: function(display) {
            this.display = display;
            this.loadDataCalls = 0;
            for (var i in this.pointDataList) {
                var pointData = this.pointDataList[i];
                if (!pointData.hasData()) {
                    this.loadDataCalls++;
                    pointData.loadData(this);
                }
                if (this.loadDataCalls == 0) {
                    this.initData();
                }
            }
            //TODO: notify display
        }
    });
}





/*
  This class defines the metadata for a record column. 
  index - the index i the data array
  id - string id
  label - string label to show to user
  type - for now not used but once we have string or other column types we'll need it
  missing - the missing value forthis field. Probably not needed and isn't used
  as I think RAMADDA passes in NaN
  unit - the unit of the value
*/
function RecordField(props, source) {
    $.extend(this, {
        isDate: props.type == "date",
        isLatitude: false,
        isLongitude: false,
        isElevation: false,
	forDisplay:true
    });
    $.extend(this, props);

    $.extend(this, {
        isGroup:props.group,
        properties: props
    });


    //check for extended attributes
    if(source && source.getProperty) {
	["type","label","unit"].forEach(t=>{
	    let ext = source.getProperty(props.id+"." + t);
	    if(ext) this[t] = ext;
	});
    }
    RamaddaUtil.defineMembers(this, {
	clone: function() {
	    var newField = {};
	    $.extend(newField,this);
	    return newField;
	},
	toString: function() {
	    if(this.group)
		return this.getId();
	    return this.getId();
	},
	getForDisplay: function() {
	    return this.forDisplay;
	},
        getIndex: function() {
            return this.index;
        },
        getValue: function(record,dflt) {
	    let v;
	    if(record.getValue)
		v= record.getValue(this.index);
	    else
		v = record[this.index];
	    if(!v && !Utils.isDefined(v)) return dflt;
	    return v;
        },
	getGroup: function() {
	    return this.group;
	},
        getEnumeratedValues: function(row) {
	    return this.enumeratedValues;
	},
        isFieldGroup: function() {
            return this.isGroup;
        },
	isRecordDate: function() {
	    return this.getId()=="recordDate";
	},
        isFieldGeo: function() {
            return this.isFieldLatitude() || this.isFieldLongitude() || this.isFieldElevation();
        },
        isFieldLatitude: function() {
            return this.isLatitude || this.id.toLowerCase() == "latitude";
        },
        isFieldLongitude: function() {
            return this.isLongitude || this.id.toLowerCase() == "longitude";
        },
        isFieldElevation: function() {
            return this.isElevation || this.id.toLowerCase() == "elevation" || this.id.toLowerCase() == "altitude";
        },
        isFieldNumeric: function() {
            return this.isNumeric();
        },
        isFieldString: function() {
            return this.type == "string" || this.type == "enumeration" || this.type == "multienumeration";
        },
        isFieldEnumeration: function() {
            return this.type == "enumeration" || this.type == "multienumeration";
        },
        isFieldMultiEnumeration: function() {
            return  this.type == "multienumeration";
        },	
        isFieldDate: function() {
            return this.isDate;
        },
        isChartable: function() {
            return this.chartable;
        },
        getSortOrder: function() {
            return this.sortorder;
        },
        getId: function() {
            return this.id;
        },
        getTypeLabel: function() {
            var type = "fa-font";
            if(this.isFieldGeo()) {
                type="fa-globe";
            } else if(this.isFieldNumeric()) {
                type="fa-hashtag";
            } else if(this.isFieldEnumeration()) {
                type="fa-list";
            }
            var tt = this.getType();
            return  HtmlUtils.span(["title",tt,"class","fa " +type,"style","color:rgb(169, 169, 169);font-size:12pt;"]);
        },
        getUnitLabel: function() {
            return this.getLabel() + this.getUnitSuffix();
        },
        getUnitSuffix: function() {
            if (this.unit && this.unit != "")
                return "&nbsp;[" + this.unit + "]";
            return "";
        },

        getLabel: function() {
            if (this.label == null || this.label.length == 0) return this.id;
            return this.label;
        },
        setLabel: function(l) {
            this.label = l;
        },
	canEdit: function() {
	    return this.canedit==true;
	},
        isNumeric: function() {
	    return this.type == "double" || this.type == "integer";
	},
	isString: function() {
	    return this.type == "string" || this.isFieldEnumeration() || this.type =="url" || this.type == "image";
	},
        getType: function() {
            return this.type;
        },
        setType: function(t) {
            this.type = t;
        },	
        getMissing: function() {
            return this.missing;
        },
        setUnit: function(u) {
            this.unit = u;
        },
        getUnit: function() {
            return this.unit;
        }
    });

}



/*
  The main data record. This holds a lat/lon/elevation, time and an array of data
  The data array corresponds to the RecordField fields
*/
function PointRecord(fields,lat, lon, elevation, time, data, rowIdx) {
    this.isPointRecord = true;
    $.extend(this, {
	rowIndex:rowIdx,
	fields:fields,
        latitude: lat,
        longitude: lon,
        elevation: elevation,
        recordTime: time,
        data: data,
	id: HtmlUtils.getUniqueId(),
    });
    if(!time && data) {
	data.every(d=>{
	    if(d && d.getTime) {
		this.recordTime = d;
		return false;
	    }
	    return true;
	});
    }
}


PointRecord.prototype =  {
    clone: function() {
	var newRecord = {};
	$.extend(newRecord,this);
	newRecord.data = [];
	this.data.map((v,idx)=>{newRecord.data[idx] = v;});
	return newRecord;
    },
    isHighlight: function(display) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	return this.highlightForDisplay[display];
    },
    getDisplayProperty: function(display,prop,dflt) {
	if(!this.displayProperties) this.displayProperties={};
	let props = this.displayProperties[display];
	if(!props) {
	    props = this.displayProperties[display] = {};
	}
	return props[prop] || dflt;
    },
    setDisplayProperty: function(display,prop,value) {
	if(!this.displayProperties) this.displayProperties={};
	let props = this.displayProperties[display];
	if(!props) {
	    props = this.displayProperties[display] = {};
	}
	props[prop] =value;
    },
    setHighlight:function(display, value) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	if(!value || this.highlightForDisplay[display] == null) {
	    this.highlightForDisplay[display] = value;
	}
    },
    clearHighlight:function(display) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	delete this.highlightForDisplay[display];
    },
    toString: function() {
	return "data:"  + this.data;
    },
    getId: function() {
	return this.id;
    },
    getData: function() {
        return this.data;
    },
    setData: function(d) {
        this.data = d;
    },    
    getValueFromField:function(id) {
	let value = null;
	this.fields.every(field=>{
	    if(field.getId()==id) {
		value = this.getValue(field.getIndex());
		return false;
	    }
	    return true;
	});
	return value;
    },

    allZeros: function() {
        var tuple = this.getData();
        var allZeros = false;
        var nums = 0;
        var nonZero = 0;
        for (var j = 0; j < tuple.length; j++) {
            if (typeof tuple[j] == "number") {
                nums++;
                if (!isNaN(tuple[j]) && tuple[j] != 0) {
                    nonZero++;
                    break;
                }
            }
        }
        if (nums > 0 && nonZero == 0) {
            return true;
        }
        return false;
    },
    getValue: function(index) {
        return this.data[index];
    },
    setValue: function(index,value) {
        this.data[index] = value;
    },
    push: function(v) {
        this.data.push(v);
    },
    hasDate: function() {
	return this.getDate()!=null;
    },
    hasLocation: function() {
        return this.latitude !=null && !isNaN(this.latitude);
    },
    hasElevation: function() {
        return this.elevation !=null && !isNaN(this.elevation);
    },
    setLocation: function(lat,lon) {
	this.latitude=lat;
	this.longitude=lon;
    },
    getLatitude: function() {
        return this.latitude;
    },
    getLongitude: function() {
        return this.longitude;
    },
    getTime: function() {
        return this.recordTime;
    },
    getElevation: function() {
        return this.elevation;
    },
    getDate: function() {
        return this.recordTime;
    }
};


function makePointData(json, derived, source,url) {
    let debug  =false;
    if(debug) console.log("makePointData");
    var fields = [];
    var latitudeIdx = -1;
    var longitudeIdx = -1;
    var elevationIdx = -1;
    var dateIdx = -1;
    var dateIndexes = [];

    var offsetFields = [];
    var lastField = null;
    for (var i = 0; i < json.fields.length; i++) {
        var field = json.fields[i];
        var recordField = new RecordField(field,source);
        if (recordField.isFieldNumeric()) {
            if (source.getProperty) {
                var offset1 = source.getProperty(recordField.getId() + ".offset1", source.getProperty("offset1"));
                var offset2 = source.getProperty(recordField.getId() + ".offset2", source.getProperty("offset2"));
                var scale = source.getProperty(recordField.getId() + ".scale", source.getProperty("scale"));

                if (offset1 || offset2 || scale) {
                    var unit = source.getProperty(recordField.getId() + ".unit", source.getProperty("unit"));
                    if (unit) {
                        recordField.unit = unit;
                    }
                    var o = {
                        offset1: 0,
                        offset2: 0,
                        scale: 1
                    };
                    if (offset1) o.offset1 = parseFloat(offset1);
                    if (offset2) o.offset2 = parseFloat(offset2);
                    if (scale) o.scale = parseFloat(scale);
                    recordField.offset = o;
                    offsetFields.push(recordField);
                }
            }
        }


        lastField = recordField;
        fields.push(recordField);
        //        console.log("field:" + recordField.getId());
        if (recordField.isFieldLatitude()) {
            latitudeIdx = recordField.getIndex();
        } else if (recordField.isFieldLongitude()) {
            longitudeIdx = recordField.getIndex();
            //            console.log("Longitude idx:" + longitudeIdx);
        } else if (recordField.isFieldElevation()) {
            elevationIdx = recordField.getIndex();
            //            console.log("Elevation idx:" + elevationIdx);
        } else if (recordField.isFieldDate()) {
	    dateIdx = recordField.getIndex();
	    dateIndexes.push(dateIdx);
        }

    }

    if (derived) {
        var index = lastField.getIndex() + 1;
        for (var dIdx = 0; dIdx < derived.length; dIdx++) {
            var d = derived[dIdx];
            var label = d.label || d.name;
            var recordField = new RecordField({
                type: "double",
                index: (index + dIdx),
                chartable: true,
                id: d.name,
                label: label,
            });
            recordField.derived = d;
            fields.push(recordField);
        }
    }

    let pointRecords = [];
    let isArray = false;
    let hasGeo = false;
    let hasDate = false;
    let setDateFlags = false;
    let dateIsString = false;
    json.data.forEach((tuple,rowIndex)=>{
	//	if(rowIndex>100) return;
	if(debug && rowIndex>0 && (rowIndex%10000)==0) console.log("\tprocessed:" + i);
	if(rowIndex==0) {
	    isArray = Array.isArray(tuple);
	    hasDate = !(typeof tuple.date === 'undefined');
	}
	let values;
	if(isArray)
	    values = tuple;
	else
            values = tuple.values;

        //lat,lon,alt,time,data values
        let date = null;
        if (isArray || !hasDate) {
            if (dateIdx >= 0) {
		if(!setDateFlags) {
		    dateIsString = (typeof values[dateIdx] == "string");
		    setDateFlags = true;
		}
		if(dateIsString) {
		    date = Utils.parseDate(values[dateIdx]);
		} else {
		    date = new Date(0);
		    date.setUTCMilliseconds(values[dateIdx]);
		}
            }
        } else {
            if (tuple.date != null && tuple.date != 0) {
		date = new Date(0);
		date.setUTCMilliseconds(tuple.date);
            }
        }
        if (isArray || (typeof tuple.latitude === 'undefined')) {
            if (latitudeIdx >= 0)
                tuple.latitude = values[latitudeIdx];
            else
                tuple.latitude = NaN;
        }
        if (isArray || (typeof tuple.longitude === 'undefined')) {
            if (longitudeIdx >= 0)
                tuple.longitude = values[longitudeIdx];
            else
                tuple.longitude = NaN;
        }
        for (var j = 0; j < dateIndexes.length; j++) {
	    let index = dateIndexes[j];
	    let value = values[index];
	    values[index] = Utils.parseDate(value);
        }
        for (var col = 0; col < values.length; col++) {
            if(values[col]==null) {
                values[col] = NaN;
            } 
        }

        if (derived) {
            for (var dIdx = 0; dIdx < derived.length; dIdx++) {
                var d = derived[dIdx];
                if (!d.isRow) {
                    continue;
                }
                if (!d.compiledFunction) {
                    var funcParams = [];
                    var params = (d.columns.indexOf(";") >= 0 ? d.columns.split(";") : d.columns.split(","));
                    d.fieldsToUse = [];
                    for (var i = 0; i < params.length; i++) {
                        var param = params[i].trim();
                        funcParams.push("v" + (i + 1));
                        var theField = null;
                        for (var fIdx = 0; fIdx < fields.length; fIdx++) {
                            var f = fields[fIdx];
                            if (f.getId() == param) {
                                theField = f;
                                break;
                            }
                        }
                        d.fieldsToUse.push(theField);

                    }
                    var code = "";
                    for (var i = 0; i < funcParams.length; i++) {
                        code += "var v" + (i + 1) + "=args[" + i + "];\n";
                    }
                    let tmpFunc = d["function"];
                    if (tmpFunc.indexOf("return") < 0) tmpFunc = "return " + tmpFunc;
                    code += tmpFunc + "\n";
                    d.compiledFunction = new Function("args", code);
                    //                    console.log("Func:" + d.compiledFunction);
                }
                //TODO: compile the function once and call it
                var args = [];
                var anyNotNan = false;
                for (var fIdx = 0; fIdx < d.fieldsToUse.length; fIdx++) {
                    var f = d.fieldsToUse[fIdx];
                    var v = NaN;
                    if (f != null) {
                        v = values[f.getIndex()];
                        if (v == null) v = NaN;
                    }
                    if (!isNaN(v)) {
                        anyNotNan = true;
                    } else {}
                    args.push(v);
                }
                //                console.log("anyNot:" + anyNotNan);
                //                console.log(args);
                try {
                    var result = NaN;
                    if (anyNotNan) {
                        result = d.compiledFunction(args);
                        if (d.decimals >= 0) {
                            result = result.toFixed(d.decimals);
                        }
                        result = parseFloat(result);
                    } else {
                        //                        console.log("NAN");
                    }
                    //                    console.log("in:" + result +" out: " + result);
                    values.push(result);
                } catch (e) {
                    console.log("Error evaluating function:" + d["function"] + "\n" + e);
                    values.push(NaN);
                }
            }
	}

        for (var fieldIdx = 0; fieldIdx < offsetFields.length; fieldIdx++) {
            var field = offsetFields[fieldIdx];
            var offset = field.offset;
            var value = values[field.getIndex()];
            value = (value + offset.offset1) * offset.scale + offset.offset2;
            values[field.getIndex()] = value;
        }

        var record = new PointRecord(fields, tuple.latitude, tuple.longitude, tuple.elevation, date, values,rowIndex);
        pointRecords.push(record);

    });


    if (source != null) {
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var prefix = "field." + field.getId() + ".";
            if (Utils.isDefined(source[prefix + "unit"])) {
                field.setUnit(source[prefix + "unit"]);
            }
            if (Utils.isDefined(source[prefix + "label"])) {
                field.setLabel(source[prefix + "label"]);
            }
            if (Utils.isDefined(source[prefix + "scale"]) || Utils.isDefined(source[prefix + "offset1"]) || Utils.isDefined(source[prefix + "offset2"])) {
                var offset1 = Utils.isDefined(source[prefix + "offset1"]) ? parseFloat(source[prefix + "offset1"]) : 0;
                var offset2 = Utils.isDefined(source[prefix + "offset2"]) ? parseFloat(source[prefix + "offset2"]) : 0;
                var scale = Utils.isDefined(source[prefix + "scale"]) ? parseFloat(source[prefix + "scale"]) : 1;
                var index = field.getIndex();
                for (var rowIdx = 0; rowIdx < pointRecords.length; rowIdx++) {
                    var record = pointRecords[rowIdx];
                    var values = record.getData();
                    var value = values[index];
                    values[index] = (value + offset1) * scale + offset2;
                }
            }

        }
    }

    var name = json.name;
    if ((typeof name === 'undefined')) {
        name = "Point Data";
    }

    pointRecords.sort(function(a, b) {
        if (a.getDate() && b.getDate()) {
            if (a.getDate().getTime() < b.getDate().getTime()) return -1;
            if (a.getDate().getTime() > b.getDate().getTime()) return 1;
            return 0;
        }
    });

    let pd =  new PointData(name, fields, pointRecords,url);
    return pd;
}



function BaseFilter(display,properties) {
    this.display = display;
    if (properties == null) properties = {};
    RamaddaUtil.defineMembers(this, {
        properties: properties,
	isEnabled: function() {
	    return true;
	},
	prepareToFilter: function() {
	},
        isRecordOk: function(display, record, values) {
            return true;
        },
	getWidget: function() {return ""},
	initWidget: function(inputFunc) {}
    });
}



function BoundsFilter(display, properties) {
    RamaddaUtil.inherit(this, new BaseFilter(display, properties));
    $.extend(this, {
	enabled:true,
	getWidget: function() {
	    let id = this.display.getDomId("boundsfilter");
	    return HtmlUtils.span([STYLE,HU.css("margin-left","4px","margin-right","4px"), ID,id,CLASS,"ramadda-clickable", TITLE,"Filter records on map view. Shift-click to clear"], HtmlUtils.getIconImage("fas fa-globe-americas"));
	},
	initWidget: function(inputFunc) {
	    this.inputFunc = inputFunc;
	    let id = this.display.getDomId("boundsfilter");
	    let _this = this;
	    this.display.jq("boundsfilter").click(function(event){
		if (event.shiftKey) {
		    if(!_this.bounds) return;
		    _this.bounds = null;
		} else {
		    _this.bounds = _this.display.getBounds();
		}
		inputFunc($(this),null,_this.bounds);
	    });
	},
	isRecordOk: function(record) {
	    if(!this.bounds) {
		return true;
	    }
	    if(record.hasLocation()) {
		var b = this.bounds;
		var lat = record.getLatitude();
		var lon = record.getLongitude();
		if(lat>b.top || lat<b.bottom || lon <b.left || lon>b.right)
		    return false;
	    }
            return true;
	},
    });
}


function RecordFilter(display,filterFieldId, properties) {
    const ID_TEXT = "_text_";
    this.id = filterFieldId;
    this.isText = this.id == ID_TEXT;
    let fields;
    if(this.isText) {
	fields = display.getFieldsByType(null, "string");
    } else {
	let filterField = display.getFieldById(null, filterFieldId);
	if(filterField)
	    fields = [filterField];
	else {
	    console.warn("Error: could not find filter field::" + filterFieldId);
	    display.getFieldById(null, filterFieldId);
	    fields = [];
	}
    }
    $.extend(this, new BaseFilter(display, properties));
    this.getId = function() {
	return this.id;
    }
    let getAttr = (suffix,dflt)=>{
	let key = this.getId()+"." + suffix;
	let v = display.getProperty(key,dflt);
	return v;
    };
    let label = "";
    if(this.isText)  {
	label = getAttr("filterLabel","Text");
    } else  {
	label = getAttr("filterLabel",fields.length>0?fields[0].getLabel():"");
    }
    $.extend(this, {
	fields: fields,
	values:[],
	hideFilterWidget: display.getProperty("hideFilterWidget",false, true),
	displayType:getAttr("filterDisplay","menu"),
	label:   label,
	suffix:  getAttr("filterSuffix",""),
	depends: getAttr("filterDepends",null),
	dateIds: [],
	prefix:display.getProperty(this.getId() +".filterPrefix"),
	suffix:display.getProperty(this.getId() +".filterSuffix"),
	startsWith:display.getProperty(this.getId() +".filterStartsWith",false),
	ops:Utils.split(display.getProperty(this.getId() +".filterOps"),";",true,true),
	labelField:display.getFieldById(null,display.getProperty(this.getId() +".labelField"))
    });


    if(this.ops) {
	let tmp = [];
	this.ops.forEach(tok=>{
	    let tuple  = tok.split(",");
	    tmp.push({
		op: tuple[0],
		value: tuple[1],
		label: tuple[2]||this.id+tuple[0] +tuple[1]
	    });
	});
	this.ops = tmp;
    }

    $.extend(this, {
	toString:function() {
	    return "filter:" + this.getId();
	},
	getField: function() {
	    return this.fields[0];
	},
	getFieldId: function() {
	    return this.fields[0].getId();
	},	
	getLabel: function() {
	    return this.label;
	},

	getValue: function(record) {
	    if(this.fields.length==1) {
		return record.getValue(this.fields[0].getIndex());
	    } else {
		let v = this.fields.reduce((acc,field)=>{
		    return acc+=" " + record.getValue(field.getIndex());
		},"");
		return v;
	    }
	},
	isFieldNumeric:function() {
	    return this.getField().isNumeric();
	},
	isFieldEnumeration: function() {
	    return this.getField().isFieldEnumeration();
	},
	isFieldMultiEnumeration: function() {
	    return this.getField().isFieldMultiEnumeration();
	},
	getFieldType: function() {
	    return this.getField().getType();
	},
	getFilterId: function(id) {
	    return  this.display.getDomId("filterby_" + (id||this.getId()));
	},
	isEnabled: function() {
	    return this.isText || this.getField()!=null;
	},
	recordOk: function(display, record, values) {
            return true;
        },
	getProperty: function(key, dflt) {
	    return this.display.getProperty(key, dflt);
	},
	getPropertyFromUrl: function(key, dflt) {
	    return this.display.getPropertyFromUrl(key, dflt);
	},	
	prepareToFilter: function() {
	    this.mySearch = null;
	    if(this.depend) {
		this.checkDependency();
	    }
	    if(!this.isEnabled()) {
		return;
	    }
	    //	    if (prefix) pattern = prefix + value;
	    //	    if (suffix) pattern = value + suffix;
	    let value=null;
	    let _values =[];
	    let values=null;
	    let matchers =[];
	    if(this.ops) {
		let v = $("#" + this.getFilterId(this.getId())).val();
		if(v==FILTER_ALL) {
		    this.mySearch = null;
		    return;
		}
		this.mySearch =  {
		    index: parseFloat(v)
		};
		return;
	    } else  if(this.isFieldNumeric()) {
		let minField = $("#" + this.display.getDomId("filterby_" + this.getId()+"_min"));
		let maxField = $("#" + this.display.getDomId("filterby_" + this.getId()+"_max"));
		if(!minField.val() || !maxField.val()) return;
		let minValue = parseFloat(minField.val().trim());
		let maxValue = parseFloat(maxField.val().trim());
		let dfltMinValue = parseFloat(minField.attr("data-min"));
		let dfltMaxValue = parseFloat(maxField.attr("data-max"));
		if(minValue!= dfltMinValue || maxValue!= dfltMaxValue) {
		    value = [minValue,maxValue];
		}
 	    } else if(this.getFieldType()=="date"){
		let date1 = $("#" + this.display.getDomId("filterby_" + this.getId()+"_date1")).val();
		let date2 = $("#" + this.display.getDomId("filterby_" + this.getId()+"_date2")).val();
		if(date1!=null && date1.trim()!="") 
		    date1 =  Utils.parseDate(date1);
		else
		    date1=null;
		if(date2!=null && date2.trim()!="") 
		    date2 =  Utils.parseDate(date2);
		else
		    date2=null;
		if(date1!=null || date2!=null)
		    value = [date1,date2]; 
	    }  else {
		values = this.getFieldValues();
		if(!values) return;
		if(!Array.isArray(values)) values = [values];
		if(values.length==0) return;
		values = values.map(v=>{
		    return v.replace(/_comma_/g,",");
		});
		values.forEach(v=>{
		    _values.push((""+v).toLowerCase());
		    try {
			matchers.push(new TextMatcher(v));
		    } catch(skipIt){}
		});
	    }
	    let anyValues = value!=null;
	    if(!anyValues && values) {
		values.forEach(v=>{if(v.length>0 && v!= FILTER_ALL)anyValues = true});
	    }
	    if(anyValues) {
		this.mySearch =  {
		    value:value,
		    values:values,
		    matchers:matchers,
		    _values:_values,
		    anyValues:anyValues,
		};
	    } else {
		this.mySearch = null;
	    }
//	    console.log(this +"prepare:" + JSON.stringify(this.mySearch));
	},
	isRecordOk:function(record,debug) {
	    let ok = true;
	    if(!this.isEnabled() || !this.mySearch) {
		if(debug) {
		    if(!this.isEnabled())
			console.log("\tfilter  not enabled");
		    if(!this.mySearch)
			console.log("\tfilter  no mySearch");
		}
		return ok;
	    }
	    if(debug) console.log("\tfilter.isRecordOk:" + JSON.stringify(this.mySearch));
	    let rowValue = this.getValue(record);
	    if(this.ops) {
		let op = this.ops[this.mySearch.index];
		if(op.op=="<") ok =  rowValue<op.value;
		else if(op.op=="<=") ok = rowValue<=op.value;
		else if(op.op==">") ok= rowValue>op.value;
		else if(op.op==">=") ok= rowValue>=op.value;
		else if(op.op=="==") ok= rowValue==op.value;				
	    } else   if(this.isFieldEnumeration()) {
		rowValue=String(rowValue);
		if(this.isFieldMultiEnumeration()) {
 		    ok = false;
		    let values = rowValue.split(",");
		    values.forEach(value=>{
			value=value.trim();
			if(this.mySearch.values.includes(value)) ok = true;
		    });
//		    console.log(this.mySearch.values);
		    
		} else {
		    ok = this.mySearch.values.includes(rowValue);
		}
	    } else if(this.isFieldNumeric()) {
		if(isNaN(this.mySearch.value[0]) && isNaN(this.mySearch.value[1])) return ok;
		if(isNaN(rowValue) || rowValue=="")  ok =false;
		else if(!isNaN(this.mySearch.value[0]) && rowValue<this.mySearch.value[0]) ok = false;
		else if(!isNaN(this.mySearch.value[1]) && rowValue>this.mySearch.value[1]) ok = false;
	    } else if(this.getFieldType()=="date"){
		if(this.mySearch.value &&  Array.isArray(this.mySearch.value)) {
		    if(rowValue == null) {
			ok = false;
		    }  else  {
			let date1 = this.mySearch.value[0];
			let date2 = this.mySearch.value[1];
			let dttm = rowValue.getTime();
			if(isNaN(dttm)) ok = false;
			else if(date1 && dttm<date1.getTime())
			    ok = false;
			else if(date2 && dttm>date2.getTime())
			    ok = false;
		    }
		}
	    } else {
		let startsWith = this.startsWith;
		ok = false;
		rowValue  = String(rowValue).toLowerCase();

		for(let j=0;j<this.mySearch._values.length;j++) {
		    let fv = this.mySearch._values[j];
		    if(startsWith) {
			if(rowValue.toString().startsWith(fv)) {
			    ok = true;
			    break;
			}
		    } else  if(rowValue.toString().indexOf(fv)>=0) {
			ok = true;
			break;
		    }
		}
		
		if(!ok && !startsWith) {
		    for(ri=0;ri<this.mySearch.matchers.length;ri++) {
			let matcher = this.mySearch.matchers[ri];
			if(matcher.matches(rowValue.toString())) {
			    ok = true;
			    break;
			}
		    }
		}
	    }
	    return ok;
	},

	doTags:function() {
	    if(!this.getProperty(this.getId()+".showFilterTags",true)) return false;
	    let tags =  this.getProperty(this.getId()+".showFilterTags") || this.getProperty("showFilterTags");
	    return tags;
	},
	doTagsColor:function() {
	    if(!this.getProperty(this.getId()+".colorFilterTags",true)) return false;
	    let tags =  this.getProperty(this.getId()+".colorFilterTags", true) || this.getProperty("colorFilterTags");
	    return tags;
	},

	getFieldValues: function() {
	    if(this.isFieldEnumeration()) {
		if(this.doTags()) {
		    return this.selectedTags ||[];
		}
	    }
	    let element =$("#" + this.display.getDomId("filterby_" + this.getId()));
	    let value=null;
	    if(element.attr("isCheckbox")) {
		if(element.is(':checked')) {
		    value = element.attr("onValue");
		} else {
		    value = element.attr("offValue");
		}
	    } else if(element.attr("isButton")) {
		value = element.attr("data-value");
	    } else {
		value = element.val();
	    }
	    if(!value) {
		if(this.defaultValue) value = this.defaultValue;
		else value = FILTER_ALL;
	    }
	    if(!Array.isArray(value)) {
		if(!this.isFieldEnumeration()) {
		    value = value.split(",");
		} else {
		    value = [value];
		}
	    }
	    let tmp = [];
	    value.forEach(v=>tmp.push(v.trim()));
	    value = tmp;
	    return value;
	},
	toggleTag:function(value,on,cbx, propagateEvent) {
	    let _this = this;
	    let type  = this.getFilterId();
	    let tagId = Utils.makeId(type +"_" +  value);

	    if(on) {
		if(this.selectedTags.includes(value)) return;
		this.selectedTags = Utils.addUnique(this.selectedTags,value);
		let tagGroup = this.display.jq(ID_TAGBAR).find(".tag-group" +HU.attrSelect("tag-type",this.getFilterId()));
		if(tagGroup.length==0) {
		    let bar;
		    if(this.display.getProperty("tagDiv"))
			bar= $("#"+this.display.getProperty("tagDiv"));
		    else
			bar= this.display.jq(ID_TAGBAR);
		    tagGroup = $(HU.div([STYLE,HU.css("display","inline-block"), CLASS,"tag-group","tag-type",this.getFilterId()])).appendTo(bar);
		}
		
		let tag = $(HU.div(["metadata-type",type,"metadata-value",value,TITLE,value, STYLE, HU.css("background", Utils.getEnumColor(this.getFieldId())),CLASS,"display-search-tag", ID,tagId],value+SPACE +HU.getIconImage("fas fa-times"))).appendTo(tagGroup);
		tag.click(function(){
		    _this.selectedTags = Utils.removeElement(_this.selectedTags,value);
		    if(cbx)
			cbx.prop('checked',false);
		    $(this).remove();
		    _this.inputFunc(_this.fakeInput,null,_this.selectedTags);
		});
	    } else {
		this.selectedTags = Utils.removeElement(this.selectedTags,value);
		$("#" + tagId).remove();
	    }
	    if(propagateEvent && this.inputFunc) {
		this.inputFunc(this.fakeInput,null,this.selectedTags);
	    }
	},
	    
	initWidget: function(inputFunc) {
	    if(!this.isEnabled()) return;
	    this.inputFunc = inputFunc;
	    this.fakeInput  = {
		attr:function(key) {
		    return this[key];
		},
		val: function() {return null},
		id: this.getId(),
		fieldId:this.getFieldId()
	    };

	    this.initDateWidget(inputFunc);
//	    this.display.selectboxit($("#" + this.widgetId));
	    if(this.tagCbxs) {
		let _this = this;
		let cbxChange = function() {
        	    let cbx = $(this);
	            let on = cbx.is(':checked');
		    let value  = $(this).attr("metadata-value");
		    _this.toggleTag(value,on,cbx,true);
		}
		let clickId = this.getFilterId()+"_popup";
		$("#" + clickId).click(()=>{
		    let dialog = this.display.createTagDialog(this.tagCbxs, $("#" + clickId), cbxChange, this.getFilterId(),this.getLabel());
		    dialog.find(".metadata-cbx").each(function() {
			let value = $(this).attr('metadata-value');
			$(this).prop('checked',_this.selectedTags.includes(value));
		    });
		});
	    }

	},
	initDateWidget: function(inputFunc) {
	    if(!this.hideFilterWidget) {
		for(let i=0;i<this.dateIds.length;i++) {
		    let id = this.dateIds[i];
		    HtmlUtils.datePickerInit(id);
		    $("#" + id).change(function(){
			inputFunc($(this));
		    });
		}
	    }
	},
	checkDependency: function() {
	    if(!this.depend || !this.records || !this.dependMySearch || !this.depend.mySearch || !this.dependMySearch.values || !this.depend.mySearch.values) {
		console.log("no depend:" + this.depend +" " + (this.records!=null) + " " + this.dependMySearch);
		return;
	    }

	    let v1 = this.dependMySearch.values;
	    let v2 = this.depend.mySearch.values;
	    if(v1.length == v2.length) {
		let equals = true;
		for(let i=0;i<v1.length && equals;i++)
		    equals = v1[i] == v2[i];
		if(equals) return;
	    }
            let enums = this.getEnums(this.records);
	    let widgetId = this.getFilterId(this.getId());
	    let tmp = [];
	    enums.map(e=>tmp.push(e.value));
	    this.display.ignoreFilterChange = true;
	    let widget = $("#" + widgetId);
	    let val = widget.val();
	    if(!val) val  = 	widget.attr("data-value");
	    widget.html(HU.makeOptions(tmp,val));
	    this.display.ignoreFilterChange = false;
	},
	handleEventPropertyChanged:function(prop) {
	    if(this.isFieldEnumeration() && this.doTags()) {
		if(this.selectedTags) {
		    let type  = this.getFilterId();
		    this.selectedTags.forEach(value=>{
			let tagId = Utils.makeId(type +"_" +  value);	
			$("#" + tagId).remove();
		    });
		}
		this.selectedTags = [];
		prop.value.forEach(value=>{
		    this.toggleTag(value,true);
		});
		return;
	    }


	    let id = this.widgetId;
	    if(prop.id && prop.id.endsWith("date1")) {
		id+="_date1";
	    } else 	if(prop.id && prop.id.endsWith("date2")) {
		id+="_date2";
	    }

	    let widget = $("#"+id);
	    if(widget.attr("isCheckbox")) {
		let on = widget.attr("onValue");
		widget.prop('checked',prop.value.includes(on));
	    } else {
		widget.val(prop.value);
	    }
	    widget.attr("data-value",prop.value);
	    if(widget.attr("isButton")) {
		widget.find(".display-filter-button").removeClass("display-filter-button-selected");
		widget.find("[value='" + prop.value +"']").addClass("display-filter-button-selected");
	    }
	},
	getWidget: function(fieldMap, bottom,records, vertical) {
	    this.records = records;
	    let debug = false;
	    if(debug) console.log(this.id +".getWidget");
	    if(!this.isEnabled()) {
		if(debug) console.log("\tnot enabled");
		return "";
	    }
	    let widgetStyle = "";
	    if(this.hideFilterWidget)
		widgetStyle = "display:none;";
	    fieldMap[this.getId()] = {
		field: this.fields[0],
		values:[],
	    };
	    let showLabel = true;
            let widget;
	    let widgetId = this.widgetId = this.getFilterId(this.getId());
	    let widgetLabel =   this.getProperty(this.getId()+".filterLabel",this.getLabel());
	    let suffix =   this.getProperty(this.getId()+".filterSuffix","");

            if(this.ops) {
		let labels =[];
		this.ops.forEach((op,idx)=>{
		    labels.push([String(idx),op.label]);
		});

		let selected = this.getPropertyFromUrl(this.getId() +".filterValue",FILTER_ALL);
		let showLabel = this.getProperty(this.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true));
		let allName = this.getProperty(this.getId() +".allName",!showLabel?this.getLabel():"All");
		let enums = Utils.mergeLists([[FILTER_ALL,allName]],labels);
		let attrs= [STYLE,widgetStyle, ID,widgetId,"fieldId",this.getId()];
		widget = HU.select("",attrs,enums,selected);
	    } else   if(this.isFieldEnumeration()) {
		if(debug) console.log("\tis enumeration");
		let dfltValue = this.defaultValue = this.getPropertyFromUrl(this.getId() +".filterValue",FILTER_ALL);
                let enums = this.getEnums(records);
		let attrs= ["style",widgetStyle, "id",widgetId,"fieldId",this.getId()];
		if(this.getProperty(this.getId() +".filterMultiple",false)) {
		    attrs.push("multiple");
		    attrs.push("");
		    attrs.push("size");
		    attrs.push(this.getProperty(this.getId() +".filterMultipleSize","3"));
		    dfltValue = dfltValue.split(",");
		}

		if(this.displayType!="menu") {
		    if(debug) console.log("\tnot menu");
		    let includeAll = this.getProperty(this.getId() +".includeAll",this.getProperty("filter.includeAll", true));
		    if(!includeAll && dfltValue == FILTER_ALL) dfltValue = enums[0].value;
		    let buttons = "";
		    let colorMap = Utils.parseMap(this.getProperty(this.getId() +".filterColorByMap"));
		    let useImage = this.displayType == "image";
		    let imageAttrs = [];
		    let imageMap = Utils.getNameValue(this.getProperty(this.getId() +".filterImages"));
		    if(useImage) {
			let w = this.getProperty(this.getId() +".filterImageWidth");
			let h = this.getProperty(this.getId() +".filterImageHeight");
			if(h) {
			    imageAttrs.push("height");
			    imageAttrs.push(h);
			}
			if(w) {
			    imageAttrs.push("width");
			    imageAttrs.push(w);
			}
			if(!h && !w) {
			    imageAttrs.push("width");
			    imageAttrs.push("50");
			}
			
			imageAttrs.push("style");
			imageAttrs.push(this.getProperty(this.getId() +".filterImageStyle","border-radius:50%;"));
		    }
		    for(let j=0;j<enums.length;j++) {
			let extra = "";
			let v = enums[j].value;
			let color = colorMap?colorMap[v]:null;
			let label;
			if(Array.isArray(v)) {
			    label = v[1];
			    v = v[0];
			} else {
			    label = v;
			}

			let style = this.getProperty(this.getId() +".filterItemStyle","");
			if(color) {
			    style += " background-color:" + color +"; ";
			}
			
			let clazz = " display-filter-item display-filter-item-" + this.displayType +" ";
			if(v == dfltValue) {
			    clazz+=  " display-filter-item-" + this.displayType +"-selected ";
			}
			if(v == FILTER_ALL) {
			    extra = " display-filter-item-all ";
			}
			if(useImage) {
			    let image=null;
			    if(imageMap) image = imageMap[v];
			    if(!image || image=="") image = enums[j].image;
			    if(image) {
				buttons+=HtmlUtils.div(["fieldId",this.getId(),"class",clazz,"style",style, "data-value",v,"title",label],
						       HtmlUtils.image(image,imageAttrs));
			    } else {
				buttons+=HtmlUtils.div(["fieldId",this.getId(),"class",clazz,"style",style,"data-value",v,"title",label],label);
			    }
			} else {
			    buttons+=HtmlUtils.div(["fieldId",this.getId(),"class",clazz, "style",style,"data-value",v],label);
			}
			buttons+="\n";
		    }

		    if(useImage && this.getProperty(this.getId() +".filterShowButtonsLabel")) {
			buttons+=HtmlUtils.div(["class","display-filter-item-label","id",this.display.getDomId("filterby_" + this.getId() +"_label")],"&nbsp;");
		    }
		    bottom[0]+= HtmlUtils.div(["data-value",dfltValue,"class","display-filter-items","id",widgetId,"isButton","true", "fieldId",
					       this.getId()], buttons);
		    if(debug) console.log("\treturn 1");
		    return "";
		} else if(this.getProperty(this.getId() +".filterCheckbox")) {
		    if(debug) console.log("\tis checkbox");
		    attrs.push("isCheckbox");
		    attrs.push(true);
		    let tmp = [];
		    enums.map(e=>tmp.push(e.value));
		    let checked = tmp.includes(dfltValue);
		    if(tmp.length>0) {
			attrs.push("onValue");
			attrs.push(tmp[0]);
		    }
		    if(tmp.length>1) {
			attrs.push("offValue");
			attrs.push(tmp[1]);
		    }
		    widget = HtmlUtils.checkbox("",attrs,checked);
		    //			    console.log(widget);
		} else if(this.doTags()) {
		    let doColor = this.doTagsColor();
		    showLabel  =false;
		    let cbxs = [];
		    this.tagToCbx = {};
		    this.selectedTags = [];
		    enums.map((e,idx)=>{
			let count  = e.count;
			let value = e.value;
			let label = value;
			if(Array.isArray(value)) {
			    value = e.value[0];
			    label = e.value[1];
			    if(value === "")
				label = "-blank-";
			}
			let showCount  = true;
			if(count) label = label +(showCount?" (" + count+")":"");
			let cbxId = this.getFilterId() +"_cbx_" + idx;
			this.tagToCbx[value] = cbxId;
			let cbx = HU.checkbox("",[CLASS,"metadata-cbx",ID,cbxId,"metadata-type",this.getFilterId(),"metadata-value",value],false) +" " + HU.tag( "label",  [CLASS,"ramadda-noselect ramadda-clickable","for",cbxId],label);
			cbx = HU.span([CLASS,'display-search-tag','tag',label,STYLE, HU.css("background", Utils.getEnumColor(this.getFieldId()))], cbx);
			cbxs.push(cbx);
		    }); 
		    this.tagCbxs  = cbxs;
		    let clickId = this.getFilterId()+"_popup";
		    let label = " " +this.getLabel()+" ("+ cbxs.length+")";
		    label = label.replace(/ /g,"&nbsp;");
		    let style = HU.css("white-space","nowrap", "line-height","1.5em",  "margin-top","6px","padding-right","5px");
		    if(doColor)
			style+=HU.css("border","1px solid #ccc","background", Utils.getEnumColor(this.getFieldId()));
		    else
			style+=HU.css();
		    widget= HU.div([STYLE, style, TITLE,"Click to select tag", ID,clickId,CLASS,"ramadda-clickable entry-toggleblock-label"], HU.makeToggleImage("fas fa-plus","font-size:8pt;") +label);   
		} else {
		    if(debug) console.log("\tis select");
		    let tmp = [];
		    let showCount = this.getProperty(this.getId()+".filterShowCount",this.getProperty("filterShowCount",true));
		    enums.map(e=>{
			let count  = e.count;
			let v = e.value;
			let label = v;
			if(Array.isArray(v)) {
			    v = e.value[0];
			    label = e.value[1];
			    if(v === "")
				label = "-blank-";
			}
			if(count) label = label +(showCount?" (" + count+")":"");
			tmp.push([v,label]);
		    }); 
                    widget = HtmlUtils.select("",attrs,tmp,dfltValue);
		}
	    } else if(this.isFieldNumeric()) {
		if(debug) console.log("\tis numeric");
		let min=0;
		let max=0;
		let cnt=0;
		records.map(record=>{
		    let value = this.getValue(record);
		    if(isNaN(value))return;
		    if(cnt==0) {min=value;max=value;}
		    else {
			min = Math.min(min, value);
			max = Math.max(max, value);
		    }
		    cnt++;
		});
		let tmpMin = this.getPropertyFromUrl(this.getId() +".filterValueMin",this.getProperty("filterValueMin"));
		let tmpMax = this.getPropertyFromUrl(this.getId() +".filterValueMax",this.getProperty("filterValueMax"));		
		let minStyle = "";
		let maxStyle = "";
		let dfltValueMin = min;
		let dfltValueMax = max;
		if(Utils.isDefined(tmpMin)) {
		    minStyle = "background:" + TEXT_HIGHLIGHT_COLOR+";";
		    dfltValueMin = parseFloat(tmpMin);
		}
		if(Utils.isDefined(tmpMax)) {
		    maxStyle = "background:" + TEXT_HIGHLIGHT_COLOR+";";
		    dfltValueMax = parseFloat(tmpMax);
		}


                widget = HtmlUtils.input("",dfltValueMin,[STYLE,minStyle,"data-min",min,"class","display-filter-range display-filter-input","style",widgetStyle, "id",widgetId+"_min","size",3,"fieldId",this.getId()]);
		widget += "-";
                widget += HtmlUtils.input("",dfltValueMax,[STYLE,maxStyle,"data-max",max,"class","display-filter-range display-filter-input","style",widgetStyle, "id",widgetId+"_max","size",3,"fieldId",this.getId()]);
	    } else if(this.getFieldType() == "date") {
                widget =HtmlUtils.datePicker("","",["class","display-filter-input","style",widgetStyle, "id",widgetId+"_date1","fieldId",this.getId()]) +"-" +
		    HtmlUtils.datePicker("","",["class","display-filter-input","style",widgetStyle, "id",widgetId+"_date2","fieldId",this.getId()]);
		this.dateIds.push(widgetId+"_date1");
		this.dateIds.push(widgetId+"_date2");
            } else {
		let dfltValue = this.getPropertyFromUrl(this.getId() +".filterValue","");
		let width = this.getProperty(this.getId() +".filterWidth","150px");		
		let attrs =[STYLE,widgetStyle+"width:" + HU.getDimension(width), "id",widgetId,"fieldId",this.getId(),"class","display-filter-input"];
		let placeholder = this.getProperty(this.getId() +".filterPlaceholder");
		attrs.push("width");
		attrs.push(width);
		if(placeholder) {
		    attrs.push("placeholder");
		    attrs.push(placeholder);
		} else {
		    showLabel = false;
		    attrs.push("placeholder");
		    attrs.push(widgetLabel);
		}

                widget =HtmlUtils.input("",dfltValue,attrs);
		let values=fieldMap[this.getId()].values;
		let seen = {};
		records.map(record=>{
		    let value = this.getValue(record);
		    if(!seen[value]) {
			seen[value] = true;
			values.push(value);
		    }	
		});
            }
	    if(!this.hideFilterWidget) {
		let tt = widgetLabel;
		if(widgetLabel.length>50) widgetLabel = widgetLabel.substring(0,49)+"...";
		if(!this.getProperty(this.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true))) {
		    widgetLabel = "";
		}
		else
		    widgetLabel = widgetLabel+": ";
		let labelVertical = vertical || this.getProperty(this.getId()+".filterLabelVertical",false)  || this.getProperty("filterLabelVertical",false);
		widgetLabel = this.display.makeFilterLabel(widgetLabel,tt,labelVertical);
		if(labelVertical) widgetLabel = widgetLabel+"<br>";
		if(vertical) {
		    widget = HtmlUtils.div([],(showLabel?widgetLabel:"") + widget+suffix);
		} else {
		    widget = HtmlUtils.div(["style","display:inline-block;"],(showLabel?widgetLabel:"") + widget+suffix);
		}
	    }
	    if(!vertical)
		widget= widget +(this.hideFilterWidget?"":"&nbsp;&nbsp;");
	    return widget;
	},
	getEnums: function(records) {
	    let counts = {};
	    let isMulti  = this.isFieldMultiEnumeration();
	    records.forEach((record,idx)=>{
		let value = this.getValue(record);
		if(value ===null) return;
		value = String(value);
		let values = isMulti?value.split(","):[value];
		values.forEach(v=>{
		    v =v.trim ();
		    if(!counts[v]) counts[v]=1;
		    else   counts[v]++;
		});
	    });

	    let enums = null;
	    let filterValues = this.getProperty(this.getId()+".filterValues");
	    let showLabel = this.getProperty(this.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true));

	    if (filterValues) {
		let toks;
		if ((typeof filterValues) == "string") {
		    filterValues = Utils.getMacro(filterValues);
		    toks = filterValues.split(",");
		} else {
		    toks = filterValues;
		}
		enums=[];
		toks.map(tok=>{
		    let tmp = tok.split(":");
		    if(tmp.length>1) {
			tok = [tmp[0],tmp[1]];
		    } else if(tok == FILTER_ALL) {
			let allName = this.getProperty(this.getId() +".allName",!showLabel?this.getLabel():"All");
			tok = [tmp[0],allName];
		    } else {
			tok = [tok,tok];
		    }
		    let count = counts[tok[0]];
		    enums.push({value:tok,count:count});
		})
	    }
	    let includeAll = this.getProperty(this.getId() +".includeAll",this.getProperty("filter.includeAll", true));
	    if(enums == null) {
		let depend = this.getProperty(this.getId() +".depends");
		if(depend) {
		    depend=this.depend = this.display.getRecordFilter(depend);
		}
		let allName = this.getProperty(this.getId() +".allName",!showLabel?this.getLabel():"All");
		enums = [];
		if(includeAll && !this.getProperty(this.getId() +".filterLabel")) {
		    enums.push({value:[FILTER_ALL,allName]});
		}
		let seen = {};
		let dflt = this.getField().getEnumeratedValues();
		if(dflt) {
		    for(let v in dflt) {
			seen[v] = true;
			let count = counts[v];
			enums.push({value:[v,dflt[v]],count:count});
		    }
		}
		let enumValues = [];
		let imageField=this.display.getFieldByType(null, "image");
		let valuesAreNumbers = true;

		if(depend) {
		    depend.prepareToFilter();
		    this.dependMySearch = depend.mySearch;
		}


		records.forEach((record,idx)=>{
		    if(depend) {
			if(!depend.isRecordOk(record,idx<5)) return;
		    }
		    let value =this.getValue(record);
		    let values;
		    if(isMulti) {
			values = value.split(",").map(v=>{return v.trim();});
		    } else {
			values = [value];
		    }

		    values.forEach(value=>{
			if(seen[value]) return;
			seen[value]  = true;
			let obj = {};
			if(imageField)
			    obj.image = this.display.getDataValues(record)[imageField.getIndex()];
			if((+value+"") != value) valuesAreNumbers = false;
			let label = value;
			if(label.length>30) {
			    label=  label.substring(0,29)+"...";
			}
			if(this.labelField) {
			    label += " - " + this.labelField.getValue(record);
			    console.log("l:" + label);
			}


			if(typeof value == "string")
			    value = value.replace(/\'/g,"&apos;");
			let tuple = [value, label];
			obj.value = tuple;
			obj.count =  counts[value];

			enumValues.push(obj);
		    });
		});
		if(this.getProperty(this.getId() +".filterSort",true)) {
		    let sortCount = this.getProperty(this.getId() +".filterSortCount",true);
		    enumValues.sort((a,b)  =>{
			if(sortCount && a.count && b.count) {
			    if(b.count!=a.count)
				return b.count-a.count;
			}
			a= a.value;
			b = b.value;
			if(valuesAreNumbers) {
			    return +a - +b;
			}
			return (""+a[1]).localeCompare(""+b[1]);
		    });
		}
		for(let j=0;j<enumValues.length;j++) {
		    let v = enumValues[j];
		    enums.push(v);
		}
	    }
	    return enums;
	}
	
    });


    


}




function MonthFilter(param) {
    RamaddaUtil.inherit(this, new BaseFilter());
    RamaddaUtil.defineMembers(this, {
        months: param.split(","),

        recordOk: function(display, record, values) {
            for (i in this.months) {
                let month = this.months[i];
                let date = record.getDate();
                if (date == null) return false;
                if (date.getMonth == null) {
                    //console.log("bad date:" + date);
                    return false;
                }
                if (date.getMonth() == month) return true;
            }
            return false;
        }
    });
}



var ArrayUtil = {
    add: function(v1, v2) {
        if (isNaN(v1) || isNaN(v2)) return NaN;
        return v1 + v2;
    },
    average: function(values) {
        var sum = 0;
        if (values.length == 0) return 0;
        for (var i = 0; i < values.length; i++) {
            sum += values[i];
        }
        return sum / values.length;
    },
    percentIncrease: function(values) {
        var percents = [];
        var sum = 0;
        if (values.length == 0) return 0;
        var lastValue;
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            var incr = NaN;
            if (i > 0 && lastValue != 0) {
                incr = (v - lastValue) / lastValue;
            }
            lastValue = v;
            percents.push(incr * 100);
        }
        return percents;
    },
    movingAverage: function(values, props) {
        if (!props) {
            props = {};
        }
        if (!props.step) props.step = 5;
	if(values.length==0) return values;
        var newValues = [];
        console.log("STEP:" + props.step);
	let tupleGetter = values[0].tuple?v=>{return v.tuple}:v=>{return  v};
	let isNumeric = tupleGetter(values[0]).map((v,idx)=>{return Utils.isNumber(v);});
	dataList.forEach((o,rowIdx)=>{
		    if(rowIdx==0) return;
		    let tuple = Utils.mergeLists(o.tuple);
		    tmp.push({
			record:o.record,
			tuple:tuple});
		    tuple[0] = "x"; tuple[1] = 5;
		    tuple.forEach((v,colIdx)=>{
			if(!isNumeric[colIdx]) return;
			tuple[colIdx]=5;
		    });
		});
		dataList = tmp;



        for (var i = props.step; i < values.length; i++) {
            var total = 0;
            var cnt = 0;
            for (var j = i - props.step; j < i; j++) {
                if (values[j] == values[j]) {
                    total += values[j];
                    cnt++;
                }
            }
            var value = (cnt > 0 ? total / cnt : NaN);
            if (newValues.length == 0) {
                for (var extraIdx = 0; extraIdx < props.step; extraIdx++) {
                    newValues.push(value);
                }
            }
            newValues.push(value);
        }

        console.log("MovingAverage: values:" + values.length + " new:" + newValues.length);
        return newValues;
    },
    expMovingAverage: function(values, props) {
        if (!props) {
            props = {};
        }
        if (!props.step) props.step = 5;
        var sma = ArrayUtil.movingAverage(values, props);
        var mult = (2.0 / (props.step + 1));
        var newValues = [];
        console.log("STEP:" + props.step);
        for (var i = props.step; i < values.length; i++) {
            var total = 0;
            var cnt = 0;
            for (var j = i - props.step; j < i; j++) {
                if (values[j] == values[j]) {
                    total += values[j];
                    cnt++;
                }
            }
            var value = (cnt > 0 ? total / cnt : NaN);
            if (newValues.length == 0) {
                for (var extraIdx = 0; extraIdx < props.step; extraIdx++) {
                    newValues.push(value);
                }
            }
            newValues.push(value);
        }

        console.log("MovingAverage: values:" + values.length + " new:" + newValues.length);
        return newValues;
    },

    max: function(values) {
        var max = NaN;
        for (var i = 0; i < values.length; i++) {
            if (i == 0 || values[i] > max) {
                max = values[i];
            }
        }
        return max;
    },
    min: function(values) {
        var min = NaN;
        for (var i = 0; i < values.length; i++) {
            if (i == 0 || values[i] < min) {
                min = values[i];
            }
        }
        return min;
    },

}

var RecordUtil = {
    groupBy:function(records, display, dateBin, field) {
	let debug = displayDebug.groupBy;
	if(debug) console.log("groupBy");
	let groups ={
	    max:0,
	    values:[],
	    labels:[],
	    map:{},
	}
	records.forEach((r,idx)=>{
	    let key;
	    let label = null;
	    let date = r.getDate();
	    //	    if(debug && idx>0 && (idx%10000)==0) console.log("\trecord:" + idx);
	    if(field) {
		if(field=="latlon") {
		    key = label = r.getLatitude() +"/" + r.getLongitude(); 
		} else {
		    key = label = r.getValue(field.getIndex());
		}
	    } else {
		if(!date) {
		    return;
		}
		key = date;
		if(dateBin===true) {
		    //do the label later
		} else {
		    if(dateBin=="day") {
			key = new Date(label=date.getFullYear()+"-" + date.getUTCMonth() +"-" +date.getUTCDay())
		    } else if(dateBin=="month") {
			label=date.getFullYear()+"-" + date.getUTCMonth();
			key = new Date(label +"-01");
		    } else if(dateBin=="year") {
			label = date.getFullYear();
			key = new Date(date.getFullYear()+"-01-01");
		    } else if(dateBin=="decade") {
			let year = date.getFullYear();
			year = year-year%10;
			label = year+"s";
			key = new Date(year+"-01-01");
		    } else if(dateBin) {
			label = String(key);
		    }
		}
	    }
	    let array = groups.map[key];
	    if(!array) {
		if(debug) console.log("\tadding group:"  + key);
		array = groups.map[key] = [];
		groups.values.push(key);
		if(label==null)
		    label = display.formatDate(date,null,true);
		groups.labels.push(label);
	    }
	    array.push(r);
	    groups.max = Math.max(groups.max, array.length);
	});
	return groups;
    },
    expandBounds: function(bounds, perc) {
	return new RamaddaBounds(
	    Math.min(90,bounds.north +(bounds.north-bounds.south)*perc),
	    Math.max(-180, bounds.west -(bounds.east-bounds.west)*perc),
	    Math.max(-90,bounds.south -(bounds.north-bounds.south)*perc),
	    Math.min(180,bounds.east +(bounds.east-bounds.west)*perc)
	);
    },
    convertBounds: function(bounds) {
	if(!bounds) return null;
	return new RamaddaBounds(bounds);
    },
    subset:function(records,bounds) {
	bounds = RecordUtil.convertBounds(bounds);
	//	console.log("subset:" + JSON.stringify(bounds));
	let cnt = 0;
	records =  records.filter((record,idx)=>{
	    let lat = record.getLatitude?record.getLatitude():record.r?record.r.getLatitude():record.y;
	    let lon = record.getLongitude?record.getLongitude():record.r?record.r.getLongitude():record.x;
	    let ok =   lat<= bounds.north &&
		lat>= bounds.south &&
		lon>= bounds.west &&
		lon<= bounds.east;
	    return ok;
	});
	return records;
    },
    getRanges: function(fields, records) {
        var maxValues = [];
        var minValues = [];
        for (var i = 0; i < fields.length; i++) {
            maxValues.push(NaN);
            minValues.push(NaN);
        }

        for (var row = 0; row < records.length; row++) {
            for (var col = 0; col < fields.length; col++) {
                var value = records[row].getValue(col);
                if (isNaN(value)) continue;
                maxValues[col] = (isNaN(maxValues[col]) ? value : Math.max(value, maxValues[col]));
                minValues[col] = (isNaN(minValues[col]) ? value : Math.min(value, minValues[col]));
            }
        }

        var ranges = [];
        for (var col = 0; col < fields.length; col++) {
            ranges.push([minValues[col], maxValues[col]]);
        }
        return ranges;
    },



    getElevationRange: function(fields, records) {
        var maxValue = NaN;
        var minValue = NaN;

        for (var row = 0; row < records.length; row++) {
            if (records[row].hasElevation()) {
                var value = records[row].getElevation();
                maxValue = (isNaN(maxValue) ? value : Math.max(value, maxValue));
                minValue = (isNaN(minValue) ? value : Math.min(value, minValue));
            }
        }
        return [minValue, maxValue];
    },


    slice: function(records, index) {
        var values = [];
        for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
            var row = records[rowIdx];
            if (row.getValue) {
                values.push(row.getValue(index));
            } else {
                values.push(row[index]);
            }
        }
        return values;
    },


    sort: function(fields) {
        fields = fields.slice(0);
        fields.sort(function(a, b) {
            var s1 = a.getSortOrder();
            var s2 = b.getSortOrder();
            return s1 < s2;
        });
        return fields;
    },
    getPoints: function(records, bounds) {
	let points = [];
	this.getBounds(records, bounds,points);
	return points;
    },
    getBounds: function(records, bounds,points) {
	bounds = bounds||{};
        if (records == null) {
	    return bounds;
	}
        var north = NaN,
            west = NaN,
            south = NaN,
            east = NaN;
	let errorCnt = 0;
        for (j = 0; j < records.length; j++) {
            var record = records[j];
            if (!isNaN(record.getLatitude()) && !isNaN(record.getLongitude())) {
                if (j == 0) {
                    north = record.getLatitude();
                    south = record.getLatitude();
                    west = record.getLongitude();
                    east = record.getLongitude();
                } else {
                    north = Math.max(north, record.getLatitude());
                    south = Math.min(south, record.getLatitude());
                    west = Math.min(west, record.getLongitude());
                    east = Math.max(east, record.getLongitude());
                }
                if (record.getLongitude() < -180 || record.getLatitude() > 90) {
		    //		    if(errorCnt++<50)
		    //			console.log("bad location: index=" + j + " " + record.getLatitude() + " " + record.getLongitude());
                }
		if(points)
                    points.push({x:record.getLongitude(), y:record.getLatitude()});
            }
        }
        bounds.north = north;
        bounds.west = west;
        bounds.south = south;
        bounds.east = east;
        return new RamaddaBounds(bounds);
    },

    findClosest: function(records, lon, lat, indexObj) {
        if (records == null) return null;
        var closestRecord = null;
        var minDistance = 1000000000;
        var index = -1;
        for (j = 0; j < records.length; j++) {
            var record = records[j];
            if (isNaN(record.getLatitude())) {
                continue;
            }
            var distance = Math.sqrt((lon - record.getLongitude()) * (lon - record.getLongitude()) + (lat - record.getLatitude()) * (lat - record.getLatitude()));
            if (distance < minDistance) {
                minDistance = distance;
                closestRecord = record;
                index = j;
            }
        }
        if (indexObj != null) {
            indexObj.index = index;
        }
        return closestRecord;
    },
    clonePoints: function(points) {
        var result = [];
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            result.push({x:point.x, y:point.y});
        }
        return result;
    }
};


function CsvUtil() {
    let eg = "convertData=\"derived(field=field_id, function=population*10);\nrotateData(includeFields=true,includeDate=true,flipColumns=true);\naddPercentIncrease(replaceValues=false);\"\n";
    $.extend(this, {
	process: function(display, pointData, cmds) {
	    this.display = display;
	    let theCmd;
	    try {
		let commands = DataUtils.parseCommands(cmds);
		commands.map(cmd=>{
		    theCmd =cmd;
		    if(this[cmd.command]) {
			let orig = pointData;
    			pointData = this[cmd.command](pointData, cmd.args);
			if(!pointData) pointData=orig;
			else pointData.entryId = orig.entryId;
		    } else {
			console.log("unknown command:" + cmd.command);
		    }
		});
	    } catch(e) {
		console.log("Error applying derived function:" + theCmd.command);
		console.log(e);
		console.log(e.stack);
	    }
	    return pointData;
	},
	help: function(pointData, args) {
	    console.log(eg);
	    return null;
	},
	furlData: function(pointData, args) {
	    /** TODO
		let records = pointData.getRecords(); 
		let header = this.display.getDataValues(records[0]);
		var newRecords  =[];
		var newFields = [];
		var lastRecord = dataList[dataList.length-1];
		var fields  = pointData.getRecordFields();
		var newData  =[];
		newData.push(["label","value"]);
		//		dataList.map(r=>{
		fields.map((f,idx)=>{
		let row = [f.getLabel(),lastRecord.getValue(f.getIndex())];
		newData.push();
		});
		pointData = convertToPointData(newData);
		pointData.entryId = originalPointData.entryId;
	    **/
	},
	derived: function(pointData, args) {
	    let records = pointData.getRecords(); 
	    let fields =  pointData.getRecordFields();
	    let newFields =  fields.slice();
	    let newRecords  =[];
	    let id = args["field"] || ("field_" + fields.length);
            newFields.push(new RecordField({
		id:id,
		index:fields.length,
		label:Utils.makeLabel(id),
		type:"double",
		chartable:true,
		unit: args.unit
            }));
	    let func = args["function"];
	    if(!func) {
		console.log("No func specified in derived");
		return null;
	    }
	    func = func.replace(/_nl_/g, "\n").replace(/_semi_/g,";");
	    if(func.indexOf("return")<0) {
		func = "return " + func;
	    }
            let setVars = "";
            fields.forEach((field,idx)=>{
		if(/*field.isFieldNumeric() && */field.getId()!="") {
		    if(func.indexOf(field.getId())<0) return;
		    let varName = field.getId().replace(/^([0-9]+)/g,"v$1");
		    setVars += "\tvar " + varName + "=displayGetFunctionValue(args[\"" + field.getId() + "\"]);\n";
		}
            });

//	    setVars+="console.log('v:' + (max_pool_elevation-lake_reservoir_elevation));\n";
            let code = "function displayDerivedEval(args) {\n" + setVars +  func + "\n}";
//	    console.log(code);

            eval(code);
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.data= record.data.slice();
		newRecord.fields =  newFields;
		newRecords.push(newRecord);
		let funcArgs = {};
		fields.map((field,idx)=>{
		    if(/*field.isFieldNumeric() &&*/ field.getId()!="") {
			funcArgs[field.getId()] = record.getValue(field.getIndex());
		    }
		});
		try {
		    let value = displayDerivedEval(funcArgs);
		    newRecord.data.push(value);
		} catch(exc) {
		    console.log("Error processing derived:" + exc);
		    newRecord.data.push(NaN);
		}
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	rotateData: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
	    let rotated = [];
	    for(var colIdx=0;colIdx<header.length;colIdx++) {
		rotated.push([]);
	    }
	    let includeFields =args["includeFields"] == "true";
	    let includeDate = args["includeDate"] == "true";
	    let flipColumns =args["flipColumns"]=="true";
	    let fields = pointData.getRecordFields();
	    if (!flipColumns && includeFields) {
                fields.map((f,colIdx)=>{
		    if(f.isRecordDate()) return;
		    rotated[colIdx].push(colIdx==0?args["fieldName"]||"Field":f.getLabel());
		});
	    }
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.display.getDataValues(records[rowIdx]);
		for(var colIdx=0;colIdx<row.length;colIdx++) {
		    let field = fields[colIdx];
		    if(field.isRecordDate()) {
			continue;
		    }
		    var value = row[colIdx];
		    if(value.f) value = value.f;
		    if(value.getTime) {
			value = this.display.formatDate(value);
		    }
		    if(!includeFields && rowIdx==0 && colIdx==0) value="";

		    if(flipColumns)
			rotated[colIdx].unshift(value);
		    else
			rotated[colIdx].push(value);
		}
            }
	    if (flipColumns && includeFields) {
                fields.map((f,colIdx)=>{
		    if(f.isRecordDate()) return;
		    rotated[colIdx].unshift(colIdx==0?args["fieldName"]||"Field":f.getLabel());
		});
	    }
	    return  convertToPointData(rotated);
	},
	addPercentIncrease: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let firstRecord= records[0];
	    let replaceValues = args["replaceValues"]=="true";
	    let newFields = [];
	    let fieldOk = f=>{
		return !f.isFieldGeo() && f.isNumeric();
	    };
	    fields.forEach((f,fieldIdx)=>{
		f = f.clone();
		let newField = f.clone();
		f.index = newFields.length;
		if(!fieldOk(newField)) {
		    newFields.push(f);
		    return;
		}
		if(!replaceValues) {
		    newFields.push(f);
		}
		newField.unit = "%";
		newField.index = newFields.length;
		newField.id = newField.id +"_percent";
		newField.label = newField.label+" % increase";
		newFields.push(newField);
	    });
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    records.forEach((record, rowIdx)=>{
		let data = [];
		let newRecord = record.clone();
		newRecord.data=data;
		newRecord.fields =newFields;
		newRecords.push(newRecord);
		fields.forEach((f,fieldIdx)=>{
		    let value = record.data[f.getIndex()];
		    if(!fieldOk(f)) {
			if(rowIdx==records.length-1) {
	//		    console.log(f +" ==" +  value);
			}
			data.push(value);
			return;
		    }
		    if(!replaceValues) {
			data.push(value);
		    }
		    if(rowIdx==0) {
			data.push(0);
		    } else {
			let basev = firstRecord.data[f.getIndex()];
			let perc = basev==0?0:(value-basev)/basev;
			data.push(perc);
			if(rowIdx==records.length-1) {
//			    console.log(f +" =" + basev +" " + value +" perc:" + perc);
			}
		    }
		}); 
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	addFixed: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let value = args["value"];
	    let type = args["type"]||"double";
	    if(type == "double") value = parseFloat(value);
	    let id = args["id"];
	    let label = args["label"]||Utils.makeLabel(id);	    	    
	    let newFields = [];
	    fields.forEach((f,fieldIdx)=>{
		newFields.push(f.clone());
	    });
	    newFields.push(new RecordField({
		id:id,
		index:newFields.length,
		label:label,
		type:type,
		chartable:true,
	    }));
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.data  =  [];
		record.data.forEach(d=>{newRecord.data.push(d)});
		newRecord.data.push(value);
		newRecords.push(newRecord);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	addBearing: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let newFields = [];
	    fields.forEach((f,fieldIdx)=>{
		f = f.clone();
		newFields.push(f);
	    });
	    let bearingField = new RecordField();
	    newFields.push(new RecordField({
		id:"bearing",
		index:newFields.length,
		label:"Bearing",
		type:"double",
		chartable:true,
	    }));
	    let pervPoint;
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.fields =newFields;
		newRecords.push(newRecord);
		let bearing = NaN;
		if(prevPoint) {
		    let point = {lat:newRecord.getLatitude(),lon: newRecord.getLongitude()};
		    bearing  = Utils.getBearing(prevPoint, point);
		    prevPoint = point;
		}
		newRecord.data.push(bearing);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	cut: function(pointData, args) {
	    let cut  = args.fields?args.fields.split(","):[];
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newFields = [];
	    let newRecords = [];
	    let indices = [];
	    fields.forEach((f,fieldIdx)=>{
//		console.log(f.getId());
		if(cut.indexOf(f.getId())>=0) return;
		f = f.clone();
		let newField = f.clone();
		indices.push(newField.index);
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.fields =newFields;
		let data= newRecord.data;
		let newData=[];
		indices.forEach(i=>{
		    newData.push(data[i]);
		});
		newRecord.data = newData;
		newRecords.push(newRecord);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	doAverage: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    var newRecords  =[];
	    var newFields = [];
	    var firstRow = records[0];
	    fields.forEach(f=>{
		var newField = f.clone();
		newFields.push(newField);
		newField.label = newField.label+" (avg)";
	    });
	    var sums=[];
	    fields.forEach(f=>{sums.push(0)});
	    var newRecord;
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		if(newRecord==null) {
		    newRecord = record.clone();
		    newRecords.push(newRecord);
		    newRecord.fields =newFields;
		    newRecord.parentRecords=[];
		}
		newRecord.parentRecords.push(record);
		fields.forEach((f,idx)=>{
		    if(!f.isNumeric()) return;
		    var v = record.data[f.getIndex()];
		    sums[idx]+=v;
		});
		fields.map((f,idx)=>{
		    if(!f.isNumeric()) return;
		    newRecord.data[idx] = sums[idx]/records.length;
		});
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	noop: function(pointData, args) {
	    return pointData;
	},
	doublingRate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields =  this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    let keyFields =  this.display.getFieldsByIds(allFields, (args.keyFields||"").replace(/_comma_/g,","));
	    let newRecords  =[]
	    let newFields = Utils.cloneList(allFields);
	    fields.map(f=>{
		if(!f.isNumeric()) return;
		let newField = f.clone();
		newField.id = newField.id+"_doubling";
		newField.unit = "days";
		newField.label = newField.label+" doubling";
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    let keys = [];
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		let key = "";
		keyFields.forEach(f=>{
		    key+="_"+record.getValue(f.getIndex());
		});
		keys.push(key);
	    }

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		let key = keys[rowIdx];
		newRecords.push(newRecord);
		newRecord.fields =newFields;
		fields.map((f,idx)=>{
		    if(!f.isNumeric()) return;
		    let v = record.getValue(f.getIndex());
		    let v2 = NaN;
		    let lastDate = null;
		    for (var j=rowIdx-1; j>=0; j--) {
			if(keyFields.length>0) {
			    let key2 = keys[j];
			    if(key!=key2) continue;
			}
			let record2 = records[j];
			v2 = record2.getValue(f.getIndex());
			if(v>=v2*2) {
			    lastDate  = record2.getDate();
			    break;
			}
		    }
		    let diff = NaN;
		    if(lastDate) {
			diff = (record.getDate().getTime()-lastDate.getTime())/1000/60/60/24;
		    }
		    newRecord.data.push(diff);
		});
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	scaleAndOffset: function(pointData,args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let unit = args.unit;
	    let scale = args.scale?parseFloat(args.scale):1;
	    let offset1 = args.offset1?parseFloat(args.offset1):0;
	    let offset2 = args.offset?parseFloat(args.offset):args.offset2?parseFloat(args.offset2):0;	    	    
	    let newRecords  =[]
	    let newFields = [];
	    let changedFields = {};
	    fields.forEach(f=>{changedFields[f.getId()]  =true});
	    allFields.map(f=>{
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) {
		    return;
		}
		if(changedFields[newField.getId()]) {
		    newField.unit = unit;
		}
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			d  = (d + offset1) * scale + offset2;
			newData[f.getIndex()]=d;
		    }
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	scaleAndOffset: function(pointData,args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let unit = args.unit;
	    let scale = args.scale?parseFloat(args.scale):1;
	    let offset1 = args.offset1?parseFloat(args.offset1):0;
	    let offset2 = args.offset?parseFloat(args.offset):args.offset2?parseFloat(args.offset2):0;	    	    
	    let newRecords  =[]
	    let newFields = [];
	    let changedFields = {};
	    fields.forEach(f=>{changedFields[f.getId()]  =true});
	    allFields.map(f=>{
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) {
		    return;
		}
		if(changedFields[newField.getId()]) {
		    newField.unit = unit;
		}
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			d  = (d + offset1) * scale + offset2;
			newData[f.getIndex()]=d;
		    }
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	function: function(pointData, args) {
	},
	accum: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    let suffix = args.suffix!=null?args.suffix:"_accum";
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    let totals =[];
	    allFields.map(f=>{
		totals.push(0);
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) return;
		newField.id = newField.id+suffix;
		newField.label = newField.label+suffix;
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			let x = d;
			totals[f.getIndex()]+=d;
			d = totals[f.getIndex()];
		    }
		    newData[f.getIndex()] = d;
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	aggregate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let groupField = this.display.getFieldById(allFields,args.groupBy);
	    if(!groupField) throw new Error("No groupBy defined: "+ args.groupBy +" args:" + JSON.stringify(args));
	    let includeRows = args.includeRows;
	    let fields;
	    let suffix = args.suffix!==null?args.suffix:"_accum";
	    suffix = "";
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    let totals =[];
	    let groupMap = {};
	    let groups = [];
	    let prop= (f,p)=>{
		let id = f.getId()+"." + p;
		if(Utils.isDefined(args[id])) return args[id];
		if(Utils.isDefined(this.display.getProperty(id))) return this.display.getProperty(id);
		return this.display.getProperty(p);		
	    };
	    fields.forEach(f=>{
		let newField = f.clone();
		newFields.push(newField);
		newField.id = newField.id+suffix;
		newField.label = newField.label+suffix;
		if(newField.isNumeric()) {
		    newField.weightedByField = this.display.getFieldById(allFields,prop(newField,"weightedByField"));
		    let op = prop(newField,"operator");
		    if(!op && newField.getUnit()=="%")
			op = "average";
	 	    newField.operator =op;
		}
	    });
	    records.forEach(record=>{
		let groupValue = groupField.getValue(record);
		let group = groupMap[groupValue];
		if(!group) {
		    group = groupMap[groupValue] = [];
		    groups.push(groupValue);
		}
		group.push(record);
	    });
	    groups.forEach(group=>{
		let newData = [];
		let rows = groupMap[group];
		newFields.forEach(f=>{
		    if(f.weightedByField) {
			f.weight = Utils.sumList(rows.map(record=>{return f.weightedByField.getValue(record);}));
		    }
		    if(f.isFieldNumeric()) newData.push(0);
		    else {
			if(f.getId()==groupField.getId()) 
			    newData.push(group);
			else
			    newData.push("");
		    }
		});
		let debug = group=="Delaware";
		rows.forEach((record,recordIdx)=>{
		    newFields.forEach((f,idx)=>{
			let v = f.getValue(record);
			if(f.isFieldNumeric()) {
			    if(!isNaN(v)) {
				
				if(f.operator=="average" && f.weightedByField) {
				    let weight = f.weightedByField.getValue(record);
				    let percent = weight/f.weight;
				    v= v*percent;
				}
				newData[idx]+=v;
			    }
			} else {
			    if(recordIdx==0)
				newData[idx] = v;
			    if(groupField.getId()==f.getId()) {
				newData[idx] = groupField.getValue(record);
			    }
			}
		    });
		});
	    	let newRecord = rows[0].clone();
		newRecords.push(newRecord);
		newFields.forEach(f=>{
		    if(!f.isNumeric()) {
			if(groupField.getId()!=f.getId())
			    newData[f.getIndex()]="";
			return;
		    }
		    let debug = group=="Delaware";
		    let d = newData[f.getIndex()]
		    if(!isNaN(d)) {
			if(f.operator=="average") {
			    if(!f.weightedByField) {
				d =  d/rows.length;
			    } 
			}
			let decimals = prop(f,"numberFormatDecimals");
			if(decimals!==null)
			    d = Utils.roundDecimals(d,decimals);
//			if(debug) console.log(f.getId() +" d:" + d);
			newData[f.getIndex()] = d;
		    }
		});
		newRecord.setData(newData);
		newRecord.isAggregate = true;
		newRecord.aggregateValue=group;
		if(includeRows) 
		    newRecords = Utils.mergeLists(newRecords, rows);

	    })
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


	mean: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    allFields.map(f=>{
		newFields.push(f.clone());
	    });
	    newFields.push(new RecordField({
		id:"mean",
		index:newFields.length,
		label:"Mean",
		type:"double",
		chartable:true,
	    }));

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		let total = 0;
		let fieldCnt = 0;
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    fieldCnt++;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			total+=d;
		    }
		});
		newData.push(total/fieldCnt);
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	prune: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    allFields.map(f=>{
		newFields.push(f.clone());
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let data = record.getData();
		let newData=Utils.cloneList(data);
		let ok = false;
		let fieldCnt= 0;
		fields.every(f=>{
		    if(!f.isNumeric()) return true;
		    fieldCnt++;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			ok = true;
			return false;
		    }
		    return true;
		});
		if(ok)  {
		    let newRecord = record.clone();
		    newRecord.setData(newData);
		    newRecords.push(newRecord);
		}
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


	mergeRows: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let op = args.operator || "count";
	    let ops = {};
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    let altFields =  this.display.getFieldsByIds(fields, (args.altFields||"").replace(/_comma_/g,","));
	    let newFields = [];
	    let seen = {};
	    keyFields.forEach((f,idx)=>{
		seen[f.getId()] = true;
		let newField = f.clone();
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    let tmp =  this.display.getFieldsByIds(fields, (args["valueFields"]||"").replace(/_comma_/g,","));
	    if(args.valueFields==null) tmp=fields;
	    let valueFields = [];


	    tmp.forEach(f=>{
		if(!seen[f.getId()]) {
		    ops[f.getId()] = args[f.getId()+".operator"];
		    valueFields.push(f);
		}
	    });

	    valueFields.forEach((f,idx)=>{
		var newField = f.clone();
		newField.index = newFields.length;
		if(newField.isNumeric()) {
		    let label = args[newField.id+".label"];
		    newField.id = newField.id +"_" + (ops[f.getId()+".operator"] || op);
		    newField.label = label || Utils.makeLabel(newField.id);
		}
		newFields.push(newField);
	    });
	    //	    console.log("key fields:" + keyFields);
	    //	    console.log("value fields:" + valueFields);
	    if(op == "count") {
		newFields.push(new RecordField({
		    id:"count",
		    index:newFields.length,
		    label:"Count",
		    type:"double",
		    chartable:true,
		}));
	    }
//	    console.log("fields:" + newFields);
	    let keys = [];
	    let collection ={
	    };

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		let key = "";
		keyFields.forEach(f=>{
		    let v = record.getValue(f.getIndex());
		    if(v=="" && altFields.length>0) {
			altFields.forEach(f2=>{
			    v+=record.getValue(f1.getIndex()) +"-";
			});
		    }
		    key +=v+"-";
		});
		let obj = collection[key];
		if(!obj) {
		    keys.push(key);
		    obj = collection[key]= {
			count:0,
			sums: [],
			mins: [],
			maxs:[],
			records:[]
		    };
		    valueFields.forEach((f,idx)=>{
			obj.sums.push(0);
			obj.mins.push(NaN);
			obj.maxs.push(NaN);
		    });
		}
		valueFields.forEach((f,idx)=>{
		    let v = record.getValue(f.getIndex());
		    if(f.isNumeric() && !isNaN(v)) {
			obj.sums[idx]+=v;
			obj.mins[idx] = isNaN(obj.mins[idx])?v:Math.min(obj.mins[idx],v);
			obj.maxs[idx] = isNaN(obj.maxs[idx])?v:Math.max(obj.maxs[idx],v);
		    }
		});
		obj.count++;
		obj.records.push(record);
	    }
	    let newRecords = [];
	    let cnt = 0;
	    keys.forEach((key,idx)=>{
		let obj = collection[key];
		let data =[];
		let seen = {};
		let date = obj.records[0].getDate();
		let bounds = RecordUtil.getBounds(obj.records);
		let lat =  bounds.south+(bounds.north-bounds.south)/2;
		let lon =  bounds.west+(bounds.east-bounds.west)/2;
		if(key.indexOf("US")>=0) {
		    cnt++;
		    if(cnt==1) {
			//			console.log(obj.records.length +" " +bounds.west +" " + bounds.east +" " + lat  +" " +lon);
			obj.records.forEach(r=>{
			    //			    console.log(r.getValue(0) + " " + r.getLatitude() +" " + r.getLongitude())
			});
		    }
		}
		keyFields.forEach(f=>{
		    let v = obj.records[0].getValue(f.getIndex());
		    data.push(v);
		    seen[f.getId()]=true;
		});
		valueFields.forEach((f,idx)=>{
		    if(seen[f.getId()]) return;
		    if(!f.isNumeric()) {
			data.push(obj.records[0].getValue(f.getIndex()));
		    } else {
			if(op == "sum") 
			    data.push(obj.sums[idx]);
			else if(op == "average") 
			    data.push(obj.sums[idx]/obj.count);
			else if(op == "min") 
			    data.push(obj.mins[idx]);
			else if(op == "max") 
			    data.push(obj.maxs[idx]);
		    }
		});
		if(op == "count") {
		    data.push(obj.count);
		}
		let newRecord = new  PointRecord(newFields,lat,lon, NaN, date, data);
		newRecords.push(newRecord);
	    });

	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	maxDate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    let seen = {};
	    let keys = [];
	    let collection ={
	    };

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		let key = "";
		keyFields.forEach(f=>{
		    key +=  record.getValue(f.getIndex())+"-";
		});
		let obj = collection[key];
		if(!obj) {
		    keys.push(key);
		    obj = collection[key]= {
			records:[]
		    };
		}
		obj.records.push(record);
	    }
	    let newRecords = [];
	    let cnt = 0;
	    keys.forEach((key,idx)=>{
		let records = collection[key].records;
		let maxRecord = null;
		let maxDate = null;
		records.forEach(r=>{
		    if(maxRecord==null || r.getDate().getTime()>maxDate) {
			maxDate = r.getDate().getTime();
			maxRecord = r;
		    }
		});
		newRecords.push(maxRecord);
	    });

	    return   new  PointData("pointdata", fields, newRecords,null,{parent:pointData});
	},

	unfurl: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let headerField =  this.display.getFieldById(fields, args.headerField||"");
	    let uniqueField =  this.display.getFieldById(fields, args.uniqueField||"");
	    let valueFields =  this.display.getFieldsByIds(fields, args.valueFields||"");
	    let includeFields =  this.display.getFieldsByIds(fields, args.includeFields||"");
	    let prefix = args.prefix||"";
	    if(!headerField) throw new Error("No headerField");
	    let uniqueIsDate = false;
	    if(!uniqueField) {
		if(args.uniqueField=="date") {
		    uniqueIsDate = true;
		} else {
		    throw new Error("No uniqueField");
		}
	    }
	    if(valueFields.length==0) throw new Error("No value fields");
	    /*
	      newFields.push(new RecordField({
	      id:"count",
	      index:newFields.length,
	      label:"Count",
	      type:"double",
	      chartable:true,
	      }));
	    */
	    let newColumns = [];
	    let newColumnMap = {};
	    let uniqueToRecords = {};
	    let rowMap = {};
	    let uniques = [];
	    let indexMap={};
	    records.forEach(record=>{
		let unfurlValue = record.getValue(headerField.getIndex());
		let uniqueValue = uniqueIsDate?record.getDate():record.getValue(uniqueField.getIndex());
		if(!newColumnMap[unfurlValue]) {
                    newColumnMap[unfurlValue] = true;
                    if (valueFields.length > 1) {
                        valueFields.forEach(f=>{
                            let label = unfurlValue + " - "
                                + f.getLabel();
                            newColumns.push(label);
                        });
                    } else {
			newColumns.push(unfurlValue);
		    }
		}
                let rowGroup    = rowMap[uniqueValue];
                if (rowGroup == null) {
                    rowMap[uniqueValue] =  rowGroup = [];
                    uniques.push(uniqueValue);
                }
                rowGroup.push(record);
	    });

	    //In case the new colum labels are numbers
	    newColumns.sort((a,b)=>{
		if(typeof a =="number" &&  typeof b =="number") {
		    return a-b;
		}
		return (""+a).localeCompare(""+b);
	    });
            newColumns.forEach((v,idx) => {
                indexMap[v] = idx;
            });

	    let newRecords = [];
	    let newFields = [];
	    let uniqueType = "string";
	    if(uniques[0]) {
		if(uniques[0].getTime)
		    uniqueType ="date";
		else if(typeof uniques[0] =="number")
		    uniqueType ="double";
		    
	    }
	    if(uniqueIsDate)
		newColumns = Utils.mergeLists(["date"], newColumns);
	    else
		newColumns = Utils.mergeLists([uniqueField.getId()], newColumns);
	    newColumns.forEach((c,idx)=>{
		if(idx>0)
		    c = prefix+""+c;
		else
		    c = ""+c;
		let label =Utils.makeLabel(c);
		let id  = Utils.makeId(c);
		let type = (idx==0?uniqueType:"double");
		newFields.push(new RecordField({
		    id:id,
		    index:newFields.length,
		    label:label,
		    type:type,
		    chartable:true,
		}));
	    });
	    uniques.forEach(u=>{
		let array = [];
		newColumns.forEach(c=>{
		    array.push("");
		});
                array[0] = u;
                let  includeCnt = 0;
                let rowValues  = null;
                let firstRow   = null;
                cnt = 0;
                rowMap[u].forEach(row=>{
                    if (firstRow == null) {
                        firstRow = row;
                    }
                    let colname = row.getValue(headerField.getIndex());
                    if (valueFields.length > 1) {
                        valueFields.forEach(f=>{
                            let label = colname + " - "  + f.getId();
                            let idx = indexMap[label];
                            if (idx == null) {
				return;
                            }
                            let value =  row.getValue(valueIndex);
                            array[1 + includeFields.length + idx] = value;
                        });
		    } else {
                        let idx = indexMap[colname];
                        if (idx == null) {
			    return;
                        }
                        let    valueIndex = valueFields[0].getIndex();
                        let value = row.getValue(valueIndex);
                        array[1 + includeFields.length + idx] = value;
                    }
                    cnt++;
		});

                includeFields.forEach(f=>{
                    array[1 + includeCnt] = firstRow.getValue(f.getIndex());
                    includeCnt++;
                });
		let newRecord = new  PointRecord(newFields,firstRow.getLatitude(),firstRow.getLongitude(), NaN, null, array);
//		console.log("lat:" + firstRow.getLatitude());
		newRecords.push(newRecord);
                cnt++;
            });
 	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


    });
}




var DataUtils = {
    getCsv: function(fields, records) {
	let csv = "";
	fields.forEach((f,idx)=>{
	    if(idx>0) csv+=",";
	    csv+=f.getId();
	});
	csv+="\n";
	records.forEach(r=>{
	    fields.forEach((f,idx)=>{
		let v = r.getValue(f.getIndex());
		if(v && v.getTime) {
		    v  =Utils.formatDateYYYYMMDDHHMM(v);
		} else {
		    v = String(v);
		}
		if(idx>0) csv+=",";
		let needToQuote = v.indexOf("\n")>=0 || v.indexOf(",")>=0;
		if(v.indexOf("\"")>=0) {
		    needToQuote = true;
		    v = v.replace(/\"/g,"\"\"");
		}
		if(needToQuote) {
		    v = "\"" + v +"\"";
		}
		csv+=v;
	    });
	    csv+="\n";
	});
	return csv;
    },
    getJson: function(fields, records, filename) {
	let json = [];
	records.forEach(r=>{
	    let obj = {};
	    json.push(obj);
	    fields.forEach((f,idx)=>{
		let v = r.getValue(f.getIndex());
		if(v && v.getTime) {
		    v  =Utils.formatDateYYYYMMDDHHMM(v);
		} else {
		    v = String(v);
		}
		obj[f.getId()] = v;
	    });
	});
	Utils.makeDownloadFile(filename, JSON.stringify(json,null,2));
    },


    parseCommands: function(commands) {
	let result = [];
	if(!commands) return result;
	commands.split(";").forEach(command=>{
	    command = command.trim();
	    let idx=command.indexOf("(");
	    let args = {};
	    if(idx>=0) {
		let rest = command.substring(idx+1).trim();
		command = command.substring(0,idx).trim();
		if(rest.endsWith(")")) rest = rest.substring(0,rest.length-1);
		let toks = [];
		let inQuote = false;
		let escape = false;
		let tok = "";
		for(let i=0;i<rest.length;i++) {
		    let c = rest[i];
		    if(c=="\\") {
			escape=true;
			continue;
		    }
		    if(escape) {
			tok += c;
			escape=false;
			continue;
		    }
		    if(c=="\'") {
			if(!inQuote) {
			    inQuote = true;
			} else {
			    inQuote = false;
			}
			tok += c;
			continue;
		    }
		    if(c == ",") {
			if(inQuote) {
			    tok += c;			    
			    continue;
			}
			toks.push(tok);
			tok = "";
			continue;
		    }
		    tok += c;			    
		}
		toks.push(tok);
		toks.forEach(arg=>{
		    arg =arg.trim();
		    let value = "";
		    let atoks = arg.match(/(.*)=(.*)/);
		    if(atoks) {
			arg=atoks[1];
			value= atoks[2];
		    }
		    arg = arg.trim();
		    value = value.trim();
		    //		    console.log("arg:" + arg +" v:" + value);
		    //Strip off quotes
		    value = value.replace(/^'/g,"").replace(/'$/g,"");
		    if(arg!="") {
			args[arg] = value;
		    }
		});
	    }
	    if(command!="") {
		result.push({command:command,args:args});
	    }
	});
	return result;
    },
    getDataFilters: function(display, prop) {
	let filters = [];
	if(!prop) return filters;
	let baseId = display.getId();
	let cnt = 0;
	DataUtils.parseCommands(prop).map(cmd=>{
	    let filterId = baseId+"_" + (cnt++);
	    let [type,fieldId,value,enabled,label,expr]  = [cmd.command,cmd.args.field,cmd.args.value,cmd.args.enabled,cmd.args.label,cmd.args.expr];
	    if(!Utils.isDefined(enabled))
		enabled = true;
	    else {
		enabled = enabled.trim()=="true" || enabled.trim()=="";
	    }
	    if(label) {
		var cbx =  display.jq("datafilterenabled_" + filterId);
		if(cbx.length) {
		    enabled = cbx.is(':checked');
		} 
	    }
	    if(type=="match" || type=="notmatch")
		value = new RegExp(value);
	    else
		value = +value;
	    let fields = null;
	    if(cmd.args.fields) {
		fields = display.getFieldsByIds(null, cmd.args.fields.replace(/:/g,","));
	    }
	    let allFields = display.getData().getRecordFields();
	    let field = display.getFieldById(null,fieldId);
	    filters.push({
		id:filterId,
		props:cmd.args,
		type:type.trim(),
		field:field,
		fields:fields?fields:field?[field]:null,
		allFields:allFields,
		value:value,
		label:label,
		enabled: enabled,
		expr:expr,
		isRecordOk: function(r) {
		    if(!this.enabled) {
			return true;
		    }
		    let value = this.field?r.getValue(this.field.getIndex()):NaN;
		    if(this.type == "match") {
			return String(value).match(this.value);
		    } else if(this.type == "nomissing") {
			let fieldsToUse =null;
			if(this.fields) {
			    fieldsToUse = this.fields;
			} else if(this.field) {
			    fieldsToUse = [this.field];
			} else {
			    fieldsToUse = r.fields;
			}
			let ok = false;
			fieldsToUse.some(f=>{
			    if(field && !(field.isFieldLatitude() || f.isFieldLongitude()))
				if(f.isFieldLatitude() || f.isFieldLongitude()) return true;
			    if(f.isNumeric()) {
				let v  = r.getValue(f.getIndex());
				//				console.log("V:" + v);
				ok  =!isNaN(v);
			    }
			    return ok;
			});
			//			if(!ok) 
			//			    console.log("****** V:" +value + " v:" + this.value);
			return ok;
		    } else if(this.type == "notmatch") {
			return  !String(value).match(this.value);
		    } else if(this.type == "lessthan") {
			return  value<this.value;
		    } else if(this.type == "greaterthan") {
			return  value>this.value;
		    }  else if(this.type == "equals") {
			return  value==this.value;
		    }  else if(this.type == "notequals") {
			return value!=this.value;
		    }  else if(this.type == "bounds") {
			let lat =  r.getLatitude();
			let lon =  r.getLongitude();
			if(this.props.north && lat>+this.props.north) return false;
			if(this.props.south && lat<+this.props.south) return false;
			if(this.props.west && lon<+this.props.west)   return false;
			if(this.props.east && lon>+this.props.east) {return false;}
			return true;
		    }  else if(this.type == "eval") {
			//return true;
			//assume its inline code
			let code = "function dataFilterCall(){\n";
			this.allFields.every(f=>{
			    let value = r.getValue(f.getIndex());
			    if(typeof value == "string") value = "'" + value +"'";
			    else if(typeof value != "number") value = "'" + value +"'";
			    code+=f.getId() +"=" + value+";\n"
			    return true;
			});
			let expr = this.expr;
			if(expr == null) throw "No expr given in data filter";
			if(expr.indexOf("return")<0)  expr  = " return " + expr;
			code+=expr+"\n}\n";
			code +="var dataFilterValue = dataFilterCall();\n";
			eval(code);
			return dataFilterValue;
		    } else {
			console.log("Unknown filter:" + this.type);
			return true;
		    }

		}
	    });
	});
	return filters;
    },
}


function RequestMacro(display, macro) {
    this.display = display;
    let values = null;
    let enums = this.getProperty("request." +macro+".values");
    if(enums) {
	values =[]	
	let includeAll = false;
	if(this.getProperty("request." + macro+".includeAll",this.getProperty("request.includeAll",false))) {
	    values.push(["","All"]);
	    includeAll = true;
	}
	if(this.getProperty("request." + macro+".includeNone",false)) {
	    values.push(["","None"]);
	}
	enums.split(",").forEach(tok=>{
	    let toks = tok.split(":");
	    let id = toks[0];
	    let label = toks[1];
	    if(!includeAll && id=="_all_") return;
	    values.push([id,label||id]);
	});
    }

    let macroType = this.getProperty("request." +macro+".type",values!=null?"enumeration":macro=="bounds"?"bounds":"string");
    //    console.log(macro +" type:" + macroType +" v:" + values);
    let dflt =this.getProperty("request." +macro+".default",null);
    if(dflt == null) {
	if(values && values.length>0  && macroType=="enumeration") {
	    dflt = values[0][0];
	} else {
	    dflt = "";
	}
	dflt = "";
    }
    if(dflt && macroType=="enumeration") {
	if(dflt.split)	dflt = dflt.split(",");
    }

    let prefix = this.getProperty("requestPrefix","");
    $.extend(this,{
	name: macro,
	values:values,
	urlarg: this.getProperty("request." +macro+".urlarg",prefix+macro),
	type:macroType,
	triggerReload:this.getProperty("request." +macro+".triggerReload",true),
	dflt:dflt,
	dflt_from:this.getProperty("request." +macro+"_from.default",""),		    
	dflt_to:this.getProperty("request." +macro+"_to.default",""),
	dflt_min:this.getProperty("request." +macro+"_min.default",""),		    
	dflt_max:this.getProperty("request." +macro+"_max.default",""),
	label:this.getProperty("request." +macro+".label",Utils.makeLabel(macro)),
	multiple:this.getProperty("request." +macro+".multiple",false),
	template:this.getProperty("request." +macro+".template"),
	multitemplate:this.getProperty("request." +macro+".multitemplate"),
	nonetemplate:this.getProperty("request." +macro+".nonetemplate"),		
	delimiter:this.getProperty("request." +macro+".delimiter"),
	rows:this.getProperty("request." +macro+".rows",3),
    });
}


RequestMacro.prototype = {
    getProperty: function(prop, dflt)   {
	return this.display.getProperty(prop, dflt);
    },
    isVisible: function() {
	return  this.getProperty("request." +this.name +".visible",
				 this.getProperty("macros.visible",true));
    },
    getWidget: function(dateIds) {
	let debug = false;
	let visible = this.isVisible();
	let style = visible?"":"display:none;";
	let widget;
	let label = this.label;
	if(debug)console.log(this.getId() +".getWidget:" + label +" type:" + this.type);
	if(this.type=="bounds") {
	    widget = HU.checkbox("",[ID,this.display.getDomId(this.getId())], false) +HU.span([CLASS,"display-request-reload",TITLE,"Reload with current bounds"], " In bounds");
	    label = null;
	} else if(this.type=="enumeration") {
 	    if(this.values && this.values.length>0) {
		let attrs = [STYLE, style, ID,this.display.getDomId(this.getId()),CLASS,"display-filter-input"];
		let values = this.values;
		if(this.dflt) {
		    let first = [];
		    let rest = [];
		    values.forEach(v=>{
			if(this.dflt.indexOf(v[0])>=0)  first.push(v);
			else rest.push(v);
		    });
		    values = Utils.mergeLists(first,rest);
		} else {
		}
		

		if(this.multiple) {
		    attrs.push("multiple");
		    attrs.push(null);
		    attrs.push("size");
		    attrs.push(Math.min(this.rows,values.length));
		} else {
		    values = Utils.mergeLists([[VALUE_NONE,"--"]],values);
		}
		if(debug)
		    console.log("\tselect: dflt:" + this.dflt +" values:" + this.values);
		
		widget = HU.select("",attrs,values,this.dflt,20);
	    }
	} else if(this.type=="numeric") {
	    let minId = this.display.getDomId(this.getId()+"_min");
	    let maxId = this.display.getDomId(this.getId()+"_max");			    
	    widget = HU.input("","",["data-min", this.dflt_min, STYLE, style, ID,minId,"size",4,CLASS,"display-filter-input display-filter-range"],this.dflt_min) +
		" - " +
		HU.input("","",["data-max", this.dflt_max, STYLE, style, ID,maxId,"size",4,CLASS,"display-filter-input display-filter-range"],this.dflt_max)
	    label = label+" range";
	} else if(this.type=="date") {
	    let fromId = this.display.getDomId(this.getId()+"_from");
	    let toId = this.display.getDomId(this.getId()+"_to");
	    dateIds.push(fromId);
	    dateIds.push(toId);
	    widget = HU.datePicker("",this.dflt_from,[CLASS,"display-filter-input",STYLE, style, "name","",ID,fromId]) +
		" - " +
		HU.datePicker("",this.dflt_to,[CLASS,"display-filter-input",STYLE, style, "name","",ID,toId])
	    label = label+" range";
	} else {
	    let size = "10";
	    if(this.type=="number")
		size = "4";
	    widget = HU.input("",this.dflt,[STYLE, style, ID,this.display.getDomId(this.getId()),"size",size,CLASS,"display-filter-input"]);
	}
	if(!widget) return "";
	return (visible?this.display.makeFilterWidget(label,widget):widget);
    },
    isMacro: function(id) {
	return id == this.name;
    },
    getId: function() {
	return "macro_" + this.name;
    },
    getValue: function() {
	let widget = this.display.jq(this.getId());
	let value = this.dflt;
	if(widget.length!=0) {
	    value =  widget.val();
	} else {
	    if(this.type=="enumeration") {
		return VALUE_NONE;
	    }
	}
	this.display.setProperty("request." + this.name+".default",value);
	//	console.log(this.getId() +".getValue=" + value);
	return value;
    },
    setValue: function(prop) {
	let id = this.getId();
	if(prop.what == "min")
	    this.display.jq(i+"_min").val(prop.value);
	else if(prop.what == "max")
	    this.display.jq(id+"_max").val(prop.value);
	else if(prop.what == "from")
	    this.display.jq(id+"_from").val(prop.value);
	else if(prop.what == "to")
	    this.display.jq(id+"_to").val(prop.value);
	else {
	    console.log(this.type +" macroChanged:" + prop.value +" " + this.display.jq(id).length);
	    this.display.jq(id).val(prop.value);
	    console.log("after:" + this.display.jq(id).val());
	}
    },
    apply: function(url) {
	if(this.type == "bounds") {
	    if(this.display.getBounds && this.display.jq(this.getId()).is(':checked')) {
		let bounds = this.display.getBounds();
		if(bounds) {
		    bounds = RecordUtil.convertBounds(bounds);
		    ["north","south","east","west"].map(b=>{
			url+="&" + b+"=" +bounds[b];
		    });
		    
		}
	    }
	} else if(this.type=="numeric") {
	    let min = this.display.jq(this.getId()+"_min").val()||"";
	    let max = this.display.jq(this.getId()+"_max").val()||"";
	    this.dflt_min = min;
	    this.dflt_max = max;
	    if(min!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_from",min);
	    if(max!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_to",max);
	    this.display.setProperty("request." +this.name+"_min.default",min);
	    this.display.setProperty("request." +this.name+"_max.default",max);

	} else if(this.type=="date") {
	    let from = this.display.jq(this.getId()+"_from").val()||"";
	    let to = this.display.jq(this.getId()+"_to").val()||"";
	    this.dflt_from = from;
	    this.dflt_to = to;
	    this.display.setProperty("request." +this.name+"_from.default",from);
	    this.display.setProperty("request." +this.name+"_to.default",to);
	    if(from!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_fromdate",from);
	    if(to!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_todate",to);
	    //			    this.display.setProperty(this.name+".default",value);
	} else if(this.type=="enumeration") {
	    let value = this.getValue();
	    if(!Array.isArray(value)) {value=[value];}

	    if(value[0] == "_all_" || value[0] == "_none_" || value[0] == VALUE_NONE) return url;
	    if(value.length>0) {
		let regexp = new RegExp(this.urlarg+"=[^$&]*",'g');
		url = url.replace(regexp,"");
		let values = [];
		value.forEach(v=>{
		    if(this.template) v = this.template.replace(/\${value}/,v);
		    values.push(v);
		});
		if(this.delimiter) {
		    let arg = "";
		    values.forEach((v,idx)=>{
			if(idx>0) arg+=this.delimiter;
			arg+=v;
		    });
		    if(this.multitemplate && values.length>1) {
			arg =this.multitemplate.replace(/\${value}/,arg);
		    }
		    url = url +"&" + HU.urlArg(this.urlarg,arg);
		} else {
		    values.forEach(v=>{
			url = url +"&" + HU.urlArg(this.urlarg,v);
		    });
		}
	    } else {
	    }
	} else {
	    let value = this.getValue();
	    this.dflt  = value;
	    if(value!="") {
		let regexp = new RegExp(this.urlarg+"=[^$&]*",'g');
		url = url.replace(regexp,"");
		url = url +"&" + HU.urlArg(this.urlarg,value);
	    }
	}
	return  url;
    }

}



function RamaddaBounds(north,west,south,east) {
    if(Utils.isDefined(north.north)) {
	let b = north;
	this.north = b.north;
	this.west  = b.west;
	this.south  =b.south;
	this.east = b.east;
    } else if(Utils.isDefined(north.top)) {
	let b = north;
	this.north = b.top;
	this.west  = b.left;
	this.south  =b.bottom;
	this.east = b.right
    }  else { 
	this.north = north;
	this.west  = west;
	this.south  =south;
	this.east = east;
    }
    $.extend(this,{
	toString: function() {
	    return "N:" + this.north +" W:" + this.west +" S:" + this.south +" E:" + this.east;
	}
    });
	      
}


function makeInlineData(display, src) {
    let csv = $("#"+src).html().trim();
    let lines = csv.split("\n");
    let fields = [];
    let samples = lines[1].split(",");
    let latField  =null, lonField=null,dateField=null;
    lines[0].split(",").forEach((tok,idx)=>{
	tok = tok.trim();
	let id = Utils.makeId(tok);
	let label = Utils.makeLabel(tok);
	let type = "string";
	let sample = samples[idx];
	if(display.getProperty(id+".label")) {
	    label =display.getProperty(id+".label");
	}
	if(display.getProperty(id+".type")) {
	    type =  display.getProperty(id+".type");
	    if(type=="enum") type = "enumeration";
	} else {
	    if(id=="date") {
		type="date";
	    } else {
		if(!isNaN(parseFloat(sample))) type = "double";
		//check for numeric
	    }
	}
	let field = new RecordField({
            id:tok,
	    index:idx,
            label:label,
            type:type,
            chartable:true
        });
	fields.push(field);
	if(field.isFieldLatitude()) latField = field;
	else if(field.isFieldLongitude()) lonField = field;
    });
    let records =[];
    lines.forEach((line,idx)=>{
	if(idx==0) return;
	line = line.trim();
	if(line.length==0) return;
	let data =[];
	let lat = NaN;
	let lon = NaN;
	let date = null;
	line.split(",").forEach((tok,col)=>{
	    tok  = tok.replace(/_nl_/g,"\n").replace(/_qt_/g,"\"").replace(/_comma_/g,",");
	    let field = fields[col];
	    if(latField && latField.getIndex()==col) {
		lat = tok = parseFloat(tok);
	    } else  if(lonField && lonField.getIndex()==col) {
		lon = tok = parseFloat(tok);
	    } else  if(dateField && dataField.getIndex()==col) {
		date = tok = new Data(tok);
	    } else {
		if(field.isFieldNumeric()) {
		    tok = parseFloat(tok);
		}
	    }
	    data.push(tok);
	});
	//PointRecord(fields,lat, lon, elevation, time, data)
        records.push(new  PointRecord(fields,lat, lon, NaN, date, data));
    });
    return  new PointData(src, fields, records,"#" + src);
}
/**
   Copyright 2008-2021 Geode Systems LLC
*/


const DISPLAY_LINECHART = "linechart";
const DISPLAY_AREACHART = "areachart";
const DISPLAY_BARCHART = "barchart";
const DISPLAY_BARTABLE = "bartable";
const DISPLAY_BARSTACK = "barstack";
const DISPLAY_PIECHART = "piechart";
const DISPLAY_TIMERANGECHART = "timerangechart";
const DISPLAY_SANKEY = "sankey";
const DISPLAY_CALENDAR = "calendar";
const DISPLAY_SCATTERPLOT = "scatterplot";
const DISPLAY_HISTOGRAM = "histogram";
const DISPLAY_BUBBLE = "bubble";
const DISPLAY_GAUGE = "gauge";
const DISPLAY_TABLE = "table";
const DISPLAY_WORDTREE = "wordtree";
const DISPLAY_TREEMAP = "treemap";
const ID_CHART = "chart";
const ID_CHARTS = "charts";
const ID_CHARTS_INNER = "chartsinner";


var googleChartsLoaded = false;
function googleChartsHaveLoaded() {
    googleChartsLoaded = true;
}
if(window["google"]) {
    google.charts.setOnLoadCallback(googleChartsHaveLoaded);
}

var ramaddaChartsLoaded={};

function ramaddaLoadGoogleChart(display, what) {
    if(!ramaddaChartsLoaded[what]) {
	google.charts.load(HtmlUtils.googleChartsVersion, {
            packages: [what],
	    callback:()=>{
		ramaddaChartsLoaded[what] = true;
		display.updateUI();
	    }
	});
	return false;
    }
    return true;
}


function haveGoogleChartsLoaded() {
    if (!googleChartsLoaded) {
        if (Utils.isDefined(google.visualization)) {
            if (Utils.isDefined(google.visualization.Gauge)) {
                googleChartsLoaded = true;
            }
        }
    }
    return googleChartsLoaded;
}

function waitOnGoogleCharts(object, callback) {
    if (haveGoogleChartsLoaded()) {
	return true;
    }
    if (!object.googleChartCallbackPending) {
        object.googleChartCallbackPending = true;
        let func = function() {
            object.googleChartCallbackPending = false;
            callback();
        }
        setTimeout(func, 100);
    }
    return false;
}


addGlobalDisplayType({
    type: DISPLAY_TABLE,
    label: "Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    desc:"Basic tabular display",
    tooltip: makeDisplayTooltip("Tabular display of data","table.png")                        
}, true);
addGlobalDisplayType({
    type: DISPLAY_LINECHART,
    label: "Line Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip("Basic line chart","linechart.png","Show time series or other data"),
    helpurl:true
});
addGlobalDisplayType({
    type: DISPLAY_BARCHART,
    label: "Bar Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"barchart.png")    
});
addGlobalDisplayType({
    type: DISPLAY_BARSTACK,
    label: "Stacked Bar Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip("Stacked bar chart","barstack.png"),
    helpurl:true    
});
addGlobalDisplayType({
    type: DISPLAY_AREACHART,
    label: "Area Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"areachart.png")    
});

addGlobalDisplayType({
    type: DISPLAY_BARTABLE,
    label: "Bar Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"bartable.png")        
});
addGlobalDisplayType({
    type: DISPLAY_SCATTERPLOT,
    label: "Scatter Plot",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"scatterplot.png")            
});
addGlobalDisplayType({
    type: DISPLAY_HISTOGRAM,
    label: "Histogram",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"histogram.png")                
});
addGlobalDisplayType({
    type: DISPLAY_BUBBLE,
    label: "Bubble Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"bubblechart.png")    
});
addGlobalDisplayType({
    type: DISPLAY_PIECHART,
    label: "Pie Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"piechart.png")                    
});

addGlobalDisplayType({
    type: DISPLAY_GAUGE,
    label: "Gauge",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("A gauge","gauge.png")
});
addGlobalDisplayType({
    type: DISPLAY_TIMERANGECHART,
    label: "Timerange",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Time ranges","timerange.png","Show data with start/end times")    
});
addGlobalDisplayType({
    type: DISPLAY_SANKEY,
    label: "Sankey Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"sankey.png")                                    
});

addGlobalDisplayType({
    type: DISPLAY_CALENDAR,
    label: "Calendar Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Show a calendar","calendar.png")
});
addGlobalDisplayType({
    type: DISPLAY_WORDTREE,
    label: "Word Tree",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Displays data as a tree of words","wordtree.png","Specify a number of fields. Each field value is a level in the tree")    
});
addGlobalDisplayType({
    type: DISPLAY_TREEMAP,
    label: "Tree Map",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip("A tree map","treemap.png")    
});



let PROP_CHART_MIN = "chartMin";
let PROP_CHART_MAX = "chartMax";
let DFLT_WIDTH = "600px";
let DFLT_HEIGHT = "200px";

/*
  Create a chart
  id - the id of this chart. Has to correspond to a div tag id 
  pointData - A PointData object (see below)
*/
function RamaddaGoogleChart(displayManager, id, chartType, properties) {
    const ID_TRENDS_CBX = "trends_cbx";
    const ID_PERCENT_CBX = "percent_cbx";
    const ID_COLORS = "colors";
    const ID_HIGHLIGHTFIELDSHOLDER = "highlightfieldsholder";
    const ID_HIGHLIGHTFIELDS = "highlightfields";	    
    let _this = this;
    //Init the defaults first
    $.extend(this, {
	debugChartOptions:false,
	useTestData:false,	
        indexField: -1,
        curveType: 'none',
        fontSize: 0,
        showPercent: false,
        percentFields: null,
    });
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, chartType, properties);
    let myProps = [
	{label:'Chart Style'},
	{p:'highlightFields',d:null,ex:'fields'},
	{p:'highlightShowFields',d:null,ex:'true'},
	{p:'highlightShowFieldsSize',d:"4",ex:'4'},
	{p:"acceptHighlightFieldsEvent",d:true,ex:'true'},
	{p:'highlightDim',d:'true',ex:'true',tt:'Dim the non highlight lines'},

	{p:'lineDashStyle',d:null,ex:'2,2,20,2,20'},
	{p:'highlight.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},
	{p:'nohighlight.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},	
	{p:'some_field.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},

	{p:'labelInLegend',d:null,ex:'label'},
	{p:'highlight.labelInLegend',d:null,ex:'label'},
	{p:'nohighlight.labelInLegend',d:null,ex:'label'},	
	{p:'some_field.labelInLegend',d:null,ex:'label'},

	{p:'seriesType',d:null,ex:'line|area|bars'},
	{p:'highlight.seriesType',d:null,ex:'line|area|bars'},
	{p:'nohighlight.seriesType',d:null,ex:'line|area|bars'},	
	{p:'some_field.seriesType',d:null,ex:'line|area|bars'},	

	{p:'pointSize',d:null,ex:'0'},
	{p:'highlight.pointSize',d:'0',ex:'4'},
	{p:'nohighlight.pointSize',d:'0',ex:'4'},	
	{p:'some_field.pointSize',d:'4',ex:'4'},

	{p:'lineWidth',d:null,ex:null},
	{p:'highlight.lineWidth',d:null,ex:'2'},
	{p:'nohighlight.lineWidth',d:null,ex:'2'},	
	{p:'some_field.lineWidth',d:'2',ex:'2'},

	{p:'highlight.color',d:null,ex:null},
	{p:'nohighlight.color',d:null,ex:null},
	{p:'some_field.color',d:null,ex:null},

	{p:'pointShape',d:null,ex:null},
	{p:'highlight.pointShape',d:null,ex:null},
	{p:'nohighlight.pointShape',d:null,ex:null},	
	{p:'some_field.pointShape',d:null,ex:null},

	{label:'Trendlines'},
	{p:'showTrendline',d:null,ex:"true"},
	{p:"trendlineType",ex:"exponential"},
	{p:"trendlineVisibleInLegend",ex:"true"},
	{p:"trendlineColor",ex:""},
	{p:"trendlineLineWidth",ex:"true"},
	{p:"trendlineOpacity",ex:"0.3"}		    		    		    
    ];
    this.debugTimes = false;


    defineDisplay(this, SUPER, myProps, {
	checkFinished: function() {
	    return true;
	},
	useDisplayMessage:function() {
	    return true;
	},
	//Override so we don't include the expandable class
	getContentsClass: function() {
	    return "display-contents-inner display-" + this.type;
	},

        useChartableFields: function() {
            return true;
        },
        defaultSelectedToAll: function() {
            return false;
        },
        updateUI: function(args) {
	    let debug = false;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	    if(debug)
		console.log(this.type+".updateUI")
            if (!this.getDisplayReady()) {
		if(debug)
		    console.log("\tdisplay not ready");
                return;
            }
	    if(debug)
		console.log("\tcalling displayData");
	    if(args.dataFilterChanged) {
		this.setDisplayMessage(this.getLoadingMessage());
		setTimeout(()=>{
		    this.displayData(args.reload, debug);
		},1);
		return;
	    }
            this.displayData(args.reload, debug);
        },
        getWikiAttributes: function(attrs) {
            this.defineWikiAttributes(["vAxisMinValue", "vAxisMaxValue"]);
            SUPER.getWikiAttributes.call(this, attrs);
            if (this.colorList.join(",") != "blue,red,green") {
                attrs.push("colors");
                attrs.push(this.getColorList().join(", "));
            }
        },

        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function(e) {
                if (e && e.which != 13 && e.which!=0) {
                    return;
                }
                _this.vAxisMinValue = Utils.toFloat(_this.jq("vaxismin").val());
		//		console.log("vaxis:" + _this.vAxisMinValue + " " + this.getVAxisMinValue());
                _this.vAxisMaxValue = Utils.toFloat(_this.jq("vaxismax").val());
                _this.minDate = _this.jq("mindate").val();
                _this.maxDate = _this.jq("maxdate").val();
                _this.displayData();

            };
	    ["vaxismin","vaxismax","mindate","maxdate"].map(f=>{
		this.jq(f).blur(updateFunc);
		this.jq(f).keypress(updateFunc);
	    });



            this.jq(ID_COLORS).keypress(function(e) {
                if (e.which != 13) {
                    return;
                }
                let v = _this.jq(ID_COLORS).val();
                _this.colorList = v.split(",");
                _this.displayData();
                let pointData = _this.dataCollection.getList();
                _this.getDisplayManager().handleEventPointDataLoaded(_this, _this.lastPointData);
            });

            this.jq(ID_TRENDS_CBX).click(function() {
                _this.showTrendLines = _this.jq(ID_TRENDS_CBX).is(':checked');
                _this.displayData();

            });
            this.jq(ID_PERCENT_CBX).click(function() {
                _this.showPercent = _this.jq(ID_PERCENT_CBX).is(':checked');
                _this.displayData();

            });

        },
        setColor: function() {
            let v = prompt("Enter comma separated list of colors to use", this.colorList.join(","));
            if (v != null) {
                this.colorList = v.split(",");
                this.displayData();
                let pointData = this.dataCollection.getList();
                this.getDisplayManager().handleEventPointDataLoaded(this, this.lastPointData);
            }
        },
        getVAxisMinValue: function() {
            return parseFloat(this.getProperty("vAxisMinValue", NaN));
        },
        getVAxisMaxValue: function() {
            return parseFloat(this.getProperty("vAxisMaxValue", NaN));
        },
	getHAxisMinValue: function() {
            return parseFloat(this.getProperty("hAxisMinValue", NaN));
        },
        getHAxisMaxValue: function() {
            return parseFloat(this.getProperty("hAxisMaxValue", NaN));
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            //                menuItems.push(HU.onClick(get+".setColor();", "Set color"));

            let min = "0";
            if (!isNaN(this.getVAxisMinValue())) {
                min = "" + this.getVAxisMinValue();
            }
            let max = "";
            if (!isNaN(this.getVAxisMaxValue())) {
                max = "" + this.getVAxisMaxValue();
            }

            let tmp = HU.formTable();
            tmp += HU.formEntry("Axis Range:", HU.input("", min, ["size", "7", ATTR_ID, this.domId("vaxismin")]) + " - " +
				HU.input("", max, ["size", "7", ATTR_ID, this.domId("vaxismax")]));
            tmp += HU.formEntry("Date Range:", HU.input("", this.minDate, ["size", "10", ATTR_ID, this.domId("mindate")]) + " - " +
				HU.input("", this.maxDate, ["size", "10", ATTR_ID, this.domId("maxdate")]));


            tmp += HU.formEntry("Colors:",
				HU.input("", this.getColorList().join(","), ["size", "35", ATTR_ID, this.domId(ID_COLORS)]));
            tmp += "</table>";
            menuItems.push(tmp);

        },
        getChartType: function() {
            return this.getType();
        },
        askMinZAxis: function() {
            this.setMinZAxis(prompt("Minimum axis value", "0"));
        },
        setMinZAxis: function(v) {
            if (v != null) {
                this.vAxisMinValue = parseFloat(v);
                this.displayData();
            }
        },
        askMaxZAxis: function() {
            this.setMaxZAxis(prompt("Maximum axis value", "100"));
        },
        setMaxZAxis: function(v) {
            if (v != null) {
                this.vAxisMaxValue = parseFloat(v);
                this.displayData();
            }
        },
        askMinDate: function() {
            let ex = this.minDate;
            if (ex == null || ex == "") {
                ex = "1800-01-01";
            }
            let v = prompt("Minimum date", ex);
            if (v == null) return;
            this.setMinDate(v);
        },
        setMinDate: function(v) {
            this.minDate = v;
            this.displayData();
        },
        askMaxDate: function() {
            let ex = this.maxDate;
            if (ex == null || ex == "") {
                ex = "2100-01-01";
            }
            let v = prompt("Maximum date", ex);
            if (v == null) return;
            this.setMaxDate(v);
        },
        setMaxDate: function(v) {
            this.maxDate = v;
            this.displayData();
        },
        trendLineEnabled: function() {
            return false;
        },
        getDialogContents: function(tabTitles, tabContents) {
            let height = "600";
            let html = HU.div([ATTR_ID, this.domId(ID_FIELDS), STYLE, HU.css('overflow-y','auto','max-height', height + "px")], " FIELDS ");
            if (this.trendLineEnabled()) {
                html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Other");

                html += HU.checkbox(this.domId(ID_TRENDS_CBX),
				    [],
				    this.getProperty("showTrendLines", false)) + "  " + "Show trend line";
                html += " ";
                html += HU.checkbox(this.domId(ID_PERCENT_CBX),
				    [],
				    this.showPercent) + "  " + "Show percent of displayed total" + "<br>";
                html += "<br>";
            }

            tabTitles.push("Fields");
            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },
        okToHandleEventRecordSelection: function() {
            return true;
        },
        handleEventRecordHighlight: function(source, args) {
	    this.handleEventRecordSelection(source, args);
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
            //TODO: don't do this in index space, do it in time or space space
            if (source == this) {
                return;
            }
            if (!this.okToHandleEventRecordSelection()) {
                return;
	    }
	    let index = this.findMatchingIndex(args.record).index
	    if(index<0 || !Utils.isDefined(index)) {
		return;
	    }
	    this.setChartSelection(index);
        },
        getFieldsToSelect: function(pointData) {
            //STRING return pointData.getChartableFields();
	    return pointData.getRecordFields();
        },
        canDoGroupBy: function() {
            return false;
        },
        clearCache: function() {
        },
        googleChartCallbackPending: false,
        includeIndexInData: function() {
            return false;
        },
        getGroupBy: function() {
            return this.getProperty("groupByField");
        },
        getIncludeIndexIfDate: function() {
            return false;
        },
	makeIndexValue: function(indexField, value, offset) {
	    if(indexField.isString()) {
		return  {v:offset,f:value};
	    } 
	    if(value && value.getTime) {
		return  {v:value,f:this.formatDate(value)}
	    }
	    return value;
	},
	getFieldsToDisplay: function(fields) {
	    return fields;
	},

        displayData: function(reload, debug) {
	    if(debug)
		console.log(this.type +" displayData " + this.getId() +" " + this.type);

	    let isExpanded = this.jq(ID_CHART).attr("isexpanded");
	    let originalHeight = this.jq(ID_CHART).attr("original-height");
	    if(isExpanded==="true") {
		this.setProperty("expandedHeight",this.jq(ID_CHART).css("height"));
		this.setProperty("isExpanded",true);
		this.setProperty("originalHeight",originalHeight);
	    } else {
		this.setProperty("expandedHeight",null);
		this.setProperty("isExpanded",false);
		this.setProperty("originalHeight",null);
	    }
            if (!this.getDisplayReady()) {
		if(debug)
		    console.log("\tdisplay not ready");
                return;
            }
            if (this.inError) {
		if(debug)
		    console.log("\tin error");
                return;
            }
            if (!haveGoogleChartsLoaded()) {
		if(debug)
		    console.log("\tgoogle charts have not loaded callback pending:" +this.googleChartCallbackPending);
                if (!this.googleChartCallbackPending) {
                    this.googleChartCallbackPending = true;
		    this.setDisplayMessage(this.getLoadingMessage());
                    setTimeout(()=> {
                        this.googleChartCallbackPending = false;
                        this.displayData();
                    }, 100);
                }
                return;
            }
            if (this.inError) {
                return;
            }
            if (!this.hasData()) {
                this.clearChart();
		this.setDisplayMessage(this.getLoadingMessage());
                return;
            }

	    if(!this.getAcceptEventDataSelection()) {
		this.setDisplayMessage("Creating display...");
	    }


            //            let selectedFields = this.getSelectedFields(this.getFieldsToSelect(pointData));
	    let records =this.filterData();
            let selectedFields = this.getSelectedFields();
	    if(debug)
		console.log("\tpointData #records:" +records.length);


	    if(debug)
		console.log("\tselectedFields:" + selectedFields);

            if (selectedFields.length == 0 && this.lastSelectedFields != null) {
                selectedFields = this.lastSelectedFields;
		if(debug)
		    console.log("\tusing last selectedFields:" + selectedFields);
            }


            if (selectedFields == null || selectedFields.length == 0) {
                if (this.getChartType() == DISPLAY_TABLE || this.getChartType() == DISPLAY_TREEMAP) {
                    selectedFields = this.dataCollection.getList()[0].getNonGeoFields();
		    if(debug)
			console.log("\tfields from data collection:" + selectedFields);
                } else {
                    selectedFields = this.getSelectedFields();
		    if(debug)
			console.log("\tgetSelectedFields again:" + selectedFields);
		    
                    selectedFields = this.getSelectedFields();
		    if(selectedFields.length==0) {
			this.getFields().every(f=>{
			    if(f.isNumeric() && !f.isFieldGeo()) {
				selectedFields = [f];
				return false;
			    }
			    return true;
			});

		    }
                }
            }


            if (selectedFields.length == 0) {
		if(!this.getAcceptEventDataSelection()) {
//                    this.setContents("No fields selected");
		    this.setDisplayMessage("No fields selected");
		}
                return;
            }

            //Check for the skip
            let tmpFields = [];
            for (let i = 0; i < selectedFields.length; i++) {
                if (!this.shouldSkipField(selectedFields[i])) {
                    tmpFields.push(selectedFields[i]);
                }
            }
            selectedFields = tmpFields;
	    if(debug)
		console.log("\tsetting lastSelectedFields:" + selectedFields);
            this.lastSelectedFields = selectedFields;
	    //Do this here because the title, if displayed, may hold a {field} macro
	    //that doesn't get set before we've loaded the data
	    if(this.lastSelectedFields && this.lastSelectedFields.length>0) {
		this.jq(ID_TITLE_FIELD).html(this.lastSelectedFields[0].getLabel());
	    }

            let props = {
                includeIndex: this.includeIndexInData()
            };
            props.groupByIndex = -1;

            let groupBy = this.getGroupBy();
            if (groupBy) {
		this.getFields().every(field=>{
                    if (field.getId() == groupBy) {
                        props.groupByIndex = field.getIndex();
                        props.groupByField = field;
			return false;
                    }
		    return true;
                });
            }

            let fieldsToSelect = selectedFields;
            if (this.raw) {
                fieldsToSelect = this.dataCollection.getList()[0].getRecordFields();
                props.raw = true;
            }

            props.includeIndexIfDate = this.getIncludeIndexIfDate();

            let dataHasIndex = props.includeIndex;

	    let t1= new Date();
            let dataList = this.getStandardData(this.getFieldsToDisplay(fieldsToSelect), props);
	    let t2= new Date();
	    if(this.debugTimes)
		Utils.displayTimes("chart.getStandardData",[t1,t2],true);
	    if(debug)
		console.log(this.type +" fields:" + fieldsToSelect.length +" dataList:" + dataList.length);
            if (dataList.length == 0 && !this.userHasSelectedAField) {
                let pointData = this.dataCollection.getList()[0];
                let chartableFields = this.getFieldsToSelect(pointData);
                for (let i = 0; i < chartableFields.length; i++) {
                    let field = chartableFields[i];
                    dataList = this.getStandardData([field], props);
                    if (dataList.length > 0) {
                        this.setSelectedFields([field]);
                        break;
                    }
                }
            }

            if (dataList.length == 0) {
		this.setContents(this.getMessage(this.getNoDataMessage()));
//                this.setDisplayMessage(this.getNoDataMessage());
                return;
            }

            if (this.showPercent) {
                let newList = [];
                let isNumber = [];
                let isOk = [];
                let headerRow = null;
                let fields = null;
                if (this.percentFields != null) {
                    fields = this.percentFields.split(",");
                }
                for (let i = 0; i < dataList.length; i++) {
                    let row = this.getDataValues(dataList[i]);
                    if (i == 0) {
                        headerRow = row;
                        continue;
                    }
                    if (i == 1) {
                        let seenIndex = false;
                        for (let j = 0; j < row.length; j++) {
                            let valueIsNumber = (typeof row[j] == "number");
                            let valueIsDate = (typeof row[j] == "object");
                            if (valueIsNumber) {
                                if (dataHasIndex && !seenIndex) {
				    valueIsNumber = false;
                                    seenIndex = true;
                                }
                            }
                            if (valueIsDate) {
                                seenIndex = true;
                            }
                            if (valueIsNumber && fields != null) {
                                valueIsNumber = fields.indexOf(fieldsToSelect[j].getId()) >= 0 ||
                                    fields.indexOf("#" + (j + 1)) >= 0;
                            }
                            isNumber.push(valueIsNumber);
                        }
                        let newHeader = [];
                        for (let j = 0; j < headerRow.length; j++) {
                            let v = headerRow[j];
                            if (!isNumber[j]) {
                                newHeader.push(v);
                            } else {
                                newHeader.push("% " + v);
                            }
                        }
                        newList.push(newHeader);
                    }

                    let total = 0;
                    let cnt = 0;
                    for (let j = 0; j < row.length; j++) {
                        if (isNumber[j]) {
                            total += parseFloat(row[j]);
                            cnt++;
                        }
                    }
                    let newRow = [];
                    for (let j = 0; j < row.length; j++) {
                        if (isNumber[j]) {
                            if (total != 0) {
                                let v = parseFloat(((row[j] / total) * 100).toFixed(1));
                                newRow.push(v);
                            } else {
                                newRow.push(NaN);
                            }
                        } else {
                            newRow.push(row[j]);
                        }
                    }
                    newList.push(newRow);
                }
                dataList = newList;
            }
            try {
		this.clearDisplayMessage();
		let tt1 =new Date();
                this.makeGoogleChart(dataList, props, selectedFields);
		let tt2 =new Date();
		if(this.debugTimes)
		    Utils.displayTimes("chart.makeGoogleChart",[tt1,tt2],true);
            } catch (e) {
		this.handleError("Error making chart:" + e,e);
		this.setIsFinished();
                return;
            }
	    this.setIsFinished();
            let container = this.jq(ID_CHART);
	    if(this.jq(ID_CHART).is(':visible')) {
		this.lastWidth = container.width();
	    } else {
		this.lastWidth = -1;
	    }

	    if(reload) {
		let pointData = this.getData();
		if(pointData) {
		    let dataList = pointData.getRecords();
		    if(dataList.length>0) {
			let record = dataList[0];
			this.propagateEventRecordSelection({record: record});
		    }
		}
	    }
        },
        printDataList: function(dataList) {
            console.log("data list:" + dataList.length);
            for (let i = 0; i < dataList.length; i++) {
                let row = dataList[i];
                let s = "";
                for (let j = 0; j < row.length; j++) {
                    if (j > 0) s += ", ";
                    s += row[j];
                }
                console.log("row: " + i + "  " + s);
            }
        },
	mapCharts: function(func) {
            if (this.charts != null) {
		this.charts.map(chart=>{
		    func(chart);
		});
	    }
	},
        clearChart: function() {
	    this.mapCharts(chart=>{
		if(chart.clearChart) {
		    chart.clearChart();
		}
	    });
        },
        setChartSelection: function(index) {
	    this.mapCharts(chart=>{
                if (chart.setSelection) {
		    chart.setSelection([{
                        row: index,
			column:null
		    }]);
		}});
        },
        tableHeaderMouseover: function(i, tooltip) {},
	doAddTooltip: function() {
	    return true;
	},
	getAddStyle: function() {
	    return true;
	},
	getAnnotationTemplate: function() {
	    return this.getProperty("annotationTemplate");
	},
	getFormatNumbers: function() {
	    return false;
	},
        getDataTableValueGetter: function() {
	    return (v)=>{return v;}
	},
	getHighlightFields:function() {
	    let p = this.getPropertyFromUrl("highlightFields");
	    return  Utils.split(this.getPropertyFromUrl("highlightFields"),",",true,true)||[];
	},
        handleEventPropertyChanged: function(source, prop) {
	    if(prop.property == "highlightFields") {
		if(this.getProperty("acceptHighlightFieldsEvent",true)) {
		    this.setProperty("highlightFields",prop.value);
		    this.forceUpdateUI();
		    let v = Utils.split(prop.value,",",true,true);
		    this.jq(ID_HIGHLIGHTFIELDS).val(v);
		}
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this, source,prop);
	},
	makeSeriesInfo: function(dataTable) {
	    let seriesNames =[];
	    //Assume first one is the index
	    for(let i=1;i<dataTable.getNumberOfColumns();i++) {
		//Styles, etc
		if(dataTable.getColumnRole(i)!="") continue;
		seriesNames.push(dataTable.getColumnLabel(i));
	    }
	    let colors = this.getColorList();
	    let highlightMap  ={};
	    let highlightFields = this.getHighlightFields();
	    let highlightDim = this.getProperty("highlightDim",false);
	    highlightFields.forEach(f=>{highlightMap[f] = true});
	    let seriesInfo = {};
            let useMultipleAxes = this.getProperty("useMultipleAxes", true);
	    seriesNames.forEach((name,idx)=>{
		name = name.replace(/\(.*\)/g,"");
		let id = Utils.makeId(name);
		let highlight = highlightMap[id];
		let s = {
		};
		["labelInLegend ", "seriesType","lineDashStyle","pointSize", "lineWidth","color","pointShape"].forEach(a=>{
		    let dflt = this.getProperty((highlight?"highlight.":"nohighlight.") + a,this.getProperty(a));
		    let value = this.getProperty(id+"." + a,dflt);
		    if(value && a=="lineDashStyle") {
			let tmp = [];
			Utils.split(value,",",true,true).forEach(tok=>{
			    tmp.push(parseFloat(tok));
			});
			value=tmp;
		    }
		    if(a=="seriesType") a = "type";
		    s[a] = value;
		});
		if(!s.color) s.color = colors[idx%colors.length];
		if(highlightFields.length>0) {
		    if(!highlight && highlightDim) {
			s.color = Utils.pSBC(0.75,s.color);
		    }
		}
		if (useMultipleAxes) {
		    if(idx%2==0) {
			s.targetAxisIndex=0;
		    }  else  {
			s.targetAxisIndex=1;
		    }
		}
		seriesInfo[idx] = s;
	    });


	    if(this.getProperty("highlightShowFields",false)) {
		if(this.jq(ID_HIGHLIGHTFIELDSHOLDER).length==0) {
		    this.jq(ID_HEADER2).append(HU.span([ID,this.domId(ID_HIGHLIGHTFIELDSHOLDER)]));
		}
		
		if(this.jq(ID_HIGHLIGHTFIELDS).length==0) {
		    let seriesValues = [];
		    seriesNames.forEach(n=>{
			seriesValues.push([Utils.makeId(n),n]);
		    });
		    seriesValues.sort((a,b)=>{
			return a[1].localeCompare(b[1]);
			
		    });
		    let highlightWidget = SPACE + HU.vbox(["Highlight",
							  HU.select("",[ID,this.domId(ID_HIGHLIGHTFIELDS),"multiple","true","size",this.getProperty("highlightShowFieldsSize","3")],seriesValues,highlightFields)]);
		    let select =  HU.span([CLASS,"display-filter",STYLE,""],highlightWidget);
		    this.jq(ID_HIGHLIGHTFIELDSHOLDER).html(select);
		    this.jq(ID_HIGHLIGHTFIELDS).change(()=>{
			let v = Utils.makeArray(this.jq(ID_HIGHLIGHTFIELDS).val());
			v = Utils.join(v,",");
			this.setProperty("highlightFields",v);
			this.addToDocumentUrl("highlightFields",v);
			this.forceUpdateUI();
			let props = {
			    property: "highlightFields",
			    value:v
			};
			this.propagateEvent(DisplayEvent.propertyChanged, props);
		    });
		}
	    }
	    //	    console.log(JSON.stringify(seriesInfo,null,2));
	    return seriesInfo;
	},
	    
	makeTrendlinesInfo: function(dataTable) {
	    let seriesNames =[];
	    //Assume first one is the index
	    for(let i=1;i<dataTable.getNumberOfColumns();i++) {
		//Styles, etc
		if(dataTable.getColumnRole(i)!="") continue;
		seriesNames.push(dataTable.getColumnLabel(i));
	    }
	    let trendlinesInfo = {};
	    seriesNames.forEach((name,idx)=> {
		let id = Utils.makeId(name);
		if(this.getProperty("showTrendline." + id, this.getProperty("showTrendline"))) {
		    let s = {
		    };
		    trendlinesInfo[idx] = s;
		    s.type = this.getProperty("trendlineType." + id,this.getProperty("trendlineType"));
		    s.visibleInLegend = this.getProperty("trendlineVisibleInLegend." + id,this.getProperty("trendlineVisibleInLegend"));
		    s.color = this.getProperty("trendlineColor." + id,this.getProperty("trendlineColor"));
		    s.lineWidth = this.getProperty("trendlineLineWidth." + id,this.getProperty("trendlineLineWidth"));
		    s.opacity = this.getProperty("trendlineOpacity." + id,this.getProperty("trendlineOpacity"));		    		    		    
		}
	    });
	    return trendlinesInfo;
	},
        makeDataTable: function(dataList, props, selectedFields, chartOptions) {
	    this.getPropertyCount=0;
	    this.getPropertyCounts={};

	    let dateType = this.getProperty("dateType","date");
	    let debug =    false || displayDebug.makeDataTable;
	    let debugRows = 4;
	    if(debug) console.log(this.type+" makeDataTable #records" + dataList.length);
	    if(debug) console.log("\tfields:" + selectedFields);
	    let maxWidth = this.getProperty("maxFieldLength",this.getProperty("maxFieldWidth",-1));
	    let tt = this.getProperty("tooltip");
	    let addTooltip = (tt || this.getProperty("addTooltip",false)) && this.doAddTooltip();
	    
    	    let addStyle= this.getAddStyle();
	    let annotationTemplate = this.getAnnotationTemplate();
	    let formatNumbers = this.getFormatNumbers();


            if (dataList.length == 1) {
		return google.visualization.arrayToDataTable(this.makeDataArray(dataList));
            }

	    let groupField = this.getFieldById(null,  this.getProperty("groupBy"));
	    if(groupField) {
		dataList = this.filterData();
		let groupedData =[];
		let groupValues = [];
		let seen = {};
		let cnt =0;
		let dateToValue =  {};
		let dates = [];
		if(debug)console.log("record[0]:" + dataList[0]);

		dataList.map((record,idx)=>{
		    if(cnt++==0) return;
		    let values = this.getDataValues(record);
		    let value = values[groupField.getIndex()];
		    if(!seen[value]) {
			seen[value]  = true;
			seen[Utils.makeId(value)]  = true;			
			groupValues.push(value);
		    }
		    let newValues =dateToValue[record.getDate()];
		    if(!newValues) {
			dates.push(record.getDate());
			newValues = {};
			dateToValue[record.getDate()] = newValues;
		    }
		    newValues[value] = values[selectedFields[0].getIndex()];
		});

		let data = [];
		let tmp = [];
		let highlightFields = this.getHighlightFields();
		let tmpMap ={};
		highlightFields.forEach(f=>{
		    if(seen[f]) {
			tmp.push(Utils.makeLabel(f));
		    }
		});

		groupValues = Utils.mergeLists(tmp,groupValues);
		groupValues = groupValues.filter(v=>{
		    if(tmpMap[v]) return false;
		    tmpMap[v] = true;
		    return true;
		});
		dates.map(date=>{
		    let tuple=[this.getDateValue(date)];
		    data.push(tuple);
		    let valueMap = dateToValue[date];
		    groupValues.map(group=>{
			let value = valueMap[group];
			tuple.push(value);
		    });
		});

		let header = Utils.mergeLists(["Date"],groupValues);
		if(debug)console.log("header:" + header);
		let dataTable = new google.visualization.DataTable();
		if(data.length>0) {
		    //TODO: figure out type of columns with null values
		    let tuple = data[0];
		    tuple.forEach((t,idx)=>{
			let name = header[idx];
			let type = t==null?"number":(typeof t);
			if(type =="number") {
			    if(debug)console.log("column:" + name+ " type: number");
			    dataTable.addColumn("number", name);
			} else if(type =="string") {
			    if(debug)console.log("column:" + name+ " type: string");
			    dataTable.addColumn("string", name);
			} else if(t.getTime || (t.v && t.v.getTime)) {
			    if(debug)console.log("column:" + name+ " type: date");
			    dataTable.addColumn("date", name);
			} else {
			    console.log("Unknown type:" + t);
			    console.log(JSON.stringify(t,null,2));
			}
		    });
		}
		dataTable.addRows(data);
		if(chartOptions) {
		    chartOptions.series = this.makeSeriesInfo(dataTable);
		    chartOptions.trendlines = this.makeTrendlinesInfo(dataTable);		    
		}
		return dataTable;
	    }

            let justData = [];
            let tooltipFields = this.getFieldsByIds(null,this.getProperty("tooltipFields", ""));
            let dataTable = new google.visualization.DataTable();
            let header = this.getDataValues(dataList[0]);
            let sample = this.getDataValues(dataList[1]);
	    let fixedValueS = this.getProperty("fixedValue");
	    let fixedValueN;
	    if(fixedValueS) fixedValueN = parseFloat(fixedValueS);
	    let fIdx = 0;
	    let indexIsString = this.getProperty("indexIsString", this.getProperty("forceStrings",false));
	    let maxHeaderLength = this.getProperty("maxHeaderLength",-1);
	    let maxHeaderWidth = this.getProperty("maxHeaderWidth",-1);
	    let headerStyle= this.getProperty("headerStyle");



            for (let j = 0; j < header.length; j++) {
		let field=null;
		if(j>0 || !props.includeIndex) {
		    field = selectedFields[fIdx++];
		} else {
		    //todo?
		}
                let value = sample[j];
		let headerLabel = header[j];
		if(maxHeaderLength>0 && headerLabel.length>maxHeaderLength) {
		    let orig = headerLabel;
		    headerLabel = headerLabel.substring(0,maxHeaderLength-1)+"...";
		    headerLabel = HU.span([TITLE,orig], headerLabel);
		}
		if(maxHeaderWidth>0 || headerStyle) {
		    let orig = headerLabel;
		    let style = "";
		    if(maxHeaderWidth>0)
			headerLabel = headerLabel.replace(/ /g,"&nbsp;");
		    if(maxHeaderWidth>0)
			style+="max-width:" + maxHeaderWidth +"px;overflow-x:auto;";
		    if(headerStyle)
			style+=headerStyle;
		    headerLabel = HU.div([TITLE,orig,STYLE,style], headerLabel);
		} 

                if (j == 0 && props.includeIndex) {
                    //This might be a number or a date
                    if ((typeof value) == "object") {
                        //assume its a date
 			if(typeof value.v == "number") {
			    if(indexIsString) 
				dataTable.addColumn('string', headerLabel);
			    else {
				dataTable.addColumn('number', headerLabel);
			    }
			} else {
			    dataTable.addColumn(dateType, headerLabel);
			}
                    } else {
                        dataTable.addColumn((typeof value), headerLabel);
                    }
                } else {
		    if(j>0 && fixedValueS) {
			dataTable.addColumn('number', this.getProperty("fixedValueLabel","Count"));
		    } else {
			if(field.isString()) {
			    dataTable.addColumn('string', headerLabel);
			} else if(field.isFieldDate()) {
			    dataTable.addColumn(dateType, headerLabel);
			} else {
			    dataTable.addColumn('number', headerLabel);
			}
		    }
		    if(annotationTemplate) {
			dataTable.addColumn({
			    type: 'string',
			    role: 'annotation',
			    'p': {
				'html': true
			    }
			});
		    }

		    if(addStyle) {
			if(debug)
			    console.log("add style column");
			dataTable.addColumn({ type: 'string', role: 'style' });
		    }
		    if(j>0 && fixedValueS) {
			break;
		    }
                }
	    }

	    if(addTooltip) {
		if(debug)
		    console.log("add tooltip column");
		dataTable.addColumn({
                    type: 'string',
                    role: 'tooltip',
                    'p': {
			'html': true
                    }
		});
	    }


	    if(debug) {
		for(let i=0;i<dataTable.getNumberOfColumns();i++)
		    console.log("col[" + i +"]=" + dataTable.getColumnLabel(i) +" " + dataTable.getColumnType(i));
	    }
	    if(this.getProperty("annotations") ||  this.getProperty("annotationFields")) {
		let clonedList = Utils.cloneList(dataList);
		clonedList.shift();
		this.annotations  = new Annotations(this,clonedList);
		if(this.annotations.hasFields()) {
                    dataTable.addColumn({
			type: 'string',
			role: 'annotation',
			'p': {
                            'html': true
			}
                    });
		    dataTable.addColumn({
			type: 'string',
			role: 'annotationText',
			'p': {
                            'html': true
			}
                    });
		}
	    }

	    if(this.annotations && this.annotations.isEnabled()) {
		if(this.annotations.getShowLegend()) {
		    //Pad the left to align with  the chart axis
		    this.jq(ID_LEGEND).html("<table width=100%><tr valign=top><td width=10%></td><td width=90%>" +
					    HU.div([CLASS, "display-chart-legend"],this.annotations.getLegend())
					    +"</td></tr></table>");
		}
		dataTable.addColumn({
                    type: 'string',
                    role: 'annotation',
                    'p': {
                        'html': true
                    }
                });
		dataTable.addColumn({
                    type: 'string',
                    role: 'annotationText',
                    'p': {
                        'html': true
                    }
                });
	    }


	    let annotationCnt=0;
	    let times = [new Date()];
	    let records = [];
            for (let i = 1; i < dataList.length; i++) {
		records.push(dataList[i].record);
	    }
	    let colors =  this.getColorTable(true);
            let colorBy = this.getColorByInfo(records);
	    let valueGetter = this.getDataTableValueGetter(records);
	    let didColorBy = false;
	    let tuples = [];
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
		let record =dataList[rowIdx];
                let row = this.getDataValues(record);
		//		let index = row[0];
		//		if(index.v) index  = index.v;
		let theRecord = record.record;
		let color = "";
                if (colorBy.index >= 0) {
                    let value = theRecord.getData()[colorBy.index];
		    hasColorByValue  = true;
		    colorByValue = value;
                    didColorBy = true;
		    color =  colorBy.getColorFromRecord(theRecord);
                }

                row = row.slice(0);


                let newRow = [];
		if(debug && rowIdx<debugRows)
		    console.log("row[" + rowIdx+"]:");

		let fIdx=0;
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
		    let field = selectedFields[fIdx++];
                    let value = row[colIdx];
		    if(indexIsString) {
			if(value.f) value = (value.f).toString().replace(/\n/g, " ");
		    }
		    if(colIdx>0 && fixedValueS) {
			newRow.push(valueGetter(fixedValueN, colIdx, field, theRecord));
			if(debug && rowIdx<debugRows)
			    console.log("\t fixed:" + fixedValueN);
		    } else {
			let type = (typeof value);
			if(type == "number") {
                            if(formatNumbers) {
				value = {v:value,f:String(this.formatNumber(value))};
			    }
			}  else if(type=="boolean") {
			    value = String(value);
			}
			if(debug && rowIdx<debugRows) {
			    let v = value.f?("f:" + value.f +" v:" +value.v):value;
			    console.log("\t value[" + colIdx +"]="+ v +" " + (typeof value));
			}
			if(maxWidth>0 && type == "string" && value.length > maxWidth)
			    value = value.substring(0,maxWidth) +"...";
			let o = valueGetter(value, colIdx, field, theRecord);
			newRow.push(o);
		    }
                    if (colIdx == 0 && props.includeIndex) {
			/*note to self - an inline comment breaks the minifier 
			  if the index so don't add a tooltip */
                    } else {
			if(annotationTemplate) {
			    let v = annotationTemplate.replace("${value}",value.f||value);
			    if(debug && rowIdx<debugRows)
				console.log("\t annotation" + v);
			    newRow.push(v);
			}
			if(addStyle) {
			    newRow.push(color);
			    if(debug && rowIdx<debugRows)
				console.log("\t color:" + color);
			    //			    if(debug && rowIdx<debugRows)
			    //				console.log("\t style:" + color);
			}
                    }
		    if(colIdx>0 && fixedValueS) {
			break;
		    }
		}


		if(addTooltip) {
		    let tooltip = "";
		    if(tt) {
			tooltip  = this.getRecordHtml(theRecord,null,tt);
		    } else {
			let label = "";
			if (theRecord) {
			    for (let j = 0; j < tooltipFields.length; j++) {
				label += "<b>" + tooltipFields[j].getLabel() + "</b>: " +
				    theRecord.getValue(tooltipFields[j].getIndex()) + "<br>";
			    }
			}
			tooltip += label;
			for (let j = 0; j < row.length; j++) {
			    if (j > 0)
				tooltip += "<br>";
			    label = header[j].replace(/ /g, "&nbsp;");
			    value = row[j];
			    if (!Utils.isDefined(value)) value = "NA";
			    if (value && value.f) {
				value = value.f;
			    }
			    
			    if (Utils.isNumber(value)) {
				value = this.formatNumber(value);
			    }
			    value = "" + value;
			    value = value.replace(/ /g, SPACE);
			    tooltip += HU.b(label) + ":" + SPACE + value;
			}
		    }
		    tooltip = HU.div([STYLE,HU.css('padding','8px')],tooltip);
                    newRow.push(tooltip);
		    if(debug && rowIdx<debugRows)
			console.log("\t tooltip:");
		}


		if(this.annotations && this.annotations.hasFields()) {
                    if (theRecord) {
			let desc = "";
			this.annotations.getFields().forEach(f=>{
			    let d = ""+theRecord.getValue(f.getIndex());
			    if(d!="")
				desc+= (d+"<br>");
			});
			desc = desc.trim();
			desc = desc.replace(/ /g,"&nbsp;");
			annotationCnt++;
			let label = null; 
			if(desc.trim().length>0) {
			    label =""+( this.annotations.labelField?theRecord.getValue(this.annotations.labelField.getIndex()):(annotationCnt))
			    if(label.trim().length==0) label = ""+annotationCnt;
			}
			debug =true;
			if(debug && rowIdx<debugRows) {
			    console.log("\t label:" + label);
			    console.log("\t desc:" + desc);
			}
			debug =false;
			console.log("A2:" +label);
			newRow.push(label);
			newRow.push(desc);
		    } else {
			if(i<2)
			    console.log("No records for annotation");
		    }
		}
		if(this.annotations &&  this.annotations.isEnabled()) {
		    let annotations = this.annotations.getAnnotationsFor(rowIdx);
		    if(annotations) {
			if(debug && rowIdx<debugRows) {
			    console.log("\t annotation:" + annotations);
			}
			let label = "";
			let desc = "";
			annotations.forEach(a=>{
			    if(label!="") label+="/";
			    label+=a.label;
			    if(desc!="") desc+="<br>";
			    else {
				if(a.record && a.record.getDate()) {
				    desc+=HU.b(this.formatDate(a.record.getDate()))+"<br>";
				}
			    }
			    desc+=a.description;			    
			});
			newRow.push(label);
			newRow.push(desc);
		    } else {
			if(debug && rowIdx<debugRows) {
			    console.log("\t annotation:" + "null");
			    console.log("\t desc:" + "null");
			}
			newRow.push(null);
			newRow.push(null);
		    }
		    debug =false;
		}
                justData.push(newRow);
//		console.log("row:" + newRow);
		//		if(debug && rowIdx>debugRows) break;
	    }

	    if(debug)
		console.log("#rows:" + justData.length);

	    times.push(new Date());
            dataTable.addRows(justData);
            if (didColorBy) {
		colorBy.displayColorTable();
            }
	    if(chartOptions) {
		//Only make the series if it isn't stacked
		if(!chartOptions.isStacked) {
		    chartOptions.series = this.makeSeriesInfo(dataTable);
		}
		chartOptions.trendlines = this.makeTrendlinesInfo(dataTable);
	    }

	    if(this.debugTimes)
		Utils.displayTimes("makeDataTable",times,true);
            return dataTable;
        },
        makeChartOptions: function(dataList, props, selectedFields) {
            let chartOptions = {
                tooltip: {
                    isHtml: true,
//		    ignoreBounds: true, 
		    trigger: 'both' 
                },
            };

            $.extend(chartOptions, {
		width:"100%",
                lineWidth: this.getProperty("lineWidth",1),
                colors: this.getColorList(),
                curveType: this.curveType,
		pointShape:this.getProperty("pointShape"),
		pointSize: this.getProperty("pointSize"),
                vAxis: {}
            });

            chartOptions.backgroundColor = {};
            chartOptions.chartArea = {};
            chartOptions.chartArea.backgroundColor = {};

            chartOptions.legend = {
                textStyle: {}
            };
            chartOptions.hAxis = {
                gridlines: {},
                minorGridlines: {},		
                textStyle: {},
            };
	    chartOptions.xannotations = {
		textStyle: {
		    fontSize: this.getProperty('annotationsFontSize',12),
		    color: this.getProperty('annotationsTextColor')
		},
		stem: {
		    color:this.getProperty('annotationsStemColor'),
		    length:this.getProperty('annotationsStemLength'),
		},
		style: this.getProperty('annotationsStyle')
	    };



            chartOptions.vAxis = {
                gridlines: {},
                minorGridlines: {},		
                textStyle: {}
            };
	    chartOptions.hAxis.minValue = this.getProperty("hAxisMinValue");
	    chartOptions.hAxis.maxValue = this.getProperty("hAxisMaxValue");
	    chartOptions.vAxis.minValue = this.getProperty("vAxisMinValue");
	    chartOptions.vAxis.maxValue = this.getProperty("vAxisMaxValue");


	    chartOptions.vAxis.logScale = this.getProperty("vAxisLogScale",this.getProperty("logScale"));
	    chartOptions.hAxis.logScale = this.getProperty("hAxisLogScale");

            chartOptions.hAxis.titleTextStyle = {};
            chartOptions.vAxis.titleTextStyle = {};
	    if(this.getProperty("hAxisDateFormat")) {
		chartOptions.hAxis.format = this.getProperty("hAxisDateFormat");
	    }


	    //	    this.getPropertyShow = true;
	    let lineColor = this.getProperty("lineColor");
	    let backgroundColor = this.getProperty("chartBackground");
            this.setPropertyOn(chartOptions.backgroundColor, "chart.fill", "fill", backgroundColor);
            this.setPropertyOn(chartOptions.backgroundColor, "chart.stroke", "stroke", this.getProperty("chartArea.fill", ""));
            this.setPropertyOn(chartOptions.backgroundColor, "chart.strokeWidth", "strokeWidth", null);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.fill", "fill", backgroundColor);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.stroke", "stroke", null);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.strokeWidth", "strokeWidth", null);

	    let minorGridLinesColor = this.getProperty("minorGridLines.color",this.getProperty("gridlines.color")||lineColor||"transparent");
            this.setPropertyOn(chartOptions.hAxis.gridlines, "hAxis.gridlines.color", "color", this.getProperty("gridlines.color")|| lineColor);
	    this.setPropertyOn(chartOptions.hAxis.minorGridlines, "hAxis.minorGridlines.color", "color", minorGridLinesColor);

	    this.setPropertyOn(chartOptions.hAxis, "hAxis.baselineColor", "baselineColor", this.getProperty("baselineColor")|| lineColor);	    
            this.setPropertyOn(chartOptions.vAxis.gridlines, "vAxis.gridlines.color", "color", this.getProperty("gridlines.color")|| lineColor);
	    this.setPropertyOn(chartOptions.vAxis.minorGridlines, "vAxis.minorGridlines.color", "color",  minorGridLinesColor);
	    this.setPropertyOn(chartOptions.vAxis, "vAxis.baselineColor", "baselineColor", this.getProperty("baselineColor")|| lineColor);

            let textColor = this.getProperty("textColor", "#000");
	    let textBold = this.getProperty("textBold", "false");
            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.color", "color", this.getProperty("axis.text.color", textColor));
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.color", "color", this.getProperty("axis.text.color", textColor));

            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.bold", "bold", textBold);
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.bold", "bold", textBold);

	    chartOptions.vAxis.title  = Utils.decodeText(this.getProperty("vAxis.text", this.getProperty("vAxisText")));
	    chartOptions.hAxis.title  = Utils.decodeText(this.getProperty("hAxis.text", this.getProperty("hAxisText")));	    
	    chartOptions.hAxis.slantedText = this.getProperty("hAxis.slantedText",this.getProperty("slantedText",false));
            this.setPropertyOn(chartOptions.hAxis.titleTextStyle, "hAxis.text.color", "color", textColor);
            this.setPropertyOn(chartOptions.vAxis.titleTextStyle, "vAxis.text.color", "color", textColor);
            this.setPropertyOn(chartOptions.legend.textStyle, "legend.text.color", "color", textColor);

	    let prop;
	    prop = this.getProperty("hAxis.ticks");
	    if(prop || prop=="")  {
		chartOptions.hAxis.ticks  = Utils.split(this.getProperty("hAxis.ticks"),",",true,true);
	    }
	    prop = this.getProperty("vAxis.ticks");
	    if(prop || prop=="")  {
		chartOptions.vAxis.ticks  = Utils.split(this.getProperty("vAxis.ticks"),",",true,true);
	    }
//	    console.log("ticks:" + chartOptions.vAxis.ticks);


            if (this.fontSize > 0) {
                chartOptions.fontSize = this.fontSize;
            }

	    let defaultRanges=[];
	    let numeric = [];
            dataList.forEach((v,idx)=>{
		if(idx==0) return;
		let tuple = this.getDataValues(v);
		if(idx==1) {
		    tuple.forEach((tv,idx)=>{
			numeric.push((typeof tv)=="number");
		    });
		    numeric.forEach(v=>defaultRanges.push([Number.MAX_VALUE,Number.MIN_VALUE]));
		}
		
		
		let cnt = 0;
		tuple.forEach((tv,idx)=>{
		    if(numeric[idx]) {
			defaultRanges[cnt][0] = Math.min(defaultRanges[cnt][0],tv);
			defaultRanges[cnt][1] = Math.max(defaultRanges[cnt][1],tv);
			cnt++;
		    }
		});
	    });

            let range = [NaN, NaN];
	    //	    console.log("range:" +this.getVAxisMinValue());
            if (!isNaN(this.getVAxisMinValue())) {
                range[0] = this.getVAxisMinValue();
            } else if (defaultRanges.length>0) {
		if(this.getProperty("vAxisUseDefault")) {
                    range[0] = defaultRanges[0][0];
		}
            }

	    if (!isNaN(this.getVAxisMaxValue())) {
                range[1] = this.getVAxisMaxValue();
            } else if (defaultRanges.length>0) {
//                range[1] = defaultRanges[0][1];
            }



            if (!isNaN(range[0])) {
                chartOptions.vAxis.minValue = range[0];
            }
            if (!isNaN(range[1])) {
                chartOptions.vAxis.maxValue = range[1];
//		chartOptions.vAxis.maxValue = null;
            }

//	    console.log(chartOptions.vAxis.maxValue);

            this.chartDimensions = {
                width: "90%",
                left: "10%",
                right: 10,
            }

            useMultipleAxes = this.getProperty("useMultipleAxes", true);

            if ((selectedFields.length > 1 && useMultipleAxes) || this.getProperty("padRight", false) === true) {
                this.chartDimensions.width = "80%";
            }

            if (this.getProperty("showTrendLines", false)) {
                chartOptions.trendlines = {
                    0: {
                        type: 'linear',
                        color: 'green',
                    }
                };
            }
	    
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(expandedHeight) {
		chartOptions.height = expandedHeight;
	    }
	    if(this.getPropertyShow) {
		this.getPropertyShow = false;
		Utils.makeDownloadFile("props.txt",this.getPropertyOutput);
	    }
            this.setContents(HU.div([ID,this.domId(ID_CHARTS)]));
            return chartOptions;
        },
        getChartHeight: function() {
            return this.getProperty("height");
        },
        getChartWidth: function() {
            return this.getProperty("width");
        },
        getChartDiv: function(chartId) {
            let divAttrs = [ATTR_ID, chartId];
            let style = "";
            let width = this.getChartWidth();
            if (false && width) {
		if(width.endsWith("%")) {
                    style += HU.css("width", width);
		} else {
                    if (width > 0)
			style += HU.css("width", width + "px");
                    else if (width < 0)
			style += HU.css("width" , (-width) + "%");
                    else
			style += HU.css("width", width);
		}
            } else {
		//                style += HU.css("width","100%");
            }
	    let expandedHeight  = this.getProperty("expandedHeight");
            let height =  this.getChartHeight();
	    if(expandedHeight) {
                style += HU.css("height", expandedHeight);
	    } else {
		if (height) {
                    if (height > 0)
			style += HU.css("height", height + "px");
                    else if (height < 0)
			style += HU.css("height", (-height) + "%");
                    else
			style += HU.css("height", height);
		} else {
                    style += HU.css("height", "100%");
		}
	    }
	    //	    style += HU.css("text-align","center");
            divAttrs.push(STYLE);
            divAttrs.push(style);
	    divAttrs.push(CLASS);
	    divAttrs.push("ramadda-expandable-target");
	    let isExpanded = this.getProperty("isExpanded");
	    let originalHeight = this.getProperty("originalHeight");
	    if(isExpanded) {
		divAttrs.push("isexpanded","true")
		divAttrs.push("original-height",originalHeight)
	    }
	    if(this.getProperty("expandableHeight")) {
		divAttrs.push("expandable-height");
		divAttrs.push(this.getProperty("expandableHeight"));
	    }
            return HU.div(divAttrs, "");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            throw new Error("doMakeGoogleChart undefined");
        },
	makeGoogleChart: function(dataList, props, selectedFields) {
	    try {
		this.doMakeGoogleChartInner(dataList,props,selectedFields);
	    } catch(err) {
		this.handleError("Error creating chart: " + err, err);
	    }
	},
	setAxisRanges: function(chartOptions, selectedFields, records) {
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[0]);
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }

	    if(this.getProperty("vAxisFixedRange") || this.getProperty("vAxisSelectedFields") || this.getProperty("vAxisAllFields")) {
		let min = Number.MAX_VALUE;
		let max = Number.MIN_VALUE;		
		let fields = this.getProperty("vAxisAllFields")?this.getFields():selectedFields;
		fields.forEach(f=>{
		    if(f.isFieldNumeric()) {
			let y = this.getColumnValues(records, f);
			if(!isNaN(y.min))
			    min  = Math.min(min, y.min);
			if(!isNaN(y.max))
			    max  = Math.max(max, y.max);
		    }
		});
		if(min!=Number.MAX_VALUE) {
		    chartOptions.vAxis.minValue = min;
		    chartOptions.vAxis.maxValue = max;
		}
	    }

	},
	doMakeGoogleChartInner: function(dataList, props, selectedFields) {
            if (typeof google == 'undefined') {
                this.setDisplayMessage("No google");
                return;
            }
            this.chartOptions = this.makeChartOptions(dataList, props, selectedFields);
	    this.chartOptions.bar = {groupWidth:"95%"}
            if (!Utils.isDefined(this.chartOptions.height)) {
                this.chartOptions.height = "100%";
            }

	    this.charts = [];
	    this.chartCount  = -1;

            let records = this.getPointData().getRecords();
	    this.setAxisRanges(this.chartOptions, selectedFields, records);

//	    console.log(JSON.stringify(this.chartOptions, null,2));
	    
	    if(this.getProperty("doMultiCharts",this.getProperty("multipleCharts",false))) {
		let multiField=this.getFieldById(null,this.getProperty("multiField"));
		let labelPosition = this.getProperty("multiChartsLabelPosition","bottom");
		let map = {};
		let groups = [];
		let tmp = [];
		dataList.forEach((v,idx)=>{if(idx>0) tmp.push(v)});
		if(!multiField) {
		    tmp.sort(function(a,b) {
			let v1 = a.record?a.record.getDate():a.date;
			let v2 = b.record?b.record.getDate():b.date;
			return v1.getTime()-v2.getTime();
		    });
		}
		dataList = Utils.mergeLists([dataList[0]], tmp);
		dataList.forEach((v,idx)=>{
		    if(idx==0) return;
                    let record = v.record;
		    let groupValue = record?multiField?record.getValue(multiField.getIndex()):record.getDate():v.date;
		    let list=null;
		    list = map[groupValue];
		    if(!list) {
			list = [];
			map[groupValue] = list;
			groups.push(groupValue);
		    }
		    list.push(v);
		})
		this.jq(ID_CHARTS).html(HU.div([ID,this.domId(ID_CHARTS_INNER),STYLE,HU.css('text-align','center')]));
		let multiStyle="width:200px;" + this.getProperty("multiStyle","");
		let multiLabelTemplate=this.getProperty("multiLabelTemplate","${value}");
		if(multiField) groups.sort();
		groups.forEach((groupValue,idx)=>{
		    this.chartCount  =idx;
		    let tmpDataList = [];
		    let list = map[groupValue];
		    tmpDataList.push(dataList[0]);
		    tmpDataList = Utils.mergeLists(tmpDataList,list);
		    let innerId = this.domId(ID_CHART)+"_" + this.chartCount;
		    let label = groupValue;
		    if(groupValue.getTime) label = this.formatDate(groupValue);
		    label = multiLabelTemplate.replace("${value}",label);
		    let header = HU.div([CLASS,"display-multi-header"], label);
		    let top =labelPosition=="top"?header:"";
		    let bottom = labelPosition=="bottom"?header:"";
		    let div = HU.div([CLASS,"display-multi-div", STYLE,HU.css('display','inline-block')+ multiStyle], top + this.getChartDiv(innerId) + bottom);
		    this.jq(ID_CHARTS_INNER).append(div);
		    let chart = this.makeGoogleChartInner(tmpDataList, innerId, props, selectedFields);
		    if(chart) this.charts.push(chart);
		});
	    } else {
		this.jq(ID_CHARTS).append(this.getChartDiv(this.domId(ID_CHART)));
		let chart = this.makeGoogleChartInner(dataList, this.domId(ID_CHART), props, selectedFields);
		if(chart) this.charts.push(chart);
	    }
	    

	    this.mapCharts(chart=>{
		google.visualization.events.addListener(chart, 'onmouseout',()=>{
		    //console.log("mouseout");
		    //this.setChartSelection(null);
		});
	    });



	},
	makeGoogleChartInner: function(dataList, chartId, props, selectedFields) {

	    let chartDiv = document.getElementById(chartId);
	    if(!chartDiv) {
		console.log(this.type+".makeGoogleChart: no chart div found:" + chartId);
		return;
	    }
	    let dataTable = this.makeDataTable(dataList, props, selectedFields, this.chartOptions);
            let chart = this.doMakeGoogleChart(dataList, props, chartDiv, selectedFields, this.chartOptions);
            if (chart == null) return null;
            if (!dataTable) {
                this.setDisplayMessage(this.getNoDataMessage());
                return null;
            }
	    if(this.getProperty("vAxisSharedRange")) {
		let max = NaN;
		for(let i=0;i<dataTable.getNumberOfColumns();i++) {
		    let minmax = dataTable.getColumnRange(i);
		    if(!isNaN(minmax.max) && minmax.max!=null && (typeof minmax.max) == "number") {
			max = max==null|| isNaN(max)?minmax.max:Math.max(max, minmax.max);
		    }
		}
                chartOptions.vAxis.maxValue = max;
            }


	    if(this.getProperty("animation",false,true)) {
		this.chartOptions.animation = {
		    startup: true,
		    duration:parseFloat(this.getProperty("animationDuration",1000,true)),
		    easing:this.getProperty("animationEasing","linear",true)
		};
		HU.callWhenScrolled(this.domId(ID_CHART),()=>{
		    if(!this.animationCalled) {
			this.animationCalled = true;
			this.mapCharts(chart=>{
			    chart.draw(dataTable, this.chartOptions);
			});
		    }
		});
	    } else {
		try {
		    if(this.debugChartOptions)
			console.log(JSON.stringify(this.chartOptions, null,2));
		    this.chart = chart;
		    this.dataTable = dataTable;
		    let testData = google.visualization.arrayToDataTable([
			['Genre', 'Fantasy & Sci Fi', 'Western'],
			['2010', 10, 24],
			['2020', 16, 22],
			['2030', 28, 19]
		    ]);

		    let t1 = new Date();

		    chart.draw(this.useTestData?testData:dataTable, this.chartOptions);
//		    Utils.displayTimes("chart.draw",[t1,new Date()],true);
		} catch(err) {
		    this.handleError("Error creating chart:" + err,err);
		    return null;
		}
	    }
	    this.addEvents(chart);
	    return chart;
	},
	addEvents: function(chart) {
            let _this = this;
	    if(this.getProperty("propagateHighlightEvent")) {
		google.visualization.events.addListener(chart, 'onmouseover', function(event) {
                    pointData = _this.dataCollection.getList()[0];
                    let fields = pointData.getRecordFields();
                    let records = pointData.getRecords();
	            let record = records[event.row];
		    if(!record) return;
		    _this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, _this, {highlight:true,record: record});
		});
	    }
            google.visualization.events.addListener(chart, 'select', function(event) {
                _this.mapCharts(chart=>{
		    if (chart.getSelection) {
			let selected = chart.getSelection();
			if (selected && selected.length > 0) {
                            let index = selected[0].row;
			    let record = _this.indexToRecord[index];
			    if(record) {
				let records = _this.getBinnedRecords(record);
				if(records) {
				    if(records.length==1)  {
					_this.propagateEventRecordSelection({record: records[0]});
				    } else {
					_this.propagateEventRecordSelection({record: records[0],
									     records:records});
				    }
				} else {
				    _this.propagateEventRecordSelection({record: record});
				}
			    }
			}
		    }});
            });
	}


    });
}



function RamaddaAxisChart(displayManager, id, chartType, properties) {
    let SUPER = new RamaddaGoogleChart(displayManager, id, chartType, properties);
    let myProps = [
	{label:'Chart Properties'},
	{p:'indexField',ex:'field',tt:'alternate field to use as index'},
 	{p:'indexIsString',ex:'true',tt:'if index is a string set to true'},
	{p:'vAxisMinValue',ex:''},
	{p:'vAxisMaxValue',ex:''},
	{p:'vAxisSharedRange',ex:'true',tt:'use the same max value across all time series'},
	{p:"hAxisFixedRange"},
	{p:"vAxisSelectedFields",ex:'true',tt:'Use selected fields to find min/max for the range'},
	{p:"vAxisAllFields",ex:'true',tt:'Use all field values to find min/max for the range'},
	{p:'vAxisLogScale',ex:'true'},
	{p:'hAxisLogScale',ex:'true'},
	{p:'tooltipFields',ex:''},
	{p:'annotations',ex:'date,label,desc;date,label,desc;',tt:'e.g. 2008-09-29,A,Start of housing crash;2008-11-04,B,Obama elected;'},
 	{p:'annotationFields',ex:''},
	{p:'annotationLabelField',ex:''},
 	{p:'dateType',ex:'datetime'},
 	{p:'addTooltip',ex:'false',tt:'Set this to false for multi-series charts if you only want the hovered series to show in the tt'},
	{inlineLabel:'Multiples Charts'},
	{p:'doMultiCharts',ex:'true'},
	{p:'multiField',ex:'field'},
	{p:'multiStyle',ex:''},
	{p:'multiLabelTemplate',ex:'${value}'},
	{p:'multiChartsLabelPosition',ex:'bottom|top|none'},
	{inlineLabel:'Chart Layout'},
	{p:'chartHeight',ex:''},
	{p:'chartWidth',ex:''},
	{p:'chartLeft',ex:'0'},
	{p:'chartRight',ex:'0'},
	{p:'chartTop',ex:'0'},
	{p:'chartBottom',ex:'0'},
	{p:'lineColor',ex:''},
	{p:'chartBackground',ex:''},
	{p:'chart.fill',ex:''},
	{p:'chartArea.fill',ex:''},
	{p:'chart.stroke',ex:''},
	{p:'chart.strokeWidth',ex:''},
	{p:'chartArea.fill',ex:''},
	{p:'chartArea.stroke',ex:''},
	{p:'chartArea.strokeWidth',ex:''},
	{p:'gridlines.color',ex:'transparent'},
	{p:'minorGridLines.color',ex:'transparent'},
	{p:'gridlines.color',ex:''},
	{p:'hAxis.gridlines.color',ex:''},
	{p:'hAxis.minorGridlines.color',ex:'transparent'},
	{p:'baselineColor',ex:''},
	{p:'hAxis.baselineColor',ex:''},
	{p:'gridlines.color',ex:''},
	{p:'vAxis.gridlines.color',ex:''},
	{p:'vAxis.minorGridlines.color',ex:'transparent'},
	{p:'baselineColor',ex:''},
	{p:'vAxis.baselineColor',ex:''},
	{p:'textColor',ex:'#000'},
	{p:'textBold',ex:'true'},
	{p:'axis.text.color',ex:'#000'},
	{p:'hAxis.text.color',ex:'#000'},
	{p:'axis.text.color',ex:'#000'},
	{p:'vAxis.text.color',ex:'#000'},
	{p:'hAxis.text.bold',ex:'false'},
	{p:'vAxis.text.bold',ex:'false'},
	{p:'vAxisText',ex:''},
	{p:'vAxis.text',ex:''},
	{p:'slantedText',ex:'true'},
	{p:'hAxis.slantedText',ex:''},
	{p:'hAxis.text.color',ex:'#000'},
	{p:'vAxis.text.color',ex:'#000'},
	{p:'legend.position',ex:'top|bottom|none'},
	{p:'legend.text.color',ex:'#000'},
	{p:'hAxis.ticks',ex:''},
	{p:'hAxis.ticks',ex:''},
	{p:'vAxis.ticks',ex:''},
	{p:'vAxis.ticks',ex:''},
	{p:'useMultipleAxes',ex:'true'},
	{p:'showTrendLines',ex:'true'},
    ];

    defineDisplay(this, SUPER, myProps, {

	setChartArea: function(chartOptions) {
            if (!chartOptions.chartArea) {
                chartOptions.chartArea = {};
            }
	    $.extend(chartOptions.chartArea, {
                left: this.getProperty("chartLeft", this.chartDimensions.left),
                right: this.getProperty("chartRight", this.chartDimensions.right),
                top: this.getProperty("chartTop", "10"),
		bottom: this.getProperty("chartBottom"),
                height: this.getProperty("chartHeight", "70%"),
                width: this.getProperty("chartWidth", this.chartDimensions.width),
            });
	    ["left","top","right","bottom"].forEach(a=>{
		let v =chartOptions.chartArea[a];
		if(v) v = String(v).replace("px","");
		chartOptions.chartArea[a] = v;
	    });						    
	},

        makeChartOptions: function(dataList, props, selectedFields) {
            chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);

	    let dataFields = dataList[0].fields;


	    let expandedHeight  = this.getProperty("expandedHeight");
            chartOptions.height = expandedHeight || this.getProperty("chartHeight", this.getProperty("height", "150"));

            if (!chartOptions.legend)
                chartOptions.legend = {};


	    this.setPropertyOn(chartOptions.legend, "legend.position", "position", this.getProperty("legendPosition", 'bottom'));
	    this.setChartArea(chartOptions);
   
            let useMultipleAxes = this.getProperty("useMultipleAxes", true);
            if (useMultipleAxes) {
		//TODO: 
                chartOptions.series = [
		    {
			targetAxisIndex: 0
                    }, {
			targetAxisIndex: 1
                    }];
            }

	    if(chartOptions.legend.position=="left") {
		console.log(chartOptions.legend.position);
                chartOptions.series = [
		    {
			targetAxisIndex: 1
		    }]
	    }

	    if (!chartOptions.hAxis) {
		chartOptions.hAxis = {};
	    }
	    if (!chartOptions.vAxis) {
		chartOptions.vAxis = {};
	    }
	    chartOptions.hAxis.textPosition = this.getProperty("hAxisTextPosition","top");
	    chartOptions.vAxis.textPosition = this.getProperty("vAxisTextPosition");


            if (this.getProperty("hAxisTitle")) {
                chartOptions.hAxis.title = this.getProperty("hAxisTitle");
            }
            if (this.getProperty("vAxisTitle")) {
                chartOptions.vAxis.title = this.getProperty("vAxisTitle");
		if(chartOptions.vAxis.title && dataFields) {
		    let label = dataFields.reduce((acc,v)=>{
			return acc+" " + v.getLabel();
		    },"");
		    chartOptions.vAxis.title = chartOptions.vAxis.title.replace("${fields}",label);
		}

            }
//	    console.log(JSON.stringify(chartOptions,null,2));

            if (Utils.isDefined(this.chartHeight)) {
                chartOptions.height = this.chartHeight;
            }

            return chartOptions;

        }
    });

}



function RamaddaSeriesChart(displayManager, id, chartType, properties) {
    const SUPER = new RamaddaAxisChart(displayManager, id, chartType, properties);
    defineDisplay(this, SUPER, [], {
        includeIndexInData: function() {
            return this.getProperty("includeIndex", true);
        },
        trendLineEnabled: function() {
            return true;
        },
    });
}


function BlankchartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, "blankchart", properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            return null;
        },
    });
}


function LinechartDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaSeriesChart(displayManager, id, DISPLAY_LINECHART, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            return new google.visualization.LineChart(chartDiv);
        },
    });
}




function AreachartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, DISPLAY_AREACHART, properties);
    let myProps = [
	{label:'Area Chart Properties'},
	{p:'isStacked',ex:'true'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            if (this.isStacked)
                chartOptions.isStacked = true;
            return new google.visualization.AreaChart(chartDiv);
        }
    });
}


function RamaddaBaseBarchart(displayManager, id, type, properties) {
    const SUPER  = new RamaddaSeriesChart(displayManager, id, type, properties);
    let myProps = [
    ];
    defineDisplay(this, SUPER, myProps, {
        canDoGroupBy: function() {
            return true;
        },
        makeChartOptions: function(dataList, props, selectedFields) {
            chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            let chartType = this.getChartType();
            if (chartType == DISPLAY_BARSTACK) {
		chartOptions.series = null;
                chartOptions.isStacked = true;
            }
            if (this.getProperty("barWidth")) {
		let w = this.getProperty("barWidth");
		if(w=="flex") {
		    if(dataList.length<100) {
			w = "10";
		    } else {
			w = null;
		    }
		}
		if(w) {
                    chartOptions.bar = {
			groupWidth: w
                    }
		}
	    }
	    chartOptions.orientation = this.getProperty("orientation","horizontal");
	    return chartOptions;
	},

        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            return new google.visualization.BarChart(chartDiv);
        }
    });
}


function BarchartDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaBaseBarchart(displayManager, id, DISPLAY_BARCHART, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {});
}

function BarstackDisplay(displayManager, id, properties) {
    properties = $.extend({
        "isStacked": true
    }, properties);
    const SUPER =  new RamaddaBaseBarchart(displayManager, id, DISPLAY_BARSTACK, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {});
}


function HistogramDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_HISTOGRAM, properties);
    let myProps = [
	{label:'Histogram Properties'},
	{p:'legendPosition',ex:'none|top|right|left|bottom'},
	{p:'textPosition',ex:'out|in|none'},
	{p:'isStacked',ex:'false|true|percent|relative'},
	{p:'logScale',ex:'true|false'},
	{p:'scaleType',ex:'log|mirrorLog'},
	{p:'minValue',ex:''},
	{p:'maxValue',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        okToHandleEventRecordSelection: function() {
            return false;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            return google.visualization.arrayToDataTable(this.makeDataArray(dataList));
        },
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            //            chartOptions = {};
            if (this.legendPosition) {
                if (!chartOptions.legend)
                    chartOptions.legend = {};
                chartOptions.legend.position = this.legendPosition;
            }
            let isStacked = this.getProperty("isStacked", null);
            if (isStacked)
                chartOptions.isStacked = isStacked == "true" ? true : isStacked == "false" ? false : isStacked;
            chartOptions.vAxis = {};
            chartOptions.vAxis.viewWindow = {};
            if (Utils.isDefined(this.logScale)) {
                chartOptions.vAxis.logScale = ("" + this.logScale) == true;
            }
            if (this.textPosition) {
                chartOptions.vAxis.textPosition = this.textPosition;
            }


            if (Utils.isDefined(this.minValue)) {
                chartOptions.vAxis.viewWindow.min = parseFloat(this.minValue);
            }
            if (Utils.isDefined(this.maxValue)) {
                chartOptions.vAxis.viewWindow.max = parseFloat(this.maxValue);
            }
            if (!isNaN(this.getVAxisMaxValue())) {
                chartOptions.vAxis.maxValue = this.getVAxisMaxValue();
            }
            if (!isNaN(this.getVAxisMinValue())) {
                chartOptions.vAxis.minValue = parseFloat(this.getVAxisMinValue());
            }
            if (!isNaN(this.getHAxisMaxValue())) {
                chartOptions.hAxis.maxValue = this.getHAxisMaxValue();
            }
            if (!isNaN(this.getHAxisMinValue())) {
                chartOptions.hAxis.minValue = parseFloat(this.getHAxisMinValue());
            }	    
            return new google.visualization.Histogram(chartDiv);
        },

    });
}


function RamaddaTextChart(displayManager, id, chartType, properties) {
    const SUPER = new RamaddaGoogleChart(displayManager, id, chartType, properties);
    defineDisplay(this, SUPER, [], {
        getFieldsToSelect: function(pointData) {
            return pointData.getNonGeoFields();
        },
    });
}




function PiechartDisplay(displayManager, id, properties) {
    let ID_PIE_LEGEND = "pielegend";
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_PIECHART, properties);
    let myProps = [
	{label:'Pie Chart Properties'},
	{p:'groupBy',ex:''},
	{p:'groupByCount',ex:'true'},
	{p:'groupByCountLabel',ex:''},
	{p:'binCount',ex:'true'},
	{p:'pieHole',ex:'0.5'},
	{p:'is3D',ex:'true'},
	{p:'bins',ex:''},
	{p:'binMin',ex:''},
	{p:'binMax',ex:'max'},
	{p:'sliceVisibilityThreshold',ex:'0.01'},
	{p:'pieSliceTextColor',ex:'black'},
	{p:'pieSliceBorderColor',ex:'black'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {

	uniqueValues:[],
	uniqueValuesMap:{},
        canDoGroupBy: function() {
            return true;
        },
	makeGoogleChart: function(dataList, props, selectedFields) {
	    this.uniqueValues = [];
	    this.uniqueValuesMap = {};
	    SUPER.makeGoogleChart.call(this, dataList, props, selectedFields);
	    if(!this.getProperty("showTopLegend")) return;
	    let legend = "";
	    let colors = this.getColorList();
	    let colorCnt = 0;
	    this.uniqueValues.map((v,idx)=>{
		if(colorCnt>=colors.length) colorCnt = 0;
		let color  = colors[colorCnt];
		legend += HU.div([STYLE,HU.css('display','inline-block','width','8px','height','8px','background', color)]) +SPACE + v +SPACE2;
		colorCnt++;
	    });
	    if(this.jq(ID_PIE_LEGEND).length==0) {
		this.jq(ID_HEADER2).append(HU.div([ID,this.domId(ID_PIE_LEGEND)]));
	    }
	    this.jq(ID_PIE_LEGEND).html(legend);

	},
        setChartSelection: function(index) {
	    //noop
	},
        getGroupBy: function() {
            if (!this.groupBy && this.groupBy != "") {
                let stringField = this.getFieldByType(this.getFields(), "string");
                if (stringField) {
                    this.groupBy = stringField.getId();
                }
            }
            return this.groupBy;
        },
        getChartDiv: function(chartId) {
            let divAttrs = [ATTR_ID, chartId];
            divAttrs.push(STYLE);
            let style = "";
	    let width = this.getProperty("chartWidth") || this.getChartWidth();
	    let height = this.getProperty("chartHeight") || this.getChartHeight();
            if (width) {
                if (width > 0)
                    style += "width:" + width + "px;";
                else if (width < 0)
                    style += "width:" + (-width) + "%;";
                else
                    style += "width:" + width + ";";
            } else {
                style += "width:" + "100%;";
            }
            if (height) {
                if (height > 0)
                    style += "height:" + height + "px;";
                else if (height < 0)
                    style += "height:" + (-height) + "%;";
                else
                    style += "height:" + height + ";";
            } else {
                style += "height:" + "100%;";
            }
	    //	    style += "border:1px solid green;"
	    style += "padding:5px;"
            divAttrs.push(style);
            return HU.div(divAttrs, "");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            chartOptions.tooltip = {
                textStyle: {
                    color: '#000000',
		    fontSize:12,
                },
                showColorCode: true,
		//		isHtml: true,
		//		ignoreBounds: true,
            };
	    this.chartOptions.legend = {'position':this.getProperty("legendPosition", 'right'),'alignment':'center'};
            if (this.getProperty("bins", null)) {
                chartOptions.title = "Bins: " + this.getDataValues(dataList[0])[1];
	    } else if(this.getProperty("sumFields")) {
                chartOptions.title = this.getProperty("chartTitle","Categories/Values");
            } else {
                chartOptions.title = this.getDataValues(dataList[0])[0] + " - " + this.getDataValues(dataList[0])[1];
            }

            if (this.is3D) {
                chartOptions.is3D = true;
            }
            if (this.pieHole) {
                chartOptions.pieHole = this.pieHole;
            }
            if (this.sliceVisibilityThreshold) {
                chartOptions.sliceVisibilityThreshold = this.sliceVisibilityThreshold;
            }

	    chartOptions.pieSliceBorderColor = this.getProperty("pieSliceBorderColor","transparent");
	    chartOptions.pieSliceTextStyle  = {
		color: this.getProperty("pieSliceTextColor","white")
            };

	    chartOptions.chartArea = {};
	    $.extend(chartOptions.chartArea, {
                left: this.getProperty("chartLeft", 0),
                right: this.getProperty("chartRight", 0),
                top: this.getProperty("chartTop", 0),
		bottom: this.getProperty("chartBottom",0),
                width: '100%',
                height: '100%'
            });

            return new google.visualization.PieChart(chartDiv);
        },
	getColorList:function() {
	    if (this.getProperty("colors") && this.getProperty("colors")!="default") {
		return SUPER.getColorList.call(this);
	    }
	    if (this.getProperty("colorTable")) {
		let ct =this.getColorTable();
		return ct.colors;
	    }	    
	    return Utils.mergeLists(Utils.getColorTable("schemeset1",true),
				    Utils.getColorTable("schemecategory",true));
	},

        makeDataTable: function(dataList, props, selectedFields) {
            let dataTable = new google.visualization.DataTable();
            let list = [];
            let header = this.getDataValues(dataList[0]);
            dataTable.addColumn("string", header[0]);
            dataTable.addColumn("number", header[1]);


            if (this.getProperty("bins", null)) {
                let bins = parseInt(this.getProperty("bins", null));
                let min = Number.MAX_VALUE;
                let max = Number.MIN_VALUE;
                let haveMin = false;
                let haveMax = false;
                if (this.getProperty("binMin")) {
                    min = parseFloat(this.getProperty("binMin"));
                    haveMin = true;
                }
                if (this.getProperty("binMax")) {
                    max = parseFloat(this.getProperty("binMax"));
                    haveMax = true;
                }

                let goodValues = [];
                for (let i = 1; i < dataList.length; i++) {
                    let tuple = this.getDataValues(dataList[i]);
                    let value = tuple[1];
                    if (!Utils.isRealNumber(value)) {
                        continue;
                    }
                    if (!haveMin)
                        min = Math.min(value, min);
                    if (!haveMax)
                        max = Math.max(value, max);
                    goodValues.push(value);
                }

                let binList = [];
                let step = (max - min) / bins;
                for (let binIdx = 0; binIdx < bins; binIdx++) {
                    binList.push({
                        min: min + binIdx * step,
                        max: min + (binIdx + 1) * step,
                        values: []
                    });
                }

                for (let rowIdx = 0; rowIdx < goodValues.length; rowIdx++) {
                    let value = goodValues[rowIdx];
                    let ok = false;

                    for (let binIdx = 0; binIdx < binList.length; binIdx++) {
                        if (value < binList[binIdx].min || (value >= binList[binIdx].min && value <= binList[binIdx].max)) {
                            binList[binIdx].values.push(value);
                            ok = true;
                            break;
                        }
                    }
                    if (!ok) {
                        binList[binList.length - 1].values.push(value);
                    }
                }
                for (let binIdx = 0; binIdx < bins; binIdx++) {
                    let bin = binList[binIdx];
                    list.push(["Bin:" + this.formatNumber(bin.min) + "-" + this.formatNumber(bin.max),
                               bin.values.length
			      ]);
                }
            } else if(this.getProperty("sumFields")) {
		dataTable = new google.visualization.DataTable();
		dataTable.addColumn("string", "Category");
		dataTable.addColumn("number", "Value");
		let records=  this.filterData();
		let sumFields =  this.getFieldsByIds(null, this.getProperty("sumFields"));
		let sums = [];
		sumFields.map(f=>{sums.push(0)});
		if(this.chartCount>=0) {
		    records = [records[this.chartCount]];
		}
                records.map(record=>{
		    sumFields.map((f,idx)=>{
			let v = record.getValue(f.getIndex());
			if(!isNaN(v))  sums[idx]+=v;
		    });
		});
		sumFields.map((f,idx)=>{
                    list.push([f.getLabel(),sums[idx]>0?sums[idx]:0]);
		});

            } else {
                for (let i = 1; i < dataList.length; i++) {
                    let tuple = this.getDataValues(dataList[i]);
                    let s = "" + (tuple.length == 1 ? "#" + i : tuple[0]);
                    let v = tuple.length == 1 ? tuple[0] : tuple[1];
                    list.push([s, v]);
                }
            }
	    list.map(tuple=>{
		let s = tuple[0];
		if(!this.uniqueValuesMap[s]) {
		    this.uniqueValuesMap[s] = true;
		    this.uniqueValues.push(s);
		}
	    });
	    //	    list =[];
	    //	    for(i=0;i<20;i++)list.push([""+i,5]);


            dataTable.addRows(list);
            return dataTable;
        }
    });


}


//TODO: this is broken because we don't load the sankey package because it loads an old version of d3


function SankeyDisplay(displayManager, id, properties) {
    this.tries = 0;
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_SANKEY, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'sankey')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            chartOptions.height = parseInt(this.getProperty("chartHeight", this.getProperty("height", "400")));
            chartOptions.sankey = {
                node: {
                    colors: this.colors,
                    width: 5,
                },
                link: {
                    colorMode: 'source',
                    colors: this.colors,
                    color: {
                        //                                stroke:'black',
                        //strokeWidth:1,
                    }
                }
            }
	    return new google.visualization.Sankey(chartDiv);
        },
        defaultSelectedToAll: function() {
            return true;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            if (!this.getProperty("doCategories", false)) {
                let values = this.makeDataArray(dataList);
                return google.visualization.arrayToDataTable(values);
            }
            let strings = [];
            for (let i = 0; i < selectedFields.length; i++) {
                let field = selectedFields[i];
                if (field.isFieldString()) {
                    strings.push(field);
                }
            }
            let values = [];
            values.push(["characteristic 1", "characteristic 2", "value"]);
            for (let i = 1; i < strings.length; i++) {
                let field1 = strings[i - 1];
                let field2 = strings[i];
                let cnts = {};
                for (let r = 1; r < dataList.length; r++) {
                    let row = this.getDataValues(dataList[r]);
                    let value1 = row[i - 1];
                    let value2 = row[i];
                    let key = value1 + "-" + value2;
                    if (!cnts[key]) {
                        cnts[key] = {
                            v1: value1,
                            v2: value2,
                            cnt: 0
                        }
                    }
                    cnts[key].cnt++;
                }
                for (a in cnts) {
                    values.push([cnts[a].v1, cnts[a].v2, cnts[a].cnt]);
                }
            }
            return google.visualization.arrayToDataTable(values);
        }
    });
}

function WordtreeDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_WORDTREE, properties);
    let myProps = [
	{label:"Word Tree"},
	{p:"treeRoot",d:"root", tt:"Word to use for root"},
	{p:"wordColors",ex:"red,green,blue",tt:"Colors to use for tree levels"},
	{p:"fixedSize",d:"false",tt:""},
	{p:"buckets",ex:"100,110,115,120,130",tt:"For numeric fields the buckets to put the records in"},	
	{p:"&lt;field&gt;.buckets",ex:"100,110,115,120,130",tt:"Specify buckets for a particular field"},
	{p:"bucketLabels",ex:"young,middle,old,really_old",tt:"For numeric fields the labels used for the buckets"},	
	{p:"&lt;field&gt;.bucketLabels",ex:"young,middle,old,really_old",tt:"Specify bucket labels for a particular field"},			
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        handleEventRecordSelection: function(source, args) {},
        updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'wordtree')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            if (this.getProperty("chartHeight"))
                chartOptions.height = parseInt(this.getProperty("chartHeight"));
            if (this.getWordColors()) {
                let tmp = this.getWordColors().split(",");
                let colors = [];
                for (let i = 0; i < 3 && i < tmp.length; i++) {
                    colors.push(tmp[i]);
                }
                if (colors.length == 3)
                    chartOptions.colors = colors;
            }

            if (this.getProperty("chartWidth")) {
                chartOptions.width = parseInt(this.getProperty("chartWidth"));
            }

            chartOptions.wordtree = {
                format: 'implicit',
                wordSeparator: "_SEP_",
                word: this.getTreeRoot(),
                //                    type: this.getProperty("treeType","double")

            }
            if (this.getProperty("maxFontSize")) {
                chartOptions.maxFontSize = parseInt(this.getProperty("maxFontSize"));
            }

            return new google.visualization.WordTree(chartDiv); 
        },


        makeDataTable: function(dataList, props, selectedFields) {
            //null ->get all data
            let root = this.getTreeRoot();
            let records = this.filterData(null, selectedFields, {skipFirst:true});
            let fields = this.getSelectedFields(this.getData().getRecordFields());
            let valueField = this.getFieldById(null, this.getProperty("colorBy"));
            let values = [];
            let typeTuple = ["phrases"];
            values.push(typeTuple);
            let fixedSize = this.getFixedSize();
            if (valueField)
                fixedSize = 1;
            if (fixedSize) typeTuple.push("size");
            if (valueField)
                typeTuple.push("value");
            let fieldInfo = {};

            let header = "";
            for (let i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (header != "")
                    header += " -&gt;";
                header += field.getLabel();
                if (!field.isFieldNumeric()) continue;
                let column = this.getColumnValues(records, field);
                let buckets = [];
                let argBuckets = this.getProperty("buckets." + field.getId(), this.getProperty("buckets", null));
                let min, max;
                if (argBuckets) {
                    let argBucketLabels = this.getProperty("bucketLabels." + field.getId(), this.getProperty("bucketLabels", null));
                    let bucketLabels;
                    if (argBucketLabels)
                        bucketLabels = argBucketLabels.split(",");
                    let bucketList = argBuckets.split(",");
                    let prevValue = 0;
                    for (let bucketIdx = 0; bucketIdx < bucketList.length; bucketIdx++) {
                        let v = parseFloat(bucketList[bucketIdx]);
                        if (bucketIdx == 0) {
                            min = v;
                            max = v;
                        }
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                        if (bucketIdx > 0) {
                            let label;
                            if (bucketLabels && i <= bucketLabels.length)
                                label = bucketLabels[bucketIdx - 1];
                            else
                                label =this.formatNumber(prevValue) + "-" + this.formatNumber(v);
                            buckets.push({
                                min: prevValue,
                                max: v,
                                label: label
                            });
                        }
                        prevValue = v;
                    }
                } else {
                    let numBuckets = parseInt(this.getProperty("numBuckets." + field.getId(), this.getProperty("numBuckets", 10)));
                    min = column.min;
                    max = column.max;
                    let step = (column.max - column.min) / numBuckets;
                    for (let bucketIdx = 0; bucketIdx < numBuckets; bucketIdx++) {
                        let r1 = column.min + (bucketIdx * step);
                        let r2 = column.min + ((bucketIdx + 1) * step);
			let label = this.formatNumber(r1) + "-" + this.formatNumber(r2);
                        buckets.push({
                            min: r1,
                            max: r2,
                            label: label
                        });
                    }
                }
                fieldInfo[field.getId()] = {
                    min: min,
                    max: max,
                    buckets: buckets
                };
            }

            let sep = "_SEP_";
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                let string = root;
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    string += sep;
                    let value = row[field.getIndex()];
                    if (field.isFieldNumeric()) {
                        let info = fieldInfo[field.getId()];
                        for (let bucketIdx = 0; bucketIdx < info.buckets.length; bucketIdx++) {
                            let bucket = info.buckets[bucketIdx];
                            if (value >= bucket.min && value <= bucket.max) {
                                value = bucket.label;
                                break;
                            }
                        }
                    }
                    string += value;
                }
                let data = [string.trim()];
                if (fixedSize) data.push(parseInt(fixedSize));
                if (valueField)
                    data.push(row[valueField.getIndex()]);
                values.push(data);
            }
            if (this.getProperty("header")) {
                header = this.getProperty("header", "");
            } else {
                header = "<b>Fields: </b>" + header;
                if (this.getProperty("headerPrefix"))
                    header = this.getProperty("headerPrefix") + " " + header;
            }
            this.writeHtml(ID_DISPLAY_TOP, header);
            return google.visualization.arrayToDataTable(values);
        },
    });
}



function TableDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TABLE, properties);
    let myProps = [
	{label:'Table'},
	{p:'imageField',ex:''},
	{p:'tableWidth',ex:'100%'},
	{p:'frozenColumns',ex:'1'},
	{p:'colorCells',ex:'field1,field2'},
	{p:'foregroundColor'},
	{p:'showRowNumber',ex:true},
	{p:'field.colorTable',ex:''},
	{p:'field.colorByMap',ex:'value1:color1,value2:color2'},
	{p:'maxHeaderLength',ex:'60'},
	{p:'maxHeaderWidth',ex:'60'},
	{p:'headerStyle'}];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'table')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},
        canDoGroupBy: function() {
            return true;
        },
        defaultSelectedToAll: function() {
            return true;
        },
        getDataTableValueGetter: function(records) {
	    let unhighlightColor = this.getProperty("unhighlightColor","#fff");
	    let highlightColor = this.getProperty("highlightColor","#FFFFCC");
	    let colorCells = this.getProperty("colorCells");
	    let colorByMap = {};
	    let linkField = this.getFieldById(null,this.getProperty("linkField"));
	    let iconField = this.getFieldById(null,this.getProperty("iconField"));
	    let foreground = this.getProperty("foregroundColor");
	    let cbs = [];
	    if(colorCells) {
		colorCells.split(",").forEach(c=>{
		    let f = this.getFieldById(null,c);
		    if(f) {
			colorByMap[c] = new ColorByInfo(this, null, records, null,c+".colorByMap",null, c, f);
			cbs.push(colorByMap[c]);
		    }
		});
	    }

	    //Show the bars
	    let dom = this.jq(ID_COLORTABLE);
	    cbs.forEach((cb,idx)=>{
		let id = this.domId(ID_COLORTABLE+idx);
		dom.append(HU.div([ID,id]));
		cb.displayColorTable(null,true,ID_COLORTABLE+idx);
	    });


	    return  (v,idx, field, record)=>{
		if(v===null) {
		    return {
			v:0,
			f:""
		    }
		}
		let f = v;
		if(v.f) {
		    f = v.f;
		    v = v.v;
		}
		if(v.getTime) {
		    f = this.formatDate(v);
		}
		if(iconField && record && idx==0) {
		    let icon = record.getValue(iconField.getIndex());
		    f = HU.image(icon) +"&nbsp;" +f;
		}
		if(linkField && record&& idx==0) {
		    let url = record.getValue(linkField.getIndex());
		    if(f) f = f.trim();
		    if (Utils.isDefined(f) && f!="") {
			f = HU.href(url,f);
		    }
		}

		if(!this.getFilterHighlight() || !record) {
		    f = HU.div([STYLE,HU.css('padding','4px')],f)
		} else {
		    let c = record.isHighlight(this) ? highlightColor: unhighlightColor;
		    f = HU.div([STYLE,HU.css('padding','4px','background', c)],f)
		}


		if(field) {
		    let colorBy = colorByMap[field.getId()];
		    if(colorBy && record) {
			let color =  colorBy.getColorFromRecord(record);
			let fg = foreground || Utils.getForegroundColor(color);
			f = HU.div([STYLE,HU.css('height','100%','background', color,'color',fg+" !important")],f)
		    }
		    if(field.getType()=="url") {
			return {
			    v:v,
			    f:HU.href(v,v)
			};
		    }
		    if(field.getType()=="image") {
			return {
			    v:v,
			    f:HU.href(v,HU.image(v,[WIDTH,this.getProperty("imageWidth",100)]))
			};
		    }		    
		}

		return {
		    v:v,
		    f:f
		};
	    }
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(!expandedHeight) {
		chartOptions.height = null;
		if (this.chartHeight) {
                    chartOptions.height = this.chartHeight;
		}
		if (chartOptions.height == null) {
                    let height = this.getProperty("height", null);
                    if (height) {
			chartOptions.height = height;
                    }
		}
		if (chartOptions.height == null) {
                    chartOptions.height = "300px";
		}
	    }


	    if(this.debugChartOptions)
		console.log(JSON.stringify(chartOptions,null,2));
            chartOptions.allowHtml = true;
	    if(this.getProperty("tableWidth"))
		chartOptions.width=this.getProperty("tableWidth");
            chartOptions.frozenColumns =this.getProperty("frozenColumns",0);
	    chartOptions.showRowNumber=this.getProperty("showRowNumber",false);

            if (dataList.length && this.getDataValues(dataList[0]).length > 4) {
                chartOptions.cssClassNames = {
                    headerCell: 'display-table-header-max'
                };
            } else {
                chartOptions.cssClassNames = {
                    headerCell: 'display-table-header'
                };
            }
	    if(!chartOptions.cssClassNames)
		chartOptions.cssClassNames = {};

	    if(this.getProperty("fixCellHeight",true)) {
		chartOptions.cssClassNames.headerCell= 'display-table-cell';
		chartOptions.cssClassNames.tableCell= 'display-table-cell';
	    }
            return new google.visualization.Table(chartDiv); 
        },
	doAddTooltip: function() {
	    return false;
	},
	getAddStyle: function() {
	    return false;
	},
	getFormatNumbers: function() {
	    return true;
	},
        xxxxmakeDataTable: function(dataList, props, selectedFields) {
            let rows = this.makeDataArray(dataList);
            let data = [];
            for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                let row = rows[rowIdx];
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
		    let t = (typeof row[colIdx]);
                    if (t == "string") {
                        row[colIdx] = row[colIdx].replace(/\n/g, "<br>");
			if(row[colIdx].startsWith("http:") || row[colIdx].startsWith("https:")) {
			    row[colIdx] = "<a href='" +row[colIdx] +"'>" + row[colIdx]+"</a>";
			}
		    } else if(t == "number") {
			//This doesn't stick
			if(isNaN(row[colIdx])) 
			    row[colIdx] = "--";
		    }
                }
                data.push(row);
            }
            return google.visualization.arrayToDataTable(data);
        }
    });

}



function BubbleDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_BUBBLE, properties);
    let myProps = [
	{label:'Bubble Chart Attibutes'},
	{p:'xField'},
	{p:'yField'},	
	{p:'labelField'},
	{p:'colorBy'},
	{p:'sizeField'},	
	{p:'legendPosition',ex:'none|top|right|left|bottom'},
	{p:'hAxisFormat',ex:'none|decimal|scientific|percent|short|long'},
	{p:'vAxisFormat',ex:'none|decimal|scientific|percent|short|long'},
	{p:'hAxisTitle',ex:''},
	{p:'vAxisTitle',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getChartDiv: function(chartId) {
            let divAttrs = [ATTR_ID, chartId];
            divAttrs.push(STYLE);
            let style = "";
	    let width = this.getProperty("chartWidth") || this.getChartWidth();
	    let height = this.getProperty("chartHeight") || this.getChartHeight();
            if (width) {
                if (width > 0)
                    style += "width:" + width + "px;";
                else if (width < 0)
                    style += "width:" + (-width) + "%;";
                else
                    style += "width:" + width + ";";
            } else {
                style += "width:" + "100%;";
            }
            if (height) {
                if (height > 0)
                    style += "height:" + height + "px;";
                else if (height < 0)
                    style += "height:" + (-height) + "%;";
                else
                    style += "height:" + height + ";";
            } else {
                style += "height:" + "100%;";
            }
	    //	    style += "border:1px solid green;"
	    style += "padding:5px;"
            divAttrs.push(style);
            return HU.div(divAttrs, "");
        },

	getFieldsToDisplay: function(fields) {
	    if(fields.length>=4) return fields;
	    let labelField=this.getFieldById(null, this.getProperty("labelField"));
	    let colorField=this.getFieldById(null, this.getColorBy(this.getProperty("colorField")));
	    let sizeField=this.getFieldById(null, this.getProperty("sizeField"));
	    let xField=this.getFieldById(null, this.getProperty("xField"));
	    let yField=this.getFieldById(null, this.getProperty("yField"));	    	    	    	    
	    if(!labelField) throw new Error("Need to specify labelField");
	    if(!xField) throw new Error("Need to specify xField");
	    if(!yField) throw new Error("Need to specify yField");	    
	    let f = [labelField, xField, yField];
	    if(colorField) f.push(colorField);
	    if(sizeField) f.push(sizeField);
	    return f;
	},

        makeDataTable: function(dataList, props, selectedFields, chartOptions) {
	    let debug =displayDebug.makeDataTable;
	    if(debug) {
		console.log(this.type+" makeDataTable #records:" + dataList.length);
                let fields = this.getSelectedFields();
		console.log("\t fields:" + fields);
	    }
	    let tmp =[];
	    let a = this.makeDataArray(dataList);
	    while(a[0].length<5)
		a[0].push("");
	    tmp.push(a[0]);
	    //Remove nans
	    this.didUnhighlight = false;
	    let minColorValue = Number.MAX_SAFE_INTEGER;
	    for(let i=1;i<a.length;i++) {
		let tuple = a[i];
		while(tuple.length<5) {
		    tuple.push(1);
		}
		minColorValue = Math.min(minColorValue, tuple[3]);
	    }


	    for(let i=1;i<a.length;i++) {
		let tuple = a[i];
		while(tuple.length<5)
		    tuple.push(1);
		if(debug && i<5)
		    console.log("\tdata:" + tuple);
		let ok = true;
		for(j=1;j<tuple.length && ok;j++) {
		    if(isNaN(tuple[j])) ok = false;
		}
		//If highlighting and have color then set to NaN
		if(this.getFilterHighlight()) {
		    let unhighlightColor = this.getProperty("unhighlightColor","#eee");
		    if(dataList[i].record && !dataList[i].record.isHighlight(this)) {
			this.didUnhighlight = true;
			tuple[3] =minColorValue-0.111;
		    }
		}
		if(ok) 
		    tmp.push(tuple);
	    }
            return google.visualization.arrayToDataTable(tmp);
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            let ct = this.getColorTable(true);
            if (ct) {
                chartOptions.colors = ct;
            } else if (!this.colors) {
                chartOptions.colors = this.getColorList();
            }
            if (chartOptions.colors) {
                chartOptions.colors = Utils.getColorTable("rainbow", true);
            }
	    $.extend(chartOptions.chartArea, {
                left: this.getProperty("chartLeft", this.chartDimensions.left),
                right: this.getProperty("chartRight", this.chartDimensions.right),
                top: this.getProperty("chartTop", "10"),
		bottom: this.getProperty("chartBottom",40),
		//                width: this.getProperty("chartWidth", '98%'),
                height: this.getProperty("chartHeight", '200')
            });
            chartOptions.height = "100px";
            chartOptions.sizeAxis = {
	    }

            chartOptions.colorAxis = {
                legend: {
                    position: this.getProperty("legendPosition", "in")
                }
            }
	    let colorTable = this.getColorTable(true);
	    if(colorTable) {
		chartOptions.colorAxis.colors = colorTable;
		if(this.didUnhighlight) {
		    chartOptions.colorAxis.colors = [...chartOptions.colorAxis.colors];
		    chartOptions.colorAxis.colors.unshift(this.getProperty("unhighlightColor","#eee"));
		}
	    }

            chartOptions.bubble = {
                textStyle: {
                    auraColor: "none"
                },
                stroke: "#666"
            };


            header = this.getDataValues(dataList[0]);
	    chartOptions.hAxis = chartOptions.hAxis||{};
            chartOptions.vAxis = chartOptions.vAxis||{};

	    chartOptions.hAxis.minValue = this.getProperty("hAxisMinValue");
	    chartOptions.hAxis.maxValue = this.getProperty("hAxisMaxValue");
	    chartOptions.vAxis.minValue = this.getProperty("vAxisMinValue");
	    chartOptions.vAxis.maxValue = this.getProperty("vAxisMaxValue");


            let records = this.getPointData().getRecords();
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[1]);
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }
	    if(this.getProperty("vAxisFixedRange")) {
		let y = this.getColumnValues(records, selectedFields[2]);
		chartOptions.vAxis.minValue = y.min;
		chartOptions.vAxis.maxValue = y.max;
	    }



	    chartOptions.vAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");
	    chartOptions.hAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");

            chartOptions.hAxis.format = this.getProperty("hAxisFormat", null);
            chartOptions.vAxis.format = this.getProperty("vAxisFormat", null);

            chartOptions.hAxis.title = this.getProperty("hAxisTitle", header.length > 1 ? header[1] : null);
            chartOptions.vAxis.title = this.getProperty("vAxisTitle", header.length > 2 ? header[2] : null);

	    //	    console.log(JSON.stringify(chartOptions,null,2));

            return new google.visualization.BubbleChart(chartDiv); 
        }

    });
}


function BartableDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, DISPLAY_BARTABLE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
	updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'bar')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            let height = "";
            if (Utils.isDefined(this.chartHeight)) {
                height = this.chartHeight;
            } else {
                if (dataList.length > 1) {
                    let numBars = dataList.length;
                    if (this.isStacked) {
                        height = numBars * 22;
                    } else {
                        height = numBars * 22 + numBars * 14 * (this.getDataValues(dataList[0]).length - 2);
                    }
                }
            }

            $.extend(chartOptions, {
                title: "the title",
                bars: 'horizontal',
                colors: this.getColorList(),
                width: (Utils.isDefined(this.chartWidth) ? this.chartWidth : "100%"),
                chartArea: {
                    left: '30%',
                    top: 0,
                    width: '70%',
                    height: '80%'
                },
                height: height,
                bars: 'horizontal',
                tooltip: {
                    showColorCode: true,
                },
                legend: {
                    position: 'none'
                },
            });

            if (Utils.isDefined(this.isStacked)) {
                chartOptions.isStacked = this.isStacked;
            }

            if (this.hAxis)
                chartOptions.hAxis = {
                    title: this.hAxis
                };
            if (this.vAxis)
                chartOptions.vAxis = {
                    title: this.vAxis
                };
            return new google.charts.Bar(chartDiv); 
        },
        getDefaultSelectedFields: function(fields, dfltList) {
            let f = [];
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (!field.isNumeric()) {
                    f.push(field);
                    break;
                }
            }
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.isNumeric()) {
                    f.push(field);
                    break;
                }
            }
            return f;
        }
    });


}


function TreemapDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TREEMAP, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        handleEventRecordSelection: function(source, args) {},
        updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'treemap')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},
        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        tooltips: {},
        makeChartOptions: function(dataList, props, selectedFields) {
            let _this = this;
            let tooltip = function(row, size, value) {
                if (_this.tooltips[row]) {
                    return _this.tooltips[row];
                }
                return "<div class='display-treemap-tooltip-outer'><div class='display-treemap-tooltip''><i>left-click: go down<br>right-click: go up</i></div></div>";
            };
            let chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            $.extend(chartOptions, {
                highlightOnMouseOver: true,
                generateTooltip: tooltip,
                maxDepth: parseInt(this.getProperty("maxDepth", 2)),
                maxPostDepth: parseInt(this.getProperty("maxPostDepth", 3)),
            });

            return chartOptions;
        },
        defaultSelectedToAll: function() {
            return true;
        },

        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            let dataTable = this.makeDataTable(dataList, props, selectedFields, chartOptions);
            if (!dataTable) return null;
            return new google.visualization.TreeMap(chartDiv);
        },

        addTuple: function(data, colorField, seen, value, parent, n1, n2) {
            let ovalue = value;
            let cnt = 0;
            if (Utils.isDefined(seen[value]) && parent) {
                value = parent + ":" + value;
            }
            while (true) {
                if (!Utils.isDefined(seen[value])) {
                    seen[value] = true;
                    break;
                }
                value = ovalue + " " + (++cnt);
            }
            let tuple = [value, parent, n1];
            if (colorField) tuple.push(n2);
            data.push(tuple);
            return value;
        },

        valueClicked: function(field, value) {
            field = this.getFieldById(this.getFields(), field);
            this.propagateEvent("fieldValueSelected", {
                field: field,
                value: value
            });
        },
        makeDataTable: function(dataList, props, selectedFields) {
            let records = this.filterData(null,null,{skipFirst:true});
            if (!records) {
                return null;
            }
            let allFields = this.getFields();
            let fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            let strings = this.getFieldsByType(fields, "string");
            if (strings.length < 2) {
                this.displayError("No string fields specified");
                return null;
            }
            let addPrefix = this.getProperty("addPrefix", true);
            let sizeField = this.getFieldById(allFields, this.getProperty("sizeBy"));
            let colorField = this.getFieldById(allFields, this.getProperty("colorBy"));
            let values = this.getFieldsByType(fields, "numeric");
            if (!sizeField && values.length > 0)
                sizeField = values[0];
            if (!colorField && values.length > 1)
                colorField = values[1];

            let tooltipFields = [];
            let toks = this.getProperty("tooltipFields", "").split(",");
            for (let i = 0; i < toks.length; i++) {
                let tooltipField = this.getFieldById(null, toks[i]);
                if (tooltipField)
                    tooltipFields.push(tooltipField);
            }
            if (tooltipFields.length == 0) tooltipFields = allFields;

            this.tooltips = {};

            let columns = [];
            for (let fieldIndex = 0; fieldIndex < strings.length; fieldIndex++) {
                let field = strings[fieldIndex];
                columns.push(this.getColumnValues(records, field).values);
            }

            let data = [];
            let leafs = [];
            let tmptt = [];
            let seen = {};
            this.addTuple(data, colorField, {}, "Node", "Parent", "Value", "Color");
            let root = strings[0].getLabel();
            this.addTuple(data, colorField, seen, root, null, 0, 0);
            let keys = {};
            let call = this.getGet();
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                //               if(rowIdx>20) break;
                let row = this.getDataValues(records[rowIdx]);
                let key = "";
                let parentKey = "";
                for (let fieldIndex = 0; fieldIndex < strings.length - 1; fieldIndex++) {
                    let values = columns[fieldIndex];
                    if (key != "")
                        key += ":";
                    key += values[rowIdx];
                    if (!Utils.isDefined(keys[key])) {
                        let parent = Utils.isDefined(keys[parentKey]) ? keys[parentKey] : root;
                        let value = values[rowIdx];
                        if (addPrefix && fieldIndex > 0)
                            value = parent + ":" + value;
                        keys[key] = this.addTuple(data, colorField, seen, value, parent, 0, 0);
                    }
                    parentKey = key;
                }
                let parent = Utils.isDefined(keys[parentKey]) ? keys[parentKey] : root;
                let value = row[strings[strings.length - 1].getIndex()];
                let size = sizeField ? row[sizeField.getIndex()] : 1;
                let color = colorField ? row[colorField.getIndex()] : 0;
                value = this.addTuple(leafs, colorField, seen, value, parent, size, color);
                let tt = "<div class='display-treemap-tooltip-outer'><div class='display-treemap-tooltip''>";
                for (let f = 0; f < tooltipFields.length; f++) {
                    let v = row[tooltipFields[f].getIndex()];
                    let field = tooltipFields[f];
                    v = HU.onClick(call + ".valueClicked('" + field.getId() + "','" + v + "')", v, []);
                    tt += HU.b(field.getLabel()) + ": " + v + "<br>";
                }
                tt += "</div></div>";
                tmptt.push(tt);
            }
            for (let i = 0; i < leafs.length; i++) {
                data.push(leafs[i]);
                this.tooltips[data.length - 2] = tmptt[i];
            }
            return google.visualization.arrayToDataTable(data);
        },
    });
}



function TimerangechartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TIMERANGECHART, properties);
    let myProps = [
	{label:'Time Range'},
	{p:'startDateField',ex:''},
	{p:'endDateField',ex:''},
	{p:'labelFields',ex:''},
	{p:'showLabel',ex:'false'},		
	{p:"fontSize",d:10},
	{p:"font",d:'Helvetica'},
	{p:'alternatingRowStyle',d:'true',ex:'false'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'timeline')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    if(this.dataColors && this.dataColors.length)
		chartOptions.colors = this.dataColors;

	    chartOptions.alternatingRowStyle = this.getAlternatingRowStyle();
	    chartOptions.timeline =  {
		rowLabelStyle: {fontName: this.getFont(), fontSize: this.getFontSize()},
                barLabelStyle: {fontName: this.getFont(), fontSize:  this.getFontSize() }
	    };

	    chartOptions.tooltip = null;
            return new google.visualization.Timeline(chartDiv);
        },
        makeDataTable: function(dataList, props, selectedFields) {
	    let tt = this.getProperty("tooltip");
	    let addTooltip = (tt || this.getProperty("addTooltip",false)) && this.doAddTooltip();
	    let records = this.filterData(null,null,{skipFirst:true});
            let strings = [];
            let stringField = this.getFieldByType(selectedFields, "string");
            if (!stringField)
                stringField = this.getFieldByType(null, "string");
            let showLabel = this.getProperty("showLabel", true);
            let labelFields = [];
            let labelFieldsTemplate = this.getProperty("labelFieldsTemplate");
            let toks = this.getProperty("labelFields", "").split(",");
            for (let i = 0; i < toks.length; i++) {
                let field = this.getFieldById(null, toks[i]);
                if (field)
                    labelFields.push(field);
            }

	    let startDateField = this.getFieldById(null,this.getPropertyStartDateField());
	    let endDateField = this.getFieldById(null,this.getPropertyEndDateField());
            let dateFields = [];
	    if(startDateField==null || endDateField==null) {
                dateFields = this.getFieldsByType(null, "date");
	    } else {
		dateFields = [startDateField, endDateField];
	    }
            let values = [];
            let dataTable = new google.visualization.DataTable();
            if (dateFields.length < 2) {
                throw new Error("Need to have at least 2 date fields");
            }

            if (stringField) {
                dataTable.addColumn({
                    type: 'string',
                    id: stringField.getLabel()
                });
            } else {
                dataTable.addColumn({
                    type: 'string',
                    id: "Index"
                });
            }

	    labelFields = [];

            if (labelFields.length > 0) {
                dataTable.addColumn({
                    type: 'string',
                    id: 'Label'
                });
            } else if(addTooltip) {
                dataTable.addColumn({
                    type: 'string',
                    id: 'dummy'
                });
	    }
	    if(addTooltip)  {
		dataTable.addColumn({
                    type: 'string',
                    role: 'tooltip',
                    'p': {
			'html': true
                    }});
	    }

            dataTable.addColumn({
                type: 'date',
                id: dateFields[0].getLabel()
            });
            dataTable.addColumn({
                type: 'date',
                id: dateFields[1].getLabel()
            });



            let colorBy = this.getColorByInfo(records);
	    if(colorBy.isEnabled()) {
		this.dataColors = [];
	    }

            for (let r = 0; r < records.length; r++) {
		let record = records[r];
                let row = this.getDataValues(records[r]);
                let tuple = [];
		if(this.dataColors) {
		    this.dataColors.push(colorBy.getColorFromRecord(record, "blue"));
		}
                values.push(tuple);
                if (stringField && showLabel)
                    tuple.push(row[stringField.getIndex()]);
                else
                    tuple.push("#" + (r + 1));
                if (labelFields.length > 0) {
                    let label = "";
                    if (labelFieldsTemplate)
                        label = labelFieldsTemplate;
                    for (let l = 0; l < labelFields.length; l++) {
                        let f = labelFields[l];
                        let value = row[f.getIndex()];
                        if (labelFieldsTemplate) {
                            label = label.replace("{" + f.getId() + "}", value);
                        } else {
                            label += value + " ";
                        }

                    }
                    tuple.push(label);
                } else 	if(addTooltip)  {
		    tuple.push(null);
		}
		if(addTooltip)  {
		    let text =   this.getRecordHtml(record, null, tt);
		    tuple.push(text);
		}
                tuple.push(row[dateFields[0].getIndex()]);
                tuple.push(row[dateFields[1].getIndex()]);
            }
            dataTable.addRows(values);
	    if(colorBy.isEnabled()) {
		colorBy.displayColorTable(null,true);
	    }
            return dataTable;
        }
    });
}



function CalendarDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_CALENDAR, properties);
    let myProps = [
	{label:'Calendar'},
	{p:'cellSize',d:15,ex:"15"},
	{p:'missingValue',ex:""},	
	{p:'strokeColor',d: '#76a7fa', ex:'#76a7fa'},
	{p:'strokeWidth',ex:'1'},
	{p:'strokeOpacity',d:0.5,ex:'0.5'},	    		
	{p:'noDataBackground',ex:'green'},
	{p:'noDataColor',ex:'red'},
	{p:'colorAxis',ex:'red,blue'},	

    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'calendar')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    let opts = {
		calendar: {
                    cellSize: parseInt(this.getPropertyCellSize()),
		    cellColor: {
			stroke: this.getPropertyStrokeColor(),
			strokeOpacity: this.getPropertyStrokeOpacity(),
			strokeWidth: this.getPropertyStrokeWidth(1),
		    },
		},
		height: this.getProperty("height", 800),
		noDataPattern: {
		    backgroundColor: this.getPropertyNoDataBackground(),
		    color: this.getPropertyNoDataColor()
		},
	    };
	    let colors = this.getPropertyColorAxis();
	    if(colors) {
		opts.colorAxis =  {
		    colors:colors.split(",")
		}
	    }
	    $.extend(chartOptions, opts);
            //If a calendar is show in tabs then it never returns from the draw
            if (this.jq(ID_CHART).width() == 0) {
                return;
            }

            let cal =  new google.visualization.Calendar(chartDiv);
	    return cal;

        },
        defaultSelectedToAll: function() {
            return true;
        },
        getContentsStyle: function() {
            let height = this.getProperty("height", 800);
            if (height > 0) {
                return " height:" + height + "px; " + " max-height:" + height + "px; overflow-y: auto;";
            }
            return "";
        },
        canDoMultiFields: function() {
            return false;
        },
        getIncludeIndexIfDate: function() {
            return true;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            let dataTable = new google.visualization.DataTable();
            let header = this.getDataValues(dataList[0]);
            if (header.length < 2) return null;
            dataTable.addColumn({
                type: 'date',
                id: 'Date'
            });
            dataTable.addColumn({
                type: 'number',
                id: header[1]
            });
            dataTable.addColumn({
                type: 'string',
                role: 'tooltip',
                'p': {
                    'html': true
                }
            });
            let haveMissing = false;
            let missing = this.getPropertyMissingValue();
            if (missing) {
                haveMissing = true;
                missing = parseFloat(missing);
            }
            let list = [];
            let cnt = 0;
            let options = {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            };
	    this.dateToRecords = {};
            for (let i = 1; i < dataList.length; i++) {
		let records = this.getBinnedRecords(dataList[i].record);
		let obj = dataList[i];
		if(!records && obj.record) records  = [obj.record];
                let value = this.getDataValues(obj)[1];
                if (value == NaN) continue;
                if (haveMissing && value == missing) {
                    continue;
                }
                cnt++;

		let dttm = this.getDataValues(dataList[i])[0];
		this.dateToRecords[dttm.v.getTime()] = records;
                let tooltip = "<center><b>" + dttm.f + "</b></center>" +
                    "<b>" + header[1].replace(/ /g, "&nbsp;") + "</b>:&nbsp;" + this.formatNumber(value);
                tooltip = HU.div([STYLE, HU.css('padding','5px')], tooltip);
                list.push([this.getDataValues(dataList[i])[0], value, tooltip]);
            }
            dataTable.addRows(list);
            return dataTable;
	}

    });


}









function GaugeDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_GAUGE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        updateUI: function(args) {
	    if(!ramaddaLoadGoogleChart(this,'gauge')) return;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	},

        getChartHeight: function() {
            return this.getProperty("height", this.getChartWidth());
        },
        getChartWidth: function() {
            return this.getProperty("width", "150");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            this.dataList = dataList;
            this.chartOptions = chartOptions;
            let min = Number.MAX_VALUE;
            let max = Number.MIN_VALUE;
            let setMinMax = true;
            for (let row = 1; row < dataList.length; row++) {
                let tuple = this.getDataValues(dataList[row]);
                //                        if(tuple.length>2) setMinMax = false;
                for (let col = 0; col < tuple.length; col++) {
                    if (!Utils.isNumber(tuple[col])) {
                        continue;
                    }
                    let value = tuple[col];
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
            min = Utils.formatNumber(min, true);
            max = Utils.formatNumber(max, true);
            if (Utils.isDefined(this.gaugeMin)) {
                setMinMax = true;
                min = parseFloat(this.gaugeMin);
            }
            if (Utils.isDefined(this.gaugeMax)) {
                setMinMax = true;
                max = parseFloat(this.gaugeMax);
            }
            if (setMinMax) {
                chartOptions.min = min;
                chartOptions.max = max;
            }
            return new google.visualization.Gauge(chartDiv);
        },

        makeDataTable: function(dataList, props, selectedFields) {
            dataList = this.makeDataArray(dataList);
            if (!Utils.isDefined(this.index)) this.index = dataList.length - 1;
            let index = this.index + 1;
            let list = [];
            list.push(["Label", "Value"]);
            let header = this.getDataValues(dataList[0]);
            if (index >= dataList.length) index = dataList.length - 1;
            let row = this.getDataValues(dataList[index]);
            for (let i = 0; i < row.length; i++) {
                if (!Utils.isNumber(row[i])) continue;
                let h = header[i];
                if (h.length > 20) {
                    let index = h.indexOf("(");
                    if (index > 0) {
                        h = h.substring(0, index);
                    }
                }
                if (h.length > 20) {
                    h = h.substring(0, 19) + "...";
                }
                if (this.getProperty("gaugeLabel"))
                    h = this.getProperty("gaugeLabel");
                else if (this["gaugeLabel" + (i + 1)]) h = this["gaugeLabel" + (i + 1)];
                let value = row[i];
                list.push([h, Utils.formatNumber(value, true)]);
            }
            return google.visualization.arrayToDataTable(list);
        },
        setChartSelection: function(index) {
            this.index = index;
            let dataTable = this.makeDataTable(this.dataList);
            this.mapCharts(chart=>{

                chart.draw(dataTable, this.chartOptions);
	    });
        },
    });
}




function ScatterplotDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaGoogleChart(displayManager, id, DISPLAY_SCATTERPLOT, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        trendLineEnabled: function() {
            return true;
        },
	setAxisRanges: function(chartOptions, selectedFields, records) {
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[0]);
		if(chartOptions.hAxis) chartOptions.hAxis = {};
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }

	    if(this.getProperty("vAxisFixedRange")) {
		if(chartOptions.vAxis) chartOptions.vAxis = {};
		let x = this.getColumnValues(records, selectedFields[1]);
		chartOptions.vAxis.minValue = x.min;
		chartOptions.vAxis.maxValue = x.max;
	    }
	},
        makeChartOptions: function(dataList, props, selectedFields) {
            let chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            chartOptions.curveType = null;
            chartOptions.lineWidth = 0;
            $.extend(chartOptions, {
                title: '',
                tooltip: {
                    isHtml: true
                },
                legend: 'none',
            });

            if (!chartOptions.chartArea) chartOptions.chartArea = {};
            $.extend(chartOptions.chartArea, {
                left: "10%",
                top: 10,
                height: "80%",
                width: "90%"
            });
            if (this.getShowTitle()) {
                chartOptions.title = this.getTitle(true);
            }

	    if (!chartOptions.hAxis) chartOptions.hAxis = {};
	    if (!chartOptions.vAxis) chartOptions.vAxis = {};
	    if(this.getProperty("hAxisLogScale", false)) 
		chartOptions.hAxis.logScale = true;
	    if(this.getProperty("vAxisLogScale", false)) 
		chartOptions.vAxis.logScale = true;


	    chartOptions.vAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");
	    chartOptions.hAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");

	    /*
	      chartOptions.trendlines =  {
	      0: {
	      type: 'linear',
	      color: 'green',
	      lineWidth: 3,
	      opacity: 0.3,
	      showR2: true,
	      visibleInLegend: true
	      }
	      };		

	    */


            if (dataList.length > 0 && this.getDataValues(dataList[0]).length > 1) {
                if (!chartOptions.vAxis) chartOptions.vAxis = {};
                if (!chartOptions.hAxis) chartOptions.hAxis = {};
		if (this.getProperty("hAxisTitle")) {
                    chartOptions.hAxis.title = this.getProperty("hAxisTitle");
		}
		if (this.getProperty("vAxisTitle")) {
                    chartOptions.vAxis.title = this.getProperty("vAxisTitle");
		}

		if(!chartOptions.hAxis.title) {
                    $.extend(chartOptions.hAxis, {
			title: this.getDataValues(dataList[0])[0]
                    });
		}

		if(!chartOptions.vAxis.title) {
                    $.extend(chartOptions.vAxis, {
			title: this.getDataValues(dataList[0])[1]
                    });
		}
                //We only have the one vAxis range for now
                if (!isNaN(this.getVAxisMinValue())) {
		    //                    chartOptions.hAxis.minValue = this.getVAxisMinValue();
                    chartOptions.vAxis.minValue = this.getVAxisMinValue();
                }
                if (!isNaN(this.getVAxisMaxValue())) {
		    //                    chartOptions.hAxis.maxValue = this.getVAxisMaxValue();
                    chartOptions.vAxis.maxValue = this.getVAxisMaxValue();
                }
            }
	    //	    console.log(JSON.stringify(chartOptions,null,2));

            return chartOptions;
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    if(!chartDiv) return
            let height = this.getProperty("height",400);
            if (Utils.isDefined(this.getProperty("chartHeight"))) {
                height = this.getProperty("chartHeight");
            }
            let width = "100%";
	    if (Utils.isDefined(this.getProperty("chartWidth"))) {
                width = this.getProperty("chartWidth");
            }
	    if((typeof height)=="number") height = height+"px";
	    if((typeof width)=="number") width = width+"px";

            $("#" + chartDiv.id).css("width", width);
            $("#" + chartDiv.id).css("height", height);
            return new google.visualization.ScatterChart(chartDiv);
        },

        getDefaultSelectedFields: function(fields, dfltList) {
            let f = [];
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.isNumeric()) {
                    f.push(field);
                    if (f.length >= 2)
                        break;
                }
            }
            return f;
        }
    });


}



/*
  Copyright 2008-2021 Geode Systems LLC
*/

const DISPLAY_SLIDES = "slides";
const DISPLAY_IMAGES = "images";
const DISPLAY_IMAGEZOOM = "imagezoom";
const DISPLAY_CARDS = "cards";


addGlobalDisplayType({
    type: DISPLAY_IMAGES,
    label: "Images",
    requiresData: true,
    forUser: true,
    category:CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Image Gallery","images.png"),                    
});

addGlobalDisplayType({
    type: DISPLAY_IMAGEZOOM,
    label: "Image Zoom",
    requiresData: true,
    forUser: true,
    category:CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Image Zoom","imagezoom.png","Show a set of images and allow for zooming in"),                        
});

addGlobalDisplayType({
    type: DISPLAY_SLIDES,
    label: "Slides",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Show records in a slide like format","slides.png")
});


addGlobalDisplayType({
    type: DISPLAY_CARDS,
    label: "Cards",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Group records hierachically showing images","cards.png"),                
});


function RamaddaCardsDisplay(displayManager, id, properties) {
    const ID_RESULTS = "results";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CARDS, properties);
    Utils.importJS(ramaddaCdn + "/lib/color-thief.umd.js",
		   () => {},
		   (jqxhr, settings, exception) => {
		       console.log("err");
		   });
  
    let myProps = [
	{label:'Cards Attributes'},
	{p:'groupByFields',ex:''},
	{p:'initGroupFields',ex:''},
	{p:'tooltipFields',ex:''},
	{p:'captionFields'},
	{p:'captionTemplate',ex:'${name}'},
	{p:'sortFields',ex:''},
	{p:'labelField',ex:''},
	{p:'imageWidth',ex:'100'},
	{p:'imageMargin',ex:'5'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        updateUI: function() {
            this.colorAnalysisEnabled = this.getProperty("doColorAnalysis");
            var pointData = this.getData();
            if (pointData == null) return;
            var allFields = pointData.getRecordFields();
	    var fields = this.getSelectedFields(allFields);
            if (fields == null || fields.length == 0) {
                fields = allFields;
	    }
            var records = this.filterData();
            if(!records) return;
	    let theFields = fields;
	    this.initGrouping  = this.getFieldsByIds(fields, this.getProperty("initGroupFields","",true));
            this.groupByFields = this.getFieldsByIds(fields, this.getProperty("groupByFields","",true));
            this.groupByMenus= +this.getProperty("groupByMenus",this.groupByFields.length);
            this.imageField = this.getFieldByType(fields, "image");
            this.urlField = this.getFieldByType(fields, "url");
            this.tooltipFields = this.getFieldsByIds(fields, this.getProperty("tooltipFields","",true));
            this.labelFields = this.getFieldsByIds(fields, this.getProperty("labelFields", null, true));
	    if(this.labelFields.length==0) {
		var tmp = this.getFieldById(fields,this.getProperty("labelField", null, true));
		if(tmp) {
		    this.labelFields.push(tmp);
		}
	    }
            this.onlyShowImages =this.getProperty("onlyShowImages", false);
            this.altLabelField = this.getFieldById(fields, this.getProperty("altLabelField", null, true));
            this.captionFields = this.getFieldsByIds(fields, this.getProperty("captionFields", "", true));
            this.captionTemplate = this.getProperty("captionTemplate",null, true);
            if(this.captionFields.length==0) this.captionFields = this.tooltipFields;
            this.colorByField = this.getFieldById(fields, this.getProperty("colorBy", null, true));
            this.colorList = this.getColorTable(true);
            this.foregroundList = this.getColorTable(true,"foreground");
            if(!this.getProperty("showImages",true)) this.imageField = null;

            if(!this.imageField)  {
                if(this.captionFields.length==0) {
                    this.displayError("No image or caption fields specified");
                    return;
                }
            }
            var contents = "";

	    if(!this.groupByHtml) {
		this.groupByHtml = "";
		if(this.colorAnalysisEnabled)
		    this.groupByHtml +=  HU.span([CLASS,"ramadda-button",ID,this.domId("docolors")], "Do colors")+" " +
		    HU.span([CLASS,"ramadda-button",ID,this.domId("docolorsreset")], "Reset");
		if(this.groupByFields.length>0) {
		    var options = [["","--"]];
		    this.groupByFields.map(field=>{
			options.push([field.getId(),field.getLabel()]);
		    });

		    this.groupByHtml +=  HU.span([CLASS,"display-fitlerby-label"], " Group by: ");
		    for(var i=0;i<this.groupByMenus;i++) {
			var selected = "";
			if(i<this.initGrouping.length) {
			    selected = this.initGrouping[i].getId();
			}
			this.groupByHtml+= HU.select("",[ID,this.domId(ID_GROUPBY_FIELDS+i)],options,selected)+"&nbsp;";
		    }
		    this.groupByHtml+="&nbsp;";
		    this.jq(ID_HEADER1).html(HU.div([CLASS,"display-filterby"],this.groupByHtml));
		    this.jq("docolors").button().click(()=>{
			this.analyzeColors();
		    });
		    this.jq("docolorsreset").button().click(()=>{
			this.updateUI();
		    });


		}
	    }



            contents += HU.div([ID,this.domId(ID_RESULTS)]);
            this.setContents(contents);
            let _this = this;
            this.jq(ID_HEADER1).find("input, input:radio,select").change(function(){
                _this.updateUI();
            });

            this.displaySearchResults(records,theFields);
        },
	analyzeColors: function() {
	    if(!window["ColorThief"]) {
		setTimeout(()=>this.analyzeColors(),1000);
		return;
	    }
	    const colorThief = new ColorThief();
	    var cnt = 0;
	    while(true) {
		var img = document.querySelector('#' + this.domId("gallery")+"img" + cnt);
		var div = $('#' + this.domId("gallery")+"div" + cnt);
		cnt++;
		if(!img) {
		    return;
		    
		}
		img.crossOrigin = 'Anonymous';
		// Make sure image is finished loading
		//		    if (img.complete) {
		var c = colorThief.getColor(img);
		var p = colorThief.getPalette(img);
		var width = img.width/p.length;
		var html = "";
		for(var i=0;i<p.length;i++) {
		    var c = p[i];
		    html+=HU.div([STYLE,HU.css('display','inline-block','width', width + "px','height', img.height +'px','background','rgb(" + c[0]+"," + c[1] +"," + c[2]+")")],"");
		}
		div.css("width",img.width);
		div.css("height",img.height);
		div.html(html);
		//			div.css("background","rgb(" + c[0]+"," + c[1] +"," + c[2]);
		img.style.display = "none";
	    }
	},
	displaySearchResults: function(records, fields) {
	    records= this.sortRecords(records);
            var fontSize = this.getProperty("fontSize",null);
            var cardStyle = this.getProperty("cardStyle",null);

            var width = this.getProperty("imageWidth","50");
            var margin = this.getProperty("imageMargin","0");
            var groupFields = [];
            var seen=[];
            for(var i=0;i<this.groupByMenus;i++) {
                var id =  this.jq(ID_GROUPBY_FIELDS+i).val();
                if(!seen[id]) {
                    seen[id] = true;
                    var field= this.getFieldById(fields, id);
                    if(field) {
                        groupFields.push(field);
                        if(field.isNumeric() && !field.range) {
                            var min = Number.MAX_VALUE;
                            var max = Number.MIN_VALUE;
                            records.map(record=>{
                                var v =field.getValue(record);
                                if(isNaN(v)) return;
                                if(v<min) min  = v;
                                if(v > max) max =v;
                            });
                            field.range = [min,max];
                            var binsProp = this.getProperty(field.getId() +".bins");
                            field.bins = [];
                            if(binsProp) {
                                var l  = binsProp.split(",");
                                for(var i=0;i<l.length-1;i++) {
                                    field.bins.push([+l[i],+l[i+1]]);
                                }
                            } else {
                                var numBins = +this.getProperty(field.getId() +".binCount",10); 
                                field.binSize = (max-min)/numBins;
                                for(var bin=0;bin<numBins;bin++) {
				    field.bins.push([min+field.binSize*bin,min+field.binSize*(bin+1)]);
				}
                            }
                        }
                    }
                }
            }

            function groupNode(id,field) {
                $.extend(this,{
                    id: id,
		    field:field,
		    members:[],
                    isGroup:true,
                    getCount: function() {
                        if(this.members.length==0) return 0;
                        if(this.members[0].isGroup) {
                            var cnt = 0;
                            this.members.map(node=>cnt+= node.getCount());
                            return cnt;
                        }
                        return this.members.length;
                    },
                    findGroup: function(v) {
                        for(var i=0;i<this.members.length;i++) {
                            if(this.members[i].isGroup && this.members[i].id == v) return this.members[i];
                        }
                        return null;
                    },
                });
            }
            var topGroup = new groupNode("");
            var colorMap ={};
            var colorCnt = 0;
	    var imgCnt = 0;
            for (var rowIdx = 0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
                var row = this.getDataValues(records[rowIdx]);
                var contents = "";
                var tooltip = "";
                this.tooltipFields.map(field=>{
                    if(tooltip!="") tooltip+="&#10;";
                    tooltip+=field.getValue(record);
                });
		tooltip =tooltip.replace(/\"/g,"&quot;");
                var label = "";
                var caption="";
                if(this.captionFields.length>0) {
                    if(this.captionTemplate) caption  = this.captionTemplate;
                    this.captionFields.map(field=>{
			var value = (""+field.getValue(record)).replace(/\"/g,"&quot;");
                        if(this.captionTemplate)
                            caption = caption.replace("\${" + field.getId()+"}",value);
                        else
                            caption+=value+"<br>";
                    });
                    if(this.urlField) {
                        var url = this.urlField.getValue(record);
                        if(url && url!="") {
                            caption = "<a style='color:inherit;'  href='" +url+"' target=_other>" +caption+"</a>";
                        }
                    }
                }
		this.labelFields.map(f=>{
		    label += row[f.getIndex()]+" ";
		});
		label = label.trim();
                var html ="";
                var img = null;
                if(this.imageField) {
                    img = row[this.imageField.getIndex()];
		    
                    if(this.onlyShowImages && !Utils.stringDefined(img)) continue;
                } 
                
                var  imgAttrs= [CLASS,"display-cards-popup","data-fancybox",this.domId("gallery"),"data-caption",caption];
		if(img) img = img.trim();
                if(Utils.stringDefined(img)) {
		    if(this.colorAnalysisEnabled)
			img = ramaddaBaseUrl+"/proxy?url=" + img;
                    img =  HU.href(img, HU.div([ID,this.domId("gallery")+"div" + imgCnt], HU.image(img,["width",width,ID,this.domId("gallery")+"img" + imgCnt])),imgAttrs)+label;
		    imgCnt++;
                    html = HU.div([CLASS,"display-cards-item", TITLE, tooltip, STYLE,HU.css('margin', margin+'px')], img);
                } else {
                    var style = "";
                    if(fontSize) {
                        style+= " font-size:" + fontSize +"; ";
                    }
                    if(this.colorByField && this.colorList) {
                        var value = this.colorByField.getValue(record);
                        if(!Utils.isDefined(colorMap[value])) {
                            colorMap[value] = colorCnt++;
                        }
                        var index = colorMap[value];
                        if(index>=this.colorList.length) {
                            index = this.colorList.length%index;
                        }
                        style+="background:" + this.colorList[index]+";";
                        if(this.foregroundList) {
                            if(index<this.foregroundList.length) {
                                style+="color:" + this.foregroundList[index]+" !important;";
                            } else {
                                style+="color:" + this.foregroundList[this.foregroundList-1]+" !important;";
                            }
                        }
                    }
                    if(cardStyle)
                        style +=cardStyle;
                    var attrs = [TITLE,tooltip,CLASS,"ramadda-gridbox display-cards-card",STYLE,style];
                    if(this.altLabelField) {
                        html = HU.div(attrs,this.altLabelField.getValue(record));
                    } else {
                        html = HU.div(attrs,caption);
                    }
                    html =  HU.href("", html,imgAttrs);
                }
                var group = topGroup;
                for(var groupIdx=0;groupIdx<groupFields.length;groupIdx++) {
                    var groupField  = groupFields[groupIdx];
                    var value = row[groupField.getIndex()];
                    if(groupField.isNumeric()) {
                        for(var binIdx=0;binIdx<groupField.bins.length;binIdx++) {
                            var bin= groupField.bins[binIdx];
                            if(value<=bin[1] || binIdx == groupField.bins.length-1) {
                                value = Utils.formatNumber(bin[0]) +" - " + Utils.formatNumber(bin[1]);
                                break;
                            }
                        }
                    }
                    var child = group.findGroup(value);
                    if(!child) {
                        group.members.push(child = new groupNode(value,groupField));
                    }
                    group = child;
                }
                group.members.push(html);
            }
	    let total = topGroup.getCount();
            let topHtml = HU.div([CLASS,"display-cards-header"],"Total" +" (" + total+")");
            topHtml+=this.makeGroupHtml(topGroup, topGroup);
            this.writeHtml(ID_RESULTS, topHtml);
            this.jq(ID_RESULTS).find("a.display-cards-popup").fancybox({
                caption : function( instance, item ) {
                    return  $(this).data('caption') || '';
                }});
        },
        makeGroupHtml: function(group, topGroup) {
            if(group.members.length==0) return "";
            var html="";
            if(group.members[0].isGroup) {
                group.members.sort((a,b)=>{
                    if(a.id<b.id) return -1;
                    if(a.id>b.id) return 1;
                    return 0;
                });
                var width = group.members.length==0?"100%":100/group.members.length;
                html +=HU.open(TABLE,[WIDTH,'100%','border',0]) +HU.open(TR,['valign','top']);
                for(var i=0;i<group.members.length;i++) {
                    var child = group.members[i];
		    var prefix="";
		    if(child.field)
			prefix = child.field.getLabel()+": ";
                    html+=HU.open(TD,[WIDTH, width+"%"]);
		    let perc = Math.round(100*child.getCount()/topGroup.getCount());
		    html+=HU.div([CLASS,"display-cards-header"],prefix+child.id +" (#" + child.getCount()+" - " + perc +"%)");
		    html+= this.makeGroupHtml(child, topGroup);
                    html+=HU.close(TD);
                }
                html +=HU.close(TR, TABLE);
            } else {
                html+=Utils.join(group.members,"");
            }
            return html;
        }
    });
}




function RamaddaImagesDisplay(displayManager, id, properties) {
    const ID_GALLERY = "gallery";
    const ID_NEXT = "next";
    const ID_PREV = "prev";
    const ID_IMAGES = "images";
    let myProps = [
	{label:'Image Gallery Properties'},
	{p:'imageField',ex:''},
	{p:'labelFields',ex:''},
	{p:'topLabelTemplate',ex:''},	
	{p:'bottomLabelTemplate',ex:''},	
	{p:'tooltipFields',ex:''},
	{p:'numberOfImages',ex:'100'},	
	{p:'includeBlanks',ex:'true'},
	{p:'blockWidth',ex:'150'},
	{p:'imageWidth',ex:'150'},
	{p:'imageHeight',ex:'150'},	
	{p:'imageMargin',ex:'10px'},
	{p:'decorate',ex:'false'},
	{p:'doPopup',ex:'false'},
	{p:'imageStyle',ex:''},			
	{p:'minHeightGallery',ex:150},
	{p:'maxHeightGallery',ex:150},	
	{p:'columns',ex:'5'},
	{p:'noun',ex:'images'},
    ];

    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_IMAGES, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	startIndex:0,
	dataFilterChanged: function() {
	    this.startIndex=0;
	    this.updateUI();
	},
        handleEventRecordSelection: function(source, args) {
	    let blocks = this.find(".display-images-block");
	    let select = HU.attrSelect(RECORD_ID, args.record.getId());
	    let block = this.find(select);
	    blocks.css('border',null);
	    block.css('border',"1px solid " +this.getHighlightColor());
	    HU.scrollVisible(this.jq(ID_IMAGES),block);
	},
        updateUI: function() {
            let records = this.filterData();
            if(!records) return;
	    let includeBlanks  = this.getPropertyIncludeBlanks(false);
	    let imageField = this.getFieldById(null, this.getProperty("imageField"));
	    if(!imageField) {
		imageField = this.getFieldByType(null,"image");
	    }
	    let urlField = this.getFieldById(null, this.getProperty("urlField"));
	    let tooltipClick = this.getProperty("tooltipClick");
            let pointData = this.getData();
            let fields = pointData.getRecordFields();

            let labelFields = this.getFieldsByIds(null, this.getProperty("labelFields", null, true));
            let topLabelTemplate = this.getPropertyTopLabelTemplate();
            let bottomLabelTemplate = this.getPropertyBottomLabelTemplate();	    
            let tooltipFields = this.getFieldsByIds(null, this.getProperty("tooltipFields", null, true));
	    if(!imageField) {
		this.setDisplayMessage("No image field in data");
		return;
	    }
	    let decorate = this.getPropertyDecorate(true);
	    let columns = +this.getPropertyColumns(0);
	    let number = +this.getPropertyNumberOfImages(50);
	    let colorBy = this.getColorByInfo(records);
	    let width = this.getPropertyImageWidth();
	    let blockWidth = this.getBlockWidth("200px");	    
	    let height = this.getPropertyImageHeight();	    
	    if(!width && !height) width="100%";
	    let imageStyle = this.getPropertyImageStyle("");
	    let contents = "";
	    let uid = HtmlUtils.getUniqueId();
	    let base = "gallery"+uid;
	    let displayedRecords = [];
	    let doPopup = this.getPropertyDoPopup(true);
	    let recordIndex = 0;
	    let columnCnt = -1;
	    let columnMap = {};
	    let class1= "display-images-image-outer display-images-block ";
	    let class2 = "display-images-image-inner";
	    this.idToRecord = {};
	    let baseStyle = "";
	    if(!decorate) {
		class2 = "";
		class1 = "display-images-block";
		baseStyle = HU.css("margin",this.getPropertyImageMargin("10px"));
	    }
	    if(columns) {
		if(width && width.endsWith("%"))
		    baseStyle+=HU.css(WIDTH,width);
	    }
	    baseStyle+=this.getProperty("blockStyle","");
	    if(this.startIndex<0) this.startIndex=0;
	    if(this.startIndex>records.length) this.startIndex=records.length-number;
	    let cnt = 1;
            for (let rowIdx = this.startIndex; rowIdx < records.length; rowIdx++) {
		let record = records[rowIdx];
                let row = this.getDataValues(record);
		let image = record.getValue(imageField.getIndex());
		if(image=="" && !includeBlanks) {
		    continue;
		}
		if(cnt++>number) break;
		displayedRecords.push(record);
		this.idToRecord[record.getId()] = record;
		let topLabel = null;
		if(topLabelTemplate) {
		    topLabel = this.getRecordHtml(record,fields,topLabelTemplate);
		}
		let label = "";
		let galleryLabel = "";
		if(Utils.stringDefined(bottomLabelTemplate)) {
		    label = this.getRecordHtml(record,fields,bottomLabelTemplate);
		} 
		labelFields.forEach(l=>{
		    let value  = record.getValue(l.getIndex());
		    if(value.getTime) {
			value = this.formatDate(value);
		    } 
		    galleryLabel += " " + value; 
		});
		if(galleryLabel=="") galleryLabel=label;
		else if(label=="") label = galleryLabel;		
		let tt = "";
		tooltipFields.forEach(l=>{tt += "\n" + l.getLabel()+": " + row[l.getIndex()]});
		tt = tt.trim();
		let style = baseStyle;
		let imgAttrs = [STYLE,imageStyle,"alt",galleryLabel,ID,base+"image" + rowIdx,"loading","lazy"];
		if(width) imgAttrs.push(WIDTH,width);
		else if(height) imgAttrs.push(HEIGHT,height);		
		let img = image==""?SPACE1:HU.image(image,imgAttrs);
		let topLbl = (topLabel!=null?HU.div([CLASS,"ramadda-clickable display-images-toplabel"], topLabel):"");
		let lbl = HU.div([CLASS,"ramadda-clickable display-images-label"], label.trim());
		if(urlField) {
		    if(topLbl!="")
			topLbl = HU.href(urlField.getValue(record), topLbl,["target","_target"]);
		    lbl = HU.href(urlField.getValue(record), lbl,["target","_target"]);
		    galleryLabel = HU.href(urlField.getValue(record), galleryLabel,["target","_target"]);
		    galleryLabel = galleryLabel.replace(/"/g,"'");
		}
		if(!this.getProperty("showBottomLabel",true))
		    lbl="";
		if(colorBy.isEnabled()) {
		    let c = colorBy.getColorFromRecord(record);
		    style+=HU.css(BACKGROUND,c);
		}

		style+=HU.css("vertical-align","top","width",blockWidth);
		if(doPopup) {
		    img = HU.href(image,img,[CLASS,"popup_image","data-fancybox",base,"data-caption",galleryLabel]);
		} else if(urlField&& !tooltipClick) {
		    img = HU.href(urlField.getValue(record),img,["target","_target"]);
		}
		let block = 
		    HU.div([STYLE, style, RECORD_ID,record.getId(),RECORD_INDEX,recordIndex++,ID,base+"div"+  rowIdx, CLASS, class1,TITLE,tt],
			   HU.div([CLASS,class2], topLbl + img + lbl));
		if(columns) {
		    if(++columnCnt>=columns) {
			columnCnt=0;
		    }
		    if(!columnMap[columnCnt]) columnMap[columnCnt] = "";
		    columnMap[columnCnt] += block;
		} else {
		    contents += block;
		}
	    }
	    if(columns) {
		contents = "<table border=0 width=100%><tr valign=top>";
		for(let col=0;true;col++) {
		    if(!columnMap[col]) break;
		    contents+=HU.td(['align','center'],columnMap[col]);
		}
		contents+="</tr></table>";
	    } else {
	    }

	    let header = "";
	    if(this.startIndex>0) {
		header += HU.span([ID,this.domId(ID_PREV)],"Previous")+" ";
	    }
	    if(this.startIndex+number<records.length) {
		header += HU.span([ID,this.domId(ID_NEXT)],"Next") +" ";
	    }
	    cnt--;
	    if(number<records.length) {
		header += "Showing " + (this.startIndex+1) +" - " +(this.startIndex+cnt);
		header += " of " + records.length +" " + this.getNoun("images");
	    }

	    if(header!="") {
		header = HU.div([STYLE,HU.css('margin-right','10px', "display","inline-block")],header);
		this.jq(ID_HEADER2_PREFIX).html(header);
		this.jq(ID_HEADER2).css("text-align","left");
	    }
	    header ="";

	    if(this.getPropertyMinHeightGallery() || this.getPropertyMaxHeightGallery()) {
		let css = "";
		if(this.getPropertyMinHeightGallery()) css+=HU.css("min-height",HU.getDimension(this.getPropertyMinHeightGallery()));
		if(this.getPropertyMinHeightGallery())	css+= HU.css("max-height",HU.getDimension(this.getPropertyMaxHeightGallery()));
		contents = HU.div([ID,this.domId(ID_IMAGES),STYLE,css+HU.css("overflow-y","auto")], contents);
	    }

	    contents  = HU.div([CLASS,"ramadda-grid"],contents);
            this.setContents(header + contents);
	    let blocks = this.find(".display-images-block");
	    let _this = this;
	    blocks.mouseenter(function() {
		$(this).attr("oldborder",$(this).css("border"));
		$(this).css("border","1px solid " + _this.getHighlightColor());
	    });
	    blocks.mouseleave(function() {
		$(this).css("border",$(this).attr("oldborder"));
	    });			      


	    this.makeTooltips(blocks,displayedRecords);
	    if(!doPopup) {
		let _this = this;
		if(!tooltipClick) {
		    blocks.click(function() {
			let record = _this.idToRecord[$(this).attr(RECORD_ID)];
			if(record) {
			    _this.propagateEventRecordSelection({record: record});
			}
		    });
		}
	    }
	    this.jq(ID_PREV).button().click(()=>{
		this.startIndex-=number;
		this.updateUI();
	    });
	    this.jq(ID_NEXT).button().click(()=>{
		this.startIndex+=number;
		this.updateUI();
	    });

	    if(this.getProperty("propagateEventRecordList",false)) {
		this.getDisplayManager().notifyEvent(DisplayEvent.recordList, this, {
		    recordList: displayedRecords,
		});
	    }
	}
    })
}



function RamaddaImagezoomDisplay(displayManager, id, properties) {
    const ID_THUMBS = "thumbs";
    const ID_THUMB = "thumb";    
    const ID_IMAGE = "image";
    const ID_IMAGEINNER = "imageinner";    
    const ID_POPUP = "imagepopup";
    const ID_POPUPIMAGE = "imagepopupimage";
    const ID_RECT = "imagerect";            
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_IMAGEZOOM, properties);
    let myProps = [
	{label:"Image Zoom Attributes"},
	{p:'labelFields'},
	{p:'thumbField'},
	{p:'thumbWidth',ex:'100'},
	{p:'imageWidth',ex:'150'},
	{p:'urlField'},
	{p:'popupWidth'},
	{p:'popupHeight'},	
	{p:"popupImageWidth",d:2000}
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	dataFilterChanged: function() {
	    this.updateUI();
	},
        updateUI: function() {
            let pointData = this.getData();
            if (pointData == null) return;
            let records = this.filterData();
            if(!records) return;
            let fields = pointData.getRecordFields();
            this.urlField = this.getFieldById(fields, this.getProperty("urlField", "url"));
	    this.imageField = this.getFieldById(fields,"image");
	    if(!this.imageField)
		this.imageField = this.getFieldByType(fields,"image");
	    if(!this.imageField) {
		this.setDisplayMessage("No image field in data");
		return;
	    }
	    this.labelFields = this.getFieldsByIds(fields, this.getPropertyLabelFields());
            let thumbField = this.getFieldById(fields, this.getProperty("thumbField", "thumb")) || this.imageField;
	    let thumbWidth = parseFloat(this.getProperty("thumbWidth",100));
	    let height=this.getHeightForStyle();
	    let imageWidth = this.getProperty("imageWidth",500);
	    this.popupWidth =  +this.getProperty("popupWidth",imageWidth);
	    this.popupHeight = +this.getProperty("popupHeight",300);

	    let rect = HU.div([STYLE,HU.css("border","1px solid " +this.getHighlightColor(),"width","20px","height","20px","left","10px","top","10px","display","none","position","absolute","z-index",1000,"pointer-events","none"),ID, this.domId(ID_RECT)]);
	    let imageDiv = HU.div(["style","position:relative"],
				  rect+
				  HU.div([ID,this.domId(ID_IMAGE),STYLE,HU.css("position","relative") ]) +
				  HU.div([ID,this.domId(ID_POPUP),CLASS,"display-imagezoom-popup",STYLE,HU.css("z-index","100","display","none",WIDTH,this.popupWidth+"px",HEIGHT,this.popupHeight+"px","overflow-y","hidden","overflow-x","hidden", "position","absolute","top","0px","left", imageWidth+"px")],""));

	    let contents = HU.table(["border",0,WIDTH,"100%"],
				    HU.tr(["valign","top"],
					  HU.td([WIDTH,"2%"],
						HU.div([ID,this.domId(ID_THUMBS), STYLE,HU.css("max-height",height,"overflow-y","auto","display","inline-block")],"")) +
					  HU.td([WIDTH,"90%"],
						imageDiv)));
	    let thumbsHtml = "";
	    let first = null;
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
		let image = row[this.imageField.getIndex()];
		if(image=="") {
		    continue;
		}
		if(!first) first=records[rowIdx];
		let thumb = row[thumbField.getIndex()];		
		thumbsHtml += HU.image(thumb,[RECORD_INDEX,rowIdx,ID,this.domId(ID_THUMB)+rowIdx,WIDTH, thumbWidth,CLASS,"display-imagezoom-thumb"])+"<br>\n";
	    }
            this.setContents(contents);
	    this.jq(ID_THUMBS).html(thumbsHtml);
	    let _this = this;
	    let thumbs = this.jq(ID_THUMBS).find(".display-imagezoom-thumb");
	    let thumbSelect = (thumb=>{
		thumbs.css("border","1px solid transparent");
		thumb.css("border","1px solid " + this.getHighlightColor());
		let index = parseFloat(thumb.attr(RECORD_INDEX));
		HU.addToDocumentUrl("imagezoom_thumb",index);
		let record = records[index]
		_this.handleImage(record);
		_this.propagateEventRecordSelection({record: record});
	    });

	    thumbs.mouseover(function() {	
		thumbSelect($(this));
	    });
	    this.jq(ID_THUMBS).css("border","1px solid transparent");
	    let selectedIndex =  HU.getUrlArgument("imagezoom_thumb");
	    let x = HU.getUrlArgument("imagezoom_x");
	    let y = HU.getUrlArgument("imagezoom_y");	    
	    let selectedThumb = this.jq(ID_THUMB+(selectedIndex||"0"));
	    if(selectedThumb.length)
		thumbSelect(selectedThumb);
	    if(selectedIndex) this.showPopup();
	    if(Utils.isDefined(x)) {
		setTimeout(()=>{
		    this.handleMouseMove({x:parseFloat(x),y:parseFloat(y)});
		},250);
	    }

	    this.jq(ID_IMAGE).click((e)=>{
		let width = +this.getPopupImageWidth();
                if (event.shiftKey) {
		    this.setProperty("popupImageWidth",Math.max(width*0.9,500));
		} else {
		    this.setProperty("popupImageWidth",width*1.2);
		}
		this.showPopup();
		this.handleMouseMove();
	    });
	},
	showPopup: function() {
	    if(!this.currentRecord) return;
	    let row = this.getDataValues(this.currentRecord);
	    let image = row[this.imageField.getIndex()];
	    this.jq(ID_POPUP).css("display","block");
	    let imageAttrs = [ID,this.domId(ID_POPUPIMAGE),STYLE,HU.css("xposition","absolute")];
	    if(this.getPopupImageWidth()) {
		imageAttrs.push(WIDTH);
		imageAttrs.push(this.getPopupImageWidth());
	    } 
	    this.jq(ID_POPUP).html(HU.image(image,imageAttrs));
	},
	handleImage: function(record, offset) {
	    let _this = this;
	    this.currentRecord = record;
            let row = this.getDataValues(record);
	    let image = row[this.imageField.getIndex()];
	    let width = this.getProperty("imageWidth",500);
    	    let label = "";
	    if(this.labelFields.length>0) {
		this.labelFields.map(l=>{label += " " + row[l.getIndex()]});
		if(this.urlField) {
                    var url = this.urlField.getValue(record);
                    if(url && url!="") {
                        label = "<a style='color:inherit;'  href='" +url+"' target=_other>" +label+ "</a>";

                    }
		}
	    }
	    let html =  HU.image(image,["x","+:zoom in/-:zoom out",STYLE,HU.css("z-index",1000),WIDTH, width,ID,this.domId(ID_IMAGEINNER)]);
	    if(label!="")
		html+=HU.div([STYLE,"color:#000"],label);
	    this.jq(ID_IMAGE).html(html);

	    this.jq(ID_POPUP).html("");
	    this.jq(ID_POPUP).css("display","none");
	    this.jq(ID_IMAGEINNER).mouseenter(()=>{
		this.showPopup();
	    });
	    this.jq(ID_IMAGEINNER).mouseout(()=>{
		this.jq(ID_POPUP).html("");
		this.jq(ID_POPUP).css("display","none");
		this.jq(ID_RECT).css("display","none");		
	    });

	    this.jq(ID_IMAGEINNER).mousemove((e)=>{
		this.handleMouseMove({
		    event:e});
	    });
	    if(offset)
		this.jq(ID_POPUPIMAGE).offset(offset);
	},
	handleMouseMove(params) {
	    if(!params) params = {event:this.currentMouseEvent};
	    this.currentMouseEvent=params.event;
	    let image = this.jq(ID_IMAGEINNER);
	    let w = image.width();
	    let h = image.height();
	    let popupImage = this.jq(ID_POPUPIMAGE);
	    let iw = popupImage.width();
	    let ih = popupImage.height();		
	    if(h==0 || ih==0) return false;
	    let popupWidth = popupImage.parent().width();
	    let popupHeight = popupImage.parent().height(); 	    	    
	    let scaleX = w/iw;
	    let scaleY = h/ih;
	    let scaledWidth = scaleX*popupWidth;
	    let scaledHeight = scaleY*popupHeight;
	    let sw2 = scaledWidth/2;
	    let sh2 = scaledHeight/2;	    
	    let parentOffset = image.parent().offset();
	    if(!Utils.isDefined(params.x)) 
		params.x = params.event.pageX - parentOffset.left;
	    if(!Utils.isDefined(params.y)) 
		params.y = params.event.pageY - parentOffset.top;
	    if(params.x<sw2) params.x=sw2;
	    if(params.y<sh2) params.y=sh2;
	    if(params.x>w-sw2) params.x=w-sw2;
	    if(params.y>h-sh2) params.y=h-sh2;	    	    
	    

	    //This causes problems
//	    HU.addToDocumentUrl("imagezoom_x",params.x);
//	    HU.addToDocumentUrl("imagezoom_y",params.y);	    

	    let offX = scaleX*iw/2;
	    let offY = scaleY*ih/2;		
	    let percentW = (params.x-sw2)/w;
	    let percentH = (params.y-sh2)/h;

	    if(popupImage.parent().length==0) return;
	    let pp = popupImage.parent().offset();
	    let offset = {
		left:pp.left-percentW*iw,
		top:pp.top-percentH*ih};
	    this.jq(ID_POPUPIMAGE).offset(offset);		    
	    let rect = this.jq(ID_RECT);
	    rect.css({"display":"block",top:params.y-sh2+"px",left:params.x-sw2+"px",width:scaledWidth+"px",height:scaledHeight+"px"});
	    return true;
	},

    })
}






function RamaddaSlidesDisplay(displayManager, id, properties) {
    const ID_SLIDE = "slide";
    const ID_PREV = "prev";
    const ID_NEXT = "next";
    if(!Utils.isDefined(properties.displayStyle)) properties.displayStyle = "background:rgba(0,0,0,0);";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_SLIDES, properties);
    let myProps = [
	{label:'Slides Attributes'},
	{p:'template',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	slideIndex:0,

        handleEventRecordSelection: function(source, args) {
	    //	    console.log(this.type+ ".recordSelection");
	    if(!this.records) return;
	    var index =-1;
	    for(var i=0;i<this.records.length;i++) {
		if(this.records[i].getId() == args.record.getId()) {
		    index = i;
		    break;
		}
	    }
	    if(index>=0) {
		this.slideIndex=index;
		this.displaySlide();
	    }
	    
	},
        getContentsStyle: function() {
            var style = "";
            var height = this.getHeightForStyle();
            if (height) {
		style += " height:" + height + ";";
            }
            var width = this.getWidthForStyle();
            if (width) {
                style += " width:" + width + ";";
            }
            return style;
        },

	updateUI: function() {
	    var pointData = this.getData();
	    if (pointData == null) return;
	    this.records = this.filterData();
	    if(!this.records) return;
            this.fields = this.getData().getRecordFields();
	    this.records= this.sortRecords(this.records);
	    var template = this.getProperty("template","");
	    var slideWidth = this.getProperty("slideWidth","100%");
            var height = this.getHeightForStyle("400");
	    var left = HU.div([ID, this.domId(ID_PREV), STYLE,HU.css('font-size','200%'),CLASS,"display-slides-arrow-left fas fa-angle-left"]);
	    var right = HU.div([ID, this.domId(ID_NEXT), STYLE,HU.css('font-size','200%'), CLASS,"display-slides-arrow-right fas fa-angle-right"]);
	    var slide = HU.div([STYLE,HU.css('overflow-y','auto','max-height', height), ID, this.domId(ID_SLIDE), CLASS,"display-slides-slide"]);

	    var navStyle = "padding-top:20px;";
	    var contents = HU.div([STYLE,HU.css('position','relative')], "<table width=100%><tr valign=top><td width=20>" + HU.div([STYLE,navStyle], left) + "</td><td>" +
					 slide + "</td>" +
					 "<td width=20>" + HU.div([STYLE,navStyle],right) + "</td></tr></table>");
	    this.setContents(contents);
	    this.jq(ID_PREV).click(() =>{
		this.slideIndex--;
		this.displaySlide(true);
	    });
	    this.jq(ID_NEXT).click(() =>{
		this.slideIndex++;
		this.displaySlide(true);
	    });
	    setTimeout(()=>{
		this.displaySlide();},200);

	},
	displaySlide: function(propagateEvent) {
	    if(this.slideIndex<0) this.slideIndex=0;
	    if(this.slideIndex>=this.records.length) this.slideIndex=this.records.length-1;
	    if(this.slideIndex==0)
		this.jq(ID_PREV).hide();
	    else
		this.jq(ID_PREV).show();
	    if(this.slideIndex==this.records.length-1)
		this.jq(ID_NEXT).hide();
	    else
		this.jq(ID_NEXT).show();
	    var record = this.records[this.slideIndex];
	    var row = this.getDataValues(record);
	    var html = this.applyRecordTemplate(record, row,this.fields,this.getProperty("template",""));
	    html = html.replace(/\${recordIndex}/g,(this.slideIndex+1));
	    this.jq(ID_SLIDE).html(html);
	    var args = {highlight:true,record: record};
	    if(propagateEvent)
		this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, this, args);
	},
        handleEventRecordHighlight: function(source, args) {
	}
    })}



/**
   Copyright 2008-2021 Geode Systems LLC
*/


const DISPLAY_FILTER = "filter";
const DISPLAY_ANIMATION = "animation";
const DISPLAY_LABEL = "label";
const DISPLAY_DOWNLOAD = "download";
const DISPLAY_LEGEND = "legend";
const DISPLAY_RELOADER = "reloader";
const DISPLAY_MESSAGE = "message";
const DISPLAY_FIELDSLIST = "fieldslist";
const DISPLAY_TICKS = "ticks";
const DISPLAY_MENU = "menu";

addGlobalDisplayType({
    type: DISPLAY_DOWNLOAD,
    label: "Download",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Show a download link",null,"Allows user to select fields and<br>download CSV and JSON")                                        
});



addGlobalDisplayType({
    type: DISPLAY_RELOADER,
    label: "Reloader",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Reload the displays",null,"Automatically reloads the displays on a set frequency")                                            
});
addGlobalDisplayType({
    type: DISPLAY_FILTER,
    label: "Filter",
    requiresData: false,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just provides data filtering")
});
addGlobalDisplayType({
    type: DISPLAY_ANIMATION,
    label: "Animation",
    requiresData: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Steps through time to drive other displays","animation.png","")                                                        
});
addGlobalDisplayType({
    type: DISPLAY_MESSAGE,
    label: "Message",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a formatted message",null,"")                                                    
});
addGlobalDisplayType({
    type: DISPLAY_MENU,
    label: "Menu",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows records in a menu to be selected")
});

addGlobalDisplayType({
    type: DISPLAY_FIELDSLIST,
    label: "Fields List",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
//    tooltip: makeDisplayTooltip("No data, just a formatted message",null,"")                                                    
});

addGlobalDisplayType({
    type: DISPLAY_LABEL,
    label: "Label",
    requiresData: false,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a text label",null,"Useful to add text to the display layout")                                                
});
addGlobalDisplayType({
    type: DISPLAY_LEGEND,
    label: "Legend",
    requiresData: false,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a configurable legend","legend.png")
});
addGlobalDisplayType({
    type: DISPLAY_TICKS,
    label: "Ticks",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows records as ticks in a timeline","ticks.png")
});

function RamaddaFilterDisplay(displayManager, id, properties) {
    let SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_FILTER, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        html: "<p>&nbsp;&nbsp;&nbsp;Nothing selected&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p>",
        initDisplay: function() {
            this.createUI();
            this.setContents(this.html);
        },
    });
}


function RamaddaAnimationDisplay(displayManager, id, properties) {
    var ID_START = "start";
    var ID_STOP = "stop";
    var ID_TIME = "time";
    let SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_ANIMATION, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        running: false,
        timestamp: 0,
        index: 0,
        sleepTime: 500,
        iconStart: "fa-play",
        iconStop: "fa-stop",
        iconBack: "fa-step-backward",
        iconForward: "fa-step-forward",
        iconSlower: "fa-minus",
	iconFaster: "fa-plus",
	iconBegin: "fa-fast-backward",
	iconEnd: "fa-fast-forward",
        needsData: function() {
            return true;
        },
        deltaIndex: function(i) {
            this.stop();
            this.setIndex(this.index + i);
        },
        setIndex: function(i) {
            if (i < 0) i = 0;
            this.index = i;
            this.applyStep(true, !Utils.isDefined(i));
        },
        toggle: function() {
            if (this.running) {
                this.stop();
            } else {
                this.start();
            }
        },
        tick: function() {
            if (!this.running) return;
            this.index++;
            this.applyStep();
            var theAnimation = this;
            setTimeout(function() {
                theAnimation.tick();
            }, this.sleepTime);
        },
        applyStep: function(propagate, goToEnd) {
            if (!Utils.isDefined(propagate)) propagate = true;
	    let records = this.currentRecords;
            if (records == null) {
                $("#" + this.getDomId(ID_TIME)).html("No data");
                return;
            }
            if (goToEnd) this.index = records.length - 1;
            if (this.index >= records.length) {
                this.index = 0;
            }
            var record = records[this.index];
            var label = "";
            if (record.getDate() != null) {
                var dttm = this.formatDate(record.getDate(), {
                    suffix: this.getTimeZone()
                });
                label += HU.b("Date:") + " " + dttm;
            } else {
                label += HU.b("Index:") + " " + this.index;
            }
            $("#" + this.getDomId(ID_TIME)).html(label);
            if (propagate) {
		this.propagateEventRecordSelection({record: record});
            }
        },
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let records = this.currentRecords;
	    if(!records) {
		if(args.record) records = [args.record];
	    }
	    records.every((r,idx)=>{
		if(r.getId() == args.record.getId()) {
		    this.index = idx;
		    this.applyStep(false);
		    return false;
		}
		return true;
	    });
        },
        faster: function() {
            this.sleepTime = this.sleepTime / 2;
            if (this.sleepTime == 0) this.sleepTime = 100;
        },
        slower: function() {
            this.sleepTime = this.sleepTime * 1.5;
        },
        start: function() {
            if (this.running) return;
            this.running = true;
            this.timestamp++;
            $("#" + this.getDomId(ID_START)).html(HU.getIconImage(this.iconStop));
            this.tick();
        },
        stop: function() {
            if (!this.running) return;
            this.running = false;
            this.timestamp++;
            $("#" + this.getDomId(ID_START)).html(HU.getIconImage(this.iconStart));
        },
        updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    this.currentRecords = records;
	    //            this.createUI();
            this.stop();

            var get = this.getGet();
            var html = "";
	    let c = "display-animation-button";
            html += HU.onClick(get + ".setIndex(0);", HU.div([ATTR_TITLE, "beginning", ATTR_CLASS, c],HU.getIconImage(this.iconBegin)));
            html += HU.onClick(get + ".deltaIndex(-1);", HU.div([ATTR_TITLE, "step back", ATTR_CLASS, c],HU.getIconImage(this.iconBack)));
            html += HU.onClick(get + ".toggle();", HU.div([ATTR_ID, this.getDomId(ID_START),ATTR_TITLE, "play/stop",ATTR_CLASS, c], HU.getIconImage(this.iconStart)));
            html += HU.onClick(get + ".deltaIndex(1);", HU.div([ATTR_TITLE, "step forward", ATTR_CLASS, c],HU.getIconImage(this.iconForward)));
            html += HU.onClick(get + ".setIndex();", HU.div([ATTR_TITLE, "end", ATTR_CLASS, c],HU.getIconImage(this.iconEnd)));
            html += HU.onClick(get + ".faster();", HU.div([ATTR_TITLE, "faster", ATTR_CLASS, c],HU.getIconImage(this.iconFaster)));
            html += HU.onClick(get + ".slower();", HU.div([ATTR_TITLE, "slower", ATTR_CLASS, c],HU.getIconImage(this.iconSlower)));
            html += HU.div(["style", "display:inline-block; min-height:24px; margin-left:10px;", ATTR_ID, this.getDomId(ID_TIME)], "&nbsp;");
            this.setDisplayTitle("Animation");
            this.setContents(html);
        },
    });
}



function RamaddaMessageDisplay(displayManager, id, properties) {
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_MESSAGE, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return false;
        },
	updateUI: function() {
	    if(this.getProperty("decorate",true)) {
		this.setContents(this.getMessage(this.getProperty("message",this.getNoDataMessage())));
	    } else {
		this.setContents(this.getProperty("message",this.getNoDataMessage()));
	    }
	}});
}

function RamaddaFieldslistDisplay(displayManager, id, properties) {
    const ID_POPUP = "popup";
    const ID_POPUP_BUTTON = "popupbutton";    
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_FIELDSLIST, properties);
    let myProps =[
	{label:"Metadata"},
	{p:"decorate",ex:true},
	{p:"asList",ex:true},
	{p:"reverseFields",ex:true},		
	{p:"selectable",ex:true},
	{p:"showFieldDetails",ex:true},
	{p:"showPopup",d:true,ex:false,tt:"Popup the selector"},	
	{p:"numericOnly",ex:true},
	{p: "filterSelect",ex:true,tt:"Use this display to select filter fields"},
	{p: "filterSelectLabel",tt:"Label to use for the button"}	
    ];
    
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	needsData: function() {
            return true;
        },
	fieldsToMap:{},
	getFieldsKey:function() {
	    let fields = this.getFields();
	    let key ='';
	    fields.forEach(f=>{
		key+='_'+f.getId();
	    });
	    return key;
	},
        setEntry: function(entry) {
	    //When we change the data then cache the existing fieldMap
	    if(this.selectedMap) {
		let key = this.getFieldsKey();
		this.fieldsToMap[key] = this.selectedMap;
	    }
	    this.selectedMap=null;
	    SUPER.setEntry.call(this, entry);
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(records == null) return;
	    let html = "";
            let selectedFields;
	    if(this.getFilterSelect()) {
		selectedFields = this.getFieldsByIds(null,this.getProperty("filterFields", ""));
	    } else  {
		selectedFields = this.getSelectedFields();
	    }
	    //Check if we've displayed a pointdata with the same set of fields
	    let key = this.getFieldsKey();
	    this.selectedMap = this.selectedMap || this.fieldsToMap[key];
	    if(this.selectedMap ==null)  {
		this.selectedMap={};
		if(selectedFields && selectedFields.length!=0) {
		    selectedFields.forEach(f=>{
			this.selectedMap[f.getId()] = true;
		    });
		} else {
		    selectedFields = null;
		}
	    } else {
		selectedFields = null;
	    }
            let fields =   this.getData().getRecordFields();
	    if(this.getNumericOnly()) {
		fields  = fields.filter(f=>{
		    return f.isFieldNumeric();
		});
	    }
	    if(this.getReverseFields()) {
		let tmp = [];
		fields.forEach(f=>{
		    tmp.unshift(f);
		});
		fields=tmp;
	    }
	    this.fields	     = fields;
	    this.fieldsMap={};
	    this.fields.forEach(f=>{
		this.fieldsMap[f.getId()] = f;
	    });
//	    html += HU.center("#" + records.length +" records");
	    let fs = [];
	    let clazz = " display-fields-field ";
	    let asList = this.getAsList();
	    if(this.getDecorate(true)) clazz+= " display-fields-field-decorated ";
	    if(asList)
		clazz+=" display-fields-list-field";
	    let selectable = this.getSelectable(true);
	    let details = this.getShowFieldDetails(false);	    
	    fields.forEach((f,idx)=>{
		let block  =f.getLabel();
		if(details) {
		    block+= "<br>" +
			f.getId() + f.getUnitSuffix()+"<br>" +
			f.getType();
		}
		let c = clazz;
		let selected = this.selectedMap[f.getId()];
		if(selectable) c += " display-fields-field-selectable ";
		if(selectable && selected) c += " display-fields-field-selected ";
		let title = "";
		if(selectable)
		    title = "Click to toggle. Shift-click toggle all";
		block =HU.div([TITLE,title,"field-selected",selected, "field-id", f.getId(),'class',c], block);
		fs.push(block);
	    });
	    let fhtml = Utils.wrap(fs,"","");
	    html += fhtml;

	    if(this.getShowPopup()) {
		html = HU.div([ID,this.domId(ID_POPUP_BUTTON)],this.getFilterSelect()?this.getFilterSelectLabel("Select Filter Fields"):"Select fields") +
		    HU.div([ID,this.domId(ID_POPUP),STYLE,"display:none;max-height:300px;overflow-y:auto;width:600px;"], html);
	    }
	    this.setContents(html);
	    if(this.getShowPopup()) {
		this.jq(ID_POPUP_BUTTON).button().click(()=>{
		    HU.makeDialog({contentId:this.domId(ID_POPUP),inPlace:true,anchor:this.domId(ID_POPUP_BUTTON),draggable:true,header:true,sticky:true});
		});
	    }
	    if(selectable) {
		let _this = this;
		let fieldBoxes = this.find(".display-fields-field");
		fieldBoxes.click(function(event) {
		    let shift = event.shiftKey ;
		    let selected  = $(this).attr("field-selected")=="true";
		    selected = !selected;
		    $(this).attr("field-selected",selected);
		    if(selected) {
			$(this).addClass("display-fields-field-selected");
		    } else {
			$(this).removeClass("display-fields-field-selected");
		    }

		    if(shift) {
			fieldBoxes.attr("field-selected",selected);
			if(selected) {
			    fieldBoxes.addClass("display-fields-field-selected");
			} else {
			    fieldBoxes.removeClass("display-fields-field-selected");
			}

		    }
		    let selectedFields = [];
		    fieldBoxes.each(function(){
			let selected  = $(this).attr("field-selected")=="true";
			if(selected) {
			    let id = $(this).attr("field-id");
			    let field = _this.fieldsMap[id];
			    if(field) selectedFields.push(field);
			}
		    });
		    _this.selectedMap = {};
		    selectedFields.forEach(f=>{
			_this.selectedMap[f.getId()] = true;
		    });
		    
		    setTimeout(()=>{
			if(_this.getFilterSelect()) {
			    _this.propagateEvent(DisplayEvent.filterFieldsSelected, selectedFields);
			} else {
			    _this.propagateEvent(DisplayEvent.fieldsSelected, selectedFields);
			}
		    },20);
		});
	    }
	}});
}


function RamaddaLabelDisplay(displayManager, id, properties) {
    var ID_TEXT = "text";
    var ID_EDIT = "edit";

    if (properties && !Utils.isDefined(properties.showTitle)) {
        properties.showTitle = false;
    }
    this.text = "";
    this.editMode = properties.editMode;
    if (properties.text) this.text = properties.text;
    else if (properties.label) this.text = properties.label;
    else if (properties.html) this.text = properties.html;
    if (properties["class"]) this["class"] = properties["class"];
    else this["class"] = "display-text";

    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_LABEL, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        initDisplay: function() {
            var theDisplay = this;
            this.createUI();
            var textClass = this["class"];
            if (this.editMode) {
                textClass += " display-text-edit ";
            }
            var style = "color:" + this.getTextColor("contentsColor") + ";";
            var html = HU.div([ATTR_CLASS, textClass, ATTR_ID, this.getDomId(ID_TEXT), "style", style], this.text);
            if (this.editMode) {
                html += HU.textarea(ID_EDIT, this.text, ["rows", 5, "cols", 120, ATTR_SIZE, "120", ATTR_CLASS, "display-text-input", ATTR_ID, this.getDomId(ID_EDIT)]);
            }
            this.setContents(html);
            if (this.editMode) {
                var editObj = this.jq(ID_EDIT);
                editObj.blur(function() {
                    theDisplay.text = editObj.val();
                    editObj.hide();
                    theDisplay.initDisplay();
                });
                this.jq(ID_TEXT).click(function() {
                    var src = theDisplay.jq(ID_TEXT);
                    var edit = theDisplay.jq(ID_EDIT);
                    edit.show();
                    edit.css('z-index', '9999');
                    edit.position({
                        of: src,
                        my: "left top",
                        at: "left top",
                        collision: "none none"
                    });
                    theDisplay.jq(ID_TEXT).html("");
                });
            }


        },
        getWikiAttributes: function(attrs) {
            SUPER.getWikiAttributes(attrs);
            attrs.push("text");
            attrs.push(this.text);
        },
    });
}



function RamaddaLegendDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width='100%';
    let SUPER =  new RamaddaDisplay(displayManager, id, DISPLAY_LEGEND, properties);
    RamaddaUtil.inherit(this,SUPER);
    let myProps = [
	{label:'Legend'},
	{p:'labels',ex:''},
	{p:'colors',ex:''},
	{p:'circles',ex:'true'},	
	{p:'inBox',ex:'true'},
	{p:'labelColor',ex:'#fff'},
	{p:'labelColors',ex:'color1,color2,...'},
	{p:'orientation',ex:'vertical'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	needsData: function() {
            return false;
	},
	updateUI: function() {
	    let labels = this.getProperty("labels","").split(",");
	    let colors = this.getColorList();
	    let html = "";
	    let colorWidth = this.getProperty("colorWidth","20px");
	    let labelColor = this.getProperty("labelColor","#000");
	    let labelColors = this.getProperty("labelColors")?this.getProperty("labelColors").split(","):null;
	    let inBox = this.getProperty("inBox",false);
	    let orientation = this.getProperty("orientation","horizontal");
	    let delim = orientation=="horizontal"?" ":"<br>";
	    let circles = this.getCircles();
	    for(let i=0;i<labels.length;i++) {
		let label = labels[i];
		let color = colors[i]||"#fff";
		if(i>0) html+=delim;
		if(!inBox) {
		    html+=HU.div(["class","display-legend-item"], HU.div(["class","display-legend-color " + (circles?"display-colortable-dot":""),"style","background:" + color+";width:" + colorWidth+";"+(circles?"height:" + colorWidth+";":	  "height:15px;")]) +
				 HU.div(["class","display-legend-label"],label));
		} else {
		    let lc = labelColors?labelColors[i]:labelColor || labelColor;
		    html+=HU.div(["class","display-legend-color","style","margin-left:8px;background:" + color+";"],
				 HU.div(["class","display-legend-label","style","margin-left:8px;margin-right:8x;color:" + lc+";"],label));
		}
	    }
	    if(orientation!="vertical") {
		html = HU.center(html); 
	    }
	    this.setContents(html);
	},
    });
}



function RamaddaDownloadDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_DOWNLOAD, properties);
    const ID_DOWNLOAD_CSV = "downloadcsv";
    const ID_DOWNLOAD_JSON = "downloadjson";
    const ID_DOWNLOAD_COPY = "downloadcopy";        
    const ID_CANCEL = "cancel";    
    let myProps =[
	{label:'Download'},
	{p:'csvLabel',ex:'Download'},
	{p:'useIcon',d:'false',ex:'false'},
	{p:'iconSize',ex:'',d:'16pt'},	
	{p:'fileName',d:'download',ex:'download'},
	{p:'askFields',d:'false',ex:'true'},
	{p:'showCsvButton',ex:false,tt:'Show/hide the CSV button'},
	{p:'showJsonButton',ex:false,tt:'Show/hide the JSON button'},
	{p:'showCopyButton',ex:false,tt:'Show/hide the Copy button'},		
//	{p:'doSave',d:false,tt:'Show the save file button'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	fieldOn:{},
	needsData: function() {
            return true;
	},
	updateUI: function() {
	    let label = this.getPropertyCsvLabel("Download Data");
	    label = label.replace("${title}",this.getProperty("title",""));
	    let useIcon = this.getPropertyUseIcon(true);
	    let iconSize = this.getIconSize();
	    label = HU.span([ID,this.getDomId("csv")], useIcon?HU.getIconImage("fa-download",null,[STYLE,"cursor:pointer;font-size:" + iconSize+";",TITLE,label]):label);
	    /*
	    if(!Utils.isAnonymous() && this.getDoSave()) {
		label+=SPACE2 +HU.span([ID,this.domId("save"),CLASS,"ramadda-clickable"], HU.getIconImage("fas fa-save")) +SPACE +HU.span([ID,this.domId("savelabel")]);
	    }
	    */
	    this.setContents(HU.div([],label));
	    /*
	    if(!Utils.isAnonymous() && this.getDoSave()) {
		let _this  = this;
		this.jq("save").click(()=>{
		    if(!confirm("Are you sure you want to change the file?")) return;
		    let records = this.filterData();
		    let fields = this.getData().getRecordFields();
		    let csv = DataUtils.getCsv(fields, records);
		    let data = new FormData();
		    data.append("file",csv);
		    data.append("entryid",this.getProperty("entryId"));
		    jQuery.ajax({
			url: ramaddaBaseUrl+"/entry/setfile",
			data: data,
			cache: false,
			contentType: false,
			processData: false,
			method: 'POST',
			type: 'POST',
			success: function(data){
			    if(data.message)
				_this.jq("savelabel").html(data.message);
			    else if(data.error)
				_this.jq("savelabel").html(data.error);			    
			    else
				console.log("response:" + JSON.stringify(data));
			    setTimeout(()=>{
				_this.jq("savelabel").html("&nbsp;");
			    },3000);
			},
			fail: function(data) {
			    _this.jq("savelabel").html("An error occurred:" + data);			    
			    console.log("An error occurred:" + data);			    
			}
		    });
		});
	    }
*/
	    if(useIcon) {
		this.jq("csv").click(() => {
		    this.doDownload();
		});
	    } else {
		this.jq("csv").button().click(() => {
		    this.doDownload();
		});
	    }
	},

	getCsv: function(fields, records,copy) {
            fields = fields || this.getData().getRecordFields();
	    let csv = DataUtils.getCsv(fields, records);
	    if(copy) {
		Utils.copyToClipboard(csv);
		alert("Copied to clipboard");
	    } else {
		Utils.makeDownloadFile(this.getPropertyFileName()+".csv", csv);
	    }
	},
	getJson: function(fields, records) {
            fields = fields || this.getData().getRecordFields();
	    DataUtils.getJson(fields, records,this.getPropertyFileName()+".json");
	},

	applyFieldSelection: function() {
	    this.getData().getRecordFields().forEach(f=>{
		let cbx = this.jq("cbx_" + f.getId());
		let on = cbx.is(':checked');
		this.fieldOn[f.getId()] = on;
	    });
	},
	getDownloadDialog: function(records) {
            let selectedFields = this.getSelectedFields();
	    if(selectedFields) {
		this.fieldOn = {};
		this.getData().getRecordFields().forEach(f=>{
		    this.fieldOn[f.getId()] = false;
		});
		selectedFields.forEach(f=>{
		    this.fieldOn[f.getId()] = true;
		});
	    }
	    
	    let space = SPACE;
	    let buttons = "";
	    if(this.getShowCsvButton(true))
		buttons+=HU.div([ID,this.getDomId(ID_DOWNLOAD_CSV)],"CSV") +space;
	    if(this.getShowJsonButton(true))
		buttons+=HU.div([ID,this.getDomId(ID_DOWNLOAD_JSON)],"JSON") +space;
	    if(this.getShowCopyButton(true))
		buttons+=  HU.div([ID,this.getDomId(ID_DOWNLOAD_COPY)],"Copy") +space;
	    buttons+=  HU.div([ID,this.getDomId(ID_CANCEL)],"Cancel");
	    let html = HU.center("#" +records.length +" records") +HU.center(buttons);
	    
	    html += "<b>Include:</b>";
	    let cbx = "";
	    cbx += HU.checkbox(this.getDomId("cbx_toggle_all"),[],true,"Toggle all") +"<br>";
	    this.getData().getRecordFields().forEach((f,idx)=>{
		let on = this.fieldOn[f.getId()];
		if(!Utils.isDefined(on)) {
		    on = true;
		}
		cbx += HU.checkbox(this.getDomId("cbx_" + f.getId()),[CLASS,"display-downloader-field-cbx"],on,f.getLabel()) +"<br>";
	    });
	    html += HU.div([STYLE,HU.css("max-height","200px","overflow-y","auto","margin-left","10px")], cbx);
	    html = HU.div([STYLE,HU.css("margin","5px")],html);
	    return html;
	},
	doDownload: function() {
	    let records = this.filterData();
	    let func = (json,copy)=>{
		this.jq(ID_DIALOG).hide();
		let fields = [];
		this.applyFieldSelection();
		this.getData().getRecordFields().forEach(f=>{
		    if(this.fieldOn[f.getId()]) {
			fields.push(f);
		    }
		});
		if(json) 
		    this.getJson(fields, records);
		else	
		    this.getCsv(fields, records,copy);
		if(this.dialog) this.dialog.remove();
		this.dialog =null;	    };
	    if(this.getPropertyAskFields(true)) {
		let html = this.getDownloadDialog(records);
		let dialog;
		let init = ()=>{
		    let _this = this;
		    this.jq("cbx_toggle_all").click(function() {
			let on = $(this).is(':checked');
			dialog.find(".display-downloader-field-cbx").each(function() {
			    $(this).prop("checked",on);
			});
		    });
		    this.jq(ID_CANCEL).button().click(() =>{
			this.applyFieldSelection();
			this.jq(ID_DIALOG).hide();
			if(this.dialog) this.dialog.remove();
			this.dialog =null;
		    });
		    this.jq(ID_DOWNLOAD_CSV).button().click(() =>{
			func(false);
		    });
		    this.jq(ID_DOWNLOAD_JSON).button().click(() =>{
			func(true);
		    });
		    this.jq(ID_DOWNLOAD_COPY).button().click(() =>{
			func(false,true);
		    });				    
		};
		dialog = this.showDialog(html,this.getDomId(ID_DISPLAY_CONTENTS),init,this.getTitle());
	    } else  {
		this.getCsv(null, records);
	    }
	},
    });
}



function RamaddaReloaderDisplay(displayManager, id, properties) {
    const ID_CHECKBOX= "cbx";
    const ID_COUNTDOWN= "countdown";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RELOADER, properties);
    let myProps = [
	{label:'Reloader'},
	{p:'interval',ex:'30',d:30,label:"Interval"},
	{p:'showCheckbox',ex:'false',d:true,label:"Show Checkbox"},
	{p:'showCountdown',ex:'false',d:true,label:"Show Countdown"},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        xxpointDataLoaded: function(pointData, url, reload) {
	},
	reloadData: function() {
	    let pointData = this.dataCollection.getList()[0];
	    pointData.loadData(this,true);
	},
	updateUI: function() {
	    let html = "";
	    //If we are already displaying then don't update the UI
	    if(this.jq(ID_COUNTDOWN).length>0) return;
	    if(this.getPropertyShowCheckbox()) {
		html += HU.checkbox(this.getDomId(ID_CHECKBOX),[],true);
	    }		
	    if(this.getPropertyShowCountdown()) {
		html+=" " + HU.span([CLASS,"display-reloader-label", ID,this.getDomId(ID_COUNTDOWN)],this.getCountdownLabel(this.getPropertyInterval()));
	    } else {
		if(this.getPropertyShowCheckbox()) {
		    html+=" " + HU.span([ID,this.getDomId(ID_COUNTDOWN)],"Reload");
		}
	    }
	    this.setContents(html);
            this.clearDisplayMessage();
	    this.jq(ID_CHECKBOX).change(()=>{
		let cbx = this.jq(ID_CHECKBOX);
		if(cbx.is(':checked')) {
		    this.setTimer(this.lastTime);
		}
	    });
	    this.jq(ID_COUNTDOWN).addClass("ramadda-clickable").css("cursor","pointer").attr("title","Reload").click(()=>{
		this.checkReload(-1);
	    });
	    this.setTimer(this.getPropertyInterval());
	},
	setDisplayMessage:function(msg) {
	    //noop
	},
	okToRun: function() {
	    let cbx = this.jq(ID_CHECKBOX);
	    if(cbx.length==0) return true;
	    return cbx.is(':checked');
	},
	getCountdownLabel: function(time) {
	    let pad = "";
	    if(time<10) pad = "&nbsp;";
	    if(time>60) {
		let minutes = Math.round((time-time%60)/60);
		let seconds = time%60;
		if(minutes<10) minutes  = "0" + String(minutes);
		if(seconds<10) seconds = "0"+String(seconds);
		return "Reload in " + minutes +":" + seconds+pad;
	    }
	    return "Reload in " + time +" seconds"+pad;
	},
	updateCountdown(time) {
	    if(this.getPropertyShowCountdown()) {
		this.jq(ID_COUNTDOWN).html(this.getCountdownLabel(time));
	    } else {
		this.jq(ID_COUNTDOWN).html("Reload");
	    }
	},
	setTimer(time) {
	    if(!this.okToRun()) return;
	    this.lastTime = time;
	    this.updateCountdown(time);
	    if(this.lastTimeout) clearTimeout(this.lastTimeout);
	    this.lastTimeout = setTimeout(()=>{
		this.checkReload(time);
	    },1000);
	},
	checkReload: function(time) {
	    time--;
	    if(time<=0) {
		this.jq(ID_COUNTDOWN).html("Reloading..." +HU.span([STYLE,"color:transparent;"],""));
		this.reloadData();
		time = this.getPropertyInterval();
		//Start up again in a bit so the reloading... label is shown
		if(this.lastTimeout) clearTimeout(this.lastTimeout);
		this.lastTimeout = setTimeout(()=>{
		    this.setTimer(time);
		},1000);
	    } else {
		this.setTimer(time);
	    }
	}
    });
}

function RamaddaTicksDisplay(displayManager, id, properties) {
    if(!properties.animationHeight) properties.animationHeight = "30px";
    properties.doAnimation =  false;
    properties.animationShowButtons = false;
    properties.animationMakeSlider = false;
    const ID_ANIMATION = "animation";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TICKS, properties);
    let myProps = [
	{label:'Time Ticks'},
	{p:'animationHeight',ex:'30px'},
	{p:'showYears',ex:'true'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {    
        needsData: function() {
            return true;
        },
	dataFilterChanged: function() {
	    SUPER.dataFilterChanged.call(this);
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let dateInfo = this.getDateInfo(records);
	    let years = {
	    }
	    if(!this.getPropertyShowYears(false)) {
		years["all"] = {
		    records:records,
		    yearCnt:"all"
		}
	    } else {
		let yearCnt=0;
		records.forEach(record=>{
		    if(!record.getDate()) return;
		    let year = record.getDate().getUTCFullYear();
		    if(years[year] == null) {
			years[year] = {
			    records:[],
			}
		    }
		    years[year].records.push(record);
		});
	    }
	    let html = "";
	    Object.keys(years).sort().forEach(year=>{
		html+=HU.div([CLASS,'display-ticks-ticks', ID,this.getDomId(ID_ANIMATION+year)]);
	    })
	    this.setContents(html);
	    Object.keys(years).sort().forEach((year,idx)=>{		 
		let info=years[year];
		let dateInfo = this.getDateInfo(info.records);
		let animation = new DisplayAnimation(this,true,{baseDomId:ID_ANIMATION+year,targetDiv:this.jq(ID_ANIMATION+year)});
		animation.makeControls();
		if(year!="all") {
		    dateInfo.dateMin = new Date(Date.UTC(year,0,1));
		    dateInfo.dateMax = new Date(Date.UTC(year,11,31));
		}
		animation.init(dateInfo.dateMin, dateInfo.dateMax,info.records);
	    });
	}
    });
}



function RamaddaMenuDisplay(displayManager, id, properties) {
    const ID_MENU = "menu";
    const ID_PREV = "prev";
    const ID_NEXT = "next";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MENU, properties);
    let myProps = [
	{label:'Record Menu'},
	{p:'labelTemplate',d:'${name}'},
	{p:'menuLabel',ex:''},
	{p:'showArrows',d:false,ex:true},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {    
        needsData: function() {
            return true;
        },
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    if(!this.recordToIdx) return;
	    let idx = this.recordToIdx[args.record.getId()];
	    if(Utils.isDefined(idx)) {
		this.jq(ID_MENU).val(idx);
	    }
	},
        pointDataLoaded: function(pointData, url, reload) {
	    SUPER.pointDataLoaded.call(this, pointData,url,reload);
	    if(this.haveLoadedData&& this.records) {
		setTimeout(()=>{
		    let record = this.records[+this.jq(ID_MENU).val()];
		    if(record) {
			this.propagateEventRecordSelection({record: record});
		    }},100);
	    }
	    this.haveLoadedData= true;
	},

	updateUI: function() {
	    this.records = this.filterData();
	    if(!this.records) return;
	    let options = [];
	    let labelTemplate = this.getLabelTemplate();
	    this.recordToIdx = {};
	    this.records.forEach((record,idx)=>{
		let label = this.getRecordHtml(record, null, labelTemplate);
		options.push([idx,label]);
		this.recordToIdx[record.getId()] = idx;
	    });

	    let menu =  HU.select("",[ATTR_ID, this.getDomId(ID_MENU)],options);
	    if(this.getShowArrows(false)) {
		let noun = this.getProperty("noun", "Data");
		let prev = HU.span([CLASS,"display-changeentries-button ramadda-clickable", TITLE,"Previous " +noun, ID, this.getDomId(ID_PREV), TITLE,"Previous"], HU.getIconImage("fa-chevron-left"));
 		let next = HU.span([CLASS, "display-changeentries-button ramadda-clickable", TITLE,"Next " + noun, ID, this.getDomId(ID_NEXT), TITLE,"Next"], HU.getIconImage("fa-chevron-right")); 
		menu = menu.replace(/\n/g,"");
		menu = prev + "&nbsp;" + menu +  "&nbsp;" +next;
	    }
	    let label = this.getMenuLabel();
	    if(label) menu = label+"&nbsp;" + menu;
	    this.setContents(menu);
	    if(this.getShowArrows(false)) {
		this.jq(ID_PREV).click(e=>{
		    let index = +this.jq(ID_MENU).val()-1;
		    if(index<0) {
			index = this.records.length-1;
		    }
		    this.jq(ID_MENU).val(index).trigger("change");
		});
		this.jq(ID_NEXT).click(e=>{
		    let index = +this.jq(ID_MENU).val()+1;
		    if(index>=this.records.length) {
			index = 0;
		    }
		    this.jq(ID_MENU).val(index).trigger("change");
		});
	    }
	    this.jq(ID_MENU).change(()=> {
		let record = this.records[+this.jq(ID_MENU).val()];
		this.propagateEventRecordSelection({record: record});
	    });

	}
    });
}


/**
Copyright 2008-2021 Geode Systems LLC
*/

const DISPLAY_NOTEBOOK = "notebook";
addGlobalDisplayType({
    type: DISPLAY_NOTEBOOK,
    label: "Notebook",
    requiresData: false,
    category: CATEGORY_CONTROLS
});

var pluginDefintions = {
    'jsx': {
        "languageId": "jsx",
        "displayName": "React JSX",
        "url": "https://raw.githubusercontent.com/hamilton/iodide-jsx/master/docs/evaluate-jsx.js",
        "module": "jsx",
        "evaluator": "evaluateJSX",
        "pluginType": "language"
    },
    "lisp": {
        "languageId": "lisp",
        "displayName": "Microtalk Lisp",
        "url": "https://ds604.neocities.org/js/microtalk.js",
        "module": "MICROTALK",
        "evaluator": "evaluate",
        "pluginType": "language",
        "outputHandler": "processLispOutput",
    },
    "sql": {
        "languageId": "sql",
        "displayName": "SqlLite",
        "url": ramaddaBaseHtdocs+"/lib/notebook/sqllite.js",
        "module": "SqlLite",
        "evaluator": "evaluate",
        "pluginType": "language"
    },
    "plantuml": {
        "languageId": "plantuml",
        "displayName": "PlantUml",
        "codeMirrorMode": "",
        "keybinding": "x",
        "url": "https://raw.githubusercontent.com/six42/iodide-plantuml-plugin/master/src/iodide-plantuml-plugin.js",
        "depends": [{
            "type": "js",
            "url": "https://raw.githubusercontent.com/johan/js-deflate/master/rawdeflate.js"
        }],
        "module": "plantuml",
        "evaluator": "plantuml_img",
        "pluginType": "language"
    },
    "ml": {
        "languageId": "ml",
        "displayName": "ocaml",
        "codeMirrorMode": "mllike",
        "keybinding": "o",
        "url": "https://louisabraham.github.io/domical/eval.js",
        "module": "evaluator",
        "evaluator": "execute",
        "pluginType": "language",
        "depends": [{
            "type": "css",
            "url": "https://louisabraham.github.io/domical/style.css"
        }]
    }
};




function RamaddaNotebookDisplay(displayManager, id, properties) {
    var ID_NOTEBOOK = "notebook";
    var ID_IMPORTS = "imports";
    var ID_CELLS = "cells";
    var ID_CELLS_BOTTOM = "cellsbottom";
    var ID_INPUTS = "inputs";
    var ID_OUTPUTS = "outputs";
    var ID_CONSOLE = "console";
    var ID_CONSOLE_TOOLBAR = "consoletoolbar";
    var ID_CONSOLE_CONTAINER = "consolecontainer";
    var ID_CONSOLE_OUTPUT = "consoleout";
    var ID_CELL = "cell";
    var ID_MENU = "menu";
    this.properties = properties || {};
    let SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_NOTEBOOK, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        runOnLoad: this.getProperty("runOnLoad", true),
        displayMode: this.getProperty("displayMode", false),
        showConsole: this.getProperty("showConsole", true),
        consoleHidden: this.getProperty("consoleHidden", false),
        layout: this.getProperty("layout", "horizontal"),
        columns: this.getProperty("columns", 1),
    });

    RamaddaUtil.defineMembers(this, {
        cells: [],
        cellCount: 0,
        fetchedNotebook: false,
        currentEntries: {},
        globals: {},
        baseEntries: {},
        outputRenderers: [],
        initDisplay: async function() {
            this.createUI();
            var imports = HtmlUtils.div(["id", this.getDomId(ID_IMPORTS)]);
            var contents = imports + HtmlUtils.div([ATTR_CLASS, "display-notebook-cells", ATTR_ID, this.getDomId(ID_CELLS)], "&nbsp;&nbsp;Loading...") +
                HtmlUtils.div([ATTR_ID, this.getDomId(ID_CELLS_BOTTOM)]);
            var popup = HtmlUtils.div(["class", "ramadda-popup", ATTR_ID, this.getDomId(ID_MENU)]);
            contents = HtmlUtils.div([ATTR_ID, this.getDomId(ID_NOTEBOOK)], popup + contents);
            this.setContents(contents);
            this.makeCellLayout();
            this.jq(ID_NOTEBOOK).hover(() => {}, () => {
                this.jq(ID_MENU).hide()
            });
            if (!this.fetchedNotebook) {
                this.initOutputRenderers();
                if (!this.fetchingNotebook) {
                    this.fetchingNotebook = true;
                    await Utils.importJS(ramaddaBaseHtdocs + "/lib/ace/src-min/ace.js");
                    await Utils.importJS(ramaddaBaseUrl + "/lib/showdown.min.js");
                    var imports = "<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Main-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Math-Italic.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Size2-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Size4-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'/>\n<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Lato:300,400,700,700i'>\n<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css' crossorigin='anonymous'>\n<script defer src='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js' crossorigin='anonymous'></script>";
                    $(imports).appendTo("head");
                    setTimeout(() => this.fetchNotebook(1), 10);
                }
            } else {
                this.layoutCells();
            }
        },
        fetchNotebook: async function(cnt) {
            if (!window["ace"]) {
                if (cnt > 50) {
                    alert("Could not load ace.js");
                    return;
                }
                setTimeout(() => this.fetchNotebook(cnt + 1), cnt * 10);
                return;
            }
            var dttm = new Date().getTime();
            ace.config.set('basePath', ramaddaBaseUrl + "/htdocs_v" + dttm + "/lib/ace/src-min");
            let _this = this;
            this.fetchedNotebook = true;
            await this.getEntry(this.getProperty("entryId", ""), entry => {
                this.baseEntry = entry;
            });
            await this.baseEntry.getRoot(entry => {
                this.rootEntry = entry;
            });
            var id = this.getProperty("entryId", "");
            var url = ramaddaBaseUrl + "/getnotebook?entryid=" + id;
            url += "&notebookId=" + this.getProperty("notebookId", "default_notebook");
            var jqxhr = $.getJSON(url, function(data) {
                _this.loadJson(data);
            }).fail(function() {
                var props = {
                    showInput: true,
                }
                this.addCell("init cell", props, false).run();
                this.cells[0].focus();
            });

        },
        formatObject: function(value) {
            return Utils.formatJson(value);
        },
        initOutputRenderers: function() {
            let notebook = this;
            this.outputRenderers = [];
            /*
            this.addOutputRenderer({
                    shouldRender: (value) => {return typeof value === "object";},
                        render: (value) => {if(Array.isArray(value)) return HtmlUtils.div(["style"," white-space: pre;"], JSON.stringify(value)); return HtmlUtils.div(["style"," white-space: pre;"],JSON.stringify(value,null,2))},
                        });
            */
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return Array.isArray(value);
                },
                render: (value) => {
                    return Utils.formatJson(value);
                },
            });
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return Array.isArray(value) && value.length > 0 && Array.isArray(value[0]);
                },
                render: (value) => {
                    var table = "<table>";
                    for (var rowIdx = 0; rowIdx < value.length; rowIdx++) {
                        var row = value[rowIdx];
                        table += "<tr>";
                        for (var colIdx = 0; colIdx < row.length; colIdx++) {
                            table += "<td>&nbsp;" + row[colIdx] + "</td>";
                        }
                        table += "</tr>";
                    }
                    table += "</table>";
                    return table;

                }
            });


            this.addOutputRenderer({
                shouldRender: (value) => {
                    return typeof value === "object" && value.getTime;
                },
                render: (value) => {
                    return notebook.formatDate(value)
                },
            });

            this.addOutputRenderer({
                shouldRender: (value) => {
                    var t = typeof value;
                    return t === "string" || t === "number" || t === "boolean";
                },
                render: (value) => {
                    if (typeof value === "string") {
                        if (value.split("\n").length > 1) {
                            return HtmlUtils.div(["style", " white-space: pre;"], value);
                        }
                    }
                    return value
                },
            });
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return typeof value === "object" && "lat" in value && "lon" in value;
                },
                render: (value) => {
                    var url = 'http://staticmap.openstreetmap.de/staticmap.php?center=' + value.lat + ',' + value.lon + '&zoom=17&size=400x150&maptype=mapnik';
                    return "<img src='" + url + "'/>"
                },
            });

        },
        addOutputRenderer: function(renderer) {
            if (this.outputRenderers.indexOf(renderer) < 0) {
                this.outputRenderers.push(renderer);
            }
        },
        formatOutput: function(value) {
            if (!value) return null;
            for (var i = this.outputRenderers.length - 1; i >= 0; i--) {
                var renderer = this.outputRenderers[i];
                if (renderer.shouldRender && renderer.shouldRender(value)) {
                    return renderer.render(value);
                }
            }
            var v = null;
            if (value.iodideRender) {
                v = value.iodideRender();
            } else if (value.notebookRender) {
                v = value.notebookRender();
            }
            if (v) {
                //TODO handle elements
                if (typeof v == "string") {
                    return v;
                }
            }
            return null;
        },
        getBaseEntry: function() {
            return this.baseEntry;
        },
        getRootEntry: function() {
            return this.rootEntry;
        },
        getPopup: function() {
            return this.jq(ID_MENU);
        },
        loadJson: async function(data) {
            if (data.error) {
                this.setContents(_this.getMessage("Failed to load notebook: " + data.error));
                return;
            }
            if (!Utils.isDefined(this.properties.runOnLoad) && Utils.isDefined(data.runOnLoad)) {
                this.runOnLoad = data.runOnLoad;
            }
            if (!Utils.isDefined(this.properties.displayMode) && Utils.isDefined(data.displayMode)) {
                this.displayMode = data.displayMode;
            }
            if (!Utils.isDefined(this.properties.showConsole) && Utils.isDefined(data.showConsole)) {
                this.showConsole = data.showConsole;
            }
            if (Utils.isDefined(data.consoleHidden)) {
                this.consoleHidden = data.consoleHidden;
            }
            if (!Utils.isDefined(this.properties.columns) && Utils.isDefined(data.columns)) {
                this.columns = data.columns;
            }
            if (!Utils.isDefined(this.properties.layout) && Utils.isDefined(data.layout)) {
                this.layout = data.layout;
            }

            if (Utils.isDefined(data.currentEntries)) {
                for (a in data.currentEntries) {
                    var obj = {};
                    if (this.currentEntries[a]) continue;
                    obj.name = a;
                    obj.entryId = data.currentEntries[a].entryId;
                    try {
                        await this.getEntry(obj.entryId, e => obj.entry = e);
                        this.currentEntries[a] = obj;
                    } catch (e) {}
                }
            }
            if (Utils.isDefined(data.cells)) {
                this.cells = [];
                data.cells.forEach(cell => this.addCell(cell.outputHtml, cell, true));
                this.layoutCells();
            }
            if (this.cells.length == 0) {
                var props = {
                    showInput: true,
                }
                this.addCell("%%wiki\n", props, false);
                this.layoutCells();
                this.cells[0].focus();
            }
            if (this.runOnLoad) {
                this.runAll();
            }
        },
        addEntry: async function(name, entryId) {
            var entry;
            await this.getEntry(entryId, e => entry = e);
            this.currentEntries[name] = {
                entryId: entryId,
                entry: entry
            };
        },
        getCurrentEntries: function() {
            return this.currentEntries;
        },
        clearEntries: function() {
            this.currentEntries = {};
            for (a in this.baseEntries)
                this.currentEntries[a] = this.baseEntries[a];
        },
        saveNotebook: function(output) {
            var json = this.getJson(output);
            json = JSON.stringify(json, null, 2);
            var args = {
                entryid: this.getProperty("entryId", ""),
                notebookId: this.getProperty("notebookId", "default_notebook"),
                notebook: json
            };
            var url = ramaddaBaseUrl + "/savenotebook";
            $.post(url, args, (result) => {
                if (result.error) {
                    alert("Error saving notebook: " + result.error);
                    return;
                }
                if (result.result != "ok") {
                    alert("Error saving notebook: " + result.result);
                    return;
                }
                if (!this.getShowConsole()) {
                    alert("Notebook saved");
                } else {
                    this.log("Notebook saved", "info", "nb");
                }
            });
        },
        showInput: function() {
            if (this.displayMode && !this.getProperty("user")) {
                return false;
            }
            if (this.getProperty("showInput", true) == false) {
                return false;
	    }
            return true;
        },
        getJson: function(output) {
            var obj = {
                cells: [],
                currentEntries: {},
                runOnLoad: this.runOnLoad,
                displayMode: this.displayMode,
                showConsole: this.showConsole,
                consoleHidden: this.consoleHidden,
                layout: this.layout,
                columns: this.columns,
            };
            for (var name in this.currentEntries) {
                var e = this.currentEntries[name];
                obj.currentEntries[name] = {
                    entryId: e.entryId
                };
            }
            this.cells.forEach(cell => obj.cells.push(cell.getJson(output)));
            return obj;
        },
        initConsole: function() {
            if (!this.showInput()) {
                return;
            }
            let _this = this;
            this.console = this.jq(ID_CONSOLE_OUTPUT);
            if (this.consoleHidden)
                this.console.hide();
            this.jq(ID_CONSOLE).find(".ramadda-image-link").click(function(e) {
                var what = $(this).attr("what");
                if (what == "clear") {
                    _this.console.html("");
                }
                e.stopPropagation();
            });

            this.consoleToolbar = this.jq(ID_CONSOLE_TOOLBAR);
            this.consoleToolbar.click(() => {
                if (this.console.is(":visible")) {
                    this.console.hide(400);
                    this.consoleHidden = true;
                } else {
                    this.consoleHidden = false;
                    this.console.show(400);
                }
            });
        },
        getShowConsole: function() {
            return this.showInput() && this.showConsole;
        },
        makeConsole: function() {
            this.console = null;
            if (!this.getShowConsole()) {
                return "";
            }
            var contents = this.jq(ID_CONSOLE_OUTPUT).html();
            var consoleToolbar = HtmlUtils.div(["id", this.getDomId(ID_CONSOLE_TOOLBAR), "class", "display-notebook-console-toolbar", "title", "click to hide/show console"],
                HtmlUtils.leftRight("",
                    HtmlUtils.span(["class", "ramadda-image-link", "title", "Clear", "what", "clear"],
                        HtmlUtils.image(Utils.getIcon("clear.png")))));
            return HtmlUtils.div(["id", this.getDomId(ID_CONSOLE), "class", "display-notebook-console"],
                consoleToolbar +
                HtmlUtils.div(["class", "display-notebook-console-output", "id", this.getDomId(ID_CONSOLE_OUTPUT)], contents || ""));
        },

        makeCellLayout: function() {
            var html = "";
            var consoleContainer = HtmlUtils.div(["id", this.getDomId(ID_CONSOLE_CONTAINER)]);
            this.jq(ID_CELLS_BOTTOM).html("");
            if (this.showInput() && this.layout == "horizontal") {
                var left = HtmlUtils.div(["id", this.getDomId(ID_INPUTS), "style", "width:100%;"]);
                var right = HtmlUtils.div(["id", this.getDomId(ID_OUTPUTS), "style", "width:100%;"]);
                var center = HtmlUtils.div([], "");
                left += consoleContainer;
                html = "<table style='table-layout:fixed;' border=0 width=100%><tr valign=top><td width=50%>" + left + "</td><td style='border-left:1px #ccc solid;' width=1>" + center + "</td><td width=49%>" + right + "</td></tr></table>";
            } else {
                this.jq(ID_CELLS_BOTTOM).html(consoleContainer);
            }
            this.jq(ID_CELLS).html(html);
        },
        plugins: {},
        addPlugin: async function(plugin, chunk) {
            var error;
            if (plugin.depends) {
                for (var i = 0; i < plugin.depends.length; i++) {
                    var obj = plugin.depends[i];
                    var type = obj.type;
                    var url = obj.url;
                    if (type == "js") {
                        await Utils.importJS(url,
                            () => {},
                            (jqxhr, settings, exception) => {
                                error = "Error fetching plugin url:" + url;
                            });
                    } else if (type == "css") {
                        await Utils.importCSS(url,
                            () => {},
                            (jqxhr, settings, exception) => {
                                error = "Error fetching plugin url:" + url;
                            });
                    }
                    if (error) {
                        this.log(error, "error", "nb", chunk ? chunk.div : null);
                        return;
                    }
                }
            }

            var url = Utils.replaceRoot(plugin.url);
            await Utils.importJS(url,
                () => {},
                (jqxhr, settings, exception) => {
                    error = "Error fetching plugin url:" + url;
                });
            if (!error) {
                var module = plugin.module;
                var tries = 200;
                //Wait 20 seconds max
                while (window[module] == null && tries-- > 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                if (!window[module]) {
                    error = "Could not load plugin module: " + module;
                } else {
                    if (window[module].isPluginReady) {
                        var tries = 200;
                        while (!window[module].isPluginReady() && tries-- > 0) {
                            //                            console.log("not ready yet:" + tries);
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        //                        console.log("final ready:" + window[module].isPluginReady() );
                        if (!window[module].isPluginReady())
                            error = "Could not load plugin module: " + module;
                    }
                }
            }
            if (error) {
                this.log(error, "error", "nb", chunk ? chunk.div : null);
                return;
            }
            this.plugins[plugin.languageId] = plugin;
        },
        hasPlugin: async function(id, callback) {
            if (!this.plugins[id]) {
                if (window.pluginDefintions[id]) {
                    await this.addPlugin(window.pluginDefintions[id], null);
                }
            }
            Utils.call(callback, this.plugins[id] != null);
        },
        processChunkWithPlugin: async function(id, chunk, callback) {
            var module = this.plugins[id].module;
            var func = this.plugins[id].evaluator;
            var result = window[module][func](chunk.getContent(), chunk);
            return Utils.call(callback, result);

        },
        processPluginOutput: function(id, chunk, result) {
            if (!result) return;
            var module = this.plugins[id].module;
            var func = window[this.plugins[id].outputHandler];
            if (func) {
                chunk.div.append(func(result));
            } else {
                if (typeof result == "object") {
                    //TODO: for now don't format this as some results are recursive
                    //                   console.log(result);
                    //                   chunk.div.set(this.formatObject(result));
                } else {
                    chunk.div.set(result);
                }
            }
        },
        log: function(msg, type, from, div) {
            var icon = "";
            var clazz = "display-notebook-console-item";
            if (typeof msg == "object") {
                msg = Utils.formatJson(msg);
            }
            if (type == "error") {
                clazz += " display-notebook-console-item-error";
                icon = HtmlUtils.image(Utils.getIcon("cross-octagon.png"));
                if (div) {
                    div.append(HtmlUtils.div(["class", "display-notebook-chunk-error"], msg));
                }
            } else if (type == "output") {
                clazz += " display-notebook-console-item-output";
                icon = HtmlUtils.image(Utils.getIcon("arrow-000-small.png"));
            } else if (type == "info") {
                clazz += " display-notebook-console-item-info";
                icon = HtmlUtils.image(Utils.getIcon("information.png"));
            }
            if (!this.console) return;
            if (!from) from = "";
            else from = HtmlUtils.div(["class", "display-notebook-console-from"], from);
            var block = HtmlUtils.div(["style", "margin-left:5px;"], msg);
            var html = "<table width=100%><tr valign=top><td width=10>" + icon + "</td><td>" +
                block +
                "</td><td width=10>" +
                from +
                "</td></tr></table>";
            var item = HtmlUtils.div(["class", clazz], html);
            this.console.append(item);
            //200 is defined in display.css
            var height = this.console.prop('scrollHeight');
            if (height > 200)
                this.console.scrollTop(height - 200);
        },
        clearConsole: function() {
            this.console.html("");
        },
        layoutCells: function() {
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.prepareToLayout();
            }
            this.makeCellLayout();
            if (this.showInput() && this.layout == "horizontal") {
                var left = "";
                var right = "";
                var id;
                for (var i = 0; i < this.cells.length; i++) {
                    var cell = this.cells[i];
                    id = cell.id;
                    cell.index = i + 1;
                    left += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], "");
                    left += "\n";
                    right += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], "");
                }
                this.jq(ID_INPUTS).html(left);
                this.jq(ID_OUTPUTS).html(right);
            } else {
                var html = "<div class=row style='padding:0px;margin:0px;'>";
                var clazz = HtmlUtils.getBootstrapClass(this.columns);
                var colCnt = 0;
                for (var i = 0; i < this.cells.length; i++) {
                    var cell = this.cells[i];
                    cell.index = i + 1;
                    html += HtmlUtils.openTag("div", ["class", clazz]);
                    html += HtmlUtils.openTag("div", ["style", "max-width:100%;overflow-x:auto;padding:0px;margin:px;"]);
                    html += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], "");
                    html += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], "");
                    html += HtmlUtils.closeTag("div");
                    html += HtmlUtils.closeTag("div");
                    html += "\n";
                    colCnt++;
                    if (colCnt >= this.columns) {
                        colCnt = 0;
                        html += HtmlUtils.closeTag("div");
                        html += "<div class=row style='padding:0px;margin:0px;'>";
                    }
                };
                html += HtmlUtils.closeTag("div");
                this.jq(ID_CELLS).append(html);
            }
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.createCell();
            };
            this.jq(ID_CONSOLE_CONTAINER).html(this.makeConsole());
            this.initConsole();
        },
        addCell: function(content, props, layoutLater) {
            cell = this.createCell(content, props);
            this.cells.push(cell);
            if (!layoutLater) {
                if (this.showInput() && this.layout == "horizontal") {
                    this.jq(ID_INPUTS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], ""));
                    this.jq(ID_OUTPUTS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], ""));
                } else {
                    this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], ""));
                    this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], ""));
                }
                cell.createCell();
            }
            return cell;
        },
        createCell: function(content, props) {
            if (!props) props = {
                showInput: true
            };
            var cellId = this.getId() + "_" + this.cellCount;
            //Override any saved id
            props.id = cellId;
            this.cellCount++;
            this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cellId], ""));
            var cell = new RamaddaNotebookCell(this, cellId, content, props);
            return cell;
        },
        clearOutput: function() {
            this.cells.forEach(cell => cell.clearOutput());
        },
        getIndex: function(cell) {
            var idx = 0;
            for (var i = 0; i < this.cells.length; i++) {
                if (cell.id == this.cells[i].id) {
                    idx = i;
                    break;
                }
            }
            return idx;
        },
        moveCellUp: function(cell) {
            var cells = [];
            var newCell = null;
            var idx = this.getIndex(cell);
            if (idx == 0) return;
            this.cells.splice(idx, 1);
            this.cells.splice(idx - 1, 0, cell);
            this.layoutCells();
            cell.focus();
        },
        moveCellDown: function(cell) {
            var cells = [];
            var newCell = null;
            var idx = this.getIndex(cell);
            if (idx == this.cells.length - 1) return;
            this.cells.splice(idx, 1);
            this.cells.splice(idx + 1, 0, cell);
            this.layoutCells();
            cell.focus();
        },

        newCellAbove: function(cell) {
            var cells = [];
            var newCell = null;
            for (var i = 0; i < this.cells.length; i++) {
                if (cell.id == this.cells[i].id) {
                    newCell = this.createCell("%%wiki\n", {
                        showInput: true,
                        showHeader: false
                    });
                    cells.push(newCell);
                }
                cells.push(this.cells[i]);
            }
            this.cells = cells;
            this.layoutCells();
            newCell.focus();
        },

        newCellBelow: function(cell) {
            var cells = [];
            var newCell = null;
            for (var i = 0; i < this.cells.length; i++) {
                cells.push(this.cells[i]);
                if (cell.id == this.cells[i].id) {
                    newCell = this.createCell("%%wiki\n", {
                        showInput: true,
                        showHeader: false
                    });
                    cells.push(newCell);
                }
            }
            this.cells = cells;
            this.layoutCells();
            newCell.focus();
        },
        deleteCell: function(cell) {
            cell.jq(ID_CELL).remove();
            var cells = [];
            this.cells.forEach(c => {
                if (cell.id != c.id) {
                    cells.push(c);
                }
            });
            this.cells = cells;
            if (this.cells.length == 0) {
                this.addCell("", null);
            }
        },
        cellValues: {},
        setCellValue: function(name, value) {
            this.cellValues[name] = value;
        },
        getCellValues: function() {
            return this.cellValues;
        },
        convertInput: function(input) {
            for (name in this.cellValues) {
                var re = new RegExp("\\$\\{" + name + "\\}", "g");
                input = input.replace(re, this.cellValues[name]);
            }
            return input;
        },
        inGlobalChanged: false,
        globalChanged: async function(name, value) {
                var globalChangeCalled = this.inGlobalChanged;
                var top = !this.inGlobalChanged;
                if(this.inRunAll) {
                    top =  false;
                }
                this.inGlobalChanged=true;
                if(top) {
                    this.cells.forEach(cell=>cell.prepareToRun());
                }
                for(var i=0;i<this.cells.length;i++) {
                    await this.cells[i].globalChanged(name,value);
                }
                if(!globalChangeCalled) {
                    this.inGlobalChanged = false;
                }
        },
        addGlobal: async function(name, value, dontPropagate) {
            //TODO: more var name cleanup
            name = name.trim().replace(/[ -]/g, "_");
            var oldValue = this.getGlobalValue(name);
            if (Utils.isDefined(window[name])) window[name] = value;
            this.globals[name] = value;
            if(!dontPropagate) {
                var newValue = this.getGlobalValue(name);
                if(newValue!=oldValue) {
                    //TODO:
                    //                    await this.globalChanged(name, newValue);
                }
            }
        },
        getGlobalValue: function(name) {
                if(!this.globals[name]) return null;
                if(typeof this.globals[name] =="function") return this.globals[name]();
                return this.globals[name];
        },
        inRunAll: false,
        runAll: async function() {
            this.inRunAll = true;
            var ok = true;
            this.cellValues = {};
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.prepareToRun();
            }
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                if (!cell.runFirst) continue;
                await this.runCell(cell).then(result => ok = result);
            }
            if (!ok) return;
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                if (cell.runFirst) continue;
                await this.runCell(cell, true).then(result => ok = result);
            }
            this.inRunAll = false;
        },
        runCell: async function(cell, doingAll) {
            if (cell.hasRun) return true;
            await cell.run(result => ok = result, {
                doingAll: doingAll
            });
            if (!ok) return false;
            var raw = cell.getRawOutput();
            if (raw) {
                raw = raw.trim();
                if (Utils.stringDefined(cell.cellName)) {
                    this.cellValues[cell.cellName] = raw;
                }
            }
            return true;
        },
        toggleAll: function(on) {
            this.cells.forEach(cell => {
                cell.showInput = on;
                cell.applyStyle();
            });
        },

    });
}




var iodide = {
    addOutputRenderer: function(renderer) {
        notebook.addOutputRenderer(renderer);
    },
    addOutputHandler: function(renderer) {
        notebook.addOutputHandler(renderer);
    },
    output: {
        text: function(t) {
            notebook.write(t);
        },
        element: function(tag) {
            var id = HtmlUtils.getUniqueId();
            notebook.write(HtmlUtils.tag(tag, ["id", id]));
            return document.getElementById(id);
        }
    },
};

var notebook;


function NotebookState(cell, div) {
    this.id = HtmlUtils.getUniqueId();
    this.cell = cell;
    this.notebook = cell.notebook;
    $.extend(this, {
        entries: {},
        div: div,
        stopFlag: false,
        result: null,
        log: function(msg, type, from) {
            this.getNotebook().log(msg, type, from, this.div);
        },
        clearConsole: function() {
            this.getNotebook().clearConsole();
        },
        getStop: function() {
            return this.stopFlag;
        },
        getCell: function() {
            return this.cell;
        },
        addGlobal: async function(name,value) {
                await this.getNotebook().addGlobal(name,value);
        },

        globalChanged: async function(name,value) {
                await this.getNotebook().globalChanged(name,value);
        },
        setValue: function(name, value) {
            this.notebook.setCellValue(name, value);
        },
        makeData: async function(entry) {
            if (!entry)
                await this.getCurrentEntry(e => entry = e);
            if ((typeof entry) == "string") {
                await this.notebook.getEntry(entry, e => entry = e);
            }
            var jsonUrl = this.notebook.getPointUrl(entry);
            if (jsonUrl == null) {
                this.writeError("Not a point type:" + entry.getName());
                return null;
            }
            var pointDataProps = {
                entry: entry,
                entryId: entry.getId()
            };
            return new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
        },
        log: function(msg, type) {
            this.getNotebook().log(msg, type, "js");
        },
        getNotebook: function() {
            return this.notebook;
        },

        save: function(output) {
            this.notebook.saveNotebook(output);
            return "notebook saved";
        },

        clearEntries: function() {
            this.clearEntries();
        },

        ls: async function(entry) {
            var div = new Div();
            if (!entry)
                await this.getCurrentEntry(e => entry = e);
            this.call.getEntryHeading(entry, div);
            this.write(div.toString());
        },

        lsEntries: function() {
            var h = "";
            var entries = this.currentEntries;
            for (var name in entries) {
                var e = entries[name];
                h += name + "=" + e.entry.getName() + "<br>";
            }
            this.write(h);
        },

        stop: function() {
            this.stopFlag = true;
        },
        setGlobal: async function(name, value) {
                await this.cell.notebook.addGlobal(name, value);
        },
        setEntry: function(name, entryId) {
            this.cell.notebook.addEntry(name, entryId);
        },
        getEntry: async function(entryId, callback) {
            await this.cell.notebook.getEntry(e => entry = e);
            return Utils.call(callback, entry);
        },
        wiki: async function(s, entry, callback) {
            if (!callback) {
                var wdiv = new Div();
                this.div.append(wdiv.toString());
                callback = h => wdiv.append(h);
            }
            if (entry == null)
                await this.cell.getCurrentEntry(e => entry = e);
            if ((typeof entry) != "string") entry = entry.getId();
            await GuiUtils.loadHtml(ramaddaBaseUrl + "/wikify?doImports=false&entryid=" + entry + "&text=" + encodeURIComponent(s),
                callback);
        },
        //These are for the iodiode mimic
        addOutputRenderer: function(renderer) {
            this.getNotebook().addOutputRenderer(renderer);
        },
        addOutputHandler: function(renderer) {
            this.getNotebook().addOutputRenderer(renderer);
        },
        output: {
            text: function(t) {
                notebook.write(t);
            },
            element: function(tag) {
                var id = HtmlUtils.getUniqueId();
                notebook.write(HtmlUtils.tag(tag, ["id", id]));
                return document.getElementById(id);
            }
        },
        clearOutput: function() {
            this.cell.clearOutput();
        },
        clearAllOutput: function() {
            this.getNotebook().clearOutput();
        },
        write: function(value, clear) {
            if (!value) return;
            var s = this.getNotebook().formatOutput(value);
            if (s == null && (typeof value) == "object") {
                s = this.notebook.formatObject(value);
            }
            if (clear)
                this.div.set(s);
            else
                this.div.append(s);
        },
        linechart: async function(entry, props) {
            if (!entry)
                await this.cell.getCurrentEntry(e => entry = e);
            this.cell.createDisplay(this, entry, DISPLAY_LINECHART, props);
        },
    });
}


var notebookStates = {};

function RamaddaNotebookCell(notebook, id, content, props) {
    this.notebook = notebook;

    var ID_CELL = "cell";
    var ID_HEADER = "header";
    var ID_CELLNAME = "cellname";
    var ID_INPUT = "input";
    var ID_INPUT_TOOLBAR = "inputtoolbar";
    var ID_OUTPUT = "output";
    var ID_MESSAGE = "message";
    var ID_BUTTON_MENU = "menubutton";
    var ID_BUTTON_RUN = "runbutton";
    var ID_BUTTON_TOGGLE = "togglebutton";
    var ID_MENU = "menu";
    var ID_CELLNAME_INPUT = "cellnameinput";
    var ID_SHOWHEADER_INPUT = "showheader";
    var ID_SHOWEDIT = "showedit";
    var ID_RUN_ON_LOAD = "runonload";
    var ID_DISPLAY_MODE = "displaymode";
    var ID_LAYOUT_TYPE = "layouttype";
    var ID_SHOWCONSOLE = "showconsole";
    var ID_LAYOUT_COLUMNS = "layoutcolumns";
    var ID_RUNFIRST = "runfirst";
    var ID_SHOW_OUTPUT = "showoutput";
    var ID_RUN_ICON = "runningicon";

    let SUPER = new DisplayThing(id, {});
    RamaddaUtil.inherit(this, SUPER);

    RamaddaUtil.defineMembers(this, {
        id: id,
        inputRows: 1,
        index: 0,
        content: content,
        outputHtml: "",
        showInput: false,
        showHeader: false,
        cellName: "",
        runFirst: false,
        showOutput: true,
    });

    if (props) {
        $.extend(this, props);
    }
    RamaddaUtil.defineMembers(this, {
        getJson: function(output) {
            var obj = {
                id: this.id,
                inputRows: this.inputRows,
                content: this.getInputText(),
                showInput: this.showInput,
                showHeader: this.showHeader,
                runFirst: this.runFirst,
                showOutput: this.showOutput,
                cellName: this.cellName,
            };
            if (this.currentEntry)
                obj.currentEntryId = this.currentEntry.getId();
            if (output)
                obj.outputHtml = this.outputHtml;
            return obj;
        },
        createCell: function() {
            if (this.content == null) {
                this.content = "%% wiki";
            }
            this.editId = addHandler(this);
            addHandler(this, this.editId + "_entryid");
            addHandler(this, this.editId + "_wikilink");
            var _this = this;
            var buttons =
                this.makeButton(ID_BUTTON_MENU, icon_menu, "Show menu", "showmenu") +
                this.makeButton(ID_BUTTON_RUN, Utils.getIcon("run.png"), "Run this cell", "run") +
                this.makeButton(ID_BUTTON_RUN, Utils.getIcon("runall.png"), "Run all", "runall");

            var runIcon = HtmlUtils.image(icon_blank, ["align", "right", "id", this.getDomId(ID_RUN_ICON), "style", "padding-bottom:2px;padding-top:2px;padding-right:5px;"]);
            buttons = buttons + "&nbsp;" + HtmlUtils.span(["id", this.getDomId(ID_CELLNAME)], this.cellName);
            buttons += runIcon;
            var header = HtmlUtils.div([ATTR_CLASS, "display-notebook-header", ATTR_ID, this.getDomId(ID_HEADER), "tabindex", "0", "title", "Click to toggle input\nShift-click to clear output"], "&nbsp;" + buttons);

            //Strip out the meta chunks
            var content = "";
            var lines = this.content.split("\n");
            var inMeta = false;
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var _line = line.trim();
                if (_line.startsWith("%%")) {
                    if (_line.match(/^%% *meta/)) {
                        inMeta = true;
                    } else {
                        inMeta = false;
                    }
                }
                if (!inMeta) {
                    content += line + "\n";
                }
            }


            content = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            var input = HtmlUtils.div([ATTR_CLASS, "display-notebook-input ace_editor", ATTR_ID, this.getDomId(ID_INPUT), "title", "shift-return: run chunk\nctrl-return: run to end"], content);
            var inputToolbar = HtmlUtils.div(["id", this.getDomId(ID_INPUT_TOOLBAR)], "");

            input = HtmlUtils.div(["class", "display-notebook-input-container"], inputToolbar + input);
            var output = HtmlUtils.div([ATTR_CLASS, "display-notebook-output", ATTR_ID, this.getDomId(ID_OUTPUT)], this.outputHtml);
            output = HtmlUtils.div(["class", "display-notebook-output-container"], output);
            var menu = HtmlUtils.div(["id", this.getDomId(ID_MENU), "class", "ramadda-popup"], "");
            var html = header + input;
            html = HtmlUtils.div(["id", this.getDomId(ID_CELL)], html);
            $("#" + this.id + "_cellinput").html(html);
            $("#" + this.id + "_celloutput").html(output);
            var url = ramaddaBaseUrl + "/wikitoolbar?doImports=false&entryid=" + this.entryId + "&handler=" + this.editId;
            url += "&extrahelp=" + ramaddaBaseUrl + "/userguide/notebook.html|Notebook Help";
            GuiUtils.loadHtml(url, h => {
                this.inputToolbar = h;
                this.jq(ID_INPUT_TOOLBAR).html(h);
                $("#" + this.editId + "_prefix").html(HtmlUtils.span(["id", this.getDomId("toolbar_notebook"),
                    "style", "border-right:1px #ccc solid;",
                    "class", "ramadda-menubar-button"
                ], "Notebook"));
                this.jq("toolbar_notebook").click(() => this.showNotebookMenu());

            });
            this.header = this.jq(ID_HEADER);
            this.header.click((e) => {
                if (e.shiftKey)
                    this.processCommand("clear");
                else {
                    this.hidePopup();
                    this.processCommand("toggle");
                }

            });

            let wikiEditor = new WikiEditor("", "", this.getDomId(ID_INPUT), false, {
                maxLines: 30,
                minLines: 5
            });
	    this.editor = wikiEditor.getEditor();
            this.editor.getSession().on('change', () => {
                this.inputChanged();
            });
            this.menuButton = this.jq(ID_BUTTON_MENU);
            this.toggleButton = this.jq(ID_BUTTON_TOGGLE);
            this.cell = this.jq(ID_CELL);
            this.input = this.jq(ID_INPUT);
            this.output = this.jq(ID_OUTPUT);
            this.inputContainer = this.cell.find(".display-notebook-input-container");
            this.inputMenu = this.cell.find(".display-notebook-input-container");
            this.applyStyle();
            this.header.find(".display-notebook-menu-button").click(function(e) {
                _this.processCommand($(this).attr("what"));
                e.stopPropagation();
            });

            this.calculateInputHeight();
            this.input.focus(() => this.hidePopup());
            this.input.click(() => this.hidePopup());
            this.output.click(() => this.hidePopup());
            this.input.on('input selectionchange propertychange', () => this.calculateInputHeight());
            var moveFunc = (e) => {
                var key = e.key;
                if (key == 'v' && e.ctrlKey) {
                    this.notebook.moveCellDown(_this);
                    return;
                }
                if (key == 6 && e.ctrlKey) {
                    this.notebook.moveCellUp(_this);
                    return;
                }

            };
            this.input.keydown(moveFunc);
            this.header.keydown(moveFunc);
            this.input.keydown(function(e) {
                var key = e.key;
                if (key == 's' && e.ctrlKey) {
                    _this.notebook.saveNotebook(false);
                    return;
                }
                if (key == 'Enter') {
                    //                    console.log(key +"  shift:"  + e.shiftKey +" ctrl:" + e.ctrlKey);
                    if (e.shiftKey || e.ctrlKey) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (e.shiftKey && e.ctrlKey) {
                            //run all
                            _this.run(null);
                        } else {
                            //run current, run to end
                            _this.run(null, {
                                justCurrent: true,
                                toEnd: e.ctrlKey
                            });
                            if (!e.ctrlKey) {
                                _this.stepToNextChunk();
                            }
                        }
                    }
                }

            });
        },
        selectClick(type, id, entryId, value) {
            if (type == "entryid") {
                this.insertText(entryId);
            } else {
                this.insertText("[[" + entryId + "|" + value + "]]");
            }
            this.input.focus();
        },
        insertTags: function(tagOpen, tagClose, sampleText) {
            var id = this.getDomId(ID_INPUT);
            var textComp = GuiUtils.getDomObject(id);
            insertTagsInner(id, textComp.obj, tagOpen, tagClose, sampleText);
            this.calculateInputHeight();
        },
        insertText: function(value) {
            var id = this.getDomId(ID_INPUT);
            var textComp = GuiUtils.getDomObject(id);
            insertAtCursor(id, textComp.obj, value);
            this.calculateInputHeight();
        },
        showNotebookMenu: function() {
            var link = this.jq("toolbar_notebook");
            this.makeMenu(link, "left bottom");
        },
        makeButton: function(id, icon, title, command) {
            if (!command) command = "noop";
            return HtmlUtils.div(["what", command, "title", title, "class", "display-notebook-menu-button", "id", this.getDomId(id)], HtmlUtils.image(icon, []));
        },
        makeMenu: function(src, at) {
            if (!src) {
                src = this.input;
            }
            if (!src.is(":visible")) {
                src = this.header;
            }
            if (!src.is(":visible")) {
                src = this.output;
            }
            if (!at) at = "left top";
            let _this = this;
            var space = "&nbsp;&nbsp;";
            var line = "<div style='border-top:1px #ccc solid;margin-top:4px;margin-bottom:4px;'></div>"
            var menu = "";
            menu += HtmlUtils.input(ID_CELLNAME_INPUT, _this.cellName, ["placeholder", "Cell name", "style", "width:100%;", "id", _this.getDomId(ID_CELLNAME_INPUT)]);
            menu += "<br>";
            menu += "<table  width=100%> ";
            menu += "<tr><td align=right><b>New cell:</b>&nbsp;</td><td>";
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "newabove"], "Above") + space;
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "newbelow"], "Below");
            menu += "</td></tr>"
            menu += "<tr><td align=right><b>Move:</b>&nbsp;</td><td>";
            menu += HtmlUtils.div(["title", "ctrl-^", "class", "ramadda-link", "what", "moveup"], "Up") + space;
            menu += HtmlUtils.div(["title", "ctrl-v", "class", "ramadda-link", "what", "movedown"], "Down");
            menu += "</td></tr>"

            menu += "</table>";

            menu += line;
            menu += HtmlUtils.div(["title", "ctrl-return", "class", "ramadda-link", "what", "hideall"], "Hide all inputs");
            menu += "<br>"
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "clearall"], "Clear all outputs");
            menu += "<br>";
            var cols = this.notebook.columns;
            var colId = _this.getDomId(ID_LAYOUT_COLUMNS);
            menu += "<b>Layout:</b> ";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_LAYOUT_TYPE), [], _this.notebook.layout == "horizontal") + " Horizontal" + "<br>";
            //            menu += "Columns: ";
            //            menu += HtmlUtils.input(colId, this.notebook.columns, ["size", "3", "id", _this.getDomId(ID_LAYOUT_COLUMNS)]);
            menu += line;

            menu += HtmlUtils.checkbox(_this.getDomId(ID_SHOW_OUTPUT), [], _this.showOutput) + " Output enabled" + "<br>";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_SHOWCONSOLE), [], _this.notebook.showConsole) + " Show console" + "<br>";

            menu += HtmlUtils.checkbox(_this.getDomId(ID_RUNFIRST), [], _this.runFirst) + " Run first" + "<br>";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_RUN_ON_LOAD), [], _this.notebook.runOnLoad) + " Run on load" + "<br>";
            menu += HtmlUtils.div(["title", "Don't show the left side and input for anonymous users"], HtmlUtils.checkbox(_this.getDomId(ID_DISPLAY_MODE), [], _this.notebook.displayMode) + " Display mode" + "<br>");

            menu += line;
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "savewithout"], "Save notebook") + "<br>";
            menu += line;
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "delete"], "Delete cell") + "<br>";
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "help"], "Help") + "<br>";
            menu = HtmlUtils.div(["class", "display-notebook-menu"], menu);


            var popup = this.getPopup();
            this.dialogShown = true;
            popup.html(HtmlUtils.div(["class", "ramadda-popup-inner"], menu));
            popup.show();
            popup.position({
                of: src,
                my: "left top",
                at: at,
                collision: "fit fit"
            });
            _this.jq(ID_SHOWHEADER_INPUT).focus();

            _this.jq(ID_SHOWCONSOLE).change(function(e) {
                _this.notebook.showConsole = _this.jq(ID_SHOWCONSOLE).is(':checked');
                _this.hidePopup();
                _this.notebook.layoutCells();
            });


            _this.jq(ID_SHOWHEADER_INPUT).change(function(e) {
                _this.showHeader = _this.jq(ID_SHOWHEADER_INPUT).is(':checked');
                _this.applyStyle();
            });


            _this.jq(ID_RUNFIRST).change(function(e) {
                _this.runFirst = _this.jq(ID_RUNFIRST).is(':checked');
            });

            _this.jq(ID_SHOW_OUTPUT).change(function(e) {
                _this.showOutput = _this.jq(ID_SHOW_OUTPUT).is(':checked');
                _this.applyStyle();
            });
            _this.jq(ID_RUN_ON_LOAD).change(function(e) {
                _this.notebook.runOnLoad = _this.jq(ID_RUN_ON_LOAD).is(':checked');
            });
            _this.jq(ID_DISPLAY_MODE).change(function(e) {
                _this.notebook.displayMode = _this.jq(ID_DISPLAY_MODE).is(':checked');
            });
            _this.jq(ID_SHOWEDIT).change(function(e) {
                _this.showInput = _this.jq(ID_SHOWEDIT).is(':checked');
                _this.applyStyle();
            });

            _this.jq(ID_LAYOUT_TYPE).change(function(e) {
                if (_this.jq(ID_LAYOUT_TYPE).is(':checked')) {
                    _this.notebook.layout = "horizontal";
                } else {
                    _this.notebook.layout = "vertical";
                }
                _this.hidePopup();
                _this.notebook.layoutCells();
            });
            _this.jq(ID_LAYOUT_COLUMNS).keypress(function(e) {
                var keyCode = e.keyCode || e.which;
                if (keyCode != 13) {
                    return;
                }
                var cols = parseInt(_this.jq(ID_LAYOUT_COLUMNS).val());
                if (isNaN(cols)) {
                    _this.jq(ID_LAYOUT_COLUMNS).val("bad:" + _this.jq(ID_LAYOUT_COLUMNS).val());
                    return;
                }
                _this.hidePopup();
            });
            _this.jq(ID_CELLNAME_INPUT).keypress(function(e) {
                var keyCode = e.keyCode || e.which;
                if (keyCode == 13) {
                    _this.hidePopup();
                    return;
                }
            });
            popup.find(".ramadda-link").click(function() {
                var what = $(this).attr("what");
                _this.processCommand(what);
            });
        },
        hidePopup: function() {
            var popup = this.getPopup();
            if (popup && this.dialogShown) {
                var cols = parseInt(this.jq(ID_LAYOUT_COLUMNS).val());
                this.cellName = this.jq(ID_CELLNAME_INPUT).val();
                this.jq(ID_CELLNAME).html(this.cellName);
                popup.hide();
                this.applyStyle();

                if (!isNaN(cols) && this.notebook.columns != cols) {
                    this.notebook.columns = cols;
                    this.notebook.layoutCells();
                }
            }
            this.dialogShown = false;
        },
        processCommand: function(command) {
            if (command == "showmenu") {
                this.makeMenu();
                return;
            } else if (command == "toggle") {
                this.showInput = !this.showInput;
                this.applyStyle(true);
            } else if (command == "showthis") {
                this.showInput = true;
                this.applyStyle();
            } else if (command == "hidethis") {
                this.showInput = false;
                this.applyStyle();
            } else if (command == "showall") {
                this.notebook.toggleAll(true);
            } else if (command == "hideall") {
                this.notebook.toggleAll(false);
            } else if (command == "run") {
                this.notebook.runCell(this);
            } else if (command == "runall") {
                this.notebook.runAll();
            } else if (command == "clear") {
                this.clearOutput();
            } else if (command == "clearall") {
                this.notebook.clearOutput();
            } else if (command == "moveup") {
                this.notebook.moveCellUp(this);
            } else if (command == "movedown") {
                this.notebook.moveCellDown(this);
            } else if (command == "newabove") {
                this.notebook.newCellAbove(this);
            } else if (command == "newbelow") {
                this.notebook.newCellBelow(this);
            } else if (command == "savewith") {
                this.notebook.saveNotebook(true);
            } else if (command == "savewithout") {
                this.notebook.saveNotebook(false);
            } else if (command == "help") {
                var win = window.open(ramaddaBaseUrl + "/userguide/notebook.html", '_blank');
                win.focus();
            } else if (command == "delete") {
                this.askDelete();
                return;
            } else {
                console.log("unknown command:" + command);
            }
            this.hidePopup();
        },
        shouldShowInput: function() {
            return this.showInput && this.notebook.showInput();
        },
        applyStyle: function(fromUser) {
            if (this.shouldShowInput()) {
                this.jq(ID_INPUT_TOOLBAR).css("display", "block");
                this.inputContainer.show(400, () => this.editor.resize());
                this.showHeader = true;
            } else {
                this.jq(ID_INPUT_TOOLBAR).css("display", "none");
                this.inputContainer.hide(fromUser ? 200 : 0);
                this.showHeader = false;
            }
            this.showHeader = this.notebook.showInput();
            if (this.showHeader) {
                this.header.css("display", "block");
            } else {
                this.header.css("display", "none");
            }
            if (this.showOutput) {
                this.output.css("display", "block");
            } else {
                this.output.css("display", "none");
            }
        },
        getPopup: function() {
            return this.notebook.getPopup();
        },
        askDelete: function() {
            let _this = this;
            var menu = "";
            menu += "Are you sure you want to delete this cell?<br>";
            menu += HtmlUtils.span(["class", "ramadda-link", "what", "yes"], "Yes");
            menu += HtmlUtils.span(["style", "margin-left:50px;", "class", "ramadda-link", "what", "cancel"], "No");
            var popup = this.getPopup();

            popup.html(HtmlUtils.div(["class", "ramadda-popup-inner"], menu));
            popup.show();
            var src = this.input;
            if (!src.is(":visible")) {
                src = this.output;
            }
            if (!src.is(":visible")) {
                src = this.header;
            }
            popup.position({
                of: src,
                my: "left top",
                at: "left top",
                collision: "fit fit"
            });
            popup.find(".ramadda-link").click(function() {
                var what = $(this).attr("what");
                _this.hidePopup();
                if (what == "yes") {
                    _this.notebook.deleteCell(_this);
                }
            });
        },
        inputChanged: function() {
            var value = this.getInputText();
            var lines = value.split("\n");
            var cursor = this.editor.getCursorPosition();
            for (var i = cursor.row; i >= 0; i--) {
                var line = lines[i].trim();
                if (line.startsWith("%%")) {
                    var type = line.substring(2).trim();
                    if (type.startsWith("md") || type.startsWith("html") || type.startsWith("css") || type.startsWith("raw")) {
                        var doRows = {};
                        doRows[i] = true;
                        this.runInner(value, doRows);
                    }
                    break;
                }
            }
        },
        stepToNextChunk: function() {
            var value = this.getInputText();
            var lines = value.split("\n");
            var cursor = this.editor.getCursorPosition();
            for (var i = cursor.row + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith("%%")) {
                    var ll = lines[i].length;
                    this.editor.selection.moveTo(i, ll);
                    this.editor.scrollToLine(i, true, true, function() {});
                    break;
                }
            }

        },
        run: async function(callback, args) {
            if (!args) args = {};
            var justCurrent = args.justCurrent;
            var toEnd = args.toEnd;
            var doingAll = args.doingAll;
            if (this.running) return Utils.call(callback, true);
            this.running = true;
            var doRows = null;
            try {
                var ok = true;
                var value = this.getInputText();
                if (justCurrent) {
                    doRows = {};
                    var cursor = this.editor.getCursorPosition();
                    var row = cursor.row;
                    var lines = value.split("\n");
                    var percentCnt = 0;
                    if (toEnd) {
                        justCurrent = false;
                        while (row >= 0) {
                            if (lines[row].trim().startsWith("%%")) {
                                break;
                            }
                            row--;
                        }
                        if (row < 0) row = 0;
                        while (row < lines.length) {
                            doRows[row] = true;
                            row++;
                        }
                    } else {
                        //go to the next chunk
                        row++;
                        while (row < lines.length) {
                            if (lines[row].trim().startsWith("%%")) {
                                row--;
                                break;
                            }
                            row++;
                        }
                        if (row >= lines.length) row = lines.length - 1;
                        while (row >= 0) {
                            var line = lines[row].trim();
                            doRows[row] = true;
                            if (line.startsWith("%%")) break;
                            row--;
                        }
                    }
                }

                this.jq(ID_RUN_ICON).attr("src", icon_progress);
                await this.runInner(value, doRows, doingAll).then(r => ok = r);
                this.jq(ID_RUN_ICON).attr("src", icon_blank);
                if (!ok) {
                    this.running = false;
                    return Utils.call(callback, false);
                }
                this.outputUpdated();
            } catch (e) {
                this.jq(ID_RUN_ICON).attr("src", icon_blank);
                this.running = false;
                this.writeOutput("An error occurred:" + e.toString() + " " + (typeof e));
                console.log("error:" + e.toString());
                if (e.stack)
                    console.log(e.stack);
                return Utils.call(callback, false);
            }
            this.running = false;
            return Utils.call(callback, true);
        },
        prepareToLayout: function() {
            this.content = this.getInputText();
        },
        getInputText: function() {
            if (!this.editor) return this.content;
            return this.editor.getValue();
        },
        globalChanged: async function(name, value) {
            for(var i=0;i<this.chunks.length;i++) {
                var chunk = this.chunks[i];
                if(chunk.hasRun) continue;
                if(chunk.depends.includes(name)) {
                   var ok = true;
                   await this.runChunk(chunk,r=>ok=r);
                   if(!ok) break;
                }
            }
        },
        prepareToRun: function() {
            this.hasRun = false;
            if(this.chunks) {
                this.chunks.forEach(chunk=>chunk.hasRun = false);
            }
        },
        runInner: async function(value, doRows, doingAll) {
            value = value.trim();
            value = value.replace(/{cellname}/g, this.cellName);
            value = this.notebook.convertInput(value);
            if (!this.chunks) this.chunks = [];
            var chunks = this.chunks;
            var type = "wiki";
            var rest = "";
            var commands = value.split("\n");
            var prevChunk = null;
            var chunkCnt = 0;
            var _cell = this;
            var getChunk = (cell,type, content,  doChunk, rest) => {
                var props = Utils.parseAttributes(rest);
                props.type = type;
                props.doChunk = doChunk;
                props.content   = content;
                var chunk = (chunkCnt < chunks.length ? chunks[chunkCnt] : null);
                chunkCnt++;
                if (chunk) {
                    if (chunk.div.jq().length == 0) {
                        chunk = null;
                    } else {}
                } else {}
                if (!chunk) {
                    chunk = new NotebookChunk(cell, props);
                    chunks.push(chunk);
                    if(!chunk.skipOutput) {
                        if (prevChunk) prevChunk.div.jq().after(chunk.div.toString());
                        else cell.output.html(chunk.div.toString());
                    }
                } else {
                    chunk.initChunk(props);
                }
                prevChunk = chunk;
                chunk.div.jq().show();
                return chunk;
            };
            var content = "";
            var doChunk = true;
            for (var rowIdx = 0; rowIdx < commands.length; rowIdx++) {
                var command = commands[rowIdx];
                var _command = command.trim();
                if (_command.startsWith("//")) continue;
                if (_command.startsWith("%%")) {
                    var newRest = _command.substring(2).trim();
                    var newType;
                    var index = newRest.indexOf(" ");
                    if (index < 0) {
                        newType = newRest;
                        newRest = "";
                    } else {
                        newType = newRest.substring(0, index).trim();
                        newRest = newRest.substring(index);
                    }
                    if (content != "") {
                        getChunk(this, type, content, doChunk, rest);
                    }
                    doChunk = doRows ? doRows[rowIdx] : true;
                
                    content = "";
                    if (content != "") content += "\n";
                    if (newType != "")
                        type = newType;
                    rest = newRest;
                    continue;
                }
                content = content + command + "\n";
            }

            if (content != "") {
                getChunk(this,type, content, doChunk, rest);
            }

            this.chunkMap = {};
            for (var i = 0; i < this.chunks.length; i++) {
                var chunk = this.chunks[i];
                if (chunk.name) {
                    this.chunkMap[chunk.name] = chunk;
                }
            }
            for (var i = chunkCnt; i < this.chunks.length; i++) {
                this.chunks[i].div.jq().hide();
            }
            this.rawOutput = "";
            var ok = true;
            await this.runChunks(this.chunks, doingAll, true, r => ok = r);
            if (!ok) return false;
            await this.runChunks(this.chunks, doingAll, false, r => ok = r);
            if (!ok) return false;
            Utils.initContent("#" + this.getDomId(ID_OUTPUT));
            return true;
        },
        runChunks: async function(chunks, doingAll, justFirst, callback) {
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                var ok = true;
                if (justFirst === true && !chunk.props["runfirst"]) {
                    continue;
                }
                if (justFirst === false && chunk.props["runfirst"] === true) {
                    continue;
                }
                if (doingAll && chunk.props["skiprunall"] === true) {
                    continue;
                }
                if (!chunk.doChunk) {
                    continue;
                }
                await this.runChunk(chunk, (r => ok = r));
                if (!ok) return Utils.call(callback, false);
            }
            return Utils.call(callback, true);
        },
        runChunk: async function(chunk,   callback) {
            if (chunk.hasRun) {
                //                console.log("runChunk: chunk has run");
                return Utils.call(callback, true);
            }
            chunk.ok = true;
            chunk.div.set("");
            chunk.hasRun = true;
            for (var i = 0; i < chunk.depends.length; i++) {
                var name = chunk.depends[i];
                if (this.chunkMap[name] && !this.chunkMap[name].hasRun) {
                    var ok = true;
                    var otherChunk = this.chunkMap[name];
                    await this.runChunk(otherChunk, false, null, (r => ok = r));
                    if (!ok || !otherChunk.ok) {
                        return Utils.call(callback, false);
                    }
                }
            }
            await this.processChunk(chunk);
            if (!chunk.ok) {
                Utils.call(callback, false);
                return;
            }
            if (chunk.name && (typeof chunk.name == "string")) {
                var name = chunk.name.trim();
                if (chunk.output) {
                    if (name != "") {
                        await this.notebook.addGlobal(name, chunk.output);
                    }
                } else {
                    await this.notebook.addGlobal(name, null);
                }
            }
            return Utils.call(callback, true);
        },

        writeOutput: function(h) {
            if (!this.output) {
                err = new Error();
                console.log("no output:" + err.stack);
                return;
            }
            this.output.html(h);
            this.outputUpdated();
        },
        outputUpdated: function() {
            this.outputHtml = this.jq(ID_OUTPUT).html();
        },
        getRawOutput: function() {
            return this.rawOutput;
        },
        focus: function() {
            this.input.focus();
        },
        clearOutput: function() {
            if (this.chunks)
                this.chunks.forEach(chunk => chunk.div.set(""));
            this.outputHtml = "";
        },
        processHtml: async function(chunk) {
            var content = chunk.getContent();
            if (content.match("%\n*$")) {
                content = content.trim();
                content = content.substring(0, content.length - 1);
            }
            this.rawOutput += content + "\n";
            chunk.output = content;
            chunk.div.set(content);
        },
        processCss: async function(chunk) {
            var css = HtmlUtils.tag("style", ["type", "text/css"], chunk.getContent());
            this.rawOutput += css + "\n";
            chunk.output = css;
            chunk.div.set(css);
        },
        handleError: function(chunk, error, from) {
            chunk.ok = false;
            console.log("An error occurred:" + error);
            this.notebook.log(error, "error", from, chunk.div);
        },
        getFetchUrl: async function(url, type, callback) {
            //Check for entry id
            url = Utils.replaceRoot(url);
            if (url.match(/^[a-z0-9]+-[a-z0-9].*/)) {
                return Utils.call(callback, ramaddaBaseUrl + "/entry/get?entryid=" + url);
            } else {
                if (!url.startsWith("http")) {
                    if ((url.startsWith("/") && !url.startsWith(ramaddaBaseUrl)) || url.startsWith("..") || !url.startsWith("/")) {
                        var entry;
                        await this.getEntryFromPath(url, e => entry = e);
                        if (!entry) {
                            return Utils.call(callback, null);
                        }
                        return Utils.call(callback, ramaddaBaseUrl + "/entry/get?entryid=" + entry.getId());
                    }
                }
                return Utils.call(callback, url);
            }
        },
        processFetch: async function(chunk) {
            var lines = chunk.getContent().split("\n");
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line == "") continue;
                var origLine = line;
                var error = null;
                var msgExtra = "";
                var idx = line.indexOf(":");
                if (idx < 0) {
                    this.handleError(chunk, "Bad fetch line:" + line, "io");
                    return;
                }
                var tag = line.substring(0, idx);
                line = line.substring(idx + 1).trim();
                var idx = line.indexOf(" //");
                if (idx >= 0) {
                    line = line.substring(0, idx).trim();
                }


                var url = null;
                var variable = null;
                if (["text", "json", "blob"].includes(tag)) {
                    var args = line.match(/^([a-zA-Z0-9_]+) *= *(.*)$/);
                    if (args) {
                        variable = args[1];
                        line = args[2].trim();
                        msgExtra = " (var " + variable + ")";
                    }
                }

                await this.getFetchUrl(line, tag, u => url = u);
                if (!url) {
                    this.handleError(chunk, "Unable to get entry url:" + line, "io");
                    return;
                }

                if (tag == "js") {
                    //Don't import jquery
                    if (url.match("jquery-.*\\.js")) return;
                    await Utils.importJS(url,
                        () => {},
                        (jqxhr, settings, exception) => {
                            error = "Error fetching " + origLine + " " + (exception ? exception.toString() : "");
                        },
                        //Check the cache
                        false
                    );
                } else if (tag == "css") {
                    await Utils.importCSS(url,
                        null,
                        (jqxhr, settings, exception) => error = "Error fetching " + origLine + " " + exception, true);
                } else if (tag == "html") {
                    await Utils.doFetch(url, h => chunk.div.append(h), (jqxhr, settings, exception) => error = "Error fetching " + origLine + " " + exception);
                } else if (tag == "text" || tag == "json" || tag == "blob") {
                    var isJson = tag == "json";
                    var isBlob = tag == "blob";
                    var results = null;
                    await Utils.doFetch(url, h => results = h, (jqxhr, settings, err) => error = "Error fetching " + origLine + " error:" + (err ? err.toString() : ""), tag == "blob" ? "blob" : "text");
                    if (results) {
                        if (isJson) {
                            if (typeof results == "string")
                                results = JSON.parse(results);
                        } else if (isBlob) {
                            results = new Blob([results], {});
                        }
                        if (variable) {
                            await this.notebook.addGlobal(variable, results);
                        } else {
                            if (isJson) {
                                chunk.div.append(Utils.formatJson(results));
                            } else {
                                chunk.div.append(HtmlUtils.pre(["style", "max-width:100%;overflow-x:auto;"], results));
                            }
                        }
                    }
                } else {
                    error = "Unknown fetch:" + origLine;
                }
                if (error) {
                    this.handleError(chunk, error, "io");
                    return;
                } else {
                    this.notebook.log("Loaded: " + url + msgExtra, "output", "io");
                }
            }
        },
        processMd: async function(chunk) {
            //            await Utils.importJS(ramaddaBaseUrl + "/lib/katex/lib/katex/katex.min.css");
            //            await Utils.importJS(ramaddaBaseUrl + "/lib/katex/lib/katex/katex.min.js");

            var content = chunk.getContent();
            this.rawOutput += content + "\n";
            if (content.match("%\n*$")) {
                content = content.trim();
                content = content.substring(0, content.length - 1);
            }
            var o = "";
            var tex = null;
            var lines = content.split("\n");
            var texs = [];
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var _line = line.trim();
                if (_line.startsWith("$$")) {
                    if (tex != null) {
                        try {
                            var html = katex.renderToString(tex, {
                                throwOnError: true
                            });
                            o += "tex:" + texs.length + ":\n";
                            texs.push(html);
                        } catch (e) {
                            o += "Error parsing tex:" + e + "<pre>" + tex + "</pre>";
                        }
                        tex = null;
                    } else {
                        tex = "";
                    }
                } else if (tex != null) {
                    tex += line + "\n";
                } else {
                    o += line + "\n";
                }
            }

            var converter = new showdown.Converter();
            var html = converter.makeHtml(o);
            for (var i = 0; i < texs.length; i++) {
                html = html.replace("tex:" + i + ":", texs[i]);
            }
            var md = HtmlUtils.div(["class", "display-notebook-md"], html);
            chunk.output = html;
            chunk.div.set(md);
        },
        processPy: async function(chunk) {
            if (!this.notebook.loadedPyodide) {
                chunk.div.set("Loading Python...");
                await Utils.importJS(ramaddaBaseHtdocs + "/lib/pyodide/pyodide.js");
                await languagePluginLoader.then(() => {
                    pyodide.runPython('import sys\nsys.version;');
                    //                        pyodide.runPython('print ("hello python")');
                }, (e) => console.log("error:" + e));
                await pyodide.loadPackage(['numpy', 'cycler', 'pytz', 'matplotlib'])
                chunk.div.set("");
                this.notebook.loadedPyodide = true;
            }

            pyodide.runPython(chunk.getContent());
        },
        processPlugin: async function(chunk) {
            var plugin = JSON.parse(chunk.getContent());
            await this.notebook.addPlugin(plugin, chunk);
        },
        processWiki: async function(chunk) {
            this.rawOutput += chunk.getContent() + "\n";
            var id = this.notebook.getProperty("entryId", "");
            await this.getCurrentEntry(e => entry = e);
            if (entry) id = entry.getId();
            let _this = this;
            let divId = HtmlUtils.getUniqueId();
            var wikiCallback = function(html) {
                var h = HtmlUtils.div(["id", divId, "style"], html);
                chunk.div.set(h);
                chunk.output = h;
            }
            var wiki = "{{group showMenu=false}}\n" + chunk.getContent();
            await GuiUtils.loadHtml(ramaddaBaseUrl + "/wikify?doImports=false&entryid=" + id + "&text=" + encodeURIComponent(chunk.getContent()),
                wikiCallback);
        },
        processSh: async function(chunk) {
            var r = "";
            var lines = chunk.getContent().split("\n");
            var commands = [];
            for (var i = 0; i < lines.length; i++) {
                var fullLine = lines[i].trim();
                if (fullLine == "") continue;
                var cmds = fullLine.split(";");
                for (var cmdIdx = 0; cmdIdx < cmds.length; cmdIdx++) {
                    var line = cmds[cmdIdx].trim();
                    if (line == "" || line.startsWith("#") || line.startsWith("//")) continue;
                    var toks = line.split(" ");

                    var command = toks[0].trim();
                    var proc = null;
                    var extra = null;
                    if (this["processCommand_" + command]) {
                        proc = this["processCommand_" + command];
                    } else {
                        proc = this.processCommand_help;
                        extra = "Unknown command: <i>" + command + "</i>";
                    }
                    var div = new Div("");
                    commands.push({
                        proc: proc,
                        line: line,
                        toks: toks,
                        extra: extra,
                        div: div
                    });
                    r += div.set("");
                }
            }
            let _this = this;
            chunk.div.set(r);
            var i = 0;
            for (i = 0; i < commands.length; i++) {
                var cmd = commands[i];
                if (cmd.extra) {
                    cmd.div.append(extra);
                }
                await cmd.proc.call(_this, cmd.line, cmd.toks, cmd.div, cmd.extra);
            }
        },
        processJs: async function(chunk,state) {
            var lines;
            var topLines = 0;
            await this.getCurrentEntry(e => {
                    current = e
                });
            if(!notebookStates[state.id]) {
                throw new Error("Null NB:" + state.id);
            }
            try {
                var notebookEntries = this.notebook.getCurrentEntries();
                for (name in notebookEntries) {
                    state.entries[name] = notebookEntries[name].entry;
                }
                var jsSet = "";
                state.entries["current"] = current;
                state.entries["parent"] = this.parentEntry;
                state.entries["base"] = this.notebook.getBaseEntry();
                state.entries["root"] = this.notebook.getRootEntry();

                var stateJS = "notebookStates['" + state.id + "']";
                topLines++;
                jsSet += "var notebook= " + stateJS + ";\n";
                topLines++;
                for (name in state.entries) {
                    var e = state.entries[name];
                    topLines++;
                    jsSet += "var " + name + "= notebook.entries['" + name + "'];\n"
                }
                for (name in this.notebook.cellValues) {
                    var clean = name.replace(/ /g, "_").replace(/[^a-zA-Z0-9_]+/g, "_");
                    topLines++;
                    jsSet += "var " + clean + "= notebook.getNotebook().cellValues['" + name + "'];\n";
                }
                for (name in this.notebook.globals) {
                    name = name.trim();
                    if (name == "") continue;
                    //                    if (!Utils.isDefined(window[name])) {
                        topLines++;
                        jsSet += "var " + name + "= notebook.getNotebook().getGlobalValue('" + name + "');\n";
                        //                    }
                }
                var js = chunk.getContent().trim();
                lines = js.split("\n");
                js = jsSet + "\n" + js;
                var result = eval.call(null, js);
                if (state.getStop()) {
                    chunk.ok = false;
                }
                var html = "";
                if (result != null) {
                    chunk.output = result;
                    var rendered = this.notebook.formatOutput(result);
                    if (rendered != null) {
                        html = rendered;
                        this.rawOutput += html + "\n";
                    } else {
                        var type = typeof result;
                        if (type != "object" && type != "function") {
                            html = result;
                            this.rawOutput += html + "\n";
                        }
                    }
                }
                chunk.div.append(html);
            } catch (e) {
                chunk.ok = false;
                var line = lines[e.lineNumber - topLines - 1];
                console.log("Error:" + e.stack);
                this.notebook.log("Error: " + e.message + "<br>&gt;" + (line ? line : ""), "error", "js", chunk.div);
            }
        },
        processChunk: async function(chunk) {
            var state = new NotebookState(this, chunk.div);
            window.notebook = state;
            notebookStates[state.id] = state;
            if (chunk.type == "html") {
                await this.processHtml(chunk, state);
            } else if (chunk.type == "plugin") {
                await this.processPlugin(chunk,state);
            } else if (chunk.type == "wiki") {
                await this.processWiki(chunk,state);
            } else if (chunk.type == "css") {
                await this.processCss(chunk,state);
            } else if (chunk.type == "fetch") {
                await this.processFetch(chunk,state);
            } else if (chunk.type == "raw") {
                var content = chunk.getContent();
                chunk.output = content;
                this.rawOutput += content;
            } else if (chunk.type == "js") {
                await this.processJs(chunk,state);
            } else if (chunk.type == "sh") {
                await this.processSh(chunk,state);
            } else if (chunk.type == "meta") {
                //noop
            } else if (chunk.type == "md") {
                await this.processMd(chunk,state);
            } else if (chunk.type == "py") {
                await this.processPy(chunk,state);
            } else {
                var hasPlugin;
                await this.notebook.hasPlugin(chunk.type, p => hasPlugin = p);
                if (hasPlugin) {
                    chunk.div.set("");
                    var result;
                    await this.notebook.processChunkWithPlugin(chunk.type, chunk, r => result = r);
                    //TODO: what to do with the result
                    if (result) {
                        this.notebook.processPluginOutput(chunk.type, chunk, result);
                    }
                    return;
                }
                this.notebook.log("Unknown type:" + chunk.type, "error", null, chunk.div);
                chunk.ok = false;
            }
            delete  notebookStates[state.id];
            if (state.getStop()) {
                chunk.ok = false;
            }

        },



        calculateInputHeight: function() {
            this.content = this.getInputText();
            if (!this.content) return;
            var lines = this.content.split("\n");
            if (lines.length != this.inputRows) {
                this.inputRows = lines.length;
                this.input.attr("rows", Math.max(1, this.inputRows));
            }
        },

        writeStatusMessage: function(v) {
            var msg = this.jq(ID_MESSAGE);
            if (!v) {
                msg.hide();
                msg.html("");
            } else {
                msg.show();
                msg.position({
                    of: this.getOutput(),
                    my: "left top",
                    at: "left+4 top+4",
                    collision: "none none"
                });
                msg.html(v);
            }
        },
        handleControlKey: function(event) {
            var k = event.which;
        },
        getOutput: function() {
            return this.jq(ID_OUTPUT);
        },
        getInput: function() {
            return this.jq(ID_INPUT);
        },
        writeResult: function(html) {
            this.writeStatusMessage(null);
            html = HtmlUtils.div([ATTR_CLASS, "display-notebook-result"], html);
            var output = this.jq(ID_OUTPUT);
            output.append(html);
            output.animate({
                scrollTop: output.prop("scrollHeight")
            }, 1000);
            this.currentOutput = output.html();
            this.currentInput = this.getInputText();
        },
        writeError: function(msg) {
            this.writeStatusMessage(msg);
            //                this.writeResult(msg);
        },
        header: function(msg) {
            return HtmlUtils.div([ATTR_CLASS, "display-notebook-header"], msg);
        },
        processCommand_help: function(line, toks, div, callback, prefix) {
            if (div == null) div = new Div();
            var help = "";
            if (prefix != null) help += prefix;
            help += "<pre>pwd, ls, cd</pre>";
            return div.append(help);
        },
        entries: {},

        selectEntry: function(entryId) {
            var cnt = 1;
            var entries = this.notebook.getCurrentEntries();
            while (entries["entry" + cnt]) {
                cnt++;
            }
            var id = prompt("Set an ID", "entry" + cnt);
            if (id == null || id.trim() == "") return;
            this.notebook.addEntry(id, entryId);
        },
        setId: function(entryId) {
            var cursor = this.editor.getCursorPosition();
            this.editor.insert(entryId);
            //            this.editor.selection.moveTo(cursor.row, cursor.column);
            //            this.editor.focus();
        },
        cdEntry: function(entryId) {
            var div = new Div("");
            this.currentEntry = this.entries[entryId];
            notebookState.entries["current"] = this.currentEntry;
            this.output.html(div.toString());
            this.processCommand_pwd("pwd", [], div);
            this.outputUpdated();
        },
        addToToolbar: function(id, entry, toolbarItems) {
            var call = "getHandler('" + id + "').setId('" + entry.getId() + "')";
            var icon = HtmlUtils.image(ramaddaBaseUrl + "/icons/setid.png", ["border", 0, ATTR_TITLE, "Set ID in Input"]);
            toolbarItems.unshift(HtmlUtils.tag(TAG_A, ["onclick", call], icon));
            var call = "getHandler('" + id + "').selectEntry('" + entry.getId() + "')";
            var icon = HtmlUtils.image(ramaddaBaseUrl + "/icons/circle-check.png", ["border", 0, ATTR_TITLE, "Select Entry"]);
            toolbarItems.unshift(HtmlUtils.tag(TAG_A, ["onclick", call], icon));
        },
        getEntryPrefix: function(id, entry) {
            this.entries[entry.getId()] = entry;
            var call = "getHandler('" + id + "').cdEntry('" + entry.getId() + "')";
            return HtmlUtils.div(["style", "padding-right:4px;", "title", "cd to entry", "onclick", call, "class", "ramadda-link"], HtmlUtils.image(ramaddaBaseUrl + "/icons/go.png"));
        },
        displayEntries: function(entries, div) {
            if (div == null) div = new Div();
            this.currentEntries = entries;
            if (entries == null || entries.length == 0) {
                return div.msg("No children");
            }
            var handlerId = addHandler(this);
            var html = this.notebook.getEntriesTree(entries, {
                handlerId: handlerId,
                showIndex: false,
                suffix: Utils.getUniqueId("_shell_")
            });
            div.set(HtmlUtils.div(["style", "max-height:200px;overflow-y:auto;"], html));
            this.outputUpdated();
        },
        getEntryFromArgs: function(args, dflt) {
            var currentEntries = this.currentEntries;
            if (currentEntries == null) {
                return dflt;
            }
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (arg.match("^\d+$")) {
                    var index = parseInt(arg);
                    break;
                }
                if (arg == "-entry") {
                    i++;
                    var index = parseInt(args[i]) - 1;
                    if (index < 0 || index >= currentEntries) {
                        this.writeError("Bad entry index:" + index + " should be between 1 and " + currentEntries.length);
                        return;
                    }
                    return currentEntries[index];
                }
            }
            return dflt;
        },
        setCurrentEntry: async function(entry) {
            this.currentEntry = entry;
            this.parentEntry = null;
            if (this.currentEntry)
                await this.currentEntry.getParentEntry(entry => {
                    this.parentEntry = entry;
                });
        },
        getCurrentEntry: async function(callback) {
            if (this.currentEntry == null) {
                await this.setCurrentEntry(this.notebook.getBaseEntry());
            }
            if (this.currentEntry == null) {
                if (Utils.isDefined(dflt)) return dflt;
                this.rootEntry = new Entry({
                    id: ramaddaBaseEntry,
                    name: "Root",
                    type: "group"
                });
                this.currentEntry = this.rootEntry;
            }
            return Utils.call(callback, this.currentEntry);
        },
        createDisplay: async function(state, entry, displayType, displayProps) {
            if (!entry) await this.getCurrentEntry(e => entry = e);
            if ((typeof entry) == "string") {
                await this.notebook.getEntry(entry, e => entry = e);
            }

            if (!state.displayManager) {
                var divId = HtmlUtils.getUniqueId();
                state.div.append(HtmlUtils.div(["id", divId], ""));
                state.displayManager = new DisplayManager(divId, {
                    "showMap": false,
                    "showMenu": false,
                    "showTitle": false,
                    "layoutType": "table",
                    "layoutColumns": 1,
                    "defaultMapLayer": "osm",
                    "entryId": ""
                });
            }

            var divId = HtmlUtils.getUniqueId();
            state.div.append(HtmlUtils.div(["id", divId], "DIV"));
            var props = {
                layoutHere: true,
                divid: divId,
                showMenu: true,
                sourceEntry: entry,
                entryId: entry.getId(),
                showTitle: true,
                showDetails: true,
                title: entry.getName(),
            };

            if (displayProps) {
                $.extend(props, displayProps);
            }
            if (!props.data && displayType != DISPLAY_ENTRYLIST) {
                var jsonUrl = this.notebook.getPointUrl(entry);
                if (jsonUrl == null) {
                    this.writeError("Not a point type:" + entry.getName());
                    return;
                }
                if (jsonUrl == null) {
                    jsonUrl = this.getPointUrl(entry);
                }
                var pointDataProps = {
                    entry: entry,
                    entryId: entry.getId()
                };
                props.data = new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
            }
            state.displayManager.createDisplay(displayType, props);
        },
        createPointDisplay: async function(toks, displayType) {
            await this.getCurrentEntry(e => current = e);
            var entry = this.getEntryFromArgs(toks, currentEntry);
            var jsonUrl = this.notebook.getPointUrl(entry);
            if (jsonUrl == null) {
                this.writeError("Not a point type:" + entry.getName());
                return;
            }
            this.notebook.createDisplay(entry.getId(), displayType, jsonUrl);
        },
        processCommand_table: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_TABLE);
        },
        processCommand_linechart: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_LINECHART);
        },

        processCommand_barchart: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_BARCHART);
        },
        processCommand_bartable: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_BARTABLE);
        },
        processCommand_hello: function(line, toks) {
            this.writeResult("Hello, how are you?");
        },
        processCommand_scatterplot: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_SCATTERPLOT)
        },
        processCommand_blog: function(line, toks) {
            this.getLayoutManager().publish('blogentry');
        },
        getEntryHeading: function(entry, div) {
            var entries = [entry];
            var handlerId = addHandler(this);
            var html = this.notebook.getEntriesTree(entries, {
                handlerId: handlerId,
                showIndex: false,
                suffix: Utils.getUniqueId("_shell_")
            });
            div.set(HtmlUtils.div(["style", "max-height:200px;overflow-y:auto;"], html));
            return div;
            //            var icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
            //            return "&gt; "+ icon +" " +entry.getName();
        },
        processCommand_pwd: async function(line, toks, div) {
            if (div == null) div = new Div();
            await this.getCurrentEntry(e => entry = e);
            return this.getEntryHeading(entry, div);
        },
        processCommand_set: async function(line, toks, div) {
            if (div == null) div = new Div();
            if (toks.length < 2) {
                div.append("Error: usage: set &lt;name&gt; &lt;value&gt;");
                return;
            }
            var name = toks[1];
            if (toks.length == 2) {
                var v = this.notebook.getGlobalValue(name);
                if (v) {
                    div.append(v);
                } else {
                    div.append("Unknown: " + name);
                }
            } else {
                var v = Utils.join(toks, " ", 2);
                v = v.replace(/\"/g, "");
                await this.notebook.addGlobal(name, v);
            }
        },
        processCommand_clearEntries: function(line, toks, div) {
            this.notebook.clearEntries();
            div.set("Entries cleared");
        },
        processCommand_printEntries: async function(line, toks, div) {
            var h = "";
            await this.getCurrentEntry(e => current = e);
            h += "current" + "=" + current.getName() + "<br>";
            var entries = this.notebook.getCurrentEntries();
            for (var name in entries) {
                var e = entries[name];
                h += name + "=" + e.entry.getName() + "<br>";
            }
            if (h == "") h = "No entries";
            div.set(h);
        },
        processCommand_echo: async function(line, toks, div) {
            line = line.replace(/^echo */, "");
            div.set(line);
        },
        processCommand_print: async function(line, toks, div) {
            line = line.replace(/^print */, "");
            div.set(line);
        },

        processCommand_info: async function(line, toks, div) {
            await this.getCurrentEntry(e => entry = e);
            div.append("current:" + entry.getName() + " id:" + entry.getId() + "<br>");
        },

        processCommand_cd: async function(line, toks, div) {
            if (div == null) div = new Div();
            if (toks.length <= 1) {
                await this.setCurrentEntry(this.notebook.getBaseEntry());
                return;
                //                return this.getEntryHeading(this.currentEntry, div);
            }
            var arg = Utils.join(toks, " ", 1).trim();
            var entry;
            await this.getEntryFromPath(arg, e => entry = e);
            if (!entry) {
                div.msg("Could not get entry:" + arg);
                return;
            }
            await this.setCurrentEntry(entry);
        },
        getEntryFromPath: async function(arg, callback) {
            var entry;
            await this.getCurrentEntry(e => entry = e);
            if (arg.startsWith("/")) {
                await entry.getRoot(e => {
                    entry = e
                });
            }
            var dirs = arg.split("/");
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                if (dir == "") continue;
                if (dir == "..") {
                    await entry.getParentEntry(e => {
                        entry = e
                    });
                    if (!entry) {
                        break;
                    }
                } else {
                    await entry.getChildrenEntries(c => children = c);
                    var child = null;
                    var startsWith = false;
                    var endsWith = false;
                    if (dir.endsWith("*")) {
                        dir = dir.substring(0, dir.length - 1);
                        startsWith = true;
                    }
                    if (dir.startsWith("*")) {
                        dir = dir.substring(1);
                        endsWith = true;
                    }
                    for (var childIdx = 0; childIdx < children.length; childIdx++) {
                        var name = children[childIdx].getName();
                        if (startsWith && endsWith) {
                            if (name.includes(dir)) {
                                child = children[childIdx];
                                break;
                            }
                        } else if (startsWith) {
                            if (name.startsWith(dir)) {
                                child = children[childIdx];
                                break;
                            }
                        } else if (endsWith) {
                            if (name.endsWith(dir)) {
                                child = children[childIdx];
                                break;
                            }
                        }
                        if (children[childIdx].getName() == dir) {
                            child = children[childIdx];
                            break;
                        }
                    }
                    if (!child) {
                        break;
                    }
                    entry = child;
                }
            }
            return Utils.call(callback, entry);
        },


        processCommand_ls: async function(line, toks, div) {
            if (div == null) div = new Div();
            div.set("Listing entries...");
            await this.getCurrentEntry(e => entry = e);
            await entry.getChildrenEntries(children => {
                this.displayEntries(children, div)
            }, "");
        },
        entryListChanged: function(entryList) {
            var entries = entryList.getEntries();
            if (entries.length == 0) {
                this.writeStatusMessage("Sorry, nothing found");
            } else {
                this.displayEntries(entries);
            }
        },
        processCommand_search: async function(line, toks, div) {
            var text = "";
            for (var i = 1; i < toks.length; i++) text += toks[i] + " ";
            text = text.trim();
            var settings = new EntrySearchSettings({
                text: text,
            });
            var jsonUrl = this.notebook.getRamadda().getSearchUrl(settings, OUTPUT_JSON);
            let _this = this;
            var myCallback = {
                entryListChanged: function(list) {
                    var entries = list.getEntries();
                    div.set("");
                    if (entries.length == 0) {
                        div.append("Nothing found");
                    } else {
                        _this.displayEntries(entries, div)
                    }
                }
            };
            var entryList = new EntryList(this.notebook.getRamadda(), jsonUrl, myCallback, false);
            div.set("Searching...");
            await entryList.doSearch();
        },
        processCommand_clear: function(line, toks, div) {
            this.clearOutput();
        },
        processCommand_save: function(line, toks, div) {
            this.notebook.saveNotebook();
        },

    });

}


function processLispOutput(r) {
    if (r && r.val) return r.val;
    return Utils.formatJson(r);
}




function NotebookChunk(cell, props) {
    for(name in props)
        props[name.toLowerCase()] = props[name];
    this.div =  new Div(null, "display-notebook-chunk");
    this.cell = cell;
    $.extend(this, {
            getContent: function() {
                var content = this.content;
                for (name in this.cell.notebook.globals) {
                    var value = this.cell.notebook.getGlobalValue(name);
                    if (typeof value == "object") {
                        value = Utils.formatJson(value);
                    }
                    content = content.replace("${" + name.trim() + "}", value);
                }
                return content;
            },
           initChunk: function(props) {
                this.skipOutput = false;
                if (props["skipoutput"] === true) {
                    this.skipOutput = true;
                    this.div.set("");
                    this.div = new Div();
                }
                var depends = [];
                if (props["depends"] && typeof props["depends"] == "string") depends = props["depends"].split(",");
                var content = props.content||"";
                var regexp = RegExp(/\${([^ }]+)}/g);
                while((result = regexp.exec(content)) !== null) {
                    var param = result[1];
                    if(!depends.includes(param)) depends.push(param);
                }
                $.extend(this, {
                        name: props["name"],
                            depends: depends,
                            output: null,
                            runFirst: props["runFirst"],
                            hasRun: false,
                            content: content,
                            type: props.type,
                            props: props,
                            doChunk: !!props.doChunk,
                            ok: true
                            });
            }
        });
    this.initChunk(props);
}
/**
   Copyright 2008-2021 Geode Systems LLC
*/


//Note: I put all of the chart definitions together at the top so one can see everything that is available here
const DISPLAY_D3_GLIDER_CROSS_SECTION = "GliderCrossSection";
//const DISPLAY_D3_PROFILE = "profile";
const DISPLAY_D3_LINECHART = "D3LineChart";
const DISPLAY_SKEWT = "skewt";
const DISPLAY_VENN = "venn";
const DISPLAY_CHERNOFF = "chernoff";
const DISPLAY_D3BUBBLE = "d3bubble";
const DISPLAY_MINIDOTS = "minidots";

//Note: Added requiresData and category
addGlobalDisplayType({
    type: DISPLAY_D3_LINECHART,
    forUser: false,
    label: "D3 LineChart",
    requiresData: true,
    category: "Charts"
});
/*
addGlobalDisplayType({
    type: DISPLAY_D3_PROFILE,
    forUser: false,
    label: "Profile",
    requiresData: true,
    category: "Charts"
});
*/
addGlobalDisplayType({
    type: DISPLAY_D3_GLIDER_CROSS_SECTION,
    forUser: false,
    label: "Glider cross section",
    requiresData: true,
    category: CATEGORY_MISC
});


addGlobalDisplayType({
    type: DISPLAY_VENN,
    forUser: true,
    label: "Venn Diagram",
    requiresData: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("A Venn diagram","venn.png")    
});

addGlobalDisplayType({
    type: DISPLAY_MINIDOTS,
    forUser: false,
    label: "Mini Dots",
    requiresData: true,
    category: CATEGORY_MISC
});

addGlobalDisplayType({
    type: DISPLAY_CHERNOFF,
    forUser: false,
    label: "Chernoff Faces",
    requiresData: true,
    category: CATEGORY_MISC
});

addGlobalDisplayType({
    type: DISPLAY_D3BUBBLE,
    forUser: true,
    label: "Bubble Chart",
    requiresData: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Animated bubbles showing images","d3bubble.png"),            
});


addGlobalDisplayType({
    type: DISPLAY_SKEWT,
    forUser: false,
    label: "SkewT",
    requiresData: true,
    category: CATEGORY_MISC
});

//Note: define meaningful things as variables not as string literals
const FIELD_TIME = "time";
const FIELD_DEPTH = "depth";
const FIELD_VALUE = "value";
const FIELD_SELECTEDFIELD = "selectedfield";

const TYPE_LATITUDE = "latitude";
const TYPE_LONGITUDE = "longitude";
const TYPE_TIME = "time";
const TYPE_VALUE = "value";
const TYPE_ELEVATION = "elevation";


const FUNC_MOVINGAVERAGE = "movingAverage";

const D3Util = {
    foo: "bar",
    getAxis: function(axisType, range) {
        var axis;
        if (axisType == FIELD_TIME) {
            axis = d3.time.scale().range(range);
        } else {
            axis = d3.scale.linear().range(range);
        }
        return axis;
    },
    getDataValue: function(axis, record, index) {
        var data;
        if (axis.fieldIdx >= 0) {
            data = record.getData()[axis.fieldIdx];
        } else {
            switch (axis.type) {
            case TYPE_TIME:
                data = new Date(record.getDate());
                break;
            case TYPE_ELEVATION:
                //console.log(record.getElevation());
                data = record.getElevation();
                break;
            case TYPE_LATITUDE:
                data = record.getLatitude();
            case TYPE_LONGITUDE:
                data = record.getLongitude();
            default:
                data = record.getData()[index];
            }
        }


        if (axis.reverse == true) {
            return -1 * data;
        } else {
            return data;
        }
    },
    // This will be the default but we can add more colorscales
    getColorFromColorBar: function(value, range) {
        var colors = ["#00008B", "#0000CD", "#0000FF", "#00FFFF", "#7CFC00", "#FFFF00", "#FFA500", "#FF4500", "#FF0000", "#8B0000"];
        var colorScale = d3.scale.linear()
            .domain([0, colors.length - 1])
            .range(range);

        var colorScaler = d3.scale.linear()
            .range(colors)
            .domain(d3.range(0, colors.length).map(colorScale));

        color = colorScaler(value);
        return color;
    },
    // This is for the path lines the previous function for generic ones. 
    addColorBar: function(svg, colors, colorSpacing, displayWidth) {
        //Note: this originally had this.displayWidth which was undefined
        var colorBar = svg.append("g")
            .attr({
                "id": "colorBarG",
                "transform": "translate(" + (displayWidth - 40) + ",0)"
            });

        colorBar.append("g")
            .append("defs")
            .append("linearGradient")
            .attr({
                id: "colorBarGradient",
                x1: "0%",
                y1: "100%",
                x2: "0%",
                y2: "0%"
            })
            .selectAll("stop")
            .data(colors)
            .enter()
            .append("stop")
            .attr({
                "offset": function(d, i) {
                    return colorSpacing * (i) + "%"
                },
                "stop-color": function(d, i) {
                    return colors[i]
                },
                "stop-opacity": 1
            });

        return colorBar;
    }
}


function RamaddaSkewtDisplay(displayManager, id, properties) {
    const ID_SKEWT = "skewt";
    const ID_DATE_LABEL = "skewtdate";
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_SKEWT, properties);
    let myProps = [
        {label:'Skewt Attributes'},
        {p:'skewtWidth',ex:'500'},
        {p:'skewtHeight',ex:'550'},
        {p:'hodographWidth',ex:'150'},
        {p:'showHodograph',ex:'false'},
        {p:'windStride',ex:'1'},
        {p:'showText',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        initDisplay:  function() {
            SUPER.initDisplay.call(this);
        },
        handleEventPointDataLoaded: function(source, pointData) {
            //TODO: this results in a double  call to updateUI when first created
            this.updateUI();
        },
        updateUI: async function() {
//          console.log("skewt.updateui");
            if(!this.loadedResources) {
                var time = new Date();
                await Utils.importCSS(ramaddaCdn +"/lib/skewt/sounding.css");
                await Utils.importJS(ramaddaCdn+"/lib/skewt/d3skewt.js");
                this.loadedResources = true;
            }

            if(!window["D3Skewt"]) {
                setTimeout(()=>this.updateUI(),100);
                return;
            }
            SUPER.updateUI.call(this);

//          console.log("skewt.updateui-1");
            let records =  this.filterData();
            if (!records || records.length==0) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
//          console.log("skewt.updateui-2");

            let skewtId = this.getDomId(ID_SKEWT);
            let html = HtmlUtils.div(["id", skewtId], "");
            this.setContents(html);
            var date = records[0].getDate();
            if(this.jq(ID_DATE_LABEL).length==0) {
                this.jq(ID_TOP_LEFT).append(HtmlUtils.div([ID,this.getDomId(ID_DATE_LABEL)]));
            }
            if(date!=null) {
                this.jq(ID_DATE_LABEL).html("Date: " + this.formatDate(date));
            } else {
                this.jq(ID_DATE_LABEL).html("");
            }
            var options = {};
            if (this.propertyDefined("showHodograph"))
                options.showHodograph = this.getProperty("showHodograph", true);
            if (this.propertyDefined("showText"))
                options.showText = this.getProperty("showText", true);
            if (this.propertyDefined("skewtWidth"))
                options.skewtWidth = parseInt(this.getProperty("skewtWidth"));
            if (this.propertyDefined("skewtHeight"))
                options.skewtHeight = parseInt(this.getProperty("skewtHeight"));
            if (this.propertyDefined("hodographWidth")){
                options.hodographWidth = parseInt(this.getProperty("hodographWidth"));
            }
            if (this.propertyDefined("windStride")){
                options.windStride = parseInt(this.getProperty("windStride"));
            }
            options.showText = this.getProperty("showText",true);
            //            options.hodographWidth = 200;
            var fields = this.getData().getRecordFields();
            var names = [
                {id:"pressure",aliases:["vertCoord"]},
                {id:"height",aliases:["Geopotential_height_isobaric"]},
                {id:"temperature",aliases:["Temperature_isobaric"]},
                {id:"dewpoint",aliases:[]},
                {id:"rh",aliases:["Relative_humidity_isobaric","relative_humidity"]},
                {id:"wind_direction",aliases:[]},
                {id:"wind_speed",aliases:[]},
                {id:"uwind",aliases:["u-component_of_wind_isobaric","u"]},
                {id:"vwind",aliases:["v-component_of_wind_isobaric","v"]},
            ];
            //TODO: check for units
            var data ={};
            var dataFields ={};
            for(var i=0;i<names.length;i++) {
                var obj = names[i];
                var id = obj.id;
                var field = this.getFieldById(fields,id);
                if(field == null) {
                    for(var j=0;j<obj.aliases.length;j++) {
                        field = this.getFieldById(fields,obj.aliases[j]);
                        if(field) break;
                    }
                }
                if(field) {
                    data[id] = this.getColumnValues(records, field).values;
                    dataFields[id]=field;
                }
            }

            if(!data.pressure) {
                this.displayError("No pressure defined in data");
                return;
            }

            if(!data.temperature) {
                this.displayError("No temperature defined in data");
                return;
            }

            if(!data.height) {
                var pressures = [
                    1013.25, 954.61, 898.76, 845.59, 795.01, 746.91, 701.21,
                    657.80, 616.6, 577.52, 540.48, 505.39, 472.17, 440.75,
                    411.05, 382.99, 356.51, 331.54, 303.00, 285.85, 264.99,
                    226.99, 193.99, 165.79, 141.70, 121.11, 103.52, 88.497,
                    75.652, 64.674, 55.293, 25.492, 11.970, 5.746, 2.871,
                    1.491, 0.798, 0.220, 0.052, 0.010,];
                var alts = [
                    0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000,
                    5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000,
                    11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000,
                    20000, 25000, 30000, 35000, 40000, 45000, 50000, 60000, 70000,
                    80000,
                ];
                
                data.height = [];
                for(var i=0;i<data.pressure.length;i++) {
                    var pressure = data.pressure[i];
                    var alt = alts[alts.length-1];
                    for(var j=0;j<pressures.length;j++) {
                        if(pressure>=pressures[j]) {
                            if(j==0) alt = 0;
                            else {
                                var p1 = pressures[j-1];
                                var p2 = pressures[j];
                                var a1 = alts[j-1];
                                var a2 = alts[j];
                                var percent = 1-(pressure-p2)/(p1-p2);
                                alt = (a2-a1)*percent+a1;
                            }
                            break;
                        }
                    }
                    data.height.push(alt);
                }
            }


            if(!data.dewpoint) {
                if(!data.rh) {
                    this.displayError("No dewpoint or rh");
                    return;
                }
                data.dewpoint = [];
                for(var i=0;i<data.rh.length;i++) {
                    var rh=data.rh[i];
                    var t=data.temperature[i];
                    var dp = t-(100-rh)/5;
                    data.dewpoint.push(dp);
                }
            }


            if(!data.wind_speed) {
                if(!data.uwind || !data.vwind) {
                    this.displayError("No wind speed defined in data");
                    return;
                }
                data.wind_speed = [];
                data.wind_direction = [];
                for(var i=0;i<data.uwind.length;i++) {
                    var u = data.uwind[i];
                    var v = data.vwind[i];
                    var ws = Math.sqrt(u*u+v*v);
                    var wdir = 180+(180/Math.PI)*Math.atan2(v,u);
                    data.wind_speed.push(ws);
                    data.wind_direction.push(wdir);
                }
            }

            var alldata = data;
            data = {};
            //if any missing then don't include
            for(a  in alldata) data[a] = [];
            alldata[names[0].id].map((v,idx)=>{
                var ok = true;
                for(id in alldata) {
                    if(isNaN(alldata[id][idx])) {
                        ok = false;
                        break;
                    }
                }
                if(ok) {
                    for(id in alldata) {
                        data[id].push(alldata[id][idx]);
                    }
                }
            });


            if(data.height.length>1) {
                if(data.height[0]>data.height[1]) {
                    for(name in data)
                        data[name] = Utils.reverseArray(data[name]);
                }
            }
            if(data.temperature.length==0) {
                this.displayError(this.getNoDataMessage());
                return;
            }

            /*
            if(options.windStride > 1) {
                
                var new_wind_speed = [];
                var new_wind_direction = [];
                for (var i = 0; i<data.wind_speed.length; i++) {
		    var pres = data.pressure[i];
                    if (i%options.windStride == 0) {
                        new_wind_speed.push(data.wind_speed[i]);
                        new_wind_direction.push(data.wind_direction[i]);
                    } else {
                        new_wind_speed.push(0);
                        new_wind_direction.push(0);
		    }
                }
                data.wind_speed = new_wind_speed;
                data.wind_direction = new_wind_direction;
            }
            */


            options.myid = this.getId();
            try {
                this.skewt = new D3Skewt(skewtId, options,data);
            } catch(e) {
                this.displayError("An error occurred: " +e);
                console.log("error:" + e.stack);
                return;
            }
            await this.getDisplayEntry((e)=>{
		if(!e) return;
                var q= e.getAttribute("variables");
                if(!q) return;
                q = q.value;
                q = q.replace(/\r\n/g,"\n");
                q = q.replace(/^ *\n/,"");
                q = q.replace(/^ *([^:]+):([^\n].*)$/gm,"<div title='$1' class=display-skewt-index-label>$1</div>: <div title='$2'  class=display-skewt-index>$2</div>");
                q = q.replace(/[[\r\n]/g,"\n");
                q = HtmlUtils.div(["class", "display-skewt-text"],q);
                $("#" + this.skewt.textBoxId).html(q);
            });
        }
    });
}


function RamaddaD3Display(displayManager, id, properties) {
    const ID_SVG = "svg";
    const SUPER = new RamaddaDisplay(displayManager, id, "d3", properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        initDisplay: function() {
            this.createUI();
            this.setDisplayTitle(properties.graph.title);

            //Note: use innerHeight/innerWidth wiki attributes
            var width = this.getProperty("innerWidth", 600);
            var height = this.getProperty("innerHeight", 300);
            var margin = {
                top: 20,
                right: 50,
                bottom: 30,
                left: 50
            };
            var divStyle =
                "height:" + height + "px;" +
                "width:" + width + "px;";
            var html = HtmlUtils.div([ATTR_ID, this.getDomId(ID_SVG), ATTR_STYLE, divStyle], "");
            this.setContents(html);

            // To create dynamic size of the div
            this.displayHeight = parseInt((d3.select("#" + this.getDomId(ID_SVG)).style("height")).split("px")[0]) - margin.top - margin.bottom; //this.getProperty("height",300);//d3.select("#"+this.getDomId(ID_SVG)).style("height");//
            this.displayWidth = parseInt((d3.select("#" + this.getDomId(ID_SVG)).style("width")).split("px")[0]) - margin.left - margin.right; //this.getProperty("width",600);//d3.select("#"+this.getDomId(ID_SVG)).style("width");//

            //                console.log("WxH:" + this.displayHeight +" " + this.displayWidth);

            // To solve the problem with the classess within the class
            var myThis = this;
            var zoom = d3.behavior.zoom()
                .on("zoom", function() {
                    myThis.zoomBehaviour()
                });
            this.zoom = zoom;
            this.svg = d3.select("#" + this.getDomId(ID_SVG)).append("svg")
                .attr("width", this.displayWidth + margin.left + margin.right)
                .attr("height", this.displayHeight + margin.top + margin.bottom)
                .attr(ATTR_CLASS, "D3graph")
                .call(zoom)
                .on("click", function() {
                    myThis.click(d3.event)
                })
                .on("dblclick", function() {
                    myThis.dbclick(d3.event)
                })
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Define the Axis
            // 100 pixels for the legend... lets see if we keep it
            this.x = D3Util.getAxis(properties.graph.axis.x.type, [0, this.displayWidth - 100]);
            this.y = D3Util.getAxis(properties.graph.axis.y.type, [this.displayHeight, 0]);

            this.xAxis = d3.svg.axis()
                .scale(this.x)
                .orient("bottom");

            this.yAxis = d3.svg.axis()
                .scale(this.y)
                .orient("left");

            // Add Axis to the plot
            this.svg.append("g")
                .attr(ATTR_CLASS, "x axis")
                .attr("transform", "translate(0," + this.displayHeight + ")")
                .call(this.xAxis);

            this.svg.append("g")
                .attr(ATTR_CLASS, "y axis")
                .call(this.yAxis);


            // Color Bar
            var colors = ["#00008B", "#0000CD", "#0000FF", "#00FFFF", "#7CFC00", "#FFFF00", "#FFA500", "#FF4500", "#FF0000", "#8B0000"];

            var colorSpacing = 100 / (colors.length - 1);

            var colorBar = D3Util.addColorBar(this.svg, colors, colorSpacing, this.displayWidth);
            this.color = d3.scale.category10();
            this.updateUI();
        },
        needsData: function() {
            return true;
        },
        initDialog: function() {
            this.addFieldsCheckboxes();
        },
        getDialogContents: function() {
            var height = this.getProperty(PROP_HEIGHT, "400");
            var html = HtmlUtils.div([ATTR_ID, this.getDomId(ID_FIELDS), ATTR_CLASS, "display-fields", ]);
            html += SUPER.getDialogContents.apply(this);
            return html;
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        // onlyZoom is not updating the axis
        updateUI: function() {
            //Note: Not sure why onlyZoom was a function param. The pointData gets passes in 
            //when the json is loaded
            //            updateUI: function(onlyZoom) {
            var onlyZoom = false;

            //Note: if we write to the SVG dom element then we lose the svg object that got created in initDisplay
            //Not sure how to show a message to the user
            if (!this.hasData()) {
                return;
            }
            test = this;
            var selectedFields = this.getSelectedFields();
            if (selectedFields.length == 0) {
                //this.writeHtml(ID_SVG, "No fields selected");
                return;
            }
            this.addFieldsCheckboxes();
            pointData = this.getData();
            if (pointData == null) {
                //this.writeHtml(ID_SVG, "No data");
                console.log("no data");
                return;
            }

            var fields = pointData.getNumericFields();
            var records = pointData.getRecords();
            var ranges = RecordUtil.getRanges(fields, records);
            var elevationRange = RecordUtil.getElevationRange(fields, records);
            var offset = (elevationRange[1] - elevationRange[0]) * 0.05;
            // To be used inside a function we can use this.x inside them so we extract as variables. 
            var x = this.x;
            var y = this.y;
            var color = this.color;
            var axis = properties.graph.axis;

            if (onlyZoom) {
                this.zoom.x(this.x);
                this.zoom.y(this.y);
            } else {
                // Update axis for the zoom and other changes
                this.x.domain(d3.extent(records, function(d) {
                    return D3Util.getDataValue(axis.x, d, selectedFields[0].getIndex());
                }));
                // the y domain depends on the first selected element I have to think about it.
                this.y.domain(d3.extent(records, function(d) {
                    return D3Util.getDataValue(axis.y, d, selectedFields[0].getIndex());
                }));

                this.zoom.x(this.x);
                this.zoom.y(this.y);
            }

            this.svg.selectAll(".y.axis").call(this.yAxis);
            this.svg.selectAll(".x.axis").call(this.xAxis);

            // Remove previous lines
            this.svg.selectAll(".line").remove();
            this.svg.selectAll(".legendElement").remove();

            var myThis = this;
            for (var fieldIdx = 0; fieldIdx < selectedFields.length; fieldIdx++) {
                var dataIndex = selectedFields[fieldIdx].getIndex();
                var range = ranges[dataIndex];
                // Plot line for the values
                var line = d3.svg.line()
                    .x(function(d) {
                        return x(D3Util.getDataValue(axis.x, d, selectedFields[fieldIdx].getIndex()));
                    })
                    .y(function(d) {
                        return y(D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex()));
                    });

                displayLine = this.svg.append("path")
                    .datum(records)
                    .attr(ATTR_CLASS, "line")
                    .attr("d", line)
                    .on("mousemove", function() {
                        myThis.mouseover(d3.event)
                    })
                    .attr("fill", "none")
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("stroke-width", "0.5px");

                if (properties.graph.axis.z == FIELD_SELECTEDFIELD) {
                    displayLine.attr("stroke", "url(#colorBarGradient)");
                }

                if (properties.graph.derived != null) {
                    var funcs = properties.graph.derived.split(",");
                    for (funcIdx = 0; funcIdx < funcs.length; funcIdx++) {
                        var func = funcs[funcIdx];
                        if (func == FUNC_MOVINGAVERAGE) {
                            // Plot moving average Line
                            var movingAverageLine = d3.svg.line()
                                .x(function(d) {
                                    return x(D3Util.getDataValue(axis.x, d, selectedFields[fieldIdx].getIndex()));
                                })
                                .y(function(d, i) {
                                    if (i == 0) {
                                        return _movingSum = D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex());
                                    } else {
                                        _movingSum += D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex());
                                    }
                                    return y(_movingSum / i);
                                })
                                .interpolate("basis");
                            this.svg.append("path")
                                .attr(ATTR_CLASS, "line")
                                .attr("d", movingAverageLine(records))
                                .attr("fill", "none")
                                .attr("stroke", function(d) {
                                    return color(fieldIdx);
                                })
                                .attr("stroke-width", "1.5px")
                                .attr("viewBox", "50 50 100 100 ")
                                .style("stroke-dasharray", ("3, 3"));
                        } else {
                            console.log("Error: Unknown derived function:" + func);
                        }

                    }
                }

                // Legend element Maybe create a function or see how we implement the legend
                this.svg.append("svg:rect")
                    .attr(ATTR_CLASS, "legendElement")
                    .attr("x", this.displayWidth - 100)
                    .attr("y", (50 + 50 * fieldIdx))
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("height", 2)
                    .attr("width", 40);

                this.svg.append("svg:text")
                    .attr(ATTR_CLASS, "legendElement")
                    .attr("x", this.displayWidth - 100 + 40 + 10) // position+color rect+padding
                    .attr("y", (55 + 55 * fieldIdx))
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("style", "font-size:50%")
                    .text(selectedFields[fieldIdx].getLabel());
            }
        },

        zoomBehaviour: function() {
            // Call redraw with only zoom don't update extent of the data.
            this.updateUI(true);
        },
        //this gets called when an event source has selected a record
        handleEventRecordSelection: function(source, args) {},
        mouseover: function() {
            // TO DO
            testing = d3.event;
            console.log("mouseover");
        },
        click: function(event) {
            // TO DO
            console.log("click:" + event);
        },
        dbclick: function(event) {
            // Unzoom
            this.zoom();
            this.updateUI();
        },
        getSVG: function() {
            return this.svg;
        }
    });
}


function RamaddaD3LineChartDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Line chart",
        //Note: changed this to "derived" from "extraLine".
        //This is a comma separated list of functions (for now just one)
        derived: FUNC_MOVINGAVERAGE,
        axis: {
            y: {
                type: TYPE_VALUE,
                fieldname: FIELD_SELECTEDFIELD
            },
            x: {
                type: TYPE_TIME,
                fieldname: FIELD_TIME,
            }
        }
    };

    properties = $.extend(dfltProperties, properties);
    return new RamaddaD3Display(displayManager, id, properties);
}


/*
function RamaddaProfileDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Profile chart",
        derived: null,
        axis: {
            y: {
                type: TYPE_ELEVATION,
                fieldname: FIELD_DEPTH,
                fieldIdx: 3,
                reverse: true
            },
            x: {
                type: TYPE_VALUE,
                fieldname: FIELD_VALUE,
            },
        }
    };
    //Note: now set the properties
    properties = $.extend(dfltProperties, properties);
    return new RamaddaD3Display(displayManager, id, properties);
}
*/



function RamaddaGliderCrossSectionDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Glider cross section",
        derived: null,
        axis: {
            y: {
                type: TYPE_ELEVATION,
                fieldname: FIELD_DEPTH,
                reverse: true
            },
            x: {
                type: TYPE_TIME,
                fieldname: FIELD_TIME,
            },
            z: FIELD_SELECTEDFIELD,
        }
    };
    properties = $.extend(dfltProperties, properties);

    return new RamaddaD3Display(displayManager, id, properties);
}






function RamaddaVennDisplay(displayManager, id, properties) {
    const ID_VENN = "venn";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_VENN, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
            var includes = "<script src='" + ramaddaCdn + "/lib/venn.js'></script>";
            this.writeHtml(ID_DISPLAY_TOP, includes);
            let _this = this;
            var func = function() {
                _this.updateUIInner();
            };
            setTimeout(func, 10);
        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return;
            }
            /*
              var sets = [{sets : [0], label : 'SE', size : 28,}, 
              {sets : [1], label : 'Treat', size: 35},
              {sets : [2], label : 'Anti-CCP', size : 108}, 
              {sets : [3], label : 'DAS28', size:106},
              {sets : [0,1], size:1},
              {sets : [0,2], size:1},
              {sets : [0,3], size:14},
            */
            var setInfos = {};
            var setCnt = 0;
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var row = this.getDataValues(records[rowIdx]);
                var keys = [];
                var key = "";
                for (var fieldIdx = 0; fieldIdx < strings.length; fieldIdx++) {
                    var field = strings[fieldIdx];
                    var value = row[field.getIndex()];
                    var setKey = field.getId() + "--" + value;
                    keys.push(setKey);
                    key += "--" + setKey;
                    if (!Utils.isDefined(setInfos[setKey])) {
                        setInfos[setKey] = {
                            count: 0,
                            setIds: [setCnt],
                            label: value,
                        };
                        setCnt++;
                    }
                    setInfos[setKey].count++;
                }
                var ids = [];
                if (!Utils.isDefined(setInfos[key])) {
                    for (var i = 0; i < keys.length; i++) {
                        ids.push(setInfos[keys[i]].setIds[0]);
                    }
                    setInfos[key] = {
                        count: 0,
                        setIds: ids,
                        label: null,
                    };
                }
                setInfos[key].count++;
            }

            var sets = [];
            for (var a in setInfos) {
                var setInfo = setInfos[a];
                var obj = {
                    sets: setInfo.setIds,
                    size: setInfo.count
                };
                if (setInfo.label)
                    obj.label = setInfo.label;
                sets.push(obj);
            }
            this.setContents(HtmlUtils.div(["id", this.getDomId(ID_VENN), "style", "height:300px;"], ""));
            var chart = venn.VennDiagram()
                .width(600)
                .height(400);
            var id = "#" + this.getDomId(ID_VENN);
            var strokeColors = this.getColorTable(true, "strokeColors", "nice");
            var fillColors = this.getColorTable(true, "fillColors", "nice");
            var textColors = this.getColorTable(true, "textColors");
            if (!textColors)
                textColors = strokeColors;
            d3.select(id).datum(sets).call(chart);
            d3.selectAll(id + " .venn-circle path")
                .style("fill-opacity", parseFloat(this.getProperty("fillOpacity", 0.5)))
                .style("stroke-width", parseInt(this.getProperty("strokeWidth", 1)))
                .style("stroke-opacity", parseFloat(this.getProperty("strokeOpacity", 0.5)))
                .style("stroke", function(d, i) {
                    return i < strokeColors.length ? strokeColors[i] : strokeColors[i % strokeColors.length];
                })
                .style("fill", function(d, i) {
                    return i < fillColors.length ? fillColors[i] : fillColors[i % fillColors.length];
                })
            d3.selectAll(id + " .venn-circle text")
                .style("fill", function(d, i) {
                    return i < textColors.length ? textColors[i] : textColors[i % textColors.length]; 
               })
                .style("font-size", this.getProperty("fontSize", "16px"))
                .style("font-weight", this.getProperty("fontWeight", "100"));

        }
    });
}


function RamaddaMinidotsDisplay(displayManager, id, properties) {
    const ID_MINIDOTS = "minidots";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MINIDOTS, properties);
    let myProps = [
	{label:'Minidots Properties'},
	{p:'dateField',ex:''},
	{p:'valueField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUI();
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let dotsWidth = +this.getProperty("dotsWidth",500);
	    let dotsHeight = +this.getProperty("dotsHeight",200);	    
	    let valueField = this.getFieldById(null,this.getPropertyValueField());
	    let dateField = this.getFieldById(null,this.getPropertyDateField());
	    let groupByField = this.getFieldById(null,this.getProperty("groupBy"));
	    let divisor = +this.getProperty("divisor",1);
	    if(!valueField) {
                this.displayError("No value field specified");
		return;
	    }
	    if(!dateField) dateField = this.getFieldByType(null,"date");
	    let dateToCount = {};
	    let minDate=null, maxDate = null;
	    let groups = {};

	    records.forEach(record=>{
		let date = dateField?record.getValue(dateField.getIndex()):record.getDate();
		minDate = minDate!=null?Math.min(minDate,date.getTime()):date;
		maxDate = maxDate!=null?Math.max(maxDate,date.getTime()):date;
	    });
	    records.forEach(record=>{
		let groupByValue = groupByField?record.getValue(groupByField.getIndex()):"all";
		let date = dateField?record.getValue(dateField.getIndex()):record.getDate();
		minDate = minDate!=null?Math.min(minDate,date.getTime()):date;
		maxDate = maxDate!=null?Math.max(maxDate,date.getTime()):date;
		let data = groups[groupByValue];
		if(!data) {
		    groups[groupByValue] = data = {
			records:[],
			total:0,
			list:[],
			seen:{}
		    }
		}
		data.records.push(record);
		let value = record.getValue(valueField.getIndex());
		data.total+=value;
		value = value/divisor;
		if(data.list.length>5000) return;
		for(let i=0;i<value;i++) {
		    data.list.push({x:date.getTime(),
				    y:Math.random(),
				    record:record});
		}
	    });
	    let range = {
		minx:minDate,
		maxx:maxDate,
		miny:0,
		maxy:1
	    }
	    let groupList = Object.keys(groups).sort();
	    if(!groupByField) {
		let data = groups["all"];
		this.setContents(HtmlUtils.div([CLASS,"display-minidots-dots", ID, this.getDomId(ID_MINIDOTS), STYLE, HU.css(HEIGHT,HU.getDimension(dotsHeight),WIDTH,HU.getDimension(dotsWidth))], ""));
		drawDots(this,"#"+ this.getDomId(ID_MINIDOTS),dotsWidth,dotsHeight,data.list,range,null/*colorBy*/);
	    } else {
		let container = this.jq(ID_MINIDOTS);
		let table = "<table border=1>";
		groupList.forEach((key,idx)=>{
		    let data = groups[key];
		    table+="<tr>";
		    table += HU.td([],key +" (" + data.total+")");
		    let id = this.getDomId(ID_MINIDOTS+"_"+idx);
		    table += HU.td([],HtmlUtils.div([CLASS,"display-minidots-dots", ID, id, STYLE, HU.css(HEIGHT,HU.getDimension(dotsHeight),WIDTH,HU.getDimension(dotsWidth))], ""));
		    table+="</tr>\n";
		});
		this.setContents(table);
		groupList.forEach((key,idx)=>{
		    let data = groups[key];
		    let id = this.getDomId(ID_MINIDOTS+"_"+idx);
		    drawDots(this,"#"+ id,dotsWidth,dotsHeight,data.list,range,null/*colorBy*/);
		});
	    }

        }
    });
}



function RamaddaChernoffDisplay(displayManager, id, properties) {
    const ID_VENN = "venn";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_VENN, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        timeout: 100,
        written: false,
        updateUI: function() {
            if (!this.written) {
                this.written = true;
                var includes = "<script src='" + ramaddaCdn + "/lib/chernoff.js'></script>";
                this.writeHtml(ID_DISPLAY_TOP, includes);
            }
            this.updateUIInner();
        },
        updateUIInner: function() {
            let _this = this;
            if (!Utils.isDefined(d3.chernoff)) {
                this.timeout = this.timeout * 2;
                var func = function() {
                    _this.updateUIInner();
                };
                setTimeout(func, this.timeout);
                return;
            }
            let records = this.filterData();
            if (!records) {
                return;
            }
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length == 0)
                fields = allFields;
            var string = this.getFieldByType(fields, "string");
            var legend = "";
            var colorField = this.getFieldById(allFields, this.getProperty("colorBy"));
            var colorscale;
            if (colorField) {
                var colors = this.getColorTable(true, null, "blue_white_red");
                var colorValues = this.getColumnValues(records, colorField);
                colorscale = [];
                var min = parseFloat(this.getProperty("colorByMin", colorValues.min));
                var max = parseFloat(this.getProperty("colorByMax", colorValues.max));
                var range = max - min;
                //                console.log("range:" +  max +" " +min +" #colors:" + colors.length);
                for (var i = 0; i < colorValues.values.length; i++) {
                    var value = colorValues.values[i];
                    var percent = (value - min) / range;
                    var idx = Math.round(percent * (colors.length - 1));
                    //                    console.log(idx+" " +colors[idx] +" " + value + " " + percent);
                    colorscale.push(colors[idx]);
                }
                this.displayColorTable(colors, ID_DISPLAY_BOTTOM, min, max);
                legend += "<b>Colored by</b>: " + colorField.getLabel() + "&nbsp;&nbsp;";
            }
            var attrs = [{
                label: "Face width",
                name: "face",
                key: "f",
                min: 0,
                max: 1
            }, {
                label: "Hair",
                name: "hair",
                key: "h",
                min: -1,
                max: 1
            }, {
                label: "Mouth",
                name: "mouth",
                key: "m",
                min: -1,
                max: 1
            }, {
                label: "Nose height",
                name: "noseHeight",
                key: "nh",
                min: 0,
                max: 1
            }, {
                label: "Nose width",
                name: "noseWidth",
                key: "nw",
                min: 0,
                max: 1
            }, {
                label: "Eyes height",
                name: "eyesHeight",
                key: "eh",
                min: 0,
                max: 1
            }, {
                label: "Eyes width",
                name: "eyesWidth",
                key: "ew",
                min: 0,
                max: 1
            }, {
                label: "Brow",
                name: "brow",
                key: "b",
                min: -1,
                max: 1
            }];
            var html = "";
            var showHelp = this.getProperty("showHelp", false);
            if (showHelp) {
                html += "Settings:<br><table class=ramadda-table><thead><tr><th>Attribute&nbsp;</th><th>&nbsp;Default range&nbsp;</th><th>&nbsp;Set field&nbsp;</th><th>&nbsp;Set min&nbsp;</th><th>&nbsp;Set max&nbsp;</th></tr></thead><tbody>";
            }

            for (a in attrs) {
                var attr = attrs[a];
                if (showHelp) {
                    html += "<tr><td>" + attr.label + "</td><td align=center>" + attr.min + " - " + attr.max + "</td><td>" + attr.name + "Field=&lt;field_id&gt;" + "</td><td>" + attr.name + "Min=&lt;min_value&gt;" + "</td><td>" + attr.name + "Max=&lt;max_value&gt;" + "</td></tr>";
                }
                attr.field = this.getFieldById(allFields, this.getProperty(attr.name + "Field"));
                if (attr.field) {
                    legend += "<b>" + attr.label + "</b>: " + attr.field.getLabel() + "&nbsp;&nbsp;";
                    if (Utils.isDefined(this.getProperty(attr.name + "Min"))) {
                        attr.min = parseFloat(this.getProperty(attr.name + "Min"));
                    }
                    if (Utils.isDefined(this.getProperty(attr.name + "Max"))) {
                        attr.max = parseFloat(this.getProperty(attr.name + "Max"));
                    }
                    attr.column = this.getColumnValues(records, attr.field);
                }
            }
            if (showHelp) {
                html += "</tbody></table>";
            }

            var sortField = this.getFieldById(allFields, this.getProperty("sortBy"));

            var rows = [];
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var blob = {
                    values: this.getDataValues(records[rowIdx])
                };
                if (colorscale) blob.color = colorscale[rowIdx]
                rows.push(blob);
            }

            if (sortField) {
                rows.sort(function(a, b) {
                    var v1 = a.values[sortField.getIndex()];
                    var v2 = b.values[sortField.getIndex()];
                    if (v1 < v2) return 1;
                    if (v1 > v2) return -1;
                    return 0;
                });
            }

            var data = [];
            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var blob = rows[rowIdx];
                var row = blob.values;
                var color = blob.color;
                var faceData = {
                    f: 0.5, //0-1
                    h: 0, //-1-1
                    m: 0, //-1-1
                    nh: 0.5, //0-1
                    nw: 0.5, //0-1
                    eh: 0.5, //0-1
                    ew: 0.5, //0-1
                    b: 0 //-1-1
                };
                data.push({
                    faceData: faceData,
                    color: color
                });
                var tt = "";
                for (a in attrs) {
                    var attr = attrs[a];
                    var field = attr.field;
                    if (!field) {
                        faceData[attr.key] = attr.min + (attr.max - attr.min) / 2;
                    } else {
                        var value = row[field.getIndex()];
                        var min = attr.column.min;
                        var max = attr.column.max;
                        tt += field.getLabel() + ": " + value + " range: " + min + " - " + max + " (" + attr.label + ")\n";
                        if (max != min) {
                            var percent = (value - min) / (max - min);
                            var adjValue = attr.min + (attr.max - attr.min) * percent;
                            //                            console.log(" %:" + percent + " v:" + value +" min:" + min +" max:" + max +" adj:" + adjValue);
                            faceData[attr.key] = adjValue;
                        }
                    }
                }
                var label = (string ? row[string.getIndex()] : "Row: " + rowIdx);
                var labelValue = (string ? row[string.getIndex()] : "");
                label = HtmlUtils.div(["class", "display-chernoff-label"], label);
                var div = HtmlUtils.div(["id", this.getDomId("chernoff") + "_" + rowIdx, "class", "display-chernoff-face"], "");
                html += HtmlUtils.div(["title", tt, "class", "display-chernoff-wrapper ramadda-div-link", "value", labelValue], div + label);
            }
            legend = HtmlUtils.div(["class", "display-chernoff-legend"], legend);
            var height = this.getProperty("height", "400px");
            if (!height.endsWith("px")) height += "px";
            this.setContents(legend + HtmlUtils.div(["style", "height:" + height + ";", "class", "display-chernoff-container", "id", this.getDomId("chernoff")], html));
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var div = "#" + this.getDomId("chernoff") + "_" + rowIdx;
                this.makeFace(div, data[rowIdx].faceData, data[rowIdx].color);
            }

            if (string) {
                this.find(".ramadda-div-link").click(function() {
                    var value = $(this).attr("value");
                    _this.propagateEvent("fieldValueSelected", {
                        field: string,
                        value: value
                    });
                });
            }
        },
        makeFace: function(div, faceData, color) {
            function chernoffFace() {
                var width = 400,
                    height = 200;
                var chernoff = d3.chernoff()
                    .face(function(d) {
                        return d.f;
                    })
                    .hair(function(d) {
                        return d.h;
                    })
                    .mouth(function(d) {
                        return d.m;
                    })
                    .nosew(function(d) {
                        return d.nw;
                    })
                    .noseh(function(d) {
                        return d.nh;
                    })
                    .eyew(function(d) {
                        return d.ew;
                    })
                    .eyeh(function(d) {
                        return d.eh;
                    })
                    .brow(function(d) {
                        return d.b;
                    });

                function data() {
                    return [faceData];
                }

                function drawFace(selection) {
                    var svg = selection.append("svg")
                        .attr("width", width)
                        .attr("height", height);
                    var face = svg.selectAll("g.chernoff")
                        .data(data())
                        .enter().append("g")
                        .attr("class", "chernoff")
                        .call(chernoff);
                    if (color)
                        face.attr("style", "fill:" + color);
                }

                function draw(selection) {
                    selection.call(drawFace);
                }
                return draw;
            }
            d3.select(div)
                .call(chernoffFace());
        }





    });
}



function RamaddaD3bubbleDisplay(displayManager, id, properties) {
    const ID_BUBBLES = "bubbles";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_D3BUBBLE, properties);
    if(!window["BubbleChart"]) {
	Utils.importJS(ramaddaCdn +"/lib/d3/d3-legend.min.js");
	Utils.importJS(ramaddaCdn +"/lib/d3/bubblechart.js");
    }
    let myProps = [
	{label:'Bubble Chart'},
	{p:'labelField',ex:''},
	{p:'colorBy',ex:''},
	{p:'valueField',ex:''},
	{p:'descriptionField',ex:''},
	{p:'imageField',ex:''},
	{p:'sizeLabel1',ex:''},
	{p:'sizeLabel2',ex:''},
	{p:'showSizeLegend',ex:'false'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	callbackWaiting:false,
        displayData: function() {
	    this.updateUI();
	},
        updateUI: function() {
            if(!window["BubbleChart"]) {
		if(!this.callbackWaiting) {
		    this.callbackWaiting = true;
                    setTimeout(()=>{
			this.callbackWaiting = false;
			this.updateUI()
		    },100);
		}
                return;
            }
	    //If the width is 0 then there is an error in the d3
	    if(this.getContents().width() ==0)  {
		this.setContents("...");
		return;
	    }
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
            let colorByField = this.getFieldById(null, this.getProperty("colorBy","category"));
	    let valueField = this.getFieldById(null, this.getProperty("valueField"));
	    if(colorByField)
		this.setProperty("sortFields",colorByField.getId());
	    let html = HtmlUtil.tag("svg", ["id", this.getDomId(ID_BUBBLES),
					    "width","100%","height","700", "font-family","sans-serif","font-size","10", "text-anchor","middle"])
	    this.setContents(html);
	    let values;
	    let min = 0;
	    let max = 0;
	    if(valueField) {
		values =  this.getColumnValues(records, valueField).values;
		values.map((v,idx)=>{
		    min  = idx==0?v:Math.min(v,min);
		    max  = idx==0?v:Math.max(v,max);
		});
	    }

	    let labelField = this.getFieldById(null, this.getProperty("labelField","name"));
	    let descField = this.getFieldById(null, this.getProperty("descriptionField"));	    
	    let imageField = this.getFieldById(null, this.getProperty("imageField"));	    
	    let template = this.getProperty("template","${default}");
	    if(!labelField) {
                this.setContents(this.getMessage("No label field found"));
		return
	    }

	    let data =[];
	    records.map(r=>{
		let desc =  descField?r.getValue(descField.getIndex()):this.getRecordHtml(r,null, template);
		let label = r.getValue(labelField.getIndex());
		let obj = {
		    name: label,
		    icon:label,
		    desc:desc,
		    cat:"",
		    value:10,
		}
		if(colorByField)
		    obj.cat = r.getValue(colorByField.getIndex());
		if(valueField)
		    obj.value = r.getValue(valueField.getIndex());
		if(imageField)
		    obj.icon = r.getValue(imageField.getIndex());
		data.push(obj);
	    });
	    if(data.length==0) {
		this.setContents(this.getMessage(this.getNoDataMessage()));
		return;
	    }
	    let colors =  this.getColorTable(true);
	    new BubbleChart("#"+this.domId(ID_BUBBLES),data,{
		label1:this.getProperty("sizeLabel1"),
		label2: this.getProperty("sizeLabel2"), 
		colors:colors,
		showSizeLegend: this.getProperty("showSizeLegend",valueField!=null)
	    });
	}
    })
}
/*
  Copyright 2008-2021 Geode Systems LLC
*/

const DISPLAY_WORDCLOUD = "wordcloud";
const DISPLAY_TEXTSTATS = "textstats";
const DISPLAY_FREQUENCY = "frequency";
const DISPLAY_TEXTANALYSIS = "textanalysis";
const DISPLAY_TEXTRAW = "textraw";
const DISPLAY_TEXT = "text";

const DISPLAY_BLOCKS = "blocks";
const DISPLAY_TEMPLATE = "template";
const DISPLAY_TOPFIELDS = "topfields";
const DISPLAY_GLOSSARY = "glossary";

addGlobalDisplayType({
    type: DISPLAY_TEXT,
    label: "Text Readout",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Simple text display","text.png")
});

addGlobalDisplayType({
    type: DISPLAY_TEMPLATE,
    label: "Template",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Flexible text template to show records","template.png")    
});


addGlobalDisplayType({
    type: DISPLAY_TOPFIELDS,
    label: "Top Fields",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("List Fields","topfields.png","For every row it sorts the field values and lists the field names"),    
});

addGlobalDisplayType({
    type: DISPLAY_WORDCLOUD,
    forUser: true,
    label: "Word Cloud",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Cloud of words","wordcloud.png")
});

addGlobalDisplayType({
    type: DISPLAY_TEXTSTATS,
    forUser: true,
    label: "Text Stats",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Summary statistics for text","textstats.png","Incudes line/word count, word length and frequency")    
});

addGlobalDisplayType({
    type: DISPLAY_FREQUENCY,
    forUser: true,
    label: "Frequency",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Text field based frequencies","frequency.png")
});
addGlobalDisplayType({
    type: DISPLAY_TEXTRAW,
    forUser: true,
    label: "Text Raw",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Shows raw text","textraw.png","Provides a search field")                                        
});
addGlobalDisplayType({
    type: DISPLAY_TEXTANALYSIS,
    forUser: true,
    label: "Text Analysis",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Analyzes text","textanalysis.png")
});
addGlobalDisplayType({
    type: DISPLAY_BLOCKS,
    forUser: true,
    label: "Blocks",
    requiresData: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Blocks","blocks.png","Shows a certain number of small blocks or<br> icons color coded from the data"),        
});

addGlobalDisplayType({
    type: DISPLAY_GLOSSARY,
    forUser: true,
    label: "Glossary",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Searchable glossary","glossary.png")    
});


function RamaddaBaseTextDisplay(displayManager, id, type, properties) {
    const ID_TEXTBLOCK = "textblock";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    defineDisplay(this, SUPER, [], {
        processText: function(cnt,fields) {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            var fieldInfo = {};
            var allFields = this.getData().getRecordFields();
            fields = fields || this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
            var minLength = parseInt(this.getProperty("minLength", 0));
            var maxLength = parseInt(this.getProperty("maxLength", 100));
            var stopWords = this.getProperty("stopWords");
            if (stopWords) {
                if (stopWords == "default") {
                    stopWords = Utils.stopWords;
                } else {
                    stopWords = stopWords.split(",");
                }
            }
            var extraStopWords = this.getProperty("extraStopWords");
            if (extraStopWords) extraStopWords = extraStopWords.split(",");

            var stripTags = this.getProperty("stripTags", false);
            var tokenize = this.getProperty("tokenize", false);
            var lowerCase = this.getProperty("lowerCase", false);
            var removeArticles = this.getProperty("removeArticles", false);
            if (cnt) {
                cnt.count = 0;
                cnt.total = 0;
                cnt.lengths = {};
            }
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var row = this.getDataValues(records[rowIdx]);
                for (var fieldIdx = 0; fieldIdx < strings.length; fieldIdx++) {
                    var field = strings[fieldIdx];
                    if (!fieldInfo[field.getId()]) {
                        fieldInfo[field.getId()] = {
                            field: field,
                            words: [],
                            counts: {},
                            divId: this.domId(ID_TEXTBLOCK + (field.getIndex())),
                        }
                    }
                    var fi = fieldInfo[field.getId()];
                    var value = row[field.getIndex()];
                    if (stripTags) {
                        value = Utils.stripTags(value);
                    }
                    var values = [value];
                    if (tokenize) {
			values[0] = values[0].replace(/\"/g," ");
                        values = Utils.tokenizeWords(values[0], stopWords, extraStopWords, removeArticles);
                    }
                    for (var valueIdx = 0; valueIdx < values.length; valueIdx++) {
                        var value = values[valueIdx].trim();
			if(values.length>1 && value.length<=1) continue;
			if(value.startsWith("&")) continue;  
			var _value = value.toLowerCase();
                        if (cnt) {
                            cnt.count++;
                            cnt.total += value.length;
                            if (!Utils.isDefined(cnt.lengths[value.length]))
                                cnt.lengths[value.length] = 0;
                            cnt.lengths[value.length]++;
                        }


                        if (!tokenize) {
                            if (stopWords && stopWords.includes(_value)) continue;
                            if (extraStopWords && extraStopWords.includes(_value)) continue;
                        }
                        if (value.length > maxLength) continue;
                        if (value.length < minLength) continue;
                        if (lowerCase) value = value.toLowerCase();
                        if (!Utils.isDefined(fi.counts[value])) {
                            fi.counts[value] = 0;
                        }
                        fi.counts[value]++;
                    }
                }
            }



            return fieldInfo;
        }
    });
}


function RamaddaWordcloudDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_WORDCLOUD, properties);
    let myProps = [
	{label:"Wordcloud"},
	{p:'termField'},
	{p:'fields'},	
	{p:'tableFields'},
	{p:'countField'},
	{p:'tokenize',ex:true},
	{p:'handleClick',ex:true},
	{p:'showFieldLabel',ex:true},
	{p:'showRecords'},
	{p:'combined'},
	{p:'shape',ex:'rectangular'},
	{p:'stopWords',ex:'word1,word2'},
	{p:'showFieldLabel',ex:'false'}	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
	    if(!this.loadedJq) {
		this.loadedJq = true;
		let includes = "<link rel='stylesheet' href='" + ramaddaCdn + "/lib/jqcloud.min.css'>";
		includes += "<script src='" + ramaddaCdn + "/lib/jqcloud.min.js'></script>";
		this.writeHtml(ID_DISPLAY_TOP, includes);
		let _this = this;
		let func = function() {
                    _this.updateUIInner();
		};
		setTimeout(func, 10);
	    } else {
                this.updateUIInner();
	    }
        },
        updateUIInner: function() {
            let records = this.filterData();
	    if(records == null) return;
            let options = {
                autoResize: true,
            };
            let colors = this.getColorTable(true);
            if (colors) {
                options.colors = colors,
                options.classPattern = null;
                options.fontSize = {
                    from: 0.1,
                    to: 0.02
                };
            }
            if (this.getProperty("shape"))
                options.shape = this.getProperty("shape");

	    let countField = this.getFieldById(null, this.getProperty("countField"));
	    let termField = this.getFieldById(null, this.getProperty("termField"));
	    if(countField && termField) {
		let minLength = parseInt(this.getProperty("minLength", 0));
		let maxLength = parseInt(this.getProperty("maxLength", 100));
		let stopWords = this.getProperty("stopWords");
		if (stopWords) {
                    if (stopWords == "default") {
			stopWords = Utils.stopWords;
                    } else {
			stopWords = stopWords.split(",");
                    }
		}
		let info = [];
		let wordToWeight = {};
		records.every(record=>{
		    let word =termField.getValue(record);
		    let _word = word.toLowerCase();
                    if (stopWords && stopWords.includes(_word)) return true;
		    if(!wordToWeight[word]) {
			wordToWeight[word]=0;
		    }
		    wordToWeight[word]+=countField.getValue(record);
		    return true;
		});
                let handlers = null;
		let _this = this;
                if (this.getProperty("handleClick", true)) {
                    handlers = {
                        click: function(w) {
                            let word = w.target.innerText;
                            _this.showRows(records, null, word, fields);
                        }
                    }
                };

		    
		for(word in wordToWeight) {
		    info.push({
			text: word,
			html:{style:"cursor:pointer;"},
			weight:wordToWeight[word] ,
			handlers:handlers,
		    });

		}
                this.setContents(HU.div([ID, this.domId("words"), STYLE, HU.css('height','300px')], ""));
                $("#" + this.domId("words")).jQCloud(info, options);
		return
	    }
            let allFields = this.getData().getRecordFields();
            let fields = termField?[termField]:this.getSelectedFields(allFields);
            let fieldInfo = this.processText(null,fields);
            if (fieldInfo == null) return;
            if (fields.length == 0)
                fields = allFields;
            let strings = this.getFieldsByType(fields, "string");
            let _this = this;
            let divs = "";
            let words = [];
            let maxWords = parseInt(this.getProperty("maxWords", -1));
            let minCount = parseInt(this.getProperty("minCount", 0));
            let width = (100 * 1 / strings.length) + "%;";
            for (a in fieldInfo) {
                let fi = fieldInfo[a];
                let field = fi.field;
                let handlers = null;
                if (this.getProperty("handleClick", true)) {
                    handlers = {
                        click: function(w) {
                            let word = w.target.innerText;
                            _this.showRows(records, field, word, fields);
                        }
                    }
                };

                let counts = [];
                for (word in fi.counts) {
                    let count = fi.counts[word];
                    counts.push({
                        word: word,
                        count: count
                    });
                }
                counts.sort(function(a, b) {
                    if (a.count < b.count) return -1;
                    if (a.count > b.count) return 1;
                    return 0;
                });
                if (minCount > 0) {
                    let tmp = [];
                    for (let i = 0; i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }
                if (maxWords > 0) {
                    let tmp = [];
                    for (let i = 0; i <= maxWords && i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                for (let wordIdx = 0; wordIdx < counts.length; wordIdx++) {
                    let word = counts[wordIdx];
                    let obj1 = {
                        weight: word.count,
			html:{style:"cursor:pointer;"},
                        handlers: handlers,
                        text: word.word,
                    };
                    let obj2 = {
                        weight: word.count,
			html:{style:"cursor:pointer;"},
                        handlers: handlers,
                        text: field.getLabel() + ":" + word.word,
                    };
                    fi.words.push(obj1);
                    words.push(obj2);
                }
                let label = "";
                if (this.getProperty("showFieldLabel", true))
                    label = HU.b(fi.field.getLabel());

                divs += HU.div([STYLE,HU.css('display','inline-block','width', width)], 
			       label + HU.div([STYLE, HU.css('border','1px #ccc solid','height','300px'), ID, fi.divId], ""));
            }

            this.setContents("");
            if (this.getProperty("combined", false)) {
                this.setContents(HU.div([ID, this.domId("words"), STYLE, HU.css('height','300px')], ""));
                $("#" + this.domId("words")).jQCloud(words, options);
            } else {
                this.setContents(divs);
                for (a in fieldInfo) {
                    let fi = fieldInfo[a];
                    $("#" + fi.divId).jQCloud(fi.words, options);
                }
            }
        },
        showRows: function(records, field, word, stringFields) {
	    if(!field)
		field = this.getFieldById(null, this.getProperty("termField"));
            let tokenize = this.getProperty("tokenize", false);
            if (stringFields && word.startsWith(field.getLabel() + ":")) {
                word = word.replace(field.getLabel() + ":", "");
            }
            let tableFields;
            if (this.getProperty("tableFields")) {
                tableFields = {};
                let list = this.getProperty("tableFields").split(",");
                for (a in list) {
                    tableFields[list[a]] = true;
                }
            }
            let fields = this.getData().getRecordFields();
            let html = "";
            let data = [];
            let header = [];
            data.push(header);
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let f = fields[fieldIdx];
                if (tableFields && !tableFields[f.getId()]) continue;
                header.push(fields[fieldIdx].getLabel());
            }
            let showRecords = this.getProperty("showRecords", false);
            if (showRecords) {
                html += "<br>";
            }
            let re = new RegExp("(\\b" + word + "\\b)", 'i');
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                let value =  row[field.getIndex()];
                if (tokenize) {
                    if (!value.match(re)) {
                        continue;
                    }
                } else {
                    if (word != value) {
                        continue;
                    }
                }
                let tuple = [];
                data.push(tuple);
                for (let col = 0; col < fields.length; col++) {
                    let f = fields[col];
                    if (tableFields && !tableFields[f.getId()]) continue;
                    let v = row[f.getIndex()];
		    if(v.getTime) {
			v = {v:v,f:this.formatDate(v)};
		    } else {
			if (tokenize) {
                            v = v.replace(re, "<span style=background:yellow;>$1</span>");
			}
		    }
                    if (showRecords) {
                        html += HU.b(f.getLabel()) + ": " + v + "</br>";
                    } else {
                        tuple.push(v);
                    }
                }
                if (showRecords) {
                    html += "<p>";
                }
            }

            if (showRecords) {
                this.writeHtml(ID_DISPLAY_BOTTOM, HU.center(html));
            } else {
                let prefix = "";
                if (!tokenize) {
                    prefix = (field?field.getLabel():"Word") + "=" + word
                }
                this.writeHtml(ID_DISPLAY_BOTTOM, HU.center(prefix + HU.div([ID, this.domId("table"), STYLE, HU.css('height','300px')], "")));
                let dataTable = google.visualization.arrayToDataTable(data);
                this.chart = new google.visualization.Table(document.getElementById(this.domId("table")));
                this.chart.draw(dataTable, {
                    allowHtml: true
                });
            }
        }
    });
}




function RamaddaTemplateDisplay(displayManager, id, properties) {
    if(!Utils.isDefined(properties.showTitle)) properties.showTitle=false;
    if(!Utils.isDefined(properties.showMenu)) properties.showMenu=false;
    if(!Utils.isDefined(properties.displayStyle)) properties.displayStyle = "background:rgba(0,0,0,0);";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TEMPLATE, properties);
    let myProps = [
	{label:"Template"},
	{p: "template"},
	{p:"toggleTemplate",ex:"",tt:'Used as the toggle label for hiding/showing the main template'},
	{p:"headerTemplate",ex:"... ${totalCount} ... ${selectedCount}"},
	{p:"footerTemplate",ex:"... ${totalCount} ... ${selectedCount}"},
	{p:"emptyMessage"},
	{p:"select",ex:"max|min|<|>|=|<=|>=|contains"},
	{p:"selectField"},
	{p:"selectValue"},
	{p:'onlyShowSelected',ex:'true'},
	{p:'showRecords',tt:'comma separated list of record indices',ex:'0,3,4'},
	{p:'dontShowRecords',tt:'comma separated list of record indices to not show',ex:'0,3,4'},	
	{p:'showFirst',ex:'true'},
	{p:'showLast',ex:'true'},		
	{p:'selectHighlight',ex:'true'},	
	{p:'handleSelectOnClick'},
	{p:"groupByField"},
	{p:"groupDelimiter",ex:"<br>"},	
	{p:"groupTemplate",wikivalue:"<b>${group}</b><ul>${contents}</ul>"},
	{p:"sortGroups",wikivalue:"true"},
	{p:'${&lt;field&gt;_total}'},
	{p:'${&lt;field&gt;_max}'},
	{p:'${&lt;field&gt;_min}'},
	{p:'${&lt;field&gt;_average}'},
	{p:'highlightOnScroll',ex:'true'}];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	dataFilterChanged: function() {
	    if(this.getPropertyOnlyShowSelected() && this.selectedRecord ) {
		this.selectedRecord = null;
		this.selectedRecords = null;		
		this.setContents("");
	    }
	    SUPER.dataFilterChanged.call(this);
	},
	updateUI: function() {
	    let pointData = this.getData();
	    if(pointData==null) return;
	    let records = this.filterData();
	    if(!records) return;
	    if(this.getPropertyOnlyShowSelected()) {
		if(!this.selectedRecord && !this.selectedRecords) {
		    if(this.getShowFirst(true)) {
			this.selectedRecord = records[0];
		    }
		}
		if(!this.selectedRecord && !this.selectedRecords) {
		    this.setContents("<br>");
		    return;
		}
		records = this.selectedRecords|| [this.selectedRecord];
	    } else {
		if(this.getShowFirst(false)) {
		    records = [records[0]];
		} else 	if(this.getShowLast(false)) {
		    records = [records[records.length-1]];
		}
	    }
	    records= this.sortRecords(records);
	    let showRecords = this.getShowRecords();
	    if(showRecords) {
		let tmp = [];
		showRecords.split(",").forEach(idx=>{
		    tmp.push(records[+idx]);
		});
		records = tmp;
	    }
	    let dontShowRecords = this.getDontShowRecords();
	    if(dontShowRecords) {
		let notOK = {};
		dontShowRecords.split(",").forEach(idx=>{
		    notOK[+idx]=true;
		});
		let tmp = [];
		for(let i=0;i<records.length;i++) {
		    if(notOK[i]) continue;
		    tmp.push(records[i]);
		}
		records = tmp;
	    }	    
	    let fields = pointData.getRecordFields();
	    let uniqueFields  = this.getFieldsByIds(fields, this.getProperty("uniqueFields"));
	    let uniqueMap ={};
	    let template = this.getProperty("template","");
	    let toggleTemplate = this.getProperty("toggleTemplate");
	    let select = this.getProperty("select","all");
	    let selected = [];
	    let summary = {};
	    let goodRecords = [];
	    records.forEach(record=>{
		if(uniqueFields.length>0) {
		    var key= "";
		    uniqueFields.map(uf=>{
			key += "__" +uf.getValue(record);
		    });
		    if(Utils.isDefined(uniqueMap[key])) {
			return;
		    }
		    uniqueMap[key] = true;
		}
		goodRecords.push(record);
		for(var i=0;i<fields.length;i++) {
		    var f = fields[i];
		    var v =f.getValue(record);
		    if(!summary[f.getId()]) {
			summary[f.getId()] = {
			    total: 0,
			    min: v,
			    max:v,
			    count:0,
			    uniques:{},
			    uniqueCount:0
			}
		    }
		    var s = summary[f.getId()];
		    if(f.isString()) {
			if(!s.uniques[v]) {
			    s.uniqueCount++;
			    s.uniques[v] = true;
			}
			continue;
		    } 
		    if(f.isDate&& v.getTime) {
			if(v.getTime()<s.min.getTime()) s.min = v;
			if(v.getTime()>s.max.getTime()) s.max = v;
		    }  else if(!isNaN(v)) {
			s.total+=v;
			s.min = Math.min(s.min,v);
			s.max = Math.max(s.max,v);
			s.count++;
		    }
		}
	    });

	    records=goodRecords;

	    for(var i=0;i<fields.length;i++) {
		var f = fields[i];
		if(!f.isNumeric()) continue;
		var s = summary[f.getId()];
		if(s && s.count) {
		    s.average =  s.total/s.count;
		}
	    }
	    

	    if(select == "max" || select=="min" || select=="=" || select=="<" || select == ">" ||
	       select == "<=" || 	       select == "?>=" || select=="match") {
		var selectField = this.getProperty("selectField",null);
		if(selectField) selectField  =this.getFieldById(null, selectField);
		if(!selectField) {
		    this.setContents("No selectField specified");
		    return;
		}
		var selectValue = this.getProperty("selectValue","0");
		var selectValueNum = parseFloat(selectValue);
		var max =0; 
		var min = 0;
		var cnt = 0;
		var maxRecord;
		var minRecord;
		var equalsRecord;
		records.map(record=>{
		    var v =selectField.getValue(record);
		    if(select == "match") {
			if(v.match(selectValue)) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == "=") {
			if(v == selectValue) {
			    selected.push(record);
			}
			return;
		    }
		    if(isNaN(v)) return;
		    if(select == "<") {
			if(v < selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == ">") {
			if(v > selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == ">=") {
			if(v >= selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == "<=") {
			if(v <= selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(cnt++ == 0) {
			min  = v;
			max = v;
			minRecord = record;
			maxRecord = record;
			return;
		    }
		    if(v<min) {
			min  = v;
			minRecord = record;
		    }
		    if(v > max) {
			max =v;
			maxRecord = record;
		    }
		});
		if(select == "min") {
		    if(minRecord)
			selected.push(minRecord);
		} else 	if(select == "max") {
		    if(maxRecord)
			selected.push(maxRecord);
		}
	    } else {
		selected = records;
	    }
	    var contents = "";
	    if(selected.length==0) {
		contents = this.getProperty("emptyMessage","Nothing found");
	    }

            var colorBy = this.getColorByInfo(selected);

	    let attrs = {};
	    attrs["selectedCount"] = selected.length;
	    attrs["totalCount"] = records.length;


	    for(var i=0;i<fields.length;i++) {
		var f = fields[i];
		var s = summary[f.getId()];
		if(!s) continue;
		if(f.isDate) {
		    attrs[f.getId()+"_min"] = s.min;
		    attrs[f.getId()+"_max"] = s.max;
		    continue;
		}
		if(s && f.isString()) {
		    attrs[f.getId() +"_uniques"] =  s.uniqueCount;
		    continue;
		}
		if(!f.isNumeric()) continue;
		if(s) {
		    attrs[f.getId() +"_total"] = s.total;
		    attrs[f.getId() +"_min"] = s.min;
		    attrs[f.getId() +"_max"] = s.max;
		    attrs[f.getId() +"_average"] = s.average;
		}
	    }

	    var headerTemplate = this.getProperty("headerTemplate","");
	    var footerTemplate = this.getProperty("footerTemplate","");

	    if(selected.length==1) {
		let row = this.getDataValues(selected[0]);
		headerTemplate = this.applyRecordTemplate(selected[0],row,fields,headerTemplate);
		footerTemplate = this.applyRecordTemplate(selected[0],row,fields,footerTemplate);
	    }

	    if(this.filters) {
		let replace = (pattern,value)=>{
		    headerTemplate = headerTemplate.replace(pattern,value);
		    footerTemplate = footerTemplate.replace(pattern,value);		    
		};
		for(var filterIdx=0;filterIdx<this.filters.length;filterIdx++) {
		    let filter = this.filters[filterIdx];
		    if(!filter.isEnabled()) {
			continue;
		    }
		    let f = filter.getField();
		    if(f.isNumeric()) {
			var min = $("#" + this.domId("filterby_" + f.getId()+"_min")).val().trim();
			var max = $("#" + this.domId("filterby_" + f.getId()+"_max")).val().trim();
			attrs["filter_" + f.getId() +"_min"] = min;
			attrs["filter_" + f.getId() +"_max"] = max;
		    } else {
			var widget =$("#" + this.domId("filterby_" + f.getId())); 
			if(!widget.val || widget.val()==null) continue;
			var value = widget.val();
			if(!value) continue;
			if(Array.isArray(value)) {
			    var tmp = "";
			    value.map(v=>{
				if(tmp!="") tmp+=", ";
				tmp+=v;
			    });
			    value = tmp;
			}
			value = value.trim();
			if(value==FILTER_ALL) {
			    var regexp = new RegExp("\\${filter_" + f.getId()+"[^}]*\\}",'g');
			    replace(regexp,"");
			} else {
			    var regexp = new RegExp("\\${filter_" + f.getId()+" +prefix='([^']*)' +suffix='([^']*)' *\\}",'g');
			    replace(regexp,"$1" + value +"$2");
			    var regexp = new RegExp("\\${filter_" + f.getId()+" +prefix='([^']*)' *\\}",'g');
			    replace(regexp,"$1" + value);
			    var regexp = new RegExp("\\${filter_" + f.getId()+" +suffix='([^']*)' *\\}",'g');
			    replace(regexp,value +"$1");
			    var regexp = new RegExp("\\${filter_" + f.getId()+" *\\}",'g');
			    replace(regexp,value);
			}
		    }
		}
	    }

	    let th = Utils.tokenizeMacros(headerTemplate);
	    let tf = Utils.tokenizeMacros(footerTemplate);
	    headerTemplate = th.apply(attrs);
	    footerTemplate = tf.apply(attrs);	    

	    if(selected.length>0) {
		contents+= headerTemplate;
	    }
	    if(template!= "") {
		let groupByField  =this.getFieldById(null, this.getProperty("groupByField"));
		let groupDelimiter  = this.getProperty("groupDelimiter"," ");
		let groupTemplate  = this.getProperty("groupTemplate","<b>${group}</b><ul>${contents}</ul>");
		let groupList = [];
		let groups = {};
		var props = this.getTemplateProps(fields);
		var max = parseFloat(this.getProperty("maxNumber",-1));
		var cols = parseFloat(this.getProperty("templateColumns",-1));
		var colTag;
		if(cols>0) {
		    colTag = "col-md-" +Math.round(12/cols);
		    contents += '<div class="row-tight row">';
		}
		var colCnt = 0;
		var style = this.getProperty("templateStyle","");
		let handleSelectOnClick = this.getPropertyHandleSelectOnClick(true);

		for(var rowIdx=0;rowIdx<selected.length;rowIdx++) {
		    if(max!=-1 && rowIdx>=max) break;
		    if(cols>0) {
			if(colCnt>=cols) {
			    colCnt=0;
			    contents += '</div>\n';
			    contents += '<div class="row-tight row">\n';
			}
			contents+='<div  class="' + colTag+'">\n';
			colCnt++;
		    }
		    var record = selected[rowIdx];
		    var color = null;
                    if (colorBy.index >= 0) {
			var value =  record.getData()[colorBy.index];
			color =  colorBy.getColor(value, record);
		    }
		    let s = template.trim();
		    let row = this.getDataValues(record);
		    if(s.startsWith("${default")) {
			s = this.getRecordHtml(record,fields,s);
		    } else {
			s= this.applyRecordTemplate(record, row,fields,s,props);
		    }


		    let macros = Utils.tokenizeMacros(s);
		    let rowAttrs = {};
		    rowAttrs["selectCount"] = selected.length;
		    rowAttrs["totalCount"] = records.length;
		    rowAttrs[RECORD_INDEX] = rowIdx+1;
		    let dataFilters = this.getDataFilters();
		    this.filters.forEach(f=>{
			if(!f.isEnabled() || !f.getField) return;
			rowAttrs["filter." + f.getField().getId()] =  f.getFieldValues();
		    });
		    var recordStyle = style;
		    if(color) {
			if(this.getProperty("colorBackground",false)) {
			    recordStyle = HU.css("background",color) + recordStyle;
			}
			rowAttrs["color"] = color;
		    }
		    if(!handleSelectOnClick)
			recordStyle+=HU.css("cursor","default");
		    var tag = HU.openTag("div",[CLASS,"display-template-record",STYLE,recordStyle, ID, this.getId() +"-" + record.getId(), TITLE,"",RECORD_ID,record.getId(),RECORD_INDEX, rowIdx]);
		    s = macros.apply(rowAttrs);
		    if(s.startsWith("<td")) {
			s = s.replace(/<td([^>]*)>/,"<td $1>"+tag);
			s = s.replace(/<\/td>$/,"</div></td>");
		    } else if(s.startsWith("<tr")) {
			s = s.replace(/<td([^>]*)>/g,"<td $1>"+tag);
			s = s.replace(/<\/td>/g,"</div></td>");
		    }  else {
			s = tag +s +HU.close(DIV);
		    }
		    if(toggleTemplate) {
			let t =this.applyRecordTemplate(record, row,fields,toggleTemplate,props); 
			s =  HU.toggleBlock(t, s,false);
		    }

		    if (groupByField) {
			let groupValue =groupByField.getValue(record);
			if(groupValue.getTime) groupValue = this.formatDate(groupValue);
			if(!groups[groupValue]) {
			    groupList.push(groupValue);
			    groups[groupValue] = "";
			} else {
			    groups[groupValue]+=groupDelimiter;
			}
			groups[groupValue]+=s;
		    } else {
			contents+=s;
		    }


		    if(cols>0) {
			contents+=HU.close(DIV);
		    }
		}
		if (groupByField) {
		    if(this.getPropertySortGroups(false))
			groupList = groupList.sort();
		    groupList.forEach(group=>{
			contents+=  groupTemplate.replace("${group}",group).replace("${contents}",groups[group]);
		    });
		}
		if(cols>0) {
		    contents += HU.close(DIV);
		}
	    }
	    if(selected.length>0) 
		contents+= footerTemplate;
	    this.setContents(contents,true);
	    this.addFieldClickHandler(null,null,false);
	    var recordElements = this.find(".display-template-record");
	    this.makeTooltips(recordElements, selected);
	    this.makePopups(recordElements, selected);
	    let _this = this;
	    if(this.getPropertyHandleSelectOnClick(true)) {
		this.find(".display-template-record").click(function() {
		    var record = selected[$(this).attr(RECORD_INDEX)];
		    _this.handleEventRecordHighlight(this, {record:record,highlight:true,immediate:true,skipScroll:true});
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		});
	    }


	    if(this.getPropertyHighlightOnScroll(false)) {
		let items = this.find(".display-template-record");
		this.getContents().css('overflow-y','scroll');
		this.getContents().scroll(()=>{
		    let topElement = null;
		    items.each(function() {
			let pos  = $(this).position();
			if(pos.top<0) {
			    topElement = $(this);
			}
		    });
		    if(topElement) {
			var record = selected[topElement.attr(RECORD_INDEX)];
			if(record && this.currentTopRecord && record!=this.currentTopRecord) {
			    this.propagateEventRecordSelection({highlight:true,record: record});
			}
			this.currentTopRecord = record;
		    }
		});
	    }





	},
	highlightCount:0,
        handleEventRecordSelection: function(source, args) {
	    this.selectedRecords = args.records;
	    this.selectedRecord = args.record;
	    if(this.getProperty("onlyShowSelected")) {
		this.updateUI();
	    } else {
		args.highlight = true;
		this.handleEventRecordHighlight(source, args);
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    if(this.getPropertySelectHighlight()) {
		this.selectedRecord=args.record;
		this.callUpdateUI();
		return
	    }

	    this.currentTopRecord = null;
	    let myCount = ++this.highlightCount;
	    var id = "#" + this.getId()+"-"+args.record.getId();
	    if(this.highlightedElement) {
		this.unhighlightElement(this.highlightedElement);
		this.highlightedElement = null;
	    }
//	    console.log(this.type+ " handleEventRecordHighlight " + args.highlight); 
	    if(args.highlight) {
		if(args.immediate) {
		    this.highlightElement(args);
		} else {
		    setTimeout(() =>{
			if(myCount == this.highlightCount) {
			    this.highlightElement(args);
			}
		    },500);
		}
	    } else {
		var id = "#" + this.getId()+"-"+args.record.getId();
		var element = $(id);
		this.unhighlightElement(element);
	    }
	},
	unhighlightElement: function(element) {
	    this.currentTopRecord = null;
	    element.removeClass("display-template-record-highlight");
	    var css = this.getProperty("highlightOffCss","").split(";");
	    if(css.length>0) {
		css.map(tok=>{
		    var c = tok.split(":");
		    var a = c[0];
		    var v = c.length>1?c[1]:null;
		    if(!v || v=="") {
			v = element.attr("prev-" + a);
		    }
		    if(v) {
			//			    console.log("un highlight css:" + element.css("background")+ " idx:" + element.attr(RECORD_INDEX));
			element.css(a,v);
		    }
		});
	    } 
	},
	highlightElement: function(args) {
	    var id = "#" + this.getId()+"-"+args.record.getId();
	    var element = $(id);
	    this.highlightedElement = element;
	    element.addClass("display-template-record-highlight");
	    var css = this.getProperty("highlightOnCss","").split(";");
	    if(css.length>0) {
		css.map(tok=>{
		    var c = tok.split(":");
		    var a = c[0];
		    var v = c.length>1?c[1]:null;
		    if(!v || v=="") {
			v = element.attr("prev-" + a);
		    }
		    if(v) {
			var oldV = element.css(a);
			if(oldV) {
			    element.attr("prev-" + a,oldV);
			}
			element.css(a,v);
		    }
		});
	    } 
	    

	    try {
		if(!args.skipScroll) {
		    var eo = element.offset();
		    if(eo==null) return;
		    var container = this.getContents();
		    if(this.getProperty("orientation","vertical")== "vertical") {
			var c = container.offset().top;
			var s = container.scrollTop();
			container.scrollTop(eo.top- c + s)
		    } else {
			var c = container.offset().left;
			var s = container.scrollLeft();
			container.scrollLeft(eo.left- c + s)
		    }
		}

	    } catch(err) {
		console.log("Error:" + err);
	    }

	}
    })}





function RamaddaTopfieldsDisplay(displayManager, id, properties) {
    const ID_SLIDE = "slide";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TOPFIELDS, properties);
    let myProps = [
	{label:'Top Fields'},
	{p:'fieldCount',tt:''},
	{p:'labelField',tt:''},
	{p:'dateFormat',ex:'yyyy'},
	{p:'labelField'},
	{p:'scaleFont',ex:'false'}
    ]
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    var pointData = this.getData();
	    if (pointData == null) return;
	    let records = this.filterData();
	    if(!records) return;

            var fields = this.getData().getNonGeoFields();
	    var labelField = this.getFieldById(fields,this.getProperty("labelField"));
	    if(labelField==null) {
		labelField = this.getFieldById(fields, TITLE);
	    }
	    if(labelField==null) {
		labelField = this.getFieldById(fields, "name");
	    }
	    var fieldsToUse = this.getFieldsByIds(fields,this.getPropertyFields());
	    if(fieldsToUse.length==0) fieldsToUse = fields;
	    var html = "";
	    var fieldCount = +this.getProperty("fieldCount",10);
	    var dataList = [];
	    var min = Number.MAX_VALUE;
	    var max = Number.MIN_VALUE;
	    var dateFormat = this.getProperty("dateFormat");
	    for(var i=0;i<records.length;i++) {
		var record = records[i]; 
		var tuple = record.getData();
		var data =[];
		for(var j=0;j<fieldsToUse.length;j++) {
		    var field = fieldsToUse[j];
		    if(!field.isNumeric()) continue;
		    var value  =tuple[field.getIndex()];
		    if(!isNaN(value)) {
			min  = Math.min(min, value);
			max  = Math.max(max, value);
		    }
		    data.push({value: value, field: field});
		}
		data.sort((a,b)=>{
		    return b.value-a.value;
		});
		var header = labelField?tuple[labelField.getIndex()]:" Record:" + (i+1);
		if((labelField && labelField.isFieldDate()) || (typeof header =="date"))  {
		    header = Utils.formatDateWithFormat(header, dateFormat);
		}
		dataList.push({data:data,record:record,header:header});
	    }
	    var scaleFont = this.getProperty("scaleFont",true);
	    for(var i=0;i<dataList.length;i++) {
		var data = dataList[i].data;
		var record = dataList[i].record;
		var header = dataList[i].header;
		var tuple = record.getData();
		var div = "";
		var contents = "";
		for(var j=0;j<data.length && j<fieldCount;j++) {
		    var value = data[j].value;
		    var percent = max==min?1:(value-min)/(max-min);
		    var fontSize = 6+Math.round(percent*24)+"pt";
		    if(!scaleFont) fontSize = "100%";
		    var field = data[j].field;
		    contents += HU.div(["field-id",field.getId(), "data-value",field.getLabel(), TITLE,"Value: " + value, CLASS,"display-topfields-row",STYLE,"font-size:" + fontSize+";"], field.getLabel());
		}
		div += HU.div([CLASS,"display-topfields-header",RECORD_INDEX,i],header);
		div += HU.div([CLASS,"display-topfields-values"], contents);
		html+=HU.div([CLASS,"display-topfields-record"], div);
	    }
	    this.setContents(html);
	    let _this = this;
	    this.find(".display-topfields-header").click(function(){
		var idx = $(this).attr(RECORD_INDEX);
		_this.find(".display-topfields-record").removeClass("display-topfields-selected");
		$(this).parent().addClass("display-topfields-selected");
		var record = records[idx];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    let rows =this.find(".display-topfields-row");
	    rows.hover(function() {
		rows.removeClass("display-topfields-highlight");
		var value = $(this).attr("data-value");
		_this.find(HU.attrSelect("data-value", value)).addClass("display-topfields-highlight");
		
	    });
	    rows.click(function() {
		var field = $(this).attr("field-id");
		_this.getDisplayManager().notifyEvent(DisplayEvent.fieldsSelected, _this, [field]);
		
	    });
	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    var index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    var container = this.getContents();
	    container.find(".display-topfields-record").removeClass("display-topfields-selected");
	    var element =   container.find(HU.attrSelect(RECORD_INDEX, index)).parent();
	    element.addClass("display-topfields-selected");
	    var c = container.offset().top;
	    var s = container.scrollTop();
	    var eo = element.offset();
	    var diff = eo.top- c + s;
	    container.scrollTop(diff)
	},



    })}










function RamaddaBlocksDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_BLOCKS, properties);
    const ID_BLOCKS_HEADER = "blocks_header";
    const ID_BLOCKS = "blocks";
    const ID_BLOCKS_FOOTER = "blocks_footer";
    let myProps = [
	{label:'Block'},
	{p:'animStep',d:0,ex:"1000",tt:'Animation delay (ms)'},
	{p:'doSum',d:true,ex:"false",tt:''},
	{p:'numBlocks',d:1000,ex:"1000",tt:'How many blocks to show'},
	{p:'header',d:true,ex:"Each block represents ${blockValue} ... There were a total of ${total} ...",tt:''},
	{p:'blockIcon',d:null,ex:"fa-male",tt:'Use an icon'},
	{p:'emptyBlockStyle',d:"background:transparent;border:1px solid #ccc;",tt:'Style for blocks not displayed yet'},	
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        updateUI: function() {
	    let f = this.getPropertyFields();
	    let records;
	    if(f) {
		records = this.filterData();
		if(!records) return;
	    }
	    this.counts = [];
	    this.counts2 = [];
	    if(f) {
		let fields = this.getFieldsByIds(null,f);
		if(!fields) return;
		this.footers = [];
		this.headers = [];
		let numBlocks  = this.getNumBlocks(1000);
		this.total = 0;
		fields.forEach(f=>{
		    this.footers.push("${count} " + f.getLabel());
		    let v = f.getValue(records[0]);
		    if(!isNaN(v)) this.total+=v;
		    this.counts.push(v);
		});

		if(this.total>0) {
		    this.blockValue = this.total/numBlocks;
		    this.counts.forEach(v=>{
			let percent = isNaN(v)?0:v/this.total;
			let scaledValue = percent*numBlocks;
			this.counts2.push(scaledValue);
		    });
		}
	    } else {
		//todo: set this
		this.blockValue = 0;
		let counts = this.getProperty("counts","100",true).split(";");
		for(var i=0;i<counts.length;i++) 
		    this.counts.push(parseFloat(counts[i]));
		let doSum = this.getPropertyDoSum();
		if(doSum) {
		    this.counts2 = this.counts;
		} else {
		    this.total = 0;
		    for(var i=0;i<this.counts.length;i++) {
			let tmp = this.counts[i];
			this.counts2.push(this.counts[i]-this.total);
			this.total+= tmp;
		    }
		}
		this.footers = this.getProperty("footers","",true).split(";");
		this.headers = this.getProperty("headers","",true).split(";");
	    }
	    while(this.footers.length< this.counts.length)
		this.footers.push("");
	    while(this.headers.length< this.counts.length)
		this.headers.push("");
	    this.setContents(
		HU.div([CLASS,"display-blocks-header",STYLE, this.getProperty("headerStyle","", true),ID,this.domId(ID_BLOCKS_HEADER)]) +
		    HU.div([CLASS,"display-blocks-blocks",ID,this.domId(ID_BLOCKS)],"")+
		    HU.div([CLASS,"display-blocks-footer", STYLE, this.getProperty("footerStyle","", true), ID,this.domId(ID_BLOCKS_FOOTER)]));
	    //Show the outline
	    this.showBlocks(true);
	    if(this.getProperty("displayOnScroll")) {
		HU.callWhenScrolled(this.domId(ID_DISPLAY_CONTENTS),()=>{
		    if(!this.displayedBlocks) {
			this.displayedBlocks = true;
			if(this.timeout)
			    clearTimeout(this.timeout);
			this.tmeout = setTimeout(()=>{this.showBlocks(false)},this.getPropertyAnimStep());
		    }
		},500);
	    }  else {
		this.showBlocks(false);
	    }
	},
	showBlocks: function(initial, step) {
	    if(!Utils.isDefined(step)) {
		if(initial)step = this.counts.length;
		else step = 0;
	    }
	    let contents = "";
	    contents += HU.openDiv([CLASS,"display-blocks"]);
	    let tmp =this.getProperty("colors","#d73027,#fdae61,#74add1,#423E3B,red,green,blue",true); 
	    let ct = (typeof tmp) =="string"?tmp.split(","):tmp;
	    let footer ="";
	    while(ct.length<this.counts.length) {
		ct.push(ct[ct.length-1]);
	    }

	    let multiplier = parseFloat(this.getProperty("multiplier","1",true));
	    let dim=this.getProperty("blockDimensions","8",true);
	    let labelStyle = this.getProperty("labelStyle","", true);
	    let blockCnt = 0;
	    let iconProp = this.getProperty("blockIcon");
	    let clazz = iconProp?"display-block-icon":"display-block";
	    let emptyStyle = this.getEmptyBlockStyle();
	    for(let i=0;i<this.counts2.length;i++) {
		let num = multiplier*this.counts[i];
		if(isNaN(num)) num = 0;
		let label = this.footers[i].replace("${count}",Utils.formatNumberComma(num));
		let style =  iconProp?"":"width:" + dim+"px;height:" + dim+"px;";
		let iconStyle = "";
		if(!initial) {
		    if(i<step) {
			if(!iconProp)
			    style += HU.css("background", ct[i]);
			else
			    iconStyle+=HU.css("color" ,ct[i]);
			let footerIcon =  iconProp?HU.getIconImage(iconProp, null, [STYLE, iconStyle]):"";
			footer += HU.div([CLASS,clazz,STYLE,style],footerIcon) +" " + HU.span([STYLE,labelStyle], label)+"&nbsp;&nbsp;";
		    } else {
			style += HU.css("background","transparent","border","1px solid #ccc");
			footer += "&nbsp;&nbsp;";
		    }
		} else {
		    style+=emptyStyle;
		}
		let icon = iconProp?HU.getIconImage(iconProp, null, [STYLE, iconStyle]):"";
		let cnt = this.counts2[i];
		for(let j=0;j<10000 && j<this.counts2[i];j++) {
		    contents += HU.div([CLASS,clazz,STYLE,style,TITLE,label],icon);
		}
		blockCnt++;
	    }
	    contents += HU.closeDiv();
	    let header = this.getProperty("header","");
	    header = header.replace("${total}",Utils.formatNumberComma(this.total)).replace("${blockValue}", Utils.formatNumberComma(Math.round(this.blockValue)));

	    this.jq(ID_BLOCKS_HEADER).html(header);
	    this.jq(ID_BLOCKS).html(contents);
	    this.jq(ID_BLOCKS_FOOTER).html(footer);
	    if(step < this.counts.length) {
		if(!this.getPropertyAnimStep()) {
		    this.showBlocks(false, step+1);
		} else {
		    if(this.timeout)
			clearTimeout(this.timeout);
		    this.timeout = setTimeout(()=>{this.showBlocks(false, step+1)},this.getPropertyAnimStep());
		}
	    }
	}
    });
}





function RamaddaTextstatsDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTSTATS, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        updateUI: function() {
            var cnt = {};
            var fieldInfo = this.processText(cnt);
            if (fieldInfo == null) return;
            let records = this.filterData();
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;

            var strings = this.getFieldsByType(fields, "string");
            let _this = this;
            var divs = "";
            var words = [];
            var html = "";
            var counts = [];
            var maxWords = parseInt(this.getProperty("maxWords", -1));
            var minCount = parseInt(this.getProperty("minCount", 0));
            var showBars = this.getProperty("showBars", true);
            var scale = this.getProperty("barsScale", 10);
            var barColor = this.getProperty("barColor", "blue");

            var barWidth = parseInt(this.getProperty("barWidth", "400"));
            for (a in fieldInfo) {
                var fi = fieldInfo[a];
                let field = fi.field;
                for (word in fi.counts) {
                    var count = fi.counts[word];
                    counts.push({
                        word: word,
                        count: count
                    });
                }
                counts.sort(function(a, b) {
                    if (a.count < b.count) return -1;
                    if (a.count > b.count) return 1;
                    return 0;
                });
                if (minCount > 0) {
                    var tmp = [];
                    for (var i = 0; i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                if (maxWords > 0) {
                    var tmp = [];
                    for (var i = 0; i <= maxWords && i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                var min = 0;
                var max = 0;
                if (counts.length > 0) {
                    max = counts[0].count;
                    min = counts[counts.length - 1].count;
                }

                var tmp = [];
                for (a in cnt.lengths) {
                    tmp.push({
                        length: parseInt(a),
                        count: cnt.lengths[a]
                    });
                }
                tmp.sort(function(a, b) {
                    if (a.length < b.length) return -1;
                    if (a.length > b.length) return 1;
                    return 0;
                });
                var min = 0;
                var max = 0;
                for (var i = 0; i < tmp.length; i++) {
                    max = (i == 0 ? tmp[i].count : Math.max(max, tmp[i].count));
                    min = (i == 0 ? tmp[i].count : Math.min(min, tmp[i].count));
                }
                if (this.getProperty("showFieldLabel", true))
                    html += HU.b(fi.field.getLabel()) + "<br>";
                var td1Width = "20%";
                var td2Width = "10%";
                if (this.getProperty("showSummary", true)) {
                    html += HU.openTag("table", [CLASS, "nowrap ramadda-table", ID, this.domId("table_summary")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Summary") + HU.th([], "&nbsp;"));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    html += HU.tr([], HU.td(["align", "right"], "Total lines:") + HU.td([], records.length));
                    html += HU.tr([], HU.td(["align", "right"], "Total words:") + HU.td([], cnt.count));
                    html += HU.tr([], HU.td(["align", "right"], "Average word length:") + HU.td([], Math.round(cnt.total / cnt.count)));
                    html += HU.closeTag("tbody");

                    html += HU.closeTag("table");
                    html += "<br>"
                }
                if (this.getProperty("showCounts", true)) {
                    html += HU.openTag("table", [CLASS, "row-border nowrap ramadda-table", ID, this.domId("table_counts")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Word Length") + HU.th(["width", td2Width], "Count") + (showBars ? HU.th([], "") : ""));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    for (var i = 0; i < tmp.length; i++) {
                        var row = HU.td([], tmp[i].length) + HU.td([], tmp[i].count);
                        if (showBars) {
                            var wpercent = (tmp[i].count - min) / max;
                            var width = 2 + wpercent * barWidth;
                            var color = barColor;
                            var div = HU.div([STYLE, "height:10px;width:" + width + "px;background:" + color], "");
                            row += HU.td([], div);
                        }
                        html += HU.tr([], row);
                    }
                    html += HU.closeTag("tbody");
                    html += HU.closeTag("table");
                    html += "<br>"
                }
                if (this.getProperty("showFrequency", true)) {
                    html += HU.openTag("table", [CLASS, "row-border ramadda-table", ID, this.domId("table_frequency")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Word") + HU.th(["width", td2Width], "Frequency") + (showBars ? HU.th([], "") : ""));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    var min = 0;
                    var max = 0;
                    if (counts.length > 0) {
                        min = counts[0].count;
                        max = counts[counts.length - 1].count;
                    }
                    var totalWords = 0;
                    for (var i = 0; i < counts.length; i++) {
                        totalWords += counts[i].count;
                    }
                    for (var i = counts.length - 1; i >= 0; i--) {
                        var percent = Math.round(10000 * (counts[i].count / totalWords)) / 100;
                        var row = HU.td([], counts[i].word + "&nbsp;:&nbsp;") +
                            HU.td([], counts[i].count + "&nbsp;&nbsp;(" + percent + "%)&nbsp;:&nbsp;");
                        if (showBars) {
                            var wpercent = (counts[i].count - min) / max;
                            var width = 2 + wpercent * barWidth;
                            var color = barColor;
                            var div = HU.div([STYLE, "height:10px;width:" + width + "px;background:" + color], "");
                            row += HU.td([], div);
                        }
                        html += HU.tr([], row);
                    }
                    html += HU.closeTag("tbody");
                    html += HU.closeTag("table");
                }
            }
            this.setContents(html);
            var tableHeight = this.getProperty("tableHeight", "200");

            if (this.getProperty("showSummary", true))
                HU.formatTable("#" + this.domId("table_summary"), {
                    scrollY: this.getProperty("tableSummaryHeight", tableHeight)
                });
            if (this.getProperty("showCounts", true))
                HU.formatTable("#" + this.domId("table_counts"), {
                    scrollY: this.getProperty("tableCountsHeight", tableHeight)
                });
            if (this.getProperty("showFrequency", true)) {
                this.frequencyTable = HU.formatTable("#" + this.domId("table_frequency"), {
		    scrollY: this.getProperty("tableFrequenecyHeight", tableHeight),
		    searching: this.getProperty("showSearch", true)
		});
		this.frequencyTable.on( 'search.dt', ()=>{
		    if(this.settingSearch) return;
		    this.propagateEvent(DisplayEvent.propertyChanged, {
			property: "searchValue",
			value: this.frequencyTable.search()
		    });

		} );
	    }
	    
        },
        handleEventPropertyChanged: function(source, prop) {
            if (prop.property == "searchValue") {
		this.settingSearch=true;
		this.setProperty("searchValue", prop.value);
		this.frequencyTable.search(prop.value);
		this.frequencyTable.draw();
		this.settingSearch=false;
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this,source, prop);
	},

    });
}



function RamaddaFrequencyDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_FREQUENCY, properties);
    let myProps = [
	{label:'Frequency'},
	{p:'orientation',ex:'vertical'},
	{p:'tableHeight',ex:'300px'},
	{p:'showPercent',ex:'false'},
	{p:'showCount',ex:'false'},
	{p:'showBars',ex:'true'},
	{p:'showBars',ex:'false'},
	{p:'showHeader',ex:'false'},
	{p:'banner',ex:'true'},
	{p:'barWidth',ex:'200'},
	{p:'clickFunction',ex:'selectother'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        updateUI: function() {
            let records = this.filterData();
	    if(!records) return;
            let allFields = this.getData().getRecordFields();
            let fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
	    let summary={};
	    for (let col = 0; col < fields.length; col++) {
		let f = fields[col];
		if(!Utils.isDefined(summary[f.getId()])) {
		    summary[f.getId()] = {
			counts:{},
			values:[],
			min:null,
			max:null,
			total:0,
			numbers:[],
			field:f
		    }
		}
	    }

	    let showCount = this.getProperty("showCount",true);
	    let showPercent = this.getProperty("showPercent",true);
	    let showBars = this.getProperty("showBars",false);
	    let barWidth = +this.getProperty("barWidth",200);

            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                for (let col = 0; col < fields.length; col++) {
                    let f = fields[col];
		    let s = summary[f.getId()];
                    let value =  row[f.getIndex()];
		    if(!Utils.isDefined(s.min)) {
			s.min=value;
			s.max=value;
		    }
		    if(f.isNumeric()) {
			s.numbers.push(value);
			if(isNaN(s.max)) s.max = value;
			else if(!isNaN(value))s.max = Math.max(value,s.max);
			if(isNaN(s.min)) s.min = value;
			else if(!isNaN(value))s.min = Math.min(value,s.min);
		    } else {
			if(!Utils.isDefined(s.counts[value])) {
			    let tuple = {value:value,count:0}
			    s.counts[value] = tuple;
			    s.values.push(tuple);
			}
			s.total++;
			s.counts[value].count++;
		    }
                }
	    }
	    let html = "";
	    let bannerHtml = "";
	    for (let col = 0; col < fields.length; col++) {
		bannerHtml += "<div style='text-align:center;'>";
		let f = fields[col];
		let s = summary[f.getId()];
		//		if(col>0) html+="<br>";
		if(f.isNumeric()) {
		    let numBins = parseFloat(this.getProperty("numBins",10,true));
		    s.bins = [];
		    let range = s.max-s.min;
		    let binWidth = (s.max-s.min)/numBins;
		    let label = "Not defined";
		    s.bins.push(label);
		    let tuple = {value:label,count:0}
		    s.counts[label] = tuple;
		    s.values.push(tuple);
                    let binsProp = this.getProperty(f.getId() +".bins");
		    let hasBins = Utils.stringDefined(binsProp);
		    let binValues;
                    if(hasBins) {
                        let l  = binsProp.split(",");
			binValues = [];
			l.map(v=>binValues.push(+v));
                        for(let i=0;i<l.length-1;i++) {
			    let v1 = +l[i];
			    let v2 = +l[i+1];
			    let label = v1 +" - " + v2;
			    s.bins.push(label);
			    let tuple = {value:label,count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
                        }
		    } else {
			for(let i=0;i<numBins;i++) {
			    let label = (Utils.formatNumber(s.min+binWidth*i)) +" - " + Utils.formatNumber(s.min+binWidth*(i+1));
			    s.bins.push(label);
			    let tuple = {value:label,count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
			}
		    }
		    for(let i=0;i<s.numbers.length;i++) {
			let value = s.numbers[i];
			let bin=0;
			if(!isNaN(value)) {
			    if(binValues) {
				for(let j=0;j<binValues.length-1;j++) {
				    if(value>=binValues[j] && value< binValues[j+1]) {
					bin = j;
					break;
				    }
				}
			    } else {
				if(binWidth!=0) {
				    let perc = (value-s.min)/range;
				    bin = Math.round(perc/(1/numBins))+1;
				    if(bin>numBins) bin = numBins;
				}
			    }
			}
			let label = s.bins[bin]; 
			if(!Utils.isDefined(s.counts[label])) {
			    let tuple = {value:s.bins[bin],count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
			}
			s.total++;
			s.counts[label].count++;
		    }
		}

		let hor = this.getProperty("orientation","") != "vertical";
		if(this.getProperty("floatTable") !=null) {
		    hor = this.getProperty("floatTable")==true;
		}
		html += HU.openTag("div", [CLASS,"display-frequency-table",STYLE,hor?"":"display:block;"]);
		html += HU.openTag("table", ["cellpadding","3",ID,this.domId("summary"+col),"table-height",this.getProperty("tableHeight","300",true), CLASS, "stripe row-border nowrap ramadda-table"]);
		if(this.getProperty("showHeader",true)) {
		    html += HU.openTag("thead", []);
		    let label =  HU.span([TITLE,"Click to reset",CLASS,"display-frequency-label","data-field",s.field.getId()],f.getLabel());

		    
		    label = HU.div([STYLE,"max-width:500px;overflow-x:auto;"], label);
		    let count = showCount? HU.th(["align","right","width","20%"],HU.div([STYLE,"text-align:right"],"Count")):"";
		    let percent  = showPercent?HU.th(["align","right","width","20%"],  HU.div([STYLE,"text-align:right"],"Percent")):"";
		    let bars = showBars? HU.th(["align","right","width",barWidth],HU.div([STYLE,"text-align:right"],"&nbsp;")):"";
		    html += HU.tr([], HU.th(["xxwidth","60%"],  label+ count+ percent+bars));
		    html += HU.closeTag("thead");
		}

		html += HU.openTag("tbody", []);
		let colors = this.getColorTable(true);
		let dfltColor = this.getProperty("barColor","blue");
		if(colors) {
		    for(let i=0;i<s.values.length;i++) {
			let value = s.values[i].value;
			if(i<colors.length)
			    s.values[i].color = colors[i];
			else
			    s.values[i].color = colors[colors.length-1];
		    }
		}

	    	if(!f.isNumeric()) {
		    s.values.sort((a,b)=>{
			if(a.count<b.count) return 1;
			if(a.count>b.count) return -1;
			return 0;
		    });
		}

		let maxPercent = 0;
		for(let i=0;i<s.values.length;i++) {
		    let count = s.values[i].count;
		    if(count==0) continue;
		    let perc = count/s.total;
		    maxPercent = Math.max(maxPercent, perc);
		}

		for(let i=0;i<s.values.length;i++) {
		    let value = s.values[i].value;
		    let label = value;
		    if(label=="") label="&lt;blank&gt;";
		    let count = s.values[i].count;
		    if(count==0) continue;
		    let perc = count/s.total;
		    value = value.replace(/\'/g,"&apos;");
		    let countLabel = count
		    let color = s.values[i].color;
		    if(!color) color = dfltColor;

		    if(showPercent) countLabel+=" (" + Math.round(perc*100)+"%)";
		    bannerHtml += HU.div([TITLE,"Click to select",CLASS," display-frequency-item","data-field",s.field.getId(),"data-value",value], value +"<br>" + countLabel);
		    let tdv = HU.td([], value);
		    let tdc =  (showCount?HU.td(["align", "right"], count):"");
		    let tdp =  showPercent?HU.td(["align", "right"], s.total==0?"0":Math.round(perc*100)+"%"):"";
		    let bw = perc/maxPercent;
		    let tdb = showBars?HU.td(["valign","center","width",barWidth], HU.div([TITLE,Math.round(perc*100)+"%",STYLE,"background:" + color+";height:10px;width:"+ (Math.round(bw*barWidth))+"px"],"")):"";
		    html += HU.tr([], 
					 tdv + tdc + tdp + tdb
					);
		}
		html += HU.close(TBODY,TABLE,DIV);
		bannerHtml += HU.close(TD);
	    }

	    let doBanner = this.getProperty("banner",false);
	    if(doBanner) html = HU.div([CLASS,"display-frequency-banner"], bannerHtml);
	    this.setContents(html);
	    let _this = this;
	    let cnt = 0;
	    let items = this.find(".display-frequency-item");
	    items.click(function(){
		let click = _this.getProperty("clickFunction")
		let value = $(this).attr("data-value");
		let fieldId = $(this).attr("data-field");
		let parent = $(this).parent();
		let isSelected = $(this).hasClass("display-frequency-item-selected");
		items.removeClass("display-frequency-item-selected");
		if(!isSelected) {
		    $(this).addClass("display-frequency-item-selected");
		} else {
		    value = FILTER_ALL;
		}
		if(!click || click =="select") {
		    _this.handleEventPropertyChanged(_this,{
			property: "pattern",
			fieldId: fieldId,
			value: value
		    });
		} else if(click == "selectother") {
		    _this.propagateEvent(DisplayEvent.fitlerChanged, {
			value: value,
			id:_this.getFilterId(fieldId),
			fieldId: fieldId,
		    });
		}
	    });
	    this.find(".display-frequency-label").click(function(){
		let field = $(this).attr("data-field");
		//		    _this.find("[data-field=" + field+"]").css("color","black");
		_this.handleEventFilterChanged(_this,{
		    id:ID,
		    fieldId: field,
		    value: "-all-"
		});
	    });

	    if(this.getProperty("showHeader",true)) {
		for (let col = 0; col < fields.length; col++) {
		    HU.formatTable("#" +this.domId("summary"+col),{});
		}
	    }
	}
    });
}

function RamaddaTextanalysisDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTANALYSIS, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
            var includes = "<script src='" + ramaddaCdn + "/lib/compromise.min.js'></script>";
            this.writeHtml(ID_DISPLAY_TOP, includes);
            let _this = this;
            var func = function() {
                _this.updateUIInner();
            };
            setTimeout(func, 10);
        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            let _this = this;
            this.setDisplayMessage("Processing text...");
            var func = function() {
                _this.updateUIInnerInner();
            };
            setTimeout(func, 10);
        },
        updateUIInnerInner: function() {
            let records = this.filterData();
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
	    var strings = this.getFieldsByIds(fields,"fields");
            if (strings.length == 0) {
		strings = this.getFieldsByType(fields, "string");
	    }
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
	    if(!this.lastRecords || this.lastRecords.length!= records.length) {
		this.lastRecords = records;
		var corpus = "";
		for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                    var row = this.getDataValues(records[rowIdx]);
                    var line = "";
                    for (var col = 0; col < strings.length; col++) {
			var f = fields[col];
			line += " ";
			line += row[f.getIndex()];
                    }
                    corpus += line;
		    corpus += "\n";
		}
		//		console.log("corpus:" + corpus.length +"\n" + corpus.substring(0,1000));
		this.nlp = window.nlp(corpus);
		//		console.log("after");
	    }
	    var nlp = this.nlp;
            var cols = [];
            if (this.getProperty("showPeople", false)) {
                cols.push(this.printList("People", nlp.people().out('topk')));
            }
            if (this.getProperty("showPlaces", false)) {
                cols.push(this.printList("Places", nlp.places().out('topk')));
            }
            if (this.getProperty("showOrganizations", false)) {
                cols.push(this.printList("Organizations", nlp.organizations().out('topk')));
            }
            if (this.getProperty("showTopics", false)) {
                cols.push(this.printList("Topics", nlp.topics().out('topk')));
            }
            if (this.getProperty("showNouns", false)) {
                cols.push(this.printList("Nouns", nlp.nouns().out('topk')));
            }
            if (this.getProperty("showVerbs", false)) {
                cols.push(this.printList("Verbs", nlp.verbs().out('topk')));
            }
            if (this.getProperty("showAdverbs", false)) {
                cols.push(this.printList("Adverbs", nlp.adverbs().out('topk')));
            }
            if (this.getProperty("showAdjectives", false)) {
                cols.push(this.printList("Adjectives", nlp.adjectives().out('topk')));
            }
            if (this.getProperty("showClauses", false)) {
                cols.push(this.printList("Clauses", nlp.clauses().out('topk')));
            }
            if (this.getProperty("showContractions", false)) {
                cols.push(this.printList("Contractions", nlp.contractions().out('topk')));
            }
            if (this.getProperty("showPhoneNumbers", false)) {
                cols.push(this.printList("Phone Numbers", nlp.phoneNumbers().out('topk')));
            }
            if (this.getProperty("showValues", false)) {
                cols.push(this.printList("Values", nlp.values().out('topk')));
            }
            if (this.getProperty("showAcronyms", false)) {
                cols.push(this.printList("Acronyms", nlp.acronyms().out('topk')));
            }
            if (this.getProperty("showNGrams", false)) {
                cols.push(this.printList("NGrams", nlp.ngrams().out('topk')));
            }
            if (this.getProperty("showDates", false)) {
                cols.push(this.printList("Dates", nlp.dates().out('topk')));
            }
            if (this.getProperty("showQuotations", false)) {
                cols.push(this.printList("Quotations", nlp.quotations().out('topk')));
            }
            if (this.getProperty("showUrls", false)) {
                cols.push(this.printList("URLs", nlp.urls().out('topk')));
            }
            if (this.getProperty("showStatements", false)) {
                cols.push(this.printList("Statements", nlp.statements().out('topk')));
            }
            if (this.getProperty("showTerms", false)) {
                cols.push(this.printList("Terms", nlp.terms().out('topk')));
            }
            if (this.getProperty("showPossessives", false)) {
                cols.push(this.printList("Possessives", nlp.possessives().out('topk')));
            }
            if (cols.length == 0) {
                this.setDisplayMessage("No text types specified");
                return;
            }
            var height = this.getProperty("height", "400");
            var html = HU.openTag("div", [ID, this.domId("tables")]);

            for (var i = 0; i < cols.length; i += 3) {
                var c1 = cols[i];
                var c2 = i + 1 < cols.length ? cols[i + 1] : null;
                var c3 = i + 2 < cols.length ? cols[i + 2] : null;
                var width = c2 ? (c3 ? "33%" : "50%") : "100%";
                var style = "padding:5px";
                var row = "";
                row += HU.td(["width", width], HU.div([STYLE, style], c1));
                if (c2)
                    row += HU.td(["width", width], HU.div([STYLE, style], c2));
                if (c3)
                    row += HU.td(["width", width], HU.div([STYLE, style], c3));
                html += HU.tag("table", ["width", "100%"], HU.tr(row));
            }
            html += HU.closeTag("div");
            this.setContents(html);
            HU.formatTable("#" + this.domId("tables") + " .ramadda-table", {
                scrollY: this.getProperty("tableHeight", "200")
            });
        },
        printList: function(title, l) {
            var maxWords = parseInt(this.getProperty("maxWords", 10));
            var minCount = parseInt(this.getProperty("minCount", 0));
            var table = HU.openTag("table", ["width", "100%", CLASS, "stripe hover ramadda-table"]) + HU.openTag("thead", []);
            table += HU.tr([], HU.th([], title) + HU.th([], "&nbsp;"));
            table += HU.close(THEAD);
            table += HU.open(TBODY);
            var cnt = 0;
            for (var i = 0; i < l.length; i++) {
                if (l[i].count < minCount) continue;
                var row = HU.td([], l[i].normal) +
                    HU.td([], l[i].count + " (" + l[i].percent + "%)");
                table += HU.tr([], row);
                if (cnt++ > maxWords) break;
            }
            table += HU.close(TBODY,TABLE);
            return table;
        }
    });
}


function RamaddaTextrawDisplay(displayManager, id, properties) {
    const ID_TEXT = "text";
    const ID_OVERLAY = "overlay";
    const ID_OVERLAY_TABLE = "overlaytable";
    const ID_LABEL = "label";
    const ID_SEARCH = "search";
    const ID_HIGHLIGHT = "highlight"; 
    const ID_SHRINK = "shrink";
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTRAW, properties);
    let myProps = [
	{label:'Raw Text'},
	{p:'doBubble',ex:'true'},
	{p:'addLineNumbers',ex:'false'},
	{p:'labelTemplate',ex:'${lineNumber}'},
	{p:'maxLines',ex:'1000'},
	{p:'pattern',ex:'initial search pattern'},
	{p:'fromField',ex:''},
	{p:'linesDescriptor',ex:''},
	{p:'asHtml',ex:'false'},
	{p:'breakLines',ex:'true'},
	{p:'includeEmptyLines',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	doShrink: properties["initialShrink"],
        checkLayout: function() {
            this.updateUI();
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            var pointData = this.getData();
            this.allRecords = pointData.getRecords();
            var pattern = this.getProperty("pattern");
            if (pattern && pattern.length == 0) pattern = null;
	    if(pattern) pattern = pattern.replace(/"/g,"&quot;");
	    let input = "";
	    if(!this.filters || this.filters.length==0) 
		input += " " + HU.input("pattern", (pattern ? pattern : "") , ["placeholder", "Search text", ID, this.domId(ID_SEARCH)]);
	    this.showShrink = this.getProperty("showShrink",false);
	    if(this.showShrink) {
		input += " " + HU.checkbox("shrink",[ID,this.domId(ID_SHRINK)], this.getProperty("initialShrink", true)) +" Shrink ";
	    }

            this.writeHtml(ID_TOP_RIGHT, HU.span([ID,this.domId(ID_LABEL)]," ") + input);
            let _this = this;
	    this.jq(ID_SHRINK).click(function() {
		_this.doShrink = _this.jq(ID_SHRINK).is(':checked');
		_this.setProperty("initialShrink",_this.doShrink);
		_this.updateUI();
	    });
            this.jq(ID_SEARCH).keypress(function(event) {
                if (event.which == 13) {
                    _this.setProperty("pattern", $(this).val());
		    _this.propagateEvent(DisplayEvent.propertyChanged, {
			property: "pattern",
			value: $(this).val()
		    });
                    _this.updateUI();
                }
            });
            var height = this.getProperty("height", "600");
	    var style = this.getProperty("displayInnerStyle","");
            var html = HU.div([ID, this.domId(ID_TEXT), STYLE, "padding:4px;border:1px #ccc solid; max-height:" + height + "px;overflow-y:auto;" + style]);
            this.setContents(html);
	    let t1 = new Date();
            this.showText();
	    let t2 = new Date();
//	    Utils.displayTimes("T",[t1,t2]);
        },
        handleEventPropertyChanged: function(source, prop) {
            if (prop.property == "pattern") {
		this.setProperty("pattern", prop.value);
		this.updateUI();
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this,source, prop);
	},

        showText: function() {
	    let _this  = this;
            let records = this.filterData();
            if (!records) {
                return null;
            }
	    this.records = records;
 	    this.recordToIndex = {};
	    this.indexToRecord = {};
            var pattern = this.getProperty("pattern");
            if (pattern && pattern.length == 0) pattern = null;
	    var asHtml = this.getProperty("asHtml", true);
            var addLineNumbers = this.getProperty("addLineNumbers", true);
	    var labelTemplate = this.getProperty("labelTemplate","");
	    var labelWidth = "10px";
	    if(labelTemplate == "") {
		labelWidth = "1px";
	    }
	    if(labelTemplate == "" && addLineNumbers) {
		labelTemplate = "${lineNumber}";
	    }

            if (labelTemplate) asHtml = true;
            var maxLines = parseInt(this.getProperty("maxLines", 100000));
            var lineLength = parseInt(this.getProperty("lineLength", 10000));
            var breakLines = this.getProperty("breakLines", true);


            var includeEmptyLines = this.getProperty("includeEmptyLines", false);
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
	    var highlights;
	    var highlightStyles;
	    if(this.getProperty("highlights")) {
		highlights=[];
		highlightStyles = this.getProperty("highlightStyles","background:rgb(250_comma_0_comma_0);").split(",");
		this.getProperty("highlights","").split(",").map(h=>{
		    if(h.indexOf("(")<0) h = "(" + h +")";
		    highlights.push(RegExp(h,'ig'));
		});
	    }

            var corpus = HU.openTag("div", [STYLE,"position:relative;"]);
	    corpus+=HU.div([ID,this.domId(ID_OVERLAY),STYLE,"position:absolute;top:0;left:0;"],
				  HU.tag("table",[ID,this.domId(ID_OVERLAY_TABLE)]));

	    var fromField = this.getFieldById(null,this.getProperty("fromField"));
	    var bubble=this.getProperty("doBubble",false);
            if (labelTemplate) {
                corpus += "<table width=100%>";
            }
            var lineCnt = 0;
            var displayedLineCnt = 0;
	    var patternMatch = new TextMatcher(pattern);
	    var regexpMaps = {};
	    var filterFieldMap = {};
	    if(this.filters) {
		this.filters.map(f=>{if(f.field && f.field.isString)filterFieldMap[f.field.getId()]=f;});
	    }
	    var templates = {};
	    fields.map(f=>{
		templates[f.getId()] = this.getProperty(f.getId() +".template");
	    });
            var colorBy = this.getColorByInfo(records);
	    var delimiter = this.getProperty("delimiter","");
	    var rowScale = this.showShrink?this.getProperty("rowScale",0.3):null;

	    if(this.showShrink) {
		corpus+=HU.tr([],HU.td([],HU.getIconImage("fa-caret-down")));
	    }
	    let templateFields = this.getFields();
	    let templateProps = this.getTemplateProps(templateFields);	    
	    let templateMacros = Utils.tokenizeMacros(labelTemplate?labelTemplate:"");
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
		var record = records[rowIdx];
		if(!Utils.isDefined(record.lineNumber)) {
		    record.lineNumber = (rowIdx+1);
		}
		this.indexToRecord[rowIdx] = record;
		this.recordToIndex[record.getId()] = rowIdx;
                var row = this.getDataValues(record);
                var line = "";
                for (var col = 0; col < fields.length; col++) {
                    var f = fields[col];
		    if(rowIdx==0) {
			if(filterFieldMap[f.getId()]) {
			    let filter = filterFieldMap[f.getId()];
			    var value = filter.getFieldValues();
			    if(value) {
				if(!Array.isArray(value)) {
				    value = [value];
				}
				try {
				    regexpMaps[f.getId()] =  [];
				    value.map(v=>{
					if(v == "" || v == FILTER_ALL) return;
					var re = new TextMatcher(v);
					regexpMaps[f.getId()].push(re);
				    })
				} catch(e) {console.log("Error making regexp:" + e);}
			    }
			}
		    }
		    var value = ""+row[f.getIndex()];
                    value = value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
		    if(regexpMaps[f.getId()]) {
			regexpMaps[f.getId()].map(re=>{
			    value  = re.highlight(value);
			});
		    }
		    
		    if(line!="") 
			line += delimiter+" ";
		    if(templates[f.getId()]) {
			value = templates[f.getId()].replace("${value}",value);
		    }
                    line += value;
                }
                line = line.trim();
                if (!includeEmptyLines && line.length == 0) continue;
                lineCnt++;
		var rowAttrs =["valign", "top"];
		var rowStyle="";
                if (colorBy.index >= 0) {
		    var value = record.getData()[colorBy.index];
		    var color =  colorBy.getColor(value, record);
		    if(color) {
			rowAttrs.push(STYLE);
			rowStyle +="background:" + Utils.addAlphaToColor(color,"0.25")+";";
		    }
                }
		rowAttrs.push(CLASS);
		rowAttrs.push("display-raw-row");
		var matches=patternMatch.matches(line);
		var hasMatch = matches && patternMatch.hasPattern();
		if(hasMatch) {
		    rowAttrs.push("matched");
		    rowAttrs.push(true);
		}
		if(rowScale) {
		    if(!hasMatch) {
			rowStyle += "-webkit-transform: scale(1," + rowScale +");";
			rowStyle += "line-height:"+ rowScale +";";
			rowAttrs.push(STYLE);
			rowAttrs.push(rowStyle);
		    }
		} else  if(!matches) {
		    continue;
		}
                line = patternMatch.highlight(line);
                displayedLineCnt++;
                if (displayedLineCnt > maxLines) break;
		let lineAttrs = [TITLE," ",CLASS, " display-raw-line ",RECORD_INDEX,rowIdx]
		if(bubble) line = HU.div([CLASS,"ramadda-bubble"],line);
		if(fromField) line+=HU.div([CLASS,"ramadda-bubble-from"],  ""+row[fromField.getIndex()]);

		if(highlights) {
		    for(var hi=0;hi<highlights.length;hi++) {
			var h = highlights[hi];
			var s = hi<highlightStyles.length?highlightStyles[hi]:highlightStyles[highlightStyles.length-1];
			s = s.replace(/_comma_/g,",");
			line= line.replace(h, "<span style='" + s +"'>$1</span>");
		    }
		}
		line = HU.div(lineAttrs,line);
                if (labelTemplate) {
		    let row = this.getDataValues(record);
		    let label = this.applyRecordTemplate(record, row, templateFields,labelTemplate, templateProps,templateMacros);
		    var num = record.lineNumber;
		    if(!Utils.isDefined(num)) {
			num - lineCnt;
		    }
		    label = label.replace("${lineNumber}", "#" +(num));
		    label = label.replace(/ /g,"&nbsp;");
		    var r =  "";
		    if(this.showShrink) {
			r+= HU.td([WIDTH, "5px",STYLE,HU.css('background','#ccc')],  HU.getIconImage("fa-caret-right",null, [STYLE,"line-height:0px;"]));
		    }
		    r+= HU.td([WIDTH, labelWidth], "<a name=line_" + lineCnt + "></a>" +
				     "<a href=#line_" + lineCnt + ">" + label + "</a>&nbsp;  ") +
			HU.td([], line);
		    corpus += HU.tr(rowAttrs, r);
                } else {
                    corpus += line;
                    if (asHtml) {
                        if (breakLines)
                            corpus += "<p>";
                        else
                            corpus += "<br>";
                    } else {
                        corpus += "\n";
                        if (breakLines)
                            corpus += "\n";
                    }
                }
            }
            if (addLineNumbers) {
                corpus += HU.close(TABLE);
            }
            corpus+= HU.close(DIV);

            if (!asHtml)
                corpus = HU.tag(PRE, [], corpus);
            this.writeHtml(ID_TEXT, corpus);
	    colorBy.displayColorTable();
	    var linesWord = " "+ this.getProperty("linesDescriptor","lines");
	    var label =displayedLineCnt +linesWord;
	    if(this.allRecords.length!=displayedLineCnt) {
		label = displayedLineCnt+"/" + this.allRecords.length+linesWord+" (" + Math.round(displayedLineCnt/this.allRecords.length*100)+"%)";
	    }
	    this.jq(ID_LABEL).html(label);
	    this.jq(ID_SEARCH).focus();
	    if(rowScale) {
		var rows =  this.jq(ID_TEXT).find(".display-raw-row");
		var open = function() {
		    $(this).css("transform","scaleY(1)");		    
		    $(this).css("line-height","1.5");
		    $(this).css("border-bottom","1px solid #ccc");
		    $(this).css("border-top","1px solid #ccc");
		};
		var close = function() {
		    var row = this;
		    if(!$(row).attr("matched")) {	
			$(row).css("transform","scaleY(" + rowScale +")");
			$(row).css("line-height",rowScale);
			$(row).css("border-bottom","0px solid #ccc");
			$(row).css("border-top","0px solid #ccc");
		    }
		}
		rows.each(close);
		rows.mouseenter(open);
		rows.mousemove(open);
		rows.mouseout(close);
	    }
	    let lines =this.jq(ID_TEXT).find(".display-raw-line");
	    lines.click(function() {
		var idx = $(this).attr(RECORD_INDEX);
		var record = _this.indexToRecord[idx];
		if(record) {
		    _this.showRecordPopup($(this),record);
		    _this.propagateEventRecordSelection({record: record});
		    _this.highlightLine(idx);
		}
	    });
	    this.makeTooltips(lines,records);
        },
	highlightLine: function(index) {
	    var container = this.jq(ID_TEXT);
	    container.find(".display-raw-line").removeClass("display-raw-line-selected");
	    var sel = HU.attrSelect(RECORD_INDEX,index);
	    var element =  container.find(sel);
	    element.addClass("display-raw-line-selected");

	},
        handleEventRecordSelection: function(source, args) {
	    var index = this.findMatchingIndex(args.record).index;
	    if(index<0 || !Utils.isDefined(index)) {
		return;
	    }
	    this.highlightLine(index);
	    var container = this.jq(ID_TEXT);
	    var sel = HU.attrSelect(RECORD_INDEX,index);
	    var element =  container.find(sel);
	    var c = container.offset().top;
	    var s = container.scrollTop();
	    var eo = element.offset();
	    var diff = eo.top- c + s;
	    container.scrollTop(diff)
	},
    });
}


function RamaddaTextDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_TEXT, properties);
    let myProps = [
	{label:'Text Display'},
	{p:'recordTemplate',ex:''},
	{p:'showDefault',d:true,ex:"false"},
	{p:'message',d:null,ex:""},
    ];
    if(!properties["recordTemplate"]) {
	properties["recordTemplate"] = "${default}";
    }

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	handleAnnotation: function() {
	    let annotation = null;
	    let template = this.getProperty("template","${date} - ${description}");
	    let  macros = Utils.tokenizeMacros(template);
	    let attrs = {};
	    let date = null;
	    if(this.selectedRecord) {
		annotation = this.annotations.getAnnotationFromDate(date = this.selectedRecord.getDate());
	    }
	    if(!annotation) {
		annotation = this.annotations.getAnnotationFromDate(date=this.getAnimation().getBeginTime());
	    }
	    if(date) {
		attrs.date = date;
	    }  else {
		attrs.date = "";
	    }
	    if(!annotation) {
		this.setContents("");
		return;
	    }
	    attrs.description = annotation.description;
	    attrs.label = annotation.label;
	    if(this.annotations.getShowLegend()) {
		attrs.legend  = this.annotations.getLegend();
	    } else {
		attrs.legend  = "";
	    }
	    let html =  macros.apply(attrs);
	    if(this.getProperty("decorate",true)) {
		html = this.getMessage(html);
	    }
	    this.setContents(html);
	},
	updateUI: function() {
            SUPER.updateUI.call(this);
	    if(this.getProperty("annotations")) {
		let pointData = this.getData();
		if (pointData == null) return;
		if(!this.annotations) {
		    this.annotations  = new Annotations(this,this.filterData());
		} 
		if(this.annotations.isEnabled()) {
		    this.handleAnnotation();
		    return;
		}
	    }
	    if(this.selectedRecord) {
		this.setContents(this.getRecordHtml(this.selectedRecord));
	    } else  if(this.getPropertyShowDefault()) {
		this.recordMap = {};
		let records = this.filterData();
		if(records && records.length>0) {
		    records.forEach((record,idx)=>{
			this.recordMap[record.getId()] = record;
		    });
		    this.selectedRecord =records[0];
		    this.setContents(this.getRecordHtml(records[0]));
		}
	    } else  if(this.getPropertyMessage()) {
		this.setDisplayMessage(this.getPropertyMessage());
	    }
        },
        pointDataLoaded: function(pointData, url, reload) {
	    this.selectedRecord= null;
	    SUPER.pointDataLoaded.call(this, pointData,url,reload);
	},
        handleEventRecordSelection: function(source, args) {
	    if(this.recordMap) {
		if(!this.recordMap[args.record.getId()]) {
		    return;
		}
	    }
	    this.selectedRecord= args.record;
	    this.updateUI();
        }
    });
}




function RamaddaGlossaryDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_GLOSSARY, properties);
    const ID_GLOSSARY_HEADER = "glossary_header";
    let myProps = [
	{label:'Glossary'},
	{p:'wordField',ex:""},
	{p:'definitionField',ex:""},	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let wordField = this.getFieldById(null,this.getProperty("wordField"));
	    let definitionField = this.getFieldById(null,this.getProperty("definitionField"));	    
	    if(!wordField) {
                this.displayError("No word field specified");
                return;
	    }
	    if(!definitionField) {
                this.displayError("No definition field specified");
                return;
	    }	    
	    let letters = {};
	    records.forEach(record=>{
		let word = String(wordField.getValue(record)).trim();
		let definition = definitionField.getValue(record);
		let letter = word.substring(0,1).toUpperCase();
		let list = letters[letter] || (letters[letter] = []);
		list.push({word:word,definition:definition, record:record});
	    });
	    let highlight  = this.getFilterTextMatchers();
	    let header =  HU.div([CLASS,"display-glossary-letter"], "All");
	    let html = "";
	    Object.keys(letters).sort().forEach(letter=>{
		let _letter = letter.trim();
		_letter = _letter==""?"_":_letter;
		let clazz = " display-glossary-letter ";
		if(this.searchLetter == _letter) {
		    clazz+=" display-glossary-letter-highlight ";
		}
		header += HU.div([CLASS,clazz,"letter",_letter], _letter);
		if(this.searchLetter && this.searchLetter!=_letter) return;
		let group =  HU.div([CLASS,"display-glossary-group-header"],  _letter) +
		    HU.openTag(DIV,[CLASS,"display-glossary-group-inner"]);
		letters[letter].sort((a,b)=>{
		    return a.word.localeCompare(b.word);
		}).forEach(info=>{
		    let def = String(info.definition);
		    highlight.forEach(h=>{
			def  = h.highlight(def);
		    });

		    let entry  = HU.div([CLASS,"display-glossary-word"], info.word) + HU.div([CLASS,"display-glossary-definition"], def); 
		    group+=HU.div([TITLE,"",CLASS,"display-glossary-entry",RECORD_ID,info.record.getId()],entry);
		});
		group += HU.closeTag(DIV);
		html+=group;
	    });

	    let height = this.getProperty("glossaryHeight","600px");
	    header = HU.div([ID,this.domId(ID_GLOSSARY_HEADER), CLASS,"display-glossary-header"], header);
	    html = HU.div([STYLE,HU.css("max-height",HU.getDimension(height),"overflow-y","auto")], html);
	    this.setContents(header  + html);
	    let _this = this;
	    this.jq(ID_GLOSSARY_HEADER).find(".display-glossary-letter").click(function() {
		_this.searchLetter =  $(this).attr("letter");
		_this.forceUpdateUI();
	    });
	    this.makeTooltips(this.find(".display-glossary-entry"),records);
	},
    });
}



/**
Copyright 2008-2021 Geode Systems LLC
*/


let DISPLAY_ENTRYLIST = "entrylist";
let DISPLAY_TESTLIST = "testlist";
let DISPLAY_ENTRYDISPLAY = "entrydisplay";
let DISPLAY_ENTRY_GALLERY = "entrygallery";
let DISPLAY_ENTRY_GRID = "entrygrid";
let DISPLAY_OPERANDS = "operands";
let DISPLAY_METADATA = "metadata";
let DISPLAY_ENTRYTIMELINE = "entrytimeline";
let DISPLAY_REPOSITORIES = "repositories";
let DISPLAY_ENTRYTITLE = "entrytitle";
let DISPLAY_SEARCH  = "search";
let DISPLAY_SIMPLESEARCH  = "simplesearch";
let ID_RESULTS = "results";
let ID_SEARCH_FORM = "searchform";
let ID_SEARCH_HEADER = "searchheader";
let ID_SEARCH_BAR = "searchbar";
let ID_SEARCH_TAG = "searchtag";
let ID_SEARCH_TAG_GROUP = "searchtaggroup";
let ID_ENTRIES = "entries";
let ID_DETAILS_INNER = "detailsinner";
let ID_DETAILS_ANCESTORS = "detailsancestors";
let ID_DETAILS_TAGS= "detailstags";
let ID_DETAILS_TYPE= "detailstype";
let ID_PROVIDERS = "providers";
let ID_SEARCH_ORDERBY = "orderby";
let ID_SEARCH_SETTINGS = "searchsettings";
let ID_SEARCH_AREA = "search_area";
let ID_SEARCH_DATE_RANGE = "search_date";
let ID_SEARCH_DATE_CREATE = "search_createdate";
let ID_SEARCH_TAGS = "search_tags";
let ID_SEARCH_ANCESTOR = "search_ancestor";
let ID_TREE_LINK = "treelink";
let ATTR_ENTRYID = "entryid";

let ID_SEARCH = "search";
let ID_FORM = "form";
let ID_TEXT_FIELD = "textfield";
let ID_ANCESTOR = "ancestor";
let ID_ANCESTOR_NAME = "ancestorname";
let ID_TYPE_FIELD = "typefield";
let ID_TYPE_DIV = "typediv";
let ID_TYPEFIELDS = "typefields";
let ID_METADATA_FIELD = "metadatafield";
let ID_COLUMN = "column";

let ID_SEARCH_HIDEFORM = "searchhideform";




addGlobalDisplayType({
    type: DISPLAY_ENTRYLIST,
    label: "Entry List",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
/*
addGlobalDisplayType({
    type: DISPLAY_SEARCH,
    label: "Entry Search",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
*/
/*
addGlobalDisplayType({
    type: DISPLAY_TESTLIST,
    label: "Test  List",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
*/
addGlobalDisplayType({
    type: DISPLAY_ENTRYDISPLAY,
    label: "Entry Display",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRYTITLE,
    label: "Entry Title",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRY_GALLERY,
    label: "Entry Gallery",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRY_GRID,
    label: "Entry Date Grid",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
//addGlobalDisplayType({type: DISPLAY_OPERANDS, label:"Operands",requiresData:false,category:CATEGORY_ENTRIES});
addGlobalDisplayType({
    type: DISPLAY_METADATA,
    label: "Metadata Table",
    requiresData: false,
    category: CATEGORY_ENTRIES
});



function RamaddaEntryDisplay(displayManager, id, type, properties) {
    const  SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    RamaddaUtil.inherit(this, SUPER);
    this.defineProperties([
	{label:'Entry Search'},
	{p:'providers',ex:'this,category:.*',tt:'List of search providers'},
    ]);

    this.ramaddas = new Array();
    let repos = this.getProperty("repositories", this.getProperty("repos", null));
    if (repos != null) {
        let toks = repos.split(",");
        //OpenSearch;http://adasd..asdasdas.dasdas.,
        for (let i = 0; i < toks.length; i++) {
            let tok = toks[i];
            tok = tok.trim();
            this.ramaddas.push(getRamadda(tok));
        }
        if (this.ramaddas.length > 0) {
            let container = new RepositoryContainer("all", "All entries");
            addRepository(container);
            for (let i = 0; i < this.ramaddas.length; i++) {
                container.addRepository(this.ramaddas[i]);
            }
            this.ramaddas.push(container);
            this.setOriginalRamadda(this.ramaddas[0]);
            this.setRamadda(this.ramaddas[0]);
        }
    }


    RamaddaUtil.defineMembers(this, {
        searchSettings: new EntrySearchSettings({
            parent: properties.searchEntryParent || properties.entryParent,
            provider: properties.provider,
            text: properties.searchEntryText || properties.entryText,
            entryType: properties.searchEntryType,
            orderBy: properties.orderBy,
	    ancestor: properties.searchAncestor || properties.ancestor ,
        }),
        entryList: properties.entryList,
        entryMap: {},
	writeEntries: function(msg, entries) {
	    this.jq(ID_ENTRIES).html(msg);
	},
	writeMessage:function( msg)  {
	    this.jq(ID_RESULTS).html(msg);
	},
	writeResults: function(msg) {
	    this.jq(ID_RESULTS).html(msg);
	},
        getSearchSettings: function() {
            if (this.getPropertyProviders() != null) {
                let provider = this.searchSettings.provider;
		let select = this.jq(ID_PROVIDERS);
                let fromSelect = select.val();
                if (fromSelect != null) {
                    provider = fromSelect;
                } else {
		    this.getPropertyProviders().forEach(p=>{
			provider = p.id;
                    });
                }
		let ramadda=this.getRamadda();
		let ok = true;
		if(ramadda && ramadda.getId() == provider) {
		    ok = false;
		}
		if(ok) {
                    this.searchSettings.provider = provider;
		} else {
                    this.searchSettings.provider = null;
		}
            }
            return this.searchSettings;
        },
        getEntries: function() {
            if (this.entryList == null) return [];
            return this.entryList.getEntries();
        },
	getEntriesMetadata:function(entries) {
	                let mdtsFromEntries = [];
            let mdtmap = {};
            let tmp = {};
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let metadata = entry.getMetadata();
                for (let j = 0; j < metadata.length; j++) {
                    let m = metadata[j];
                    if (tmp[m.type] == null) {
                        tmp[m.type] = "";
                        mdtsFromEntries.push(m.type);
                    }
                    mdtmap[metadata[j].type] = metadata[j].label;
                }
            }

            let html = "";
            html += HU.openTag(TAG_TABLE, ["id", this.getDomId("table"), ATTR_CLASS, "cell-border stripe ramadda-table", ATTR_WIDTH, "100%", "cellpadding", "5", "cellspacing", "0"]);
            html += "<thead>"
            let type = this.findEntryType(this.searchSettings.entryType);
            let typeName = "Entry";
            if (type != null) {
                typeName = type.getLabel();
            }
	    this.writeMessage(this.getResultsHeader(entries));
            let mdts = null;
            //Get the metadata types to show from either a property or
            //gather them from all of the entries
            // e.g., "project_pi,project_person,project_funding"
            let prop = this.getProperty("metadataTypes", null);
            if (prop != null) {
                mdts = prop.split(",");
            } else {
                mdts = mdtsFromEntries;
                mdts.sort();
            }

            let skip = {
                "content.pagestyle": true,
                "content.pagetemplate": true,
                "content.sort": true,
                "spatial.polygon": true,
            };
            let headerItems = [];
            headerItems.push(HU.th([], HU.b(typeName)));
            for (let i = 0; i < mdts.length; i++) {
                let type = mdts[i];
                if (skip[type]) {
                    continue;
                }
                let label = mdtmap[mdts[i]];
                if (label == null) label = mdts[i];
                headerItems.push(HU.th([], HU.b(label)));
            }
            let headerRow = HU.tr(["valign", "bottom"], HU.join(headerItems, ""));
            html += headerRow;
            html += "</thead><tbody>"
            let divider = "<div class=display-metadata-divider></div>";
            let missing = this.missingMessage;
            if (missing = null) missing = "&nbsp;";
            for (let entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                let entry = entries[entryIdx];
                let metadata = entry.getMetadata();
                let row = [];
                let buttonId = this.getDomId("entrylink" + entry.getIdForDom());
                let link = entry.getLink(entry.getIconImage() + " " + entry.getName());
                row.push(HU.td([], HU.div([ATTR_CLASS, "display-metadata-entrylink"], link)));
                for (let mdtIdx = 0; mdtIdx < mdts.length; mdtIdx++) {
                    let mdt = mdts[mdtIdx];
                    if (skip[mdt]) {
                        continue;
                    }
                    let cell = null;
                    for (let j = 0; j < metadata.length; j++) {
                        let m = metadata[j];
                        if (m.type == mdt) {
                            let item = null;
                            if (m.type == "content.thumbnail" || m.type == "content.logo") {
                                let url = this.getRamadda().getRoot() + "/metadata/view/" + m.value.attr1 + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + m.id;
                                item = HU.image(url, [ATTR_WIDTH, "100"]);
                            } else if (m.type == "content.url" || m.type == "dif.related_url") {
                                let label = m.value.attr2;
                                if (label == null || label == "") {
                                    label = m.value.attr1;
                                }
                                item = HU.href(m.value.attr1, label);
                            } else if (m.type == "content.attachment") {
                                let toks = m.value.attr1.split("_file_");
                                let filename = toks[1];
                                let url = this.getRamadda().getRoot() + "/metadata/view/" + m.value.attr1 + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + m.id;
                                item = HU.href(url, filename);
                            } else {
                                item = m.value.attr1;
                                if (Utils.isDefined(m.value.attr2)) {
				    if(String(m.value.attr2).trim().length > 0) {
					item += " - " + m.value.attr2;
				    }
                                }
                            }
                            if (item != null) {
                                if (cell == null) {
                                    cell = "";
                                } else {
                                    cell += divider;
                                }
                                cell += HU.div([ATTR_CLASS, "display-metadata-item"], item);
                            }

                        }
                    }
                    if (cell == null) {
                        cell = missing;
                    }
                    if (cell == null) {
                        cell = "";
                    }
                    let add = HU.tag(TAG_A, [ATTR_STYLE, "color:#000;", ATTR_HREF, this.getRamadda().getRoot() + "/metadata/addform?entryid=" + entry.getId() + "&metadata_type=" + mdt,
                        "target", "_blank", "alt", "Add metadata", ATTR_TITLE, "Add metadata"
                    ], "+");
                    add = HU.div(["class", "display-metadata-table-add"], add);
                    let cellContents = add + divider;
                    if (cell.length > 0) {
                        cellContents += cell;
                    }
                    row.push(HU.td([], HU.div([ATTR_CLASS, "display-metadata-table-cell-contents"], cellContents)));
                }
                html += HU.tr(["valign", "top"], HU.join(row, ""));
                //Add in the header every 10 rows
                if (((entryIdx + 1) % 10) == 0) html += headerRow;
            }
            html += "</tbody>"
            html += HU.closeTag(TAG_TABLE);
	    return html;
	},

        getEntriesGallery: function(entries) {
            let nonImageHtml = "";
            let html = "";
            let imageCnt = 0;
            let imageEntries = [];
	    for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                //Don: Right now this just shows all of the images one after the other.
                //If there is just one image we should just display it
                //We should do a gallery here if more than 1

                if (entry.isImage()) {
                    imageEntries.push(entry);
                    let link = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], entry.getName());
                    imageCnt++;
		    let imageUrl =entry.getImageUrl();
                    html += HU.tag(TAG_IMG, ["src", imageUrl, ATTR_WIDTH, "500", ATTR_ID,
                            this.getDomId("entry_" + entry.getIdForDom()),
                            ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
                        ]) + "<br>" +
                        link + "<p>";
                } else {
                    let icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
                    let link = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], icon + " " + entry.getName());
                    nonImageHtml += link + "<br>";
                }
            }

            if (imageCnt > 1) {
                //Show a  gallery instead
		this.galleryId = HU.getUniqueId("gallery_");
                let newHtml = HU.open("div",[ID, this.galleryId,CLASS,"ramadda-grid"]);
		let itemWidth = this.getProperty("galleryItemWidth","200px");
                for (let i = 0; i < imageEntries.length; i++) {
                    let entry = imageEntries[i];
		    let attrs = ["width",itemWidth];
                    newHtml += HU.open("div",[CLASS,"display-entrygallery-item",STYLE,HU.css(attrs)]);
                    let link = HU.tag(TAG_A, ["target","_entries",ATTR_HREF, entry.getEntryUrl()], entry.getName());
		    link = link.replace(/"/g,"'");
		    let imageUrl =entry.getImageUrl();
                    let img = HU.image(imageUrl, ["loading","lazy", ATTR_WIDTH, "100%", ATTR_ID,
						  this.getDomId("entry_" + entry.getIdForDom()),
						  ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
						 ]);
                    img = HU.href(entry.getResourceUrl(), img, ["data-fancybox",this.galleryId, "data-caption",link, CLASS, "popup_image"]);
                    newHtml += HU.div([CLASS, "image-outer"], HU.div(["class", "image-inner"], img) +
                        HU.div(["class", "image-caption"], link));

                    newHtml += HU.close("div");
                }
                newHtml += HU.close("div");
                html = newHtml;
            }


            //append the links to the non image entries
            if (nonImageHtml != "") {
                if (imageCnt > 0) {
                    html += "<hr>";
                }
                html += HU.div([STYLE,HU.css("margin","10px")],nonImageHtml);
            }
            return html;
        }
    });
    if (properties.searchEntryType != null) {
        this.searchSettings.addType(properties.searchEntryType);
    }
}






function RamaddaSearcherDisplay(displayManager, id,  type, properties) {
    let NONE = "-- None --";
    let myProps = [
	{label:'Search'},
        {p:'showForm',d: true},
        {p:'formOpen',d: true},	
        {p:'showOrderBy',d:true,ex: 'true'},
        {p:'orderBy',ex: 'name_ascending|name_descending|fromdate_ascending|fromdate_descending|todate_|createdate_|size_'},
        {p:'orientation',ex:'horizontal|vertical',d:'horizontal'},
        {p:'showSearchSettings',d: true},
        {p:'showToggle',d: false},
	{p:'formHeight',d:'400px'},
        {p:'entriesHeight',d:'400px'},	
        {p:'showEntries',d: true},
        {p:'showFooter',d: true},	
        {p:'showType',d: true},
        {p:'entryTypes',ex:'comma separated list of types'},
	{p:'ancestor',ex:'this',tt:'Constrain search to this tree'},		
        {p:'doSearch',d: true,tt:'Apply search at initial display'},
	{p:'searchHeaderLabel',d: 'Search'},
	{p:'searchOpen',d: true},
        {p:'showAncestor',d: true},
	{p:'showEntryBreadcrumbs',ex:'false'},
	{p:'showSnippetInList',ex:'true'},
        {p:'showDate',d: true},
        {p:'showCreateDate',ex:'true',d: false},	
        {p:'showArea',d: true},
        {p:'showText',d: true},
	{p:'textRequired',d:false},
        {p:'searchText',d: '',tt:'Initial search text'},
	{p:'searchPrefix',ex:'name:, contents:, path:'},
        {p:'showMetadata',d: true},
	{p:'metadataTypes', d:'enum_tag:Tag,content.keyword:Keyword,thredds.variable:Variable'},
        {p:'showTags',d: true},	
	{p:'tagPopupLimit',d: 25,tt:'When do we show the tag popup' },		
	{p:'showSearchLabels',d:true},
	{p:'comparators',d:'<=,>=,=,between',tt:'comparators for numeric search'},
	{p:'searchDirect',d:true,tt:'Directly search remote RAMADDA repositories'},
        {p:'fields',d: null},
        {p:'formWidth',d: '300px'},
        {p:'entriesWidth',d: 0},
	{p:'displayTypes',ex:'list,images,timeline,map,metadata'},
	{p:'defaultImage',ex:'blank.gif'},
        {p:'showDetailsForGroup',d: false},
	{p:'doWorkbench',d:false,ex:'true', tt:'Show the new, charts, etc links'},
	];

    const SUPER = new RamaddaEntryDisplay(displayManager, id, type, properties);

    defineDisplay(this, SUPER, myProps, {
        metadataTypeList: [],
	haveSearched: false,
        haveTypes: false,
        metadata: {},
        metadataLoading: {},
	ctor: function() {
	    if (this.getShowMetadata() && this.getShowSearchSettings()) {
		let metadataTypesAttr = this.getMetadataTypes();
		//look for type:value:label, or type:label,
		let toks = metadataTypesAttr.split(",");
		for (let i = 0; i < toks.length; i++) {
		    let type = toks[i];
		    let label = type;
		    let value = null;
		    let subToks = type.split(":");
		    if (subToks.length > 1) {
			type = subToks[0];
			if (subToks.length >= 3) {
			    value = subToks[1];
			    label = subToks[2];
			} else {
			    label = subToks[1];
			}
		    }
		    this.metadataTypeList.push(new MetadataType(type, label, value));
		}
	    }
	},
        getLoadingMessage: function(msg) {
	    if(!msg) return "";
	    return msg;
	},
        isLayoutHorizontal: function() {
	    return this.getOrientation()== "horizontal";
        },

	initHtml: function() {
	    this.jq(ID_ANCESTOR).click((event) =>{
		let aid = this.domId(ID_ANCESTOR);
		let root = this.getRamadda().getRoot();
		selectInitialClick(event,aid,aid,true,null,null,'',root);
	    });


	    this.jq(ID_SEARCH_HIDEFORM).click(()=>{
		this.formShown  = !this.formShown;
		if(this.formShown)
		    this.jq(ID_SEARCH_FORM).show();
		else
		    this.jq(ID_SEARCH_FORM).hide();
	    });
	    if(this.areaWidget) this.areaWidget.initHtml();
	    if(this.getShowOrderBy()) {
		let settings = this.getSearchSettings();
		let byList = [["Relevant","relevant"], ["A-Z","name_ascending"],["Z-A","name_descending"],
			  ["Create date - newest first","createdate_descending"],
			  ["Create date - oldest first","createdate_ascending"],
			  ["From date - youngest first","fromdate_descending"],			  			  
			  ["From date - oldest first","fromdate_ascending"],
			  ["Size - largest first","size_descending"],
			  ["Size - smallest first","size_ascending"]];			  
		let options = "";
		byList.forEach(tuple=>{
		    let label = tuple[0];
		    let by = tuple[1];
		    let extra = settings.orderBy==by?" selected ":""
		    options += "<option title='" + label+"'  " + "" + extra + " value=\"" + by + "\">" + label + "</option>\n";
		    
		});
		let select = HU.tag("select", ["id", this.getDomId(ID_SEARCH_ORDERBY), ATTR_CLASS, "display-search-orderby"], options);
		this.jq(ID_SEARCH_HEADER).append(select);
	    }
            this.addExtraForm();
	},
        getDefaultHtml: function() {
            let html = "";
            let horizontal = this.isLayoutHorizontal();
            let footer = this.getFooter();
            if (!this.getShowFooter(true)) {
                footer = "";
            }
	    this.jq(ID_BOTTOM).html(footer);
	    footer = "";
            let entriesDivAttrs = [ATTR_ID, this.getDomId(ID_ENTRIES), ATTR_CLASS, this.getClass("content")];
            let innerHeight = this.getProperty("innerHeight", null);
            let entriesStyle = this.getProperty("entriesStyle", "");	    
	    let style = "";
            if (innerHeight == null) {
                innerHeight = this.getEntriesHeight();
            }
            if (innerHeight != null) {
                style = "margin: 0px; padding: 0px;  xmin-height:" + HU.getDimension(innerHeight) + "; max-height:" + HU.getDimension(innerHeight) + "; overflow-y: auto;";
            }
	    style+= entriesStyle;
            entriesDivAttrs.push(ATTR_STYLE);
            entriesDivAttrs.push(style);	    
	    let searchBar = HU.div([CLASS,horizontal?"display-search-bar":"display-search-bar-vertical",ID, this.domId(ID_SEARCH_BAR)],"");
            let resultsDiv = "";
            if (this.getProperty("showHeader", true)) {
                resultsDiv = HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)], "&nbsp;");
            }
	    resultsDiv = HU.leftRightTable(resultsDiv,HU.div([CLASS,"display-search-header", ID,this.domId(ID_SEARCH_HEADER)]),null,null,{valign:"bottom"});
	    let toggle = "";
	    if(horizontal && this.getShowForm()) {
		toggle = HU.div([TITLE, "Toggle form", ID,this.domId(ID_SEARCH_HIDEFORM), CLASS,"ramadda-clickable",STYLE,HU.css("position","absolute","left","0px","top","0px")],
				HU.getIconImage("fas fa-bars"));
	    }
            let entriesDiv = HU.div([STYLE,HU.css("position","relative")],
				    toggle +
				    searchBar +
				    resultsDiv +
				    HU.div(entriesDivAttrs, this.getLoadingMessage()));

            if (horizontal) {
		html += HU.open("table",["width","100%","border",0]);
		html+="<tr valign=top>";
                let entriesAttrs = ["class", "col-md-12"];
                if (this.getShowForm()) {
                    let attrs = [];
		    let form = HU.div([STYLE,HU.css("min-height","400px","max-width",HU.getDimension(this.getFormWidth()),"overflow-x","auto")],this.makeSearchForm());
		    html += HU.tag("td", [ID,this.getDomId(ID_SEARCH_FORM),"width","1%"], form);
		    this.formShown  = true;
                }
                if (this.getShowEntries()) {
                    let attrs = [];
                    if (this.getEntriesWidth() === "") {
                        attrs = [];
                    } else if (this.getEntriesWidth() != 0) {
                        attrs = [ATTR_WIDTH, this.getEntriesWidth()];
                    }
                    html += HU.tag("td",[], entriesDiv);		    
                }
                html += HU.closeTag("tr");
                html += HU.closeTag("table");

                html += HU.openTag(TAG_DIV, ["class", "row"]);
                if (this.getShowForm()) {
                    html += HU.tag(TAG_DIV, ["class", "col-md-6"], "");
                }
                if (this.getShowEntries()) {
                    if (this.getShowFooter(true)) {
                        html += HU.tag(TAG_DIV, ["class", "col-md-6"], footer);
                    }
                }
                html += HU.closeTag(TAG_DIV);
            } else {
                if (this.getShowForm()) {
                    html += this.makeSearchForm();
                }
                if (this.getShowEntries()) {
                    html += entriesDiv;
                    html += footer;
                }
            }
            html += HU.div([ATTR_CLASS, "display-entry-popup", ATTR_ID, this.getDomId(ID_DETAILS)], "&nbsp;");
            return html;
        },
        initDisplay: function() {
            let theDisplay = this;

            this.jq(ID_SEARCH).click(function(event) {
               theDisplay.submitSearchForm();
                event.preventDefault();
            });

            this.jq(ID_TEXT_FIELD).autocomplete({
                source: function(request, callback) {
                    //                            theDisplay.doQuickEntrySearch(request, callback);
                }
            });

	    //Don't selectbox the orderby
//	    this.selectboxit(this.jq(ID_SEARCH_ORDERBY));
	    this.jq(ID_SEARCH_ORDERBY).change(()=>{	    
                this.submitSearchForm();
	    });
            this.selectboxit(this.jq(ID_REPOSITORY));
            this.jq(ID_REPOSITORY).change(function() {
                let v = theDisplay.jq(ID_REPOSITORY).val();
                let ramadda = getRamadda(v);
                theDisplay.setRamadda(ramadda);
                theDisplay.addTypes(null);
                theDisplay.typeChanged();
            });

            this.jq(ID_FORM).submit(function(event) {
                theDisplay.submitSearchForm();
                event.preventDefault();
            });


            this.addTypes(this.entryTypes);
	    this.initMetadata();
            if (!this.haveSearched) {
                if (this.getDoSearch()) {
                    this.submitSearchForm();
                }
            }
        },
        showEntryDetails: async function(event, entryId, src, leftAlign) {
            if (true) return;
            let entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            let popupId = "#" + this.getDomId(ID_DETAILS + entryId);
            if (this.currentPopupEntry == entry) {
                this.hideEntryDetails(entryId);
                return;
            }
            let myloc = 'right top';
            let atloc = 'right bottom';
            if (leftAlign) {
                myloc = 'left top';
                atloc = 'left bottom';
            }
            this.currentPopupEntry = entry;
            if (src == null) src = this.getDomId("entry_" + entry.getIdForDom());
            let closeImage = HU.getIconImage(icon_close, []);
            let close = HU.onClick(this.getGet() + ".hideEntryDetails('" + entryId + "');",closeImage);

            let contents = this.getEntryHtml(entry, {
                headerRight: close
            });
            $(popupId).html(contents);
            $(popupId).show();
            /*
            $(popupId).position({
                    of: jQuery( "#" +src),
                        my: myloc,
                        at: atloc,
                        collision: "none none"
                        });
            */
        },

	getCloser: function() {
	    if(true) return "";
	    return  HU.jsLink("",HU.getIconImage(icon_close, [ID,this.domId("close"),STYLE,HU.css("cursor","pointer")]));
	},
	initCloser: function(what) {
	    this.jq("close").click(()=>{
		this.jq(what||ID_RESULTS).hide();
	    });
	},
        getResultsHeader: function(entries, includeCloser) {
            let settings = this.getSearchSettings();
	    //Always show the next/prev because the results might be < max even though there
	    //are more on the repository because some results might be hidden due to access control
//            if (entries.length < DEFAULT_MAX) return entries.length+" result" +(entries.length>1?"s":"");
            let left = "Showing " + (settings.skip + 1) + "-" + (settings.skip + Math.min(settings.max, entries.length));
	    if(entries.length==0) left = SPACE3+SPACE3+SPACE3;
            let nextPrev = [];
            let lessMore = [];
            if (settings.skip > 0) {
                nextPrev.push(HU.onClick(this.getGet() + ".loadPrevUrl();", HU.getIconImage("fa-arrow-left", [ATTR_TITLE, "Previous"]), [ATTR_CLASS, "display-link"]));
            }
            let addMore = false;
            if (entries.length>0 &&(true || entries.length == settings.getMax())) {
                nextPrev.push(HU.onClick(this.getGet() + ".loadNextUrl();", HU.getIconImage("fa-arrow-right", [ATTR_TITLE, "Next"]), [ATTR_CLASS, "display-link"]));
                addMore = true;
            }

	    if(entries.length>0) {
		lessMore.push(HU.onClick(this.getGet() + ".loadLess();", HU.getIconImage("fa-minus", [ATTR_TITLE, "View less"]), [ATTR_CLASS, "display-link"]));
		if (addMore) {
                    lessMore.push(HU.onClick(this.getGet() + ".loadMore();", HU.getIconImage("fa-plus", [ATTR_TITLE, "View more"]), [ATTR_CLASS, "display-link"]));
		}
	    }
            let results = "";
            let spacer = "&nbsp;&nbsp;&nbsp;"
	    if(includeCloser)
		results = this.getCloser();
	    results += "&nbsp;" + left + spacer;
            results += 
                HU.join(nextPrev, "&nbsp;") + spacer +
                HU.join(lessMore, "&nbsp;");
            return results+"<br>";
        },
	makeSearchSettings: function() {
	                let settings = this.getSearchSettings();
            settings.text = this.getFieldValue(this.getDomId(ID_TEXT_FIELD), settings.text);
	    if(settings.text) {
		HU.addToDocumentUrl(ID_TEXT_FIELD,settings.text);
		if(settings.text.trim()!="") {
		    if(this.getSearchPrefix())
			settings.text = this.getSearchPrefix()+ settings.text;
		}
	    }  else {
		HU.addToDocumentUrl(ID_TEXT_FIELD,"");
	    }

	    settings.ancestor = this.getAncestor();
	    let orderBy = this.jq(ID_SEARCH_ORDERBY).val();
	    if(orderBy) {
		let ascending = orderBy.indexOf("_ascending")>=0;
		if(orderBy=="relevant") ascending=false;
		orderBy = orderBy.replace("_ascending","").replace("_descending","");
		settings.orderBy =  orderBy;
		settings.ascending = ascending;
	    }


            if (this.haveTypes) {
                settings.entryType = this.getFieldValue(this.getDomId(ID_TYPE_FIELD), settings.entryType);
		if(settings.entryType) {
		    HU.addToDocumentUrl(ID_TYPE_FIELD,settings.entryType);
		} else {
		    HU.addToDocumentUrl(ID_TYPE_FIELD,"");
		}
            } else if(this.typeList && this.typeList.length==1) {
		settings.entryType = this.typeList[0];
	    }
            settings.clearAndAddType(settings.entryType);
	    let ancestor = this.jq(ID_ANCESTOR+"_hidden").val();
	    if(Utils.stringDefined(ancestor)) {
		settings.ancestor = ancestor;
		HU.addToDocumentUrl(ID_ANCESTOR,ancestor);
		let name = this.jq(ID_ANCESTOR).val();
		if(name)
		    HU.addToDocumentUrl(ID_ANCESTOR_NAME,name);		    
	    } else {
		//delete it
		HU.addToDocumentUrl(ID_ANCESTOR,null);
		HU.addToDocumentUrl(ID_ANCESTOR_NAME,null);		
	    }
            if (this.areaWidget) {
                this.areaWidget.setSearchSettings(settings);
            }
            if (this.dateRangeWidget) {
                this.dateRangeWidget.setSearchSettings(settings);
            }
            if (this.createdateRangeWidget) {
                this.createdateRangeWidget.setSearchSettings(settings);
            }	    
	    
            settings.metadata = [];
	    if(!this.getShowTags()) {
		for (let i = 0; i < this.metadataTypeList.length; i++) {
                    let metadataType = this.metadataTypeList[i];
                    let value = metadataType.getValue();
                    if (value == null) {
			value = this.getFieldValues(this.getMetadataFieldId(metadataType), null);
                    }
                    if (value != null) {
			if(!Array.isArray(value)) {value=[value]}
			value.forEach(v=>{
			    settings.metadata.push({
				type: metadataType.getType(),
				value: v
			    });
			});
                    }
		}
	    } else {
		let _this = this;
		this.jq(ID_SEARCH_BAR).find(".display-search-tag").each(function() {
		    let type  = $(this).attr("metadata-type");
		    let value  = $(this).attr("metadata-value");			
		    if(!type) return;
		    settings.metadata.push({
			type: type,
			value: value
		    });
		});
            }
	    return settings;
	},
        submitSearchForm: function() {
            if (this.fixedEntries) {
                return;
            }
            this.haveSearched = true;
	    let settings  =this.makeSearchSettings();

            if (this.getTextRequired() && (settings.text == null || settings.text.trim().length == 0)) {
                this.writeEntries("");
                return;
            }

            //Call this now because it sets settings
            let theRepository = this.getRamadda()

	    this.writeMessage(this.getWaitImage() + " " +"Searching...");
            if (theRepository.children) {
                this.entryList = new EntryListHolder(theRepository, this);
                this.multiSearch = {
                    count: 0,
                };

                for (let i = 0; i < theRepository.children.length; i++) {
                    let ramadda = theRepository.children[i];
                    let jsonUrl = this.makeSearchUrl(ramadda);
                    this.updateForSearching(jsonUrl);
                    this.entryList.addEntryList(new EntryList(ramadda, jsonUrl, null, false));
                    this.multiSearch.count++;
                }
                this.entryList.doSearch(this);
            } else {
                this.multiSearch = null;
                let jsonUrl = this.makeSearchUrl(this.getRamadda());
                this.handleLog(jsonUrl);
                this.entryList = new EntryList(this.getRamadda(), jsonUrl, this, true);
                this.updateForSearching(jsonUrl);
            }
        },
        entryListChanged:function(entryList) {
	},
        handleSearchError: function(url, msg) {
            this.writeEntries("");
            this.writeMessage("Error performing search:" + msg);
            console.log("Error performing search:" + msg);
            //alert("There was an error performing the search\n" + msg);
        },
        updateForSearching: function(jsonUrl) {
            let outputs = this.getRamadda().getSearchLinks(this.getSearchSettings());
            this.footerRight = outputs == null ? "" : "Links: " + HU.join(outputs, " - ");
            this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
            let msg = this.searchMessage;
            if (msg == null) {
                msg = this.getRamadda().getSearchMessage();
            }
            let provider = this.getSearchSettings().provider;
            if (provider != null) {
                msg = null;
                if (this.providerMap != null && this.providerMap[provider]) {
                    msg = this.providerMap[provider].name;
                }
                if (msg == null) {
                    msg = provider;
                }
                msg = "Searching " + msg;
            }
            this.hideEntryDetails();
        },
        prepareToLayout: function() {
            SUPER.prepareToLayout.apply(this);
            this.savedValues = {};
            let cols = this.getSearchableColumns();
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                let id = this.getDomId(ID_COLUMN + col.getName());
                let value = $("#" + id).val();
                if (value == null || value.length == 0) continue;
                this.savedValues[id] = value;
            }
        },
        makeSearchUrl: function(repository) {
            let extra = "";
            let cols = this.getSearchableColumns();
	    let searchBar  = this.jq(ID_SEARCH_BAR);
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                if (!col.getCanSearch()) continue;
		let id  = ID_COLUMN + col.getName();
		let arg = col.getSearchArg();
		let tag = searchBar.find(HU.attrSelect("column",col.getName()));
		if(col.isNumeric()) {
                    let expr = this.jq(id+"_expr").val();
                    let from = this.jq(id+"_from").val();
                    let to = this.jq(id+"_to").val();		    		    
		    if(Utils.stringDefined(from) || Utils.stringDefined(to)) {
			let label =  (Utils.stringDefined(from)?(from+" &lt; "):"") +  col.getLabel() + (Utils.stringDefined(to)?(" &lt; " +to):"");
			if(tag.length==0) {
			    tag = $(HU.div([CLASS,"display-search-tag","column",col.getName()],label)).appendTo(searchBar);
			    tag.click(()=>{
				this.jq(id+"_from").val("");
				this.jq(id+"_to").val("");		    		    
				this.submitSearchForm();
			    });
			} else {
			    tag.html(label);
			}
//			extra += "&" + arg  +"_expr" +  "=" + encodeURIComponent(expr);
			if(Utils.stringDefined(from))
			    extra += "&" + arg  +"_from" +  "=" + encodeURIComponent(from);
			if(Utils.stringDefined(to))
			    extra += "&" + arg  +"_to" +  "=" + encodeURIComponent(to);						
//			console.log("expr:" +expr +" from:" + from +" to:" + to);
		    } else {
			tag.remove();
		    }
		} else {
                    let value = this.jq(id).val();
                    if (value == null || value==VALUE_NONE) {
			tag.remove();
			continue;
		    }
		    if(col.getType()=="string") {
			if(value=="") {
			    tag.remove();
			    continue;
			}
		    }

		    let label = col.getLabel() +"=" + value;
		    if(tag.length==0) {
			tag = $(HU.div([CLASS,"display-search-tag","column",col.getName()],label)).appendTo(searchBar);
			tag.click(()=>{
			    this.jq(id).data("selectBox-selectBoxIt").selectOption(VALUE_NONE);
			    this.submitSearchForm();
			});
		    } else {
			tag.html(label);
		    }
                    extra += "&" + arg + "=" + encodeURIComponent(value);
		}
            }
            this.getSearchSettings().setExtra(extra);
            let jsonUrl = repository.getSearchUrl(this.getSearchSettings(), OUTPUT_JSON);
            return jsonUrl;
        },
        makeSearchForm: function() {
            let form = HU.openTag("form", [ATTR_ID, this.getDomId(ID_FORM), "action", "#"]);

            let buttonLabel = HU.getIconImage("fa-search", [ATTR_TITLE, "Search"]);
            let topItems = [];
            let searchButton = HU.div([ATTR_ID, this.getDomId(ID_SEARCH), ATTR_CLASS, "display-search-button ramadda-clickable"], buttonLabel);
            let extra = "";
            let settings = this.getSearchSettings();
	    let addWidget = (label, widget)=>{
		if(horizontal) 
		    return HU.div([CLASS,"display-search-label"], label) + 
		    HU.div([CLASS,"display-search-widget"], widget);
		return HU.formEntry("",widget);
	    };

            let horizontal = this.isLayoutHorizontal();

            if (this.ramaddas.length > 0) {
                let repositoriesSelect = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_REPOSITORY), ATTR_CLASS, "display-repositories-select"]);
                let icon = ramaddaCdn + "/icons/favicon.png";
                for (let i = 0; i < this.ramaddas.length; i++) {
                    let ramadda = this.ramaddas[i];
                    let attrs = [ATTR_TITLE, "", ATTR_VALUE, ramadda.getId(),
                        "data-iconurl", icon
                    ];
                    if (this.getRamadda().getId() == ramadda.getId()) {
                        attrs.push("selected");
                        attrs.push(null);
                    }
                    let label =
                        repositoriesSelect += HU.tag(TAG_OPTION, attrs,
                            ramadda.getName());
                }
                repositoriesSelect += HU.closeTag(TAG_SELECT);
                topItems.push(repositoriesSelect);
            }


            this.providerMap = {};
            if (this.getPropertyProviders() != null) {
		if(this.getPropertyProviders().length==1) {
		    this.provider = this.getPropertyProviders()[0].id;

		} else {
                    let options = "";
		    let selected = HU.getUrlArgument(ID_PROVIDERS);
                    let currentCategory = null;
                    let catToBuff = {};
                    let cats = [];
		    this.getPropertyProviders().forEach(provider=>{
			this.providerMap[provider.id] = provider;
			let id = provider.id;
			if(!Utils.isDefined(selected)) {
			    selected = id;
			}
			let label = provider.name;
			if (label.length > 40) {
                            label = label.substring(0, 39) + "...";
			}
			let extraAttrs = "";
			if (id == selected) {
                            extraAttrs += " selected ";
			}
			let category = provider.category||"";
			let buff = catToBuff[category];
			if (buff == null) {
                            cats.push(category);
                            catToBuff[category] = "";
                            buff = "";
			}
			let img = provider.icon;
			if(img) {
                            img = img.replace(/\${urlroot}/g, ramaddaBaseUrl);
                            img = img.replace(/\${root}/g, ramaddaBaseUrl);
                            extraAttrs += " data-iconurl=\"" + img + "\" ";
			}
			buff += "<option  title='" + label+"' class=display-search-provider " + extraAttrs + " value=\"" + id + "\">" + label + "</option>\n";
			catToBuff[category] = buff;
		    });

		    if(cats.length==1) {
			options += catToBuff[cats[0]];
		    } else {
			for (let catIdx = 0; catIdx < cats.length; catIdx++) {
			    let category = cats[catIdx];
			    if (category != "")
				options += "<optgroup label=\"" + category + "\">\n";
			    options += catToBuff[category];
			    if (category != "")
				options += "</optgroup>";
			}
		    }
		    let providersSelect = HU.tag("select", [STYLE,HU.css(),"multiple", null, "id", this.getDomId(ID_PROVIDERS), ATTR_CLASS, "display-search-providers"], options);
                    topItems.push(providersSelect);
		}
	    }


	    this.typeList = null;
            if (this.getEntryTypes()) {
		this.typeList = this.getEntryTypes().split(",");
	    }
            if (this.getShowType()) {
		if(this.typeList == null || this.typeList.length==0) {
                    topItems.push(HU.div([STYLE,HU.css("margin-bottom","4px"),ATTR_ID, this.getDomId(ID_TYPE_DIV)], HU.span([ATTR_CLASS, "display-loading"], "Loading types...")));
		} else {
		    extra+= HU.div([STYLE,HU.css("margin-bottom","4px"),ATTR_ID, this.getDomId(ID_TYPE_DIV)]);
		}
            }



	    let text  = this.getFormText();
	    if(!text || text=="")
		text = HU.getUrlArgument(ID_TEXT_FIELD);
	    let attrs  = ["placeholder", this.getEgText("Search text"), TITLE,"e.g. name:, contents:,path:", ATTR_CLASS, "display-simplesearch-input",  ATTR_ID, this.domId(ID_TEXT_FIELD)];
	    if(this.getProperty("inputSize")) {
		attrs.push(ATTR_SIZE);
		attrs.push(this.getProperty("inputSize", "30"));
	    } else {
		attrs.push(STYLE);
		attrs.push(HU.css("width","100%","min-width","200px","max-width","300px"));
	    }
            let textField = HU.input("", text, attrs);

            if (this.getShowText()) {
		topItems.push(textField);
            }

	    let contents = "";
	    let topContents = "";	    
	    if(topItems.length>0) {
		if (horizontal) {
                    form += "<table><tr valign=top><td>" + searchButton + "</td><td>" + topItems[0] + "</td></tr></table>";
		    topContents +=  HU.join(topItems.slice(1), "");
		} else {
//                    form += "<table width=100%><tr valign=top><td width=1>" + searchButton + "</td><td>" + topItems[0] + "</td></tr></table>";
		    topItems = Utils.mergeLists([searchButton], topItems);
		    topItems = topItems.map(item=>{return HU.div([STYLE,HU.css("margin-right","8px")], item);});

		    form+=   HU.hrow(...topItems);
		}
	    }
		

	    if(!horizontal)  {
		extra += HU.formTable();
	    }

	    if(this.getShowAncestor() && ramaddaTreeSearchEnabled===true) {
		let ancestor = HU.getUrlArgument(ID_ANCESTOR);
		let name = HU.getUrlArgument(ID_ANCESTOR_NAME);		
		let aid = this.domId(ID_ANCESTOR);
		let selectClick = "selectInitialClick(event," + HU.squote(aid)+"," +HU.squote(aid) +",'true',null,null,'');";
		let clear = HU.href("javascript:void(0);",HU.getIconImage("fas fa-eraser"), ['onClick',"clearSelect(" + HU.squote(aid) +");",TITLE,"Clear selection"]);
		let input = HU.input("",name||"",["READONLY",null,'placeholder',' Search under', STYLE,HU.css('cursor','pointer','width','100%'),ID,aid,CLASS,"ramadda-entry-popup-select  disabledinput"]);


		extra += HU.hidden("",ancestor||"",[ID,aid+"_hidden"]);
		extra+=addWidget("",HU.div([ID,this.domId(ID_SEARCH_ANCESTOR)], HU.leftRightTable(clear,input,"5%", "95%")));
	    }

            if (this.getShowDate()) {
                this.dateRangeWidget = new DateRangeWidget(this);
                extra += addWidget("", HU.div([ID,this.domId(ID_SEARCH_DATE_RANGE)], this.dateRangeWidget.getHtml()));
            }
            if (this.getShowCreateDate(true)) {
                this.createdateRangeWidget = new DateRangeWidget(this,"createdate");
                extra += addWidget("", HU.div([ID,this.domId(ID_SEARCH_DATE_CREATE)], this.createdateRangeWidget.getHtml()));
            }
            if (this.getShowArea()) {
                this.areaWidget = new AreaWidget(this);
                extra += addWidget("", HU.div([ID,this.domId(ID_SEARCH_AREA)], this.areaWidget.getHtml()));
            }

            extra += HU.div([ATTR_ID, this.getDomId(ID_TYPEFIELDS)], "");

            if (this.getShowMetadata()) {
		let metadataBlock = "";
                for (let i = 0; i < this.metadataTypeList.length; i++) {
                    let type = this.metadataTypeList[i];
                    let value = type.getValue();
                    let metadataSelect;
                    if (value != null) {
                        metadataSelect = value;
                    } else {
                        metadataSelect = HU.tag(TAG_SELECT, [ATTR_ID, this.getMetadataFieldId(type),
                                ATTR_CLASS, "display-metadatalist"
                            ],
                            HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""],
                                NONE));
                    }
		    if(this.getShowTags()) {
			let block = HU.div([CLASS,"display-search-metadata-block"], HU.div([CLASS,"display-search-metadata-block-inner", ID,this.getMetadataFieldId(type)]));
			let countId = this.getMetadataFieldId(type)+"_count";
			let wrapperId = this.getMetadataFieldId(type)+"_wrapper";			
			let label = type.getLabel()+" " + HU.span([ID,countId]);
			let wrapper = HU.div([ID,wrapperId], HU.toggleBlock(label,block,false,{
			    headerStyle:HU.css("border","1px solid #ccc", "margin-top","6px","background", Utils.getEnumColor(type))}));
			metadataBlock+=wrapper;
		    } else {
			metadataBlock += addWidget(type.getLabel() + ":", metadataSelect);
		    }
                }
		extra += HU.div([ID,this.domId(ID_SEARCH_TAGS)], metadataBlock);
            }
	    if(!horizontal) 
		extra += HU.closeTag(TAG_TABLE);

            if (this.getShowSearchSettings()) {
                let id = this.getDomId(ID_SEARCH_SETTINGS);
                if (this.getShowToggle()) {
                    contents+= HU.div([ATTR_CLASS, "display-search-extra", ATTR_ID, id],
				      HU.toggleBlock("Search Settings", HU.div([ATTR_CLASS, "display-search-extra-inner"], extra), this.getFormOpen(true)));
                } else {
                    contents += HU.div([ATTR_CLASS, "display-search-extra", ATTR_ID, id],
                        HU.div([ATTR_CLASS, "display-search-extra-inner"], extra));
                }
            }

            //Hide the real submit button
            contents += "<input type=\"submit\" style=\"position:absolute;left:-9999px;width:1px;height:1px;\"/>";
	    if(this.getFormHeight()) {
		contents = HU.div([STYLE,HU.css("overflow-y","auto","max-height",HU.getDimension(this.getFormHeight()))], contents);
	    }

	    form+=HU.div([STYLE,"margin-top:5px", CLASS,"display-search-extra"],topContents);
	    form+=contents;
            form += HU.closeTag("form");
            return form;

        },
	getEgText:function(eg) {
            eg = this.getProperty("placeholder",eg);
            if (this.eg) {
                eg = " " + this.eg;
            }
	    return eg;
	},

	getFormText:function() {
	    let text = this.getSearchSettings().text;
            if (text == null) {
                let args = Utils.getUrlArgs(document.location.search);
                text = args.text;
            }
            if (text == null) {
                text = this.getSearchText();
            }
	    return text;
	},

        handleEventMapBoundsChanged: function(source, args) {
            if (this.areaWidget) {
                this.areaWidget.handleEventMapBoundsChanged(source, args);
            }
        },
        typeChanged: function() {
            let settings = this.getSearchSettings();
            settings.skip = 0;
            settings.max = DEFAULT_MAX;
            settings.entryType = this.getFieldValue(this.getDomId(ID_TYPE_FIELD), settings.entryType);
            settings.clearAndAddType(settings.entryType);
            this.addExtraForm();
            this.submitSearchForm();
        },
        initMetadata: function() {
            this.metadata = {};
            this.metadataLoading = {};	    
            for (let i = 0; i < this.metadataTypeList.length; i++) {
                let type = this.metadataTypeList[i];
                this.addMetadata(type, null);
            }
	},
        addMetadata: function(metadataType, metadata) {
            if (metadata == null) {
                metadata = this.metadata[metadataType.getType()];
            }
            if (metadata == null) {
                let theDisplay = this;
                if (!this.metadataLoading[metadataType.getType()]) {
                    this.metadataLoading[metadataType.getType()] = true;
                    metadata = this.getRamadda().getMetadataCount(metadataType, function(metadataType, metadata) {
                        theDisplay.addMetadata(metadataType, metadata);
                    });
                }
            }
            if (metadata == null) {
                return;
            }

	    if(!this.metadataBoxes) this.metadataBoxes={};
	    this.metadataBoxes[metadataType.getType()] = {};
            this.metadata[metadataType.getType()] = metadata;
	    let popupLimit = this.getTagPopupLimit();
            let select = HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""], NONE);
	    let cbxs = [];
            for (let i = 0; i < metadata.length; i++) {
                let count = metadata[i].count;
                let value = metadata[i].value;
                let label = metadata[i].label;
		let type = metadataType.getType();
                let optionAttrs = [ATTR_VALUE, value, ATTR_CLASS, "display-metadatalist-item"];
                let selected = false;
                if (selected) {
                    optionAttrs.push("selected");
                    optionAttrs.push(null);
                }
                select += HU.tag(TAG_OPTION, optionAttrs, label + " (" + count + ")");
		let cbxId = this.getMetadataFieldId(metadataType)+"_checkbox_" + i;
		this.metadataBoxes[type][value] = cbxId;
		let cbx = HU.checkbox("",[ID,cbxId,"metadata-type",type,"metadata-value",value],false) +" " + HU.tag( "label",  [CLASS,"ramadda-noselect ramadda-clickable","for",cbxId],label +" (" + count+")");
		if(metadata.length>popupLimit) {
		    cbx = HU.span([CLASS,'display-search-tag','tag',label,STYLE, HU.css("background", Utils.getEnumColor(metadataType))], cbx);
		}
		cbxs.push(cbx);
	    }
	    if(!this.getShowTags()) {
		$("#" + this.getMetadataFieldId(metadataType)).html(select);
		this.selectboxit($("#" + this.getMetadataFieldId(metadataType)));
	    } else {
		let countId = this.getMetadataFieldId(metadataType)+"_count";
		let wrapperId = this.getMetadataFieldId(metadataType)+"_wrapper";		
		$("#" + countId).html("(" + cbxs.length+")");
		let cbxInner = HU.div([STYLE,HU.css("margin","5px", "width","800px;","max-height","300px","overflow-y","auto")],    Utils.wrap(cbxs,"",""));
		let inner = Utils.wrap(cbxs,"","<br>");
		let clickId = this.getMetadataFieldId(metadataType)+"_popup";
		let _this = this;
		let cbxChange = function(){
		    let value  = $(this).attr("metadata-value");
		    let type  = $(this).attr("metadata-type");		
                    let on = $(this).is(':checked');
		    let cbx = $(this);
		    if(on) {
			_this.addMetadataTag(metadataType.getType(), metadataType.getLabel(),value, cbx);
		    } else {
			let tagId = Utils.makeId(_this.domId(ID_SEARCH_TAG) +"_" + metadataType.getType() +"_" + value);
			$("#" + tagId).remove();
		    }		
		    _this.submitSearchForm();
		};
		if(cbxs.length>popupLimit) {
		    $("#"+wrapperId).html(HU.div([STYLE, HU.css("border","1px solid #ccc",  "margin-top","6px","background", Utils.getEnumColor(metadataType)), TITLE,"Click to select tag", ID,clickId,CLASS,"ramadda-clickable entry-toggleblock-label"], HU.makeToggleImage("fas fa-plus","font-size:8pt;") +" " +metadataType.getLabel()+" ("+ cbxs.length+")"));
		    $("#" + clickId).click(()=>{
			this.createTagDialog(cbxs, $("#" + clickId), cbxChange, metadataType.getType(),metadataType.getLabel());
		    });

		} else {
		    $("#" + this.getMetadataFieldId(metadataType)).html(inner);
		}
		$("#" + this.getMetadataFieldId(metadataType)).find(":checkbox").change(cbxChange);
	    }
        },

	metadataTagSelected:function(type, value) {
	    let tagGroupId = ID_SEARCH_TAG_GROUP+"_"+type;
	    let tagGroup = this.jq(tagGroupId);
	    let existing = tagGroup.find(HU.attrSelect("metadata-type",type)+HU.attrSelect("metadata-value",value));
	    return (existing.length>0);
	},
	addMetadataTag:function(type, label,value, cbx) {
	    let _this = this;
	    let tagGroupId = ID_SEARCH_TAG_GROUP+"_"+type;
	    let tagGroup = _this.jq(tagGroupId);
	    if(this.metadataTagSelected(type, value)) return false;
	    let tagId = Utils.makeId(_this.domId(ID_SEARCH_TAG) +"_" +type +"_" + value);
	    if(tagGroup.length==0) {
		tagGroup = $(HU.div([CLASS,"display-search-tag-group",ID,_this.domId(tagGroupId)])).appendTo(_this.jq(ID_SEARCH_BAR));			     
	    }

	    let tag = $(HU.div(["metadata-type",type,"metadata-value",value,TITLE,label+":" + value, STYLE, HU.css("background", Utils.getEnumColor(type)),CLASS,"display-search-tag", ID,tagId],value+SPACE +HU.getIconImage("fas fa-times"))).appendTo(tagGroup);
	    tag.click(function() {
		$(this).remove();
		if(cbx)
		    cbx.prop("checked",false);
		_this.submitSearchForm();
	    });
	    return true;
	},
	typeTagClicked:function(type) {
	    this.jq(ID_TYPE_FIELD).selectBoxIt('selectOption', type.getId());
	},	
	metadataTagClicked:function(metadata) {
	    if(!this.metadataBoxes[metadata.type] || !this.metadataBoxes[metadata.type][metadata.value.attr1]) {
		this.addMetadataTag(metadata.type, metadata.type,metadata.value.attr1, null);
		this.submitSearchForm();
		return;
	    }

	    let cbx = $("#" + this.metadataBoxes[metadata.type][metadata.value.attr1]);
	    if(cbx.is(':checked')) return;
	    cbx.click();
	},
        getMetadataFieldId: function(metadataType) {
            let id = metadataType.getType();
            id = id.replace(".", "_");
            return this.getDomId(ID_METADATA_FIELD + id);
        },

        findEntryType: function(typeName) {
            if (this.entryTypes == null) return null;
            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                if (type.getId() == typeName) return type;
            }
            return null;
        },
        addTypes: function(newTypes) {
            if (newTypes == null) {
                newTypes = this.getRamadda().getEntryTypes((ramadda, types) =>{
                    this.addTypes(types);
                },this.getEntryTypes());
            }
            if (newTypes == null) {
                return;
            }

            this.entryTypes = newTypes;

            if (this.getEntryTypes()) {
                let showType = {};
		let typeList = this.getEntryTypes().split(",");
                typeList.forEach(type=>{
                    showType[type] = true;
                });
                let tmp = [];
                for (let i = 0; i < this.entryTypes.length; i++) {
                    let type = this.entryTypes[i];
                    if (showType[type.getId()]) {
                        tmp.push(type);
                    } else if (type.getCategory() != null && showType[type.getCategory()]) {
                        tmp.push(type);
                    }
                }
                this.entryTypes = tmp;
	    }

            this.haveTypes = true;
            if (!this.getShowType()) {
		this.addExtraForm();
                return;
            }


            let cats = [];
            let catMap = {};
            let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_TYPE_FIELD),
                ATTR_CLASS, "display-typelist",
                "onchange", this.getGet() + ".typeChanged();"
            ]);
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""], "Any Type");
	    let hadSelected = false;
            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                let icon = type.getIcon();
                let optionAttrs = [ATTR_TITLE, type.getLabel(), ATTR_VALUE, type.getId(), ATTR_CLASS, "display-typelist-type",
                    "data-iconurl", icon
                ];
                let selected = this.getSearchSettings().hasType(type.getId());
		if(!selected) {
		    let fromUrl = HU.getUrlArgument(ID_TYPE_FIELD);
		    if(fromUrl)
			selected = type.getId()==fromUrl;
		}
                if (selected) {
		    hadSelected = true;
                    optionAttrs.push("selected");
                    optionAttrs.push(null);
                }
		let label = type.getLabel();
		if(type.getEntryCount()>0) 
		    label += " (" + type.getEntryCount() + ")"

                let option = HU.tag(TAG_OPTION, optionAttrs, label);
                let map = catMap[type.getCategory()];
                if (map == null) {
                    catMap[type.getCategory()] = HU.tag(TAG_OPTION, [ATTR_CLASS, "display-typelist-category", ATTR_TITLE, "", ATTR_VALUE, ""], type.getCategory());
                    cats.push(type.getCategory());
                }
                catMap[type.getCategory()] += option;

            }
            for (let i in cats) {
                select += catMap[cats[i]];
            }
            select += HU.closeTag(TAG_SELECT);
	    if(this.entryTypes.length==1) {
		this.writeHtml(ID_TYPE_DIV, HU.hidden(ID_TYPE_FIELD,this.entryTypes[0].getId()));
	    } else {
		this.writeHtml(ID_TYPE_DIV, select);
	    }
	    
            this.selectboxit(this.jq(ID_TYPE_FIELD),    { autoWidth: false,  "max-height":"100px"});
            this.addExtraForm();
	    if(hadSelected) {
		this.submitSearchForm();
	    }
        },
        getSelectedType: function() {
            if (this.entryTypes == null) {
		return null;
	    }
	    if(this.entryTypes.length==1) return this.entryTypes[0];
            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                if (type.getId) {
                    if (this.getSearchSettings().hasType(type.getId())) {
                        return type;
                    }
                }
            }
            let selectedType =  this.getFieldValue(this.getDomId(ID_TYPE_FIELD), null);
	    if(selectedType) {
		for (let i = 0; i < this.entryTypes.length; i++) {
                    let type = this.entryTypes[i];
                    if (type.getId) {
			if(selectedType == type.getId())
                            return type;
                    }
                }
            }
	    return null;

        },
        getSearchableColumns: function() {
            let searchable = [];
            let type = this.getSelectedType();
            if (type == null) {
                return searchable;
            }
            let cols = type.getColumns();
            if (cols == null) {
                return searchable;
            }
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                if (!col.getCanSearch()) continue;
                searchable.push(col);
            }
            return searchable;
        },
        addExtraForm: function() {
            if (this.savedValues == null) this.savedValues = {};
            let extra = "";
            let cols = this.getSearchableColumns();
	    let comparators = this.getComparators().split(",");


            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                if (this.getProperty("fields") != null && this.getProperty("fields").indexOf(col.getName()) < 0) {
                    continue;
                }

                if (extra.length == 0) {
//                    extra += HU.formTable();
                }
                let field = "";
                let id = this.getDomId(ID_COLUMN + col.getName());
                let savedValue = this.savedValues[id];
                if (savedValue == null) {
                    savedValue = this.jq(ID_COLUMN + col.getName()).val();
                }
//                if (savedValue == null) savedValue = "";
		let widget = "";
		let help = "";
		if(col.getSuffix()) {
		    help = HU.span([STYLE,HU.css('cursor','help','margin-left','10px'), TITLE,col.getSuffix()], HU.getIconImage("fas fa-info"));
		}		
		
                if (col.isEnumeration()) {
		    let showLabels = this.getShowSearchLabels();
                    field = HU.openTag(TAG_SELECT, [ATTR_ID, id, ATTR_CLASS, "display-searchmenu display-metadatalist"]);
		    field+="\n";
                    field += HU.tag(TAG_OPTION, [CLASS,"display-metadatalist-item", ATTR_TITLE, "", ATTR_VALUE, VALUE_NONE],
				    showLabels?"-- Select --":col.getLabel());
                    let values = col.getValues();
		    field+="\n";
                    for (let vidx in values) {
                        let value = values[vidx].value||"";
                        let extraAttr = "";
                        if (value == savedValue) {
                            extraAttr = " selected ";
                        }
			if(value=="") {
			    value = "--blank--";
			}
                        let label = values[vidx].label.trim();
			if(label=="&lt;blank&gt;") label="--blank--";
			if(label=="")
			    label= "--blank--"; 
                        field += HU.tag(TAG_OPTION, [CLASS,"display-metadatalist-item", ATTR_TITLE, label, ATTR_VALUE, value, extraAttr, null],
					label);
			field+="\n";
                    }
                    field += HU.closeTag(TAG_SELECT);
		    if(showLabels) {
			widget += HU.div([CLASS,"display-search-label"], col.getLabel()+":");
			widget+= HU.div([CLASS,"display-search-widget"], field+help);
		    } else {
			widget+= HU.div([CLASS,"display-search-block display-search-widget"], field+help);
		    }
		} else if (col.isNumeric()) {
		    let from = HU.input("", "", [ATTR_CLASS, "input", STYLE,HU.css("width","2.5em"), ATTR_ID, id+"_from"]);
		    let to = HU.input("", "", [ATTR_CLASS, "input", STYLE,HU.css("width","2.5em"), ATTR_ID, id+"_to"]);		    
                    widget += HU.div([CLASS,"display-search-label"], col.getLabel()) +
			from +" - " + to +help;
                } else {
                    field = HU.input("", savedValue, ["placeholder",col.getLabel(),ATTR_CLASS, "input", ATTR_SIZE, "15", ATTR_ID, id]);
                    widget += HU.div([CLASS,"display-search-label"], "") +HU.div([CLASS,"display-search-widget"], field + " " + help);
                }
		extra+=widget;
	    }
            if (extra.length > 0) {
		extra = HU.toggleBlock(this.getSearchHeaderLabel(),extra,this.getSearchOpen());
            }
            this.writeHtml(ID_TYPEFIELDS, extra);
	    let _this = this;
	    this.jq(ID_TYPEFIELDS).find(".ramadda-expr").change(function() {
		let id = $(this).attr("id");
		let val = $(this).val();
		id  = id.replace("_expr","_to");
		if(val=="between")
		    $("#" + id).show();
		else
		    $("#" + id).hide();
	    });
	    let menus = this.jq(ID_TYPEFIELDS).find(".display-searchmenu");
	    this.selectboxit(menus);
	    menus.change(()=>{
		this.submitSearchForm();
	    });
        },
        getEntries: function() {
            if (this.entryList == null) return [];
            return this.entryList.getEntries();
        },
        loadNextUrl: function() {
            this.getSearchSettings().skip += this.getSearchSettings().max;
            this.submitSearchForm();
        },
        loadMore: function() {
            this.getSearchSettings().max = this.getSearchSettings().max += DEFAULT_MAX;
            this.submitSearchForm();
        },
        loadLess: function() {
            let max = this.getSearchSettings().max;
            max = parseInt(0.75 * max);
            this.getSearchSettings().max = Math.max(1, max);
            this.submitSearchForm();
        },
        loadPrevUrl: function() {
            this.getSearchSettings().skip = Math.max(0, this.getSearchSettings().skip - this.getSearchSettings().max);
            this.submitSearchForm();
        },
        entryListChanged: function(entryList) {
            this.entryList = entryList;
        }
    });
}


function RamaddaEntrylistDisplay(displayManager, id, properties, theType) {
    if (theType == null) {
        theType = DISPLAY_ENTRYLIST;
    }
    const SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_ENTRYLIST, properties);
    let myProps = [];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        haveDisplayed: false,
        selectedEntries: [],
        getSelectedEntries: function() {
            return this.selectedEntries;
        },
        initDisplay: function() {
            let _this = this;
            if (this.getIsLayoutFixed() && this.haveDisplayed) {
                return;
            }
            this.haveDisplayed = true;
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
            this.providerChanged(true);
            if (this.dateRangeWidget) {
                this.dateRangeWidget.initHtml();
            }
            if (this.createdateRangeWidget) {
                this.createdateRangeWidget.initHtml();
            }	    
            SUPER.initDisplay.apply(this);
            if (this.entryList != null && this.entryList.haveLoaded) {
                this.entryListChanged(this.entryList);
            }
            this.selectboxit(this.jq(ID_PROVIDERS),   { autoWidth: false,  "max-height":"100px"});
            this.jq(ID_PROVIDERS).change(function() {
                _this.providerChanged();
            });
        },
        providerChanged: function(initialCall) {
	    if(this.jq(ID_PROVIDERS).length==0) return;
	    if(!initialCall && this.jq(ID_ANCESTOR).val) {
		this.jq(ID_ANCESTOR).val("");
		this.jq(ID_ANCESTOR+"_hidden").val("");		
	    }
	    this.getSearchSettings().skip=0;
            let id = this.jq(ID_PROVIDERS).val();
	    this.provider = this.providerMap[id];
	    HU.addToDocumentUrl(ID_PROVIDERS,id);
	    this.jq(ID_SEARCH_BAR).html("");
	    let blocks = [ID_SEARCH_AREA, ID_SEARCH_TAGS,ID_SEARCH_ANCESTOR,ID_SEARCH_DATE_CREATE,ID_SEARCH_DATE_RANGE];
            if (this.provider && this.provider.type!="ramadda") {
		this.setRamadda(this.originalRamadda);
		let caps = (this.provider.capabilities||"").split(",");
		caps.forEach(cap=>{
		    let index = blocks.indexOf("search_" + cap);
		    if(index>=0) {
			blocks.splice(index,1);
		    }
		});
		//area
		blocks.forEach(id=>{
		    this.jq(id).hide();
		});
		this.jq(ID_TYPE_DIV).hide();
            } else {
		blocks.forEach(id=>{
		    this.jq(id).show();
		});
		this.jq(ID_TYPE_DIV).show();
		if(this.getSearchDirect()) {
		    if(this.provider)
			this.setRamadda(getRamadda(this.provider.id+";"+ this.provider.name));
		    this.addTypes();
		    this.initMetadata();
		}
            }
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.apply(this, menuItems);
            if (this.getSelectedEntriesFromTree().length > 0) {
                let get = this.getGet();
                menuItems.push(HU.onClick(get + ".makeDisplayList();", "Make List"));
                menuItems.push(HU.onClick(get + ".makeDisplayGallery();", "Make Gallery"));
            }
        },
        makeDisplayList: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries,
                showForm: false,
                showMenu: true,
                fixedEntries: true
            };
            props.entryList = new EntryList(this.getRamadda(), "", this, false);
            props.entryList.setEntries(entries);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRYLIST, props);
        },
        makeDisplayGallery: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries
            };

	    let eg = this.getEgText();
	    let text  = this.getFormText();
            let textField = HU.input("", text, ["placeholder", eg, ATTR_CLASS, "display-search-input", ATTR_SIZE, "30", ATTR_ID, this.getDomId(ID_TEXT_FIELD)]);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRY_GALLERY, props);
        },
        handleEventEntrySelection: function(source, args) {
            this.selectEntry(args.entry, args.selected);
        },
        selectEntry: function(entry, selected) {
            let changed = false;
            if (selected) {
                this.jq("entry_" + entry.getIdForDom()).addClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index < 0) {
                    this.selectedEntries.push(entry);
                    changed = true;
                }
            } else {
                this.jq("entry_" + entry.getIdForDom()).removeClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index >= 0) {
                    this.selectedEntries.splice(index, 1);
                    changed = true;
                }
            }
        },
        makeEntriesDisplay: function(entries) {
	    this.tabId = null;
	    this.mapId = null;
	    if(this.myDisplays) {
		this.myDisplays.forEach(info=>{
		    removeRamaddaDisplay(info.display.getId());
		});
	    }
	    this.myDisplays = [];


	    let titles = [];
	    let contents = [];
	    this.getDisplayTypes("list,images,timeline,map").split(",").forEach(type=>{
		if(type=="list") {
		    titles.push("List");
		    contents.push(this.getEntriesTree(entries));
		} else if(type=="images") {
		    let defaultImage = this.getDefaultImage();
		    let imageEntries = entries.filter(entry=>{
			if(defaultImage) return true;
			return entry.isImage();
		    });
		    if(imageEntries.length>0) {
			titles.push("Images");
			let id = HU.getUniqueId(type +"_");
			this.myDisplays.push({id:id,type:type});
			contents.push(HU.div([ID,id,STYLE,HU.css("width","100%")]));
		    }
		} else if(type=="timeline") {
		    titles.push("Timeline");
		    let id = HU.getUniqueId(type +"_");
		    this.myDisplays.push({id:id,type:type});
		    contents.push(HU.div([ID,id,STYLE,HU.css("width","100%")]));
		} else if(type=="map") {
		    this.areaEntries = entries.filter(entry=>{
			return entry.hasBounds() || entry.hasLocation();
		    });
		    if(this.areaEntries.length>0) {
			titles.push("Map");
			let id = HU.getUniqueId(type +"_");
			this.myDisplays.push({id:id,type:type,entries:this.areaEntries});
			contents.push(HU.div([ID,id,STYLE,HU.css("width","100%")]));
//			this.mapId = HU.getUniqueId("map_");
//			let mapDiv = HU.div([ID,this.mapId,STYLE,HU.css("width","100%","height","400px")]);
//			contents.push(mapDiv);
		    }

		} else if(type=="metadata") {		    
		    titles.push("Metadata");
		    let mtd = HU.div([STYLE,HU.css("width","800px","max-width","800px","overflow-x","auto")],this.getEntriesMetadata(entries));
		    contents.push(mtd);
		}
	    });

	    if(titles.length==1) return HU.div([CLASS,"xdisplay-entrylist-content-border"],contents[0]);
	    let tabId = HU.getUniqueId("tabs_");
	    let tabs = HU.open("div",[ID,tabId,CLASS,"ui-tabs"]) +"<ul>";
	    titles.forEach((title,idx)=>{
		tabs +="<li>" +HU.href("#" + tabId+"-" + idx,title) +"</li>\n"
	    })
	    tabs +="</ul>\n";
	    this.tabCount = contents.length;
	    contents.forEach((content,idx)=>{
		tabs +=HU.div([ID,tabId+"-" + idx,CLASS,"ui-tabs-hide"], content);
	    });
	    tabs +=HU.close("div");
	    this.tabId = tabId;
	    return tabs;
        },

        entryListChanged: function(entryList) {
            if (this.multiSearch) {
                this.multiSearch.count--;
            }
            SUPER.entryListChanged.apply(this, [entryList]);
            let entries = this.entryList.getEntries();

            if (entries.length == 0) {
//                this.getSearchSettings().skip = 0;
                this.getSearchSettings().max = DEFAULT_MAX;
                let msg = "Nothing found";
                if (this.multiSearch) {
                    if (this.multiSearch.count > 0) {
                        msg = "Nothing found so far. Still searching " + this.multiSearch.count + " repositories";
                    } else {}
                }
                this.writeHtml(ID_FOOTER_LEFT, "");
		this.jq(ID_ENTRIES).html(this.getMessage(msg));
//                this.writeMessage(msg);		
                this.getDisplayManager().handleEventEntriesChanged(this, []);
//		this.jq(ID_ENTRIES).html("");
//                return;
            }
	    this.writeMessage(this.getResultsHeader(entries));
            if (entries.length == 0) {
		return
	    }

            let get = this.getGet();
            this.writeHtml(ID_FOOTER_LEFT, "");
            if (this.footerRight != null) {
                this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
            }

            //                let entriesHtml  = this.getEntriesTree(entries);
            let entriesHtml = this.makeEntriesDisplay(entries);
            let html = "";
            html += HU.openTag(TAG_OL, [ATTR_CLASS, this.getClass("list"), ATTR_ID, this.getDomId(ID_LIST)]);
            html += entriesHtml;
            html += HU.closeTag(TAG_OL);
            this.writeEntries(html, entries);
            this.addEntrySelect();
            this.getDisplayManager().handleEventEntriesChanged(this, entries);
	    if(this.galleryId) {
	    	$("#" + this.galleryId).find("a.popup_image").fancybox({helpers:{title:{type:'over'}}});
	    }
	    let tabbed = (event,ui)=>{
		this.activeTabIndex = ui.newTab.index();
		HtmlUtil.tabLoaded();
	    };
	    if(this.tabId) {
		let index = this.activeTabIndex;
		if(index>=this.tabCount)  index = this.tabCount-1;
		$('#' + this.tabId).tabs({activate: tabbed,active: index});
	    }	
	    if(this.myDisplays && this.myDisplays.length) {
		let index=0;
		let fields = [new RecordField({type: "string", index: (index++), id: "name",label: "Name"}),
			      new RecordField({type: "string", index: (index++), id: "description",label: "Description"}),
			      new RecordField({type: "url", index: (index++), id: "url",label: "URL"}),
			      new RecordField({type: "image", index: (index++), id: "image",label: "Image"}),
			      new RecordField({type: "url", index: (index++), id: "iconUrl",label: "Icon"}),
			      new RecordField({type: "string", index: (index++), id: "tags",label: "Tags"}),			      			      
			      new RecordField({index: (index++), id: "latitude",label: "Latitude"}),
			      new RecordField({index: (index++), id: "longitude",label: "Longitude"}),			      			      					     ]
		let entryType = null;
		if(this.entryTypes && this.entryTypes.length) {
		    entryType = this.entryTypes[0];
		    entryType.getColumns().forEach(column=>{
			fields.push(new RecordField({index: (index++), id: column.getName(),label: column.getLabel()}));
		    });
		}
		let records = [];
		let makeData = entries=>{
		    let records = [];
		    entries.forEach(entry=>{
			let tags = this.makeEntryTags(entry,true,"");
			let defaultImage = this.getDefaultImage();
			if(defaultImage) {
			    if(defaultImage.startsWith("http"))
				defaultImage = ramaddaBaseUrl+ defaultImage;
			}
			let data = [entry.getName(),entry.getSnippet()||"",entry.getEntryUrl(),entry.getImageUrl()||defaultImage||"",entry.getIconUrl(),tags,entry.getLatitude(), entry.getLongitude()];
			if(entryType) {
			    entryType.getColumns().forEach(column=>{
				let v = entry.getAttributeValue(column.getName());
				data.push(v);
			    });
			}
			records.push(new PointRecord(fields, entry.getLatitude(),entry.getLongitude(),NaN,entry.getStartDate() || entry.getCreateDate(),data,0));
		    });
		    return records;
		};
		let baseData= new  PointData("pointdata", fields, makeData(entries),null,null);
		let _this = this;
		this.myDisplays.forEach(info=> {
		    let data = info.entries?new  PointData("pointdata", fields, makeData(info.entries)):baseData;
		    let dialogListener = (display, dialog)=>{
			dialog.find(".display-search-tag").click(function() {
			    let type = $(this).attr("metadata-type");
			    let value = $(this).attr("metadata-value");			    
			    if(!_this.addMetadataTag(type,type, value)) return;
			    _this.submitSearchForm();
			});
		    };
		    let tooltip = this.getProperty("tooltip");
		    let props = {dialogListener: dialogListener,highlightColor:"#436EEE",blockStyle:this.getProperty("blockStyle",""),doPopup:this.getProperty("doPopup",true),tooltip:tooltip, tooltipClick:tooltip,descriptionField:"description",imageWidth:"140px",blockWidth:"150px",numberOfImages:500,showTableOfContents:true,iconField:"iconUrl",iconSize:16,displayEntries:false, imageField:"image",urlField:"url",titleField:"name",labelField:"name",labelFields:"name",showBottomLabel:false,bottomLabelTemplate:"", topLabelTemplate:"${name}", textTemplate:"${description}",displayId:info.id,divid:info.id,showMenu:false,theData:data,displayStyle:""};
		    info.display =  this.getDisplayManager().createDisplay(info.type,props);
		})
	    }

	    if(this.mapId && this.areaEntries && this.areaEntries.length>0) {
		let map = new RepositoryMap(this.mapId);
		map.initMap(false);
		this.areaEntries.forEach(entry=>{
                    let link = HU.tag(TAG_A, ["target","_entries",ATTR_HREF, entry.getEntryUrl()], entry.getName());
		    let text = link;
		    if(entry.isImage()) {
			text = HU.image(entry.getResourceUrl(), [ATTR_WIDTH, "400", ATTR_ID,
								 this.getDomId("entry_" + entry.getIdForDom()),
								 ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
								]) +"<br>" + link;


			
		    }
//		    map.addMarker:  function(id, location, iconUrl, markerName, text, parentId, size, yoffset, canSelect, attrs) {
		    map.addMarker('',{x:entry.getLongitude(),y:entry.getLatitude()}, entry.getIconUrl(),"",text,null,16,0,true,{});
/*
{"pointRadius":16,
												     "strokeWidth":1,
												     "fillColor":"blue",
												     "strokeColor":"#000"},text);
*/
		});
		map.centerOnMarkersInit(null);
	    }

        },
    });
}



function RamaddaSimplesearchDisplay(displayManager, id, properties) {
    let myProps = [
	{label:'Simple Search'},
	{p:'resultsPosition',ex:'absolute|relative'},
	{p:'maxHeight',ex:300},
	{p:'maxWidth',ex:200},
	{p:'maxWidth',ex:200},		
	{p:"autoSearch",ex:true},
	{p:"showHeader",ex:true},
	{p:"inputSize",ex:"100%"},
	{p:"searchEntryType",ex:"",tt:"Constrain search to entries of this type"},		
    ];

    const SUPER   = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_SIMPLESEARCH, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	callNumber:1,
        haveDisplayed: false,
        selectedEntries: [],
        getSelectedEntries: function() {
            return this.selectedEntries;
        },
        initDisplay: function() {
            let _this = this;
            if (this.getIsLayoutFixed() && this.haveDisplayed) {
                return;
            }
            this.haveDisplayed = true;
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
	    let input = this.jq(ID_TEXT_FIELD);
	    if(this.getAutoSearch(true)) {
		//KEY
		input.keyup(function(event) {
		    _this.getSearchSettings().skip =0;
                    _this.getSearchSettings().max = DEFAULT_MAX;
		    if($(this).val().trim()=="") {
			_this.writeMessage("");
			_this.writeEntries("");			
			if(_this.dialog) {
			    _this.dialog.remove();
			    _this.dialog = null;
			}
			return;
		    }
		    let myCallNumber = ++_this.callNumber;
		    //Wait a bit in case more keys are coming
		    setTimeout(()=>{
			if(myCallNumber == _this.callNumber) {
			    _this.submitSearchForm(true,myCallNumber);
			} else {
			}
		    },400);
		});
	    }

            this.jq(ID_SEARCH).click(function(event) {
		_this.submitSearchForm(false,++_this.callNumber);
                event.preventDefault();
            });
            this.jq(ID_FORM).submit(function(event) {
		_this.submitSearchForm(false,++_this.callNumber);
                event.preventDefault();
            });


            this.jq(ID_TEXT_FIELD).autocomplete({
                source: function(request, callback) {
                }
            });

	},
        getDefaultHtml: function() {
	    let html = this.makeSearchForm();
	    let style="";
	    let abs = (this.getProperty("resultsPosition","absolute")=="absolute");
	    if(!abs) {
		if(this.getMaxHeight(400)) {
		    style+=HU.css("max-height",HU.getDimension(this.getMaxHeight(400)));
		} 
		if(this.getMaxWidth()) {
		    style+=HU.css("width",HU.getDimension(this.getMaxWidth(400)));
		    style+=HU.css("max-width",HU.getDimension(this.getMaxWidth(200)));
		}
		let entries = HU.div([ID,this.domId(ID_ENTRIES),CLASS,"display-simplesearch-entries",STYLE,style]);
		if (this.getShowHeader(true)) {
		    html+=  HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)]);
		}
		html+=entries;
	    }
	    return html;
	},
        makeSearchForm: function() {
            let form = HU.openTag("form", [ATTR_ID, this.getDomId(ID_FORM), "action", "#"]);
	    
	    let eg = this.getEgText();
	    let text  = this.getFormText();
	    let size = this.getPropertyInputSize("100%");
            let textField = HU.input("", text, [STYLE, HU.css("width", size), "placeholder", eg, ATTR_CLASS, "display-search-input", ATTR_ID, this.getDomId(ID_TEXT_FIELD)]);

	    form += textField;
            form += "<input type=\"submit\" style=\"position:absolute;left:-9999px;width:1px;height:1px;\"/>";
            form += HU.closeTag("form");
	    form+=HU.div([ID,this.domId(ID_FORM)]);
            return form;
	},
	handleNoEntries: function() {
	    this.writeEntries("",[]);
            this.writeMessage("Nothing found");
            this.getDisplayManager().handleEventEntriesChanged(this, []);
	},
	writeMessage: function(msg) {
	    this.makeDialog();
	    SUPER.writeMessage.call(this,msg);
	},

	makeDialog: function() {
	    if(this.dialog && (this.dialog.parent()==null ||this.dialog.parent().length==0)) this.dialog = null;
	    if(!this.dialog) {
                let header = HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)], "&nbsp;");
                let entries= HU.div([CLASS,"display-entries-entries", ATTR_ID, this.getDomId(ID_ENTRIES)], "");		
		this.dialog = HU.makeDialog({content:header+entries,anchor:this.getContents(),
					     draggable:true,header:true});
	    } else {
		this.dialog.show();
	    }
	},	    
	writeEntries: function(msg, entries) {
	    let abs = this.getProperty("resultsPosition","absolute")=="absolute";
	    if(!abs) {
		this.jq(ID_ENTRIES).html(msg);
		return;
	    }
	    this.makeDialog();

	    if(Utils.stringDefined(msg)) {
		this.jq(ID_ENTRIES).html(msg);
		this.writeMessage(this.getResultsHeader(entries,true));
	    } else {
		this.jq(ID_ENTRIES).html("");
	    }
	},

        submitSearchForm: function(auto, callNumber) {
	    this.writeMessage(this.getWaitImage() + " " +"Searching...");
	    if(callNumber==null) callNumber = this.callNumber;
            this.haveSearched = true;
            let settings  =this.makeSearchSettings();
	    settings.entryType = this.getSearchEntryType();	    
            let jsonUrl = this.makeSearchUrl(this.getRamadda());
            this.entryList = new EntryList(this.getRamadda(), jsonUrl);
	    let success= ()=>{
		if(this.callNumber == callNumber) {
		    this.entryListChanged(this.entryList);
		} 
	    };
	    let fail= (error)=>{
		this.writeEntries("Error:" + error);
	    };	    
	    this.entryList.doSearch(null,success,fail);
	    if(!auto)
		this.updateForSearching(jsonUrl);
        },

        makeDisplayList: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries,
                showForm: false,
                showMenu: true,
                fixedEntries: true
            };
            props.entryList = new EntryList(this.getRamadda(), "", this, false);
            props.entryList.setEntries(entries);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRYLIST, props);
        },
        handleEventEntrySelection: function(source, args) {
            this.selectEntry(args.entry, args.selected);
        },
        selectEntry: function(entry, selected) {
            let changed = false;
            if (selected) {
                this.jq("entry_" + entry.getIdForDom()).addClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index < 0) {
                    this.selectedEntries.push(entry);
                    changed = true;
                }
            } else {
                this.jq("entry_" + entry.getIdForDom()).removeClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index >= 0) {
                    this.selectedEntries.splice(index, 1);
                    changed = true;
                }
            }
        },
        makeEntriesDisplay: function(entries) {
            return this.getEntriesTree(entries);
        },
        entryListChanged: function(entryList) {
            if (this.multiSearch) {
                this.multiSearch.count--;
            }
            SUPER.entryListChanged.apply(this, [entryList]);
            let entries = this.entryList.getEntries();
            if (entries.length == 0) {
                this.getSearchSettings().skip = 0;
                this.getSearchSettings().max = DEFAULT_MAX;
		this.handleNoEntries();
                return;
            }
            this.writeMessage(this.getResultsHeader(entries, true));
	    this.initCloser(ID_RESULTS);

            let get = this.getGet();
            this.writeHtml(ID_FOOTER_LEFT, "");
            if (this.footerRight != null) {
                this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
            }


	    let html = "";
	    let inner = "";
	    let map = {};
	    entries.forEach((entry,idx) =>{
		map[entry.getId()] = entry;
		let thumb = entry.getThumbnail();
		let attrs = [TITLE,"",CLASS,"display-simplesearch-entry","entryid",entry.getId()];
		if(thumb) attrs.push("thumbnail",thumb);
		inner+=HU.div(attrs, HU.href(this.getRamadda().getEntryUrl(entry),HU.image(entry.getIconUrl()) +"  "+ entry.getName()));
	    });
//	    inner = HU.div([CLASS,"display-simplesearch-entries"],inner);
            this.writeEntries(inner, entries);
	    let _this = this;
	    this.jq(ID_ENTRIES).find(".display-simplesearch-entry").tooltip({
		content: function() {
		    let thumb = $(this).attr("thumbnail");
		    let entry = map[$(this).attr("entryid")];
		    let active= true;
		    let parent;
		    entry.getParentEntry(p=>{
			parent = p;
			if(!active) {
			    _this.jq("parenttooltip").html(HU.b("Parent: ") +parent.getName());
			}
		    });
		    active = false;
		    let snippet = entry.getSnippet();
		    let html = HU.div([ID,_this.domId("parenttooltip")],parent?HU.b("Parent: ") + parent.getName():"")
		    if(snippet)
			html+=snippet;
			
		    if(thumb) {
			html+=
			    HU.div([STYLE,HU.css("max-height","100px","overflow-y","hidden")],
				   HU.image(thumb,["width","200px"]));
		    }

		    return html;
		}});

            this.getDisplayManager().handleEventEntriesChanged(this, entries);
        },

    });
}





function RamaddaEntrygridDisplay(displayManager, id, properties) {
    const ID_CONTENTS = "contents";
    const ID_GRID = "grid";
    const ID_AXIS_LEFT = "axis_left";
    const ID_AXIS_BOTTOM = "axis_bottom";
    const ID_CANVAS = "canvas";
    const ID_LINKS = "links";
    const ID_RIGHT = "right";

    const ID_SETTINGS = "gridsettings";
    const ID_YAXIS_ASCENDING = "yAxisAscending";
    const ID_YAXIS_SCALE = "scaleHeight";
    const ID_XAXIS_ASCENDING = "xAxisAscending";
    const ID_XAXIS_TYPE = "xAxisType";
    const ID_YAXIS_TYPE = "yAxisType";
    const ID_XAXIS_SCALE = "scaleWidth";
    const ID_SHOW_ICON = "showIcon";
    const ID_SHOW_NAME = "showName";
    const ID_COLOR = "boxColor";

    let myProps = [];
    let SUPER = new RamaddaEntryDisplay(displayManager, id, DISPLAY_ENTRY_GRID, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        entries: properties.entries,
        initDisplay: function() {
            let _this = this;
            this.createUI();
            let html = HU.div([ATTR_ID, this.getDomId(ID_CONTENTS)], this.getLoadingMessage("Loading entries..."));
            this.setContents(html);
            if (!this.entryIds) {
                _this.jq(ID_CONTENTS).html(this.getLoadingMessage("No entries specified"));
                return;
            }
            let props = {
                entries: this.entryIds
            };
            let searchSettings = new EntrySearchSettings(props);
            let jsonUrl = this.getRamadda().getSearchUrl(searchSettings, OUTPUT_JSON, "BAR");
            let myCallback = {
                entryListChanged: function(list) {
                    _this.entries = list.getEntries();
                    if (_this.entries.length == 0) {
                        _this.jq(ID_CONTENTS).html(_this.getLoadingMessage("No entries selected"));
                        return;
                    }
                    _this.drag = null;
                    _this.jq(ID_CONTENTS).html(_this.makeFramework());

                    _this.canvas = $("#" + _this.getDomId(ID_CANVAS));
                    _this.gridPopup = $("#" + _this.getDomId(ID_GRID) + " .display-grid-popup");
                    let debugMouse = false;
                    let xAxis = _this.jq(ID_AXIS_BOTTOM);
                    let yAxis = _this.jq(ID_AXIS_LEFT);
                    let mousedown = function(evt) {
                        if (debugMouse)
                            console.log("mouse down");
                        _this.handledClick = false;
                        _this.drag = {
                            dragging: false,
                            x: GuiUtils.getEventX(evt),
                            y: GuiUtils.getEventY(evt),
                            X: {
                                minDate: _this.axis.X.minDate ? _this.axis.X.minDate : _this.minDate,
                                maxDate: _this.axis.X.maxDate ? _this.axis.X.maxDate : _this.maxDate,
                            },
                            Y: {
                                minDate: _this.axis.Y.minDate ? _this.axis.Y.minDate : _this.minDate,
                                maxDate: _this.axis.Y.maxDate ? _this.axis.Y.maxDate : _this.maxDate,
                            }
                        }
                    }
                    let mouseleave = function(evt) {
                        if (debugMouse)
                            console.log("mouse leave");
                        _this.drag = null;
                        _this.handledClick = false;
                    }
                    let mouseup = function(evt) {
                        if (debugMouse)
                            console.log("mouse up");
                        if (_this.drag) {
                            if (_this.drag.dragging) {
                                if (debugMouse)
                                    console.log("mouse up-was dragging");
                                _this.handledClick = true;
                            }
                            _this.drag = null;
                        }
                    }
                    let mousemove = function(evt, doX, doY) {
                        if (debugMouse)
                            console.log("mouse move");
                        let drag = _this.drag;
                        if (!drag) return;
                        drag.dragging = true;
                        let x = GuiUtils.getEventX(evt);
                        let deltaX = drag.x - x;
                        let y = GuiUtils.getEventY(evt);
                        let deltaY = drag.y - y;
                        let width = $(this).width();
                        let height = $(this).height();
                        let percentX = (x - drag.x) / width;
                        let percentY = (y - drag.y) / height;
                        let ascX = _this.getXAxisAscending();
                        let ascY = _this.getXAxisAscending();
                        let diffX = (drag.X.maxDate.getTime() - drag.X.minDate.getTime()) * percentX;
                        let diffY = (drag.Y.maxDate.getTime() - drag.Y.minDate.getTime()) * percentY;

                        if (doX) {
                            _this.axis.X.minDate = new Date(drag.X.minDate.getTime() + ((ascX ? -1 : 1) * diffX));
                            _this.axis.X.maxDate = new Date(drag.X.maxDate.getTime() + ((ascX ? -1 : 1) * diffX));
                        }
                        if (doY) {
                            _this.axis.Y.minDate = new Date(drag.Y.minDate.getTime() + ((ascY ? 1 : -1) * diffY));
                            _this.axis.Y.maxDate = new Date(drag.Y.maxDate.getTime() + ((ascY ? 1 : -1) * diffY));
                        }
                        _this.makeGrid(_this.entries);
                    }
                    let mouseclick = function(evt, doX, doY) {
                        if (_this.handledClick) {
                            if (debugMouse)
                                console.log("mouse click-other click");
                            _this.handledClick = false;
                            return;
                        }
                        if (_this.drag && _this.drag.dragging) {
                            if (debugMouse)
                                console.log("mouse click-was dragging");
                            _this.drag = null;
                            return;
                        }
                        if (debugMouse)
                            console.log("mouse click");
                        _this.drag = null;
                        let action;
                        if (evt.metaKey || evt.ctrlKey) {
                            action = "reset";
                        } else {
                            let zoomOut = evt.shiftKey;
                            if (zoomOut)
                                action = "zoomout";
                            else
                                action = "zoomin";
                        }
                        _this.doZoom(action, doX, doY);
                    };

                    let mousemoveCanvas = function(evt) {
                        mousemove(evt, true, true);
                    }
                    let mousemoveX = function(evt) {
                        mousemove(evt, true, false);
                    }
                    let mousemoveY = function(evt) {
                        mousemove(evt, false, true);
                    }

                    let mouseclickCanvas = function(evt) {
                        mouseclick(evt, true, true);
                    }
                    let mouseclickX = function(evt) {
                        mouseclick(evt, true, false);
                    }
                    let mouseclickY = function(evt) {
                        mouseclick(evt, false, true);
                    }


                    _this.canvas.mousedown(mousedown);
                    _this.canvas.mouseleave(mouseleave);
                    _this.canvas.mouseup(mouseup);
                    _this.canvas.mousemove(mousemoveCanvas);
                    _this.canvas.click(mouseclickCanvas);

                    xAxis.mousedown(mousedown);
                    xAxis.mouseleave(mouseleave);
                    xAxis.mouseup(mouseup);
                    xAxis.mousemove(mousemoveX);
                    xAxis.click(mouseclickX);

                    yAxis.mousedown(mousedown);
                    yAxis.mouseleave(mouseleave);
                    yAxis.mouseup(mouseup);
                    yAxis.mousemove(mousemoveY);
                    yAxis.click(mouseclickY);

                    let links =
                        HU.image(icon_zoom, ["class", "display-grid-action", "title", "reset zoom", "action", "reset"]) +
                        HU.image(icon_zoom_in, ["class", "display-grid-action", "title", "zoom in", "action", "zoomin"]) +
                        HU.image(icon_zoom_out, ["class", "display-grid-action", "title", "zoom out", "action", "zoomout"]);
                    _this.jq(ID_LINKS).html(links);
                    $("#" + _this.getDomId(ID_GRID) + " .display-grid-action").click(function() {
                        let action = $(this).attr("action");
                        _this.doZoom(action);
                    });


                    _this.jq(ID_AXIS_LEFT).html("");
                    _this.jq(ID_AXIS_BOTTOM).html("");
                    _this.makeGrid(_this.entries);
                }
            };
            let entryList = new EntryList(this.getRamadda(), jsonUrl, myCallback, true);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let cbx = this.jq(ID_SETTINGS + " :checkbox");
            cbx.click(function() {
                _this.setProperty($(this).attr("attr"), $(this).is(':checked'));
                _this.makeGrid(_this.entries);
            });
            let input = this.jq(ID_SETTINGS + " :input");
            input.blur(function() {
                _this.setProperty($(this).attr("attr"), $(this).val());
                _this.makeGrid(_this.entries);
            });
            input.keypress(function(event) {
                let keycode = (event.keyCode ? event.keyCode : event.which);
                if (keycode == 13) {
                    _this.setProperty($(this).attr("attr"), $(this).val());
                    _this.makeGrid(_this.entries);
                }
            });

        },
        getDialogContents: function(tabTitles, tabContents) {
            let height = "600";
            let html = "";
            html += HU.openTag("div", ["id", this.getDomId(ID_SETTINGS)]);

            html += HU.formTable();
            html += HU.formEntry("",
                HU.checkbox(this.getDomId(ID_SHOW_ICON),
                    ["attr", ID_SHOW_ICON],
                    this.getProperty(ID_SHOW_ICON, "true")) + " Show Icon" +
                "&nbsp;&nbsp;" +
                HU.checkbox(this.getDomId(ID_SHOW_NAME),
                    ["attr", ID_SHOW_NAME],
                    this.getProperty(ID_SHOW_NAME, "true")) + " Show Name");
            html += HU.formEntry("X-Axis:",
                HU.checkbox(this.getDomId(ID_XAXIS_ASCENDING),
                    ["attr", ID_XAXIS_ASCENDING],
                    this.getXAxisAscending()) + " Ascending" +
                "&nbsp;&nbsp;" +
                HU.checkbox(this.getDomId(ID_XAXIS_SCALE),
                    ["attr", ID_XAXIS_SCALE],
                    this.getXAxisScale()) + " Scale Width");
            html += HU.formEntry("Y-Axis:",
                HU.checkbox(this.getDomId(ID_YAXIS_ASCENDING),
                    ["attr", ID_YAXIS_ASCENDING],
                    this.getYAxisAscending()) + " Ascending" +
                "&nbsp;&nbsp;" +
                HU.checkbox(this.getDomId(ID_YAXIS_SCALE),
                    ["attr", ID_YAXIS_SCALE],
                    this.getYAxisScale()) + " Scale Height");

            html += HU.formEntry("Box Color:",
                HU.input(this.getDomId(ID_COLOR),
                    this.getProperty(ID_COLOR, "lightblue"),
                    ["attr", ID_COLOR]));

            html += HU.formTableClose();
            html += HU.closeTag("div");
            tabTitles.push("Entry Grid");
            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },

        doZoom: function(action, doX, doY) {
            if (!Utils.isDefined(doX)) doX = true;
            if (!Utils.isDefined(doY)) doY = true;
            if (action == "reset") {
                this.axis.Y.minDate = null;
                this.axis.Y.maxDate = null;
                this.axis.X.minDate = null;
                this.axis.X.maxDate = null;
            } else {
                let zoomOut = (action == "zoomout");
                if (doX) {
                    let d1 = this.axis.X.minDate.getTime();
                    let d2 = this.axis.X.maxDate.getTime();
                    let dateRange = d2 - d1;
                    let diff = (zoomOut ? 1 : -1) * dateRange * 0.1;
                    this.axis.X.minDate = new Date(d1 - diff);
                    this.axis.X.maxDate = new Date(d2 + diff);
                }
                if (doY) {
                    let d1 = this.axis.Y.minDate.getTime();
                    let d2 = this.axis.Y.maxDate.getTime();
                    let dateRange = d2 - d1;
                    let diff = (zoomOut ? 1 : -1) * dateRange * 0.1;
                    this.axis.Y.minDate = new Date(d1 - diff);
                    this.axis.Y.maxDate = new Date(d2 + diff);
                }
            }
            this.makeGrid(this.entries);
        },
        initGrid: function(entries) {
            let _this = this;
            let items = this.canvas.find(".display-grid-entry");
            items.click(function(evt) {
                let index = parseInt($(this).attr("index"));
                entry = entries[index];
                let url = entry.getEntryUrl();
                if (_this.urlTemplate) {
                    url = _this.urlTemplate.replace("{url}", url).replace(/{entryid}/g, entry.getId()).replace(/{resource}/g, entry.getResourceUrl());
                }

                _this.handledClick = true;
                _this.drag = null;
                window.open(url, "_entry");
                //                        evt.stopPropagation();
            });
            items.mouseout(function() {
                let id = $(this).attr("entryid");
                if (id) {
                    let other = _this.canvas.find("[entryid='" + id + "']");
                    other.each(function() {
                        if ($(this).attr("itemtype") == "box") {
                            $(this).attr("prevcolor", $(this).css("background"));
                            $(this).css("background", $(this).attr("prevcolor"));
                        }
                    });
                }

                _this.gridPopup.hide();
            });
            items.mouseover(function(evt) {
                let id = $(this).attr("entryid");
                if (id) {
                    let other = _this.canvas.find("[entryid='" + id + "']");
                    other.each(function() {
                        if ($(this).attr("itemtype") == "box") {
                            $(this).attr("prevcolor", $(this).css("background"));
                            $(this).css("background", "rgba(0,0,255,0.5)");
                        }
                    });
                }
                let x = GuiUtils.getEventX(evt);
                let index = parseInt($(this).attr("index"));
                entry = entries[index];
                let thumb = entry.getThumbnail();
                let html = "";
                if (thumb) {
                    html = HU.image(thumb, ["width", "300;"]) + "<br>";
                } else if (entry.isImage()) {
                    html += HU.image(entry.getResourceUrl(), ["width", "300"]) + "<br>";
                }
                html += entry.getIconImage() + " " + entry.getName() + "<br>";
                let start = entry.getStartDate().getUTCFullYear() + "-" + Utils.padLeft(entry.getStartDate().getUTCMonth() + 1, 2, "0") + "-" + Utils.padLeft(entry.getStartDate().getUTCDate(), 2, "0");
                let end = entry.getEndDate().getUTCFullYear() + "-" + Utils.padLeft(entry.getEndDate().getUTCMonth() + 1, 2, "0") + "-" + Utils.padLeft(entry.getEndDate().getUTCDate(), 2, "0");
                html += "Date: " + start + " - " + end + " UTC";
                _this.gridPopup.html(html);
                _this.gridPopup.show();
                _this.gridPopup.position({
                    of: $(this),
                    at: "left bottom",
                    my: "left top",
                    collision: "none none"
                });
                _this.gridPopup.position({
                    of: $(this),
                    my: "left top",
                    at: "left bottom",
                    collision: "none none"
                });
            });
        },
        makeFramework: function(entries) {
            let html = "";
            let mouseInfo = "click:zoom in;shift-click:zoom out;command/ctrl click: reset";
            html += HU.openDiv(["class", "display-grid", "id", this.getDomId(ID_GRID)]);
            html += HU.div(["class", "display-grid-popup ramadda-popup"], "");
            html += HU.openTag("table", ["border", "0", "class", "", "cellspacing", "0", "cellspacing", "0", "width", "100%", "style", "height:100%;"]);
            html += HU.openTag("tr", ["valign", "bottom"]);
            html += HU.tag("td");
            html += HU.tag("td", [], HU.div(["id", this.getDomId(ID_LINKS)], ""));
            html += HU.closeTag("tr");
            html += HU.openTag("tr", ["style", "height:100%;"]);
            html += HU.openTag("td", ["style", "height:100%;"]);
            html += HU.openDiv(["class", "display-grid-axis-left ramadda-noselect", "id", this.getDomId(ID_AXIS_LEFT)]);
            html += HU.closeDiv();
            html += HU.closeDiv();
            html += HU.closeTag("td");
            html += HU.openTag("td", ["style", "height:" + this.getProperty("height", "400") + "px"]);
            html += HU.openDiv(["class", "display-grid-canvas ramadda-noselect", "id", this.getDomId(ID_CANVAS)]);
            html += HU.closeDiv();
            html += HU.closeDiv();
            html += HU.closeTag("td");
            html += HU.closeTag("tr");
            html += HU.openTag("tr", []);
            html += HU.tag("td", ["width", "100"], "&nbsp;");
            html += HU.openTag("td", []);
            html += HU.div(["class", "display-grid-axis-bottom ramadda-noselect", "title", mouseInfo, "id", this.getDomId(ID_AXIS_BOTTOM)], "");
            html += HU.closeTag("table");
            html += HU.closeTag("td");
            return html;
        },


        getXAxisType: function() {
            return this.getProperty(ID_XAXIS_TYPE, "date");
        },
        getYAxisType: function() {
            return this.getProperty(ID_YAXIS_TYPE, "month");
        },
        getXAxisAscending: function() {
            return this.getProperty(ID_XAXIS_ASCENDING, true);
        },
        getYAxisAscending: function() {
            return this.getProperty(ID_YAXIS_ASCENDING, true);
        },
        getXAxisScale: function() {
            return this.getProperty(ID_XAXIS_SCALE, true);
        },
        getYAxisScale: function() {
            return this.getProperty(ID_YAXIS_SCALE, false);
        },


        makeGrid: function(entries) {
            let showIcon = this.getProperty(ID_SHOW_ICON, true);
            let showName = this.getProperty(ID_SHOW_NAME, true);

            if (!this.minDate) {
                let minDate = null;
                let maxDate = null;
                for (let i = 0; i < entries.length; i++) {
                    let entry = entries[i];
                    minDate = minDate == null ? entry.getStartDate() : (minDate.getTime() > entry.getStartDate().getTime() ? entry.getStartDate() : minDate);
                    maxDate = maxDate == null ? entry.getEndDate() : (maxDate.getTime() < entry.getEndDate().getTime() ? entry.getEndDate() : maxDate);
                }
                this.minDate = new Date(Date.UTC(minDate.getUTCFullYear(), 0, 1));
                this.maxDate = new Date(Date.UTC(maxDate.getUTCFullYear() + 1, 0, 1));
            }

            let axis = {
                width: this.canvas.width(),
                height: this.canvas.height(),
                Y: {
                    vertical: true,
                    axisType: this.getYAxisType(),
                    ascending: this.getYAxisAscending(),
                    scale: this.getYAxisScale(),
                    skip: 1,
                    maxTicks: Math.ceil(this.canvas.height() / 80),
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                    ticks: [],
                    lines: "",
                    html: "",
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                },
                X: {
                    vertical: false,
                    axisType: this.getXAxisType(),
                    ascending: this.getXAxisAscending(),
                    scale: this.getXAxisScale(),
                    skip: 1,
                    maxTicks: Math.ceil(this.canvas.width() / 80),
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                    ticks: [],
                    lines: "",
                    html: ""
                }
            }
            if (!this.axis) {
                this.axis = axis;
            } else {
                if (this.axis.X.minDate) {
                    axis.X.minDate = this.axis.X.minDate;
                    axis.X.maxDate = this.axis.X.maxDate;
                } else {
                    this.axis.X.minDate = axis.X.minDate;
                    this.axis.X.maxDate = axis.X.maxDate;
                }
                if (this.axis.Y.minDate) {
                    axis.Y.minDate = this.axis.Y.minDate;
                    axis.Y.maxDate = this.axis.Y.maxDate;
                } else {
                    this.axis.Y.minDate = axis.Y.minDate;
                    this.axis.Y.maxDate = axis.Y.maxDate;
                }
            }

            if (axis.Y.axisType == "size") {
                this.calculateSizeAxis(axis.Y);
            } else if (axis.Y.axisType == "date") {
                this.calculateDateAxis(axis.Y);
            } else {
                this.calculateMonthAxis(axis.Y);
            }
            for (let i = 0; i < axis.Y.ticks.length; i++) {
                let tick = axis.Y.ticks[i];
//                let style = (axis.Y.ascending ? "bottom:" : "top:") + tick.percent + "%;";
                let style = "bottom:" + tick.percent + "%;";
                let lineClass = tick.major ? "display-grid-hline-major" : "display-grid-hline";
                axis.Y.lines += HU.div(["style", style, "class", lineClass], " ");
                axis.Y.html += HU.div(["style", style, "class", "display-grid-axis-left-tick"], tick.label + " " + HU.div(["class", "display-grid-htick"], ""));
            }

            if (axis.X.axisType == "size") {
                this.calculateSizeAxis(axis.X);
            } else if (axis.X.axisType == "date") {
                this.calculateDateAxis(axis.X);
            } else {
                this.calculateMonthAxis(axis.X);
            }
            for (let i = 0; i < axis.X.ticks.length; i++) {
                let tick = axis.X.ticks[i];
                if (tick.percent > 0) {
                    let lineClass = tick.major ? "display-grid-vline-major" : "display-grid-vline";
                    axis.X.lines += HU.div(["style", "left:" + tick.percent + "%;", "class", lineClass], " ");
                }
                axis.X.html += HU.div(["style", "left:" + tick.percent + "%;", "class", "display-grid-axis-bottom-tick"], HU.div(["class", "display-grid-vtick"], "") + " " + tick.label);
            }

            let items = "";
            let seen = {};
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let vInfo = this[axis.Y.calculatePercent].call(this, entry, axis.Y);
                let xInfo = this[axis.X.calculatePercent].call(this, entry, axis.X);
                if (vInfo.p1 < 0) {
                    vInfo.p2 = vInfo.p2 + vInfo.p1;
                    vInfo.p1 = 0;
                }
                if (vInfo.p1 + vInfo.p2 > 100) {
                    vInfo.p2 = 100 - vInfo.p1;
                }

                let style = "";
                let pos = "";

                if (axis.X.ascending) {
                    style += "left:" + xInfo.p1 + "%;";
                    pos += "left:" + xInfo.p1 + "%;";
                } else {
                    style += "right:" + xInfo.p1 + "%;";
                    pos += "left:" + (100 - xInfo.p2) + "%;";
                }

                if (axis.X.scale) {
                    if (xInfo.delta > 1) {
                        style += "width:" + xInfo.delta + "%;";
                    } else {
                        style += "width:" + this.getProperty("fixedWidth", "5") + "px;";
                    }
                }


                let namePos = pos;
                if (axis.Y.ascending) {
                    style += " bottom:" + vInfo.p2 + "%;";
                    pos += " bottom:" + vInfo.p2 + "%;";
                    namePos += " bottom:" + vInfo.p2 + "%;";
                } else {
                    style += " top:" + vInfo.p2 + "%;";
                    pos += " top:" + vInfo.p2 + "%;";
                    namePos += " top:" + vInfo.p2 + "%;";
                    namePos += "margin-top:-15px;"
                }
                if (axis.Y.scale) {
                    if (vInfo.p2 > 1) {
                        style += "height:" + vInfo.delta + "%;";
                    } else {
                        style += "height:" + this.getProperty("fixedHeight", "5") + "px;";
                    }
                }

                if (entry.getName().includes("rilsd")) {
                    console.log("pos:" + namePos);
                }
                if (showIcon) {
                    items += HU.div(["class", "display-grid-entry-icon display-grid-entry", "entryid", entry.getId(), "index", i, "style", pos], entry.getIconImage());
                }
                let key = Math.round(xInfo.p1) + "---" + Math.round(vInfo.p1);
                if (showName && !seen[key]) {
                    seen[key] = true;
                    let name = entry.getName().replace(/ /g, "&nbsp;");
                    items += HU.div(["class", "display-grid-entry-text display-grid-entry", "entryid", entry.getId(), "index", i, "style", namePos], name);
                }
                let boxStyle = style + "background:" + this.getProperty(ID_COLOR, "lightblue");
                items += HU.div(["class", "display-grid-entry-box display-grid-entry", "itemtype", "box", "entryid", entry.getId(), "style", boxStyle, "index", i], "");
            }
            this.jq(ID_AXIS_LEFT).html(axis.Y.html);
            this.jq(ID_CANVAS).html(axis.Y.lines + axis.X.lines + items);
            this.jq(ID_AXIS_BOTTOM).html(axis.X.html);
            this.initGrid(entries);
        },
        calculateSizeAxis: function(axisInfo) {
            let min = Number.MAX_VALUE;
            let max = Number.MIN_VALUE;
            for (let i = 0; i < this.entries.length; i++) {
                let entry = this.entries[i];
                min = Math.min(min, entry.getSize());
                max = Math.max(max, entry.getSize());
            }
        },
        checkOrder: function(axisInfo, percents) {
            /*
            if(!axisInfo.ascending) {
                percents.p1 = 100-percents.p1;
                percents.p2 = 100-percents.p2;
                let tmp  =percents.p1;
                percents.p1=percents.p2;
                percents.p2=tmp;
            }
            */
            return {
                p1: percents.p1,
                p2: percents.p2,
                delta: Math.abs(percents.p2 - percents.p1)
            };
        },
        calculateDatePercent: function(entry, axisInfo) {
            let p1 = 100 * (entry.getStartDate().getTime() - axisInfo.min) / axisInfo.range;
            let p2 = 100 * (entry.getEndDate().getTime() - axisInfo.min) / axisInfo.range;
            return this.checkOrder(axisInfo, {
                p1: p1,
                p2: p2,
                delta: Math.abs(p2 - p1)
            });
        },
        calculateMonthPercent: function(entry, axisInfo) {
            let d1 = entry.getStartDate();
            let d2 = entry.getEndDate();
            let t1 = new Date(Date.UTC(1, d1.getUTCMonth(), d1.getUTCDate()));
            let t2 = new Date(Date.UTC(1, d2.getUTCMonth(), d2.getUTCDate()));
            let p1 = 100 * ((t1.getTime() - axisInfo.min) / axisInfo.range);
            let p2 = 100 * ((t2.getTime() - axisInfo.min) / axisInfo.range);
            if (entry.getName().includes("rilsd")) {
                console.log("t1:" + t1);
                console.log("t2:" + t2);
                console.log("before:" + p1 + " " + p2);
            }
            return this.checkOrder(axisInfo, {
                p1: p1,
                p2: p2,
                delta: Math.abs(p2 - p1)
            });
        },
        calculateMonthAxis: function(axisInfo) {
            axisInfo.calculatePercent = "calculateMonthPercent";
            axisInfo.minDate = new Date(Date.UTC(0, 11, 15));
            axisInfo.maxDate = new Date(Date.UTC(1, 11, 31));
            axisInfo.min = axisInfo.minDate.getTime();
            axisInfo.max = axisInfo.maxDate.getTime();
            axisInfo.range = axisInfo.max - axisInfo.min;
            let months = Utils.getMonthShortNames();
            for (let month = 0; month < months.length; month++) {
                let t1 = new Date(Date.UTC(1, month));
                let percent = (axisInfo.maxDate.getTime() - t1.getTime()) / axisInfo.range;
                if (axisInfo.ascending)
                    percent = 1 - percent;
                axisInfo.ticks.push({
                    percent: 100 * percent,
                    label: months[month],
                    major: false
                });
            }
        },
        calculateDateAxis: function(axisInfo) {
            axisInfo.calculatePercent = "calculateDatePercent";
            let numYears = axisInfo.maxDate.getUTCFullYear() - axisInfo.minDate.getUTCFullYear();
            let years = numYears;
            axisInfo.type = "year";
            axisInfo.skip = Math.max(1, Math.floor(numYears / axisInfo.maxTicks));
            if ((numYears / axisInfo.skip) <= (axisInfo.maxTicks / 2)) {
                let numMonths = 0;
                let tmp = new Date(axisInfo.minDate.getTime());
                while (tmp.getTime() < axisInfo.maxDate.getTime()) {
                    Utils.incrementMonth(tmp);
                    numMonths++;
                }
                axisInfo.skip = Math.max(1, Math.floor(numMonths / axisInfo.maxTicks));
                axisInfo.type = "month";
                if ((numMonths / axisInfo.skip) <= (axisInfo.maxTicks / 2)) {
                    let tmp = new Date(axisInfo.minDate.getTime());
                    let numDays = 0;
                    while (tmp.getTime() < axisInfo.maxDate.getTime()) {
                        Utils.incrementDay(tmp);
                        numDays++;
                    }
                    axisInfo.skip = Math.max(1, Math.floor(numDays / axisInfo.maxTicks));
                    axisInfo.type = "day";
                }
            }


            axisInfo.min = axisInfo.minDate.getTime();
            axisInfo.max = axisInfo.maxDate.getTime();
            axisInfo.range = axisInfo.max - axisInfo.min;
            let months = Utils.getMonthShortNames();
            let lastYear = null;
            let lastMonth = null;
            let tickDate;
            if (axisInfo.type == "year") {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear()));
            } else if (axisInfo.type == "month") {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear(), axisInfo.minDate.getUTCMonth()));
            } else {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear(), axisInfo.minDate.getUTCMonth(), axisInfo.minDate.getUTCDate()));
            }
            //                if(axisInfo.vertical)
            //                    console.log(axisInfo.type+" skip:" + axisInfo.skip + "   min:" + Utils.formatDateYYYYMMDD(axisInfo.minDate)+"   max:" + Utils.formatDateYYYYMMDD(axisInfo.maxDate));
            while (tickDate.getTime() < axisInfo.maxDate.getTime()) {
                let percent = (tickDate.getTime() - axisInfo.minDate.getTime()) / axisInfo.range;
                if (!axisInfo.ascending)
                    percent = (1 - percent);
                percent = 100 * percent;
                //                    console.log("    perc:"+ percent +" " + Utils.formatDateYYYYMMDD(tickDate));
                if (percent >= 0 && percent < 100) {
                    let label = "";
                    let year = tickDate.getUTCFullYear();
                    let month = tickDate.getUTCMonth();
                    let major = false;
                    if (axisInfo.type == "year") {
                        label = year;
                    } else if (axisInfo.type == "month") {
                        label = months[tickDate.getUTCMonth()];
                        if (lastYear != year) {
                            label = label + "<br>" + year;
                            lastYear = year;
                            major = true;
                        }
                    } else {
                        label = tickDate.getUTCDate();
                        if (lastYear != year || lastMonth != month) {
                            label = label + "<br>" + months[month] + " " + year;
                            lastYear = year;
                            lastMonth = month;
                            major = true;
                        }
                    }
                    axisInfo.ticks.push({
                        percent: percent,
                        label: label,
                        major: major
                    });
                }
                if (axisInfo.type == "year") {
                    Utils.incrementYear(tickDate, axisInfo.skip);
                } else if (axisInfo.type == "month") {
                    Utils.incrementMonth(tickDate, axisInfo.skip);
                } else {
                    Utils.incrementDay(tickDate, axisInfo.skip);
                }
            }

        }
    });
}


function RamaddaMetadataDisplay(displayManager, id, properties) {
    if (properties.formOpen == null) {
        properties.formOpen = false;
    }
    let SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_METADATA, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        haveDisplayed: false,
        initDisplay: function() {
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
            SUPER.initDisplay.apply(this);
            if (this.haveDisplayed && this.entryList) {
                this.entryListChanged(this.entryList);
            }
            this.haveDisplayed = true;
        },
        entryListChanged: function(entryList) {
            this.entryList = entryList;
            let entries = this.entryList.getEntries();
            if (entries.length == 0) {
                this.writeMessage("Nothing found");
                return;
            }
	    let html = this.getEntriesMetadata(entries);
            this.writeEntries(html, entries);
            HU.formatTable("#" + this.getDomId("table"), {
                scrollY: 400
            });
        },
    });

}



function RamaddaEntrydisplayDisplay(displayManager, id, properties) {
    let SUPER;
    $.extend(this, {
        sourceEntry: properties.sourceEntry
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ENTRYDISPLAY, properties));
    if (properties.sourceEntry == null && properties.entryId != null) {
        let _this = this;
        let f = async function() {
            await _this.getEntry(properties.entryId, entry => {
                _this.sourceEntry = entry;
                _this.initDisplay()
            });

        }
        f();
    }


    addRamaddaDisplay(this);
    $.extend(this, {
        selectedEntry: null,
        initDisplay: function() {
            this.createUI();
            let title = this.title;
            if (this.sourceEntry != null) {
                this.addEntryHtml(this.sourceEntry);
                let url = this.sourceEntry.getEntryUrl();

                if (title == null) {
                    title = this.sourceEntry.getName();
                }
                title = HU.tag("a", ["href", url, "title", this.sourceEntry.getName(), "alt", this.sourceEntry.getName()], title);
            } else {
                this.addEntryHtml(this.selectedEntry);
                if (title == null) {
                    title = "Entry Display";
                }
            }
            this.setDisplayTitle(title);
        },
        handleEventEntrySelection: function(source, args) {
            //Ignore select events
            if (this.sourceEntry != null) return;
            let selected = args.selected;
            let entry = args.entry;
            if (!selected) {
                if (this.selectedEntry != entry) {
                    //not mine
                    return;
                }
                this.selectedEntry = null;
                this.setContents("");
                return;
            }
            this.selectedEntry = entry;
            this.addEntryHtml(this.selectedEntry);
        },
        getEntries: function() {
            return [this.sourceEntry];
        },
        addEntryHtml: function(entry) {
            if (entry == null) {
                this.setContents("&nbsp;");
                return;
            }
            let html = this.getEntryHtml(entry, {
                showHeader: false
            });
            let height = this.getProperty("height", "400px");
            if (!height.endsWith("px")) height += "px";
            this.setContents(HU.div(["class", "display-entry-description", "style", "height:" + height + ";"],
                html));
            this.entryHtmlHasBeenDisplayed(entry);
        },
    });
}



function RamaddaEntrytitleDisplay(displayManager, id, properties) {
    let SUPER;
    $.extend(this, {
        sourceEntry: properties.sourceEntry
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ENTRYDISPLAY, properties));
    if (properties.sourceEntry == null && properties.entryId != null) {
        let _this = this;
        let f = async function() {
            await _this.getEntry(properties.entryId, entry => {
                _this.sourceEntry = entry;
                _this.initDisplay()
            });
        }
        f();
    }

    let myProps = [
	{label:'Entry Title'},
	{p:'template',ex:'<b>${icon} ${name} Date: ${date} ${start_date} ${end_date} ${entry_attribute...}</b>'},
	{p:'showLink',ex:'false'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	initDisplay: function() {
            this.createUI();
	    let html = "";
	    if(this.sourceEntry) {
		let e = this.sourceEntry;
		html = this.getProperty("template","<b>${icon} ${name} Date: ${date}</b>");
		html = html.replace("${name}",e.getDisplayName());
		html = html.replace("${icon}",e.getIconImage());
		html = html.replace("${date}",this.formatDate(e.getStartDate()));
		html = html.replace("${start_date}",this.formatDate(e.getStartDate()));
		html = html.replace("${end_date}",this.formatDate(e.getEndDate()));
		e.getAttributeNames().map(n=>{
		    html = html.replace("${" + n+"}",e.getAttributeValue(n));
		});
		if(this.getProperty("showLink",true)) {
		    html = HU.href(e.getEntryUrl(),html);
		}
	    }
	    this.displayHtml(html);
        },
	setEntry: function(entry) {
	    this.sourceEntry = entry;
	    this.initDisplay();
	},
        handleEventEntrySelection: function(source, args) {
        },
    });
}





function RamaddaOperandsDisplay(displayManager, id, properties) {
    const ID_SELECT = TAG_SELECT;
    const ID_SELECT1 = "select1";
    const ID_SELECT2 = "select2";
    const ID_NEWDISPLAY = "newdisplay";

    $.extend(this, new RamaddaEntryDisplay(displayManager, id, DISPLAY_OPERANDS, properties));
    addRamaddaDisplay(this);
    $.extend(this, {
        baseUrl: null,
        initDisplay: function() {
            this.createUI();
            this.baseUrl = this.getRamadda().getSearchUrl(this.searchSettings, OUTPUT_JSON);
            if (this.entryList == null) {
                this.entryList = new EntryList(this.getRamadda(), jsonUrl, this);
            }
            let html = "";
            html += HU.div([ATTR_ID, this.domId(ID_ENTRIES), ATTR_CLASS, this.getClass("entries")], "");
            this.setContents(html);
        },
        entryListChanged: function(entryList) {
            let html = "<form>";
            html += "<p>";
            html += HU.openTag(TAG_TABLE, [ATTR_CLASS, "formtable", "cellspacing", "0", "cellspacing", "0"]);
            let entries = this.entryList.getEntries();
            let get = this.getGet();

            for (let j = 1; j <= 2; j++) {
                let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_SELECT + j)]);
                select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""],
                    "-- Select --");
                for (let i = 0; i < entries.length; i++) {
                    let entry = entries[i];
                    let label = entry.getIconImage() + " " + entry.getName();
                    select += HU.tag(TAG_OPTION, [ATTR_TITLE, entry.getName(), ATTR_VALUE, entry.getId()],
                        entry.getName());

                }
                select += HU.closeTag(TAG_SELECT);
                html += HU.formEntry("Data:", select);
            }

            let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_CHARTTYPE)]);
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "linechart"],
                "Line chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "barchart"],
                "Bar chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "barstack"],
                "Stacked bars");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "bartable"],
                "Bar table");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "piechart"],
                "Pie chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "scatterplot"],
                "Scatter Plot");
            select += HU.closeTag(TAG_SELECT);
            html += HU.formEntry("Chart Type:", select);

            html += HU.closeTag(TAG_TABLE);
            html += "<p>";
            html += HU.tag(TAG_DIV, [ATTR_CLASS, "display-button", ATTR_ID, this.getDomId(ID_NEWDISPLAY)], "New Chart");
            html += "<p>";
            html += "</form>";
            this.writeEntries(html);
            let theDisplay = this;
            this.jq(ID_NEWDISPLAY).button().click(function(event) {
                theDisplay.createDisplay();
            });
        },
        createDisplay: function() {
            let entry1 = this.getEntry(this.jq(ID_SELECT1).val());
            let entry2 = this.getEntry(this.jq(ID_SELECT2).val());
            if (entry1 == null) {
                alert("No data selected");
                return;
            }
            let pointDataList = [];

            pointDataList.push(new PointData(entry1.getName(), null, null, ramaddaBaseUrl + "/entry/show?&output=points.product&product=points.json&numpoints=1000&entryid=" + entry1.getId()));
            if (entry2 != null) {
                pointDataList.push(new PointData(entry2.getName(), null, null, ramaddaBaseUrl + "/entry/show?&output=points.product&product=points.json&numpoints=1000&entryid=" + entry2.getId()));
            }

            //Make up some functions
            let operation = "average";
            let derivedData = new DerivedPointData(this.displayManager, "Derived Data", pointDataList, operation);
            let pointData = derivedData;
            let chartType = this.jq(ID_CHARTTYPE).val();
            displayManager.createDisplay(chartType, {
                "layoutFixed": false,
                "data": pointData
            });
        }

    });
}


function RamaddaRepositoriesDisplay(displayManager, id, properties) {
    RamaddaUtil.inherit(this, new RamaddaEntryDisplay(displayManager, id, DISPLAY_REPOSITORIES, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        initDisplay: function() {
            let theDisplay = this;
            this.createUI();
            let html = "";
            if (this.ramaddas.length == 0) {
                html += this.getMessage("No repositories specified");
            } else {
                html += this.getMessage("Loading repository listing");
            }
            this.numberWithTypes = 0;
            this.finishedInitDisplay = false;
            //Check for and remove the all repositories
            if (this.ramaddas.length > 1) {
                if (this.ramaddas[this.ramaddas.length - 1].getRoot() == "all") {
                    this.ramaddas.splice(this.ramaddas.length - 1, 1);
                }
            }
            for (let i = 0; i < this.ramaddas.length; i++) {
                if (i == 0) {}
                let ramadda = this.ramaddas[i];
                let types = ramadda.getEntryTypes(function(ramadda, types) {
                    theDisplay.gotTypes(ramadda, types);
                });
                if (types != null) {
                    this.numberWithTypes++;
                }
            }
            this.setDisplayTitle("Repositories");
            this.setContents(html);
            this.finishedInitDisplay = true;
            this.displayRepositories();
        },
        displayRepositories: function() {
            if (!this.finishedInitDisplay || this.numberWithTypes != this.ramaddas.length) {
                return;
            }
            let typeMap = {};
            let allTypes = [];
            let html = "";
            html += HU.openTag(TAG_TABLE, [ATTR_CLASS, "display-repositories-table", ATTR_WIDTH, "100%", ATTR_BORDER, "1", "cellspacing", "0", "cellpadding", "5"]);
            for (let i = 0; i < this.ramaddas.length; i++) {
                let ramadda = this.ramaddas[i];
                let types = ramadda.getEntryTypes();
                for (let typeIdx = 0; typeIdx < types.length; typeIdx++) {
                    let type = types[typeIdx];
                    if (typeMap[type.getId()] == null) {
                        typeMap[type.getId()] = type;
                        allTypes.push(type);
                    }
                }
            }

            html += HU.openTag(TAG_TR, ["valign", "bottom"]);
            html += HU.th([ATTR_CLASS, "display-repositories-table-header"], "Type");
            for (let i = 0; i < this.ramaddas.length; i++) {
                let ramadda = this.ramaddas[i];
                let link = HU.href(ramadda.getRoot(), ramadda.getName());
                html += HU.th([ATTR_CLASS, "display-repositories-table-header"], link);
            }
            html += "</tr>";

            let onlyCats = [];
            if (this.categories != null) {
                onlyCats = this.categories.split(",");
            }



            let catMap = {};
            let cats = [];
            for (let typeIdx = 0; typeIdx < allTypes.length; typeIdx++) {
                let type = allTypes[typeIdx];
                let row = "";
                row += "<tr>";
                row += HU.td([], HU.image(type.getIcon()) + " " + type.getLabel());
                for (let i = 0; i < this.ramaddas.length; i++) {
                    let ramadda = this.ramaddas[i];
                    let repoType = ramadda.getEntryType(type.getId());
                    let col = "";
                    if (repoType == null) {
                        row += HU.td([ATTR_CLASS, "display-repositories-table-type-hasnot"], "");
                    } else {
                        let label =
                            HU.tag(TAG_A, ["href", ramadda.getRoot() + "/search/type/" + repoType.getId(), "target", "_blank"],
                                repoType.getEntryCount());
                        row += HU.td([ATTR_ALIGN, "right", ATTR_CLASS, "display-repositories-table-type-has"], label);
                    }

                }
                row += "</tr>";

                let catRows = catMap[type.getCategory()];
                if (catRows == null) {
                    catRows = [];
                    catMap[type.getCategory()] = catRows;
                    cats.push(type.getCategory());
                }
                catRows.push(row);
            }

            for (let i = 0; i < cats.length; i++) {
                let cat = cats[i];
                if (onlyCats.length > 0) {
                    let ok = false;
                    for (let patternIdx = 0; patternIdx < onlyCats.length; patternIdx++) {
                        if (cat == onlyCats[patternIdx]) {
                            ok = true;
                            break;
                        }
                        if (cat.match(onlyCats[patternIdx])) {
                            ok = true;
                            break;

                        }
                    }
                    if (!ok) continue;

                }
                let rows = catMap[cat];
                html += "<tr>";
                html += HU.th(["colspan", "" + (1 + this.ramaddas.length)], cat);
                html += "</tr>";
                for (let row = 0; row < rows.length; row++) {
                    html += rows[row];
                }

            }


            html += HU.closeTag(HU.TAG_TABLE);
            this.setContents(html);
        },
        gotTypes: function(ramadda, types) {
            this.numberWithTypes++;
            this.displayRepositories();
        }
    });
}


/**
Copyright 2008-2021 Geode Systems LLC
*/


//uncomment this to add this type to the global list
//addGlobalDisplayType({type: "example", label:"Example"});


/*
  This gets created by the displayManager.createDisplay('example')
 */
function RamaddaExampleDisplay(displayManager, id, properties) {

    //Dom id for example
    //The displays use display.getDomId(ID_CLICK) to get a unique (based on the display id) id
    var ID_CLICK = "click";

    var ID_DATA = "data";

    //Create the base class
    RamaddaUtil.inherit(this, new RamaddaDisplay(displayManager, id, "example", properties));

    //Add this display to the list of global displays
    addRamaddaDisplay(this);

    //Define the methods
    RamaddaUtil.defineMembers(this, {
        //gets called by displaymanager after the displays are layed out
        initDisplay: function() {
            //Call base class to init menu, etc
            this.createUI();

            //I've been calling back to this display with the following
            //this returns "getRamaddaDisplay('" + this.getId() +"')";
            var get = this.getGet();
            var html = "<p>";
            html += HtmlUtils.onClick(get + ".click();", HtmlUtils.div([ATTR_ID, this.getDomId(ID_CLICK)], "Click me"));
            html += "<p>";
            html += HtmlUtils.div([ATTR_ID, this.getDomId(ID_DATA)], "");

            //Set the contents
            this.setContents(html);

            //Add the data
            this.updateUI();
        },
        //this tells the base display class to loadInitialData
        needsData: function() {
            return true;
        },
        //this gets called after the data has been loaded
        updateUI: function() {
            var pointData = this.getData();
            if (pointData == null) return;
            var recordFields = pointData.getRecordFields();
            var records = pointData.getRecords();
            var html = "";
            html += "#records:" + records.length;
            //equivalent to:
            //$("#" + this.getDomId(ID_DATA)).html(html);
            this.jq(ID_DATA).html(html);
        },
        //this gets called when an event source has selected a record
        handleEventRecordSelection: function(source, args) {
            //args: index, record, html
            //this.setContents(args.html);
        },
        click: function() {
            this.jq(ID_CLICK).html("Click again");
        }
    });
}/**
   Copyright 2008-2021 Geode Systems LLC
*/

const DISPLAY_MAP = "map";
const DISPLAY_MAPGRID = "mapgrid";
const DISPLAY_MAPCHART = "mapchart";
const DISPLAY_MAPARRAY = "maparray";
const DISPLAY_MAPSHRINK = "mapshrink";
const DISPLAY_MAPIMAGES = "mapimages";

let displayMapMarkers = ["marker.png", "marker-blue.png", "marker-gold.png", "marker-green.png"];
let displayMapCurrentMarker = -1;
let displayMapUrlToVectorListeners = {};
let displayMapMarkerIcons = {};



addGlobalDisplayType({
    type: DISPLAY_MAP,
    label: "Map",
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Maps of many colors",["map1.png","map2.png"],"Lots of ways to show georeferenced data - dots, heatmaps, plots, etc"),        
});

addGlobalDisplayType({
    type: DISPLAY_MAPGRID,
    label: "Map Grid",
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Schematic map grid","mapgrid.png","Can display US States or World countries"),    
});

addGlobalDisplayType({
    type: DISPLAY_MAPCHART,
    label: "Map Chart",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("2.5D display in a map","mapchart.png","Plot numeric data as heights. Can display US States, European countries or world countries"),        
});


addGlobalDisplayType({
    type: DISPLAY_MAPSHRINK,
    label: "Map Shrink",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Show values as relative size of map regions","mapshrink.png","Can display US States, European countries or world countries"),            
});


addGlobalDisplayType({
    type: DISPLAY_MAPARRAY,
    label: "Map Array",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Colored map regions displayed separately","maparray.png","Can display US States, European countries or world countries"),                
});
addGlobalDisplayType({
    type: DISPLAY_MAPIMAGES,
    label: "Map Images",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Display images in map regions","mapimage.png","Can display US States, European countries or world countries"),                    
});




function MapFeature(source, points) {
    RamaddaUtil.defineMembers(this, {
        source: source,
        points: points
    });
}

var ID_MAP = "map";

function RamaddaBaseMapDisplay(displayManager, id, type,  properties) {
    $.extend(this, {
        theMap: null
    });


    const SUPER = new RamaddaDisplay(displayManager, id, type,   properties);
    RamaddaUtil.inherit(this,SUPER);
    this.defineSizeByProperties();
    let myProps = [
	{label:'Base Map Properties'},
	{p:'bounds',ex:'north,west,south,east',tt:'initial bounds'},
	{p:'gridBounds',ex:'north,west,south,east'},	
	{p:'mapCenter',ex:'lat,lon',tt:"initial position"},
	{p:'zoomLevel',ex:4,tt:"initial zoom"},
	{p:'zoomTimeout',ex:500,tt:"initial zoom timeout delay. set this if the map is in tabs, etc, and not going to the initial zoom"},
	{p:'linked',ex:true,tt:"Link location with other maps"},
	{p:'linkGroup',ex:'some_name',tt:"Map groups to link with"},
	{p:'initialLocation', ex:'lat,lon',tt:"initial location"},
	{p:'defaultMapLayer',ex:'ol.openstreetmap|esri.topo|esri.street|esri.worldimagery|esri.lightgray|esri.physical|opentopo|usgs.topo|usgs.imagery|usgs.relief|osm.toner|osm.toner.lite|watercolor'},
	{p:'mapLayers',ex:'ol.openstreetmap,esri.topo,esri.street,esri.worldimagery,esri.lightgray,esri.physical,opentopo,usgs.topo,usgs.imagery,usgs.relief,osm.toner,osm.toner.lite,watercolor'},
	{p:'extraLayers',tt:'comma separated list of layers to display'},
	{p:'annotationLayerTop',ex:'true',tt:'If showing the extra annotation layer put it on top'},
	{p:'showLocationSearch',ex:'true'},
	{p:'showLatLonPosition',ex:'false'},
	{p:'showLayerSwitcher',ex:'false'},
	{p:'showScaleLine',ex:'true'},
	{p:'showZoomPanControl',ex:'true'},
	{p:'showZoomOnlyControl',ex:'false'},
	{p:'enableDragPan',ex:'false'},
	{p:'showLayers',d:true,ex:'false'},
	{p:'locations',ex:'usairports.json,usstates.json'},
	{p:'highlightColor',ex:'#ccc',tt:''},
	{p:'highlightFillColor',ex:'#ccc',tt:''},	
	{p:'highlightStrokeWidth',ex:'2',tt:''},	
];
    
    displayDefineMembers(this, myProps, {
        mapBoundsSet: false,
        initDisplay: function() {
            SUPER.initDisplay.call(this);
	    if(!HU.documentReady) {
		$( document ).ready(()=> {
		    if(this.map) {
			setTimeout(()=>{
			    this.callingUpdateSize = true;
			    this.map.getMap().updateSize();
			    this.callingUpdateSize = false;
			},50);
		    }
		});
	    }
            var _this = this;
            var html = "";
            var extraStyle="";
            var height = this.getProperty("height", this.getProperty("mapHeight", 300));
            if (height < 0) {
		height = (-height)+"%";
	    }
	    height = HU.getDimension(height);
            extraStyle += HU.css(HEIGHT, height);

	    let map =HU.div(["tabindex","1",ATTR_CLASS, "display-map-map ramadda-expandable-target", STYLE,
			     extraStyle, ATTR_ID, this.domId(ID_MAP)]);

	    let mapContainer = HU.div([CLASS,"ramadda-map-container"],
				      map+
				      HU.div([CLASS,"ramadda-map-slider",STYLE,this.getProperty("popupSliderStyle", "max-height:400px;overflow-y:auto;max-width:300px;overflow-x:auto;"),ID,this.domId(ID_MAP)+"_slider"]));

            this.setContents(mapContainer);
    
            if (!this.map) {
                this.createMap();
            } else {
                this.map.setMapDiv(this.domId(ID_MAP));
            }
            if (!this.haveCalledUpdateUI) {
                var callback = function() {
                    _this.updateUI();
                }
                setTimeout(callback, 1);
            }
        },
	setErrorMessage: function(msg) {
	    if(this.map)
		this.map.setProgress(HU.div([ATTR_CLASS, "display-map-message"], msg));
	    else
		SUPER.setErrorMessage.call(this,msg);
	},
	setMessage: function(msg) {
	    if(this.map) {
		if(msg!="")
		    msg = HU.div([ATTR_CLASS, "display-map-message"], msg);
		this.map.setProgress(msg);
	    }
	},
	setMapLabel: function(msg) {
	    if(this.map)
		this.map.setLabel(HU.div([ATTR_CLASS, "display-map-message"], msg));
	},	
	startProgress: function() {
	    this.setMessage(this.getProperty("loadingMessage","Creating map..."));
	},
	clearProgress: function() {
	    if(this.errorMessage) {
		this.errorMessage = null;
		return;
	    }
	    if(this.map)
		this.map.setProgress("");
	},

        checkLayout: function() {
            if (!this.map) {
                return;
            }
            var d = this.jq(ID_MAP);
            if (d.width() > 0 && this.lastWidth != d.width() && this.map) {
                this.lastWidth = d.width();
                this.map.getMap().updateSize();
            }
	    if(!this.setMapLocationAndZoom && this.mapParams) {
		this.setMapLocationAndZoom = true;
		if(this.mapParams.initialZoom>=0) {
		    this.map.getMap().zoomTo(this.mapParams.initialZoom);
		}
		if(this.mapParams.initialLocation) {
		    let loc = MapUtils.createLonLat(this.mapParams.initialLocation.lon, this.mapParams.initialLocation.lat);
		    this.map.setCenter(loc);
		}

	    }
        },

        initMapParams: function(params) {
	    if(this.getProperty("showOpacitySlider")||true) {
		params.showOpacitySlider=true;
	    }
	},
	initMap:function(map) {
	},
        doDisplayMap: function() {
	    return true;
	},
        createMap: function() {
            let _this = this;
            var params = {
                defaultMapLayer: this.getDefaultMapLayer(map_default_layer),
		showLayerSwitcher: this.getShowLayerSwitcher(true),
		showScaleLine: this.getShowScaleLine(false),
		showLatLonPosition: this.getShowLatLonPosition(true),
		showZoomPanControl: this.getShowZoomPanControl(false),
		showZoomOnlyControl: this.getShowZoomOnlyControl(true),
		enableDragPan: this.getEnableDragPan(true),
		highlightColor: this.getHighlightColor("blue"),
		highlightFillColor: this.getHighlightFillColor("transparent"),		
		highlightStrokeWidth: this.getHighlightStrokeWidth(1),
		showLatLonLines:this.getProperty("showLatLonLines")
            };
	    this.mapParams = params;
            var displayDiv = this.getProperty("displayDiv", null);
            if (displayDiv) {
                params.displayDiv = displayDiv;
		params.displayDivSticky = this.getProperty("displayDivSticky", false);
            }
            if (!this.getShowLocationSearch(true)) {
                params.showLocationSearch = false;
            }
            var mapLayers = this.getMapLayers(null);
            if (mapLayers) {
                params.mapLayers = [mapLayers];
            }

	    params.linked = this.getLinked(false);
	    params.linkGroup = this.getLinkGroup(null);

	    this.hadInitialPosition = false;
            if (this.getProperty("latitude")) {
		this.hadInitialPosition = true;
                params.initialLocation = {lon:+this.getProperty("longitude", -105),
					  lat:+this.getProperty("latitude", 40)};
	    }
	    if(this.getMapCenter()) {
		this.hadInitialPosition = true;
		[lat,lon] =  this.getMapCenter().split(",");
                params.initialLocation = {lon:lon,lat:lat};
	    }

	    if(this.getZoomLevel()) {
		this.hadInitialPosition = true;
                params.initialZoom = +this.getZoomLevel();
		params.initialZoomTimeout = this.getZoomTimeout();
	    }

            this.map = this.getProperty("theMap", null);
            if (this.map) {
                this.map.setMapDiv(this.domId(ID_MAP));
            } else {
		if(this.getInitialLocation()) {
		    let toks = this.getInitialLocation().split(",");
		    params.initialLocation = {
			lat:+toks[0],
			lon:+toks[1]
		    }
		}
		this.initMapParams(params);

                this.map = new RepositoryMap(this.domId(ID_MAP), params);
		//Set this so there is no popup on the off feature
		this.map.textGetter = (layer,feature) =>{
		    return null;
		};
                this.lastWidth = this.jq(ID_MAP).width();
            }
	    this.initMap(this.map);

            if (this.doDisplayMap()) {
                this.map.setDefaultCanSelect(false);
            }
            this.map.initMap(false);

	    let hasLoc = Utils.isDefined(this.getZoomLevel())   ||
		Utils.isDefined(this.getMapCenter()) ||
		this.hadInitialPosition;
	    
            if (this.getPropertyBounds() ||this.getPropertyGridBounds() ) {
		this.hadInitialPosition = true;
                let toks = this.getPropertyBounds(this.getGridBounds("")).split(",");
                if (toks.length == 4) {
                    if (this.getProperty("showBounds", false)) {
                        var attrs = {};
                        if (this.getProperty("boundsColor")) {
                            attrs.strokeColor = this.getProperty("boundsColor", "");
                        }
                        this.map.addRectangle("bounds", parseFloat(toks[0]), parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]), attrs, "");
                    }
		    if(!hasLoc)
			this.setInitMapBounds(parseFloat(toks[0]), parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]));
                }
            }

	    
	    if(this.getProperty("annotationLayer")) {
		let opts = {theMap:this.map,
			    embedded:true,
			    displayOnly:true,
			   };
		if(this.getPropertyAnnotationLayerTop()) {
		    opts.layerIndex = 100;
		}

		this.editableMap = new  RamaddaEditablemapDisplay(this.getDisplayManager(),HU.getUniqueId(""),opts);
		this.editableMap.initDisplay(true);
		this.editableMap.loadMap(this.getProperty("annotationLayer"));
	    }
	    
	    this.getProperty("extraLayers","").split(",").forEach(tuple=>{
		if(tuple.trim().length==0) return;
		let toks = tuple.split(":");
		toks = toks.map(tok=>{return tok.replace(/_semicolon_/g,":")});
		let getUrl = url =>{
		    if(url.startsWith("resources")) {
			url = ramaddaBaseUrl +"/" + url;
		    } else if(url.startsWith("/resources")) {
			url = ramaddaBaseUrl + url;			
		    } else    if(!url.startsWith("/") && !url.startsWith("http")) {
			url = ramaddaBaseUrl +"/entry/get?entryid=" + url;
		    }
		    return url;
		};

		let type = toks[0];
		if(type=="baselayer") {
		    let layer = this.map.getBaseLayer(toks[1]);
		    if(!layer) {
			console.log("Could not find base layer:" + toks[1]);
		    } else {
			layer.setVisibility(true);
		    }
		} else 	if(type=="geojson" || type=="kml") {
		    let name = toks[1];		
		    let url = getUrl(toks[2]);
//		    console.log("Adding geojson:" + url);
		    let args = {
			fillColor:'transparent',
		    }
		    for(let i=3;i<toks.length;i+=2) {
			args[toks[i]] = toks[i+1];
		    }
		    //(name, url, canSelect, selectCallback, unselectCallback, args, loadCallback, zoomToExtent)
		    if(type=="kml") {
			this.map.addKmlLayer(name, url, false, null, null, args, null);
		    } else {
			this.map.addGeoJsonLayer(name, url, false, null, null, args, null);
		    }
		} else if(type=="wms") {
		    let name = toks[1];
		    let url = toks[2];
		    let layer=toks[3];
		    let opacity = toks[4];
                    this.map.addWMSLayer(name,url,layer, false,true,{opacity:opacity});
		  //  "wms:ESRI Aeronautical,https://wms.chartbundle.com/mp/service,sec",
		} else {
		    console.log("Unknown map type:" + type)
		}
	    });


            if (this.getShowLayers()) {
		//do this later so the map displays its initial location OK
		setTimeout(()=>{
                    if (_this.getProperty("kmlLayer")) {
			var url = ramaddaBaseUrl + "/entry/show?output=shapefile.kml&entryid=" + _this.getProperty("kmlLayer");
			_this.addBaseMapLayer(url, true);
                    }
                    if (_this.getProperty("geojsonLayer")) {
			url = _this.getRamadda().getEntryDownloadUrl(_this.getProperty("geojsonLayer"));
			_this.addBaseMapLayer(url, false);
                    }
		},500);
            }
        },
        getBounds: function() {
	    return this.map.getBounds();
	},
    });
}
	


function RamaddaMapDisplay(displayManager, id, properties) {
    const ID_MAP = "map";
    const ID_MAP_SLIDER = "map_slider";    
    const ID_LATFIELD = "latfield";
    const ID_LONFIELD = "lonfield";
    const ID_SIZEBY_LEGEND = "sizebylegend";
    const ID_COLORTABLE_SIDE = "colortableside";
    const ID_SHAPES = "shapes";
    const ID_HEATMAP_ANIM_LIST = "heatmapanimlist";
    const ID_HEATMAP_ANIM_PLAY = "heatmapanimplay";
    const ID_HEATMAP_ANIM_STEP = "heatmapanimstep";
    const ID_HEATMAP_TOGGLE = "heatmaptoggle";    
    const ID_REGION_SELECTOR = "regionselector";
    const ID_HTMLLAYER = "htmllayer";
    const ID_TRACK_VIEW = "trackview";

    $.extend(this, {
        showBoxes: true,
        showPercent: false,
        percentFields: null,
        kmlLayer: null,
        kmlLayerName: "",
        geojsonLayer: null,
        geojsonLayerName: "",
        theMap: null
    });


    const SUPER = new RamaddaBaseMapDisplay(displayManager, id, DISPLAY_MAP, properties);
    RamaddaUtil.inherit(this,SUPER);
    addRamaddaDisplay(this);
    this.defineSizeByProperties();
    let myProps = [
	{label:'Map Properties'},
	{p:'strokeWidth',d:1},
	{p:'strokeColor',d:'#000'},
	{p:"fillColor",d:"blue"},
	{p:"fillOpacity",d:0.5},
	{p:'radius',d:5,tt:"Size of the map points"},
	{p:'scaleRadius',ex:"true",tt:'Scale the radius based on # points shown'},
	{p:'radiusScale',ex:"value,size,value,size e.g.: 10000,1,8000,2,5000,3,2000,3,1000,5,500,6,250,8,100,10,50,12",tt:'Radius scale'},
	{p:'maxRadius',ex:"16",d:1000},
	{p:'shape',d:'circle',ex:'plane|star|cross|x|square|triangle|circle|lightning|church',tt:'Use shape'},
	{p:'markerIcon',ex:"/icons/..."},
	{p:'iconSize',ex:16},
	{p:'justOneMarker',ex:"true",tt:'This is for data that is all at one point and you want to support selecting points for other displays'},	
	{p:'showPoints',ex:'true',tt:'Also show the map points when showing heatmap or glyphs'},
	{p:'bounds',ex:'north,west,south,east',tt:'initial bounds'},
	{p:'gridBounds',ex:'north,west,south,east'},	
	{p:'mapCenter',ex:'lat,lon',tt:"initial position"},
	{p:'zoomLevel',ex:4,tt:"initial zoom"},
	{p:'zoomTimeout',ex:500,tt:"initial zoom timeout delay. set this if the map is in tabs, etc, and not going to the initial zoom"},
	{p:'fixedPosition',ex:true,tt:'Keep the initial position'},
	{p:'linked',ex:true,tt:"Link location with other maps"},
	{p:'linkGroup',ex:'some_name',tt:"Map groups to link with"},

	{p:'initialLocation', ex:'lat,lon',tt:"initial location"},
	{p:'defaultMapLayer',ex:'ol.openstreetmap|esri.topo|esri.street|esri.worldimagery|esri.lightgray|esri.physical|opentopo|usgs.topo|usgs.imagery|usgs.relief|osm.toner|osm.toner.lite|watercolor'},
	{p:'mapLayers',ex:'ol.openstreetmap,esri.topo,esri.street,esri.worldimagery,esri.lightgray,esri.physical,opentopo,usgs.topo,usgs.imagery,usgs.relief,osm.toner,osm.toner.lite,watercolor'},
	{p:'extraLayers',tt:'comma separated list of layers to display',
	 ex:'baselayer:goes-visible,baselayer:nexrad,geojson:US States:/resources/usmap.json:fillColor:transparent'},
	{p:'doPopup', ex:'false',tt:"Don't show popups"},
	{p:'doPopupSlider', ex:'true',tt:"Do the inline popup that slides down"},
	{p:'popupSliderRight', ex:'true',tt:"Position the inline slider to the right"},	
	{p:'popupSliderStyle', ex:'max-width:300px;overflow-x:auto;',tt:""},	
	{p:'labelField',ex:'',tt:'field to show in TOC'},
	{p:'showRegionSelector',ex:true},
	{p:'regionSelectorLabel'},	
	{p:'showBaseLayersSelect',ex:true},
	{p:'centerOnFilterChange',ex:true,tt:'Center map when the data filters change'},
	{p:'centerOnHighlight',ex:true,tt:'Center map when a record is highlighted'},
	{p:'boundsAnimation',ex:true,tt:'Animate when map is centered'},
	{p:'iconField',ex:'""',tt:'Field id for the image icon url'},
	{p:'rotateField',ex:'""',tt:'Field id for degrees rotation'},	

	{label:"Map GUI"},
	{p:'showTableOfContents',ex:'true',tt:'Show left table of contents'},
	{p:'tableOfContentsTitle'},
	{p:'showMarkersToggle',ex:'true',tt:'Show the toggle checkbox for the marker layer'},
	{p:'showMarkersToggleLabel',ex:'label',tt:'Label to use for checkbox'},
	{p:'showClipToBounds',ex:'true',tt:'Show the clip bounds checkbox'},
	{p:'clipToBounds',ex:'true',tt:'Clip to bounds'},	
	{p:'showMarkers',ex:'false',tt: 'Hide the markers'},

	{label:'Map Highlight'},
	{p:'showRecordSelection',ex:'false'},
	{p:'highlight',ex:'true',tt:"Show mouse over highlights"},
	{p:'displayDiv',tt:'Div id to show highlights in'},
	{p:'recordHighlightShape',ex:'circle|star|cross|x|square|triangle|circle|lightning|rectangle'},
	{p:'recordHighlightRadius',ex:'20',tt:'Radius to use to show other displays highlighted record'},
	{p:'recordHighlightStrokeWidth',ex:'2',tt:'Stroke to use to show other displays highlighted record'},
	{p:'recordHighlightStrokeColor',ex:'red',tt:'Color to use to show other displays highlighted record'},
	{p:'recordHighlightFillColor',ex:'rgba(0,0,0,0)',tt:'Fill color to use to show other displays highlighted record'},
	{p:'recordHighlightFillOpacity',ex:'0.5',tt:'Fill opacity to use to show other displays highlighted record'},
	{p:'recordHighlightVerticalLine',tt:'Draw a vertical line at the location of the selected record'},
	{p:'highlightColor',ex:'#ccc',tt:''},
	{p:'highlightFillColor',ex:'#ccc',tt:''},	
	{p:'highlightStrokeWidth',ex:'2',tt:''},	
	{p:'unhighlightColor',ex:'#ccc',tt:'Fill color when records are unhighlighted with the filters'},
	{p:'unhighlightStrokeWidth',ex:'1',tt:'Stroke width for when records are unhighlighted with the filters'},
	{p:'unhighlightStrokeColor',ex:'#aaa',tt:'Stroke color for when records are unhighlighted with the filters'},
	{p:'unhighlightRadius',ex:'1',tt:'Radius for when records are highlighted with the filters'},

	{label:'Map Vectors'},
	{p:'vectorLayerStrokeColor',ex:'#000'},
	{p:'vectorLayerFillColor',ex:'#ccc'},
	{p:'vectorLayerFillOpacity',ex:'0.25'},
	{p:'vectorLayerStrokeWidth',ex:'1'},

	{label:"Map Collisions"},
	{p:'handleCollisions',ex:'true',tt:"Handle point collisions"},
	{p:'collisionFixed',d:false,ex:'false',tt:"Always show markers"},
	{p:'collisionMinPixels',d:16,ex:'16',tt:"How spread out"},
	{p:'collisionDotColor',ex:'red',tt:"Color of dot drawn at center"},
	{p:'collisionDotRadius',ex:'3',tt:"Radius of dot drawn at center"},
	{p:'collisionScaleDots',ex:'false',d:true,tt:"Scale the group dots"},					
	{p:'collisionLineColor',ex:'red',tt:"Color of line drawn at center"},
	{p:'collisionIcon',ex:'/icons/...',tt:"Use an icon for collisions"},
	{p:'collisionIconSize',d:16,ex:'16'},
	{p:'collisionTooltip',ex:'${default}',tt:"Tooltip to use for collision dot"},


	{label:"Map Lines"},
	{p:'showSegments',ex:'true',tt:'If data has 2 lat/lon locations draw a line'},
	{p:'isPath',ex:'true',tt:'Make a path from the points'},	
	{p:'pathWidth',ex:'2'},
	{p:'pathColor',ex:'red'},	
	{p:'isTrajectory',ex:'true',tt:'Make a path from the points'},	
	{p:'showPathEndPoint',ex:true},
	{p:'pathEndPointShape',ex:'arrow'},
	{p:'latField1',tt:'Field id for segments'},
	{p:'lonField1',tt:'Field id for segments'},
	{p:'latField2',tt:'Field id for segments'},
	{p:'lonField2',tt:'Field id for segments'},
	{p:'trackUrlField',ex:'field id',tt:'The data can contain a URL that points to data'},

	{label:"Map Labels"},
	{p:"labelTemplate",ex:"${field}",tt:"Display labels in the map"},
	{p:"labelKeyField",ex:"field",tt:"Make a key, e.g., A, B, C, ... based on the value of the key field"},	
	{p:"labelLimit",ex:"1000",tt:"Max number of records to display labels"},
  	{p:"doLabelGrid",ex:"true",tt:"Use a grid to determine if a label should be shown"},		
	{p:"labelFontColor",ex:"#000"},
	{p:"labelFontSize",ex:"12px"},
	{p:"labelFontFamily",ex:"'Open Sans', Helvetica Neue, Arial, Helvetica, sans-serif"},
	{p:"labelFontWeight",ex:"plain"},
	{p:"labelAlign",ex:"l|c|r t|m|b"},
	{p:"labelXOffset",ex:"0"},
	{p:"labelYOffset",ex:"0"},
	{p:"labelOutlineColor",ex:"#fff"},
	{p:"labelOutlineWidth",ex:"0"},


	{label:'Map Glyphs'},
	{p:'doGridPoints',ex:'true',tt:'Display a image showing shapes or bars'},
	{p:'gridWidth',ex:'800',tt:'Width of the canvas'},
	{label:'label glyph',p:"glyph1",ex:"type:label,pos:sw,dx:10,dy:-10,label:field_colon_ ${field}_nl_field2_colon_ ${field2}"},
	{label:'rect glyph', p:"glyph1",ex:"type:rect,pos:sw,dx:10,dy:0,colorBy:field,width:150,height:100"},
	{label:'circle glyph',p:"glyph1",ex:"type:circle,pos:n,dx:10,dy:-10,fill:true,colorBy:field,width:20,baseWidth:5,sizeBy:field"},
	{label:'3dbar glyph', p:"glyph1",ex:"type:3dbar,pos:sw,dx:0,dy:0,height:30,width:6,baseHeight:5,sizeBy:field"},
	{label:'gauge glyph',p:"glyph1",ex:"type:gauge,color:#000,pos:sw,width:50,height:50,dx:10,dy:-10,sizeBy:field,sizeByMin:0"},

	{label:'Heatmap'},
	{p:'doHeatmap',ex:'true',tt:'Grid the data into an image'},
	{p:'hmShowPoints',ex:'true',tt:'Also show the map points'},
	{p:'hmShowReload',ex:'true',tt:''},
	{p:'hmShowGroups',ex:'true',tt:''},
	{p:'hmBounds',ex:'north,west,south,east',tt:''},
	{p:'htmlLayerField'},
	{p:'htmlLayerShape',ex:'barchart|piechart'},	
	{p:'htmlLayerWidth',ex:'30'},
	{p:'htmlLayerHeight',ex:'15'},
	{p:'htmlLayerStyle',ex:'css style'},
	{p:'htmlLayerScale',ex:'2:0.75,3:1,4:2,5:3,6:4,7:6',tt:'zoomlevel:scale,...'},
	{p:'cellShape',ex:'rect|3dbar|circle|vector'},
	{p:'cellColor',ex:'color'},
	{p:'cellFilled',ex:true},
	{p:'cellSize',ex:'8'},
	{p:'cellSizeH',ex:'20',tt:'Base value to scale by to get height'},
	{p:'cellSizeHBase',ex:'0',tt:'Extra height value'},
	{p:'angleBy',ex:'field',tt:'field for angle of vectors'},
	{p:'hmOperator',ex:'count|average|min|max'},
	{p:'hmAnimationSleep',ex:'1000'},
	{p:'hmReloadOnZoom',ex:'true'},
	{p:'reloadOnZoom',ex:'true'},	
	{p:'hmGroupByDate',ex:'true|day|month|year|decade',tt:'Group heatmap images by date'}, 
	{p:'hmGroupBy',ex:'field id',tt:'Field to group heatmap images'}, 
	{p:'hmLabelPrefix'},
	{p:'hmShowToggle',ex:true,tt:'Show the toggle checkbox to turn off/on the heatmap'},
	{p:'hmToggleLabel'},
	{p:'boundsScale',ex:'0.1',tt:'Scale up the map bounds'},
	{p:'hmFilter',ex:'average5|average9|average25|gauss9|gauss25',tt:'Apply filter to image'},
	{p:'hmFilterPasses',ex:'1'},
	{p:'hmFilterThreshold',ex:'1'},
	{p:'hmCountThreshold',ex:'1'},
    ];
    
    displayDefineMembers(this, myProps, {
        mapBoundsSet: false,
        features: [],
        myMarkers: {},
        mapEntryInfos: {},
	tracks:{},
	checkFinished: function() {
	    return true;
	},
        initDisplay: function() {
            SUPER.initDisplay.call(this);
            var _this = this;
	    let legendSide = this.getProperty("sizeByLegendSide");
	    if(legendSide) {
		let legend = HU.div([ID,this.domId(ID_SIZEBY_LEGEND)]);
		if(legendSide=="top") {
		    this.jq(ID_TOP).append(legend);
		} else if(legendSide=="left") {
		    this.jq(ID_LEFT).append(legend);
		} else if(legendSide=="right") {
		    this.jq(ID_RIGHT).append(legend);
		} else if(legendSide=="bottom") {
		    this.jq(ID_BOTTOM).append(legend);
		} else {
		    console.log("Unknown legend side:" + legendSide);
		}
	    }
	    this.startProgress();
        },
        checkLayout: function() {
            if (!this.map) {
                return;
            }
            var d = this.jq(ID_MAP);
            if (d.width() > 0 && this.lastWidth != d.width() && this.map) {
                this.lastWidth = d.width();
                this.map.getMap().updateSize();
            }
	    if(!this.setMapLocationAndZoom && this.mapParams) {
		this.setMapLocationAndZoom = true;
		if(this.mapParams.initialZoom>=0) {
		    this.map.getMap().zoomTo(this.mapParams.initialZoom);
		}
		if(this.mapParams.initialLocation) {
		    let loc = MapUtils.createLonLat(this.mapParams.initialLocation.lon, this.mapParams.initialLocation.lat);
		    this.map.setCenter(loc);
		}

	    }
        },

	handlePopup: function(feature, popup) {
	    if(!this.trackUrlField) return;
	    let func = ()=>{
		if(feature.record) {
		    if(this.tracks[feature.record.getId()]) {
			this.removeTrack(feature.record);
		    } else {
			let url = feature.record.getValue(this.trackUrlField.getIndex());
			$.getJSON(url, data=>{this.loadTrack(feature.record, data)}).fail(err=>{console.log("url failed:" + url +"\n" + err)});
		    }
		}
	    };
	    this.jq(ID_TRACK_VIEW).click(func);
	    this.jq(ID_TRACK_VIEW+"_1").click(func);	    
	},
	macroHook: function(record, token,value) {
	    if(!this.trackUrlField) {
		return null;
	    }
	    if(token.tag!=this.trackUrlField.getId()) {
		return null;
	    }
	    if(String(value).trim().length==0) return "";
	    this.currentPopupRecord = record;
	    let haveTrack = this.tracks[record.getId()]!=null;
	    let label =haveTrack?"Remove track":(token.attrs["label"] ||  "View track");
	    return SPACE + HU.span([CLASS,"ramadda-clickable",ID,this.domId(ID_TRACK_VIEW)],label);
	}, 
	getRecordUrlHtml: function(attrs, field, record) {
	    this.currentPopupRecord = record;
	    if(!this.trackUrlField || this.trackUrlField.getId()!=field.getId()) {
		return SUPER.getRecordUrlHtml.call(this, attrs, field, record);
	    }
	    let value = record.getValue(field.getIndex());
	    let haveTrack = this.tracks[record.getId()]!=null;
	    let label = haveTrack?"Remove track":(attrs[field.getId()+".label"] || "View track");
	    return  HU.span([CLASS,"ramadda-clickable",ID,this.domId(ID_TRACK_VIEW+"_1")],label);
	},
	removeTrack:function(record) {
	    if(this.tracks[record.getId()]) {
		this.map.removePolygon(this.tracks[record.getId()]);
		this.tracks[record.getId()] = null;
	    }
	    this.jq(ID_TRACK_VIEW).html("View track");
	    this.jq(ID_TRACK_VIEW+"_1").html("View track");
	    let item = this.jq(ID_LEFT).find(HU.attrSelect(RECORD_ID,record.getId()));
	    item.removeClass("display-map-toc-item-on");
	},
	loadTrack: function(record, data) {
            let newData = makePointData(data, null,this,"");
	    let points = RecordUtil.getPoints(newData.getRecords(),{});
	    let feature = this.markers?this.markers[record.getId()]:null;
	    let item = this.jq(ID_LEFT).find(HU.attrSelect(RECORD_ID,record.getId()));
	    record.trackData = newData;
	    item.addClass("display-map-toc-item-on");
	    try {
		record.setLocation(points[0].y, points[0].x);
		let loc =  new OpenLayers.LonLat(points[0].x, points[0].y);
		loc = this.map.transformLLPoint(loc);
		if(feature)
		    feature.move(loc);
	    } catch(err) {
		console.log(err);
	    }

	    let bounds = {};
	    let attrs = {
		strokeColor:this.getStrokeColor("blue"),
		strokeWidth:this.getStrokeWidth(1),
		fillColor:this.getProperty("fillColor") ||'transparent',
	    };
            let polygon = this.map.addPolygon("", "", points, attrs);
	    polygon.record = record;
	    this.tracks[record.getId()]=polygon;
	    if(polygon.geometry) {
		this.map.zoomToExtent(polygon.geometry.getBounds());
	    }
	    this.map.closePopup();
	    setTimeout(()=>{
		this.getDisplayManager().notifyEvent(DisplayEvent.dataSelection, this, {data:newData});
	    },100);
	},
	applyToFeatureLayers:function(func) {
	    if(this.myFeatureLayer) func(this.myFeatureLayer);
	    if(this.myFeatureLayerNoSelect) func(this.myFeatureLayerNoSelect);
	},
	addFeatures:function(features,noSelect) {
	    if(!this.myFeatureLayer) {
		this.myFeatureLayerNoSelect = this.map.createFeatureLayer("Features-2",false);		
		this.myFeatureLayer = this.map.createFeatureLayer("Map Features",true);
		if(this.getProperty("showMarkersToggle") && !this.getProperty("markersVisibility", true)) {
		    this.applyToFeatureLayers(layer=>{layer.setVisibility(false);});
		}
		this.myFeatures= [];
	    }
	    let layer = noSelect?this.myFeatureLayerNoSelect:this.myFeatureLayer;
	    layer.addFeatures(features);
	    features.forEach(feature=>{
		feature.layer = layer;
		this.myFeatures.push(feature);
	    });
	},
	removeFeature: function(feature) {
	    if(feature) {
		this.applyToFeatureLayers(layer=>{
		    layer.removeFeatures([feature]);
		});
	    }
	},

	removeFeatureLayer: function() {
	    if(this.myFeatureLayer) {
		this.map.removeLayer(this.myFeatureLayer);
	    }
	    if(this.myFeatureLayerNoSelect) {
		this.map.removeLayer(this.myFeatureLayerNoSelect);
	    }	    
	    if(this.labelFeatures) {
		this.map.labelLayer.removeFeatures(this.labelFeatures);
		this.labelFeatures = null;
		this.jq("legendid").html("");
	    }
	    this.myFeatureLayer = null;
	    this.myFeatureLayerNoSelect = null;
	    this.myFeatures= null;
	},

        initMapParams: function(params) {
	    SUPER.initMapParams.call(this,params);
	    if(this.getDoPopupSlider()) {
		params.doPopupSlider = true;
		if(this.getPopupSliderRight()) {
		    params.popupSliderRight = true;
		}
	    }
	},
	initMap: function(map) {
	    if(!this.getShowMarkers(this.getProperty("markersVisibility", true))) {
		map.getMarkersLayer().setVisibility(false);
	    }
	    let boundsAnimation = this.getProperty("boundsAnimation");
	    if(boundsAnimation) {
		this.didAnimationBounds = false;
                let animationBounds = boundsAnimation.split(",");
                if (animationBounds.length == 4) {
		    var pause = parseFloat(this.getProperty("animationPause","1000"));
		    HU.callWhenScrolled(this.domId(ID_MAP),()=>{
			if(_this.didAnimationBounds) {
			    return;
			}
			_this.didAnimationBounds = true;
			var a = animationBounds;
			var b = MapUtils.createBounds(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]),parseFloat(a[0]));
			_this.map.animateViewToBounds(b);
		    },pause);
		}
            }
	},
        createMap: function() {
	    SUPER.createMap.call(this);
            let _this = this;
	    if(!this.getShowMarkers(this.getProperty("markersVisibility", true))) {
		this.map.getMarkersLayer().setVisibility(false);
	    }

            if (this.doDisplayMap()) {
                this.map.setDefaultCanSelect(false);
            }
            this.map.initMap(false);
            this.map.addRegionSelectorControl(function(bounds) {
		_this.propagateEvent(DisplayEvent.mapBoundsChanged, {"bounds": bounds,    "force": true});
            },true);
	    this.map.popupHandler = (feature,popup) =>{
		this.handlePopup(feature, popup);
	    };
	    this.map.addFeatureSelectHandler(feature=>{
		this.lastFeatureSelectTime = new Date();
		if(feature.collisionInfo)  {
		    feature.collisionInfo.dotSelected(feature);
		    return;
		}
		if(feature.record) {
		    this.propagateEventRecordSelection({record:feature.record});
		    this.propagateFilterFields(feature.record);
		}

		if(feature.record && !this.map.doPopup && this.getProperty("showRecordSelection", true)) {
		    this.highlightPoint(feature.record.getLatitude(),feature.record.getLongitude(),true,false);
		}
		if(feature.record && this.getProperty("shareSelected")) {
		    let idField = this.getFieldById(null,"id");
		    if(idField) {
			ramaddaDisplaySetSelectedEntry(feature.record.getValue(idField.getIndex()),this.getDisplayManager().getDisplays());
		    }
		}
	    });

            this.map.addFeatureHighlightHandler((feature, highlight)=>{
		if(feature.record) {
		    if(this.lastHighlightedRecord) {
			var args = {highlight:false,record: this.lastHighlightedRecord};
			this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, this, args);
			if (this.getAnimationEnabled()) {
			    this.getAnimation().handleEventRecordHighlight(this, args);
			}
			this.lastHighlightedRecord = null;
		    }
		    if(highlight) {
			this.lastHighlightedRecord = feature.record;
		    }
		    var args = {highlight:highlight,record: feature.record};
		    this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, this, args);
		    if (this.getAnimationEnabled()) {
			this.getAnimation().handleEventRecordHighlight(this, args);
		    }
		}

	    });

	    this.map.highlightBackgroundColor=this.getProperty("highlighBackgroundColor","#fff");
	    if(this.getProperty("addEntryMarkers")) {
		this.map.doPopup = true;
	    } else {
		this.map.doPopup = this.getProperty("doPopup",true);
	    }
            this.map.addClickHandler(this.domId(ID_LONFIELD), this
				     .domId(ID_LATFIELD), null, this);

            this.map.getMap().events.register("updatesize", "", ()=>{
		if(!this.callingUpdateSize) {
		    _this.updateHtmlLayers();
		}
            });


            this.map.getMap().events.register("zoomend", "", ()=>{
                _this.mapBoundsChanged();
		_this.checkHeatmapReload();
		_this.updateHtmlLayers();
		if(!this.haveAddPoints) return;
		if(this.getHandleCollisions()) {
		    if(this.lastZoom == this.map.getZoom()) {
			return;
		    }

		    //Wait a bit
		    if(this.lastCollisionTimeout) {
			clearTimeout(this.lastCollisionTimeout);
		    }

		    this.lastTimeout = setTimeout(()=>{
			this.haveCalledUpdateUI = false;
			this.updateUI();
			this.lastCollisionTimeout = null;
		    },1000);
		}
            });
	    this.createTime = new Date();
            this.map.getMap().events.register("moveend", "", ()=> {
		if(_this.map.doingPopup) return;
                _this.mapBoundsChanged();
		_this.checkHeatmapReload();
            });

	    
	    var boundsAnimation = this.getProperty("boundsAnimation");
	    if(boundsAnimation) {
		this.didAnimationBounds = false;
                let animationBounds = boundsAnimation.split(",");
                if (animationBounds.length == 4) {
		    var pause = parseFloat(this.getProperty("animationPause","1000"));
		    HU.callWhenScrolled(this.domId(ID_MAP),()=>{
			if(_this.didAnimationBounds) {
			    return;
			}
			_this.didAnimationBounds = true;
			var a = animationBounds;
			var b = MapUtils.createBounds(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]),parseFloat(a[0]));
			_this.map.animateViewToBounds(b);
		    },pause);
		}
            }


            let currentFeatures = this.features;
            this.features = [];
            for (var i = 0; i < currentFeatures.length; i++) {
                this.addFeature(currentFeatures[i]);
            }
	    if(this.getProperty("displayEntries",true)) {
		let entries = this.getDisplayManager().collectEntries();
		for (let i = 0; i < entries.length; i++) {
                    let pair = entries[i];
                    this.handleEventEntriesChanged(pair.source, pair.entries);
		}
	    }


	    if(this.getProperty("addEntryMarkers")) {
		this.getDisplayEntry(entry=>{
		    if(!entry) {
			console.log("failed to get entry");
			return;
		    }
		    entry.getChildrenEntries(entries=>{
			entries.forEach(entry=>{
			    if(!entry.hasLocation()) return;
			    let lonlat = new MapUtils.createLonLat(entry.getWest(), entry.getNorth());
			    let html = "<b>" + entry.getName()+"</b>";
			    if(entry.isImage()) {
				html+="<br>" + HU.image(entry.getImageUrl(),["width","200px"]);
			    }
			    this.map.addMarker(entry.getId(), lonlat, entry.getIconUrl(),  "", html, null, 16);
			});
		    });
		});

	    }

            if (this.layerEntries) {
                var selectCallback = function(layer) {
                    _this.handleLayerSelect(layer);
                }
                var unselectCallback = function(layer) {
                    _this.handleLayerUnselect(layer);
                }
                var toks = this.layerEntries.split(",");
                for (var i = 0; i < toks.length; i++) {
                    var tok = toks[i];
                    var url = ramaddaBaseUrl + "/entry/show?output=shapefile.kml&entryid=" + tok;
                    this.map.addKMLLayer("layer", url, true, selectCallback, unselectCallback);
                    //TODO: Center on the kml
                }
            }


	    for(var markerIdx=1;true;markerIdx++) {
		let marker = this.getProperty("marker" + markerIdx);
		if(!marker) break;
		let props = {};
		if(marker.startsWith("base64:")) {
		    marker = window.atob(marker.substring(7));
		}
		if (marker.indexOf("{") == 0) {
		    props = JSON.parse(marker);
		} else {
		    let [lat,lon,text] = marker.split(",");
		    props.lat = lat;props.lon = lon; props.text = text;
		}
		let point = new OpenLayers.LonLat(parseFloat(props.lon), parseFloat(props.lat));
		if(props.size==null || props.size=="") props.size=16;
		let type = props.type || "icon"

		
		let attrs = props;
		attrs.pointRadius=props.size||"16";
		attrs.labelYOffset = -8-attrs.pointRadius;
		/*
		if(!props.description) props.description = "";
		if(!Utils.isAnonymous()) {
		    props.description +="<br>" + "edit";
		}
		*/

		if(type == "icon") {
		    let icon = props.icon || "/markers/marker-red.png";
		    //addMarker:  function(id, location, iconUrl, markerName, text, parentId, size, yoffset, canSelect) {
		    this.map.addMarker("", point,icon,props.description,props.description,"",parseFloat(props.size||"16"),null,true,attrs);
		} else {
		    //addPoint:  function(id, point, attrs, text, notReally, textGetter)
		    attrs.fillColor=attrs.fillColor||"blue";
		    attrs.strokeWidth=attrs.strokeWidth||"1";		    
		    attrs.graphicName=type;
		    if(type=="none") {
			attrs.graphicName = "circle";
			attrs.pointRadius=0;
			attrs.fillColor="transparent";
		    }
		    this.map.addPoint("", point, attrs, props.description);
		    if(attrs.graphicName!="circle") 
			this.map.addPoint("", point, {pointRadius:attrs.pointRadius, strokeColor:"transparent", fillColor:"transparent"},props.description);
		}
		this.map.doPopup=true;
	    }
        },
        getBounds: function() {
	    return this.map.getBounds();
	},
        addBaseMapLayer: function(url, isKml) {
            let _this = this;
            mapLoadInfo = displayMapUrlToVectorListeners[url];
            if (mapLoadInfo == null) {
                mapLoadInfo = {
                    otherMaps: [],
                    layer: null
                };
                let selectFunc = function(layer) {
                    _this.mapFeatureSelected(layer);
                }
		//Don't do this for now as its handled elsewhere?
		selectFunc = null;
                let hasBounds = this.getProperty("bounds") != null ||
		    Utils.isDefined(this.getProperty("zoomLevel"))   ||
		    Utils.isDefined(this.getProperty("mapCenter"));
		let attrs =   {
                    strokeColor: this.getProperty("vectorLayerStrokeColor","#000"),
		    fillColor:this.getProperty("vectorLayerFillColor","#ccc"),
		    fillOpacity:this.getProperty("vectorLayerFillOpacity",0.25),
                    strokeWidth: this.getProperty("vectorLayerStrokeWidth",1),
		}
                if (isKml)
                    this.map.addKMLLayer(this.getProperty("kmlLayerName"), url, this.doDisplayMap(), selectFunc, null, attrs,
					 function(map, layer) {
					     _this.baseMapLoaded(layer, url);
					 }, !hasBounds);
                else
                    this.map.addGeoJsonLayer(this.getProperty("geojsonLayerName"), url, this.doDisplayMap(), selectFunc, null, attrs,
					     function(map, layer) {
						 _this.baseMapLoaded(layer, url);
					     }, !hasBounds);
            } else if (mapLoadInfo.layer) {
                this.cloneLayer(mapLoadInfo.layer);
            } else {
                this.map.showLoadingImage();
                mapLoadInfo.otherMaps.push(this);
            }
        },
        mapFeatureSelected: function(layer) {
            if (!this.getPointData()) {
                return;
            }
            this.map.onFeatureSelect(layer);
            if (!Utils.isDefined(layer.feature.record)) {
                return;
            }
            this.propagateEventRecordSelection({
                record: layer.feature.record
            });
        },
	showVectorLayer:true,
	toggleVectorLayer: function() {
	    this.showVectorLayer = !this.showVectorLayer;
            if(this.vectorLayer != null) {
		this.vectorLayer.setVisibility(this.showVectorLayer);
	    }
	    this.haveCalledUpdateUI = false;
	    this.updateUI();
	},
        doDisplayMap: function() {
            if (!this.getShowLayers()) return false;
            if (!this.getProperty("displayAsMap", true)) return false;
            if(this.getProperty("kmlLayer") || this.getProperty("geojsonLayer")) {
		if(this.getShowLayers()) {
		    return this.showVectorLayer;
		}
	    }
        },
        cloneLayer: function(layer) {
            let _this = this;
            this.map.hideLoadingImage();
            layer = layer.clone();
            var features = layer.features;
            var clonedFeatures = [];
            for (var j = 0; j < features.length; j++) {
                feature = features[j];
                feature = feature.clone();
                if (feature.style) {
                    oldStyle = feature.style;
                    feature.style = {};
                    for (var a in oldStyle) {
                        feature.style[a] = oldStyle[a];
                    }
                }
                feature.layer = layer;
                clonedFeatures.push(feature);
            }
            layer.removeAllFeatures();
            this.map.getMap().addLayer(layer);
            layer.addFeatures(clonedFeatures);
            this.vectorLayer = layer;
            this.applyVectorMap();
            this.map.addSelectCallback(layer, this.doDisplayMap(), function(layer) {
                _this.mapFeatureSelected(layer);
            });
        },
        handleEventPointDataLoaded: function(source, pointData) {
        },
        handleEventFieldsSelected: function(source, fields) {
	    if(this.getProperty("selectedFieldIsColorBy") && fields.length>0) {
		this.colorByFieldChanged(fields[0]);
	    }
        },
        baseMapLoaded: function(layer, url) {
            this.vectorLayer = layer;
            this.applyVectorMap();
            mapLoadInfo = displayMapUrlToVectorListeners[url];
            if (mapLoadInfo) {
                mapLoadInfo.layer = layer;
                for (var i = 0; i < mapLoadInfo.otherMaps.length; i++) {
                    mapLoadInfo.otherMaps[i].cloneLayer(layer);
                }
                mapLoadInfo.otherMaps = [];
            }
        },
        handleLayerSelect: function(layer) {
            var args = this.layerSelectArgs;
            if (!this.layerSelectPath) {
                if (!args) {
                    this.map.onFeatureSelect(layer);
                    return;
                }
                //If args was defined then default to search
                this.layerSelectPath = "/search/do";
            }
            var url = ramaddaBaseUrl + this.layerSelectPath;
            if (args) {
                var toks = args.split(",");
                for (var i = 0; i < toks.length; i++) {
                    var tok = toks[i];
                    var toktoks = tok.split(":");
                    var urlArg = toktoks[0];
                    var layerField = toktoks[1];
                    var attrs = layer.feature.attributes;
                    var fieldValue = null;
                    for (var attr in attrs) {
                        var attrName = "" + attr;
                        if (attrName == layerField) {
                            var attrValue = null;
                            if (typeof attrs[attr] == 'object' || typeof attrs[attr] == 'Object') {
                                var o = attrs[attr];
                                attrValue = o["value"];
                            } else {
                                attrValue = attrs[attr];
                            }
                            url = HU.appendArg(url, urlArg, attrValue);
                            url = url.replace("${" + urlArg + "}", attrValue);
                        }
                    }
                }
            }
            url = HU.appendArg(url, "output", "json");
            var entryList = new EntryList(this.getRamadda(), url, null, false);
            entryList.doSearch(this);
            this.getEntryList().showMessage("Searching", HU.div([ATTR_STYLE, HU.css("margin","20px")], this.getWaitImage()));
        },
        getEntryList: function() {
            if (!this.entryListDisplay) {
                var props = {
                    showMenu: true,
                    showTitle: true,
                    showDetails: true,
                    layoutHere: false,
                    showForm: false,
                    doSearch: false,
                };
                var id = this.getUniqueId("display");
                this.entryListDisplay = new RamaddaEntrylistDisplay(this.getDisplayManager(), id, props);
                this.getDisplayManager().addDisplay(this.entryListDisplay);
            }
            return this.entryListDisplay;
        },
        entryListChanged: function(entryList) {
            var entries = entryList.getEntries();
            this.getEntryList().entryListChanged(entryList);
        },
        handleLayerUnselect: function(layer) {
            this.map.onFeatureUnselect(layer);
        },
        addMapLayer: function(source, props) {
            var _this = this;
            var entry = props.entry;
            if (!this.addedLayers) this.addedLayers = {};
            if (this.addedLayers[entry.getId()]) {
                var layer = this.addedLayers[entry.getId()];
                if (layer) {
                    this.map.removeKMLLayer(layer);
                    this.addedLayers[entry.getId()] = null;
                }
                return;
            }

            var type = entry.getType().getId();
            if (type == "geo_shapefile" || type == "geo_geojson") {
                var bounds = MapUtils.createBounds(entry.getWest(), entry.getSouth(), entry.getEast(), entry.getNorth());
                if (bounds.left < -180 || bounds.right > 180 || bounds.bottom < -90 || bounds.top > 90) {
                    bounds = null;
                }

                var selectCallback = function(layer) {
                    _this.handleLayerSelect(layer);
                }
                var unselectCallback = function(layer) {
                    _this.handleLayerUnselect(layer);
                }
                var layer;
                if (type == "geo_geojson") {
                    var url = entry.getRamadda().getEntryDownloadUrl(entry);
                    layer = this.map.addGeoJsonLayer(this.getProperty("geojsonLayerName"), url, this.doDisplayMap(), selectCallback, unselectCallback, null, null, true);
                } else {
                    var url = ramaddaBaseUrl + "/entry/show?output=shapefile.kml&entryid=" + entry.getId();
                    layer = this.map.addKMLLayer(entry.getName(), url, true, selectCallback, unselectCallback, null, null, true);
                }
                this.addedLayers[entry.getId()] = layer;
                return;
            }

            var baseUrl = entry.getAttributeValue("base_url");
            if (!Utils.stringDefined(baseUrl)) {
                console.log("No base url:" + entry.getId());
                return;
            }
            var layer = entry.getAttributeValue("layer_name");
            if (layer == null) {
                layer = entry.getName();
            }
            this.map.addWMSLayer(entry.getName(), baseUrl, layer, false);
        },
        mapBoundsChanged: function() {
            let bounds = this.map.getMap().calculateBounds().transform(this.map.sourceProjection,
								       this.map.displayProjection);
	    this.propagateEvent(DisplayEvent.mapBoundsChanged, {"bounds": bounds,    "force": false});
	    if(this.clipToView || this.getClipToBounds()) {
		if(this.lastUpdateTime) {
		    let now = new Date();
		    if(now.getTime()-this.lastUpdateTime.getTime()>1000) {
			this.haveCalledUpdateUI = false;
			this.clipBounds = true;
			this.updatingFromClip = true;
			this.updateUI();
		    }
		}
	    }

        },
        addFeature: function(feature) {
            this.features.push(feature);
            feature.line = this.map.addPolygon("lines_" +
					       feature.source.getId(), RecordUtil
					       .clonePoints(feature.points), null);
        },
        getContentsDiv: function() {
            let html =  HU.div([ATTR_CLASS, "display-contents", ID,
			   this.domId(ID_DISPLAY_CONTENTS)], "");
	    return html;
        },
	removeHighlight: function() {
	    if(this.highlightMarker)
		this.removeFeature(this.highlightMarker);
	},
	highlightPoint: function(lat,lon,highlight,andCenter) {
	    if(!this.map) return;
	    this.removeHighlight();
	    if(highlight) {
		var point = new OpenLayers.LonLat(lon,lat);
                var attrs = {
                    pointRadius: parseFloat(this.getProperty("recordHighlightRadius", +this.getPropertyRadius(6)+8)),
                    stroke: true,
                    strokeColor: this.getProperty("recordHighlightStrokeColor", "#000"),
                    strokeWidth: parseFloat(this.getProperty("recordHighlightStrokeWidth", 2)),
		    fillColor: this.getProperty("recordHighlightFillColor", "#ccc"),
		    fillOpacity: parseFloat(this.getProperty("recordHighlightFillOpacity", 0.5)),
                };
		if(this.getProperty("recordHighlightUseMarker",false)) {
		    var size = +this.getProperty("recordHighlightRadius", +this.getRadius(24));
		    this.highlightMarker = this.map.createMarker("pt-" + i, point, null, "pt-" + i,null,null,size);
		} else 	if(this.getProperty("recordHighlightVerticalLine",false)) {
		    let points = [];
                    points.push(new OpenLayers.Geometry.Point(lon,0));
		    points.push(new OpenLayers.Geometry.Point(lon,80));
                    this.highlightMarker = this.map.createPolygon(id, "highlight", points, attrs, null);
		} else {
		    attrs.graphicName = this.getProperty("recordHighlightShape");
		    this.highlightMarker =  this.map.createPoint("highlight", point, attrs);
		}
		if(this.highlightMarker) this.addFeatures([this.highlightMarker]);
		if(andCenter && this.getProperty("centerOnHighlight",false)) {
		    this.map.setCenter(point);
		}
	    }
	},


        handleEventEntryMouseover: function(source, args) {
            if (!this.map) {
                return;
            }
            id = args.entry.getId() + "_mouseover";
            attrs = {
                lineColor: "red",
                fillColor: "red",
                fillOpacity: 0.5,
                lineOpacity: 0.5,
                doCircle: true,
                lineWidth: 1,
                fill: true,
                circle: {
                    lineColor: "black"
                },
                polygon: {
                    lineWidth: 4,
                }
            }
            this.addOrRemoveEntryMarker(id, args.entry, true, attrs);
        },
        handleEventEntryMouseout: function(source, args) {
            if (!this.map) {
                return;
            }
            id = args.entry.getId() + "_mouseover";
            this.addOrRemoveEntryMarker(id, args.entry, false);
        },
        handleEventAreaClear: function() {
            if (!this.map) {
                return;
            }
            this.map.clearRegionSelector();
        },
	propagateFilterFields: function(record) {
	    let fields = this.getFieldsByIds(null, this.getProperty("filterFieldsToPropagate"));
	    fields.map(field=>{
		let args = {
		    fieldId:field.getId(),
		    value:record.getValue(field.getIndex())
		};
		this.propagateEvent(DisplayEvent.filterChanged, args);
	    });
	},	    
        handleClick: function(theMap, event, lon, lat) {
	    if(this.lastFeatureSelectTime) {
		let diff = new Date().getTime()-this.lastFeatureSelectTime.getTime();
		this.lastFeatureSelectTime = null;
		if(diff<1000) {
		    return;
		}
	    }

	    if(event.shiftKey) {
		if(Utils.isAnonymous()) return;
		let text = prompt("Marker text", "");
		if(!text) return;
		let url = ramaddaBaseUrl +"/metadata/addform?entryid=" + this.getProperty("entryId")+"&metadata_type=map_marker&metadata_attr1=" +
		    encodeURIComponent(text) +"&metadata_attr2=" + lat +"," + lon; 
		window.location = url;
//		console.log("click-shift");
		return
	    }

            if (!this.map) {
                return;
            }
            if (this.doDisplayMap()) {
                return;
            }
//	    console.log("click-2");
            var justOneMarker = this.getProperty("justOneMarker",false);

            if(justOneMarker) {
                var pointData = this.getPointData();
                if(pointData) {
                    pointData.handleEventMapClick(this, this, lon, lat);
		    this.getDisplayManager().notifyEvent("mapClick", this, {lat:lat,lon:lon});
                }
            }


	    if(!this.records) return;
//	    console.log("click-3");
	    let indexObj = [];
            let closest = RecordUtil.findClosest(this.records, lon, lat, indexObj);
            if (!closest) return;
//	    console.log("click-4");
	    this.propagateEventRecordSelection({record: closest});

	    //If we are highlighting a record then change the marker
	    if(this.highlightMarker) {
		this.highlightPoint(closest.getLatitude(),closest.getLongitude(),true,false);
	    }
	    
	    this.propagateFilterFields(closest);
        },

        getPosition: function() {
            var lat = $("#" + this.domId(ID_LATFIELD)).val();
            var lon = $("#" + this.domId(ID_LONFIELD)).val();
            if (lat == null)
                return null;
            return [lat, lon];
        },

        haveInitBounds: false,
        setInitMapBounds: function(north, west, south, east) {
            if (!this.map) return;
            if (this.haveInitBounds) return;
            this.haveInitBounds = true;
            this.map.centerOnMarkers(new OpenLayers.Bounds(west, south, east,
							   north),true);
        },

        sourceToEntries: {},
        handleEventEntriesChanged: function(source, entries) {
            if (!this.map) {
                return;
            }
            //debug
            if (source == this.lastSource) {
                this.map.clearSelectionMarker();
            }
            if ((typeof source.forMap) != "undefined" && !source.forMap) {
                return;
            }
            var oldEntries = this.sourceToEntries[source.getId()];
            if (oldEntries != null) {
                for (var i = 0; i < oldEntries.length; i++) {
                    var id = source.getId() + "_" + oldEntries[i].getId();
                    this.addOrRemoveEntryMarker(id, oldEntries[i], false);
                }
            }

            this.sourceToEntries[source.getId()] = entries;

            var markers = new OpenLayers.Layer.Markers("Markers");
            var lines = new OpenLayers.Layer.Vector("Lines", {});
            var north = -90,
                west = 180,
                south = 90,
                east = -180;
            var didOne = false;
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                var id = source.getId() + "_" + entry.getId();
                var mapEntryInfo = this.addOrRemoveEntryMarker(id, entries[i], true);
                if (entry.hasBounds()) {
                    if (entry.getNorth() > 90 ||
                        entry.getSouth() < -90 ||
                        entry.getEast() > 180 ||
                        entry.getWest() < -180) {
                        console.log("bad bounds on entry:" + entry.getName() + " " +
				    entry.getNorth() + " " +
				    entry.getSouth() + " " +
				    entry.getEast() + " " +
				    entry.getWest());
                        continue;
                    }

                    north = Math.max(north, entry.getNorth());
                    south = Math.min(south, entry.getSouth());
                    east = Math.max(east, entry.getEast());
                    west = Math.min(west, entry.getWest());
                    didOne = true;
                }
            }
            var bounds = (didOne ? MapUtils.createBounds(west, south, east, north) : null);
            //debug                    this.map.centerOnMarkers(bounds, true);
        },
        handleEventEntrySelection: function(source, args) {
            if (!this.map) {
                return;
            }
            var _this = this;
            var entry = args.entry;
            if (entry == null) {
                this.map.clearSelectionMarker();
                return;
            }
            var selected = args.selected;

            if (!entry.hasLocation()) {
                return;
            }
        },
        addOrRemoveEntryMarker: function(id, entry, add, args) {
            if (!args) {
                args = {};
            }
            var dflt = {
                lineColor: entry.lineColor,
                fillColor: entry.lineColor,
                lineWidth: entry.lineWidth,
                doCircle: false,
                doRectangle: this.showBoxes,
                fill: false,
                fillOpacity: 0.75,
                pointRadius: 12,
                polygon: {},
                circle: {}
            }
            dfltPolygon = {}
            dfltCircle = {}
            $.extend(dflt, args);
            if (!dflt.lineColor) dflt.lineColor = "blue";

            $.extend(dfltPolygon, dflt);
            if (args.polygon)
                $.extend(dfltPolygon, args.polygon);
            $.extend(dfltCircle, dflt);
            if (args.circle)
                $.extend(dfltCircle, args.circle);

            var mapEntryInfo = this.mapEntryInfos[id];
            if (!add) {
                if (mapEntryInfo != null) {
                    mapEntryInfo.removeFromMap(this.map);
                    this.mapEntryInfos[id] = null;
                }
            } else {
                if (mapEntryInfo == null) {
                    mapEntryInfo = new MapEntryInfo(entry);
                    this.mapEntryInfos[id] = mapEntryInfo;
                    if (entry.hasBounds() && dflt.doRectangle) {
                        var attrs = {};
                        mapEntryInfo.rectangle = this.map.addRectangle(id,
								       entry.getNorth(), entry.getWest(), entry
								       .getSouth(), entry.getEast(), attrs);
                    }
                    var latitude = entry.getLatitude();
                    var longitude = entry.getLongitude();
                    if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) {
                        return;
                    }
                    var point = new OpenLayers.LonLat(longitude, latitude);
                    if (dflt.doCircle) {
                        attrs = {
                            pointRadius: dfltCircle.pointRadius,
                            stroke: true,
                            strokeColor: dfltCircle.lineColor,
                            strokeWidth: dfltCircle.lineWidth,
                            fillColor: dfltCircle.fillColor,
                            fillOpacity: dfltCircle.fillOpacity,
                            fill: dfltCircle.fill,
                        };
                        mapEntryInfo.circle = this.map.addPoint(id, point, attrs);
                    } else {
                        mapEntryInfo.marker = this.map.addMarker(id, point, entry.getIconUrl(), "", this.getEntryHtml(entry));
                    }
                    if (entry.polygon) {
                        var points = []
                        for (var i = 0; i < entry.polygon.length; i += 2) {
                            points.push(new OpenLayers.Geometry.Point(entry.polygon[i + 1], entry.polygon[i]));
                        }
                        var attrs = {
                            strokeColor: dfltPolygon.lineColor,
                            strokeWidth: Utils.isDefined(dfltPolygon.lineWidth) ? dfltPolygon.lineWidth : 2
                        };
                        mapEntryInfo.polygon = this.map.addPolygon(id, entry.getName(), points, attrs, mapEntryInfo.marker);
                    }
                    var _this = this;
                    if (mapEntryInfo.marker) {
                        mapEntryInfo.marker.entry = entry;
                        mapEntryInfo.marker.ramaddaClickHandler = function(marker) {
                            _this.handleMapClick(marker);
                        };
                        if (this.handledMarkers == null) {
                            this.map.centerToMarkers();
                            this.handledMarkers = true;
                        }
                    }
                }
                return mapEntryInfo;
            }
        },
        handleMapClick: function(marker) {
            if (this.selectedMarker != null) {
                this.getDisplayManager().handleEventEntrySelection(this, {
                    entry: this.selectedMarker.entry,
                    selected: false
                });
            }
            this.getDisplayManager().handleEventEntrySelection(this, {
                entry: marker.entry,
                selected: true
            });
            this.selectedMarker = marker;
        },
        applyVectorMap: function(force, textGetter, args) {
            if (!force && this.vectorMapApplied) {
                return;
            }
	    let points = this.myPoints || this.myFeatures;

            if (!this.doDisplayMap() || !this.vectorLayer || !points) {
                return;
            }
	    
	    if(!args) args = {};
	    let debug = false;
	    if(debug) console.log("applyVectorMap");
	    if(!textGetter) textGetter  = this.textGetter;

	    let linkField=this.getFieldById(null,this.getProperty("linkField"));
	    let linkFeature=this.getProperty("linkFeature");
            let features = this.vectorLayer.features.slice();


            let allFeatures = features.slice();
	    let recordToFeature = {};
	    if(debug) console.log("\t#features:" + features.length);
	    
	    points.forEach(point=>{
		let record = point.record;
		if(!record) return;
		let feature = record.getDisplayProperty(this,"feature");
		if(feature)  recordToFeature[record.getId()] = feature;
	    });

	    if(linkFeature && linkField) {
		linkFeature = linkFeature.toLowerCase();
		let recordMap = {};
		points.forEach(p=>{
		    let record = p.record;
		    if(record) {
			let tuple = record.getData();
			let value = tuple[linkField.getIndex()];
			value  = value.toString().trim();
			record.linkValue = value;
			recordMap[value] = record;
		    }
		});

		features.forEach((feature,idx)=>{
		    let attrs = feature.attributes;
		    let ok = false;
		    for (let attr in attrs) {
			let _attr = String(attr).toLowerCase();
			if(linkFeature==_attr) {
			    ok  = true;
			    let value = this.map.getAttrValue(attrs, attr);
			    let debug = false;
			    if(value) {
				if(debug)
				    console.log("\tbefore");
				value = value.toString().trim();
				feature.linkValue = value;
				record = recordMap[value];
				if(record) {
				    if(debug)
					console.log("\tAdding:" + value+": " + record.getId());
				    recordToFeature[record.getId()] = feature;
				} else {
				    if(debug)
					console.log("\tCould not find record:" + value.replace(/ /g,"X") +":");
				}
				if(debug)
				    console.log("\tAFter");
			    } else {
				console.log("no attr value");
			    }
			    
			}
		    }
		    if(!ok) console.log("No ATTR found");
		});
	    }

	    let j=0;
	    features.forEach((feature,idx)=>{
		feature.wasPruned = feature.pruned;
		feature.pruned = false;
		feature.newStyle=null;
		if(feature.style) {
		    feature.style.display ="inline-block";
		}
		feature.featureIndex = j++;
		feature.featureMatched = false;
		feature.pointCount = 0;
		feature.circles = [];
		if(feature.style)feature.style.balloonStyle = null;
	    });

            this.vectorMapApplied = true;

	    let maxExtent = null;
	    let doCount = this.getProperty("colorByCount",false);
	    let matchedFeatures = [];
	    let seen = {};
	    let maxCnt = -1;
	    let minCnt = -1;

	    points.forEach((point,idx)=>{
                if (point.style && point.style.display == "none") {
		    return;
		}
		let record = point.record;
                let center = point.center;
		let tmp = {index:-1,maxExtent: maxExtent};
		let matchedFeature = recordToFeature[record.getId()];
		if(matchedFeature) {
		    matchedFeature.featureMatched = true;
		    if (matchedFeature.geometry) {
			if (maxExtent === null) {
			    maxExtent = new OpenLayers.Bounds();
			}
			maxExtent.extend(matchedFeature.geometry.getBounds());
		    } else {
			//console.log("no geometry:" + matchedFeature.CLASS_NAME);
		    }
		}  else {
                    matchedFeature = this.findContainingFeature(features, center,tmp,false);
		}
		if(!matchedFeature) {
		    return;
		}
		record.setDisplayProperty(this,"feature",matchedFeature);
		if(!point.colorByColor && point.hasColorByValue && isNaN(point.colorByValue)) {
		    return;
		}
		maxExtent = tmp.maxExtent;
		if(!seen[matchedFeature.featureIndex]) {
		    seen[matchedFeature.featureIndex] = true;
		    matchedFeatures.push(matchedFeature); 
		}
		matchedFeature.circles.push(point);
		matchedFeature.record = record;
		matchedFeature.textGetter=textGetter;
		if(doCount) {
		    matchedFeature.pointCount++;
		    maxCnt = maxCnt==-1?matchedFeature.pointCount:Math.max(maxCnt, matchedFeature.pointCount);
		    minCnt = minCnt==-1?matchedFeature.pointCount:Math.min(minCnt, matchedFeature.pointCount);
		} else {
		    if(tmp.index>=0)
			features.splice(tmp.index, 1);
		}
	    });



	    if(!doCount) {

		for(let i=0;i<matchedFeatures.length;i++) {
		    let matchedFeature = matchedFeatures[i];
		    style = matchedFeature.style;
		    if (!style) style = {
			"stylename": "from display",
		    };
		    style.display = null;
		    let newStyle = {};
		    $.extend(newStyle,style);
		    let circle = matchedFeature.circles[0];
		    $.extend(newStyle, circle.style);
		    matchedFeature.newStyle=newStyle;
		    matchedFeature.popupText = circle.text;
		    matchedFeature.dataIndex = i;
		}
	    }


	    let prune = this.getProperty("pruneFeatures", false);
	    if(doCount) {
		let colors = this.getColorTable(true);
		if (colors == null) {
		    colors = Utils.ColorTables.grayscale.colors;
		}
		let range = maxCnt-minCnt;
		let labelSuffix = this.getProperty("doCountLabel","points");
		for (let j = 0; j < features.length; j++) {
		    let feature = features[j];
		    let percent = range==0?0:(feature.pointCount - minCnt) /range;
                    let index = parseInt(percent * colors.length);
                    if (index >= colors.length) index = colors.length - 1;
                    else if (index < 0) index = 0;
		    let color= colors[index];
		    let style = feature.style;
		    if (!style) style = {
			"stylename": "from display",
		    };
		    let newStyle = {};
		    $.extend(newStyle,style);
		    $.extend(newStyle,{
			fillColor: color,
			"fillOpacity": 0.75,
			"strokeWidth": 1,
		    });

		    if(feature.pointCount==0) {
			//TODO: what to do with no count features?
			if(prune === true) {
			    newStyle.display = "none";
			}
		    }
		    feature.newStyle = newStyle;
		    feature.dataIndex = j;
		    feature.popupText = HU.div([],feature.pointCount +SPACE + labelSuffix);
		}
		this.displayColorTable(colors, ID_COLORTABLE, minCnt,maxCnt,{});
	    } else {
		if(prune) {
		    for (let i = 0; i < features.length; i++) {
			let feature = features[i];
			if(feature.featureMatched) {
			    continue;
			}
			let style = feature.style;
			if (!style) style = {
			    "stylename": "from display"
			};
			let newStyle = {};
			$.extend(newStyle,style);
			newStyle.display= "none";
			feature.pruned = true;
			feature.newStyle = newStyle;
		    }
		}
	    }

	    let redrawCnt = 0;
	    allFeatures.forEach((feature,idx)=>{
		if(!feature.newStyle) feature.newStyle={};

//		if(!feature.featureMatched)
//		    feature.newStyle.fillColor="green";


		if(feature.wasPruned && !feature.pruned ||
		   !feature.style ||
		   (feature.newStyle.display && 
		    feature.newStyle.display=="none" &&
		    feature.newStyle.display!=feature.style.display) ||
		   feature.style.fillColor!=feature.newStyle.fillColor) {
		    feature.style = feature.newStyle;


		    if(!feature.style.fillColor) {
			feature.style.fillColor = "rgba(230,230,230,0.5)";
			feature.style.strokeColor = "rgba(200,200,200,0.5)";
			feature.style.strokeWidth=1;

		    }
		    redrawCnt++;
		    this.vectorLayer.drawFeature(feature);
		}
		feature.newStyle = null;
	    });
//	    console.log("redraw:" + redrawCnt);

            if (!args.dontSetBounds && maxExtent && !this.hadInitialPosition && this.getCenterOnFilterChange(true)) {
//		console.log("max:" + this.map.transformProjBounds(maxExtent));
		this.map.zoomToExtent(maxExtent, true);
	    }
	    if(!this.getProperty("fixedPosition",false))  {
		this.hadInitialPosition    = false;
	    }

        },
	findContainingFeature: function(features, center, info,debug) {
//	    debug=true;
	    let matchedFeature = null;
            for (let j = 0; j < features.length; j++) {
                let feature = features[j];
                let geometry = feature.geometry;
                if (!geometry) {
		    if(debug) console.log("\tno geometry")
                    continue;
                }
                bounds = geometry.getBounds();
                if (!bounds.contains(center.x, center.y)) {
		    //		    if(debug) console.log("\tnot in bounds:" + bounds)
                    continue;
                }
		if(debug) console.log("\tfindContainingFeature:" + center.x+" " + center.y);
                if (geometry.components) {
		    if(debug) console.log("\thas components:" +geometry.components.length);
                    geometry.components.every(comp=> {
                        bounds = comp.getBounds();
                        if (!bounds.contains(center.x, center.y)) {
			    if(debug) console.log("\t\tnot contain:" + bounds + " " + comp.CLASS_NAME);
			    return true;
                        }
			if(!comp.containsPoint) {
			    if(debug) console.log("\t\tunknown geometry:" + comp.CLASS_NAME);
			    return true;
			}
			if(debug) console.log("\t\tcontains:" + comp.containsPoint(center));
                        if (comp.containsPoint(center)) {
                            matchedFeature = feature;
			    if (feature.geometry) {
				if (info.maxExtent === null) {
				    info.maxExtent = new OpenLayers.Bounds();
				}
				info.maxExtent.extend(feature.geometry.getBounds());
			    }
                            info.index = j;
			    return false;
                        }
			return true;
                    });
		}
		if(matchedFeature) return matchedFeature;
                if (!geometry.containsPoint) {
                    if(debug && !geometry.components) 
			console.log("unknown geometry:" + geometry.CLASS_NAME);
                    continue;
                }
                if (geometry.containsPoint(center)) {
		    if (info.maxExtent === null) {
			info.maxExtent = new OpenLayers.Bounds();
		    }
		    info.maxExtent.extend(geometry.getBounds());
                    matchedFeature = feature;
                    info.index = j;
                    break;
                }
	    }
	    return matchedFeature;
	},
        needsData: function() {
            return true;
        },
	animationStart:function(animation) {
	    if(this.myFeatures) {
                for (let i = 0; i < this.myFeatures.length; i++) {
                    let point = this.myFeatures[i];
                    point.style.display = 'none';
                }
	    }
            if (this.map.circles)
                this.map.circles.redraw();

	},
        handleDateRangeChanged: function(source, prop) {
	    this.getAnimation().setDateRange(prop.minDate, prop.maxDate);
	    this.applyDateRange();
	},
       	animationApply: function(animation) {
	    SUPER.animationApply.call(this,animation,true);
	    this.applyDateRange();
	},
       	applyDateRange: function() {
	    let animation = this.getAnimation();
            let windowStart = animation.begin.getTime();
            let windowEnd = animation.end.getTime();
            let atLoc = {};
	    if(this.myFeatures) {
		for (let i = 0; i < this.myFeatures.length; i++) {
                    let point = this.myFeatures[i];
                    if (point.date < windowStart || point.date > windowEnd) {
			point.style.display = 'none';
			continue;
                    }
                    if (atLoc[point.location]) {
			let other = atLoc[point.location];
			if (other.date < point.date) {
                            atLoc[point.location] = point;
                            other.style.display = 'none';
                            point.style.display = 'inline';
			} else {
                            point.style.display = 'none';
			}
			continue;
                    }
                    atLoc[point.location] = point;
                    point.style.display = 'inline';
		}
	    }

	    this.applyToFeatureLayers(layer=>{layer.redraw();});
            this.applyVectorMap(true, this.textGetter);
	},
        showAllPoints: function() {
	    if(this.myFeatures) {
		for (let i = 0; i < this.myFeatures.length; i++) {
		    let line = this.myFeatures[i];
		    line.style.display = 'inline';
		}
		if (this.map.lines)
		    this.map.lines.redraw();
	    }
	    this.applyToFeatureLayers(layer=>{layer.redraw();});
            this.applyVectorMap(true);
        },

	colorByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("colorBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({fieldChanged:true});
	},
	sizeByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("sizeBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({fieldChanged:true});
	},
	dataFilterChanged: function(args) {
	    if(!args) args = {};
	    this.vectorMapApplied  = false;
	    this.updateUI({source:args.source, dataFilterChanged:true, dontSetBounds:true,  reload:true,callback: ()=>{
		if(args.source=="animation") return;
		if(this.getCenterOnFilterChange(false)) {
		    if (this.vectorLayer && this.showVectorLayer) {
			this.map.zoomToLayer(this.vectorLayer,1.2);
		    } else if(this.lastImageLayer) {
			this.map.zoomToLayer(this.lastImageLayer);
		    } else {
			//true -> Just markers
			this.map.centerOnMarkers(null, false, true);
		    }
		}
	    }});
	},
	requiresGeoLocation: function() {
	    if(this.shapesField && this.shapesTypeField) return false;
	    return true;
	},
	addFilters: function(filters) {
	    SUPER.addFilters.call(this, filters);
	    if(this.getProperty("showBoundsFilter")) {
		filters.push(new BoundsFilter(this));
	    }
	},
	getHeader2:function() {
	    let html = SUPER.getHeader2.call(this);
	    if(this.getProperty("showClipToBounds")) {
		this.clipToView=false;
		html =  HU.div([STYLE,HU.css("display","inline-block","cursor","pointer","padding","1px","border","1px solid rgba(0,0,0,0)"), TITLE,"Clip to view", ID,this.domId("clip")],HU.getIconImage("fa-map"))+SPACE2+ html;
	    }


	    if(this.getProperty("showMarkersToggle")) {
		let dflt = this.getProperty("markersVisibility", true);
		html += HU.checkbox(this.domId("showMarkersToggle"),[ID,this.domId("showMarkersToggle")],dflt,
				    this.getProperty("showMarkersToggleLabel","Show Markers")) +SPACE2;
	    }

	    if(this.getProperty("showBaseLayersSelect",false)) {
		if(this.map.baseLayers) {
		    let items = [];
		    let on = false;
		    for(a in this.map.baseLayers) {
			let layer = this.map.baseLayers[a];
			if(!layer.isBaseLayer) continue;
			if(layer.getVisibility()) on = a;
			items.push([a,layer.name]);
		    }
		    html += HU.span([TITLE,"Choose base layer", CLASS,"display-filter"],  HU.select("",[ID,this.domId("baselayers")],items,on));
		}
	    }

	    if(this.getProperty("showVectorLayerToggle",false)) {
		html += HU.checkbox("",[ID,this.domId("showVectorLayerToggle")],!this.showVectorLayer) +" " +
		    this.getProperty("showVectorLayerToggleLabel","Show Points") +SPACE4;
	    }
	    html += HU.span([ID,this.domId("locations")]);

	    return html;
	},
	locationMenuCnt:0,
	addLocationMenu:function(url,data) {
	    let html = "";
	    let idx = this.locationMenuCnt++;
	    let label = data.label || data.name;
	    if(!label) {
		label = Utils.makeLabel(url.replace(/^.*[\\\/]/, '').replace(/\.[^\.]+$/,"").replace("_"," "));
	    }
	    html += HU.div([CLASS,"ramadda-menu-button ramadda-clickable bold",ID,this.domId("location_" + idx)],"View " + (label)) +SPACE;
	    this.map.appendToolbar(html);
//	    this.jq("locations").append(html);
	    let _this = this;
	    this.jq("location_" + idx).click(function() {
		let inner = "";
		let locations = [];
		if(data.features) {
		    data.features.forEach(feature=>{
			let name = feature.properties.NAME || feature.properties.name;
			locations.push({name:name,geometry:feature.geometry});
		    });
		} else {
		    locations = data.locations;
		}
		locations.sort((a,b)=>{
		    return a.name.localeCompare(b.name);
		});
		locations.forEach((loc,idx)=>{
		    if(Utils.isDefined(loc.latitude)) {
			inner+=HU.div([CLASS,"ramadda-clickable ramadda-hoverable", "latitude",loc.latitude,"longitude",loc.longitude,CLASS,"display-map-location"], loc.name);
		    } else if(Utils.isDefined(loc.north)) {
			inner+=HU.div([CLASS,"ramadda-clickable ramadda-hoverable", "north",loc.north,"west",loc.west,"south",loc.south,"east",loc.east, CLASS,"display-map-location"], loc.name);

		    } else if(Utils.isDefined(loc.geometry)) {
			inner+=HU.div([CLASS,"ramadda-clickable ramadda-hoverable", "index",idx, CLASS,"display-map-location"], loc.name);
		    }
		});
		inner = HU.div([ID,_this.domId("locationmenu"),STYLE,HU.css("max-height","200px","overflow-y","auto","padding","5px")],inner);
		let dialog = HU.makeDialog({content:inner,my:"left top",at:"left bottom",anchor:$(this),draggable:false,header:false});
		_this.jq("locationmenu").find(".ramadda-clickable").click(function() {
		    if(_this.locationFeatures) {
			_this.locationFeatures.forEach(feature=>{
			    _this.map.getHighlightLinesLayer().removeFeatures([feature]);
			});
		    }
		    _this.locationFeatures = [];
		    if($(this).attr("longitude")) {
			let point = MapUtils.createLonLat(+$(this).attr("longitude"),+$(this).attr("latitude"));
			_this.map.getMap().zoomTo(9);
			_this.map.setCenter(point);
		    } else if($(this).attr("north")) {
			_this.map.setViewToBounds(new RamaddaBounds(+$(this).attr("north"),+$(this).attr("west"),+$(this).attr("south"),+$(this).attr("east")));
		    } else {
			let geometry = locations[$(this).attr("index")].geometry;
			let type = geometry.type;
			let shapes = geometry.coordinates;
			let style = {
			    strokeColor: "blue",
			    fillColor:'rgba(0,0,255,0.10)',
			    strokeWidth: 2};
			if(type=="MultiPolygon") {
			    for(let i=0;i<shapes.length;i++) {
				let c2 = shapes[i];
				for(let j=0;j<c2.length;j++) {
				    _this.locationFeatures.push(_this.createFeature(c2[j],null,null,style));
				}
			    }
			} else if(type=="Polygon") {
			    for(let i=0;i<shapes.length;i++) {
				_this.locationFeatures.push(_this.createFeature(shapes[i],null,null,style));
			    }
			} else {
			    console.log("Unknown geometry:" + type);
			}
			_this.map.centerOnFeatures(_this.locationFeatures);
		    }
		    dialog.remove();
		});
	    });
	},
	initHeader2:function() {
	    let _this = this;
	    this.jq("baselayers").change(function() {
		let on = $(this).val();
		for(let id in _this.map.baseLayers) {
		    if(id==on) {
			_this.map.getMap().setBaseLayer(_this.map.baseLayers[id]);
			break;
		    }
		}
	    });


	    this.getProperty("locations","").split(",").forEach(url=>{
		url  =url.trim();
		if(url.length==0) return;
		if(!url.startsWith("/") && !url.startsWith("http")) {
		    url = ramaddaCdn + "/resources/" +url;			
		}
		let success = (data) =>{data=JSON.parse(data);this.addLocationMenu(url, data);};
		let fail = err=>{console.log("Error loading location json:" + url+"\n" + err);}
		Utils.doFetch(url, success,fail,null);	    
	    });


	    this.jq("showMarkersToggle").change(function() {
		let visible = $(this).is(':checked');
		_this.applyToFeatureLayers(layer=>{layer.setVisibility(visible);})
	    });
	    this.jq("showVectorLayerToggle").change(function() {
		_this.toggleVectorLayer();
	    });
	    
	    this.jq("clip").click(function(e){
		_this.clipToView = !_this.clipToView;
		if(!_this.clipToView) {
		    $(this).css("border","1px solid rgba(0,0,0,0)");
		} else {
		    $(this).css("border","1px solid #aaa");
		}
		_this.haveCalledUpdateUI = false;
		_this.updateUI();
	    });
	},

	handleNoData: function(pointData,reload) {
	    this.jq(ID_PAGE_COUNT).html("");
            this.addPoints([],[],[]);
	    this.setMessage(this.getNoDataMessage());
	},
	createFeature:function(polygon,record, textGetter, style){
	    if(!style) {
		if(this.baseStyle) {
		    this.baseStyle = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style['default']);
		    $.extend(this.baseStyle,{
			strokeColor: this.getProperty("vectorLayerStrokeColor","#000"),
			fillColor:this.getProperty("vectorLayerFillColor","#ccc"),
			fillOpacity:this.getProperty("vectorLayerFillOpacity",0.10),
			strokeWidth: this.getProperty("vectorLayerStrokeWidth",1),
			cursor:'pointer'
		    });
		}
		style = this.baseStyle;
	    }


	    let sitePoints = [];
	    polygon.forEach(pair=>{
		let point = new OpenLayers.Geometry.Point(pair[0],pair[1]);
		let projPoint = this.map.transformLLPoint(point);
		sitePoints.push(projPoint);
	    });
	    let linearRing = new OpenLayers.Geometry.LinearRing(sitePoints);
	    let geometry = new OpenLayers.Geometry.Polygon([linearRing]);
	    let polygonFeature = new OpenLayers.Feature.Vector(geometry, null, style);
	    this.map.getHighlightLinesLayer().addFeatures([polygonFeature]);
	    polygonFeature.record = record;
	    polygonFeature.textGetter = textGetter;
	    return polygonFeature;
	},
	loadShapes: function(records) {
	    if(this.coordinateFeatures) {
		this.map.getHighlightLinesLayer().removeFeatures(this.coordinateFeatures);
	    }
	    let textGetter = (f)=>{
		if(f.record) {
                    return  this.getRecordHtml(f.record, null, this.getProperty("tooltip"));
		}
		return "NONE";
	    };
	    this.coordinateFeatures = [];
	    records.forEach((r,idx)=>{
		let type = r.getValue(this.shapesTypeField.getIndex());		
		let shapesString= r.getValue(this.shapesField.getIndex());
		let shapes = JSON.parse(shapesString);
		if(type=="MultiPolygon") {
		    for(let i=0;i<shapes.length;i++) {
			let c2 = shapes[i];
			for(let j=0;j<c2.length;j++) {
			    this.coordinateFeatures.push(this.createFeature(c2[j],r,textGetter));
			}
		    }
		} else if(type=="Polygon") {
		    for(let i=0;i<shapes.length;i++) {
			this.coordinateFeatures.push(this.createFeature(shapes[i],r,textGetter));
		    }
		} else {
		    console.log("Unknown geometry:" + type);
		}
	    });

	},	    
	toggleTrack:function(record,item) {
	    let marker = this.markers?this.markers[record.getId()]:null;
	    if(this.tracks[record.getId()]) {
		if(item)item.removeClass("display-map-toc-item-on");
		this.map.removePolygon(this.tracks[record.getId()]);
		this.tracks[record.getId()] = null;
		if(item) {
		    item.attr(TITLE,"Click to view; Double-click to view track");
		}
	    } else {
		if(item) {
		    item.addClass("display-map-toc-item-on");
		    item.attr(TITLE,"Click to view; Double-click to remove track");
		}
		let url = record.getValue(this.trackUrlField.getIndex());
		if(url!="")
		    $.getJSON(url, data=>{this.loadTrack(record, data)}).fail(err=>{console.log("url failed:" + url +"\n" + err)});
	    }
	    this.map.setCenter(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude()));
	},
	makeToc:function(records) {
	    let labelField = this.getFieldById(null,this.getProperty("labelField","name"));
	    if(!labelField) labelField = this.getFieldByType(null,"string");
	    if(labelField) {
		let html = "";
		let iconField = this.getFieldById(null, this.getProperty("iconField"));
		records.forEach((record,idx)=>{
		    let title = "View record";
		    if(this.trackUrlField) title = "Click to view; Double-click to view track";
		    let clazz = "ramadda-clickable  display-map-toc-item ramadda-noselect";
		    let value = labelField.getValue(record);
		    if(!iconField) {
			clazz+=" ramadda-nav-list-link ";
		    } else {
			value = HU.getIconImage(iconField.getValue(record,icon_blank16),["width",16]) + SPACE + value;
		    }
		    html+= HU.span([TITLE, title, CLASS,clazz,RECORD_ID,record.getId(),RECORD_INDEX,idx], value);
		});

		let height = this.getProperty("height", this.getProperty("mapHeight", 300));

		html = HU.div([CLASS, "display-map-toc",STYLE,HU.css("max-height","calc(" +HU.getDimension(height)+" - 1em)"),ID, this.domId("toc")],html);
		let title = this.getProperty("tableOfContentsTitle","");
		if(title) html = HU.center(HU.b(title)) + html;
		this.jq(ID_LEFT).html(html);
		let _this = this;
		let items = this.jq(ID_LEFT).find(".display-map-toc-item");
		this.makeTooltips(items,records);
		items.click(function() {
		    let idx = $(this).attr(RECORD_INDEX);
		    let record = records[idx];
		    if(!record) return;
		    _this.highlightPoint(record.getLatitude(), record.getLongitude(),true, false);
		    _this.map.setCenter(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude()));
		    _this.map.setZoom(10);
		    if(record.trackData) {
			setTimeout(()=>{
			    _this.getDisplayManager().notifyEvent("dataSelection", _this, {data:record.trackData});
			},100);
		    }
		});

		items.dblclick(function() {
		    _this.removeHighlight();
		    let idx = $(this).attr(RECORD_INDEX);
		    let record = records[idx];
		    if(!record) return;
		    if(_this.trackUrlField) {
			let url = record.getValue(_this.trackUrlField.getIndex());
			if(url && url.length>0) {
			    _this.toggleTrack(record,$(this));
			    return;
			}
		    } 
		    _this.map.setCenter(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude()));
		});
	    }
	},	    

        updateUI: function(args) {
	    if(!args) args={};
	    let debug = false;
	    this.lastUpdateTime = null;
            SUPER.updateUI.call(this,args);
//	    console.log("map.updateUI: " + !this.getDisplayReady() +" " + !this.hasData() +" " +!this.getProperty("showData", true));
            if (this.haveCalledUpdateUI || !this.getDisplayReady() ||!this.hasData() || !this.getProperty("showData", true)) {
		if(debug) console.log("map.updateUI have called:" + this.haveCalledUI +" ready:" + this.getDisplayReady() +" has data:" + this.hasData() +" showData:" +this.getProperty("showData", true));
                return;
            }
            let pointData = this.getPointData();
	    this.lastZoom = this.map?this.map.getZoom():null;

	    //Set the shapes Fields here before filter data so we can accept non georeferenced data
	    this.shapesField = this.getFieldById(null,this.getProperty("shapesField"));
	    this.shapesTypeField = this.getFieldById(null,this.getProperty("shapesTypeField"));

	    this.trackUrlField  =  this.getFieldById(null,this.getProperty("trackUrlField"));

            let records = this.records =  this.filterData();
	    if(this.shapesTypeField && this.shapesField) {
		this.setProperty("tooltipNotFields",this.shapesTypeField.getId()+"," + this.shapesField);
		this.loadShapes(records);
	    }

	    if(debug) console.log("displaymap.updateUI reload=" +args.reload);
            if (records == null) {
		if(debug) console.log("\tno data");
                return;
            }

	    if(this.getShowTableOfContents(false)) {
		this.makeToc(records);
	    }
 
	    if(!this.updatingFromClip) {
		//stop the flash
		if(args.source!="animation") {
		    this.setMessage(args.dataFilterChanged|| args.fieldChanged|| args.reload?"Reloading map...":"Creating map...");
		}
	    }
	    this.updatingFromClip = false;

	    setTimeout(()=>{
		try {
		    this.updateUIInner(args, pointData, records,debug);
		    if(args.callback)args.callback();
		    this.clearProgress();
		} catch(exc) {
		    console.log(exc)
		    console.log(exc.stack);
		    this.setMessage("Error:" + exc);
		}
		this.setIsFinished();
	    });



	},
	filterDataPhase2:function(records) {
	    records = SUPER.filterDataPhase2.call(this,records);
	    if(this.clipBounds || this.clipToView) {
		let bounds = RecordUtil.getBounds(records);
		this.clipBounds = false;
		let clipRecords = false;
		if(!this.lastPointBounds || (this.lastPointBounds && this.lastPointBounds!=bounds)) {
		    clipRecords = true;
		}
		this.lastPointBounds = bounds;
		if(this.clipToView || clipRecords) {
		    let viewbounds = this.map.getMap().calculateBounds().transform(this.map.sourceProjection, this.map.displayProjection);
		    let tmpRecords =records.filter(r=>{
			return viewbounds.containsLonLat(new OpenLayers.LonLat(r.getLongitude(),r.getLatitude()));
		    });
//		    console.log("clipped records:" + tmpRecords.length);
		    records = tmpRecords;
		}
	    }
	    return records;
	},


	updateUIInner: function(args, pointData, records, debug) {
	    let _this = this;
	    let t1= new Date();
	    debug = debug || displayDebug.displayMapUpdateUI;
	    if(debug) console.log("displaymap.updateUIInner:" + records.length);
	    this.haveCalledUpdateUI = true;


	    if(this.getProperty("showRegionSelector")) {
		//Fetch the regions
		if(!ramaddaMapRegions) {
		    let jqxhr = $.getJSON(ramaddaCdn +"/regions.json", data=> {
			if (GuiUtils.isJsonError(data)) {
			    console.log("Error fetching regions");
			    ramaddaMapRegions=[];
			    return;
			}
			ramaddaMapRegions=data;
		    });
		}		    
		let label = this.getProperty("regionSelectorLabel") || HU.getIconImage("fa-globe-americas");
		let button = HU.div([CLASS,"ramadda-menu-button ramadda-clickable",  TITLE,"Select region", ID,this.domId("selectregion")],label)+SPACE2;
		this.writeHeader(ID_HEADER2_PREPREFIX, button);
		this.jq("selectregion").click(function() {
		    let id = _this.domId(ID_REGION_SELECTOR);
		    let groups = {};
		    ramaddaMapRegions.forEach((r,idx)=>{
			//skip world as its a dup
			if(r.name == "World") return
			let group = r.group;
			if(group.toLowerCase()=="model regions") group="Regions";
			let name = r.name.replace(/ /g,"&nbsp;");
			let item = HU.div([CLASS,"ramadda-menu-item", "idx",idx],name);
			if(!groups[group]) groups[group] = "";
			groups[group] +=item;});
		    let html = "<table width=100%><tr valign=top>";
		    Object.keys(groups).forEach(group=>{
			html+= HU.td([STYLE,HU.css()], HU.div([STYLE,HU.css("font-weight","bold","border-bottom","1px solid #ccc","margin-right","5px")], Utils.camelCase(group))+HU.div([STYLE,HU.css("max-height","200px","overflow-y","auto", "margin-right","10px")], groups[group]));
		    });
		    html+="</tr></table>"
		    //set the global 
		    let popup = HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
		    html = HU.div([ID,id],html);
		    popup.html(HU.div([CLASS, "ramadda-popup-inner"], html));
		    popup.show();
		    popup.position({
			of: $(this),
			my: "left top",
			at: "left bottom",
		    });
		    _this.jq(ID_REGION_SELECTOR).find(".ramadda-menu-item").click(function() {
			let region = ramaddaMapRegions[+$(this).attr("idx")];
			HtmlUtils.hidePopupObject();
			_this.map.setViewToBounds(new RamaddaBounds(region.north, region.west, region.south, region.east));
		    });
		});
	    }

	    if(!this.getProperty("makeDisplay",true)) {
		return;
	    }



            let pointBounds = {};
            let points = RecordUtil.getPoints(records, pointBounds);


            let fields = pointData.getRecordFields();
            let showSegments = this.getProperty("showSegments", false);
	    if(records.length!=0) {
		if (!isNaN(pointBounds.north)) {
		    this.initBounds = pointBounds;
		    if(!showSegments && !this.hadInitialPosition && !args.dontSetBounds) {
			if(!args.dataFilterChanged || this.getCenterOnFilterChange(true)) {
			    this.setInitMapBounds(pointBounds.north, pointBounds.west, pointBounds.south,
						  pointBounds.east);
			}
		    }
		}
	    }
	    if (this.map == null) {
		return;
	    }
	    if(this.highlightMarker) {
		this.map.removePoint(this.highlightMarker);
		this.map.removeMarker(this.highlightMarker);
		this.highlightMarker = null;
	    }
	    this.map.clearSeenMarkers();
	    let t2= new Date();
//	    debug = true;
	    if(debug) console.log("displaymap calling addPoints");
            this.addPoints(records,fields,points,pointBounds,debug);
	    let t3= new Date();
            this.addLabels(records,fields);
            this.applyVectorMap(true, this.textGetter,args);
	    let t4= new Date();
	    if(debug) Utils.displayTimes("time pts=" + points.length,[t1,t2,t3,t4], true);
	    this.lastUpdateTime = new Date();
	},
	heatmapCnt:0,
	animationApply: function(animation, skipUpdateUI) {
//	    console.log("map.applyAnimation:" +this.heatmapVisible);
 	    if(!this.heatmapLayers || !this.heatmapVisible) {
//		console.log("map.applyAnimation-1");
		SUPER.animationApply.call(this, animation, skipUpdateUI);
		return;
	    }
	    let onDate=null;
	    //	    console.log("displaymap.animationApply:" + animation.begin + " " +animation.end);
	    let onLayer = null;
	    let offLayers = [];
	    this.heatmapLayers.every(layer=>{
		if(!layer.date) return true;
		if(layer.date.getTime()>= animation.begin.getTime() && layer.date.getTime()<= animation.end.getTime()) {
		    onDate = layer.date;
		    onLayer = layer;
		    layer.setVisibility(true);
		} else {
		    if(layer.getVisibility()) 
			offLayers.push(layer);
		}
		return true;
	    })
	    offLayers.forEach(layer=>{
		layer.setVisibility(false);
	    });
	    console.log("map.applyAnimation-2:" + onDate);
 	    if(!onDate) {
		SUPER.animationApply.call(this, animation, skipUpdateUI);
	    }
	    if(onLayer!=null)
		this.setMapLabel(onLayer.heatmapLabel);
	},
        setDateRange: function(min, max) {
	    //Not sure why we do this
	    if(this.getProperty("doGridPoints",false)|| this.getProperty("doHeatmap",false)) {
		SUPER.setDateRange.call(this, min,max);
	    } else {
		SUPER.setDateRange.call(this, min,max);
	    }
	},
	showColorTable: function(colorBy) {
	    colorBy.displayColorTable(null,true);
	    this.callingUpdateSize = true;
	    //for now don't do this as it takes a long time
	    //	    this.map.getMap().updateSize();
	    this.callingUpdateSize = false;
	},

	applyHeatmapAnimation: function(index) {
	    this.jq(ID_HEATMAP_ANIM_LIST)[0].selectedIndex = index;
	    let offLayers = [];
	    this.heatmapLayers.forEach((layer,idx)=>{
		if(index==idx)
		    layer.setVisibility(true);
		else
		    offLayers.push(layer);
	    });
	    offLayers.forEach(layer=>{
		layer.setVisibility(false);
	    });
	    this.setMapLabel(this.heatmapLayers[index].heatmapLabel);

	},
	stepHeatmapAnimation: function(){
	    let index = this.jq(ID_HEATMAP_ANIM_LIST)[0].selectedIndex;
	    index++;
	    if(index>=this.heatmapLayers.length) {
		index =0;
	    }
	    this.applyHeatmapAnimation(index);
	    if(this.heatmapPlayingAnimation) {
		setTimeout(()=>{
		    this.stepHeatmapAnimation();
		},this.getHmAnimationSleep(1000));
	    }
	},
	checkHeatmapReload:function() {
//	    return
	    if(!this.getHmReloadOnZoom(this.getReloadOnZoom(false))) return;
	    let now = new Date ();
	    //Don't do this the first couple of seconds after we've been created
	    if(now.getTime()-this.createTime.getTime()<3000) return;
	    let diff = 0;
	    if(this.checkHeatmapReloadTime) {
		diff = now.getTime()-this.checkHeatmapReloadTime.getTime();
	    }
	    this.checkHeatmapReloadTime = now;
	    if(diff<1000) {
		if(!this.checkHeatmapReloadPending) {
		    this.checkHeatmapReloadPending = true;
		    setTimeout(()=>{
			this.checkHeatmapReloadPending = false;
			this.checkHeatmapReload();
		    },1100)
		}
		return;
	    }
	    this.checkHeatmapReloadTime = null;
	    this.reloadHeatmap = true;
	    this.haveCalledUpdateUI = false;
	    this.updateUI();
	},
	createHeatmap(records, fields, bounds) {
	    let debug = displayDebug.displayMapCreateMap;
	    if(debug) console.log("createHeatmap");
	    let colorBy = this.getColorByInfo(records, null,null,null,["hmColorBy","colorBy",""]);
	    let angleBy = this.getColorByInfo(records, "angleBy",null,null,["hmAngleBy","angleBy",""]);
	    let lengthBy = this.getColorByInfo(records, "lengthBy",null,null,["hmLengthBy","lengthBy",""]);
	    if(!angleBy.isEnabled()) angleBy = colorBy;
	    if(!lengthBy.isEnabled()) lengthBy=null;
	    records = records || this.filterData();
	    if(this.getHmBounds()) {
		let toks = this.getHmBounds().split(",");
		bounds = new RamaddaBounds(+toks[0],+toks[1], +toks[2],+toks[3]);
	    }
	    let mapBounds = this.map.getBounds();
	    bounds = bounds ||  RecordUtil.getBounds(records);
	    bounds = RecordUtil.convertBounds(mapBounds);

 	    if(this.heatmapLayers) {
		try {
		    this.heatmapLayers.every(layer=>{
			this.map.removeLayer(layer);
			return true;
		    });
		} catch(exc) {
		    console.log(exc);
		}
	    }
	    this.heatmapLayers = [];
	    if(records.length==0) {
		this.errorMessage = this.getNoDataMessage();
		this.setMessage(this.errorMessage);
		return
	    }
	    if(this.reloadHeatmap) {
		this.reloadHeatmap = false;
		bounds = new RamaddaBounds(this.map.getBounds());
		records = RecordUtil.subset(records, bounds);
//		bounds =  RecordUtil.getBounds(records);
	    }
	    bounds = RecordUtil.expandBounds(bounds,this.getProperty("boundsScale",0.05));

	    let dfltArgs = this.getDefaultGridByArgs();
	    let ratio = (bounds.east-bounds.west)/(bounds.north-bounds.south);
	    let w = Math.round(this.getProperty("gridWidth",800));
	    let h = Math.round(w/ratio);
	    let groupByField = this.getFieldById(null,this.getHmGroupBy());
	    let groupByDate = this.getHmGroupByDate();
	    if(debug) console.log("\tcalling groupBy");
	    let t1 = new Date();
	    let groups = (groupByField || groupByDate)?RecordUtil.groupBy(records, this, groupByDate, groupByField):null;
	    let t2 = new Date();
	    //	    Utils.displayTimes("make groups",[t1,t2],true);
	    if(debug) console.log("\tdone calling groupBy");
	    if(groups == null || groups.max == 0) {
		doTimes = false;
		groups= {
		    max:records.length,
		    values:["none"],
		    map:{none:records}
		}
	    }
	    
	    //	    if(debug) console.log("\tdone calling groupBy count="+ groups.values.length);
	    let recordCnt = groups.max;
 	    if(dfltArgs.cellSize==0) {
		let sqrt = Math.sqrt(recordCnt);
		let size = Math.round(w/sqrt);
		dfltArgs.cellSizeX = dfltArgs.cellSizeY = dfltArgs.cellSize = size;
	    } else if(String(dfltArgs.cellSize).endsWith("%")) {
		dfltArgs.cellSize =dfltArgs.cellSizeX =  dfltArgs.cellSizeY = Math.floor(parseFloat(dfltArgs.cellSize.substring(0,dfltArgs.cellSize.length-1))/100*w);
	    }
	    let args =$.extend({colorBy:colorBy,angleBy:angleBy,lengthBy:lengthBy,w:w,h:h,bounds:bounds,forMercator:true},
			       dfltArgs);
	    if(debug) {
		console.log("#records:" + records.length+" dim:" + w +" " +h + " #records:" + records.length +" cell:" + dfltArgs.cellSizeX + " #records:" + records.length +" bounds:" + bounds);
	    }
	    let labels = [];
	    let labelPrefix = this.getHmLabelPrefix("${field}-");
	    groups.values.every((value,idx)=>{
		let recordsAtTime = groups.map[value];
		if(debug)
		    console.log("group:" + value +" #:" + groups.map[value].length);

		let img = Gfx.gridData(this.getId(),fields, recordsAtTime,args);
//		$("#testimg").html(HU.image(img,[WIDTH,"100%", STYLE,"border:1px solid blue;"]));
		let label = value=="none"?"Heatmap": labelPrefix +" " +groups.labels[idx];
		label = label.replace("${field}",colorBy.field?colorBy.field.getLabel():"");
		labels.push(label);
//		console.log("B:" + bounds);
		let layer = this.map.addImageLayer("heatmap"+(this.heatmapCnt++), label, "", img, idx==0, bounds.north, bounds.west, bounds.south, bounds.east,w,h, { 
		    isBaseLayer: false,
		});
		this.map.getMap().setLayerIndex(layer, 1000);
		layer.heatmapLabel = label;
		if(groupByDate) {
		    if(value.getTime)
			layer.date = value;
		}
		this.heatmapLayers.push(layer);
		return true;
	    });
	    if(this.getHmShowGroups(true) && this.heatmapLayers.length>1 && !this.getAnimationEnabled()) {
		this.heatmapPlayingAnimation = false;
		let controls =  "";
		if(!groupByField) 
		    controls+=HU.div([ID,this.domId(ID_HEATMAP_ANIM_PLAY),STYLE,HU.css("display","inline-block"),TITLE,"Play/Stop Animation"],
				     HU.getIconImage("fa-play",[CLASS,"display-anim-button"]));
		controls += HU.div([ID,this.domId(ID_HEATMAP_ANIM_STEP),STYLE,HU.css("display","inline-block"),TITLE,"Step"],
 				   HU.getIconImage("fa-step-forward",[CLASS,"display-anim-button"]));
		
		controls += HU.div([STYLE,HU.css("display","inline-block","margin-left","5px","margin-right","5px")], HU.select("",[ID,this.domId(ID_HEATMAP_ANIM_LIST)],labels));
		this.writeHeader(ID_HEADER2_PREPREFIX, controls);
		let _this = this;
		this.jq(ID_HEATMAP_ANIM_LIST).change(function() {
		    let index = $(this)[0].selectedIndex;
		    _this.applyHeatmapAnimation(index);
		});
		this.jq(ID_HEATMAP_ANIM_PLAY).click(function() {
		    _this.heatmapPlayingAnimation = !_this.heatmapPlayingAnimation;
		    let icon = _this.heatmapPlayingAnimation?"fa-stop":"fa-play";
		    $(this).html(HU.getIconImage(icon,[CLASS, "display-anim-button"]));
		    if(_this.heatmapPlayingAnimation) {
			_this.stepHeatmapAnimation();
		    }
		});
		this.jq(ID_HEATMAP_ANIM_STEP).click(function() {
		    _this.heatmapPlayingAnimation = false;
		    let icon = _this.heatmapPlayingAnimation?"fa-stop":"fa-play";
		    _this.jq(ID_HEATMAP_ANIM_PLAY).html(HU.getIconImage(icon,[CLASS,"display-anim-button"]));
		    _this.stepHeatmapAnimation();
		});

	    }
	    if(groups.values[0]!="none") {
		this.setMapLabel(labels[0]);
	    }
	    this.showColorTable(colorBy);
	    if(this.getHmShowToggle() || this.getHmShowReload()) {
		let cbx = this.jq(ID_HEATMAP_TOGGLE);
		let reload =  HU.getIconImage("fa-sync",[CLASS,"display-anim-button",TITLE,"Reload heatmap", ID,this.domId("heatmapreload")])+SPACE2;
		this.heatmapVisible= cbx.length==0 ||cbx.is(':checked');

		this.writeHeader(ID_HEADER2_PREFIX,
				 reload + HU.checkbox("",[ID,this.domId(ID_HEATMAP_TOGGLE)],this.heatmapVisible) +SPACE +
				 this.getHmToggleLabel("Toggle Heatmap") +SPACE2);
		let _this = this;
		this.jq("heatmapreload").click(()=> {
		    this.reloadHeatmap = true;
		    this.haveCalledUpdateUI = false;
		    this.updateUI();
		});
		this.jq(ID_HEATMAP_TOGGLE).change(function() {
		    if(_this.heatmapLayers)  {
			let visible = $(this).is(':checked');
			_this.heatmapVisible  = visible;
			_this.heatmapLayers.forEach(layer=>layer.setVisibility(visible));
			_this.map.setPointsVisibility(!visible);
		    }
		});
	    }
	},

	updateHtmlLayers: function() {
	    if(this.htmlLayerInfo) {
		this.createHtmlLayer(this.htmlLayerInfo.records, this.htmlLayerInfo.fields);
	    }
	},
	updateHtmlLayer:function() {
	    if(!this.htmlLayer) return;
	    if(!this.htmlLayerId) {
		this.htmlLayerId =this.getUniqueId(ID_HTMLLAYER);
		let vp  = this.map.getMap().getViewport();
		vp = $(vp).children()[0];
		$(vp).css("display","relative");
		$(vp).append(HU.div([CLASS,"display-map-htmllayer", ID,this.htmlLayerId]));
	    }
	    $("#"+ this.htmlLayerId).html(this.htmlLayer);
	},
        createHtmlLayer: function(records, fields) {
	    let htmlLayerField = this.getFieldById(fields,this.getHtmlLayerField());
	    this.htmlLayerInfo = {
		records:records,
		fields:fields,
	    };
	    this.htmlLayer = "";
	    let w = this.getHtmlLayerWidth(30);
	    let h = this.getHtmlLayerHeight(15);
	    let shape = this.getHtmlLayerShape("barchart");
	    if(shape=="barchart")
		this.setProperty("colorBy",htmlLayerField.getId());
	    if(this.getHtmlLayerScale()) {
		let zooms = [];		
		this.getHtmlLayerScale().split(",").forEach(t=>{
		    zooms.push(t.split(":"));
		});
		//3:0.5,4:1,5:2
		let zoom = this.map.map.getZoom();
		let scale = 1.0;
		if(zooms.length==1 && zooms[0].length==1) {
		    scale=zooms[0][0];
		} else {
		    zooms.every(t=>{
			scale=t[1];
			if(t[0] >= zoom) {
			    return false;
			}
			return true;
		    });
		}
		w*=scale;h*=scale;
	    }
	    let style = this.getHtmlLayerStyle("");
	    let infos = [];
	    let allData = this.getColumnValues(records, htmlLayerField);
	    let groups = RecordUtil.groupBy(records, this, false,"latlon");
	    let container = $($(this.map.getMap().getViewport()).children()[0]);
	    let cleft = +container.css("left").replace("px","");
	    let ctop = +container.css("top").replace("px","");
	    let hoverW = w*3;
	    let hoverH = h*3;
	    let layerRecords = [];

	    groups.values.forEach((value,idx)=>{
		let recordsAtTime = groups.map[value];
		let data = [];
		layerRecords.push(recordsAtTime[0]);
		recordsAtTime.forEach((r,idx)=>{
		    data.push(r.getValue(htmlLayerField.getIndex()));
		});
		let record = recordsAtTime[0];
		let px = this.map.getMap().getPixelFromLonLat(this.map.transformLLPoint(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude())));
		let id = this.getId() +"_sl"+ idx;
		let hid = id +"_hover";
		let html = 
		    HU.div([ID,id,  CLASS,'display-map-html-item',STYLE,style +HU.css('line-height','0px','z-index','1000','position','absolute','left', (px.x-w/2-cleft) +'px','top', (px.y-h/2-ctop)+'px')]) +
		    HU.div([ID,hid, RECORD_INDEX, idx,TITLE,"", CLASS,'display-map-html-hitem', STYLE,style +HU.css('display','none','line-heigh','0px','z-index','1001','position','absolute','left', (px.x-hoverW/2-cleft) +'px','top', (px.y-hoverH/2-ctop)+'px')]);
		this.htmlLayer += html;
		infos.push({
		    id:id,
		    hoverId: hid,
		    data:data,
		    records: recordsAtTime
		});
	    });
	    this.updateHtmlLayer();
            let colorBy = this.getColorByInfo(records);
	    infos.forEach((info,idx)=>{
		if(shape == "pie" || shape == "piechart") {
		    [0,1].forEach((cid,idx)=>{
			let id = HU.getUniqueId("pie");
			let cw = idx==0?w:hoverW;
			let ch = idx==0?h:hoverH;
			let pie = HU.tag('canvas',[STYLE,HU.css('cursor','pointer'),ID,id ,WIDTH,cw,HEIGHT, ch]);
			if(idx==0)
			    $("#" + info.id).html(pie);
			else
			    $("#" + info.hoverId).html(pie);
			let canvas = document.getElementById(id);
			let color = colorBy&& colorBy.isEnabled()?colorBy.getColor(info.data[0]):this.getFillColor("#619FCA");
			var ctx = canvas.getContext("2d");
			if(idx==1) {
			    ctx.fillStyle= '#fff';
			    ctx.beginPath();
			    ctx.moveTo(cw/2,ch/2);
			    ctx.arc(cw/2,ch/2, cw/2-2, 0-Math.PI/2, 2*Math.PI);
			    ctx.closePath();
			    ctx.fill();
			}
			ctx.beginPath();
			ctx.moveTo(cw/2,ch/2);
			ctx.arc(cw/2,ch/2, cw/2-2, 0-Math.PI/2, info.data[0]*2 * Math.PI-Math.PI/2);
			ctx.lineTo(cw/2,ch/2);
			ctx.closePath();
			ctx.strokeStyle= this.getStrokeColor("#888");
			ctx.fillStyle= color;
			ctx.fill();
			ctx.stroke();
			ctx.beginPath();
			ctx.arc(cw/2,ch/2, cw/2-2, 0, 2 * Math.PI);
			ctx.closePath();
			ctx.stroke();
		    });
		} else {
		    drawSparkLine(this,"#"+ info.id,w,h,info.data,info.records,allData.min,allData.max,colorBy);
		    $('#' + info.hoverId).css('background','#fff').css('border','1px solid #ccc');
		    drawSparkLine(this,"#"+ info.hoverId,hoverW,hoverH,info.data,info.records,allData.min,allData.max,colorBy);		    
		}
	    });
	    let items = this.find(".display-map-html-item");
	    let hitems = this.find(".display-map-html-hitem");
	    this.makeTooltips(hitems, layerRecords);

	    items.mouseenter(function() {
		$(this).css('display','none');
		$("#"+$(this).attr(ID)+"_hover").fadeIn(1000);
		
	    });
	    hitems.mouseleave(function() {
		$("#"+ $(this).attr(ID).replace('_hover','')).css('display','block');
		$(this).css('display','none');
	    });
	    if(colorBy.hasField()) {
		this.showColorTable(colorBy);
	    }
	},
        addPoints: function(records, fields, points,bounds,debug) {
	    if(this.getDoGridPoints()|| this.getDoHeatmap(false)) {
		if(this.getHmShowPoints() || this.getShowPoints()) {
		    this.createPoints(records, fields, points, bounds,debug);
		    if(this.getHmShowToggle(false) && this.map.circles) {
			this.map.setPointsVisibility(false);
		    }
		}

		this.createHeatmap(records, fields, bounds);
		return;
	    }
	    if(this.getHtmlLayerField()) {
		this.createHtmlLayer(records, fields);
		return;
	    }
	    this.createPoints(records, fields, points, bounds,debug);
	},
        createPoints: function(records, fields, points,bounds, debug) {
	    debug = debug ||displayDebug.displayMapAddPoints;
	    let debugTimes  = false;
	    let features = [];
	    let featuresToAdd = [];
	    let pointsToAdd = [];	    
	    
	    //getColorByInfo: function(records, prop,colorByMapProp, defaultColorTable,propPrefix) {
            let colorBy = this.getColorByInfo(records,null,null,null,null,this.lastColorBy);
	    this.lastColorBy = colorBy;
	    let cidx=0
	    let polygonField = this.getFieldById(fields, this.getProperty("polygonField"));
	    let polygonColorTable = this.getColorTable(true, "polygonColorTable",null);
	    let latlon = this.getProperty("latlon",true);
            let source = this;
            let radius = +this.getPropertyRadius(8);
	    let highlightRecords = this.getFilterHighlight();
	    let unhighlightFillColor = this.getUnhighlightColor();
	    let unhighlightStrokeWidth = this.getProperty("unhighlightStrokeWidth",0);
	    let unhighlightStrokeColor = this.getProperty("unhighlightStrokeColor","#aaa");
	    let unhighlightRadius = this.getProperty("unhighlightRadius",-1);
	    this.markers = {};
	    if(this.getPropertyScaleRadius()) {
		let seen ={};
		let numLocs = 0;
		points.every(p=>{
		    let key = p.x+"_"+p.y;
		    if(!seen[key]) {
			numLocs++;
			seen[key] = true;
		    }
		    return true;
		});
		let radiusScale = this.getPropertyRadiusScale();
		if(Utils.stringDefined(radiusScale)) {
		    radiusScale = radiusScale.split(",").map(t=>{return +t;});
		} else  {
		    //Just make up some numbers
		    radiusScale =[10000,2,6000,3,4500,4,3500,5,2600,6,1300,7,800,8,300,9,275,10,250,11,225,12,175,13,125,14,100,15,50,16];
		}
		radius=radiusScale[1];
		for(let i=0;i<radiusScale.length;i+=2) {
		    if(numLocs<radiusScale[i]) {
			radius = radiusScale[i+1];
		    }
		}
//		console.log("#locs:" + numLocs +" #records:" +records.length + " radius:" + radius);
	    }

	    radius = Math.min(radius, this.getMaxRadius());



            let strokeWidth = +this.getPropertyStrokeWidth();
            let strokeColor = this.getPropertyStrokeColor();
            let sizeByAttr = this.getDisplayProp(source, "sizeBy", null);
            let isTrajectory = this.getDisplayProp(source, "isTrajectory", false);
            if (isTrajectory) {
                let attrs = {
                    strokeWidth: 2,
                    strokeColor: "blue",
		    fillColor:this.getProperty("fillColor","transparent")
                }
		if(points.length==1) {
		    featuresToAdd.push(this.map.createPoint(ID,  points[0], attrs, null));
		} else {
		    if(this.getShowPathEndPoint()) {
			featuresToAdd.push(this.map.createMarker("startpoint", points[0],ramaddaCdn+"/icons/map/marker-green.png"));
			featuresToAdd.push(this.map.createMarker("endpoint", points[points.length-1],ramaddaCdn+"/icons/map/marker-blue.png"));
		    }
                    featuresToAdd.push(this.map.createPolygon(ID, "", points, attrs, null));
		}
		this.addFeatures(featuresToAdd);
                return;
            }

            let latField1 = this.getFieldById(fields, this.getProperty("latField1"));
            let latField2 = this.getFieldById(fields, this.getProperty("latField2"));
            let lonField1 = this.getFieldById(fields, this.getProperty("lonField1"));
            let lonField2 = this.getFieldById(fields, this.getProperty("lonField2"));
            let sizeSegments = this.getProperty("sizeSegments", false);
            let sizeEndPoints = this.getProperty("sizeEndPoints", true);
            let showEndPoints = this.getProperty("showEndPoints", false);
            let endPointSize = parseInt(this.getProperty("endPointSize", "4"));
            let dfltEndPointSize = endPointSize;
            let segmentWidth = parseInt(this.getProperty("segmentWidth", "1"));
            let dfltSegmentWidth = segmentWidth;
	    let haveLayer = this.getShowLayers() && (this.getProperty("geojsonLayer") || this.getProperty("kmlLayer"));
            let showPoints = this.getProperty("showPoints", !haveLayer);
            let lineColor = this.getProperty("lineColor", "green");
	    let lineCap = this.getProperty('lineCap', 'round');
            let iconField = this.getFieldById(fields, this.getProperty("iconField"));
            let rotateField = this.getFieldById(fields, this.getProperty("rotateField"));	    
	    let markerIcon = this.getProperty("markerIcon",this.getProperty("pointIcon"));
	    if(markerIcon && markerIcon.startsWith("/")) {
                markerIcon =  ramaddaBaseUrl + markerIcon;
	    }
	    let usingIcon = markerIcon || iconField;
            let iconSize = parseFloat(this.getProperty("iconSize",this.getProperty("radius",32)));
	    let iconMap = this.getIconMap();
	    let dfltShape = this.getProperty("defaultShape",null);
	    let dfltShapes = ["circle","triangle","star",  "square", "cross","x", "lightning","rectangle","church"];
	    let dfltShapeIdx=0;
	    let shapeBy = {
		id: this.getDisplayProp(source, "shapeBy", null),
		field:null,
		map: {}
	    }


	    if(this.getDisplayProp(source, "shapeByMap", null)) {
		this.getDisplayProp(source, "shapeByMap", null).split(",").forEach((pair)=>{
		    let tuple = pair.split(":");
		    shapeBy.map[tuple[0]] = tuple[1];
		})
	    }

	    let sizeBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records);
            for (let i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.getId() == shapeBy.id || ("#" + (i + 1)) == shapeBy.id) {
                    shapeBy.field = field;
		    if (field.isString()) shapeBy.isString = true;
                }
            }
            shapeBy.index = shapeBy.field != null ? shapeBy.field.getIndex() : -1;


            if (this.getProperty("showColorByMenu", false) && colorBy.field && !this.madeColorByMenu) {
                this.madeColorByMenu = true;
                let menu = HU.open(SELECT,[CLASS,'ramadda-pulldown',ID,this.domId("colorByMenu")]);
                for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
                    if (!field.isNumeric() || field.isFieldGeo()) continue;
                    let extra = "";
                    if (colorBy.field.getId() == field.getId()) extra = "selected ";
                    menu += "<option value='" + field.getId() + "' " + extra + ">" + field.getLabel() + "</option>\n";
                }
                menu += HU.close(SELECT);
                this.writeHtml(ID_TOP_RIGHT, "Color by: " + menu);
                this.jq("colorByMenu").change(() => {
                    let value = this.jq("colorByMenu").val();
                    this.vectorMapApplied = false;
		    this.haveCalledUpdateUI = false;
                    this.setProperty("colorBy", value);
                    this.updateUI();
                });
            }



	    let dateMin = null;
	    let dateMax = null;

	    let dates = [];
            let justOneMarker = this.getPropertyJustOneMarker();

            for (let i = 0; i < records.length; i++) {
                let pointRecord = records[i];
		dates.push(pointRecord.getDate());
                if (dateMin == null) {
                    dateMin = pointRecord.getDate();
                    dateMax = pointRecord.getDate();
                } else {
                    let date = pointRecord.getDate();
                    if (date) {
                        if (date.getTime() < dateMin.getTime())
                            dateMin = date;
                        if (date.getTime() > dateMax.getTime())
                            dateMax = date;
                    }
                }
	    }


            if (dateMax) {
		if (this.getAnimationEnabled()) {
		    //TODO: figure out when to call this. We want to update the animation if it was from a filter change
		    //but not from an animation change. Hummmm.
		    //this.getAnimation().init(dateMin, dateMax,records);
		}
            }

	    this.removeFeatureLayer();

            let didColorBy = false;
            let seen = {};
	    let xnct =0;
	    let lastPoint;
	    let pathAttrs ={
		strokeColor: this.getProperty("pathColor",lineColor),
		strokeWidth: this.getProperty("pathWidth",1)
	    };


	    let fillColor = this.getPropertyFillColor();
	    let fillOpacity =  this.getPropertyFillOpacity();
	    let isPath = this.getProperty("isPath", false);
	    let groupByField = this.getFieldById(null,this.getProperty("groupByField"));
	    let groups;
	    if(groupByField)
		groups =  RecordUtil.groupBy(records, this, false, groupByField);
	    

	    let showSegments = this.getProperty("showSegments", false);
	    let tooltip = this.getProperty("tooltip");
	    let highlight = this.getProperty("highlight");
	    let highlightTemplate = this.getProperty("highlightTemplate");
	    if(highlightTemplate)
		highlight=true;
	    
	    let highlightWidth = this.getProperty("highlightWidth",200);
	    let highlightHeight = this.getProperty("highlightHeight",-1);
	    let highlightSize = null;
	    if(highlightHeight>0) {
	    	highlightSize = new OpenLayers.Size(highlightWidth,highlightHeight);
	    }


	    let addedPoints = [];
	    let textGetter = this.textGetter = f=>{
		if(f.record) {
		    let text =   this.getRecordHtml(f.record, fields, tooltip);
		    if(text=="") return "BLANK";
		    return text;
		}
		return null;
	    };
	    let highlightGetter = f=>{
		if(f.record) {
                    return   HU.div([STYLE,HU.css('background','#fff')],this.getRecordHtml(f.record, fields, highlightTemplate|| tooltip));
		}
		return null;
	    };	    
	    this.haveAddPoints = true;
	    let displayInfo = this.displayInfo = {};
	    records.forEach(record=>{
		let recordLayout = displayInfo[record.getId()] = {
		    features:[],
		    visible:true
		}
		if(!record.point) {
		    recordLayout.x = record.getLongitude();
		    recordLayout.y = record.getLatitude();
		} else {
		    recordLayout.x = record.point.x;
		    recordLayout.y = record.point.y;
		}
	    });


	    if(this.getHandleCollisions()) {
		//TODO: labels
		let doLabels = this.getProperty("collisionLabels",false);
		if(doLabels &!this.map.collisionLabelsLayer) {
		    this.map.collisionLabelsLayer = new OpenLayers.Layer.Vector("Collision Labels", {
			styleMap: new OpenLayers.StyleMap({'default':{
                            label : "${label}"
			}}),
                    });
		    this.map.addVectorLayer(this.map.collisionLabelsLayer, true);
                    this.map.collisionLabelsLayer.setZIndex(100);
		}

		let mapBounds = this.map.getBounds();
		let mapW = mapBounds.right-mapBounds.left;
		let divW  = $("#" + this.getProperty(PROP_DIVID)).width();
		let pixelsPer = divW/mapW;
		let scaleFactor = 360/pixelsPer;
		let baseOffset = mapW*0.025;
		let offset = 0;
		let cnt = 0;
		let minPixels = this.getProperty("collisionMinPixels",16);
		//figure out the offset but use cnt so we don't go crazy
		while(pixelsPer*offset<minPixels && cnt<100) {
		    offset+=baseOffset;
		    cnt++;
		}
		let lineWidth = this.getProperty("collisionLineWidth","2");				
		let lineColor = this.getProperty("collisionLineColor","#000");
		//		console.log("checking collisions:" + mapBounds +" offset:" + offset);
		let seen1={};
//		let decimals =  parseFloat(this.getProperty("collisionRound",1));
		let decimals = -1;
		let pixels = [6,12,24,48,96,192];
		for(let i=0;i<pixels.length;i++) {
		    if(pixelsPer<pixels[i]) break;
		    decimals++;
		}
		let rnd = (v)=>{
		    if(decimals>0) {
			let v0 = Utils.roundDecimals(v,decimals);
			return v0;
		    }
		    v= Math.round(v);
		    if(decimals<0)
			if (v%2 != 0)
			    v--;
		    return v;
		};
		let getPoint = (p=>{
		    let lat = rnd(p.y);
		    let lon = rnd(p.x);
		    return new OpenLayers.Geometry.Point(lon,lat);
		});
		let recordInfo = {};
		records.forEach(record=>{
		    let recordLayout = displayInfo[record.getId()];
		    if(recordLayout.x===null || recordLayout.y===null) return;
		    recordLayout.rpoint = getPoint(recordLayout);
		    if(seen1[recordLayout.rpoint]) {
			seen1[recordLayout.rpoint]++;
		    } else {
			seen1[recordLayout.rpoint]=1;
		    }
		});
		let collisionState= this.collisionState = {};
		records.forEach((record,idx)=>{
		    let recordLayout = displayInfo[record.getId()];
		    let point = recordLayout;
		    let rpoint = recordLayout.rpoint;
		    if(rpoint ==null) return;
		    if(seen1[rpoint]==1) {
			return;
		    } 
		    let cntAtPoint = seen1[rpoint];
		    let anglePer = 360/cntAtPoint;
		    let lineOffset = offset;
		    let delta = cntAtPoint/8;
		    if(delta>1)
			lineOffset*=delta;
		    let info = collisionState[rpoint];
		    if(!info) {
			info = collisionState[rpoint]= new CollisionInfo(this, seen1[rpoint], rpoint);
                        featuresToAdd.push(info.createDot(idx));
		    }
		    recordLayout.collisionInfo = info;
		    recordLayout.visible = info.visible;
		    info.addRecord(record);
		    let cnt = info.records.length;
		    let ep = Utils.rotate(rpoint.x,rpoint.y,rpoint.x,rpoint.y-lineOffset,cnt*anglePer-180,true);
		    let line = this.map.createLine("line-" + idx, "", rpoint.y,rpoint.x, ep.y,ep.x, {strokeColor:lineColor,strokeWidth:lineWidth});
		    if(!info.visible) {
			line.featureVisible = false;
			this.map.checkFeatureVisible(line,true);
		    }
		    info.addLine(line);
		    featuresToAdd.push(line);
		    point.x=ep.x;
		    point.y=ep.y;
		});
	    }

	    let i=0;
	    let sizeByFunc = function(percent, size) {
                if (sizeEndPoints &&!isNaN(percent)) {
		    endPointSize = dfltEndPointSize + parseInt(10 * percent);
                }
                if (sizeSegments) {
		    if(isNaN(percent)) {
			segmentWidth = dfltSegmentWidth + size;
		    } else {
			segmentWidth = dfltSegmentWidth + parseInt(10 * percent);
			segmentWidth=size;
			if(segmentWidth==0 || isNaN(segmentWidth)) segmentWidth=1;
		    }
                }
	    };


	    if(isPath && groups) {
		groups.values.forEach(value=>{
		    let firstRecord = null;
		    let lastRecord = null;
		    let secondRecord = null;		    
		    groups.map[value].forEach(record=>{
			if(!firstRecord) firstRecord=record;
			i++;
			if(lastRecord) {
			    pathAttrs.strokeColor = colorBy.getColorFromRecord(record, pathAttrs.strokeColor,true);
			    let line = this.map.createLine("line-" + i, "", lastRecord.getLatitude(), lastRecord.getLongitude(), record.getLatitude(),record.getLongitude(),pathAttrs);
			    featuresToAdd.push(line);
			    line.record=record;
			    line.textGetter=textGetter;
			}
			secondRecord = lastRecord;
			lastRecord = record;
			if(secondRecord) {
/*
			    var angleDeg = Utils.getBearing({x:lastRecord.getLongitude(),
							   
							   y:lastRecord.getLatitude()},
							  {x:secondRecord.getLongitude(),
							   y:secondRecord.getLatitude()});							  
//			    let endPoint = this.map.createPoint("endpoint", {x:lastRecord.getLongitude(),y:lastRecord.getLatitude()}, {fillColor:"red",strokeColor:"#000",pointRadius:6,graphicName:"arrow",rotation:angleDeg}, null);
//featuresToAdd.push(endPoint);
//                            featuresToAdd.push(endPoint);
*/
			}

		    });
		    if(lastRecord) {
			let color=  colorBy.getColorFromRecord(lastRecord, pathAttrs.strokeColor);
			if(secondRecord && this.getShowPathEndPoint(false)) {
			    let shape = this.getProperty("pathEndPointShape",null);
			    var angleDeg = Utils.getBearing({lon:secondRecord.getLongitude(),
							     lat:secondRecord.getLatitude()},
							    {lon:lastRecord.getLongitude(),
							     lat:lastRecord.getLatitude()});							  
			    let endPoint = this.map.createPoint("endpoint", {x:lastRecord.getLongitude(),y:lastRecord.getLatitude()}, {fillColor:color,strokeColor:"#000",pointRadius:6,graphicName:shape,rotation:angleDeg}, null);
			    featuresToAdd.push(endPoint);
			}
			if(this.getProperty("showPathStartPoint",false)) {
			    let endPoint = this.map.createPoint("startpoint", {x:firstRecord.getLongitude(),y:firstRecord.getLatitude()}, {fillColor:color,pointRadius:2}, null);
			    featuresToAdd.push(endPoint);
			}			
		    }
		});

	    }


	    let colorByEnabled = colorBy.isEnabled();
	    let graphicName = this.getPropertyShape();
	    let didMarker = false;
	    let times=[new Date()];
	    records.forEach((record,idx)=>{
		i++;
		let recordLayout = displayInfo[record.getId()];
		if(!recordLayout) return;
		let point  = recordLayout;
		if(!point) {
                    point = new OpenLayers.Geometry.Point(record.getLongitude(), record.getLatitude());
		} else {
		    if(!Utils.isDefined(point.x) || !Utils.isDefined(point.y)) return;
		}

		if(justOneMarker) {
		    debug = false;
		    if(didMarker) {
			if(debug)
			    console.log("didMarker");
			return;
		    }
                    this.map.removeMarker(this.justOneMarker);
                    if(!isNaN(point.x) && !isNaN(point.y)) {
			didMarker = true;
                        this.justOneMarker= this.map.createMarker(id, [point.x,point.y], null, "", "");
			featuresToAdd.push(this.justOneMarker);
			if(debug) console.log("\tadding justOneMarker had initial position:" + this.hadInitialPosition);
			if(!this.hadInitialPosition) {
			    let loc = MapUtils.createLonLat(point.x,point.y);
			    if(debug) console.log("\tsetting center:" + loc);
			    this.map.setCenter(loc);
			}
                        return;
                    } else {
			return;
                    }
                }

                let values = record.getData();
                let props = {
                    pointRadius: radius,
                    strokeWidth: strokeWidth,
                    strokeColor: strokeColor,
		    fillColor: fillColor,
		    fillOpacity: fillOpacity
                };

		if(shapeBy.field) {
		    let gv = values[shapeBy.index];
		    if(gv)  {
			if(!Utils.isDefined(shapeBy.map[gv])) {
			    if(dfltShape) {
				shapeBy.map[gv] = dfltShape;
			    } else {
				if(dfltShapeIdx>=dfltShapes.length)
				    dfltShapeIdx = 0;
				shapeBy.map[gv] = dfltShapes[dfltShapeIdx++];
			    }
			}
			if(Utils.isDefined(shapeBy.map[gv])) {
			    props.graphicName = shapeBy.map[gv];
			}
			
		    }
		}


                segmentWidth = dfltSegmentWidth;
                props.pointRadius = sizeBy.getSize(values, props.pointRadius,sizeByFunc);
		if(props.pointRadius<0) return;
		if(isNaN(props.pointRadius) || props.pointRadius == 0) props.pointRadius= radius;
		let hasColorByValue = false;
		let colorByValue;
		let colorByColor;
		let theColor =  null;

		if(colorBy.compareFields.length>0) {
		    let maxColor = null;
		    let maxValue = 0;
		    colorBy.compareFields.forEach((f,idx)=>{
			let value = record.getData()[f.getIndex()];
			if(idx==0 || value>maxValue) {
			    maxColor = colorBy.colors[idx];
			    maxValue = value;
			}
		    });
		    colorByValue = maxValue;
		    theColor = maxColor;
		} else {
		    if(colorByEnabled) {
			let value = record.getData()[colorBy.index];
			colorByValue = value;
			theColor =  colorBy.getColorFromRecord(record, theColor);
//			if(idx<5) console.log("%cpt:" + value + " " + theColor,"background:" + theColor);
		    }
                }

		if(theColor) {
                    didColorBy = true;
		    hasColorByValue  = true;
		    colorByColor = props.fillColor = colorBy.convertColor(theColor, colorByValue);
		}


		
		if(highlightRecords && !record.isHighlight(this)) {
		    props.fillColor =  unhighlightFillColor;
		    props.strokeColor =  unhighlightStrokeColor;
		    props.strokeWidth=unhighlightStrokeWidth;
		    if(unhighlightRadius>0)
			props.pointRadius = unhighlightRadius;
		}

		if(polygonField) {
		    let s = values[polygonField.getIndex()];
		    let polygonProps ={};
		    $.extend(polygonProps,props);
		    polygonProps.fillColor = "transparent";
		    if(polygonProps.strokeWidth==0)
			polygonProps.strokeWidth=1;
		    if(polygonColorTable) {
			if(cidx>=polygonColorTable.length) cidx=0;
			polygonProps.strokeColor=polygonColorTable[cidx++];
		    }
		    let polys = this.map.createPolygonString(s, polygonProps,latlon);
		    polys.forEach(poly=>{
			poly.textGetter = textGetter;
			poly.record = record;
			let recordDate = record.getDate();
			if (recordDate) {
			    poly.date = recordDate.getTime();
			}
			featuresToAdd.push(poly);
		    });
		    polys.forEach(poly=>{
			featuresToAdd.push(poly);
		    });
		}


                if (showSegments && latField1 && latField2 && lonField1 && lonField2) {
                    let lat1 = values[latField1.getIndex()];
                    let lat2 = values[latField2.getIndex()];
                    let lon1 = values[lonField1.getIndex()];
                    let lon2 = values[lonField2.getIndex()];
                    let attrs = {};
                    if (props.fillColor)
                        attrs.strokeColor = props.fillColor;
                    else
                        attrs.strokeColor = lineColor;
		    attrs.strokeLinecap = lineCap;
		    attrs.strokeColor =   colorBy.getColorFromRecord(record, attrs.strokeColor);
                    attrs.strokeWidth = segmentWidth;
		    let line = this.map.createLine("line-" + i, "", lat1, lon1, lat2, lon2, attrs);
		    featuresToAdd.push(line);
		    line.record = record;
		    line.textGetter = textGetter;
		    if(highlight) {
			line.highlightTextGetter = highlightGetter;
			line.highlightSize = highlightSize;
		    }	
		    line.record = record;
                    featuresToAdd.push(line);
                    if (showEndPoints) {
                        let pointProps = {};
                        $.extend(pointProps, props);
                        pointProps.fillColor = attrs.strokeColor;
                        pointProps.strokeColor = attrs.strokeColor;
                        pointProps.pointRadius = dfltEndPointSize;
                        pointProps.pointRadius = endPointSize;
                        let p1 = new OpenLayers.LonLat(lon1, lat1);
                        let p2 = new OpenLayers.LonLat(lon2, lat2);
                        if (!Utils.isDefined(seen[p1])) {
                            seen[p1] = true;
			    let pt1 =this.map.createPoint("endpt-" + i, p1, pointProps);
			    featuresToAdd.push(pt1);
			    pt1.record = record;
			    pt1.textGetter = textGetter;
                            featuresToAdd.push(pt1);
                        }
                        if (!Utils.isDefined(seen[p2])) {
                            seen[p2] = true;
                            let pt2 = this.map.createPoint("endpt2-" + i, p2, pointProps);
			    featuresToAdd.push(pt2);
			    pt2.record = record;
			    pt2.textGetter = textGetter;
                            featuresToAdd.push(pt2);
                        }

                    }
		}



                //We do this because openlayers gets really slow when there are lots of features at one point
		let key = point.x*10000 + point.y;
		if (!seen[key]) {
		    seen[key] = 1;
		}  else {
		    //			console.log(this.formatDate(record.getDate()) +" " + record.getLatitude() + " " + seen[key]);
		    if (seen[key] > 500) {
			return;
		    }
		    seen[key]++;
		}


		let mapPoint=null;
		let mapPoints =recordLayout.features;

		//marker
		if(usingIcon) {
		    if(iconField) {
			let tuple = record.getData();
			let icon = tuple[iconField.getIndex()];
			if(iconMap) {
			    icon = iconMap[icon];
			    if(!icon) icon = this.getMarkerIcon();
			}
			let size = iconSize;
			if(sizeBy.index>=0) {
			    size = props.pointRadius;
			}
			if(!recordLayout.collisionInfo)  {
			    mapPoint = this.map.createMarker("pt-" + i, point, icon, "pt-" + i,null,null,size);
			    mapPoint.isMarker = true;
			    mapPoints.push(mapPoint);
			    this.markers[record.getId()] = mapPoint;
			    pointsToAdd.push(mapPoint);
			}
		    } else  {
			let attrs = {
			}
			if(rotateField) attrs.rotation = record.getValue(rotateField.getIndex());
			mapPoint = this.map.createMarker("pt-" + i, point, markerIcon, "pt-" + i,null,null,iconSize,null,null,attrs);
			pointsToAdd.push(mapPoint);
			mapPoint.isMarker = true;
			mapPoints.push(mapPoint);
			this.markers[record.getId()] = mapPoint;
		    }
		}



		if(!usingIcon || colorByEnabled)  {
		    if(!props.graphicName)
			props.graphicName = graphicName;
		    if(rotateField) props.rotation = record.getValue(rotateField.getIndex());
		    props.fillColor =   colorBy.getColorFromRecord(record, props.fillColor);

		    if(radius>0) {
			mapPoint = this.map.createPoint("pt-" + i, point, props, null);
			pointsToAdd.push(mapPoint);
			this.markers[record.getId()] = mapPoint;
			mapPoints.push(mapPoint);
		    }
		}


		if(isPath && !groups && lastPoint) {
		    pathAttrs.strokeColor = colorBy.getColorFromRecord(record, pathAttrs.strokeColor);
		    let line = this.map.createLine("line-" + i, "", lastPoint.y, lastPoint.x, point.y,point.x,pathAttrs);
		    pointsToAdd.push(line);
		}
		lastPoint = point;
		if(features) {
		    mapPoints.forEach(f=>{features.push(f);});
		}
                let date = record.getDate();

		mapPoints.forEach(mapPoint=>{
		    if(highlight) {
			mapPoint.highlightTextGetter = highlightGetter;
			mapPoint.highlightSize = highlightSize;
		    }
		    mapPoint.record = record;
		    mapPoint.textGetter = textGetter;
		    mapPoint.hasColorByValue = hasColorByValue;
		    mapPoint.colorByValue= colorByValue;
		    mapPoint.colorByColor = colorByColor;
		    if (date) {
			mapPoint.date = date.getTime();
		    }
		    if(!recordLayout.visible) {
			mapPoint.featureVisible = false;
			this.map.checkFeatureVisible(mapPoint,true,records.length<20);
		    }
		});

		if(recordLayout.collisionInfo) {
		    recordLayout.collisionInfo.addPoints(mapPoints);
		}
	    });
	    
	    times.push(new Date());
	    if(showPoints) {
		this.addFeatures(pointsToAdd);
	    }
	    this.myPoints = pointsToAdd;
	    this.addFeatures(featuresToAdd);
	    times.push(new Date());
	    if(debugTimes)
		Utils.displayTimes("map: #records:" + records.length+" times:",times, true,["create markers","add features"]);


	    if(records.length>0 && this.getProperty("selectFirstRecord")&& !this.haveSelectedFirstRecord) {
		this.haveSelectedFirstRecord = true;
		let record = records[0];
		this.propagateEventRecordSelection({record:record});
		let displayDiv = this.getProperty("displayDiv", null);
		if(displayDiv && this.textGetter) {
		    $("#" + displayDiv).html(this.textGetter({record:record}));
		}
		let marker =  this.markers[record.getId()];
		if(marker) {
		    this.map.handleFeatureclick(null,marker);
		}
	    }



	    if (showSegments) {
		this.map.centerOnMarkers();
	    }


//Don't think we have to do this here. Saves lots of draw time
//	    if(this.map.circles)
//		this.map.circles.redraw();


	    let legendSide = this.getProperty("sizeByLegendSide");
	    if(legendSide) {
		let legend = sizeBy.getLegend(5,fillColor,legendSide=="left" || legendSide=="right");
		if(legend !="") {
		    let style = this.getProperty("sizeByLegendStyle");
		    if(style) legend = HU.div([STYLE,style],legend);
		    this.jq(ID_SIZEBY_LEGEND).html(legend);
		    this.callingUpdateSize = true;
		    this.map.getMap().updateSize();
		    this.callingUpdateSize = false;
		}
	    }
	    times = [new Date()];
	    this.jq(ID_BOTTOM).append(HU.div([ID,this.domId(ID_SHAPES)]));
	    if (didColorBy) {
		this.showColorTable(colorBy);
	    }
	    times.push(new Date());
//	    Utils.displayTimes("final map points:",times, true);

	    if(iconField&& iconMap) {
		let html = "";
		for(a in iconMap) {
		    html+=HU.image(iconMap[a],["width","32"]) +" " + a+" ";
		}
		this.jq(ID_SHAPES).html(HU.center(html));
	    }

	    if(shapeBy.field) {
		let shapes = shapeBy.field.getLabel()+": ";
		for(v in shapeBy.map) {
		    let shape = shapeBy.map[v];
		    if(shape=="circle") shape=HU.getIconImage("fa-circle");
		    else if(shape=="square") shape=HU.getIconImage("fa-square");		    
		    else if(shape=="rectangle") shape=HU.getIconImage("fa-square");		    
		    else if(shape=="star") shape=HU.getIconImage("fa-star");		    
		    else if(shape=="triangle") shape=HU.getIconImage("/icons/triangle.png",["width","16px"]);		    
		    else if(shape=="lightning") shape=HU.getIconImage("/icons/lightning.png",["width","16px"]);		    
		    else if(shape=="cross") shape=HU.getIconImage("/icons/cross.png",["width","16px"]);		    
		    else if(shape=="church") shape=HU.getIconImage("fa-cross");
		    shapes+=shape+" " + v +SPACE2;
		}
		this.jq(ID_SHAPES).html(HU.center(shapes));
	    }

	    if (this.getProperty("animationTakeStep", false)) {
		this.getAnimation().doNext();
	    }


        },

        addLabels:function(records, fields) {
	    let limit = this.getLabelLimit(1000);
	    if(records.length>limit) return;
	    

	    let pixelsPerCell = 10;
            let width = this.map.getMap().viewPortDiv.offsetWidth;
            let height = this.map.getMap().viewPortDiv.offsetHeight;
	    let bounds = this.map.getBounds();
	    let numCellsX = Math.round(width/pixelsPerCell);
	    let numCellsY = Math.round(height/pixelsPerCell);	    
	    let cellWidth = (bounds.right-bounds.left)/numCellsX;
	    let cellHeight = (bounds.top-bounds.bottom)/numCellsY;	    
	    let grid = {};
	    let doLabelGrid = this.getDoLabelGrid();
	    //
            let labelTemplate = this.getLabelTemplate();
	    let labelKeyField;
	    if(this.getLabelKeyField()) {
		labelKeyField = this.getFieldById(fields,this.getLabelKeyField());
	    }
            if(!labelTemplate && !labelKeyField) return;
	    if(labelKeyField) labelTemplate= "${_key}";
	    labelTemplate = labelTemplate.replace(/_nl_/g,"\n");
	    if(!this.map.labelLayer) {
		this.map.labelLayer = new OpenLayers.Layer.Vector("Labels", {
		    styleMap: new OpenLayers.StyleMap({'default':{
                        label : labelTemplate,
                        fontColor: this.getProperty("labelFontColor","#000"),
                        fontSize: this.getProperty("labelFontSize","10pt"),
                        fontFamily: this.getProperty("labelFontFamily","'Open Sans', Helvetica Neue, Arial, Helvetica, sans-serif"),
                        fontWeight: this.getProperty("labelFontWeight","plain"),
                        labelAlign: this.getProperty("labelAlign","lb"),
                        labelXOffset: this.getProperty("labelXOffset","0"),
                        labelYOffset: this.getProperty("labelYOffset","0"),
                        labelOutlineColor:this.getProperty("labelOutlineColor","#fff"),
                        labelOutlineWidth: this.getProperty("labelOutlineWidth","0"),
			labelSelect:true,
		    }}),
                });
		this.map.addVectorLayer(this.map.labelLayer, true);
                this.map.labelLayer.setZIndex(100);
	    }


	    let keyMap={};
	    let keyLegend="";
	    var features =  [];
            var seen = {};
	    var colorBy = this.getProperty("colorBy");
	    var sizeBy = this.getProperty("sizeBy");
	    let keyIndex = 0;
	    let alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
	    let  keys = [];
	    for(let j=0;j<3;j++) {
		alpha.forEach(c=>{
		    let cc = "";
		    for(let i=0;i<=j;i++) {
			cc+=c;
		    }
		    keys.push(cc);
		});
	    }
            for (var i = 0; i < records.length; i++) {
		var record = records[i];
                var point = record.point;
		//For now just set the lat/lon
		let indexX = Math.floor((record.getLongitude()-bounds.left)/cellWidth);
		let indexY = Math.floor((record.getLatitude()-bounds.bottom)/cellHeight);		
//		if(i<10)   console.log(record.getLongitude() +" " + record.getLatitude() +" " + indexX +" " + indexY);
		if(doLabelGrid) {
		    let key = indexX +"_"+ indexY;
		    if(grid[key]) continue;
		    grid[key] = true;
		}
		point = {x:record.getLongitude(),y:record.getLatitude()};
                var center = new OpenLayers.Geometry.Point(point.x, point.y);
                center.transform(this.map.displayProjection, this.map.sourceProjection);
                var pointFeature = new OpenLayers.Feature.Vector(center);
                pointFeature.noSelect = true;
                pointFeature.attributes = {
                };
                pointFeature.attributes[RECORD_INDEX] = (i+1);
                pointFeature.attributes["recordIndex"] = (i+1)+"";
		if(labelKeyField) {
		    let v = labelKeyField.getValue(record);
		    if(!keyMap[v]) {
			if(keyIndex>=keys.length) keyIndex=0;
			keyMap[v] = keys[keyIndex++];
			keyLegend+=keyMap[v]+": " + v+"<br>";
		    }
		    pointFeature.attributes["_key"] = keyMap[v];
                }
		for (var fieldIdx = 0;fieldIdx < fields.length; fieldIdx++) {
		    var field = fields[fieldIdx];
		    pointFeature.attributes[field.getId()] = field.getValue(record);
		    if(colorBy && field.getId() == colorBy) {
			pointFeature.attributes["colorBy"] = field.getValue(record);
		    }
		    if(sizeBy && field.getId() == sizeBy) {
			pointFeature.attributes["sizeBy"] = field.getValue(record);
                    }
		}
                features.push(pointFeature);
	    }
	    if(keyLegend.length>0) {
		if(!this.legendId) {
		    this.legendId = this.domId("legendid");
		    this.jq(ID_RIGHT).append(HU.div([ID,this.legendId, CLASS,"display-map-legend",STYLE, HU.css("max-height",this.getHeight("400px"))]));
		}
		this.jq("legendid").html(keyLegend);
	    }
	    if(this.labelFeatures)
		this.map.labelLayer.removeFeatures(this.labelFeatures);
            this.map.labelLayer.addFeatures(features);
	    this.labelFeatures = features;
	    $("#" + this.map.labelLayer.id).css("z-index",900);
        },


        handleEventRemoveDisplay: function(source, display) {
            if (!this.map) {
                return;
            }
            var mapEntryInfo = this.mapEntryInfos[display];
            if (mapEntryInfo != null) {
                mapEntryInfo.removeFromMap(this.map);
            }
            var feature = this.findFeature(display, true);
            if (feature != null) {
                if (feature.line != null) {
                    this.map.removePolygon(feature.line);
                }
            }
        },
        findFeature: function(source, andDelete) {
            for (var i in this.features) {
                var feature = this.features[i];
                if (feature.source == source) {
                    if (andDelete) {
                        this.features.splice(i, 1);
                    }
                    return feature;
                }
            }
            return null;
        },

        getMarkerIcon: function() {
            if (this.getProperty("markerIcon")) {
                var icon = this.getProperty("markerIcon");
                if (icon.startsWith("/"))
                    return ramaddaBaseUrl + icon;
                else
                    return icon;
            }
            displayMapCurrentMarker++;
            if (displayMapCurrentMarker >= displayMapMarkers.length) displayMapCurrentMarker = 0;
            return ramaddaCdn + "/lib/openlayers/v2/img/" + displayMapMarkers[displayMapCurrentMarker];
        },
	highlightMarker:null,
        handleEventRecordHighlight: function(source, args) {
	    SUPER.handleEventRecordHighlight.call(this,source,args);
	    this.highlightPoint(args.record.getLatitude(),args.record.getLongitude(),args.highlight,true);
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
            if (!this.map) {
                return;
            }
	    args.highlight = true;
            if (!this.getProperty("showRecordSelection", true)) {
		return;
	    }
	    this.handleEventRecordHighlight(source,args);
	    //For now return
	    if(true) return;

            var record = args.record;
            if (record.hasLocation()) {
                var latitude = record.getLatitude();
                var longitude = record.getLongitude();
                if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) return;
                var point = new OpenLayers.LonLat(longitude, latitude);
                var marker = this.myMarkers[source];
                if (marker != null) {
                    this.map.removeMarker(marker);
                }
                var icon = displayMapMarkerIcons[source];
                if (icon == null) {
                    icon = this.getMarkerIcon();
                    displayMapMarkerIcons[source] = icon;
                }
                this.myMarkers[source] = this.map.addMarker(source.getId(), point, icon, "", args.html, null, 24);
            }
        }
    });
}

function MapEntryInfo(entry) {
    RamaddaUtil.defineMembers(this, {
        entry: entry,
        marker: null,
        rectangle: null,
        removeFromMap: function(map) {
            if (this.marker != null) {
                map.removeMarker(this.marker);
            }
            if (this.rectangle != null) {
                map.removePolygon(this.rectangle);
            }
            if (this.polygon != null) {
                map.removePolygon(this.polygon);
            }
            if (this.circle != null) {
                map.removePoint(this.circle);
            }
        }

    });
}


function RamaddaMapgridDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MAPGRID, properties);
    let myProps = [
	{label:'Grid Map Attributes'},
	{p:'localeField',ex:''},
	{p:'grid',ex:'countries|us'},
	{p:'cellSize',ex:'30',tt:'use 0 for flexible width'},
	{p:'cellHeight',ex:'30'},
	{p:'showCellLabel',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        displayData: function(reload) {
	    this.updateUI();
	},
	handleEventFieldsSelected: function(source, fields) {
	    if(this.getProperty("selectedFieldIsColorBy") && fields.length>0) {
		this.colorByFieldChanged(fields[0]);
	    }
        },
	colorByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("colorBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({colorByFieldChanged:true});
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
            let fields = this.getData().getNonGeoFields();
	    let localeField = this.getFieldById(fields,this.getProperty("localeField","state"));
	    if(localeField==null) {
		localeField = this.getFieldById(fields,"state");
	    }
	    let minx = Number.MAX_VALUE;
	    let miny = Number.MAX_VALUE;
	    let maxx = Number.MIN_VALUE;
	    let maxy = Number.MIN_VALUE;
	    let map = {};
	    let grid = this.getProperty("grid","us")=="countries"?this.countries:this.states;

	    grid.forEach(o=>{
		minx = Math.min(minx,o.x);
		maxx = Math.max(maxx,o.x);
		miny = Math.min(miny,o.y);
		maxy = Math.max(maxy,o.y);
		map[this.domId("cell_" +o.x+ "_"+o.y)] = o;
	    });

            let colorBy = this.getColorByInfo(records);
	    let sparkLinesColorBy = this.getColorByInfo(records,"sparklineColorBy");
	    let strokeColorBy = this.getColorByInfo(records,"strokeColorBy","strokeColorByMap");
	    let sparkLineField = this.getFieldById(fields,this.getProperty("sparklineField"));
	    let table =HU.open(TABLE,[WIDTH,"100%"]);
	    let width = this.getProperty("cellWidth", this.getProperty("cellSize",0));
	    let height = this.getProperty("cellHeight",width);
	    if(height==0) height=30;
	    let showLabel  = this.getProperty("showCellLabel",true);
	    let cellStyle  = this.getProperty("cellStyle","");
	    let cellMap = {};
	    for(let y=1;y<=maxy;y++) {
		table+=HU.open(TR);
		for(let x=1;x<=maxx;x++) {
		    let id = this.domId("cell_" +x+ "_"+y);
		    let o = map[id];
		    let extra = " id='" + id +"' ";
		    let style = HU.css('position','relative','margin','1px','vertical-align','center','text-align','center',HEIGHT, height+"px");
		    if(width>0) style+=HU.css(WIDTH,width+'px');
		    let c = "";
		    if(o) {
			style+="background:#ccc;" + cellStyle;
			if(!sparkLineField) {
			    extra += " title='" + o.name +"' ";
			}
			extra += HU.attr(CLASS,'display-mapgrid-cell');
			c = HU.div([STYLE,HU.css('padding-left','3px')], (showLabel?o.codes[0]:""));
			o.codes.forEach(c=>cellMap[c] = id);
			cellMap[o.name] = id;
		    }
		    let td = HU.td([],"<div " + extra +" style='" + style +"'>" + c+"</div>");
		    table+=td;
		}
		table+=HU.close(TR);
	    }
	    table +=HU.tr([],HU.td(["colspan", maxx],"<br>" +   HU.div([ID,this.domId(ID_COLORTABLE)])));
	    table+=HU.close(TABLE);
	    this.setContents(HU.center(table));

	    let states = [];
	    let stateData = this.stateData = {
	    }
	    let minData = 0;
	    let maxData = 0;
	    let seen = {};
	    let contents = this.getContents();
	    for(let i=0;i<records.length;i++) {
		let record = records[i]; 
		let tuple = record.getData();
		let state = tuple[localeField.getIndex()];
		let cellId = cellMap[state];
		if(!cellId) {
		    cellId = cellMap[state.toUpperCase()];
		}
		if(!cellId) {
		    //		    console.log("Could not find cell:" + state);
		    continue;
		}
		$("#"+cellId).attr(RECORD_INDEX,i);

		if(!stateData[state]) {
		    states.push(state);
		    stateData[state] = {
			cellId: cellId,
			data:[],
			records:[]
		    }
		}
		if(sparkLineField) {
		    let value = record.getValue(sparkLineField.getIndex());
		    if(!isNaN(value)) {
			minData = i==0?value:Math.min(minData, value);
			maxData = i==0?value:Math.max(maxData, value);
			stateData[state].data.push(value);
			stateData[state].records.push(record);
		    }
		}

		let colorByEnabled = colorBy.isEnabled();

		//TODO: sort the state data on time
                if (colorByEnabled) {
                    let value = record.getData()[colorBy.index];
		    let color = colorBy.getColorFromRecord(record);
		    let cell = contents.find("#" + cellId);
		    cell.css("background",color);
		    let foreground = Utils.getForegroundColor(color);
		    if(foreground) {
			cell.css('color', foreground);
		    }
		    cell.attr(RECORD_INDEX,i);
                }
		if (strokeColorBy.isEnabled()) {
                    let value = record.getData()[strokeColorBy.index];
		    let color = strokeColorBy.getColor(value, record);
		    let cell = contents.find("#" + cellId);
		    cell.css("border-color",color);
		    cell.css("border-width","2px");
                }
	    }

	    if(sparkLineField) {
		let vOffset = 0;
		states.forEach((state,idx)=>{
		    let s = stateData[state];
		    let innerId = s.cellId+"_inner";
		    let cellWidth = width;
		    if(cellWidth==0) {
			cellWidth = $("#" + s.cellId).width();
		    }
		    let style = HU.css(WIDTH,cellWidth+'px',HEIGHT, (height-vOffset) +'px','position','absolute','left','0px','top', vOffset+'px');
		    let innerDiv = HU.div([ID, innerId, STYLE,style]);
		    $("#" + s.cellId).append(innerDiv);
		    drawSparkLine(this, "#"+innerId,cellWidth,height-vOffset,s.data,s.records,minData,maxData,sparkLinesColorBy);
		});
	    }

	    this.makePopups(contents.find(".display-mapgrid-cell"), records);
	    let _this = this;
	    contents.find(".display-mapgrid-cell").click(function() {
		let record = records[$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });	
	    if(!sparkLineField) {
		this.makeTooltips(contents.find(".display-mapgrid-cell"), records, null, "${default}");
	    }
            if (colorBy.index >= 0) {
		colorBy.displayColorTable();
	    }
	    if (sparkLinesColorBy.index >= 0) {
		sparkLinesColorBy.displayColorTable();
	    }
	},

        handleEventRecordSelection: function(source, args) {
	    let contents = this.getContents();
	    if(this.selectedCell) {
		this.selectedCell.css("border",this.selectedBorder);
	    }
	    let index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    this.selectedCell = contents.find(HU.attrSelect(RECORD_INDEX, index));
	    this.selectedBorder = this.selectedCell.css("border");
	    this.selectedCell.css("border","1px solid red");
	},

	states:  [
	    {name:"Alaska",codes:["AK"],x:2,y:1},
	    {name:"Hawaii",codes:["HI"],x:2,y:8},
	    {name:"Washington",codes:["WA"],x:3,y:3},
	    {name:"Oregon",codes:["OR"],x:3,y:4},
	    {name:"California",codes:["CA"],x:3,y:5},
	    {name:"Idaho",codes:["ID"],x:4,y:3},
	    {name:"Nevada",codes:["NV"],x:4,y:4},
	    {name:"Utah",codes:["UT"],x:4,y:5},
	    {name:"Arizona",codes:["AZ"],x:4,y:6},
	    {name:"Montana",codes:["MT"],x:5,y:3},
	    {name:"Wyoming",codes:["WY"],x:5,y:4},
	    {name:"Colorado",codes:["CO"],x:5,y:5},
	    {name:"New Mexico",codes:["NM"],x:5,y:6},
	    {name:"North Dakota",codes:["ND"],x:6,y:3},
	    {name:"South Dakota",codes:["SD"],x:6,y:4},
	    {name:"Nebraska",codes:["NE"],x:6,y:5},
	    {name:"Kansas",codes:["KS"],x:6,y:6},
	    {name:"Oklahoma",codes:["OK"],x:6,y:7},
	    {name:"Texas",codes:["TX"],x:6,y:8},
	    {name:"Minnesota",codes:["MN"],x:7,y:3},
	    {name:"Iowa",codes:["IA"],x:7,y:4},
	    {name:"Missouri",codes:["MO"],x:7,y:5},
	    {name:"Arkansas",codes:["AR"],x:7,y:6},
	    {name:"Louisiana",codes:["LA"],x:7,y:7},
	    {name:"Illinois",codes:["IL"],x:8,y:3},
	    {name:"Indiana",codes:["IN"],x:8,y:4},
	    {name:"Kentucky",codes:["KY"],x:8,y:5},
	    {name:"Tennessee",codes:["TN"],x:8,y:6},
	    {name:"Mississippi",codes:["MS"],x:8,y:7},
	    {name:"Wisconsin",codes:["WI"],x:9,y:2},
	    {name:"Ohio",codes:["OH"],x:9,y:4},
	    {name:"West Virginia",codes:["WV"],x:9,y:5},
	    {name:"North Carolina",codes:["NC"],x:9,y:6},
	    {name:"Alabama",codes:["AL"],x:9,y:7},
	    {name:"Michigan",codes:["MI"],x:9,y:3},
	    {name:"Pennsylvania",codes:["PA"],x:10,y:4},
	    {name:"Virginia",codes:["VA"],x:10,y:5},
	    {name:"South Carolina",codes:["SC"],x:10,y:6},
	    {name:"Georgia",codes:["GA"],x:10,y:7},
	    {name:"New York",codes:["NY"],x:11,y:3},
	    {name:"New Jersey",codes:["NJ"],x:11,y:4},
	    {name:"Maryland",codes:["MD"],x:11,y:5},
	    {name:"DC",codes:["DC"],x:11,y:6},
	    {name:"Florida",codes:["FL"],x:11,y:8},
	    {name:"Vermont",codes:["VT"],x:12,y:2},
	    {name:"Rhode Island",codes:["RI"],x:12,y:3},
	    {name:"Connecticut",codes:["CT"],x:12,y:4},
	    {name:"Delaware",codes:["DE"],x:12,y:5},
	    {name:"Maine",codes:["ME"],x:13,y:1},
	    {name:"New Hampshire",codes:["NH"],x:13,y:2},
	    {name:"Massachusetts",codes:["MA"],x:13,y:3},
	],
	countries:
	[
	    {
		"name": "Afghanistan",
		"codes": [
		    "AF",
		    "AFG",
		    "004",
		    "ISO 3166-2:AF"
		],
		"x": 22,
		"y": 8
	    },
	    {
		"name": "Albania",
		"codes": [
		    "AL",
		    "ALB",
		    "008",
		    "ISO 3166-2:AL"
		],
		"x": 15,
		"y": 9
	    },
	    {
		"name": "Algeria",
		"codes": [
		    "DZ",
		    "DZA",
		    "012",
		    "ISO 3166-2:DZ"
		],
		"x": 13,
		"y": 11
	    },
	    {
		"name": "Angola",
		"codes": [
		    "AO",
		    "AGO",
		    "024",
		    "ISO 3166-2:AO"
		],
		"x": 13,
		"y": 17
	    },
	    {
		"name": "Antarctica",
		"codes": [
		    "AQ",
		    "ATA",
		    "010",
		    "ISO 3166-2:AQ"
		],
		"x": 15,
		"y": 23
	    },
	    {
		"name": "Antigua & Barbuda",
		"codes": [
		    "AG",
		    "ATG",
		    "028",
		    "ISO 3166-2:AG"
		],
		"x": 7,
		"y": 4
	    },
	    {
		"name": "Argentina",
		"codes": [
		    "AR",
		    "ARG",
		    "032",
		    "ISO 3166-2:AR"
		],
		"x": 6,
		"y": 14
	    },
	    {
		"name": "Armenia",
		"codes": [
		    "AM",
		    "ARM",
		    "051",
		    "ISO 3166-2:AM"
		],
		"x": 20,
		"y": 6
	    },
	    {
		"name": "Australia",
		"codes": [
		    "AU",
		    "AUS",
		    "036",
		    "ISO 3166-2:AU"
		],
		"x": 24,
		"y": 19
	    },
	    {
		"name": "Austria",
		"codes": [
		    "AT",
		    "AUT",
		    "040",
		    "ISO 3166-2:AT"
		],
		"x": 15,
		"y": 6
	    },
	    {
		"name": "Azerbaijan",
		"codes": [
		    "AZ",
		    "AZE",
		    "031",
		    "ISO 3166-2:AZ"
		],
		"x": 21,
		"y": 7
	    },
	    {
		"name": "Bahamas",
		"codes": [
		    "BS",
		    "BHS",
		    "044",
		    "ISO 3166-2:BS"
		],
		"x": 4,
		"y": 2
	    },
	    {
		"name": "Bahrain",
		"codes": [
		    "BH",
		    "BHR",
		    "048",
		    "ISO 3166-2:BH"
		],
		"x": 20,
		"y": 9
	    },
	    {
		"name": "Bangladesh",
		"codes": [
		    "BD",
		    "BGD",
		    "050",
		    "ISO 3166-2:BD"
		],
		"x": 23,
		"y": 8
	    },
	    {
		"name": "Barbados",
		"codes": [
		    "BB",
		    "BRB",
		    "052",
		    "ISO 3166-2:BB"
		],
		"x": 8,
		"y": 6
	    },
	    {
		"name": "Belarus",
		"codes": [
		    "BY",
		    "BLR",
		    "112",
		    "ISO 3166-2:BY"
		],
		"x": 17,
		"y": 4
	    },
	    {
		"name": "Belgium",
		"codes": [
		    "BE",
		    "BEL",
		    "056",
		    "ISO 3166-2:BE"
		],
		"x": 13,
		"y": 5
	    },
	    {
		"name": "Belize",
		"codes": [
		    "BZ",
		    "BLZ",
		    "084",
		    "ISO 3166-2:BZ"
		],
		"x": 2,
		"y": 3
	    },
	    {
		"name": "Benin",
		"codes": [
		    "BJ",
		    "BEN",
		    "204",
		    "ISO 3166-2:BJ"
		],
		"x": 15,
		"y": 14
	    },
	    {
		"name": "Bhutan",
		"codes": [
		    "BT",
		    "BTN",
		    "064",
		    "ISO 3166-2:BT"
		],
		"x": 24,
		"y": 7
	    },
	    {
		"name": "Bolivia",
		"codes": [
		    "BO",
		    "BOL",
		    "068",
		    "ISO 3166-2:BO"
		],
		"x": 6,
		"y": 11
	    },
	    {
		"name": "Bosnia & Herzegovina",
		"codes": [
		    "BA",
		    "BIH",
		    "070",
		    "ISO 3166-2:BA"
		],
		"x": 15,
		"y": 7
	    },
	    {
		"name": "Botswana",
		"codes": [
		    "BW",
		    "BWA",
		    "072",
		    "ISO 3166-2:BW"
		],
		"x": 15,
		"y": 18
	    },
	    {
		"name": "Brazil",
		"codes": [
		    "BR",
		    "BRA",
		    "076",
		    "ISO 3166-2:BR"
		],
		"x": 8,
		"y": 11
	    },
	    {
		"name": "Brunei Darussalam",
		"codes": [
		    "BN",
		    "BRN",
		    "096",
		    "ISO 3166-2:BN"
		],
		"x": 25,
		"y": 12
	    },
	    {
		"name": "Bulgaria",
		"codes": [
		    "BG",
		    "BGR",
		    "100",
		    "ISO 3166-2:BG"
		],
		"x": 17,
		"y": 7
	    },
	    {
		"name": "Burkina Faso",
		"codes": [
		    "BF",
		    "BFA",
		    "854",
		    "ISO 3166-2:BF"
		],
		"x": 13,
		"y": 13
	    },
	    {
		"name": "Burundi",
		"codes": [
		    "BI",
		    "BDI",
		    "108",
		    "ISO 3166-2:BI"
		],
		"x": 15,
		"y": 16
	    },
	    {
		"name": "Cambodia",
		"codes": [
		    "KH",
		    "KHM",
		    "116",
		    "ISO 3166-2:KH"
		],
		"x": 25,
		"y": 10
	    },
	    {
		"name": "Cameroon",
		"codes": [
		    "CM",
		    "CMR",
		    "120",
		    "ISO 3166-2:CM"
		],
		"x": 14,
		"y": 15
	    },
	    {
		"name": "Canada",
		"codes": [
		    "CA",
		    "CAN",
		    "124",
		    "ISO 3166-2:CA"
		],
		"x": 1,
		"y": 1
	    },
	    {
		"name": "Cabo Verde",
		"codes": [
		    "CV",
		    "CPV",
		    "132",
		    "ISO 3166-2:CV"
		],
		"x": 10,
		"y": 15
	    },
	    {
		"name": "Central African Republic",
		"codes": [
		    "CF",
		    "CAF",
		    "140",
		    "ISO 3166-2:CF"
		],
		"x": 16,
		"y": 14
	    },
	    {
		"name": "Chad",
		"codes": [
		    "TD",
		    "TCD",
		    "148",
		    "ISO 3166-2:TD"
		],
		"x": 14,
		"y": 13
	    },
	    {
		"name": "Chile",
		"codes": [
		    "CL",
		    "CHL",
		    "152",
		    "ISO 3166-2:CL"
		],
		"x": 6,
		"y": 13
	    },
	    {
		"name": "China",
		"codes": [
		    "CN",
		    "CHN",
		    "156",
		    "ISO 3166-2:CN"
		],
		"x": 24,
		"y": 6
	    },
	    {
		"name": "Colombia",
		"codes": [
		    "CO",
		    "COL",
		    "170",
		    "ISO 3166-2:CO"
		],
		"x": 5,
		"y": 9
	    },
	    {
		"name": "Comoros",
		"codes": [
		    "KM",
		    "COM",
		    "174",
		    "ISO 3166-2:KM"
		],
		"x": 18,
		"y": 18
	    },
	    {
		"name": "Congo",
		"codes": [
		    "CG",
		    "COG",
		    "178",
		    "ISO 3166-2:CG"
		],
		"x": 14,
		"y": 16
	    },
	    {
		"name": "Congo (Democratic Republic of the)",
		"codes": [
		    "CD",
		    "COD",
		    "180",
		    "ISO 3166-2:CD"
		],
		"x": 15,
		"y": 15
	    },
	    {
		"name": "Costa Rica",
		"codes": [
		    "CR",
		    "CRI",
		    "188",
		    "ISO 3166-2:CR"
		],
		"x": 3,
		"y": 7
	    },
	    {
		"name": "Côte d'Ivoire",
		"codes": [
		    "CI",
		    "CIV",
		    "384",
		    "ISO 3166-2:CI"
		],
		"x": 12,
		"y": 15
	    },
	    {
		"name": "Croatia",
		"codes": [
		    "HR",
		    "HRV",
		    "191",
		    "ISO 3166-2:HR"
		],
		"x": 14,
		"y": 7
	    },
	    {
		"name": "Cuba",
		"codes": [
		    "CU",
		    "CUB",
		    "192",
		    "ISO 3166-2:CU"
		],
		"x": 4,
		"y": 3
	    },
	    {
		"name": "Cyprus",
		"codes": [
		    "CY",
		    "CYP",
		    "196",
		    "ISO 3166-2:CY"
		],
		"x": 17,
		"y": 10
	    },
	    {
		"name": "Czech Republic",
		"codes": [
		    "CZ",
		    "CZE",
		    "203",
		    "ISO 3166-2:CZ"
		],
		"x": 15,
		"y": 5
	    },
	    {
		"name": "Denmark",
		"codes": [
		    "DK",
		    "DNK",
		    "208",
		    "ISO 3166-2:DK"
		],
		"x": 14,
		"y": 3
	    },
	    {
		"name": "Djibouti",
		"codes": [
		    "DJ",
		    "DJI",
		    "262",
		    "ISO 3166-2:DJ"
		],
		"x": 17,
		"y": 13
	    },
	    {
		"name": "Dominica",
		"codes": [
		    "DM",
		    "DMA",
		    "212",
		    "ISO 3166-2:DM"
		],
		"x": 7,
		"y": 7
	    },
	    {
		"name": "Dominican Republic",
		"codes": [
		    "DO",
		    "DOM",
		    "214",
		    "ISO 3166-2:DO"
		],
		"x": 6,
		"y": 4
	    },
	    {
		"name": "Ecuador",
		"codes": [
		    "EC",
		    "ECU",
		    "218",
		    "ISO 3166-2:EC"
		],
		"x": 5,
		"y": 10
	    },
	    {
		"name": "Egypt",
		"codes": [
		    "EG",
		    "EGY",
		    "818",
		    "ISO 3166-2:EG"
		],
		"x": 16,
		"y": 11
	    },
	    {
		"name": "El Salvador",
		"codes": [
		    "SV",
		    "SLV",
		    "222",
		    "ISO 3166-2:SV"
		],
		"x": 1,
		"y": 5
	    },
	    {
		"name": "Equatorial Guinea",
		"codes": [
		    "GQ",
		    "GNQ",
		    "226",
		    "ISO 3166-2:GQ"
		],
		"x": 13,
		"y": 16
	    },
	    {
		"name": "Eritrea",
		"codes": [
		    "ER",
		    "ERI",
		    "232",
		    "ISO 3166-2:ER"
		],
		"x": 16,
		"y": 13
	    },
	    {
		"name": "Estonia",
		"codes": [
		    "EE",
		    "EST",
		    "233",
		    "ISO 3166-2:EE"
		],
		"x": 17,
		"y": 2
	    },
	    {
		"name": "Ethiopia",
		"codes": [
		    "ET",
		    "ETH",
		    "231",
		    "ISO 3166-2:ET"
		],
		"x": 17,
		"y": 14
	    },
	    {
		"name": "Fiji",
		"codes": [
		    "FJ",
		    "FJI",
		    "242",
		    "ISO 3166-2:FJ"
		],
		"x": 27,
		"y": 19
	    },
	    {
		"name": "Finland",
		"codes": [
		    "FI",
		    "FIN",
		    "246",
		    "ISO 3166-2:FI"
		],
		"x": 17,
		"y": 1
	    },
	    {
		"name": "France",
		"codes": [
		    "FR",
		    "FRA",
		    "250",
		    "ISO 3166-2:FR"
		],
		"x": 12,
		"y": 5
	    },
	    {
		"name": "Gabon",
		"codes": [
		    "GA",
		    "GAB",
		    "266",
		    "ISO 3166-2:GA"
		],
		"x": 14,
		"y": 17
	    },
	    {
		"name": "Gambia",
		"codes": [
		    "GM",
		    "GMB",
		    "270",
		    "ISO 3166-2:GM"
		],
		"x": 12,
		"y": 12
	    },
	    {
		"name": "Georgia",
		"codes": [
		    "GE",
		    "GEO",
		    "268",
		    "ISO 3166-2:GE"
		],
		"x": 21,
		"y": 6
	    },
	    {
		"name": "Germany",
		"codes": [
		    "DE",
		    "DEU",
		    "276",
		    "ISO 3166-2:DE"
		],
		"x": 14,
		"y": 4
	    },
	    {
		"name": "Ghana",
		"codes": [
		    "GH",
		    "GHA",
		    "288",
		    "ISO 3166-2:GH"
		],
		"x": 13,
		"y": 14
	    },
	    {
		"name": "Greece",
		"codes": [
		    "GR",
		    "GRC",
		    "300",
		    "ISO 3166-2:GR"
		],
		"x": 16,
		"y": 9
	    },
	    {
		"name": "Greenland",
		"codes": [
		    "GL",
		    "GRL",
		    "304",
		    "ISO 3166-2:GL"
		],
		"x": 8,
		"y": 1
	    },
	    {
		"name": "Grenada",
		"codes": [
		    "GD",
		    "GRD",
		    "308",
		    "ISO 3166-2:GD"
		],
		"x": 7,
		"y": 8
	    },
	    {
		"name": "Guatemala",
		"codes": [
		    "GT",
		    "GTM",
		    "320",
		    "ISO 3166-2:GT"
		],
		"x": 1,
		"y": 4
	    },
	    {
		"name": "Guinea",
		"codes": [
		    "GN",
		    "GIN",
		    "324",
		    "ISO 3166-2:GN"
		],
		"x": 11,
		"y": 14
	    },
	    {
		"name": "Guinea-Bissau",
		"codes": [
		    "GW",
		    "GNB",
		    "624",
		    "ISO 3166-2:GW"
		],
		"x": 11,
		"y": 13
	    },
	    {
		"name": "Guyana",
		"codes": [
		    "GY",
		    "GUY",
		    "328",
		    "ISO 3166-2:GY"
		],
		"x": 6,
		"y": 10
	    },
	    {
		"name": "Haiti",
		"codes": [
		    "HT",
		    "HTI",
		    "332",
		    "ISO 3166-2:HT"
		],
		"x": 5,
		"y": 4
	    },
	    {
		"name": "Honduras",
		"codes": [
		    "HN",
		    "HND",
		    "340",
		    "ISO 3166-2:HN"
		],
		"x": 2,
		"y": 5
	    },
	    {
		"name": "Hungary",
		"codes": [
		    "HU",
		    "HUN",
		    "348",
		    "ISO 3166-2:HU"
		],
		"x": 16,
		"y": 6
	    },
	    {
		"name": "Iceland",
		"codes": [
		    "IS",
		    "ISL",
		    "352",
		    "ISO 3166-2:IS"
		],
		"x": 10,
		"y": 1
	    },
	    {
		"name": "India",
		"codes": [
		    "IN",
		    "IND",
		    "356",
		    "ISO 3166-2:IN"
		],
		"x": 22,
		"y": 9
	    },
	    {
		"name": "Indonesia",
		"codes": [
		    "ID",
		    "IDN",
		    "360",
		    "ISO 3166-2:ID"
		],
		"x": 25,
		"y": 13
	    },
	    {
		"name": "Iran (Islamic Republic of)",
		"codes": [
		    "IR",
		    "IRN",
		    "364",
		    "ISO 3166-2:IR"
		],
		"x": 20,
		"y": 8
	    },
	    {
		"name": "Iraq",
		"codes": [
		    "IQ",
		    "IRQ",
		    "368",
		    "ISO 3166-2:IQ"
		],
		"x": 20,
		"y": 7
	    },
	    {
		"name": "Ireland",
		"codes": [
		    "IE",
		    "IRL",
		    "372",
		    "ISO 3166-2:IE"
		],
		"x": 10,
		"y": 4
	    },
	    {
		"name": "Israel",
		"codes": [
		    "IL",
		    "ISR",
		    "376",
		    "ISO 3166-2:IL"
		],
		"x": 18,
		"y": 10
	    },
	    {
		"name": "Italy",
		"codes": [
		    "IT",
		    "ITA",
		    "380",
		    "ISO 3166-2:IT"
		],
		"x": 13,
		"y": 7
	    },
	    {
		"name": "Jamaica",
		"codes": [
		    "JM",
		    "JAM",
		    "388",
		    "ISO 3166-2:JM"
		],
		"x": 4,
		"y": 4
	    },
	    {
		"name": "Japan",
		"codes": [
		    "JP",
		    "JPN",
		    "392",
		    "ISO 3166-2:JP"
		],
		"x": 27,
		"y": 6
	    },
	    {
		"name": "Jordan",
		"codes": [
		    "JO",
		    "JOR",
		    "400",
		    "ISO 3166-2:JO"
		],
		"x": 18,
		"y": 8
	    },
	    {
		"name": "Kazakhstan",
		"codes": [
		    "KZ",
		    "KAZ",
		    "398",
		    "ISO 3166-2:KZ"
		],
		"x": 24,
		"y": 5
	    },
	    {
		"name": "Kenya",
		"codes": [
		    "KE",
		    "KEN",
		    "404",
		    "ISO 3166-2:KE"
		],
		"x": 17,
		"y": 15
	    },
	    {
		"name": "Kiribati",
		"codes": [
		    "KI",
		    "KIR",
		    "296",
		    "ISO 3166-2:KI"
		],
		"x": 27,
		"y": 17
	    },
	    {
		"name": "North Korea",
		"codes": [
		    "KP",
		    "PRK",
		    "408",
		    "ISO 3166-2:KP"
		],
		"x": 25,
		"y": 6
	    },
	    {
		"name": "South Korea",
		"codes": [
		    "KR",
		    "KOR",
		    "410",
		    "ISO 3166-2:KR"
		],
		"x": 25,
		"y": 7
	    },
	    {
		"name": "Kosovo",
		"codes": [
		    "XK",
		    "XKX",
		    "383",
		    "ISO 3166-2:XK"
		],
		"x": 16,
		"y": 8
	    },
	    {
		"name": "Kuwait",
		"codes": [
		    "KW",
		    "KWT",
		    "414",
		    "ISO 3166-2:KW"
		],
		"x": 19,
		"y": 8
	    },
	    {
		"name": "Kyrgyzstan",
		"codes": [
		    "KG",
		    "KGZ",
		    "417",
		    "ISO 3166-2:KG"
		],
		"x": 23,
		"y": 6
	    },
	    {
		"name": "Lao People's Democratic Republic",
		"codes": [
		    "LA",
		    "LAO",
		    "418",
		    "ISO 3166-2:LA"
		],
		"x": 25,
		"y": 9
	    },
	    {
		"name": "Latvia",
		"codes": [
		    "LV",
		    "LVA",
		    "428",
		    "ISO 3166-2:LV"
		],
		"x": 17,
		"y": 3
	    },
	    {
		"name": "Lebanon",
		"codes": [
		    "LB",
		    "LBN",
		    "422",
		    "ISO 3166-2:LB"
		],
		"x": 18,
		"y": 9
	    },
	    {
		"name": "Lesotho",
		"codes": [
		    "LS",
		    "LSO",
		    "426",
		    "ISO 3166-2:LS"
		],
		"x": 17,
		"y": 19
	    },
	    {
		"name": "Liberia",
		"codes": [
		    "LR",
		    "LBR",
		    "430",
		    "ISO 3166-2:LR"
		],
		"x": 12,
		"y": 14
	    },
	    {
		"name": "Libya",
		"codes": [
		    "LY",
		    "LBY",
		    "434",
		    "ISO 3166-2:LY"
		],
		"x": 15,
		"y": 11
	    },
	    {
		"name": "Lithuania",
		"codes": [
		    "LT",
		    "LTU",
		    "440",
		    "ISO 3166-2:LT"
		],
		"x": 16,
		"y": 4
	    },
	    {
		"name": "Luxembourg",
		"codes": [
		    "LU",
		    "LUX",
		    "442",
		    "ISO 3166-2:LU"
		],
		"x": 13,
		"y": 6
	    },
	    {
		"name": "Macedonia",
		"codes": [
		    "MK",
		    "MKD",
		    "807",
		    "ISO 3166-2:MK"
		],
		"x": 17,
		"y": 8
	    },
	    {
		"name": "Madagascar",
		"codes": [
		    "MG",
		    "MDG",
		    "450",
		    "ISO 3166-2:MG"
		],
		"x": 19,
		"y": 19
	    },
	    {
		"name": "Malawi",
		"codes": [
		    "MW",
		    "MWI",
		    "454",
		    "ISO 3166-2:MW"
		],
		"x": 15,
		"y": 17
	    },
	    {
		"name": "Malaysia",
		"codes": [
		    "MY",
		    "MYS",
		    "458",
		    "ISO 3166-2:MY"
		],
		"x": 24,
		"y": 11
	    },
	    {
		"name": "Maldives",
		"codes": [
		    "MV",
		    "MDV",
		    "462",
		    "ISO 3166-2:MV"
		],
		"x": 21,
		"y": 12
	    },
	    {
		"name": "Mali",
		"codes": [
		    "ML",
		    "MLI",
		    "466",
		    "ISO 3166-2:ML"
		],
		"x": 14,
		"y": 12
	    },
	    {
		"name": "Malta",
		"codes": [
		    "MT",
		    "MLT",
		    "470",
		    "ISO 3166-2:MT"
		],
		"x": 11,
		"y": 8
	    },
	    {
		"name": "Marshall Islands",
		"codes": [
		    "MH",
		    "MHL",
		    "584",
		    "ISO 3166-2:MH"
		],
		"x": 26,
		"y": 15
	    },
	    {
		"name": "Mauritania",
		"codes": [
		    "MR",
		    "MRT",
		    "478",
		    "ISO 3166-2:MR"
		],
		"x": 11,
		"y": 12
	    },
	    {
		"name": "Mauritius",
		"codes": [
		    "MU",
		    "MUS",
		    "480",
		    "ISO 3166-2:MU"
		],
		"x": 19,
		"y": 20
	    },
	    {
		"name": "Mexico",
		"codes": [
		    "MX",
		    "MEX",
		    "484",
		    "ISO 3166-2:MX"
		],
		"x": 1,
		"y": 3
	    },
	    {
		"name": "Micronesia (Federated States of)",
		"codes": [
		    "FM",
		    "FSM",
		    "583",
		    "ISO 3166-2:FM"
		],
		"x": 26,
		"y": 16
	    },
	    {
		"name": "Moldova (Republic of)",
		"codes": [
		    "MD",
		    "MDA",
		    "498",
		    "ISO 3166-2:MD"
		],
		"x": 18,
		"y": 5
	    },
	    {
		"name": "Mongolia",
		"codes": [
		    "MN",
		    "MNG",
		    "496",
		    "ISO 3166-2:MN"
		],
		"x": 25,
		"y": 5
	    },
	    {
		"name": "Montenegro",
		"codes": [
		    "ME",
		    "MNE",
		    "499",
		    "ISO 3166-2:ME"
		],
		"x": 15,
		"y": 8
	    },
	    {
		"name": "Morocco",
		"codes": [
		    "MA",
		    "MAR",
		    "504",
		    "ISO 3166-2:MA"
		],
		"x": 12,
		"y": 11
	    },
	    {
		"name": "Mozambique",
		"codes": [
		    "MZ",
		    "MOZ",
		    "508",
		    "ISO 3166-2:MZ"
		],
		"x": 16,
		"y": 17
	    },
	    {
		"name": "Myanmar",
		"codes": [
		    "MM",
		    "MMR",
		    "104",
		    "ISO 3166-2:MM"
		],
		"x": 24,
		"y": 8
	    },
	    {
		"name": "Namibia",
		"codes": [
		    "NA",
		    "NAM",
		    "516",
		    "ISO 3166-2:NA"
		],
		"x": 15,
		"y": 19
	    },
	    {
		"name": "Nauru",
		"codes": [
		    "NR",
		    "NRU",
		    "520",
		    "ISO 3166-2:NR"
		],
		"x": 26,
		"y": 17
	    },
	    {
		"name": "Nepal",
		"codes": [
		    "NP",
		    "NPL",
		    "524",
		    "ISO 3166-2:NP"
		],
		"x": 23,
		"y": 9
	    },
	    {
		"name": "Netherlands",
		"codes": [
		    "NL",
		    "NLD",
		    "528",
		    "ISO 3166-2:NL"
		],
		"x": 13,
		"y": 4
	    },
	    {
		"name": "New Zealand",
		"codes": [
		    "NZ",
		    "NZL",
		    "554",
		    "ISO 3166-2:NZ"
		],
		"x": 26,
		"y": 21
	    },
	    {
		"name": "Nicaragua",
		"codes": [
		    "NI",
		    "NIC",
		    "558",
		    "ISO 3166-2:NI"
		],
		"x": 2,
		"y": 6
	    },
	    {
		"name": "Niger",
		"codes": [
		    "NE",
		    "NER",
		    "562",
		    "ISO 3166-2:NE"
		],
		"x": 15,
		"y": 12
	    },
	    {
		"name": "Nigeria",
		"codes": [
		    "NG",
		    "NGA",
		    "566",
		    "ISO 3166-2:NG"
		],
		"x": 13,
		"y": 15
	    },
	    {
		"name": "Norway",
		"codes": [
		    "NO",
		    "NOR",
		    "578",
		    "ISO 3166-2:NO"
		],
		"x": 15,
		"y": 1
	    },
	    {
		"name": "Oman",
		"codes": [
		    "OM",
		    "OMN",
		    "512",
		    "ISO 3166-2:OM"
		],
		"x": 19,
		"y": 11
	    },
	    {
		"name": "Pakistan",
		"codes": [
		    "PK",
		    "PAK",
		    "586",
		    "ISO 3166-2:PK"
		],
		"x": 21,
		"y": 8
	    },
	    {
		"name": "Palau",
		"codes": [
		    "PW",
		    "PLW",
		    "585",
		    "ISO 3166-2:PW"
		],
		"x": 25,
		"y": 16
	    },
	    {
		"name": "Panama",
		"codes": [
		    "PA",
		    "PAN",
		    "591",
		    "ISO 3166-2:PA"
		],
		"x": 4,
		"y": 8
	    },
	    {
		"name": "Papua New Guinea",
		"codes": [
		    "PG",
		    "PNG",
		    "598",
		    "ISO 3166-2:PG"
		],
		"x": 25,
		"y": 17
	    },
	    {
		"name": "Paraguay",
		"codes": [
		    "PY",
		    "PRY",
		    "600",
		    "ISO 3166-2:PY"
		],
		"x": 6,
		"y": 12
	    },
	    {
		"name": "Peru",
		"codes": [
		    "PE",
		    "PER",
		    "604",
		    "ISO 3166-2:PE"
		],
		"x": 5,
		"y": 11
	    },
	    {
		"name": "Philippines",
		"codes": [
		    "PH",
		    "PHL",
		    "608",
		    "ISO 3166-2:PH"
		],
		"x": 26,
		"y": 11
	    },
	    {
		"name": "Poland",
		"codes": [
		    "PL",
		    "POL",
		    "616",
		    "ISO 3166-2:PL"
		],
		"x": 15,
		"y": 4
	    },
	    {
		"name": "Portugal",
		"codes": [
		    "PT",
		    "PRT",
		    "620",
		    "ISO 3166-2:PT"
		],
		"x": 11,
		"y": 6
	    },
	    {
		"name": "Qatar",
		"codes": [
		    "QA",
		    "QAT",
		    "634",
		    "ISO 3166-2:QA"
		],
		"x": 19,
		"y": 10
	    },
	    {
		"name": "Romania",
		"codes": [
		    "RO",
		    "ROU",
		    "642",
		    "ISO 3166-2:RO"
		],
		"x": 17,
		"y": 6
	    },
	    {
		"name": "Russian Federation",
		"codes": [
		    "RU",
		    "RUS",
		    "643",
		    "ISO 3166-2:RU"
		],
		"x": 25,
		"y": 4
	    },
	    {
		"name": "Rwanda",
		"codes": [
		    "RW",
		    "RWA",
		    "646",
		    "ISO 3166-2:RW"
		],
		"x": 16,
		"y": 16
	    },
	    {
		"name": "St. Kitts & Nevis",
		"codes": [
		    "KN",
		    "KNA",
		    "659",
		    "ISO 3166-2:KN"
		],
		"x": 6,
		"y": 5
	    },
	    {
		"name": "St. Lucia",
		"codes": [
		    "LC",
		    "LCA",
		    "662",
		    "ISO 3166-2:LC"
		],
		"x": 7,
		"y": 5
	    },
	    {
		"name": "St. Vincent & the Grenadines",
		"codes": [
		    "VC",
		    "VCT",
		    "670",
		    "ISO 3166-2:VC"
		],
		"x": 7,
		"y": 6
	    },
	    {
		"name": "Samoa",
		"codes": [
		    "WS",
		    "WSM",
		    "882",
		    "ISO 3166-2:WS"
		],
		"x": 28,
		"y": 18
	    },
	    {
		"name": "Sao Tome and Principe",
		"codes": [
		    "ST",
		    "STP",
		    "678",
		    "ISO 3166-2:ST"
		],
		"x": 11,
		"y": 16
	    },
	    {
		"name": "Saudi Arabia",
		"codes": [
		    "SA",
		    "SAU",
		    "682",
		    "ISO 3166-2:SA"
		],
		"x": 19,
		"y": 9
	    },
	    {
		"name": "Senegal",
		"codes": [
		    "SN",
		    "SEN",
		    "686",
		    "ISO 3166-2:SN"
		],
		"x": 13,
		"y": 12
	    },
	    {
		"name": "Serbia",
		"codes": [
		    "RS",
		    "SRB",
		    "688",
		    "ISO 3166-2:RS"
		],
		"x": 16,
		"y": 7
	    },
	    {
		"name": "Seychelles",
		"codes": [
		    "SC",
		    "SYC",
		    "690",
		    "ISO 3166-2:SC"
		],
		"x": 18,
		"y": 17
	    },
	    {
		"name": "Sierra Leone",
		"codes": [
		    "SL",
		    "SLE",
		    "694",
		    "ISO 3166-2:SL"
		],
		"x": 12,
		"y": 13
	    },
	    {
		"name": "Singapore",
		"codes": [
		    "SG",
		    "SGP",
		    "702",
		    "ISO 3166-2:SG"
		],
		"x": 24,
		"y": 13
	    },
	    {
		"name": "Slovakia",
		"codes": [
		    "SK",
		    "SVK",
		    "703",
		    "ISO 3166-2:SK"
		],
		"x": 16,
		"y": 5
	    },
	    {
		"name": "Slovenia",
		"codes": [
		    "SI",
		    "SVN",
		    "705",
		    "ISO 3166-2:SI"
		],
		"x": 14,
		"y": 6
	    },
	    {
		"name": "Solomon Islands",
		"codes": [
		    "SB",
		    "SLB",
		    "090",
		    "ISO 3166-2:SB"
		],
		"x": 26,
		"y": 18
	    },
	    {
		"name": "Somalia",
		"codes": [
		    "SO",
		    "SOM",
		    "706",
		    "ISO 3166-2:SO"
		],
		"x": 18,
		"y": 14
	    },
	    {
		"name": "South Africa",
		"codes": [
		    "ZA",
		    "ZAF",
		    "710",
		    "ISO 3166-2:ZA"
		],
		"x": 16,
		"y": 20
	    },
	    {
		"name": "South Sudan",
		"codes": [
		    "SS",
		    "SSD",
		    "728",
		    "ISO 3166-2:SS"
		],
		"x": 15,
		"y": 13
	    },
	    {
		"name": "Spain",
		"codes": [
		    "ES",
		    "ESP",
		    "724",
		    "ISO 3166-2:ES"
		],
		"x": 12,
		"y": 6
	    },
	    {
		"name": "Sri Lanka",
		"codes": [
		    "LK",
		    "LKA",
		    "144",
		    "ISO 3166-2:LK"
		],
		"x": 22,
		"y": 11
	    },
	    {
		"name": "Sudan",
		"codes": [
		    "SD",
		    "SDN",
		    "729",
		    "ISO 3166-2:SD"
		],
		"x": 16,
		"y": 12
	    },
	    {
		"name": "Suriname",
		"codes": [
		    "SR",
		    "SUR",
		    "740",
		    "ISO 3166-2:SR"
		],
		"x": 7,
		"y": 11
	    },
	    {
		"name": "Swaziland",
		"codes": [
		    "SZ",
		    "SWZ",
		    "748",
		    "ISO 3166-2:SZ"
		],
		"x": 16,
		"y": 19
	    },
	    {
		"name": "Sweden",
		"codes": [
		    "SE",
		    "SWE",
		    "752",
		    "ISO 3166-2:SE"
		],
		"x": 16,
		"y": 1
	    },
	    {
		"name": "Switzerland",
		"codes": [
		    "CH",
		    "CHE",
		    "756",
		    "ISO 3166-2:CH"
		],
		"x": 14,
		"y": 5
	    },
	    {
		"name": "Syria",
		"codes": [
		    "SY",
		    "SYR",
		    "760",
		    "ISO 3166-2:SY"
		],
		"x": 19,
		"y": 7
	    },
	    {
		"name": "Tajikistan",
		"codes": [
		    "TJ",
		    "TJK",
		    "762",
		    "ISO 3166-2:TJ"
		],
		"x": 23,
		"y": 7
	    },
	    {
		"name": "Tanzania",
		"codes": [
		    "TZ",
		    "TZA",
		    "834",
		    "ISO 3166-2:TZ"
		],
		"x": 17,
		"y": 16
	    },
	    {
		"name": "Thailand",
		"codes": [
		    "TH",
		    "THA",
		    "764",
		    "ISO 3166-2:TH"
		],
		"x": 24,
		"y": 10
	    },
	    {
		"name": "Timor-Leste",
		"codes": [
		    "TL",
		    "TLS",
		    "626",
		    "ISO 3166-2:TL"
		],
		"x": 25,
		"y": 14
	    },
	    {
		"name": "Togo",
		"codes": [
		    "TG",
		    "TGO",
		    "768",
		    "ISO 3166-2:TG"
		],
		"x": 14,
		"y": 14
	    },
	    {
		"name": "Tonga",
		"codes": [
		    "TO",
		    "TON",
		    "776",
		    "ISO 3166-2:TO"
		],
		"x": 28,
		"y": 19
	    },
	    {
		"name": "Trinidad & Tobago",
		"codes": [
		    "TT",
		    "TTO",
		    "780",
		    "ISO 3166-2:TT"
		],
		"x": 7,
		"y": 9
	    },
	    {
		"name": "Tunisia",
		"codes": [
		    "TN",
		    "TUN",
		    "788",
		    "ISO 3166-2:TN"
		],
		"x": 14,
		"y": 11
	    },
	    {
		"name": "Turkey",
		"codes": [
		    "TR",
		    "TUR",
		    "792",
		    "ISO 3166-2:TR"
		],
		"x": 18,
		"y": 7
	    },
	    {
		"name": "Turkmenistan",
		"codes": [
		    "TM",
		    "TKM",
		    "795",
		    "ISO 3166-2:TM"
		],
		"x": 22,
		"y": 7
	    },
	    {
		"name": "Tuvalu",
		"codes": [
		    "TV",
		    "TUV",
		    "798",
		    "ISO 3166-2:TV"
		],
		"x": 27,
		"y": 18
	    },
	    {
		"name": "Uganda",
		"codes": [
		    "UG",
		    "UGA",
		    "800",
		    "ISO 3166-2:UG"
		],
		"x": 16,
		"y": 15
	    },
	    {
		"name": "Ukraine",
		"codes": [
		    "UA",
		    "UKR",
		    "804",
		    "ISO 3166-2:UA"
		],
		"x": 17,
		"y": 5
	    },
	    {
		"name": "United Arab Emirates",
		"codes": [
		    "AE",
		    "ARE",
		    "784",
		    "ISO 3166-2:AE"
		],
		"x": 20,
		"y": 10
	    },
	    {
		"name": "Great Britain and Northern Ireland",
		"codes": [
		    "GB",
		    "GBR",
		    "826",
		    "ISO 3166-2:GB"
		],
		"x": 11,
		"y": 4
	    },
	    {
		"name": "United States of America",
		"codes": [
		    "US",
		    "USA",
		    "840",
		    "ISO 3166-2:US"
		],
		"x": 1,
		"y": 2
	    },
	    {
		"name": "Uruguay",
		"codes": [
		    "UY",
		    "URY",
		    "858",
		    "ISO 3166-2:UY"
		],
		"x": 7,
		"y": 12
	    },
	    {
		"name": "Uzbekistan",
		"codes": [
		    "UZ",
		    "UZB",
		    "860",
		    "ISO 3166-2:UZ"
		],
		"x": 22,
		"y": 6
	    },
	    {
		"name": "Vanuatu",
		"codes": [
		    "VU",
		    "VUT",
		    "548",
		    "ISO 3166-2:VU"
		],
		"x": 26,
		"y": 19
	    },
	    {
		"name": "Venezuela",
		"codes": [
		    "VE",
		    "VEN",
		    "862",
		    "ISO 3166-2:VE"
		],
		"x": 6,
		"y": 9
	    },
	    {
		"name": "Viet Nam",
		"codes": [
		    "VN",
		    "VNM",
		    "704",
		    "ISO 3166-2:VN"
		],
		"x": 26,
		"y": 9
	    },
	    {
		"name": "Yemen",
		"codes": [
		    "YE",
		    "YEM",
		    "887",
		    "ISO 3166-2:YE"
		],
		"x": 18,
		"y": 11
	    },
	    {
		"name": "Zambia",
		"codes": [
		    "ZM",
		    "ZMB",
		    "894",
		    "ISO 3166-2:ZM"
		],
		"x": 14,
		"y": 18
	    },
	    {
		"name": "Zimbabwe",
		"codes": [
		    "ZW",
		    "ZWE",
		    "716",
		    "ISO 3166-2:ZW"
		],
		"x": 16,
		"y": 18
	    }
	]
    })}




const ID_BASEMAP = "basemap";
function RamaddaBasemapDisplay(displayManager, id, type, properties) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    let myProps = [
	{label:'Base map properties'},
	{p:'regionField',ex:''},
	{p:'valueField',ex:''},
	{p:'mapFile',ex:'usmap.json|countries.json',d:"usmap.json"},
	{p:'skipRegions',ex:'Alaska,Hawaii'},
	{p:'pruneMissing',ex:'true'},				
	{p:'mapBackground',ex:'transparent'},
	{p:'transforms',ex:"Alaska,0.4,30,-40;Hawaii,2,50,5;Region,scale,offsetX,offsetY"},
	{p:'prunes',ex:'Alaska,100;Region,maxCount'},
	{p:'mapWidth',ex:'600'},
	{p:'mapHeight',ex:'400'},
	{p:'maxLon'},
	{p:'minLon'},
	{p:'maxLat'},
	{p:'minLat'},			
	{p:"strokeColor"},
	{p:"strokeWidth"},
	{p:"highlightStrokeColor"},
	{p:"highlightStrokeWidth"},
	{p:"highlightFill"},
	{p:"missingFill"},			
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        checkLayout: function() {
            this.updateUI();
        },
        makeMap: function() {
	},
	makePoly:function(polygon) {
	    let poly = [];
	    polygon.forEach(point=>{
		let lon = point[0];
		let lat = point[1];
		if(isNaN(lon) || isNaN(lat)) return;
		poly.push({x:lon,y:lat});
	    });
	    return poly;
	},
	findValues:function(region, valueMap) {
	    if(valueMap[region]) return valueMap[region];
	    let values = null;
	    if(!this.aliasMap[region]) {
		return null;
	    }
	    this.aliasMap[region].forEach(alias=>{
		if(valueMap[alias]) values = valueMap[alias];
	    });
	    return values;
	},
	makeValueMap: function(records,needsValue) {
	    let regionField=this.getFieldById(null,this.getPropertyRegionField());
	    let valueField=this.getFieldById(null,this.getPropertyValueField());	    
	    if(!regionField) {
                this.displayError("No region field specified");
		return null
	    }
	    if(!valueField && needsValue) {
                this.displayError("No value field specified");
		return null
	    }	    
	    if(valueField) {
		if(this.getProperty("colorBy")==null) this.setProperty("colorBy",valueField.getId());
		if(this.getProperty("sizeBy")==null) this.setProperty("sizeBy",valueField.getId());	    
	    }
	    let valueMap = {};
	    this.valueRange = {
		min: null,
		max:null
	    };
	    this.idToRecord = {};
	    records.forEach(record=>{
		let region = record.getValue(regionField.getIndex());
		this.idToRecord[record.getId()] = record;
		let values  = valueMap[region] = {
		    record:record
		}
		if(valueField) { 
		    let value = record.getValue(valueField.getIndex());
		    values.value = value;
		    this.valueRange.min = this.valueRange.min===null?value:Math.min(value,this.valueRange.min);
		    this.valueRange.max = this.valueRange.max===null?value:Math.max(value,this.valueRange.max);
		}
	    });
	    if(valueField) {
		records.forEach(record=>{
		    let region = record.getValue(regionField.getIndex());
		    let values  = valueMap[region];
		    let value = values.value
		    let percent = (value-this.valueRange.min)/(this.valueRange.max-this.valueRange.min);
		    values.percent = percent;
		});
	    }
	    return valueMap;
	},
	writeMap:function(skipHeight)  {
	    let width = this.getMapWidth(this.getProperty("width",800));
	    let css = HU.css(BACKGROUND,this.getMapBackground("transparent"),WIDTH,HU.getDimension(width));
	    let height;
	    if(!skipHeight) {
		height = this.getMapHeight(this.getProperty("height"));
		let mw = this.mapRange.maxLon-this.mapRange.minLon;
		let mh = this.mapRange.maxLat-this.mapRange.minLat;
		if(!height)
		    height = mh/mw*width;
		if(isNaN(height)) height=400; 
		css+=HU.css(HEIGHT,HU.getDimension(height));
	    }
	    
	    this.mapRange.maxLon= this.getPropertyMaxLon(this.mapRange.maxLon);
	    this.mapRange.minLon= this.getPropertyMinLon(this.mapRange.minLon);
	    this.mapRange.maxLat= this.getPropertyMaxLat(this.mapRange.maxLat);
	    this.mapRange.minLat= this.getPropertyMinLat(this.mapRange.minLat);	    	    
	    this.setContents(HU.div([ID,this.domId(ID_BASEMAP),STYLE,css]));
	    if(isNaN(width)) {
		width = this.getContents().width();
	    }
	    return [width,height];

	},
	makeSvg: function(width,height) {
	    const svg = d3.select("#" + this.domId(ID_BASEMAP)).append('svg')
		  .attr('width', width)
		  .attr('height', height)
		  .append('g')
	    let padx = 0;
	    let pady = padx;
	    let scaleX  = d3.scaleLinear().domain([this.mapRange.minLon, this.mapRange.maxLon]).range([padx, width-padx]);
	    let scaleY  = d3.scaleLinear().domain([this.mapRange.maxLat, this.mapRange.minLat]).range([pady, height-pady]);
	    return [svg,scaleX,scaleY];
	},

	clearTooltip: function() {
	    if(this.tooltipDiv)
		this.tooltipDiv.style("opacity", 0);
	},
	makeTooltipDiv: function() {
	    if(!this.tooltipDiv) {
		this.tooltipDiv = d3.select("body").append("div")
		    .attr("class", "ramadda-shadow-box  display-tooltip")
		    .style("opacity", 0)
		    .style("position", "absolute")
		    .style("background", "#fff")
	    }
	    this.clearTooltip();
	    return this.tooltipDiv;
	},
	addEvents:function(polys, idToRecord, tooltipDiv) {
	    idToRecord  = idToRecord|| this.idToRecord;
	    tooltipDiv = tooltipDiv || this.makeTooltipDiv();
	    let _this = this;
	    let tooltip = this.getProperty("tooltip");
	    polys.on('click', function (d, i) {
		let poly = d3.select(this);
		let record = idToRecord[poly.attr(RECORD_ID)];
		if(record)
		    _this.propagateEventRecordSelection({record: record});
	    });
	    polys.on('mouseover', function (d, i) {
		let poly = d3.select(this);
		let record = idToRecord[poly.attr(RECORD_ID)];
		poly.attr("lastStroke",poly.attr("stroke"))
		    .attr("lastFill",poly.attr("fill"));
		poly.attr("stroke",_this.getPropertyHighlightStrokeColor("blue")).attr("stroke-width",_this.getPropertyHighlightStrokeWidth(1))
		    .attr("fill",_this.getPropertyHighlightFill("blue"));
		if(!tooltip) return;
		let regionName = poly.attr("regionName");
		let tt = null;
		if(!record) {
		    tt = regionName;
		    console.log("no record found for region:" +regionName);
		} else {
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		    tt =  _this.getRecordHtml(record,null,tooltip);
		}
		if(tt) {
		    _this.tooltipDiv.html(tt)
			.style("left", (d3.event.pageX + 10) + "px")
			.style("top", (d3.event.pageY + 20) + "px");
		    _this.tooltipDiv.style("opacity", 1);
		    //For now don't transition as it seems to screw up
		    //subsequent mouse overs
		    /*
		    _this.tooltipDiv.transition()
			.delay(500)
			.duration(500)
			.style("opacity", 1);
		    */
		}
	    });
	    polys.on('mouseout', function (d, i) {
//		_this.tooltipDiv.transition();
		let poly = d3.select(this);
		poly.attr("stroke",poly.attr("lastStroke"))
		    .attr("fill",poly.attr("lastFill"))
		    .attr("stroke-width",1);
		_this.tooltipDiv.style("opacity", 0);
	    });
	},
        updateUI: function() {
	    this.clearTooltip();
	    if(!this.mapJson) {
		if(!this.gettingFile) {
		    this.gettingFile = true;
		    let mapFile = this.getPropertyMapFile();
		    if(!mapFile.startsWith("/") && !mapFile.startsWith("http")) {
			mapFile =ramaddaCdn +"/resources/" + mapFile;
		    }
		    var jqxhr = $.getJSON(mapFile, (data) =>{
			this.mapJson = data;
			this.regionNames=[];
			this.makeRegions();
			this.updateUI();
		    });
		}
		return;
	    }
	    if(!this.regions) {
		if(!this.makeRegions()) return;
	    }
	    this.makeMap();
	},
	makeRegions:function() {
	    if(!this.mapJson) return false;
	    let debug = this.getProperty("debug");
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let allRegions = {};
	    if(this.getData()==null) {
		return false;
	    }
	    let allRecords = this.getData().getRecords()
	    let regionField=this.getFieldById(null,this.getPropertyRegionField());
	    if(regionField==null) {
		this.displayError("No region field");
		return false;
	    }
	    allRecords.forEach(record=>{
		let v = record.getValue(regionField.getIndex());
//		console.log("data region:" + v);
		allRegions[v] = true;
	    });
	    this.regions = {};
	    this.mapRange  = {
		minLon:null,
		maxLon:null,
		minLat:null,
		maxLat:null
	    };
	    let transforms = {}
	    let prunes = {}	    
	    this.getPropertyTransforms("").split(";").map(t=>t.split(",")).forEach(tuple=>{
		let region = tuple[0];
		transforms[region] = {
		    scale:tuple[1]!=null?+tuple[1]:1,
		    dx:tuple[2]!=null?+tuple[2]:0,
		    dy:tuple[3]!=null?+tuple[3]:0}
	    });

	    this.getPropertyPrunes("").split(";").map(t=>t.split(",")).forEach(tuple=>{
		let region = tuple[0];
		prunes[region] =  +tuple[1];
	    });

	    let tfunc=(region,polygon)=>{
		let prune = prunes[region];
		if(prune>0) {
		    if(polygon.length<prune) return null;
		}

		let transform = transforms[region];
		if(!transform) 
		    return polygon;
		let bounds = Utils.getBounds(polygon);
		let centerx = bounds.minx + (bounds.maxx-bounds.minx)/2;
		let centery = bounds.miny + (bounds.maxy-bounds.miny)/2;		
		polygon.map(pair=>{
		    pair[0]= (pair[0]-centerx)*transform.scale+centerx;
		    pair[1]= (pair[1]-centery)*transform.scale+centery;		    		    
		    pair[0] += transform.dx;
		    pair[1] += transform.dy;
		    return pair;
		});
		return polygon;		
	    };
	    
	    this.skipRegions = this.getPropertySkipRegions("").split(",").map(r=>r.replace(/_comma_/g,","));
	    let features = this.mapJson.geojson;
	    if(!features)
		features = this.mapJson.features;

	    this.aliasMap = {};
	    features.forEach(blob=>{
		let region = blob.properties.name || blob.properties.name_long || blob.properties.NAME || blob.properties.ADMIN; 
		let aliases = [region];
		//Some hacks
		if(region=="United States of America") aliases.push("United States");
		if(region=="United Republic of Tanzania") aliases.push("Tanzania");
		if(region=="Democratic Republic of the Congo") aliases.push("Democratic Republic of Congo");
		if(region=="Czech Rep.") aliases.push("Czech Republic");
		if(region=="Bosnia and Herz.") aliases.push("Bosnia and Herzegovina");
		this.aliasMap[region] = aliases;
		if(blob.properties.ISO_A3)
		    aliases.push(blob.properties.ISO_A3);
		if(blob.properties.STUSPS)
		    aliases.push(blob.properties.STUSPS);
		if(blob.properties.STATEFP)
		    aliases.push(blob.properties.STATEFP);		
		if(!blob.geometry) {
		    if(debug)
			console.log(region +" no geometry");
		    return;
		}
		if(debug)
		    console.log("region:" + region);
		let ok = true;
		aliases.forEach(alias=>{
		    if(this.skipRegions.includes(alias)) ok = false;});
		if(!ok) {
		    return;
		}
		ok = false;
		aliases.forEach(alias=>{
		    if(allRegions[alias]) {
			ok =true;
		    }});
		if(!ok) this.handleWarning("Missing data for map region:" + region);
		if(pruneMissing && !ok) return;
		this.regionNames.push(region);
		let coords = blob.geometry.coordinates;
		let info = {
		    name:region,
		    aliases: aliases,
		    polygons:[],
		    bounds:null
		};
		aliases.forEach(alias=>{
		    this.regions[alias] = info;
		});
		if(blob.geometry.type  == "MultiPolygon") {
		    coords.forEach(group=>{
			group.forEach(polygon=>{
			    polygon  = tfunc(region,polygon);
			    if(polygon)info.polygons.push(polygon);
			});
		    });
		} else {
		    coords.forEach(polygon=>{
			info.polygons.push(tfunc(region,polygon));
		    });
		}
		info.polygons.forEach(polygon=>{
		    polygon.forEach(point=>{
			let lon = point[0];
			let lat = point[1];
			if(isNaN(lon) || isNaN(lat)) return;
			this.mapRange.minLon= this.mapRange.minLon===null?lon:Math.min(this.mapRange.minLon,lon);
			this.mapRange.maxLon= this.mapRange.maxLon===null?lon:Math.max(this.mapRange.maxLon,lon);
			this.mapRange.minLat= this.mapRange.minLat===null?lat:Math.min(this.mapRange.minLat,lat);
			this.mapRange.maxLat= this.mapRange.maxLat===null?lat:Math.max(this.mapRange.maxLat,lat);						
		    });
		});
		let bounds = null;
		info.polygons.forEach(polygon=>{
		    bounds = Utils.mergeBounds(bounds, Utils.getBounds(polygon));
		});
		info.bounds = bounds;
	    });
	    return true;
	},
	
    });
}


function RamaddaMapchartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPCHART, properties);
    let myProps = [
	{label:'Map chart Properties'},
	{p:'maxLayers',ex:'10'},
	{p:'translateX',ex:'0'},
	{p:'translateY',ex:'0'},	
	{p:'skewX',ex:'-10'},
	{p:'skewY',ex:'0'},	
	{p:'rotate',ex:'10'},
	{p:'scale',ex:'0'},
	{p:'fillColor',ex:'red'},
	{p:'blur',ex:'4'},			
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let allRecords = this.getData().getRecords()
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let maxLayers = +this.getPropertyMaxLayers(20);
	    Object.keys(valueMap).forEach(region=>{
		let values = valueMap[region];
		values.layers = Math.round(values.percent*(maxLayers-1))+1;
	    });
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);
	    SU.transform(svg,SU.translate(width/2, height/2), SU.scale(0.9), SU.rotate(this.getPropertyRotate(0)), SU.translate(-width/2,-height/2), SU.translate(this.getPropertyTranslateX(30),this.getPropertyTranslateY(0)), SU.skewX(this.getPropertySkewX(-10)), SU.scale(this.getPropertyScale(1)));
	    var defs = svg.append("defs");
	    SU.makeBlur(svg,"blur", this.getPropertyBlur(3));
	    for(let layer=0;layer<maxLayers;layer++) {
		this.regionNames.forEach(region=>{
		    let values= this.findValues(region, valueMap);
		    let maxLayer = 1;
		    let value = NaN;
		    let missing = values==null;
		    let record = null;
		    if(!missing) {
			maxLayer = values.layers;
			value = values.value;
			record = values.record;
		    } else {
			if(pruneMissing) return;
			maxLayer = 1;
			if(layer>0) return;
		    }
		    let recordId = record?record.getId():"";
		    if(!Utils.isDefined(maxLayer)) maxLayer = 1;
		    if(layer>maxLayer) return;
		    this.regions[region].polygons.forEach(polygon=>{
			let uid = HtmlUtils.getUniqueId();
			let poly = this.makePoly(polygon);
			let fillColor = "transparent";
			if(missing) {
			    fillColor = "#ccc";
			    lineColor="#000" 
			} else {
			    if(layer==maxLayer-1) {
				fillColor = this.colorBy.getColor(value);
				lineColor  = Utils.pSBC(0.1,fillColor);
			    } else {
				lineColor  = Utils.pSBC(-0.3,this.colorBy.getColor(value));
			    }
			}
			if(missing) {
			    svg.selectAll(region+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
				.attr("regionName",region)
				.attr("fill","#ccc")
		    		.attr("stroke-width",1)
			    	.attr("stroke","black");
			    return;
			}
			if(layer==0) {
			    svg.selectAll(region+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
		    		.attr("stroke-width",3)
				.attr("stroke","black")
				.style("filter","url(#blur)");
			}
			let polys = 
			    svg.selectAll(region+uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill",fillColor)
			    .attr("opacity",1)
			    .attr("stroke",lineColor)
			    .attr("stroke-width",1)
			    .style("cursor", "pointer")
			    .attr(RECORD_ID,recordId);
			this.addEvents(polys);
		    });
		});
	    }
	    this.colorBy.displayColorTable();
	}
    });
}



function RamaddaMaparrayDisplay(displayManager, id, properties) {
    const ID_MAPBLOCK = "mapblock";
    const ID_MAPLABEL = "maplabel";        
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPARRAY, properties);
    let myProps = [
	{label:'Map array properties'},
	{p:'blockWidth',ex:''},
	{p:'sortByValue',ex:'true'},
	{p:'fillColor',ex:'red'},
	{p:'showValue',ex:'true'},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let allRecords = this.getData().getRecords()
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap(true);
	    let blockWidth= this.getPropertyBlockWidth(75);
	    let blockHeight= blockWidth;
	    let pruneMissing = this.getPropertyPruneMissing(true);
	    let sortedRegions = this.regionNames;
	    if(this.getPropertySortByValue(true)) {
		sortedRegions.sort((a,b)=>{
		    return valueMap[a].value-valueMap[b].value;
		});
	    } else {
		sortedRegions.sort();
	    }

	    let html = "";
	    sortedRegions.forEach((region,idx)=>{
		html+= HU.div([CLASS,"display-maparray-block"],
			      HU.div([CLASS,"display-maparray-header"],region) +
			      HU.div([ID,this.domId(ID_MAPBLOCK+"_"+idx),CLASS,"display-maparray-map",STYLE,HU.css(WIDTH,blockWidth+"px",HEIGHT,blockHeight+"px")]) +
			      HU.div([ID,this.domId(ID_MAPLABEL+"_"+idx),"display-maparray-label"]));			      


		    
	    });
	    this.jq(ID_BASEMAP).html(html+"<p>");

	    let showValue = this.getPropertyShowValue(true);

	    sortedRegions.forEach((region,idx)=>{
		let info = this.regions[region];
		let svg = d3.select("#" + this.domId(ID_MAPBLOCK+"_"+idx)).append('svg')
		    .attr('width', blockWidth)
		    .attr('height', blockHeight)
		    .append('g')
		let padx=5;
		let pady=5;
		let mapWidth = info.bounds.getWidth();
		let mapHeight = info.bounds.getHeight();
		let scaleX;
		let scaleY;
		if(mapWidth>mapHeight) {
		    scaleX= d3.scaleLinear().domain([info.bounds.minx, info.bounds.maxx]).range([0, blockWidth-padx]);
		    scaleY= d3.scaleLinear().domain([info.bounds.maxy, info.bounds.miny]).range([0, (mapHeight/mapWidth)*blockHeight-pady]);
		} else {
		    scaleX= d3.scaleLinear().domain([info.bounds.minx, info.bounds.maxx]).range([0, (mapWidth/mapHeight)*blockWidth-padx]);
		    scaleY= d3.scaleLinear().domain([info.bounds.maxy, info.bounds.miny]).range([0, blockHeight-pady]);
		}
		let values = valueMap[region];
		let value = NaN;
		let missing = values==null;
		let record = null;
		if(!missing) {
		    value = values.value;
		    record = values.record;
		    if(showValue) {
			this.jq(ID_MAPLABEL+"_"+idx).html(value);
		    }
		} else {
		    if(pruneMissing) return;
		}

		let recordId = record?record.getId():"";
		info.polygons.forEach(polygon=>{
		    let uid = HtmlUtils.getUniqueId();
		    let poly = this.makePoly(polygon);
		    let fillColor = "transparent";
		    if(missing) {
			fillColor = "#ccc";
			lineColor="#000" 
		    } else {
			fillColor = this.colorBy.getColor(value);
			lineColor = "#ccc";
		    }
		    if(missing) {
			svg.selectAll(region+uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill","#ccc")
		    	    .attr("stroke-width",1)
			    .attr("stroke","black");
			return;
		    }
		    let polys = 
			svg.selectAll(region+uid)
			.data([poly])
			.enter().append("polygon")
			.attr("points",function(d) { 
			    return d.map(d=>{return [+scaleX(d.x),+scaleY(d.y)].join(",");}).join(" ");
			})
			.attr("fill",fillColor)
			.attr("opacity",1)
			.attr("stroke",lineColor)
			.attr("stroke-width",1)
			.style("cursor", "pointer")
			.attr(RECORD_ID,recordId);
		    this.addEvents(polys);
		});
	    });
	    this.colorBy.displayColorTable();
	}
    });
}




function RamaddaMapshrinkDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPSHRINK, properties);
    let myProps = [
	{label:'Map shrink Properties'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let allRecords = this.getData().getRecords()
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let sizeBy = new SizeBy(this, allRecords);
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);

	    for(let layer=0;layer<2;layer++) {
		this.regionNames.forEach(region=>{
		    let values= this.findValues(region, valueMap);
		    let value = NaN;
		    let missing = values==null;
		    let record = null;
		    if(!missing) {
			value = values.value;
			record = values.record;
		    } else {
			if(pruneMissing) return;
			if(layer>0) return;
		    }
		    let recordId = record?record.getId():"";
		    this.regions[region].polygons.forEach(polygon=>{
			let uid = HtmlUtils.getUniqueId();
			let poly = this.makePoly(polygon);
			let fillColor = "red";
			let transform  = "";
			lineColor="#000" 
			if(layer==0) {
			    fillColor = "#fff";
			} else {
			    lineColor="transparent" 
			    fillColor = this.colorBy.getColor(value);
			    let bounds = Utils.getBounds(polygon);
			    let center = bounds.getCenter();
			    let p=0;
			    let sizeByFunc = function(p, size) {
				percent = p;
				return percent;
			    }
			    sizeBy.getSizeFromValue(value,sizeByFunc);
			    transform = SU.translate(scaleX(center.x),scaleY(center.y)) + SU.scale(percent) + SU.translate(-scaleX(center.x),-scaleY(center.y))
			}
			if(missing) {
			    svg.selectAll(region+"base"+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
				.attr("fill","#ccc")
		    		.attr("stroke-width",1)
			    	.attr("stroke","black");
			    return;
			}
			if(layer==0) {
			    svg.selectAll(region+"base"+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(","); }).join(" ");
				})
		    		.attr("stroke-width",1)
				.attr("stroke","black")
				.attr('transform',transform);
			}
			let polys = 
			    svg.selectAll(region+uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill",fillColor)
			    .attr("opacity",1)
			    .attr("stroke",lineColor)
			    .attr("stroke-width",1)
			    .attr('transform',transform)
			    .style("cursor", "pointer")
			    .attr(RECORD_ID,recordId);
			if(layer==1)
			    this.addEvents(polys);
		    });
		});
	    }
	    this.colorBy.displayColorTable();
	}
    });
}


function RamaddaMapimagesDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPIMAGES, properties);
    let myProps = [
	{label:'Map Images Properties'},
	{p:'imageField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getHeightForStyle: function(dflt) {
	    return null;
	},
	addMacroAttributes:function(macros,row,attrs) {
	    SUPER.addMacroAttributes.call(this,macros,row,attrs);
	    if(!this.imageField) return;
	    let f = this.imageField;
	    let value = row[f.getIndex()];
	    let imageAttrs = [];
	    let tokenAttrs  = macros.getAttributes("imageField_image");
	    let width = tokenAttrs?tokenAttrs["width"]:null;
	    if(width) {
		imageAttrs.push("width");
		imageAttrs.push(width);
	    } else if(this.getProperty("imageWidth")) {
		imageAttrs.push("width");
		imageAttrs.push(this.getProperty("imageWidth")); 
	    } else  {
		imageAttrs.push("width");
		imageAttrs.push("100%");
	    }
	    imageAttrs.push("style");
	    imageAttrs.push("vertical-align:top");
	    let img =  HU.image(value, imageAttrs);
	    attrs["imageField" +"_image"] =  img;
	    attrs["imageField" +"_url"] =  value;
	},
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    this.imageField = this.getFieldById(null,this.getPropertyImageField());	    
	    if(this.imageField == null) {
		this.imageField =  this.getFieldByType(null, "image");
	    }
	    if(this.imageField==null) {
                this.displayError("No image fields");
		return
	    }
	    let valueMap = this.makeValueMap(records);
	    if(!valueMap) return;
	    Object.keys(valueMap).forEach(region=>{
		let values = valueMap[region];
		values.image = values.record.getValue(this.imageField.getIndex());
	    });
	    let [width, height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);
	    var defs = svg.append("defs");
	    this.regionNames.forEach((region,idx)=>{
		let values= this.findValues(region, valueMap);
		let recordId = values!=null?values.record.getId():"";
		let regionClean = Utils.cleanId(region);
		this.regions[region].polygons.forEach(polygon=>{
		    let uid = HtmlUtils.getUniqueId();
		    if(values!=null) {
			defs.append("svg:pattern")
			    .attr("id", "bgimage"+ uid)
			    .attr("x", "1")
			    .attr("y", "1")
			    .attr("width", "100%")
		            .attr("height", "100%")
			    .attr("patternContentUnits","objectBoundingBox")
			    .append("svg:image")
			    .attr("xlink:href", values.image)
			    .attr("preserveAspectRatio","none")
			    .attr("width", 1)
			    .attr("height", 1)
			    .attr("x", "0")
			    .attr("y", "0");
		    }
		    let polys = svg.selectAll(regionClean+"base"+uid)
			.data([this.makePoly(polygon)])
			.enter().append("polygon")
			.attr("regionName",region)
			.attr("points",function(d) { 
			    return d.map(d=>{return [scaleX(d.x),scaleY(d.y)].join(",");}).join(" ");
			})
			.attr(RECORD_ID,recordId)
		    	.attr("stroke-width",this.getPropertyStrokeWidth(1))
			.attr("stroke",this.getPropertyStrokeColor("#000"));
		    if(values!=null)
			polys.style("fill", "url(#bgimage"+ uid+")")
		    else
			polys.style("fill",this.getPropertyMissingFill("#fff"));
		    this.addEvents(polys);
		});
	    });
	}
    });
}



		
function CollisionInfo(display,numRecords, roundPoint) {
    $.extend(this,{
	dot: null,
	display:display,
	roundPoint:roundPoint,
	visible: display.getPropertyCollisionFixed(),
	dot:null,
	numRecords:numRecords,
	records:[],
	addLines:false,
	lines:[],
	points:[],
	addRecord: function(record) {
	    this.records.push(record);
	},
	addLine:function(line) {
	    this.lines.push(line);
	},
	checkLines: function() {
	    if(!this.addedLines) {
		this.addedLines = true;
		this.display.addFeatures(this.lines,true);
		this.display.addFeatures(this.points,false);
	    }
	},
	createDot: function(idx) {
	    let tooltip = this.display.getCollisionTooltip();
	    let textGetter = tooltip==null?null:dot=>{
		let html = "";
		this.records.forEach(record=>{
		    html+=HU.div([STYLE,HU.css("border-bottom","1px solid #ccc")], this.display.getRecordHtml(record, null,tooltip));
		});
		return html;
	    };
	    let collisionIcon=this.display.getCollisionIcon();
	    let collisionIconSize=this.display.getCollisionIconSize(16);		
	    if(collisionIcon)
		this.dot = this.display.map.createMarker("dot-" + idx, [this.roundPoint.x,this.roundPoint.y], collisionIcon, "", "",null,collisionIconSize,null,null,null,null,false);
	    else
		this.dot = this.display.map.createPoint("dot-" + idx, this.roundPoint, this.getCollisionDotStyle(this),null,textGetter);
	    this.dot.collisionInfo  = this;
	    return this.dot;
	},
	dotSelected:function(dot) {
	    if(this.display.getCollisionFixed()) return;
	    this.setVisible(!this.visible);
	},
	styleCollisionDot:function(dot) {
	    $.extend(dot.style, this.getCollisionDotStyle(dot.collisionInfo));
	},
	addPoints:function(points) {
	    points.forEach(p=>this.points.push(p));
	},
	getCollisionDotStyle:function(collisionInfo) {
	    let collisionFixed = this.display.getCollisionFixed();
	    let dotColor = this.display.getProperty("collisionDotColor","blue");
	    let dotRadius = this.display.getProperty("collisionDotRadius",6);
	    if(!collisionFixed) {
		if(this.display.getPropertyCollisionScaleDots(false)) {
		    let scale = collisionInfo.numRecords/16;
		    if(scale>1)
			dotRadius = Math.min(dotRadius*scale,32);
//		    console.log("scaling dots " + dotRadius +" " +collisionInfo.numRecords);
		} 

		if(collisionInfo.visible)  {
		    dotColor = this.display.getProperty("collisionDotColorOn",dotColor);
		} else {
		    dotColor = this.display.getProperty("collisionDotColorOff",dotColor);
		}
	    }
	    return {
		fillColor:dotColor,
		pointRadius:dotRadius
	    }
	},


	setVisible:function(visible) {
	    this.visible = visible;
	    this.styleCollisionDot(this.dot);
	    this.dot.layer.drawFeature(this.dot, this.dot.style);
	    this.checkLines();
	    //These are the spokes
	    this.lines.forEach(f=>{
		f.featureVisible = this.visible;
		this.display.map.checkFeatureVisible(f,true);
	    });
	    this.records.forEach(record=>{
		let layoutThis = this.display.displayInfo[record.getId()];
		if(!layoutThis) {
		    return;
		}
		layoutThis.features.forEach(f=>{
		    f.featureVisible = this.visible;
		    this.display.map.checkFeatureVisible(f,true);
		});
	    });
	},
    });
    if(this.visible) {
	this.checkLines();
    }
}

/**
   Copyright 2008-2021 Geode Systems LLC
*/

const DISPLAY_EDITABLEMAP = "editablemap";


addGlobalDisplayType({
    type: DISPLAY_EDITABLEMAP,
    label: "Editable Map",
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Editable map"),        
});



function RamaddaEditablemapDisplay(displayManager, id, properties) {
    OpenLayers.Handler.ImageHandler = OpenLayers.Class(OpenLayers.Handler.RegularPolygon, {
	initialize: function(control, callbacks, options) {
	    OpenLayers.Handler.RegularPolygon.prototype.initialize.apply(this,arguments);
	    this.display = options.display;
	},
	finalize: function() {
	    this.theImage = this.image;
	    this.image =null;
	    OpenLayers.Handler.RegularPolygon.prototype.finalize.apply(this,arguments);
	    //call deactivate in a bit. If we do this now then there is an error in OL
	    setTimeout(()=>{
		this.display.clearCommands();
		//A bit of a hack but we want to change the style of the newly created image
		let image = this.display.myLayer.features[this.display.myLayer.features.length-1];
		image.style.strokeColor = "transparent";
		this.display.myLayer.redraw(image);
	    },500);
	},
	move: function(evt) {
	    if(!this.checkingImageSize) {
		this.checkingImageSize = true;
		const img = new Image();
		let _this = this;
		img.onload = function() {
		    _this.imageBounds={width:this.width,height:this.height};
		}
		img.src = this.style.imageUrl;		
	    }
	    OpenLayers.Handler.RegularPolygon.prototype.move.apply(this,arguments);
	    let mapBounds = this.feature.geometry.getBounds();
	    if(this.image) {
		this.display.map.removeLayer(this.image);
	    }
	    let b = this.display.map.transformProjBounds(mapBounds);
	    if(this.imageBounds) {
		let aspect = this.imageBounds.width/this.imageBounds.height;
		if(!evt.shiftKey)
		    b.right = aspect*(b.top-b.bottom) + b.left 
	    }
	    this.image=  this.display.map.addImageLayer("","","",this.style.imageUrl,true,  b.top,b.left,b.bottom,b.right);
	    this.image.setOpacity(this.style.imageOpacity);
	}
	
    });


    const ID_MESSAGE  ="message";
    const ID_DELETE  ="delete";
    const ID_OK  ="ok";
    const ID_APPLY  ="apply";
    const ID_CANCEL = "cancel";
    const ID_MENU_NEW = "new_file";
    const ID_MENU_FILE = "menu_file";
    const ID_MENU_EDIT = "menu_edit";    
    const ID_DELETE_ALL = "deleteall";
    const ID_TOBACK = "toback";
    const ID_TOFRONT = "tofront";    

    const ID_CUT = "cut";
    const ID_COPY= "copy";
    const ID_PASTE= "paste";        
    const ID_COMMANDS = "commands";
    const ID_CLEAR = "clear";
    const ID_PROPERTIES = "properties";
    const ID_NAVIGATE = "navigate";
    const ID_SAVE = "save";
    const ID_SAVEAS = "saveas";    
    const ID_DOWNLOAD = "download";    
    const ID_SELECTOR = "selector";
    const ID_EDIT = "edit";
    const ID_MOVER = "mover";
    const ID_RESIZE = "resize";
    const ID_RESHAPE = "reshape";    

    const SUPER = new RamaddaBaseMapDisplay(displayManager,  id, DISPLAY_EDITABLEMAP,  properties);
    RamaddaUtil.inherit(this,SUPER);
    addRamaddaDisplay(this);
    this.defineSizeByProperties();
    //do this here as this might be used by displaymap for annotation
    this.map = this.getProperty("theMap");
    let myProps = [
	{label:'Editable Map Properties'},
	{p:"displayOnly",d:false},
	{p:"strokeColor",d:"blue"},
	{p:"strokeWidth",d:2},
	{p:"pointRadius",d:10},
	{p:"externalGraphic",d:"/map/marker-blue.png"},
	{p:"fontSize",d:"16px"},
	{p:"fontWeight",d:"normal"},
	{p:"fontFamily",d:"'Open Sans', Helvetica Neue, Arial, Helvetica, sans-serif"},
	{p:"imageOpacity",d:1},
    ];
    
    displayDefineMembers(this, myProps, {
	commands: [],
        myLayer: [],
	glyphs:{},
	selected:{},
	getMap: function() {
	    return this.map;
	},
	handleEvent:function(event,lonlat) {
	    return;
	},
	setCommand:function(command) {
	    this.clearCommands();
	    this.command = command;
	    let glyph = this.glyphMap[command];
	    this.commands.forEach(cmd=>{
		cmd.deactivate();
	    });
	    if(!command) return;
	    this.jq("new_" + command).addClass("ramadda-display-editablemap-command-active");
	    this.commands.every(cmd=>{
		if(cmd.name != command) {
		    return true;
		}
		if(glyph) {
		    let styleMap = new OpenLayers.StyleMap({"default":{}});
		    let tmpStyle = {};
		    $.extend(tmpStyle,glyph.style);
		    if(glyph.isImage()) {
			let url = prompt("Image URL:",this.lastImageUrl);
			if(!url) return;
			this.lastImageUrl = url;
			tmpStyle.imageUrl = this.lastImageUrl;
		    } else if(glyph.isLabel()) {
			let text = prompt("Label text:",this.lastText);
			if(!text) return;
			text = text.replace(/\\n/g,"\n");
			this.lastText = text;
			tmpStyle.label = text;
		    }
		    cmd.handler.style = tmpStyle;
		    cmd.handler.layerOptions.styleMap=styleMap;
		}
		let message = glyph?"New " + glyph.label:cmd.message;
		message = message||"";
		this.showCommandMessage(message);
		cmd.activate();
		return false;
	    });
	},
	clearCommands:function() {
	    this.showCommandMessage("");
	    let buttons = this.jq(ID_COMMANDS).find(".ramadda-clickable");
	    buttons.removeClass("ramadda-display-editablemap-command-active");
	    buttons.each(function() {
		$(this).attr("selected",false);
	    });
	    this.commands.forEach(cmd=>{
		cmd.deactivate();
	    });
	    this.command= null;
	    this.myLayer.redraw();
	},
	addFeatures:function(features) {
	    let layer = this.myLayer;
	    layer.addFeatures(features);
	    features.forEach(feature=>{
		feature.layer = layer;
	    });
	},
	    
	addControl:function(name,msg,control) {
	    control.name = name;
	    control.message=msg;
	    this.map.getMap().addControl(control);
	    this.commands.push(control);
	    return control;
	},

	pasteCount:0,
	doPaste: function(evt) {
	    if(!this.clipboard) return;
	    let newOnes = this.clipboard.map(feature=>{return feature.clone();});
	    for(let i=0;i<newOnes.length;i++) {
		newOnes[i].type = this.clipboard[i].type;
	    }
	    let h = this.map.getMap().getExtent().getHeight();
	    this.pasteCount++;
	    let delta = (this.pasteCount*0.05)*h;
	    newOnes.forEach(feature=>{
		feature.geometry.move(delta,-delta);
		this.checkImage(feature);
	    });
	    this.myLayer.addFeatures(newOnes);
	},
	doEdit: function(feature) {
//	    this.clearCommands();
	    if(!feature) {
		if(!this.myLayer.selectedFeatures) return;
		if(this.myLayer.selectedFeatures.length==0) return;
		feature = this.myLayer.selectedFeatures[0];
	    }
	    if(!feature) return;
	    let style = feature.style;
	    let html =HU.div([STYLE,HU.css("margin","8px")], "Feature: " + feature.type); 
	    this.myLayer.redraw(feature);
	    let apply = props=>{
		props.forEach(prop=>{
		    if(prop=="labelSelect") return;
		    let v = this.jq(prop).val();
		    if(prop=="label") {
			v = v.replace(/\\n/g,"\n");
		    }
		    feature.style[prop] = v;
		});
		if(feature.style.imageUrl) {
		    if(feature.image) feature.image.setOpacity(feature.style.imageOpacity);
		    this.checkImage(feature);
		}
		this.myLayer.redraw();
	    };
	    if(feature.image && Utils.isDefined(feature.image.opacity)) {
		feature.style.imageOpacity=feature.image.opacity;
	    }

	    this.doProperties(feature.style,apply, feature);
	},

	
	makeMenu: function(html) {
	    return  HU.div([CLASS,"wiki-editor-popup"], html);
	},
	menuItem: function(id,label) {
	    return  HU.div([ID,id,CLASS,"ramadda-clickable"],label);
	},
	doProperties: function(style, apply,feature) {
	    let html = "";
	    html +=HU.formTable();
	    let props;
	    let values = {};
	    if(style) {
		props = [];
		let isImage = style.imageUrl;
		for(a in style) {
		    if(isImage) {
			if(a!="imageUrl" && a!="imageOpacity") continue;
		    }
		    props.push(a);
		    values[a] = style[a];
		}
	    } else {
		props = ["strokeColor","strokeWidth","pointRadius","externalGraphic","fontSize","fontWeight","fontFamily"];
	    }
	    props.forEach(prop=>{
		if(prop=="labelSelect") return;
		let label = Utils.makeLabel(prop);
		let widget;
		if(prop=="externalGraphic") {
		    let icons = ["/map/marker-blue.png","/map/marker-gold.png","/map/marker-green.png","/map/marker.png","/map/POI.png","/map/arts.png","/map/bar.png","/map/binocular.png","/map/blue-dot.png","/map/blue-pushpin.png","/map/building.png","/map/burn.png","/map/bus.png","/map/cabs.png","/map/calendar.png","/map/camera.png","/map/campfire.png","/map/campground.png","/map/car.png","/map/caution.png","/map/coffeehouse.png","/map/convienancestore.png","/map/cycling.png","/map/dollar.png","/map/drinking_water.png","/map/earthquake.png","/map/electronics.png","/map/envelope.png","/map/euro.png","/map/fallingrocks.png","/map/ferry.png","/map/film.png","/map/firedept.png","/map/fishing.png","/map/flag.png","/map/gas.png","/map/glass.png","/map/globe.png","/map/golfer.png","/map/green-dot.png","/map/grn-pushpin.png","/map/grocerystore.png","/map/hammer.png","/map/helicopter.png","/map/hiker.png","/map/home.png","/map/homegardenbusiness.png","/map/horsebackriding.png","/map/hospitals.png","/map/hotsprings.png","/map/info.png","/map/info_circle.png","/map/lodging.png","/map/ltblu-pushpin.png","/map/ltblue-dot.png","/map/man.png","/map/marina.png","/map/mechanic.png","/map/motorcycling.png","/map/mountain.png","/map/movies.png","/map/orange-dot.png","/map/paper-plane.png","/map/parkinglot.png","/map/partly_cloudy.png","/map/pharmacy-us.png","/map/phone.png","/map/picnic.png","/map/pink-dot.png","/map/pink-pushpin.png","/map/plane.png","/map/police.png","/map/postoffice-us.png","/map/purple-dot.png","/map/purple-pushpin.png","/map/question.png","/map/rail.png","/map/rainy.png","/map/rangerstation.png","/map/realestate.png","/map/recycle.png","/map/red-dot.png","/map/red-pushpin.png","/map/restaurant.png","/map/sailing.png","/map/salon.png","/map/shopping-basket.png","/map/shopping.png","/map/ski.png","/map/smiley.png","/map/snack_bar.png","/map/snowflake_simple.png","/map/sportvenue.png","/map/star.png","/map/sticky-note.png","/map/subway.png","/map/sunny.png","/map/swimming.png","/map/toilets.png","/map/trail.png","/map/tram.png","/map/tree.png","/map/truck.png","/map/volcano.png","/map/water.png","/map/waterfalls.png","/map/wheel_chair_accessible.png","/map/woman.png","/map/yellow-dot.png","/map/yen.png","/map/ylw-pushpin.png"];
		    let options = "";
		    let graphic = values[prop];
		    if(graphic===null)
			graphic = this.getExternalGraphic();
		    icons.forEach(icon=>{
			let extra ="";
			let url =  ramaddaBaseUrl + icon;
			let lbl = icon.replace("/map/","");
			let attrs = ["value",icon, "data-class", "ramadda-select-icon","data-style", "", "img-src",url];
			if(icon == graphic)
			    attrs.push("selected","true");
			options+=HU.tag("option",attrs, " "+lbl);
		    });

		    var select = HU.openTag("select", [ID,this.domId("externalGraphic")]);
		    select+=options;
		    select+=HU.closeTag("select");
		    widget = select;

		} else {
		    let v = values[prop];
		    if(!Utils.isDefined(v)) {
			let propFunc = "get" + prop[0].toUpperCase()+prop.substring(1);
			v = propFunc?this[propFunc]():this.getProperty(prop);
//			console.log("V:" + v +" " + "get" + prop[0].toUpperCase()+prop.substring(1));
		    } else {
//			console.log("value:" + v);
		    }
		    let size = "20";
		    if(prop=="label") {
//			v = v.replace(/\n/g,"\\n");
			size="80"
			widget =  HU.textarea("",v,[ID,this.domId(prop),"rows",5,"cols", 60]);
		    } else {
			if(prop=="strokeWidth" || prop=="pointRadius" || prop=="fontSize" || prop=="fontWeight" || prop=="imageOpacity") size="4";
			else if(prop=="fontFamily") size="60";
			else if(prop=="imageUrl") size="80";		    
			widget =  HU.input("",v,[ID,this.domId(prop),"size",size]);
		    }
		}
		html+=HU.formEntry(label+":",widget);
	    });

	    html+="</table>";
	    html = HU.div([STYLE,HU.css("max-height","350px","overflow-y","scroll","margin-bottom","5px")], html);
	    html+="<center>";
	    html +=HU.div([ID,this.domId(ID_APPLY), CLASS,"display-button"], "Apply");
	    html += SPACE2;
	    html +=HU.div([ID,this.domId(ID_OK), CLASS,"display-button"], "Ok");
	    html += SPACE2;
	    if(feature) {
		html +=HU.div([ID,this.domId(ID_DELETE), CLASS,"display-button"], "Delete");
		html += SPACE2;
	    }
	    html +=HU.div([ID,this.domId(ID_CANCEL), CLASS,"display-button"], "Cancel");	    
	    html  = HU.div([CLASS,"wiki-editor-popup"], html);
	    html+="</center>";
	    this.map.ignoreKeyEvents = true;
	    let dialog = HU.makeDialog({content:html,anchor:this.jq(ID_MENU_FILE),title:"Map Properties",header:true,draggable:true,remove:false});

	    this.jq("externalGraphic").iconselectmenu().iconselectmenu("menuWidget").addClass("ui-menu-icons ramadda-select-icon");
	    if(apply==null)
		apply = () =>{
		let style = {};
		props.forEach(prop=>{
		    let value = this.jq(prop).val();
		    this.setProperty(prop, value);
		    if(prop == "externalGraphic") {
			value = ramaddaBaseUrl+  value;
		    }
		    style[prop] = value;
		});
		this.glyphs.forEach(g=>{
		    g.applyStyle(style);
		});
	    }
	    let close = ()=>{
		this.map.ignoreKeyEvents = false;
		dialog.hide();
		dialog.remove();
	    }
	    if(feature) {
		this.jq(ID_DELETE).button().click(()=>{
		    this.myLayer.removeFeatures([feature]);
		    close();
		});
	    }
	    this.jq(ID_OK).button().click(()=>{
		apply(props);
		close();
	    });
	    this.jq(ID_APPLY).button().click(()=>{
		apply(props);
	    });
	    this.jq(ID_CANCEL).button().click(()=>{
		close();
	    });

	},
	doSaveAs: function() {
	    let name = prompt("New entry name:");
	    if(!name) return;
	    let args = {
		name:name,
		type:"geo_editable_json",
		group:this.getProperty("parentEntryId"),
		authtoken:this.getProperty("authToken"),
		response:"json"
	    }
	    let url = ramaddaBaseUrl +"/entry/change";
            $.post(url, args, (result) => {
		if(result.entries && result.entries.length) {
		    this.setProperty("entryId",result.entries[0]);
		    this.doSave();
		    this.showMessage("Saved");
		    return
		}
		console.log(result);
		if(result.error) {
		    this.showMessage(result.error);
		} else {
		    this.showMessage(result.message);
		}
	    }).fail(function(jqxhr, textStatus, error) {
		console.log("fail:" + result);
		this.showMessage("failed to save map:" + textStatus +" " + error);
	    });
	},
	doSave: function() {
	    if(this.getProperty("thisEntryType")!="geo_editable_json") {
		this.showMessage("Entry is not the correct type");
		return;
	    }
	    let json = this.makeJson();
//	    console.log(json);
	    let url = ramaddaBaseUrl +"/entry/setfile"; 
            var args = {
                entryid: this.getProperty("entryId"),
		"file": json,
            };
            $.post(url, args, (result) => {
		if(result.error) {
		    this.showMessage(result.error);
		} else {
		    this.showMessage(result.message);
		}
	    }).fail(function(jqxhr, textStatus, error) {
		this.showMessage("failed to save map:" + textStatus +" " + error);
	    });
	},
	doDownload: function() {
	    let json = this.makeJson();
	    console.log(JSON.stringify(json,null,2));
	    Utils.makeDownloadFile("map.json",json);
	},
	makeJson: function() {
	    let list =[];
            this.myLayer.features.forEach(feature=>{
		if(!feature.type) return;
		let geom = feature.geometry;
		let obj = {
		    type:feature.type,
		    points:[]
		};
		if(feature.style) {
		    if(feature.image && Utils.isDefined(feature.image.opacity)) {
			feature.style.imageOpacity=feature.image.opacity;
		    }
		    obj.style = feature.style;
		}
		list.push(obj);
		let vertices  = geom.getVertices();
		obj.geometryType=geom.CLASS_NAME;
		if(feature.image) {
		    let mapBounds = feature.geometry.getBounds();
		    let b = this.map.transformProjBounds(mapBounds);
		    obj.points.push({latitude:b.top,longitude:b.left});
		    obj.points.push({latitude:b.top,longitude:b.right});
		    obj.points.push({latitude:b.bottom,longitude:b.right});
		    obj.points.push({latitude:b.bottom,longitude:b.left});
		    obj.points.push({latitude:b.top,longitude:b.left});		    		    		    		    
		} else {
		    vertices.forEach(vertex=>{
			let pt = vertex.clone().transform(this.map.sourceProjection, this.map.displayProjection);
			obj.points.push({latitude:pt.y,longitude:pt.x});
		    });
		}

	    });
	    return  JSON.stringify(list,null,2);
	},


	showFileMenu: function(button) {
	    let html ="";
	    if(!Utils.isAnonymous()) {	    
		html +=this.menuItem(this.domId(ID_SAVE),"Save");
		//html +=this.menuItem(this.domId(ID_SAVEAS),"Save As...");		
	    }
	    html+= this.menuItem(this.domId(ID_DOWNLOAD),"Download")
	    html+= this.menuItem(this.domId(ID_PROPERTIES),"Set Default Properties");
	    html+= this.menuItem(this.domId(ID_CLEAR),"Clear Commands");
//	    html+= this.menuItem(this.domId(ID_NAVIGATE),"Navigate");	    

	    html  = this.makeMenu(html);

	    this.dialog = HU.makeDialog({content:html,anchor:button});
	    let _this = this;

	    this.jq(ID_NAVIGATE).click(function() {
		HtmlUtils.hidePopupObject();
		_this.setCommand(null);
	    });
	    this.jq(ID_SAVE).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doSave();
	    });
	    this.jq(ID_SAVEAS).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doSaveAs();
	    });	    
	    this.jq(ID_DOWNLOAD).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doDownload();
	    });	    
	    this.jq(ID_PROPERTIES).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doProperties();
	    });
	    this.jq(ID_CLEAR).click(function(){
		HtmlUtils.hidePopupObject();
		_this.clearCommands();
	    });	    
	},
	showNewMenu: function(button) {
	    let html ="";
	    this.glyphs.forEach(g=>{
		html+= this.menuItem(this.domId("menunew_" + g.type),"New " + g.label);
	    });
	    html  = this.makeMenu(html);
	    this.dialog = HU.makeDialog({content:html,anchor:button});
	    let _this = this;
	    this.glyphs.forEach(g=>{
		this.jq("menunew_" + g.type).click(function(){
		    HtmlUtils.hidePopupObject();
		    _this.setCommand(g.type);
		});
	    });

	},


	showEditMenu: function(button) {
	    let html = 
		this.menuItem(this.domId(ID_CUT),"Cut") +
		this.menuItem(this.domId(ID_COPY),"Copy") +
		this.menuItem(this.domId(ID_PASTE),"Paste") +
		HU.div([CLASS,"ramadda-menu-divider"]) +						
		this.menuItem(this.domId(ID_SELECTOR),"Select") +
		HU.div([CLASS,"ramadda-menu-divider"]) +						
		this.menuItem(this.domId(ID_MOVER),"Move") +
		this.menuItem(this.domId(ID_RESHAPE),"Reshape") +
		this.menuItem(this.domId(ID_RESIZE),"Resize") +
		HU.div([CLASS,"ramadda-menu-divider"]) +						
		this.menuItem(this.domId(ID_TOFRONT),"To Front") +
		this.menuItem(this.domId(ID_TOBACK),"To Back") +		
		HU.div([CLASS,"ramadda-menu-divider"]) +		
		this.menuItem(this.domId(ID_EDIT),"Edit Properties") +
		HU.div([CLASS,"ramadda-menu-divider"]) +
		this.menuItem(this.domId(ID_DELETE_ALL),"Delete All");		
	    
	    html  = this.makeMenu(html);
	    this.dialog = HU.makeDialog({content:html,anchor:button});
	    let buttons = [ID_EDIT,ID_SELECTOR,ID_MOVER,ID_RESHAPE,ID_RESIZE];
	    let _this = this;
	    this.jq(ID_DELETE_ALL).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doDeleteAll();
	    });
	    this.jq(ID_CUT).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doCut();
	    });
	    this.jq(ID_COPY).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doCopy();
	    });	    
	    this.jq(ID_PASTE).click(function(){
		HtmlUtils.hidePopupObject();
		_this.doPaste();
	    });
	    this.jq(ID_TOFRONT).click(function(){
		HtmlUtils.hidePopupObject();
		_this.toFront(true);
	    });
	    this.jq(ID_TOBACK).click(function(){
		HtmlUtils.hidePopupObject();
		_this.toFront(false);
	    });
	    buttons.forEach(command=>{
		this.jq(command).click(function(){
		    HtmlUtils.hidePopupObject();
		    if(ID_SELECTOR==command) {
			_this.myLayer.selectedFeatures  = [];
		    }
		    _this.setCommand(command);
		});
	    });
	},
	
	setClipboard:function(features) {
	    if(features)
		this.clipboard = features.map(feature=>{return feature;});
	    else
		this.clipboard=null;
	    this.pasteCount=0;
	},
	removeImages: function(features) {
	    if(!features) return;
	    features.forEach(feature=>{
		if(feature.image) {
		    this.map.removeLayer(feature.image);
		    feature.image = null;
		}
	    });
	},
	clearBounds:function(geom) {
	    if(geom.clearBounds) geom.clearBounds();
	    if(geom.components) {
		geom.components.forEach(g=>{
		    this.clearBounds(g);
		});
	    }
	},
	checkImage:function(feature) {
	    if(!feature.style || !feature.style.imageUrl) return;
	    if(feature.image && Utils.isDefined(feature.image.opacity)) {
		feature.style.imageOpacity=feature.image.opacity;
	    }
	    this.removeImages([feature]);
	    this.clearBounds(feature.geometry);
	    let mapBounds = feature.geometry.getBounds();
	    let b = this.map.transformProjBounds(mapBounds);
	    feature.image=  this.map.addImageLayer("","","",feature.style.imageUrl,true,  b.top,b.left,b.bottom,b.right);
	    if(Utils.isDefined(feature.style.imageOpacity))
		feature.image.setOpacity(feature.style.imageOpacity);
	},
	toFront: function(toFront) {
	    if(!this.myLayer.selectedFeatures) return;
//	    this.clearCommands();
	    let selected = this.myLayer.selectedFeatures;
	    let features = this.myLayer.features;
	    selected.forEach(s=>{
		const index = features.indexOf(s);
		console.log("index:" + index);
		if (index > -1) {
		    features.splice(index, 1);
		    if(toFront)
			features.push(s);
		    else
			features.unshift(s);			
		}
	    });
	    this.myLayer.redraw();
	},

	doCut: function() {
//	    this.clearCommands();
	    if(this.myLayer.selectedFeatures) {
		this.removeImages(this.myLayer.selectedFeatures);
		let features = this.myLayer.selectedFeatures.map(feature=>{return feature;});
		this.setClipboard(features);
		this.myLayer.removeFeatures(features);
	    }
	},
	doDeleteAll: function() {
//	    this.clearCommands();
	    if(!window.confirm("Are you sure you want to delete all map features?")) return
	    this.removeImages(this.myLayer.features);
	    this.setClipboard(this.myLayer.features.map(feature=>{return feature;}));
	    this.myLayer.removeFeatures(this.myLayer.features);
	},
	doCopy: function() {
//	    this.clearCommands();
	    if(!this.myLayer.selectedFeatures) return;
	    this.setClipboard(this.myLayer.selectedFeatures.map(feature=>{return feature;}));
	},
	addGlyph: function(glyph) {
	    this.glyphs[glyph.getId()]= glyph;
	},
	loadAnnotationJson: function(mapJson,map,layer, glyphMap) {
//	    console.log(JSON.stringify(mapJson,null,2));
	    mapJson.forEach(mapGlyph=>{
		if(!mapGlyph.points || mapGlyph.points.length==0) {
		    console.log("No points defined:" + JSON.stringify(mapGlyph));
		    return;
		}
		let glyph = glyphMap?glyphMap[mapGlyph.type]:null;
		let style = mapGlyph.style||(glyph?glyph.style:{});
		if(style.label) {
		    style.pointRadius=0
		}
		let feature;
		if(mapGlyph.points.length>1) {
		    let points = [];
		    mapGlyph.points.forEach(pt=>{
			points.push(new OpenLayers.Geometry.Point(pt.longitude,pt.latitude));
		    });
		    if(mapGlyph.geometryType=="OpenLayers.Geometry.Polygon") {
			map.transformPoints(points);
			let linearRing = new OpenLayers.Geometry.LinearRing(points);
			let geom = new OpenLayers.Geometry.Polygon(linearRing);
			feature = new OpenLayers.Feature.Vector(geom,null,style);
		    } else {
			feature = map.createPolygon("","",points,style);
		    }
		} else {
		    let point =  MapUtils.createLonLat(mapGlyph.points[0].longitude, mapGlyph.points[0].latitude);
		    feature = map.createPoint("",point,style);
		}
		feature.type=mapGlyph.type;
		feature.style = style;
		this.checkImage(feature);
		layer.addFeatures([feature]);
	    });
	},
	loadMap: function(entryId) {
	    //Pass in true=skipParent
	    let url = this.getProperty("fileUrl",null,false,true);
	    if(!url && entryId)
		url = ramaddaBaseUrl+"/entry/get?entryid=" + entryId;
	    if(!url) return;
	    let _this = this;
            $.ajax({
                url: url,
                dataType: 'text',
                success: (data) => {
		    if(data=="") data="[]";
		    try {
			_this.loadAnnotationJson(JSON.parse(data),_this.map,_this.myLayer,_this.glyphMap);
			if(!_this.getProperty("embedded") && _this.myLayer.features.length>0 && !_this.getProperty("zoomLevel")) {
			    let bounds = new OpenLayers.Bounds();
			    _this.myLayer.features.forEach(feature=>{
				bounds.extend(feature.geometry.getBounds());
			    });
			    _this.map.zoomToExtent(bounds);
			}
		    } catch(err) {
			this.showMessage("Failed to load map:" + err);
			console.log("error:" + err);
			console.log(err.stack);
			console.log("map json:" + data);
		    }
                }
            }).fail(err=>{
		this.showMessage("Failed to load map:" + err);
		console.log("error:" + JSON.stringify(err));
	    });



	},
	doMakeMapGlyphs:function() {
	    return [
		new GlyphType(this,"marker","Marker",
			     {strokeWidth:0, 
			      fillColor:"transparent",
			      externalGraphic: ramaddaBaseUrl+this.getExternalGraphic(),
			      pointRadius:this.getPointRadius(10)},
			     OpenLayers.Handler.Point),
		new GlyphType(this,"point","Point",
			     {strokeWidth:this.getProperty("strokeWidth",2), 
			      fillColor:"transparent",
			      strokeColor:this.getStrokeColor(),
			      pointRadius:this.getPointRadius(4)},
			     OpenLayers.Handler.Point),
		new GlyphType(this,"label","Label",
			     {label : "label",
			      fontColor: this.getProperty("labelFontColor","#000"),
			      fontSize: this.getFontSize(),
			      fontFamily: this.getFontFamily(),
			      fontWeight: this.getFontWeight(),
			      labelAlign: this.getProperty("labelAlign","lb"),
			      labelXOffset: this.getProperty("labelXOffset","0"),
			      labelYOffset: this.getProperty("labelYOffset","0"),
			      labelOutlineColor:this.getProperty("labelOutlineColor","#fff"),
			      labelOutlineWidth: this.getProperty("labelOutlineWidth","0"),
			      labelSelect:true,
			     }, OpenLayers.Handler.Point),
		new GlyphType(this,"box", "Box",
			      {strokeColor:this.getStrokeColor(),
			      strokeWidth:this.getStrokeWidth(),
			      fillColor:"transparent",
			      fillOpacity:1.0},
			     OpenLayers.Handler.RegularPolygon,
			     {snapAngle:90,sides:4,irregular:true}
			    ),
		new GlyphType(this,"circle", "Circle",
			     {strokeColor:this.getStrokeColor(),
			      strokeWidth:this.getStrokeWidth(),
			      fillColor:"transparent",
			      fillOpacity:1.0},
			     OpenLayers.Handler.RegularPolygon,
			     {snapAngle:45,sides:40}
			    ),
		new GlyphType(this,"triangle", "Triangle",
			     {strokeColor:this.getStrokeColor(),
			      strokeWidth:this.getStrokeWidth(),
			      fillColor:"transparent",
			      fillOpacity:1.0},
			     OpenLayers.Handler.RegularPolygon,
			     {snapAngle:10,sides:3}
			    ),				
		new GlyphType(this,"hexagon", "Hexagon",
			     {strokeColor:this.getStrokeColor(),
			      strokeWidth:this.getStrokeWidth(),
			      fillColor:"transparent",
			      fillOpacity:1.0},
			     OpenLayers.Handler.RegularPolygon,
			     {snapAngle:90,sides:6}
			    ),		
		new GlyphType(this,"line", "Line",
			     {strokeColor:this.getStrokeColor(),
			      strokeWidth:this.getStrokeWidth()},
			     OpenLayers.Handler.Path,{maxVertices:2}),		

		new GlyphType(this,"polyline", "Polyline",
			     {strokeColor:this.getStrokeColor(),
			      strokeWidth:this.getStrokeWidth()},
			     OpenLayers.Handler.Path),
		new GlyphType(this,"freehand","Freehand",
			     {strokeColor:this.getStrokeColor(),
			      strokeWidth:this.getStrokeWidth()},
			     OpenLayers.Handler.Path,
			     {freehand:true}),
		new GlyphType(this,"image", "Image",
			     {strokeColor:"blue",
			      strokeWidth:1,
			      imageOpacity:this.getImageOpacity(1),
			      fillColor:"transparent"},
			     OpenLayers.Handler.ImageHandler,
			     {snapAngle:90,sides:4,irregular:true,isImage:true}
			    ),
		
	    ];
	},
	showCommandMessage:function(msg)  {
	    this.jq(ID_MESSAGE).html(msg);
	    this.jq(ID_MESSAGE).show();
	},
	showMessage:function(msg)  {
	    this.setMessage(msg)
	    if(this.messageErase) clearTimeout(this.messageErase);
	    this.messageErase = setTimeout(()=>{
//		this.jq(ID_MESSAGE).hide();
		this.setMessage("");
	    },3000);
	},
        initDisplay: function(embedded) {
	    if(!embedded) {
		SUPER.initDisplay.call(this)
	    }
	    let _this = this;
	    this.myLayer = this.map.createFeatureLayer("Annotation Features",false,null,{rendererOptions: {zIndexing: true}});
	    if(this.getProperty("layerIndex")) {
		this.myLayer.ramaddaLayerIndex = +this.getProperty("layerIndex");
	    }
	    this.icon = "/icons/map/marker-blue.png";
	    this.glyphs = this.doMakeMapGlyphs();
	    this.glyphMap = {};
	    this.glyphs.forEach(g=>{
		this.glyphMap[g.type]  = g;
	    });
	    if(embedded) {
		return;
	    }

	    this.map.featureClickHandler = e=>{
		if(this.command!=null) return;
	    };

	    let control;
//	    if(!this.getDisplayOnly() || !Utils.isAnonymous()) {
	    if(!Utils.isAnonymous()) {
//		this.jq(ID_LEFT).html(HU.div([ID,this.domId(ID_COMMANDS),CLASS,"ramadda-display-editablemap-commands"]));
		var keyboardControl = new OpenLayers.Control();
		control = new OpenLayers.Control();
		var callbacks = { keydown: function(evt) {
                    if(!evt.metaKey) return;
//		    console.log(evt.keyCode);
		    switch(evt.keyCode) {
		    case 88: // x
			_this.doCut();
			return;
		    case 86: // v
			_this.doPaste(evt);
			return;
		    case 67: // c
			_this.doCopy();
			return;
		    case 69: // e
			_this.doEdit();
			return;		    		    

		    }
		}};
		var options = {};
		var handler = new OpenLayers.Handler.Keyboard(control, callbacks, options);
		handler.activate();
		this.map.getMap().addControl(keyboardControl);
		this.addControl(ID_SELECTOR,"Click-drag to select",new OpenLayers.Control.SelectFeature(this.myLayer, {
		    highlight: function(feature) {
			let tmp = {};
			$.extend(tmp,feature.style);
			tmp.strokeColor = "#000";
			if(tmp.pointRadius) tmp.pointRadius*=1.5;
			if(tmp.strokeWidth) tmp.strokeWidth*=2;
			//fontSize is, eg, 14px
			if(tmp.fontSize) { 
			    let match=String(tmp.fontSize).match(/([0-9\.]+)(.*)/);
			    if(match) {
				let num = 1.5*match[1];
				tmp.fontSize=num+match[2];
			    }
			    tmp.fontWeight="bold";
			}
//			console.log(JSON.stringify(tmp));
			this.selectStyle = tmp;
			OpenLayers.Control.SelectFeature.prototype.highlight.apply(this,arguments);
		    },
		    selectStyle: {
			pointRadius:this.getPointRadius(),
			strokeWidth:2,
			fillOpacity: 0.5,
			fillColor: "blue",
			cursor: "pointer"
		    },
		    clickout: true,
		    toggle: true,
		    multiple: true, 
		    hover: false,
		    toggleKey: "ctrlKey", // ctrl key removes from selection
		    multipleKey: "shiftKey", // shift key adds to selection
		    box: true
		}));

		this.addControl(ID_EDIT,"Click to edit properties",new OpenLayers.Control.SelectFeature(this.myLayer, {
		    onSelect: function(feature) {
			_this.doEdit(feature);
		    },
		    clickout: true,
		    toggle: true,
		    multiple: false, 
		    hover: false,
		    toggleKey: "ctrlKey", // ctrl key removes from selection
		    multipleKey: "shiftKey", // shift key adds to selection
		    box: false
		}));



		let imageChecker = feature=>{
		    if(feature.image) {
			_this.checkImage(feature);
		    }
		};
		let MyMover =  OpenLayers.Class(OpenLayers.Control.ModifyFeature, {
		    dragVertex: function(vertex, pixel) {
			if(!this.feature.image) {
			    OpenLayers.Control.ModifyFeature.prototype.dragVertex.apply(this, arguments);
			    return;
			}
			let v  = this.feature.geometry.getVertices();
			let p  = vertex.geometry.getVertices()[0];
			let index = -1;
			v.every((v,idx)=>{
			    if(v.x==p.x && v.y == p.y) {
				index = idx;
				return false;
			    }
			    return true
			});
			var pos = this.map.getLonLatFromViewPortPx(pixel);
			var geom = vertex.geometry;
			geom.move(pos.lon - geom.x, pos.lat - geom.y);
			p  = vertex.geometry.getVertices()[0];
			if(index==0) {
			    //nw
			    v[3].x = p.x;
			    v[1].y = p.y;			    
			} else 	if(index==1) {
			    //ne
			    v[2].x = p.x;
			    v[0].y = p.y;
			} else 	if(index==2) {
			    //se
			    v[1].x = p.x;
			    v[3].y = p.y;			    
			} else 	if(index==3) {
			    //sw
			    v[0].x = p.x;
			    v[2].y = p.y;
			}
			this.feature.geometry.clearBounds();
			this.layer.drawFeature(this.feature, this.standalone ? undefined :
					       'select');
			this.layer.drawFeature(vertex);
			imageChecker(this.feature);
		    }
		});
		let mover =  this.addControl(ID_MOVER,"Click drag to move",new OpenLayers.Control.DragFeature(this.myLayer,{
		    onDrag: function(feature, pixel) {
			imageChecker(feature);
		    }
		}));
		let resizer = new MyMover(this.myLayer,{
		    onDrag: function(feature, pixel) {imageChecker(feature);},
		    mode:OpenLayers.Control.ModifyFeature.RESIZE|OpenLayers.Control.ModifyFeature.DRAG});
		let reshaper = new MyMover(this.myLayer, {
		    onDrag: function(feature, pixel) {imageChecker(feature);},
		    createVertices:false,
		    mode:OpenLayers.Control.ModifyFeature.RESHAPE});
		this.addControl(ID_RESIZE,"Click to resize",resizer);
		this.addControl(ID_RESHAPE,"Click to reshape",reshaper);

		let menuBar=  HU.div([ID,this.domId(ID_MENU_FILE),CLASS,"ramadda-menubar-button"],"File")+
		    HU.div([ID,this.domId(ID_MENU_EDIT),CLASS,"ramadda-menubar-button"],"Edit") +
		    HU.div([ID,this.domId(ID_MENU_NEW),CLASS,"ramadda-menubar-button"],"New");		    
	    	menuBar = HU.div([CLASS,"ramadda-menubar"], menuBar);
		let message = HU.span([ID,this.domId(ID_MESSAGE),STYLE,HU.css("margin-left","10px")],"");
		menuBar+=message;
		let mapHeader = HU.div([STYLE,HU.css("margin-left","20px","display","inline-block"), ID,this.domId(ID_MAP)+"_header"]);
		menuBar= HU.table(['width','100%'],HU.tr(["valign","bottom"],HU.td(['width','50%'],menuBar) +
							 HU.td(['width','50%'],mapHeader)));
		this.jq(ID_TOP_LEFT).append(menuBar);

		this.jq(ID_MENU_NEW).click(function() {
		    _this.showNewMenu($(this));
		});
		this.jq(ID_MENU_FILE).click(function() {
		    _this.showFileMenu($(this));
		});
		this.jq(ID_MENU_EDIT).click(function() {
		    _this.showEditMenu($(this));
		});

	    } else {
		let menuBar=HU.div([STYLE,HU.css("display","inline-block"), ID,this.domId(ID_MAP)+"_header"]);
		this.jq(ID_TOP_LEFT).append(HU.center(menuBar));
	    }

	    let cmds = "";
	    this.glyphs.forEach(g=>{
		this.glyphMap[g.type]  = g;
		g.createDrawer();
	    });

	    this.jq(ID_COMMANDS).html(cmds);
	    this.defaultStyle = {
	    };
	    /**** Don't do the legend based buttons for now
	    this.glyphs.forEach(g=>{
		this.glyphMap[g.type]  = g;
		g.createDrawer();
		this.jq(ID_COMMANDS).append(HU.div([ID,this.domId("new_" + g.type),CLASS,"ramadda-clickable ramadda-display-editablemap-command"],"New " + g.label));
		this.jq("new_" + g.type).button().click(function(){
		    if($(this).hasClass("ramadda-display-editablemap-command-active")) {
			_this.setCommand(null);
		    } else {
			_this.setCommand(g.type);
		    }
		});
	    });
	    */


	    if(this.getProperty("thisEntryType")=="geo_editable_json") {
		this.loadMap();
		/* not now
		//Do it in a bit so the layer gets its bounds set
		setTimeout(()=>{
		    this.map.zoomToLayer(this.myLayer);		    
		},1000);
*/
	    }
        },
    });
}


var MapObject = function(display, glyphType,feature) {
    this.id = HU.getUniqueId("");
    feature.objectId = this.id;
    this.display = display;
    this.feature = feature;
    this.display.addGlyph(this);
}


MapObject.prototype = {
    getId:function() {
	return this.id;
    }
}

var GlyphType = function(display,type,label,style,handler,options) {
    this.display = display;
    this.label = label;
    this.type = type;
    this.style = style;
    this.handler = handler;
    this.options = options || {};
    this.options.display = display;
    this.options.mapGlyph = this;
    $.extend(this,{
	isLabel:  function() {
	    return this.style.label!=null;
	},
	isImage:  function() {
	    return this.options.isImage;
	},	
	isIcon:  function() {
	    return this.style.externalGraphic!=null;
	},	
	applyStyle: function(style) {
	    for(a in style) {
		if(this.style[a]) this.style[a] = style[a];
	    }
	},
	newFeature: function(feature) {
	    let glyph = new MapObject(this.display,this.type, feature);
	},
	createDrawer:function() {
	    let _this = this;
	    let layer = this.display.myLayer;
	    let Drawer = OpenLayers.Class(OpenLayers.Control.DrawFeature, {
		initialize: function(layer, options) {
		    let defaultStyle = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style["default"]);
		    defaultStyle={};
		    $.extend(defaultStyle, _this.style);		    
		    let styleMap = new OpenLayers.StyleMap({"default":defaultStyle});
		    options = {
			handlerOptions:{
			    style: defaultStyle,
			    layerOptions:{
				styleMap:styleMap
			    }
			}
		    };
		    $.extend(options.handlerOptions, _this.options);
		    OpenLayers.Control.DrawFeature.prototype.initialize.apply(
			this, [layer, _this.handler||OpenLayers.Handler.Point, options]
		    );
		},
		drawFeature: function(geometry) {
		    OpenLayers.Control.DrawFeature.prototype.drawFeature.apply(this, arguments);
		    let feature =this.layer.features[this.layer.features.length-1];
		    if(this.handler.theImage) {
			feature.image = this.handler.theImage;
		    }
		    feature.type = _this.type;
		    let newStyle;
		    if(this.handler.style) {
			newStyle=this.handler.style;
		    }
		    if(newStyle) {
			if(feature.style && feature.style.label)
			    newStyle.label = feature.style.label;
//			console.log(JSON.stringify(newStyle));
			let tmp = {};
			$.extend(tmp, newStyle);
			feature.style=tmp;
		    }
		    this.layer.redraw();
		    _this.newFeature(feature);
		    if(_this.isLabel()) {
			_this.display.setCommand(null);
		    }
		}
	    });
	    this.drawer = new Drawer(layer);
	    this.display.addControl(this.type,"",this.drawer);
	    return this.drawer;
	},
    });	

}
/*
  Copyright 2008-2021 Geode Systems LLC
*/

const DISPLAY_GRAPH = "graph";
const DISPLAY_TREE = "tree";
const DISPLAY_ORGCHART = "orgchart";
const DISPLAY_TIMELINE = "timeline";
const DISPLAY_HOURS = "hours";
const DISPLAY_BLANK = "blank";
const DISPLAY_PRE = "pre";
const DISPLAY_HTMLTABLE = "htmltable";
const DISPLAY_RECORDS = "records";
const DISPLAY_TSNE = "tsne";
const DISPLAY_HEATMAP = "heatmap";
const DISPLAY_CROSSTAB = "crosstab";
const DISPLAY_CORRELATION = "correlation";
const DISPLAY_RANKING = "ranking";
const DISPLAY_STATS = "stats";
const DISPLAY_COOCCURENCE = "cooccurence";
const DISPLAY_BOXTABLE = "boxtable";
const DISPLAY_DATATABLE = "datatable";
const DISPLAY_PERCENTCHANGE = "percentchange";
const DISPLAY_SPARKLINE = "sparkline";
const DISPLAY_POINTIMAGE = "pointimage";
const DISPLAY_CANVAS = "canvas";
const DISPLAY_FIELDTABLE = "fieldtable";
const DISPLAY_DATEGRID = "dategrid";

addGlobalDisplayType({
    type: DISPLAY_RANKING,
    label: "Ranking",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Show fields ordered by values","ranking.png")                            
});
addGlobalDisplayType({
    type: DISPLAY_CORRELATION,
    label: "Correlation",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip(null,"correlation.png")                            
});
addGlobalDisplayType({
    type: DISPLAY_CROSSTAB,
    label: "Crosstab",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Cross Tabulation","crosstab.png")                                
});

addGlobalDisplayType({
    type: DISPLAY_STATS,
    label: "Stats Table",
    requiresData: false,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Statistical Summary","stats.png"),
});
addGlobalDisplayType({
    type: DISPLAY_RECORDS,
    label: "Records",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Displays records as text","records.png")
});
addGlobalDisplayType({
    type: DISPLAY_TSNE,
    label: "TSNE",
    requiresData: true,
    forUser: false,
    category: CATEGORY_MISC
});
addGlobalDisplayType({
    type: DISPLAY_HEATMAP,
    label: "Heatmap",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Table showing colored fields","heatmap.png"),    
});
addGlobalDisplayType({
    type: DISPLAY_GRAPH,
    label: "Graph",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Display a force-directed graph","graph.png")
});

addGlobalDisplayType({
    type: DISPLAY_PERCENTCHANGE,
    label: "Percent Change",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Percent Change","percentchange.png","Show percent change over a given time in a text template")    
});

addGlobalDisplayType({
    type: DISPLAY_SPARKLINE,
    label: "Sparkline",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Embed little sparkline plots in text","sparkline.png"),    
});

addGlobalDisplayType({
    type: DISPLAY_CANVAS,
    label: "Canvas",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Draw records into a canvas","canvas.png"),        
});

addGlobalDisplayType({
    type: DISPLAY_POINTIMAGE,
    label: "Point Image",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Embed 2D images into text","pointimage.png"),            
});
addGlobalDisplayType({
    type: DISPLAY_FIELDTABLE,
    label: "Field Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip(null,"fieldtable.png"),
});
addGlobalDisplayType({
    type: DISPLAY_TREE,
    forUser: true,
    label: "Tree",
    requiresData: false,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"tree.png")                                    
});

addGlobalDisplayType({
    type: DISPLAY_ORGCHART,
    label: "Org Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"orgchart.png")                                
});

addGlobalDisplayType({
    type: DISPLAY_TIMELINE,
    label: "Timeline",
    requiresData: true,
    forUser: true,
    category:  CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Timeline showing text and images","timeline.png")
});
addGlobalDisplayType({
    type: DISPLAY_HOURS,
    label: "Hours",
    requiresData: true,
    forUser: true,
    category:  CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Hourly timeline","timeline.png","Show data by the day and hour")    
});
addGlobalDisplayType({
    type: DISPLAY_BLANK,
    label: "Blank",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows no data",null,"Useful for just showing filters, etc")                                                
});
addGlobalDisplayType({
    type: DISPLAY_PRE,
    label: "Preformat",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Shows records in an HTML PRE tag",null,"Useful for looking at the data")                                                
});
addGlobalDisplayType({
    type: DISPLAY_HTMLTABLE,
    label: "HTML Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Shows records in an HTML table",null,"Useful for looking at the data")                                                    
});
addGlobalDisplayType({
    type: DISPLAY_COOCCURENCE,
    label: "Cooccurence",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Cooccurence Table","cooccurrence.png","Tabular plot showing number of records that share values from two fields"),    

});
addGlobalDisplayType({
    type: DISPLAY_BOXTABLE,
    label: "Box Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Box Table","boxtable.png","Shows number of records that share the same category field value"),    
});
addGlobalDisplayType({
    type: DISPLAY_DATATABLE,
    label: "Data Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Data Table",["datatable1.png","datatable2.png"],"Selectable record grouping. Can be colored or show pie charts"),        
});
addGlobalDisplayType({
    type: DISPLAY_DATEGRID,
    label: "Date Grid",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Date Grid",["dategrid.png"],"Show records grouped by category and date"),        
});





function RamaddaGraphDisplay(displayManager, id, properties) {
    const ID_GRAPH = "graph";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_GRAPH, properties);
    if(!window["ForceGraph"]) {
	Utils.importJS("https://unpkg.com/force-graph");
    }
    let myProps = [
	{label:'Graph'},
	 {p:'sourceField',ex:''},
	 {p:'targetField',ex:''},
	 {p:'nodeBackground',ex:'#ccc'},
	 {p:'drawCircle',ex:'true'},
	 {p:'nodeWidth',ex:'10'},
	 {p:'linkColor',ex:'red'},
	 {p:'linkWidth',ex:'3'},
	 {p:'linkDash',ex:'5'},
	 {p:'linkWidth',ex:'3'},
	 {p:'arrowLength',ex:'6'},
	 {p:'arrowColor',ex:'green'},
	 {p:'directionalParticles',ex:'2'}
    ]


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	callbackWaiting:false,
        updateUI: function() {
            if(!window["ForceGraph"]) {
		if(!this.callbackWaiting) {
		    this.callbackWaiting = true;
                    setTimeout(()=>{
			this.callbackWaiting = false;
			this.updateUI()
		    },100);
		}
                return;
            }
	    let graphData = null;
	    let html = HU.div([ID, this.domId(ID_GRAPH)]);
	    this.setContents(html);
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let seenNodes = {};
	    let nodes = [];
	    let links = [];
	    let valueFields   = this.getFieldsByIds(null, this.getProperty("valueFields","",true));
	    let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    if(!labelField) {
		let strings = this.getFieldsByType(null, "string");
		if(strings.length>0) labelField = strings[0];
	    }
	    let sourceField = this.getFieldById(null, this.getProperty("sourceField","source"));
	    let targetField = this.getFieldById(null, this.getProperty("targetField","target"));
	    let textTemplate = this.getProperty("tooltip","${default}");
	    if(valueFields.length>0) {
		let seenValue = {};
		records.map((r,index)=>{
		    let label  = labelField?r.getValue(labelField.getIndex()):index;
		    let tooltip =  this.getRecordHtml(r, null, textTemplate);
		    nodes.push({id:index,label:label,tooltip:tooltip});
		    valueFields.map(f=>{
			let value = r.getValue(f.getIndex());
			if(!seenValue[value+"_" + f.getId()]) {
			    seenValue[value+"_" + f.getId()] = true;
			    nodes.push({id:value, isValue:true});
			}
			links.push({source:value, target: index});
		    });
		});
	    } else if(sourceField!=null && targetField!=null) {
		records.map(r=>{
		    let source = r.getValue(sourceField.getIndex());
		    let target = r.getValue(targetField.getIndex());
		    if(!seenNodes[source]) {
			seenNodes[source] = true;
			nodes.push({id:source,tooltip:source});
		    }
		    if(!seenNodes[target]) {
			seenNodes[target] = true;
			nodes.push({id:target,tooltip:target});
		    }
		    links.push({source:source, target: target});
		});
	    } else {
		this.setDisplayMessage("No source/target fields specified");
		return;
	    }
	    graphData = {
		nodes: nodes,
		links: links
	    };

	    /*
	      links = [];
	      gGraphData.edges.forEach(e=>{
	      links.push({source:e.from,target:e.to});
	      });

	      graphData = {
	      nodes:gGraphData.nodes,
	      links: links
	      }
	    */
	    const nodeBackground = this.getProperty("nodeBackground",'rgba(255, 255, 255, 0.8)');
	    const linkColor = this.getProperty("linkColor","#ccc");
	    const drawCircle = this.getProperty("drawCircle",false);
	    const linkWidth = +this.getProperty("linkWidth",1);
	    const linkDash = +this.getProperty("linkDash",-1);
	    const drawText = this.getProperty("drawText",true);
	    const nodeWidth = this.getProperty("nodeWidth",10);
	    const elem = document.getElementById(this.domId(ID_GRAPH));
	    const graph = ForceGraph()(elem).graphData(graphData);
	    graph.nodeCanvasObject((node, ctx, globalScale) => {
		let label = node.label;
		if(!label) label = node.id;
		const fontSize = 12/globalScale;
		ctx.font = fontSize +"px Sans-Serif";
		let textWidth = ctx.measureText(label).width;
		if(!drawText)
		    textWidth=nodeWidth;
		if(node.isValue) {
		    let bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2+2); 
		    ctx.lineWidth = 1;
		    ctx.strokeStyle = "#000";
		    ctx.fillStyle = "#fff";
		    ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
		    ctx.strokeRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
		} else  {
		    let dim = [textWidth, fontSize].map(n => n + fontSize * 0.2+2); 
		    ctx.fillStyle = nodeBackground;
		    ctx.strokeStyle = "#000";
		    if(drawCircle) {
			ctx.beginPath();
			ctx.arc(node.x, node.y, dim[0]/2, 0, 2 * Math.PI);
			ctx.fill(); 
		    } else {
			ctx.fillRect(node.x - dim[0] / 2, node.y - dim[1] / 2, ...dim);
			ctx.strokeRect(node.x - dim[0] / 2, node.y - dim[1] / 2, ...dim);
		    }
		}
		if(drawText) {
		    ctx.textAlign = 'center';
		    ctx.textBaseline = 'middle';
		    ctx.fillStyle = "black";
		    ctx.fillText(label, node.x, node.y);
		}
	    });

	    //	    graph.linkCanvasObjectMode('replace');
	    /*
	      graph.linkCanvasObject((link, ctx) => {
	      if(linkDash>0)
	      ctx.setLineDash([linkDash, linkDash]);
	      ctx.lineWidth = linkWidth;
	      ctx.strokeStyle = linkColor;
	      ctx.moveTo(link.source.x, link.source.y);
	      ctx.lineTo(link.target.x, link.target.y);
	      (link === graphData.links[graphData.links.length - 1]) && ctx.stroke();
	      });*/
	    //	    graph.linkAutoColorBy(d => gData.nodes[d.source].group);
	    if(this.getWidth())
		graph.width(this.getWidth());
	    if(this.getHeight())
		graph.height(this.getHeight());
	    graph.nodeLabel(node => node.tooltip?node.tooltip:null)
	    graph.linkWidth(+this.getProperty("linkWidth",4));
	    graph.linkColor(this.getProperty("linkColor","#000"));
	    if(this.getProperty("arrowColor")) {
		graph.linkDirectionalArrowColor(this.getProperty("arrowColor"));
	    }
	    if(this.getProperty("arrowLength")) {
		graph.linkDirectionalArrowLength(+this.getProperty("arrowLength"));
		graph.linkDirectionalArrowRelPos(+this.getProperty("arrowPosition",0.9));
	    }

	    if(this.getProperty("directionalParticles")) {
		graph.linkDirectionalParticles(+this.getProperty("directionalParticles"));
	    }
	}
    })
}


function RamaddaTreeDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_TREE, properties);
    let myProps = [
	{label:'Tree'},
	 {p:'maxDepth',ex:'3'},
	 {p:'showDetails',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	countToRecord: {},
        needsData: function() {
            return true;
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
	    let roots=null;
	    try {
		roots = this.makeTree(records);
	    } catch(error) {
                this.handleError("An error has occurred:" + error, error);
		return;
	    }

	    let html = "";
	    let baseId = this.domId("node");
	    let cnt=0;
	    let depth = 0;
	    let maxDepth = +this.getProperty("maxDepth",10);
	    let template = this.getProperty("recordTemplate","${default}");
	    let showDetails = this.getProperty("showDetails",true);
	    let _this =this;
	    let func = function(node) {
		cnt++;
		if(node.record) {
		    _this.countToRecord[cnt] = node.record;
		}
		depth++;
		let on = node.children.length>0 && depth<=maxDepth;
		let details = null;
		if(showDetails && node.record) {
		    details = _this.getRecordHtml(node.record,null, template);
		    if(details == "") details = null;
		}
		let image = "";
		if(node.children.length>0 || details) {
		    image = HU.image(on?icon_downdart:icon_rightdart,[ID,baseId+"_toggle_image" + cnt]) + " ";
		}
		html+=HU.div([CLASS,"display-tree-toggle",ID,baseId+"_toggle" + cnt,"toggle-state",on,"block-count",cnt], image +  node.label);
		html+=HU.open(DIV,[ID, baseId+"_block"+cnt,CLASS,"display-tree-block",STYLE,HU.css('display', (on?"block":"none"))]);
		if(details && details!="") {
		    if(node.children.length>0) {
			html+= HU.div([CLASS,"display-tree-toggle-details",ID,baseId+"_toggle_details" + cnt,"toggle-state",false,"block-count",cnt], HU.image(icon_rightdart,[ID,baseId+"_toggle_details_image" + cnt]) + " Details");
			html+=HU.div([ID, baseId+"_block_details"+cnt,CLASS,"display-tree-block",STYLE,HU.css('display','none')],details);
		    } else {
			html+=details;
		    }
		}
		
		if(node.children.length>0) {
		    node.children.map(func);
		}
		depth--;
		html+=HU.close(DIV);
	    }
	    //	    console.log("roots:" + roots.length);
	    roots.map(func);
	    this.myRecords = [];
            this.displayHtml(html);
	    this.find(".display-tree-toggle").click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		let cnt = $(this).attr("block-count");
		let block = $("#"+ baseId+"_block"+cnt);
		let img = $("#"+ baseId+"_toggle_image"+cnt);
		$(this).attr("toggle-state",state);
		if(state)  {
		    block.css("display","block");
		    img.attr("src",icon_downdart);
		} else {
		    block.css("display","none");
		    img.attr("src",icon_rightdart);
		}
		let record = _this.countToRecord[cnt];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    this.find(".display-tree-toggle-details").click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		let cnt = $(this).attr("block-count");
		let block = $("#"+ baseId+"_block_details"+cnt);
		let img = $("#"+ baseId+"_toggle_details_image"+cnt);
		$(this).attr("toggle-state",state);
		if(state)  {
		    block.css("display","block");
		    img.attr("src",icon_downdart);
		} else {
		    block.css("display","none");
		    img.attr("src",icon_rightdart);
		}
	    });
        },
    });
}



function OrgchartDisplay(displayManager, id, properties) {
    const ID_ORGCHART = "orgchart";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ORGCHART, properties);
    let myProps = [
	{label:'Orgchart'},
	{p:'labelField',ex:''},
	{p:'parentField',ex:''},
	{p:'idField',ex:''},
	{p:'treeRoot',ex:'some label'},
	{p:'treeTemplate',ex:''},
	{p:'treeNodeSize',ex:'small|medium|large'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER,myProps, {
        handleEventRecordSelection: function(source, args) {},
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    if(!waitOnGoogleCharts(this, ()=>{
		this.updateUI();
	    })) {
		return;
	    }
	    if(!ramaddaLoadGoogleChart(this,'orgchart')) return;
            this.displayHtml(HU.div([ID,this.domId(ID_ORGCHART)],""));
	    if(this.jq(ID_ORGCHART).length==0) {
		setTimeout(()=>this.updateUI(),1000);
		return;
	    }
	    let roots=null;
	    try {
		roots = this.makeTree();
	    } catch(error) {
		this.handleError("An error has occurred:" + error, error);
		return;
	    }
	    if(roots==null) return;

	    let data = new google.visualization.DataTable();
            data.addColumn('string', 'Name');
            data.addColumn('string', 'Parent');
            data.addColumn('string', 'ToolTip');
	    let rows = [];
	    let cnt=0;
	    let func = function(node) {
		cnt++;
		let value = node.label;
		if(node.display) {
		    value = {'v':node.label,f:node.display};
		}
		let row = [value, node.parent?node.parent.label:"",node.tooltip||""];
		rows.push(row);
		if(node.children.length>0) {
		    node.children.map(func);
		}
		if(node.record) {
		    //		    _this.countToRecord[cnt] = node.record;
		}
	    }
	    roots.map(func);
            data.addRows(rows);
            let chart = new google.visualization.OrgChart(document.getElementById(this.domId(ID_ORGCHART)));
            // Draw the chart, setting the allowHtml option to true for the tooltips.
            chart.draw(data, {'allowHtml':true,'allowCollapse':true,
			      'size':this.getProperty("treeNodeSize","medium")});
	}
    });
}


function RamaddaTimelineDisplay(displayManager, id, properties) {
    const ID_TIMELINE = "timeline";
    if(!properties.height) properties.height=400;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TIMELINE, properties);
    let myProps = [
	{label:'Timeline'},
	{p:'titleField',ex:''},
	{p:'imageField',ex:''},
	{p:'urlField',ex:''},
	{p:'textTemplate',ex:''},
	{p:'startDateField',ex:''},
	{p:'endDateField',ex:''},
	{p:'startAtSlide',ex:'0'},
	{p:'startAtEnd',ex:'true'},
	{p:'scaleFactor',ex:'10'},
	{p:'initialZoom',ex:'10'},	
	{p:'navHeight',ex:'150'},
	{p:'backgroundColor',ex:'#ccc'},
	{p:'groupField',ex:''},
	{p:'urlField',ex:''},
	{p:'timeTo',ex:'year|day|hour|second'},
//	{p:'justTimeline',ex:"true"},
	{p:'hideBanner',ex:"true"},
    ];

    Utils.importJS(ramaddaCdn+"/lib/timeline3/timeline.js");
    let css = "https://cdn.knightlab.com/libs/timeline3/latest/css/timeline.css";
    //    css =  ramaddaCdn+"/lib/timeline3/timeline.css";
    $(HU.tag('link',['rel','stylesheet','href', css,'type','text/css'] )).appendTo("head");
   
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	loadCnt:0,
	timelineLoaded: false,
        checkLayout: function() {
	    //Update the ui when the tab this is in is activated
	    this.updateUI();
	},
	updateUI: function() {
	    if(!this.timelineLoaded) {
		try {
		    let tmp =  TL.Timeline;
		    this.timelineLoaded = true;
		} catch(err) {
		    if(this.loadCnt++<100) {
			setTimeout(()=>this.updateUI(),100);
			return;
		    }
		}
	    }
	    if(!this.timelineLoaded) {
		this.setDisplayMessage("Could not load timeline");
		return;
	    }
            let records = this.filterData();
	    if(records==null) return;
	    let timelineId = this.domId(ID_TIMELINE);
	    let html = HU.div([ID,timelineId]);
	    this.setContents(html);
	    this.timelineReady = false;
	    let opts = {
		timenav_position: this.getProperty("timelinePosition","top"),
//		debug:true,
		start_at_end: this.getPropertyStartAtEnd(false),
		start_at_slide: this.getPropertyStartAtSlide(0),
		timenav_height: this.getPropertyNavHeight(200),
		height:100,
		menubar_height:100,
		gotoCallback: (slide)=>{
		    if(this.timelineReady) {
			let record = records[slide];
			if(record) {
			    this.propagateEventRecordSelection({record: record});
			}
		    }
		}
            };
	    if(this.getPropertyBackgroundColor())
		opts.default_bg_color = this.getPropertyBackgroundColor();
	    if(this.getPropertyScaleFactor(0))
		opts.scale_factor = this.getPropertyScaleFactor();
	    if(this.getPropertyInitialZoom(0))
		opts.scale_factor = this.getPropertyInitialZoom();

	    let json = {};
	    let events = [];
	    json.events = events;
	    let titleField = this.getFieldById(null,this.getPropertyTitleField());
	    if(titleField==null) {
		titleField = this.getFieldById(null, "title");
	    }
	    if(titleField==null) {
		titleField = this.getFieldById(null, "name");
	    }

	    let startDateField = this.getFieldById(null,this.getPropertyStartDateField());
	    if(!startDateField) startDateField = this.getFieldByType(null,"date");
	    let endDateField = this.getFieldById(null,this.getPropertyEndDateField());
	    let imageField = this.getFieldById(null,this.getPropertyImageField());
	    let groupField = this.getFieldById(null,this.getPropertyGroupField());
	    let urlField = this.getFieldById(null,this.getPropertyUrlField());
	    let textTemplate = this.getPropertyTextTemplate("${default}");
	    let timeTo = this.getPropertyTimeTo("day");
	    let showYears = this.getProperty("showYears",false);
	    this.recordToIndex = {};
	    this.idToRecord = {};
	    for(let i=0;i<records.length;i++) {
		let record = records[i]; 
		this.idToRecord[record.getId()] = record;
		this.recordToIndex[record.getId()] = i;
		let tuple = record.getData();
		let event = {
		};	
		let headline = titleField? tuple[titleField.getIndex()]:" record:" + (i+1);
		let debug = false;
		let text =  this.getRecordHtml(record, null, textTemplate,debug);
		if(urlField) {
		    let url  = record.getValue(urlField.getIndex());
		    headline = HU.href(url,headline);
		}

		event.unique_id = record.getId();
		event.text = {
		    headline: headline,
		    text:text
		};
		if(groupField) {
		    event.group = record.getValue(groupField.getIndex());
		}

		if(imageField) {
		    event.media = {
			url:record.getValue(imageField.getIndex())
		    };
		    if(urlField) {
			event.media.link = record.getValue(urlField.getIndex());
			event.media.link_target = "_timelinemedia";
		    }
		}
		let startDate =this.getDate(startDateField? tuple[startDateField.getIndex()]: record.getTime());
		if (showYears) {
		    event.start_date = {
			year: startDate.year
		    }
		} else {
		    event.start_date  = startDate;
		    if(endDateField) {
			event.end_date = tuple[endDateField.getIndex()];
		    }
		}
		//		console.log(JSON.stringify(event));
		events.push(event);
	    }
//	    console.log(JSON.stringify(json,null,2));
	    if($("#" + timelineId).length==0) {
//		console.info("No timeline div:" + timelineId);
		return;
	    }

	    this.timeline = new TL.Timeline(timelineId,json,opts);
	    if(this.getPropertyHideBanner(false)) {
		this.jq(ID_TIMELINE).find(".tl-storyslider").css("display","none");
		this.jq(ID_TIMELINE).find(".tl-menubar").css("display","none");		
	    } 
	    this.jq(ID_TIMELINE).find(".tl-text").css("padding","0px");
	    this.jq(ID_TIMELINE).find(".tl-slide-content").css("padding","0px 0px");
	    //	    this.jq(ID_TIMELINE).find(".tl-slide-content").css("width","100%");
	    this.jq(ID_TIMELINE).find(".tl-slidenav-description").css("display","none");
	    this.timelineReady = true;

	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    this.timeline.goTo(index);
	},
	getDate: function(time) {
	    let timeTo = this.getPropertyTimeTo("day");
	    let dt =  {year: time.getUTCFullYear()};
	    if(timeTo!="year") {
		dt.month = time.getUTCMonth()+1;
		if(timeTo!="month") {
		    dt.day = time.getUTCDate();
		    if(timeTo!="day") {
			dt.hour = time.getHours();
			dt.minute = time.getMinutes();
			if(timeTo!="hour") {
			    dt.second = time.getSeconds();
			}
		    }
		}
	    }
	    return dt;
	}
    });
}

function RamaddaHoursDisplay(displayManager, id, properties) {
    const ID_TIMELINE = "timeline";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HOURS, properties);
    const BOX_COLOR = "lightblue";
    const MULTI_ID = "multiid";
  
    let myProps = [
	{label:'Hours'},
	{p:'dateField',ex:''},
	{p:'boxWidth',ex:''},
	{p:'boxColor',ex:'blue'},	
	{p:'rowBackground',ex:''},
	{p:'dayLabelStyle',ex:''},
	{p:'fillHours',ex:'false'},			
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
            let records = this.filterData();
	    if(records==null) return;
	    let _this =this;
	    let html = "";
	    let dateField = this.getFieldById(null,this.getPropertyDateField());
	    let days = [];
	    let dayToHours = {};
	    let dateFormat = this.getProperty("dateFormat","mdy");
	    this.recordToIndex = {};
	    let timeZoneOffset = +this.getProperty("timeZoneOffset",0);
	    records.forEach((record,idx)=>{
		this.recordToIndex[record.getId()] = idx;
		let dttm0 =dateField? recordtuple[dateField.getIndex()]: record.getTime();
		let dttm = dttm0;
		let newHours = dttm.getUTCHours()+timeZoneOffset;
		dttm = new Date(Date.UTC(dttm.getUTCFullYear(),dttm.getUTCMonth(),dttm.getUTCDate(),newHours));
		let hour = +dttm.getUTCHours();
		let dayDate = new Date(Date.UTC(dttm.getUTCFullYear(),dttm.getUTCMonth(),dttm.getUTCDate()));
		let dayInfo = dayToHours[dayDate];

		if(!dayInfo) {
		    dayInfo = dayToHours[dayDate] = {
			dttm:dttm,
			hours:[],
			minutesCount:{},
			hourToRecords:{},
			minHour: hour,
			maxHour:hour
		    };
		    days.push(dayDate);
		}
		dayInfo.minHour = Math.min(dayInfo.minHour,hour);
		dayInfo.maxHour = Math.max(dayInfo.maxHour,hour);		
		let minutes = dttm0.getMinutes();
		let key  = hour+"_"+minutes;
		if(!dayInfo.minutesCount[key]) dayInfo.minutesCount[key] = 0;
		dayInfo.minutesCount[key]++;
		if(!dayInfo.hourToRecords[hour]) {
		    dayInfo.hours.push(hour);
		    dayInfo.hourToRecords[hour] = [];
		}
		dayInfo.hourToRecords[hour].push(record);
	    });
	    Utils.sortDates(days);
	    html = HU.open("div",[STYLE,"position:relative;"]) + HU.open("table",["width","100%"]);
	    let boxWidth = this.getPropertyBoxWidth(10);
	    let boxColor = this.getPropertyBoxColor(BOX_COLOR);
	    let extra = "";
	    days.forEach(day=>{
		let dayInfo = dayToHours[day];
		if(this.getPropertyFillHours(true)) {
		    for(let i=dayInfo.minHour;i<dayInfo.maxHour;i++) {
			if(!dayInfo.hourToRecords[i]) {
			    dayInfo.hours.push(i);
			    dayInfo.hourToRecords[i] = [];
			}
		    }
		}
		let dayLabel = Utils.formatDateWithFormat(day,dateFormat,true);
		html +=  HU.tr([STYLE,"border-bottom:1px solid #ccc;"],HU.tds([],["",HU.div([CLASS,"display-hours-label"], dayLabel),"#"]));
		let multiCount = 0;
		Utils.sortNumbers(dayInfo.hours).forEach(hour=>{
		    let row = "<tr style='border-top:1px solid #ccc;'>";
//		    if(hour!=9) return
		    let hourLabel  = HU.div([STYLE,this.getPropertyDayLabelStyle("")], Utils.formatHour(hour));
		    row += HU.td([WIDTH,"10","align","right"],hourLabel);
		    row += HU.open("td",[STYLE,HU.css('background','#efefef'),WIDTH,"100%"]);
		    row += HU.open("div",[STYLE, HU.css(HEIGHT,"100%",POSITION,"relative",WIDTH,"100%",BACKGROUND,this.getPropertyRowBackground("#eee"))]);
		    row += "&nbsp;";
		    let displayed = {};
		    let didOne= false;
		    dayInfo.hourToRecords[hour].forEach(record=>{
			let dttm =dateField? record.getValue(dateField.getIndex()): record.getTime();
			let minutes = dttm.getMinutes();
			//pad a bit on the left
			let left =  Math.round(minutes/61.0*100)+"%";
			let key = hour+"_"+minutes;
			if(dayInfo.minutesCount[key]>1) {
			    if(!displayed[minutes])  {
				let multiId = this.domId("multi"+ (multiCount++));
				displayed[minutes] = {
				    multiid:multiId,
				    contents:""};
				row+= HU.div([ID,multiId, TITLE,"Click to view multiples","dttm",dayInfo.dttm.getTime(), "hour",hour,"minute",minutes, STYLE, HU.css('top','0px','left',left),CLASS,'display-hours-box-multi'],dayInfo.minutesCount[key]);
			    }
			    displayed[minutes].contents +=
				HU.div([MULTI_ID,displayed[minutes].multiid,RECORD_ID, record.getId(), RECORD_INDEX,_this.recordToIndex[record.getId()],
					TITLE,"",STYLE,
					HU.css(WIDTH,boxWidth+"px",BACKGROUND,boxColor),
					CLASS,'display-hours-box'],"");
			} else {
			    let css = HU.css("position","absolute","top","0px",WIDTH,boxWidth+"px",'background',boxColor,'left',left);
			    row+= HU.div([RECORD_ID, record.getId(), RECORD_INDEX,_this.recordToIndex[record.getId()],
					  TITLE,"",STYLE, css,CLASS,'display-hours-box']);
			}
			didOne=true;
		    });
		    for(minute in displayed) {
			let id = dayInfo.dttm.getTime()+"_" + hour +"_"+minute;
			extra+=HU.div([ID,this.domId(id), CLASS,"display-hours-box-extra"],displayed[minute].contents);
		    }
		    row+="</div></td>";
		    row+=HU.td([],dayInfo.hourToRecords[hour].length);
		    row +="</tr>"
 		    if(didOne) html+=row;
		});
	    });
	    html+="</table>";
	    html+=extra;
	    html+="&nbsp;</div>";
	    this.setContents(html);
	    this.multis = this.find(".display-hours-box-multi");
	    this.multis.click(function() {
		let id = $(this).attr("dttm")+"_" + $(this).attr("hour") +"_"+$(this).attr("minute");
		let div = _this.jq(id);
		if($(this).attr("showing")=="true") {
		    div.hide();
		    $(this).css("border","1px solid #ccc");
		    $(this).attr("showing",false);
		    return;
		}
		$(this).css("border","1px solid " + HIGHLIGHT_COLOR);
		$(this).attr("showing",true);
		div.show();
		div.position({
                    of: $(this),
                    my: "left top",
                    at: "left bottom+2",
                    collision: "none none"
		});
	    });
	    this.boxes = this.find(".display-hours-box");
	    this.boxes.click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		_this.boxes.css("background",BOX_COLOR);
		if(state)  {
		    $(this).css("background",HIGHLIGHT_COLOR);
		}
		let record = records[+$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    this.makeTooltips(this.boxes,records,null,null,false);
	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let select = ".display-hours-box[" + RECORD_ID +"='" + args.record.getId()+"']";
	    let box = this.find(select);
	    if(box.length) {
		this.boxes.css("background",BOX_COLOR);
		this.multis.css("background","#efefef");		
		let multiId = 	box.attr(MULTI_ID);
		if(multiId) {
		    let multi = this.find("#" + multiId);
		    if(multi.length>0) {
			box = multi;
			box.css("background",HIGHLIGHT_COLOR);
		    }
		}
		
		box.css("background",HIGHLIGHT_COLOR);
		HU.scrollVisible(this.getContents(), box);
	    }
	},
    });
}





function RamaddaBlankDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width='100%';
    properties.showMenu = false;
    properties.showTitle = false;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_BLANK, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    this.setContents("");
	    if(!records) return;
	    let colorBy = this.getColorByInfo(records);
	    if(colorBy.index>=0) {
		records.map(record=>{
		    color =  colorBy.getColor(record.getData()[colorBy.index], record);
		});
		colorBy.displayColorTable();
	    }
	}});
}


function RamaddaPreDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_PRE, properties);
    let myProps = [
	{label:'Pre'},
	{p:'numRecords',ex:'100',d:1000},
	{p:'includeGeo',ex:'true',d:true},	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) {
		this.setContents("Loading data...");		
		return;
	    }
            let pointData = this.dataCollection.getList()[0];
            let fields = pointData.getRecordFields();
	    let numRecords = this.getNumRecords();
	    let includeGeo = this.getIncludeGeo();
	    let html ="Number of records:" + records.length+"<pre>";
	    fields.forEach((f,idx)=>{
		if(idx>0) html+=", ";
		html+=f.getId() +"[" + f.getType()+"]";
	    });
	    if(includeGeo) html+=", latitude, longitude";
	    html+="\n";
	    records.every((r,idx)=>{
		if(numRecords>-1 && idx>numRecords) return false;
		let d = r.getData();
		d = d.map(d=>{
		    if(d.getTime) return this.formatDate(d);
		    return d;
		});
		html+="#" + idx+": ";
		html+=d.join(", ");
		if(includeGeo) {
		    html+=", " + r.getLatitude() +"," + r.getLongitude();
		}
		html+="\n";
		return true;
	    });
	    html+="</pre>"
	    this.setContents(html);
	}});
}



function RamaddaHtmltableDisplay(displayManager, id, properties) {
    const ID_TABLE  = "table";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HTMLTABLE, properties);
    let myProps = [
	{label:'Html Table'},
	{p:'numRecords',ex:'5000',d:5000,tt:'Number of records to show'},
	{p:'scrollY',ex:'300px'},				
	{p:'includeGeo',ex:'true',d:false},
	{p:'includeDate',ex:'true',d:true},
	{p:'fancy',ex:'true',d:true},
	{p:'colorCells',ex:'field1,field2'},
	{p:'iconField'},
	{p:'linkField'},
        {p:'&lt;field&gt;.showBar',ex:'true',tt:'Show bar'},
        {p:'&lt;field&gt;.barMin',ex:'0',tt:'Min value'},
        {p:'&lt;field&gt;.barMax',ex:'100',tt:'Max value'},
	{p:'barLabelInside',ex:'false'},
        {p:'barStyle',ex:'background:red;',tt:'Bar style'},			
	{p:'tableHeaderStyle'},
	{p:'showAddRow',ex:'true'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	displayData: function() {
	    this.updateUI();
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) {
		this.setDisplayMessage("Loading data...");		
		return;
	    }
	    
	    let fancy  = this.getFancy();
            let pointData = this.getPointData();
            let fields = pointData.getRecordFields();
            let selectedFields = this.getSelectedFields();
	    let urlField = this.getFieldById(null,this.getProperty("urlField"));
	    let iconField = this.getFieldById(null,this.getIconField());

	    fields= (selectedFields && selectedFields.length>0)?selectedFields:fields;
	    let anyGroups = fields.filter(f=>{
		if(f==null) return true;
		return f.getGroup()!=null;
	    }).length>0;

	    let groupCnt={};
	    if(anyGroups) {
		let groups = [];
		let group = null;
		for(let i=0;i<fields.length;i++) {
		    let field = fields[i];
		    if(field==null) continue;
		    group = field.getGroup();
		    if(group==null) {
			groups.push(field);
			continue;
		    }
		    groups.push(field);
		    groupCnt[group]=1;
		    for(let j=i+1;j<fields.length;j++) {
			if(fields[j]==null) continue;
			if(fields[j].getGroup()==field.getGroup()) {
			    groupCnt[group]++;
			    groups.push(fields[j]);
			    fields[j]=null;
			}
		    }
		}
		fields=groups;
	    }

	    let aggByField = this.getFieldById(null,this.getProperty("aggregateBy"));
	    if(aggByField) {
//		aggByField.label = this.getProperty("aggregateName",this.getFieldLabel(aggByField));
		let csvUtil = new CsvUtil();
		let tmp = new PointData("", fields, records);
		let converted = csvUtil.process(this, tmp,"aggregate(includeRows=true, groupBy=" + aggByField.getId()+");");
		records = converted.getRecords();
		fields = converted.getRecordFields();
	    }

	    let colorByMap = {};
	    let cbs = [];
	    this.getColorCells("").split(",").forEach(c=>{
		let f = this.getFieldById(null,c);
		if(f) {
		    colorByMap[c] = new ColorByInfo(this, null, records, null,c+".colorByMap",null, c, f);
		    cbs.push(colorByMap[c]);
		}
	    });
	    
	    let numRecords = this.getNumRecords();
	    let includeGeo = this.getIncludeGeo();
	    let includeDate = this.getIncludeGeo();	    
	    let html =HU.openTag('table',[CLASS,"ramadda-table stripe", 'width','100%',ID,this.domId(ID_TABLE)]);
	    let headerAttrs = [STYLE,"white-space:nowrap;background:#efefef;padding:5px; font-weight:bold;"];
	    headerAttrs = [];
	    html+="<thead>\n";

//	    html+=HU.th(HU.div(headerAttrs,"&nbsp;"));	    
	    if(includeDate) html+=HU.th(HU.div(headerAttrs,"Date"));

	    if(anyGroups) {
		let attrs = [STYLE,HU.css("background","#fff","width","100%")];
		html+="<tr style='background:transparent;' valign=top>\n"
		let group = null;
		let seen = {};
		fields.forEach((f,idx)=>{
		    if(f.getGroup()) {
			if(group!=f.getGroup()) {
			    group = f.getGroup();
			    if(!seen[group]) {
				seen[group] =true;
				html+=HU.th([CLASS,"display-table-group-header-th", STYLE,HU.css("border-bottom","0px solid transparent", "background","transparent"), "colspan",groupCnt[group]],HU.div([CLASS,"display-table-group-header"], group))+"\n";
			    }
			}
			return;
		    }
		    html+=HU.th([STYLE,HU.css("border-bottom","0px solid transparent", "background","transparent")],HU.div(attrs,"&nbsp;"))+"\n";
		});
		html+="</tr>\n";
	    } 

	    html+="<tr  valign=top>\n"
	    let headerStyle = this.getTableHeaderStyle("")+"text-align:center;";
	    let fieldMap = {}
	    let sortFields = this.getProperty("sortFields");
	    let sortAscending = this.getSortAscending();
	    if(sortFields) {
		let tmp = {};
		sortFields.split(",").forEach(f=>{tmp[f]=true;});
		sortFields= tmp;
	    }
	    fields.forEach((f,idx)=>{
		fieldMap[f.getId()] = f;
		let sort = sortFields && sortFields[f.getId()];
		let attrs = [TITLE,"Click to sort",CLASS,"ramadda-clickable display-table-header", "field-id",f.getId(),STYLE,headerStyle];
		if(sort) {
		    attrs.push("sorted");
		    attrs.push("true");
		}
		if(fancy) {
		    let label = this.getFieldLabel(f);
		    if(sort) label = HU.getIconImage(sortAscending?"fas fa-arrow-down":"fas fa-arrow-up",null, [STYLE,HU.css('font-size','8pt !important')]) +" " + label;
		    html+=HU.th(attrs,HU.div(headerAttrs,label));
		}
		else {
		    html+=HU.th(attrs,HU.div(headerAttrs,f.getId() +"[" + f.getType()+"]"));
		}
		
	    });

	    if(includeGeo) html+=HU.th(HU.div(headerAttrs,"latitude")) + HU.th([],HU.div(headerAttrs,"longitude"));
	    html+="</tr>\n";
	    html+="</thead><tbody>\n";	    
	    this.savedState = Utils.getLocalStorage(this.getProperty("storageKey",this.type), true) || {};
	    let hadSavedState = false;
	    this.recordMap = {};
	    this.fieldMap = {};
	    fields.forEach(f=>{this.fieldMap[f.getId()] = f;})
 	    let aggId = "";
	    let aggIds = [];
	    let handleColumn=((field,record,v,tdAttrs)=>{
		if(!aggByField)
		    return HU.td(tdAttrs,v);
		if(field.getId() != aggByField.getId()) {
		    return HU.td(tdAttrs,v);
		}
		if(!record.isAggregate) {
		    let spacer = "&nbsp;&nbsp;&nbsp;&nbsp;";
		    return HU.td(tdAttrs,HU.row([["width","1%","style","padding:2px;"], spacer],[["style","padding:0px;"],v]));
		}
		let span = HU.span([ID,aggId+"_toggle","toggleopen","false", CLASS,"ramadda-clickable"],
				   HU.span([ID,aggId+"_toggleimage"],HU.getIconImage("fas fa-chevron-right"))+"&nbsp;" + v);
		return HU.td(Utils.mergeLists(tdAttrs,["nowrap","true"]),span);
	    });

	    records.every((record,recordIdx)=>{
		if(numRecords>-1 && recordIdx>numRecords) return false;
		let d = record.getData();
		d = d.map(d=>{
		    if(d.getTime) return this.formatDate(d);
		    return d;
		});
		

		//		if(recordIdx>40) return true;
		let prefix = "";
		if(record.isAggregate) {
		    aggId = HU.getUniqueId("agg_")
		    aggIds.push(aggId);
		}

		let clazz = (recordIdx%2)?"ramadda-row-odd":"ramadda-row-even";
		clazz = "display-htmltable-row";
		if(record.isAggregate)
		    html+=HU.openTag('tr',['aggregateRow',aggId,'style',HU.css("font-weight","550"), 'title','','valign','top','class',clazz, RECORD_ID,record.getId()]);
		else if (aggByField)
		    html+=HU.openTag('tr',['style','display:none', "aggregateId", aggId,'title','','valign','top','class',clazz, RECORD_ID,record.getId()]);
		else
		    html+=HU.openTag('tr',["aggregateId", aggId,'title','','valign','top','class',clazz, RECORD_ID,record.getId()]);				
//		html+="<td>#" + recordIdx": </td>";		
		if(includeDate) {
		    html+=HU.td([],this.formatDate(r.getDate()));
		}
		this.recordMap[record.rowIndex] = record;
		fields.forEach((f,idx)=>{
		    let value = d[f.getIndex()]
		    let v = String(value);
		    if(v.length>500) {
			v = HU.div([STYLE,"max-height:200px;overflow-y:auto;"],v);
		    }
		    if(f.canEdit()) {
			let value = v;
			if(this.savedState) {
			    let map  = this.savedState[f.getId()];
			    if(map) {
				let savedValue = map[record.rowIndex];
				if(Utils.isDefined(savedValue)) {
				    record.data[f.getIndex()] = savedValue;
				    value = savedValue;
				    hadSavedState = true;
				}
			    }
			}
			
			if(f.getType()=="boolean")  {
			    v = HU.checkbox("", ["fieldid",f.getId(),"inputtype","checkbox",RECORD_INDEX,record.rowIndex,CLASS,"display-editable", ID,this.domId("editable_" + f.getId())], value);
			} else if(f.isFieldEnumeration()) {
			    let enums = f.getEnumeratedValues() ||"";
			    let select = [];
			    for(a in enums)
				select.push([a,enums[a]]);
			    v =  HU.select("",["fieldid",f.getId(),RECORD_INDEX,record.rowIndex, CLASS,"display-editable",STYLE,"", ID,this.domId("editable_" +f.getId())],select,value);
			}  else {
			    v = HU.input("", value, ["fieldid",f.getId(),RECORD_INDEX,record.rowIndex,CLASS,"display-editable", ID,this.domId("editable_" + f.getId())]);
			}
		    }
		    
		    if(f.getType()=="image") {
			let url = record.getValue(f.getIndex());
			v = HU.image(url,[STYLE,HU.css("width","150px;")]);
		    }

		    if(idx==0 && iconField) {
			let icon = record.getValue(iconField.getIndex());
			v = HU.image(icon,[STYLE,HU.css("max-width","50px;")]) +"&nbsp;" +v;
		    }
		    if(urlField && idx==0) {
			let url = record.getValue(urlField.getIndex());
			if(v && Utils.stringDefined(url)) {
			    if(v) v = String(v).trim();
			    v = HU.href(url,v);
			}
		    }

		    let colorBy = colorByMap[f.getId()];
		    let color = null;
		    let foreground="#000";
		    let tdAttrs = [];
		    let showBar = false;
		    let barLabelInside = true;		    
		    let barMin = 0;
		    let barMax = 100;
		    let barStyle = "";
		    if(f.isFieldNumeric()) {
			tdAttrs = ["align","right"];
			showBar = this.getProperty(f.getId()+".showBar");
			barMin = this.getProperty(f.getId()+".barMin",barMin);
			barMax = this.getProperty(f.getId()+".barMax",barMax);
			barStyle = this.getProperty(f.getId()+".barStyle",this.getProperty("barStyle",barStyle));
			barLabelInside = this.getProperty(f.getId()+".barLabelInside",this.getProperty("barLabelInside",barLabelInside));			
		    }
		    tdAttrs.push("class");
		    tdAttrs.push("display-td");		    
		    if(colorBy) {
			let color =  colorBy.getColorFromRecord(record);
			let fg =  Utils.getForegroundColor(color);
			html += HU.td(Utils.mergeLists(tdAttrs, [STYLE,HU.css('background', color,'color',fg+" !important")]),v)
		    } else if(showBar) {
			let percent = 1-(value-barMin)/(barMax-barMin);
			percent = (percent*100)+"%";
			let contents = "";
			v = Utils.formatNumberComma(value)+"%";
			if(barLabelInside) {
			    contents = HU.div([STYLE,HU.css("padding-left","2px")],v);
			    v = "";
			}
			let bar = HU.div([CLASS,"ramadda-bar-inner", STYLE,HU.css("right",percent)+barStyle],contents);
			let width = this.getProperty("barLength","100px");
			let outer = HU.div([CLASS,"ramadda-bar-outer", STYLE,
					    (width?HU.css("width",HU.getDimension(width)):"")+
					    HU.css("min-width","100px")+(barLabelInside?HU.css("height","1.5em"):"")],bar);
			if(barLabelInside) {
			    html+=HU.td([],outer);
			} else {
			    html+=HU.td([],HU.row([["align","right"],v],outer));
			}
		    } else if(f.isFieldNumeric()) {
			html+=handleColumn(f,record,this.formatNumber(v,f.getId()), tdAttrs);
		    } else {
			html+=handleColumn(f,record,v,tdAttrs);
		    }
		    prefix="";
		});
		if(hadSavedState) {
		    this.getPointData().propagateEventDataChanged(this);
		}
		if(includeGeo) {
		    html+=HU.td([],record.getLatitude()) +HU.td([],record.getLongitude());
		}
		html+="</tr>\n";
		return true;
	    });
	    html+="</tbody>\n";
	    html+="</table>\n";
	    if(this.getShowAddRow()) {
		html+=HU.div([ID,this.domId("addrow"),CLASS,"ramadda-clickable"], HU.getIconImage("fas fa-plus"));
	    }	
	    this.setContents(html);
	    aggIds.forEach(id=>{
		$("#"+ id+"_toggle").click(function() {
		    let open = $(this).attr("toggleopen")=="true";
		    $(this).attr("toggleopen",!open);
		    let row = _this.jq(ID_TABLE).find(HU.attrSelect("aggregateRow", id));
		    if(open) {
			row.find(".display-td").css("font-weight","plain").css("border-bottom","0px");
			row.css("font-weight","plain").css("border-bottom","0px");

			_this.jq(ID_TABLE).find(HU.attrSelect("aggregateId", id)).hide();
 			$(this).find("#" + id+"_toggleimage").html(HU.getIconImage("fas fa-chevron-right"));
		    } else {
			row.find(".display-td").css("font-weight","bold").css("border-bottom","1px solid #888");
			_this.jq(ID_TABLE).find(HU.attrSelect("aggregateId", id)).show();
			$(this).find("#" + id+"_toggleimage").html(HU.getIconImage("fas fa-chevron-down"));
		    }
		});
	    });
	    let dom = this.jq(ID_COLORTABLE);
	    cbs.forEach((cb,idx)=>{
		let id = this.domId(ID_COLORTABLE+idx);
		dom.append(HU.div([ID,id]));
		cb.displayColorTable(null,true,ID_COLORTABLE+idx);
	    });

	    let headers =  this.find(".display-table-header");
	    headers.click(function() {
		let field = fieldMap[$(this).attr("field-id")];
		if($(this).attr("sorted")==="true") {
		    _this.setProperty("sortAscending",!_this.getSortAscending());
		} 
		_this.setProperty("sortFields", field.getId());
		_this.sortByFieldChanged(field.getId());
	    });


	    let _this = this;
	    let tooltipClick = this.getProperty("tooltipClick");
	    let rows = this.jq(ID_TABLE).find(".display-htmltable-row");
	    this.makeTooltips(rows,records);
	    let opts = {
                ordering: false,
		scrollY:this.getScrollY("400px")
	    };
            HU.formatTable("#" + this.domId(ID_TABLE), opts);
	    if(this.getShowAddRow()) {
		this.jq("addrow").click(()=>{
		    let records = this.getPointData().getRecords();
		    let newRow = records[records.length-1].clone();
		    records.push(newRow);
		    this.updateUI();
		    this.getPointData().propagateEventDataChanged(this);
		});
	    }
	    let handleChange = dom=>{
		let val;
		if(dom.attr('inputtype')=="checkbox") {
		    val = dom.is(':checked');
		} else {
		    val = dom.val();
		}
		
		let fieldId = dom.attr("fieldid");
		let map  = _this.savedState[fieldId] ||{};
		let recordIndex = dom.attr(RECORD_INDEX); 
		map[recordIndex] = val;
		_this.savedState[fieldId]  = map;
 		Utils.setLocalStorage(_this.getProperty("storageKey",_this.type), _this.savedState, true);
		let row = _this.recordMap[recordIndex];
		let field = _this.fieldMap[fieldId];		
		row.data[field.getIndex()] = val;
		_this.getPointData().propagateEventDataChanged(_this);
	    }
	    this.jq(ID_DISPLAY_CONTENTS).find(".display-editable").change(function() {
		handleChange($(this));
	    });
	    this.jq(ID_DISPLAY_CONTENTS).find(".display-editable").keypress(function(event) {
                if (event.which == 13) {
		    handleChange($(this));
		}
	    });

	}});
}





function RamaddaTsneDisplay(displayManager, id, properties) {
    const ID_CANVAS = "tsnecanvas";
    const ID_DETAILS = "tsnedetails";
    const ID_RUN = "tsnerun";
    const ID_RESET = "tsnereset";
    const ID_STEP = "tsnestep";
    const ID_SEARCH = "tsnesearch";
    $.extend(this, {
        colorTable: "red_white_blue",
        colorByMin: "-1",
        colorByMax: "1",
        height: "500px;"
    });

    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TSNE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        nameToIndex: {},
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        updateUI: async function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            await Utils.importJS(ramaddaCdn + "/lib/tsne.js");
            //Height is the height of the overall display including the menu bar
            let height = this.getProperty("height",400);
            if (String(height).endsWith("px")) height = String(height).replace("px", "");
            height = parseInt(height);
            //            height-=30;
            let details = HU.div([STYLE, HU.css('height', height + 'px','max-height', height + "px"), CLASS, "display-tnse-details", ID, this.domId(ID_DETAILS)], "");
            let canvas = HU.div([CLASS, "display-tnse-canvas-outer", STYLE, HU.css('height', height + 'px')], HU.div([CLASS, "display-tnse-canvas", ID, this.domId(ID_CANVAS)], ""));
            let buttons = HU.div([ID, this.domId(ID_RUN), CLASS, "ramadda-button", "what", "run"], "Stop") + SPACE +
                HU.div([ID, this.domId(ID_STEP), CLASS, "ramadda-button", "what", "step"], "Step") + SPACE +
                HU.div([ID, this.domId(ID_RESET), CLASS, "ramadda-button", "what", "reset"], "Reset") + SPACE +
                HU.input("", "", [ID, this.domId(ID_SEARCH), "placeholder", "search"]);

            buttons = HU.div([CLASS, "display-tnse-toolbar"], buttons);
            this.jq(ID_TOP_LEFT).append(buttons);
            this.setContents(HU.table([WIDTH,'100%'], HU.tr(['valign','top'], HU.td(['width','80%'], canvas) + HU.td(['width','20%'], details))));
            this.search = this.jq(ID_SEARCH);
            this.search.keyup(e => {
                let v = this.search.val().trim();
                this.canvas.find(".display-tnse-mark").removeClass("display-tnse-highlight");
                if (v == "") return;
                v = v.toLowerCase();
                for (name in this.nameToIndex) {
                    if (name.toLowerCase().startsWith(v)) {
                        this.jq("element-" + this.nameToIndex[name]).addClass("display-tnse-highlight");
                    }
                }
            });
            this.details = this.jq(ID_DETAILS);
            this.reset = this.jq(ID_RESET);
            this.step = this.jq(ID_STEP);
            this.step.button().click(() => {
                this.running = false;
                this.run.html(this.running ? "Stop" : "Run");
                this.takeStep();
            });
            this.reset.button().click(() => {
                this.start();
            });
            this.run = this.jq(ID_RUN);
            this.run.button().click(() => {
                this.running = !this.running;
                if (this.running) this.takeStep();
                this.run.html(this.running ? "Stop" : "Run");
            });
            this.canvas = this.jq(ID_CANVAS);
            this.running = true;
            this.start();
        },
        start: function() {
            this.canvas.html("");
            this.haveStepped = false;
            this.dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            if (!this.fields) {
                this.fields = this.getSelectedFields([]);
                if (this.fields.length == 0) this.fields = allFields;
                let strings = this.getFieldsByType(this.fields, "string");
                if (strings.length > 0)
                    this.textField = strings[0];
            }
            let data = [];
            for (let rowIdx = 1; rowIdx < this.dataList.length; rowIdx++) {
                let tuple = this.getDataValues(this.dataList[rowIdx]);
                let nums = [];
                for (let i = 0; i < this.fields.length; i++) {
                    if (this.fields[i].isNumeric()){
                        let v = tuple[this.fields[i].getIndex()];
                        if(isNaN(v)) v = 0;
                        nums.push(v);
                    }
                }
                data.push(nums);
            }

            let opt = {}
            opt.epsilon = 10; // epsilon is learning rate
            opt.perplexity = 30; // how many neighbors each point influences
            opt.dim = 2; // dimensionality of the embedding (2 = default)
            this.tsne = new tsnejs.tSNE(opt);
            this.tsne.initDataRaw(data);
            this.takeStep();
        },
        takeStep: function() {
            let numSteps = 10;
            for (let step = 0; step < numSteps; step++) {
                this.tsne.step();
            }

            let pts = this.tsne.getSolution();
            let minx, miny, maxx, maxy;
            for (let i = 0; i < pts.length; i++) {
                if (i == 0) {
                    maxx = minx = pts[i][0];
                    maxy = miny = pts[i][1];
                } else {
                    maxx = Math.max(maxx, pts[i][0]);
                    minx = Math.min(minx, pts[i][0]);
                    maxy = Math.max(maxy, pts[i][1]);
                    miny = Math.min(miny, pts[i][1]);
                }
            }
            let sleep = 250;
            for (let i = 0; i < pts.length; i++) {
                let x = pts[i][0];
                let y = pts[i][1];
                let px = 100 * (x - minx) / (maxx - minx);
                let py = 100 * (y - miny) / (maxy - miny);
                if (!this.haveStepped) {
                    let title = "";
                    if (this.textField) {
                        let tuple = this.getDataValues(this.dataList[i]);
                        title = tuple[this.textField.getIndex()];
                    }
                    if (title.length > 10) {
                        title.length = 10;
                    }
                    this.nameToIndex[title] = i;
                    this.canvas.append(HU.div([TITLE, title, "index", i, ID, this.domId("element-" + i), CLASS, "display-tnse-mark", STYLE, HU.css('left', px + '%', 'top',py +'%')], title));
                } else {
                    this.jq("element-" + i).animate({
                        left: px + "%",
                        top: py + "%"
                    }, sleep, "linear");
                }

            }
            let _this = this;
            if (!this.haveStepped) {
                this.canvas.find(".display-tnse-mark").click(function(e) {
                    let index = parseInt($(this).attr("index"));
                    if (index < 0 || index >= _this.dataList.length) return;
                    let tuple = _this.getDataValues(_this.dataList[index]);
                    let details = HU.open(TABLE,[CLASS,'formtable',WIDTH,'100%']);
                    for (let i = 0; i < _this.fields.length; i++) {
                        let field = _this.fields[i];
                        details += HU.tr([],HU.td(['align','right', CLASS,'formlabel'], this.getFieldLabel(field) + ':') + HU.td([],tuple[field.getIndex()]));
                    }
                    details += HU.close(TABLE);
                    _this.details.html(details);
                });
            }
            if (!this.haveStepped) {
                //                this.haveStepped = true;
                //                this.takeStep();
                //                return;
            }
            this.haveStepped = true;
            if (this.running)
                setTimeout(() => this.takeStep(), sleep);
        },
    });
}


function RamaddaHeatmapDisplay(displayManager, id, properties) {
    $.extend(this, {
        colorTable: "red_white_blue",
    });
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HEATMAP, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        "map-display": false,
        needsData: function() {
            return true;
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            let tmp = HU.formTable();
            let colorTable = this.getColorTableName();
            let ct = HU.open('select',[ID,this.domId("colortable")]);
            for (table in Utils.ColorTable) {
                if (table == colorTable)
                    ct += HU.tag('option',['selected',null], table);
                else
                    ct += HU.tag('option',[], table);
            }
            ct += HU.close('select');
            tmp += HU.formEntry("Color Table:", ct);
            tmp += HU.formEntry("Color By Range:", HU.input("", this.colorByMin, ["size", "7", ATTR_ID, this.domId("colorbymin")]) + " - " +
				HU.input("", this.colorByMax, ["size", "7", ATTR_ID, this.domId("colorbymax")]));
            tmp += HU.close(TABLE);
            menuItems.push(tmp);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function() {
                _this.colorByMin = _this.jq("colorbymin").val();
                _this.colorByMax = _this.jq("colorbymax").val();
                _this.updateUI();

            };
            let func2 = function() {
                _this.colorTable = _this.jq("colortable").val();
                _this.updateUI();

            };
            this.jq("colorbymin").blur(updateFunc);
            this.jq("colorbymax").blur(updateFunc);
            this.jq("colortable").change(func2);
        },

        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        getContentsStyle: function() {
            let height = this.getProperty("height", -1);
            if (height > 0) {
                return " height:" + height + "px; " + " max-height:" + height + "px; overflow-y: auto;";
            }
            return "";
        },
        updateUI: function(pointData) {
            let _this = this;
            if (!haveGoogleChartsLoaded()) {
                let func = function() {
                    _this.updateUI();
                }
                this.setDisplayMessage(this.getLoadingMessage());
                setTimeout(func, 1000);
                return;
            }

            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let dataList = this.getStandardData(null, {
                includeIndex: true
            });
            let header = this.getDataValues(dataList[0]);
            let showIndex = this.getProperty("showIndex", true);
            let showValue = this.getProperty("showValue", true);
            let textColor = this.getProperty("textColor", "black");

            let cellHeight = this.getProperty("cellHeight", null);
            let extraTdStyle = "";
            if (this.getProperty("showBorder")) {
                extraTdStyle = HU.css("border-bottom","1px #666 solid");
            }

            let extraCellStyle = "";
            if (cellHeight)
                extraCellStyle += HU.css("height", cellHeight + "px","max-height", cellHeight + "px","min-height", cellHeight + "px");

            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);

            if (fields.length == 0) fields = allFields;
            let html = "";
            let colors = null;
            let colorByMin = null;
            let colorByMax = null;
            if (Utils.stringDefined(this.getProperty("colorByMins"))) {
                colorByMin = [];
                let c = this.getProperty("colorByMins").split(",");
                for (let i = 0; i < c.length; i++) {
                    colorByMin.push(parseFloat(c[i]));
                }
            }
            if (Utils.stringDefined(this.getProperty("colorByMaxes"))) {
                colorByMax = [];
                let c = this.getProperty("colorByMaxes").split(",");
                for (let i = 0; i < c.length; i++) {
                    colorByMax.push(parseFloat(c[i]));
                }
            }

            if (Utils.stringDefined(this.getProperty("colorTables"))) {
                let c = this.getProperty("colorTables").split(",");
                colors = [];
                for (let i = 0; i < c.length; i++) {
                    let name = c[i];
                    if (name == "none") {
                        colors.push(null);
                        continue;
                    }
                    let ct = Utils.getColorTable(name, true);
                    //                        console.log("ct:" + name +" " +(ct!=null));
                    colors.push(ct);
                }
            } else {
                colors = [this.getColorTable(true)];
            }
            let mins = null;
            let maxs = null;
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let row = this.getDataValues(dataList[rowIdx]);
                if (mins == null) {
                    mins = [];
                    maxs = [];
                    for (let colIdx = 1; colIdx < row.length; colIdx++) {
                        mins.push(Number.MAX_VALUE);
                        maxs.push(Number.MIN_VALUE);
                    }
                }

                for (let colIdx = 0; colIdx < fields.length; colIdx++) {
                    let field = fields[colIdx];
                    //Add one to the field index to account for the main time index
                    let index = field.getIndex() + 1;
                    if (!field || !field.isFieldNumeric() || field.isFieldGeo()) continue;

                    let value = row[index];
                    if (value == Number.POSITIVE_INFINITY || isNaN(value) || !Utils.isNumber(value) || !Utils.isDefined(value) || value == null) {
                        continue;
                    }
                    mins[colIdx] = Math.min(mins[colIdx], value);
                    maxs[colIdx] = Math.max(maxs[colIdx], value);
                }
            }

            html += HU.open(TABLE, ["border", "0", CLASS, "display-heatmap"]);
            html += HU.open(TR,[VALIGN,'bottom']);
            if (showIndex) {
                html += HU.td([ALIGN,'center'], HU.div([CLASS, "display-heatmap-heading-top"], header[0]));
            }
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let field = fields[fieldIdx];
                if ((!field.isFieldNumeric() || field.isFieldGeo())) continue;
                html += HU.td([ALIGN,'center'], HU.div([CLASS, "display-heatmap-heading-top"], this.getFieldLabel(field)));
            }
            html += HU.close(TR);

            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let row = this.getDataValues(dataList[rowIdx]);
                let index = row[0];
                //check if its a date
                if (index.f) {
                    index = index.f;
                }
                let rowLabel = index;
                html += HU.open('tr',['valign','center']);
                if (showIndex) {
                    html += HU.td([CLASS, "display-heatmap-heading-side", STYLE, extraCellStyle + extraTdStyle], rowLabel);
                }
                let colCnt = 0;
                for (let colIdx = 0; colIdx < fields.length; colIdx++) {
                    let field = fields[colIdx];
                    //Add one to the field index to account for the main time index
                    let index = field.getIndex() + 1;
                    if (!field || !field.isFieldNumeric() || field.isFieldGeo()) continue;
                    let style = "";
                    let value = row[index];
                    let min = mins[colIdx];
                    let max = maxs[colIdx];
                    if (colorByMin && colCnt < colorByMin.length)
                        min = colorByMin[colCnt];
                    if (colorByMax && colCnt < colorByMax.length)
                        max = colorByMax[colCnt];


                    let ok = min != max && !(value == Number.POSITIVE_INFINITY || isNaN(value) || !Utils.isNumber(value) || !Utils.isDefined(value) || value == null);
                    let title = header[0] + ": " + rowLabel + " - " + this.getFieldLabel(field) + ": " + value;
                    if (ok && colors != null) {
                        let ct = colors[Math.min(colCnt, colors.length - 1)];
                        if (ct) {
                            let percent = (value - min) / (max - min);
                            let ctIndex = parseInt(percent * ct.length);
                            if (ctIndex >= ct.length) ctIndex = ct.length - 1;
                            else if (ctIndex < 0) ctIndex = 0;
                            style = "background-color:" + ct[ctIndex] + ";";
                        }
                    }
                    let number;
                    if (!ok) {
                        number = "-";
                    } else {
                        number = Utils.formatNumber(value)
                    }
                    if (!showValue) number = ""; 
                    html += HU.td(["valign", "center", "align", "right", STYLE, style + extraCellStyle + extraTdStyle, CLASS, "display-heatmap-cell"], HU.div([TITLE, title, STYLE, extraCellStyle + HU.css('color',textColor)], number));
                    colCnt++;
                }
                html += HU.close(TR);
            }
            html += HU.close(TABLE);
            this.setContents(html);
            this.initTooltip();

        },
    });
}


function RamaddaRankingDisplay(displayManager, id, properties) {
    const ID_TABLE = "rankingtable";
    $.extend(this, {
	height: "500px",
        sortAscending:false,
    });
    if(properties.sortAscending) this.sortAscending = "true" == properties.sortAscending;
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RANKING, properties);
    let myProps = [
	{label:'Ranking'},
	{p:'sortField',ex:''},
	{p:'nameFields',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            let records = this.records =  this.filterData();
            if (records == null) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    this.idToRecord = {};
	    records.forEach(record=>{
		this.idToRecord[record.getId()] = record;
	    });

            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);
            if (fields.length == 0) fields = allFields;
            let numericFields = this.getFieldsByType(fields, "numeric");
            let sortField = this.getFieldById(numericFields, this.getProperty("sortField","",true));
            if (numericFields.length == 0) {
                this.setContents("No fields specified");
                return;
            }
            if (!sortField) {
                sortField = numericFields[0];
            }
            if (!sortField) {
                this.setDisplayMessage("No fields specified");
                return;
            }

            let stringFields = this.getFieldsByIds(allFields, this.getProperty("nameFields","",true));
            if(stringFields.length==0) {
		let tmp = this.getFieldById(allFields, this.getProperty("nameField","",true));
		if(tmp) stringFields.push(tmp);
	    }
            if(stringFields.length==0) {
                let stringField = this.getFieldByType(allFields, "string");
		if(stringField) stringFields.push(stringField);
	    }
            let menu = HU.open("select",[CLASS,'ramadda-pulldown',ID, this.domId("sortfields")]);
            for (let i = 0; i < numericFields.length; i++) {
                let field = numericFields[i];
                let extra = "";
                if (field.getId() == sortField.getId()) extra = " selected ";
                menu += HU.tag('option',['value', field.getId(), extra,null], this.getFieldLabel(field));
            }
            menu += HU.close('select');
	    let top ="";
	    top += HU.span([ID,this.domId("sort")], HU.getIconImage(this.sortAscending?"fa-sort-up":"fa-sort-down", [STYLE,HU.css('cursor','pointer'),TITLE,"Change sort order"]));
            if (this.getProperty("showRankingMenu", true)) {
                top+= " " + HU.div([STYLE,HU.css('display','inline-block'), CLASS,"display-filterby"],menu);
            }
	    this.jq(ID_TOP_LEFT).html(top);
	    this.jq("sort").click(()=>{
		this.sortAscending= !this.sortAscending;
		if(this.sortAscending) 
		    this.jq("sort").html(HU.getIconImage("fa-sort-up", [STYLE,HU.css('cursor','pointer')]));
		else
		    this.jq("sort").html(HU.getIconImage("fa-sort-down", [STYLE,HU.css('cursor','pointer')]));
		this.updateUI();
	    });
            let html = "";
            html += HU.open(DIV, [STYLE, HU.css('max-height','100%','overflow-y','auto')]);
            html += HU.open(TABLE, [ID, this.domId(ID_TABLE)]);
            let tmp = records;
	    let includeNaN = this.getProperty("includeNaN",false);
	    if(!includeNaN) {
		let tmp2 = [];
		tmp.map(r=>{
		    let v = sortField.getValue(r);
		    if(!isNaN(v)) tmp2.push(r);
		});
		tmp = tmp2;
	    }
            let cnt = 0;
	    let highlight = this.getFilterHighlight();
	    let sorter = (a,b)=>{
		let r1 = a;
		let r2 = b;
		let h1 = r1.isHighlight(this);
		let h2 = r2.isHighlight(this);
		if(highlight) {
		    if(h1 && !h2) return 1;
		    if(!h1 && h2) return -1;
		}
                let t1 = this.getDataValues(a);
                let t2 = this.getDataValues(b);
                let v1 = t1[sortField.getIndex()];
                let v2 = t2[sortField.getIndex()];
                if (v1 < v2) return -1;
                if (v1 > v2) return 1;
                return 0;
	    };
            tmp.sort((a, b) => {
		let v = sorter(a,b);
		if(v==0) return 0;
		if(this.sortAscending) return v;
		return  -v;
            });


            for (let rowIdx = 0; rowIdx < tmp.length; rowIdx++) {
                let record = tmp[rowIdx];
                let tuple = this.getDataValues(record);
                let label = "";
                stringFields.map(f=>{
		    label += f.getValue(record)+" ";
		});
                label = label.trim();
		value = sortField.getValue(record);
                if (isNaN(value) || value === null) {
		    if(!includeNaN) continue;
		    value = "NA";
		} else {
		    value = this.formatNumber(value);
		}
		html += HU.tr([VALIGN,'top',CLASS,'display-ranking-row','what',record.getId()],
			      HU.td([],'#' + (rowIdx + 1)) + HU.td([],SPACE + label) +HU.td([ALIGN,'right'], SPACE +
											    value));
            }
            html += HU.close(TABLE);
            html += HU.close(DIV);
            this.setContents(html);
            let _this = this;
            this.jq(ID_TABLE).find(".display-ranking-row").click(function(e) {
		let record = _this.idToRecord[$(this).attr("what")];
		_this.propagateEventRecordSelection({record:record});
            });
	    HU.initSelect(this.jq("sortfields"));
            this.jq("sortfields").change(function() {
                _this.setProperty("sortField", $(this).val());
                _this.updateUI();
            });
        },
    });
}



function RamaddaCrosstabDisplay(displayManager, id, properties) {
    const ID_TABLE = "crosstab";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CROSSTAB, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let allFields = this.dataCollection.getList()[0].getRecordFields();
	    let enums = [];
	    allFields.map(field=>{
		let label = this.getFieldLabel(field);
		if(label.length>30) label = label.substring(0,29);
		enums.push([field.getId(),label]);
	    });
	    let select = HU.span([CLASS,"display-filterby"],
				 "Display: " + HU.select("",[STYLE,"", ID,this.domId("crosstabselect")],enums,
							 this.getProperty("column", "", true)));


            this.setContents(select+HU.div([ID,this.domId(ID_TABLE)]));
	    let _this = this;
	    this.jq("crosstabselect").change(function() {
		_this.setProperty("column", $(this).val());
		_this.makeTable();
	    });
	    this.makeTable();
	},
	makeTable: function() {
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
	    let col =  this.getFieldById(null, this.getProperty("column", "", true));
	    let rows =  this.getFieldsByIds(null, this.getProperty("rows", null, true));
	    if(!col) col  = allFields[0];
	    if(rows.length==0) rows  = allFields;

            let html = HU.open(TABLE, ["border", "1px", "bordercolor", "#ccc", CLASS, "display-crosstab", "cellspacing", "1", "cellpadding", "2"]);
	    let total = dataList.length-1;
	    let cnt =0;
	    rows.map((row)=>{
		if(row.getId()==col.getId()) return;
		cnt++;
		let colValues = [];
		let rowValues = [];
		let count ={};
		let rowcount ={};
		let colcount ={};
		for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
		    let tuple = this.getDataValues(dataList[rowIdx]);
		    let colValue = (""+tuple[col.getIndex()]).trim();
		    let rowValue = (""+tuple[row.getIndex()]).trim();
		    let key = colValue+"--" + rowValue;
		    if(colValues.indexOf(colValue)<0) colValues.push(colValue);
		    if(rowValues.indexOf(rowValue)<0) rowValues.push(rowValue);
		    if (!(rowValue in rowcount)) {
			rowcount[rowValue] = 0;
		    }
		    rowcount[rowValue]++;
		    if (!(key in count)) {
			count[key] = 0;
		    }
		    count[key]++;
		}
		colValues.sort();
		rowValues.sort();
		if(cnt==1)
		    html+=HU.tr([],HU.td()+ HU.td([ALIGN,'center',CLASS,'display-crosstab-header','colspan',colValues.length], col.getLabel()) +HU.td([],SPACE));
		html+=HU.open(TR,[VALIGN,'bottom',CLASS,'display-crosstab-header-row'],HU.td([CLASS,'display-crosstab-header'],row.getLabel()));
		for(let j=0;j<colValues.length;j++) {
		    let colValue = colValues[j];
		    html+=HU.td([],(colValue==""?"&lt;blank&gt;":colValue));
		}
		html+=HU.td([],HU.b('Total'));
		html+=HU.close(TR);
		for(let i=0;i<rowValues.length;i++) {
		    let rowValue = rowValues[i];
		    html+=HU.open(TR);
		    html+=HU.td([], (rowValue==""?"&lt;blank&gt;":rowValue));
		    for(let j=0;j<colValues.length;j++) {
			let colValue = colValues[j];
			let key = colValue+"--" + rowValue;
			if(Utils.isDefined(count[key])) {
			    let perc = Math.round(count[key]/total*100) +"%";
			    html+=HU.td([ALIGN,'right'], count[key] +"&nbsp;(" + perc+")");
			} else {
			    html+=HU.td([],SPACE);
			}
		    }
		    let perc = Math.round(rowcount[rowValue]/total*100) +"%";
		    html+=HU.td([ALIGN,'right'], rowcount[rowValue] +SPACE +'(' + perc+')');
		    html+=HU.close(TR);
		}
	    });
            html += HU.close(TABLE);
	    this.jq(ID_TABLE).html(html);
        },
    });
}




function RamaddaCorrelationDisplay(displayManager, id, properties) {
    const ID_SLIDER_LOW = "sliderlow";
    const ID_SLIDER_LOW_MIN = "sliderlowmin";
    const ID_SLIDER_LOW_MAX = "sliderlowmax"
    const ID_SLIDER_HIGH = "sliderhigh";
    const ID_SLIDER_HIGH_MIN = "sliderhighmin";
    const ID_SLIDER_HIGH_MAX = "sliderhighmax"    
    const ID_TABLE = "table";
    const ID_LASTROW = "lastrow";
    $.extend(this, {
        colorTable: "red_white_blue",
        colorByMin: "-1",
        colorByMax: "1",
    });

    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CORRELATION, properties);
    let myProps = [
	{label:'Correlation'},
	{p:'showSelectSlider',ex:'false',d:true},
	{p:'range.low.min',ex:'-1'},
	{p:'range.low.max',ex:'0'},
	{p:'range.high.min',ex:'0'},
	{p:'range.high.max',ex:'1'},
	{p:'short',ex:'true',tt:'Abbreviated display'},
	{p:'showValue',ex:'false',tt:'Show the values'},
	{p:'useId ',ex:' true',tt:'Use field id instead of label'},
	{p:'useIdTop',ex:'true',tt:'Use field id for top header'},
	{p:'useIdSide ',ex:'true',tt:'Use field id for side header'},
	{p:'labelStyle',ex:'',tt:'CSS style for labels'}

    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        "map-display": false,
        needsData: function() {
            return true;
        },


        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            let tmp = HU.formTable();
            let colorTable = this.getColorTableName();
            let ct = HU.open('select',[ID,this.domId("colortable")]);
            for (table in Utils.ColorTables) {
                if (table == colorTable)
                    ct += HU.tag('option',['selected',null],table);
                else
                    ct += HU.tag('option',[], table);
            }
            ct += HU.close('select');
            tmp += HU.formEntry("Color Bar:", ct);
            tmp += HU.formEntry("Color By Range:", HU.input("", this.colorByMin, ["size", "7", ATTR_ID, this.domId("colorbymin")]) + " - " +
				HU.input("", this.colorByMax, ["size", "7", ATTR_ID, this.domId("colorbymax")]));
            tmp += HU.close(TABLE);
            menuItems.push(tmp);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function() {
                _this.colorByMin = _this.jq("colorbymin").val();
                _this.colorByMax = _this.jq("colorbymax").val();
                _this.updateUI();

            };
            let func2 = function() {
                _this.colorTable = _this.jq("colortable").val();
                _this.updateUI();

            };
            this.jq("colorbymin").blur(updateFunc);
            this.jq("colorbymax").blur(updateFunc);
            this.jq("colortable").change(func2);
        },

        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    let _this  = this;
	    let html = "";
	    this.range = {
		low:{
		    min:this.getProperty("range.low.min",-1),
		    max:this.getProperty("range.low.max",0)
		},
		high: {
		    min:this.getProperty("range.high.min",0),
		    max:this.getProperty("range.high.max",1)
		}
	    }
	    if(this.getShowSelectSlider()) {
		let lowSlider = HU.div([STYLE,HU.css('display','inline-block')],"Low Range" + HU.tag(BR) + 
				       HU.div([ID,this.gid(ID_SLIDER_LOW_MIN),STYLE,HU.css(WIDTH,'50px','display','inline-block','text-align','right','margin-right','15px')],this.range.low.min) +
				       HU.div([STYLE,HU.css(HEIGHT,'20px','display','inline-block',WIDTH,'200px','background','#A6A6FF'), ID,this.gid(ID_SLIDER_LOW)]) +
				       HU.div([ID,this.gid(ID_SLIDER_LOW_MAX),STYLE,HU.css('text-align','left','width','50px','display','inline-block','margin-left','15px')],this.range.low.max));
		let highSlider = HU.div(["display","inline-block;"], "High Range" + HU.tag(BR) + 
					HU.div([ID,this.gid(ID_SLIDER_HIGH_MIN),STYLE,HU.css('width','50px','display','inline-block','text-align','right', 'margin-right','15px')],this.range.high.min) +
					HU.div([STYLE,HU.css(HEIGHT,'20px','display','inline-block','width','200px','background','#FD9596'), ID,this.gid(ID_SLIDER_HIGH)]) +
					HU.div([ID,this.gid(ID_SLIDER_HIGH_MAX),STYLE,HU.css('text-align','left','width','50px','display','inline-block','margin-left','15px')],this.range.high.max));


		html +=HU.center(HU.hrow(lowSlider, highSlider));
	    }
	    html +=HU.div([ID,this.domId(ID_TABLE)]);
            this.setContents(html);
	    this.makeTable();
	    if(this.getShowSelectSlider()) {
		this.jq(ID_SLIDER_LOW).slider({
		    range: true,
		    min: 0,
		    max: 100,
		    values:[(this.range.low.min+1)*100,(this.range.low.max+1)*100],
		    slide: function( event, ui ) {
			let v1 = -1+ui.values[0]/100;
			let v2 = -1+ui.values[1]/100;
			let s1 = v1==-1?-1:number_format(v1,3);
			let s2 = v2==0?0:number_format(v2,3);
			_this.jq(ID_SLIDER_LOW_MIN).html(s1);
			_this.jq(ID_SLIDER_LOW_MAX).html(s2);
		    },
		    stop: function(event,ui) {
			_this.range.low.min =   -1+2*ui.values[0]/100;
			_this.range.low.max  = -1+2*ui.values[1]/100;
			_this.makeTable();
		    }
		});
		this.jq(ID_SLIDER_HIGH).slider({
		    range: true,
		    min: 0,
		    max: 100,
		    values:[this.range.high.min*100,this.range.high.max*100],
		    slide: function( event, ui ) {
			let v1 = ui.values[0]/100;
			let v2 = ui.values[1]/100;
			_this.jq(ID_SLIDER_HIGH_MIN).html(v1==0?0:number_format(v1,3));
			_this.jq(ID_SLIDER_HIGH_MAX).html(v2==1?1:number_format(v2,3));

		    },
		    stop: function(event,ui) {
			_this.range.high.min =  ui.values[0]/100;
			_this.range.high.max  = ui.values[1]/100;
			_this.makeTable();
		    }
		});


		
	    }
            this.initTooltip();
            this.displayManager.propagateEventRecordSelection(this,
							      this.dataCollection.getList()[0], {
								  index: 0
							      });
        },
	makeTable: function() {
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);
            if (fields.length == 0) fields = allFields;
	    fields = fields.filter(field=>{
		if (!field.isFieldNumeric() || field.isFieldGeo()) return false;
		return true;
	    });
            let fieldCnt = fields.length;
	    let html = "";
	    if(fields.length>8) {
		html+=HU.openTag("div",[STYLE,HU.css('font-size','75%')]);
	    }
            html += HU.open(TABLE, ["cellspacing","0","cellpadding", "0", "border", "0", CLASS, "display-correlation", "width", "100%"]);
            let col1Width = 10 + "%";
            let width = 90 / fieldCnt + "%";
            html += HU.open(TR,["valign","bottom"]) + HU.td([CLASS,"display-heading","width", col1Width],SPACE);

            let short = this.getProperty("short", false);
            let showValue = this.getProperty("showValue", !short);
            let useId = this.getProperty("useId", false);
            let useIdTop = this.getProperty("useIdTop", useId);
            let useIdSide = this.getProperty("useIdSide", useId);
	    let labelStyle = this.getProperty("labelStyle","");
	    fields.forEach(field=>{
                if (!field.isFieldNumeric() || field.isFieldGeo()) return;
                let label = useIdTop ? field.getId() : this.getFieldLabel(field);
                if (short) label = "";
		label = label.replace(/\/ +/g,"/").replace(/ +\//g,"/");
		
		label = HU.span([STYLE,labelStyle], label);

                html += HU.td(["colfield", field.getId(), "align","center","width",width],
			      HU.div([CLASS, "display-correlation-heading display-correlation-heading-top"], label));
            });
            html += HU.close(TR);
	    if(!this.getProperty("colorTable"))
		this.setProperty("colorTable","blue_white_red");
	    let colors =  this.getColorTable(true);
            colorByMin = parseFloat(this.colorByMin);
            colorByMax = parseFloat(this.colorByMax);
	    if(colors) colors =  this.addAlpha(colors,0.5);

            for (let fieldIdx1 = 0; fieldIdx1 < fields.length; fieldIdx1++) {
                let field1 = fields[fieldIdx1];
                if (!field1.isFieldNumeric() || field1.isFieldGeo()) continue;
                let label = useIdSide ? field1.getId() : this.getFieldLabel(field1);
		label.replace(/ /g, SPACE);
		label = HU.span([STYLE,labelStyle], label);
                html += HU.open(TR, ["valign","center"]);
		html += HU.td(["rowfield",field1.getId(),CLASS, "display-correlation-heading"],  HU.div([CLASS, "display-correlation-heading-side"], label));
                let rowName = this.getFieldLabel(field1);
                for (let fieldIdx2 = 0; fieldIdx2 < fields.length; fieldIdx2++) {
                    let field2 = fields[fieldIdx2];
                    if (!field2.isFieldNumeric() || field2.isFieldGeo()) continue;
                    let colName = this.getFieldLabel(field2);
                    let t1 = 0;
                    let t2 = 0;
                    let cnt = 0;

                    for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                        let tuple = this.getDataValues(dataList[rowIdx]);
                        let v1 = tuple[field1.getIndex()];
                        let v2 = tuple[field2.getIndex()];
                        t1 += v1;
                        t2 += v2;
                        cnt++;
                    }
                    let avg1 = t1 / cnt;
                    let avg2 = t2 / cnt;
                    let sum1 = 0;
                    let sum2 = 0;
                    let sum3 = 0;
                    for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                        let tuple = this.getDataValues(dataList[rowIdx]);
                        let v1 = tuple[field1.getIndex()];
                        let v2 = tuple[field2.getIndex()];
                        sum1 += (v1 - avg1) * (v2 - avg2);
                        sum2 += (v1 - avg1) * (v1 - avg1);
                        sum3 += (v2 - avg2) * (v2 - avg2);
                    }
                    r = sum1 / Math.sqrt(sum2 * sum3);
		    let ok = r<0?
			(r>=this.range.low.min && r<=this.range.low.max):
			(r>=this.range.high.min && r<=this.range.high.max);
                    let style = "";
    		    
		    
		    if (ok && colors != null) {
			if(fieldIdx1!=fieldIdx2) {
                            let percent = (r - colorByMin) / (colorByMax - colorByMin);
                            let index = parseInt(percent * colors.length);
                            if (index >= colors.length) index = colors.length - 1;
                            else if (index < 0) index = 0;
                            style = HU.css("background-color", colors[index]);
			} else {
                            style = HU.css("background-color", "#eee");
			}
                    }
                    let value = r.toFixed(3);
                    let label = value;
		    if(fieldIdx1==fieldIdx2) label = SPACE;
                    if (!showValue || short) label = SPACE;
		    let cellContents = "";
		    if(ok) {
			cellContents = HU.div([CLASS, "display-correlation-element", TITLE, "&rho;(" + rowName + "," + colName + ") = " + value], label);
		    }
                    html += HU.td(["colfield", field2.getId(), "rowfield",field1.getId(), CLASS,"display-correlation-cell","align", "right", STYLE,style], cellContents);
                }
                html += HU.close(TR);
            }
            html += HU.tr([],HU.td([]) + HU.td(['colspan',(fieldCnt + 1)], HU.div([ID, this.domId(ID_LASTROW)], "")));
            html += HU.close(TABLE);
	    this.jq(ID_TABLE).html(html);
	    let _this = this;
	    let selectedRow;
	    let selectedCol;
	    this.jq(ID_TABLE).find("td").click(function() {
		let rowField = _this.getFieldById(null, $(this).attr("rowfield"));
		let colField = _this.getFieldById(null, $(this).attr("colfield"));
		let tds = _this.jq(ID_TABLE).find("td");
		if(rowField) {
		    tds.removeClass("display-correlation-row-cell-highlight");
		    if(rowField != selectedRow) {
			selectedRow = rowField;
			_this.jq(ID_TABLE).find(".display-correlation-cell[rowfield='" + rowField.getId()+"']").addClass("display-correlation-row-cell-highlight");
		    }  else {
			selectedRow = null;
		    }

		}
		if(colField) {
		    tds.removeClass("display-correlation-col-cell-highlight");
		    if(colField != selectedCol) {
			selectedCol = colField;
			_this.jq(ID_TABLE).find(".display-correlation-cell[colfield='" + colField.getId()+"']").addClass("display-correlation-col-cell-highlight");
		    }  else {
			selectedCol = null;
		    }



		}

	    });
	    this.displayColorTable(colors, ID_LASTROW, colorByMin, colorByMax);
	}
    });
}








function RamaddaRecordsDisplay(displayManager, id, properties, type) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RECORDS, properties);
    let myProps = [
	{label:'Records'},
	{p:'maxHeight',ex:'400px'},
	{p:'showCards',ex:'true',d:true}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {

        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        defaultSelectedToAll: function() {
            return true;
        },
        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        updateUI: function(reload) {
            SUPER.updateUI.call(this,reload);
            let records = this.filterData();
            if (!records) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    this.records = records;
	    let _this = this;
            let fields = this.getSelectedFields(this.getData().getRecordFields());
            let html = "";
	    let showCards = this.getShowCards();
	    if(showCards) html+=HU.open("div",[CLASS,"display-records-grid"]);
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
		let div = "";
                let tuple = this.getDataValues(records[rowIdx]);
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    let v = tuple[field.getIndex()];
		    if(v.getTime) v = this.formatDate(v);
                    div += HU.b(this.getFieldLabel(field)) + ": " + v + "<br>" +"\n";
                }
                let box = HU.div([CLASS,showCards?"":"display-records-record",RECORD_INDEX,rowIdx,RECORD_ID, records[rowIdx].getId()], div);

		if(showCards) box =HU.div([CLASS,"display-records-grid-box"],box);
		html+=box;
            }
	    if(showCards) html+=HU.close("div");
            let height = this.getProperty("maxHeight", "400px");
            if (!height.endsWith("px")) {
                height = height + "px";
            }
            this.setContents(HU.div([STYLE, HU.css('max-height', height,'overflow-y','auto')], html));
	    this.find(".display-records-record").click(function() {
		let record = _this.records[$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		}

	    });
        },
        handleEventRecordSelection: function(source, args) {
            //                this.lastHtml = args.html;
            //                this.setContents(args.html);
        }
    });
}


function RamaddaStatsDisplay(displayManager, id, properties, type) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type || DISPLAY_STATS, properties);
    if (!type)
        addRamaddaDisplay(this);
    let myProps = [
	{label:'Summary Statistics'},
	{p:'showDefault',ex:'false'},
	{p:'showMin',ex:'false'},
	{p:'showMax',ex:'false'},
        {p:'showAverage',ex:'false'},
        {p:'showStd',ex:'false'},
        {p:'showPercentile',ex:'false'},
        {p:'showCount',ex:'false'},
        {p:'showTotal',ex:'false'},
        {p:'showPercentile',ex:'false'},
        {p:'showMissing',ex:'false'},
        {p:'showUnique',ex:'false'},
        {p:'showType',ex:'false'},
        {p:'showText',ex:'false'},
	{p:"sortStatsBy",ex:'min|max|total|average'},
	{p:"sortStatsAscending",ex:'false'},
	{p:'doValueSelection',ex:'false'},
	{p:"fieldHeaderLabel",ex:''},
	{p:"statsTableWidth",ex:'100%'},

    ];

    defineDisplay(this, SUPER, myProps, {
        "map-display": false,
        needsData: function() {
            return true;
            //                return this.getProperty("loadData", false) || this.getCreatedInteractively();
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        getDefaultSelectedFields: function(fields, dfltList) {
            if (dfltList != null && dfltList.length > 0) {
                return dfltList;
            }
            //get the numeric fields
            let l = [];
	    fields.forEach(field=>{
                if (!this.getShowText() && !field.isNumeric()) return;
                if (field.isFieldGeo()) {
                    return;
                }
                l.push(field);
	    });
            return l;
        },

        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        defaultSelectedToAll: function() {
            return true;
        },
        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        updateUI: function(args) {
            SUPER.updateUI.call(this,args);
            let records = this.filterData();
            if (!records) {
		return;
	    }
            let fields = this.getSelectedFields([]);
            let stats = [];
            let justOne = false;
	    fields.forEach((field,idx)=>{
                stats.push({
		    field:field,
                    isNumber: false,
                    count: 0,
                    min: NaN,
                    uniqueMap: {},
                    unique: 0,
                    std: 0,
                    max: NaN,
                    total: 0,
                    numMissing: 0,
                    numNotMissing: 0,
                    type: field.getType(),
                    values: []
                });
            });
	    records.forEach(record=>{
                stats.forEach(stat=>{
		    let field = stat.field;
                    let v = field.getValue(record);
                    if (v) {
                        if (!Utils.isDefined(stat.uniqueMap[v])) {
                            stat.uniqueMap[v] = 1;
                            stat.unique++;
                        } else {
                            stat.uniqueMap[v]++;
                        }
                    }
                    stat.isNumber = field.isNumeric();
                    stat.count++;
                    if (v == null) {
                        stat.numMissing++;
                    } else {
                        stat.numNotMissing++;
                    }
                    if ((v!==null) && (typeof v == 'number')) {
                        let label = this.getFieldLabel(field).toLowerCase();
                        if (label.indexOf("latitude") >= 0 || label.indexOf("longitude") >= 0) {
			    return;
                        }
                        stat.total += v;
                        stat.max = Utils.max(stat.max, v);
                        stat.min = Utils.min(stat.min, v);
                        stat.values.push(v);
                    }
		});
	    });

		
	    let dflt = this.getProperty("showDefault",true);

	    if (this.getShowUnique(dflt)) {
                stats.forEach(stat=>{
		    let field = stat.field;
                    stat.uniqueMax = 0;
                    stat.uniqueValue = "";
                    for (let v in stat.uniqueMap) {
                        let count = stat.uniqueMap[v];
                        if (count > stat.uniqueMax) {
                            stat.uniqueMax = count;
                            stat.uniqueValue = v;
                        }
                    }
                });
	    }

            if (this.getShowStd(dflt)) {
                stats.forEach(stat=>{
                    let values = stat.values;
                    if (values.length > 0) {
                        let average = stat.total / values.length;
                        let stdTotal = 0;
                        for (let i = 0; i < values.length; i++) {
                            let diff = values[i] - average;
                            stdTotal += diff * diff;
                        }
                        let mean = stdTotal / values.length;
                        stat.std = Math.sqrt(mean);
                    }
                });
            }

            let border = (justOne ? "0" : "1");
	    let attrs = [ID,this.getDomId("statstable"), CLASS, "row-border stripe  display-stats"];
	    let tableWidth = this.getStatsTableWidth();
	    if(tableWidth) {
		attrs.push("width");
		attrs.push(tableWidth);
	    }
            let html = HU.open(TABLE, attrs);
	    html+=HU.open(THEAD);
            if (!justOne) {
                header = [this.getFieldHeaderLabel("")];
                if (this.getShowCount(dflt)) 
                    header.push("Count");
                if (this.getShowMin(dflt)) 
                    header.push("Min");
                if (this.getShowPercentile(dflt)) 
                    header.push("25%","50%","75%");
                if (this.getShowMax(dflt)) 
                    header.push("Max");
                if (this.getShowTotal(dflt)) 
                    header.push("Total");
                if (this.getShowAverage(dflt)) 
                    header.push("Average");
                if (this.getShowStd(dflt)) 
                    header.push("Std");
                if (this.getShowUnique(dflt)) 
                    header.push("# Unique","Top","Freq.");
                if (this.getShowMissing(dflt)) 
                    header.push("Not&nbsp;Missing","Missing")
                html += HU.tr(["valign", "bottom"], HU.ths([CLASS, "display-stats-header", "align", "center"], header));
            }
	    html+=HU.close(THEAD);
	    html+=HU.open(TBODY);
            let cats = [];
            let catMap = {};
	    let doValueSelection = this.getDoValueSelection(false);
            stats.forEach(stat=>{
                stat.average = stat.numNotMissing == 0 ? NaN : (stat.total / stat.numNotMissing);
	    });

	    let sortBy = this.getSortStatsBy();
	    let sortAscending = this.getSortStatsAscending(true);
	    if(sortBy) {
		let sortFunc =(a,b)=>{
		    let result  =0
		    if(sortBy == "total")
			result= a.total-b.total;
		    else if(sortBy == "min")
			result= a.min-b.min;
		    else if(sortBy == "max")
			result= a.max-b.max;
		    else if(sortBy == "average")
			result= a.average-b.average;
		    if(result==0) return result;
		    if(sortAscending) return result;
		    return -result;
		    
		};
		stats.sort(sortFunc);
	    }

            stats.forEach(stat=>{
		let field = stat.field;
                let right = "";
                let total = SPACE;
                let _label = this.getFieldLabel(field).toLowerCase();
                let avg = stat.numNotMissing == 0 ? "NA" : this.formatNumber(stat.total / stat.numNotMissing);
                //Some guess work about when to show a total
                if (_label.indexOf("%") < 0 && _label.indexOf("percent") < 0 && _label.indexOf("median") < 0) {
                    total = this.formatNumber(stat.total);
                }
                if (justOne) {
                    right = HU.tds(["xalign", "right"], [this.formatNumber(stat.min)]);
		    return;
                }
                let values = [];
                if (!stat.isNumber && this.getShowText(dflt)) {
                    if (this.getShowCount(dflt))
                        values.push(stat.count);
                    if (this.getShowMin(dflt))
                        values.push("-");
                    if (this.getShowPercentile(dflt)) 
                        values.push("-","-","-");
                    if (this.getShowMax(dflt))
                        values.push("-");
                    values.push("-");
                    if (this.getShowAverage(dflt)) 
                        values.push("-");
                    if (this.getShowStd(dflt)) 
                        values.push("-");
                    if (this.getShowUnique(dflt)) 
                        values.push(stat.unique,stat.uniqueValue,stat.uniqueMax);
                    if (this.getShowMissing(dflt)) 
                        values.push(stat.numNotMissing,stat.numMissing);
                } else {
                    if (this.getShowCount(dflt)) 
                        values.push(stat.count);
                    if (this.getShowMin(dflt)) 
                        values.push(this.formatNumber(stat.min));
                    if (this.getShowPercentile(dflt)) {
                        let range = stat.max - stat.min;
			let tmp =p=> {
                            let s = this.formatNumber(stat.min + range * p);
			    if(doValueSelection) {
				s = HU.span([CLASS,"display-stats-value","data-type", "percentile","data-value", p],s);
			    }
                            values.push(s);
			}
			let percs = [.25,.5,.75];
			percs.map(v=>tmp(v));
                    }
                    if (this.getShowMax(dflt)) 
                        values.push(this.formatNumber(stat.max));
                    if (this.getShowTotal(dflt)) 
                        values.push(total);
                    if (this.getShowAverage(dflt)) 
                        values.push(avg);
                    if (this.getShowStd(dflt)) 
                        values.push(this.formatNumber(stat.std));
                    if (this.getShowUnique(dflt)) {
                        values.push(stat.unique);
                        if (Utils.isNumber(stat.uniqueValue)) {
                            values.push(this.formatNumber(stat.uniqueValue));
                        } else {
                            values.push(stat.uniqueValue);
                        }
                        values.push(stat.uniqueMax);
                    }
                    if (this.getShowMissing(dflt)) 
                        values.push(stat.numNotMissing,stat.numMissing);
                }
                right = HU.tds(["align", "right"], values);
                let align = (justOne ? "right" : "left");
                let label = this.getFieldLabel(field);
                let toks = label.split("!!");
                let tooltip = "";
                tooltip += field.getId();
                if (field.description && field.description != "") {
                    tooltip += "\n" + field.description + "\n";
                }
                label = toks[toks.length - 1];
                if (Utils.stringDefined(field.unit)) 
                    label = label + " [" + field.unit + "]";
                if (justOne) 
                    label += ":";
                label = label.replace(/ /g, SPACE)
                let row = HU.tr([], HU.td(["nowrap","true","align", align], field.getTypeLabel() +SPACE + HU.b(HU.span([TITLE, tooltip], label))) + right);
                html += row;
            });
            html += HU.close(TBODY, TABLE);
            this.setContents(html);
	    //the aaSorting turns off the inital sorting
	    HU.formatTable("#" +this.getDomId("statstable"),{ordering:true,"aaSorting": []});	    
            this.initTooltip();

	    if(doValueSelection) {
		let values = this.find(".display-stats-value");
		values.each(function() {
		    let type  = $(this).attr("data-type");
		    let value  = $(this).attr("data-value");
		    let links = SPACE + HU.getIconImage("fa-less-than",[TITLE,"Filter other displays",
									CLASS,"display-stats-value-link","data-type",type,"data-value",value],
							[STYLE,HU.css('font-size','8pt')]);

		    $(this).append(links);
		});
		values = this.find(".display-stats-value-link");
		values.each(function() {
		});
	    }

	    /*???
            //always propagate the event when loaded
	    let record = records[0];
	    this.displayManager.propagateEventRecordSelection(this,
							      record, {
								  index: 0
							      });
	    */
        },
    });
}



function RamaddaCooccurenceDisplay(displayManager, id, properties) {
    const ID_TABLE = "table";
    const ID_HEADER = "coocheader";
    const ID_SORTBY = "sortby";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_COOCCURENCE, properties);
    let myProps = [
	{label:'Cooccurence'},
	{p:'sourceField',ex:''},
	{p:'targetField',ex:''},
	{p:'colorBy',ex:''},
	{p:'directed',ex:'false'},
	{p:'missingBackground',ex:'#eee'},
	{p:'showSortBy',ex:'false'},
	{p:'sortBy',ex:'weight'},
	{p:'minWeight',ex:''},
	{p:'topSpace',ex:'50px'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },

	getHeader2:function() {
	    let html = SUPER.getHeader2.call(this);
	    let weightField = this.getFieldById(null, this.getProperty("colorBy","weight"));
	    if(weightField && this.getProperty("showSortBy",true)) {
		let enums = [["name","Name"],["weight","Weight"]];
		html +=  HU.div([STYLE,HU.css('display','inline-block')], "Sort by: " + HU.select("",[ID,this.domId(ID_SORTBY)],enums,this.getProperty("sortBy","")))+SPACE2;
		
	    }
	    return html;

	}, 
	initHeader2:function() {
	    let _this = this;
	    this.jq(ID_SORTBY).change(function() {
		_this.setProperty("sortBy",$(this).val());
		_this.updateUI();
	    });
	},
        updateUI: function() {
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let html = HU.div([ID, this.domId(ID_HEADER)]) +
		HU.div([ID, this.domId(ID_TABLE)]);
	    this.setContents(html);


	    let sourceField = this.getFieldById(null, this.getProperty("sourceField","source"));
	    let targetField = this.getFieldById(null, this.getProperty("targetField","target"));
	    let weightField = this.getFieldById(null, this.getProperty("colorBy","weight"));

	    if(sourceField==null || targetField==null) {
		this.setDisplayMessage("No source/target fields specified");
		return;
	    }
	    let colors = this.getColorTable();
	    if(!colors) colors = Utils.getColorTable("blues",true);
	    let colorBy = this.getColorByInfo(records,null,null,colors);
	    let names = {};
	    let nameList = [];
	    let sources = [];
	    let targets = [];
	    let links={};
	    let maxWeight = 0;
	    let sortBy  = this.getProperty("sortBy","name");
	    let directed = this.getProperty("directed",true);
	    let missing = -999999;

	    records.map(r=>{
		let source = r.getValue(sourceField.getIndex());
		let target = r.getValue(targetField.getIndex());
		let weight = missing;
		if(weightField) {
		    weight = r.getValue(weightField.getIndex());
		    maxWeight = Math.max(maxWeight, weight);
		}
		sources.push({name:source,weight:weight});
		targets.push({name:target,weight:weight});
		if(!directed) {
		    sources.push({name:target,weight:weight});
		    targets.push({name:source,weight:weight});
		    
		}
		links[source+"--" + target] = weight;
	    });
	    maxWeight = this.getProperty("maxWeight", maxWeight);
	    let sortFunc =(a,b)=>{
		if(sortBy == "name" || sortBy=="") {
		    return a.name.localeCompare(b.name);
		} else {
		    return b.weight-a.weight;
		}} 
	    sources.sort(sortFunc);
	    targets.sort(sortFunc);
	    let minWeight = this.getProperty("minWeight",missing);
	    let seen = {}
	    let tmp =[];
	    let pruneFunc = t=>{
		if(minWeight!=missing) {
		    if(t.weight==missing || t.weight<minWeight) return;
		}
		if(!seen[t.name]) {
		    seen[t.name]=true;
		    tmp.push(t.name);
		}
	    }
	    sources.map(pruneFunc);
	    sources=tmp;
	    seen = {}
	    tmp =[];
	    targets.map(pruneFunc);
	    targets = tmp;

	    let table = HU.div([STYLE,HU.css('margin-top',this.getProperty("topSpace","100px"))]) +
		HU.open(TABLE,[STYLE,HU.css('height','100%'), CLASS,'display-cooc-table', 'order',0]);
	    table += HU.open(TR,['valign','bottom']) + HU.td(['border','none']);
	    targets.map(target=>{
		target = target.replace(/ /g,SPACE).replace(/-/g,SPACE);
		table += HU.td([STYLE,HU.css('border','none'), "width","6"],HU.div([CLASS,"display-cooc-colheader"], target));
	    });

	    let missingBackground  = this.getProperty("missingBackground","#eee");
	    sources.map(source=>{
		let label =  source.replace(/ /g,SPACE);
		table += HU.open(TR,['valign','bottom']) +HU.td([STYLE,HU.css('border','none'), 'align','right'], HU.div([CLASS,"display-cooc-rowheader"], label));
		targets.map(target=>{
		    let weight = links[source+"--" + target];
		    if(!directed && !Utils.isDefined(weight))
			weight = links[target+"--" + source];
		    let style="";
		    if(weight) {
			if(weight == missing || maxWeight == 0) 
			    style = HU.css('background','#ccc');
			else {
			    if(colorBy.index>=0) {
				color =  colorBy.getColor(weight);
				style = HU.css('background',color);
			    }
			    //			    let percent = weight/maxWeight;
			    //			    let index = parseInt(percent*colors.length);
			    // 			    if(index>=colors.length) index=colors.length-1;
			    //			    style = "background:" + colors[index]+";";
			}
		    }  else {
			style = HU.css('background', missingBackground);
		    }
		    table+=HU.td([TITLE,source+" -> " + target+(weight>0?" " + weight:""), "width","3"],HU.div([CLASS,"display-cooc-cell",STYLE,style+HU.css('height','100%')],SPACE));
		});
		table+= HU.close(TR);
	    });

	    table+=HU.close(TR,TABLE);
	    table+=HU.div([STYLE,HU.css('margin','5px')]);
	    this.jq(ID_TABLE).html(table);
	    colorBy.displayColorTable();

	}
    })
}



function RamaddaBoxtableDisplay(displayManager, id, properties) {
    const ID_HEADER = "coocheader";
    const ID_SORTBY = "sortby";
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_BOXTABLE, properties);
    let myProps = [
	{label:'Color Boxes'},
	{p:'categoryField',ex:''},
	{p:'colorBy',ex:''},
	{p:'tableWidth',ex:'300'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },

        updateUI: function() {
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let categoryField = this.getFieldById(null, this.getProperty("categoryField","category"));
	    if(categoryField==null) {
		this.setDisplayMessage("No category field field specified");
		return;
	    }
	    let colors = this.getColorTable();
	    if(!colors) colors = Utils.getColorTable("blues",true);
	    let colorBy = this.getColorByInfo(records,null,null,colors);
	    let catMap =  {};
	    let cats = [];
	    records.forEach(r=>{
		let category = r.getValue(categoryField.getIndex());
		let value = colorBy.index>=0?r.getValue(colorBy.index):0;
		let list = catMap[category] && catMap[category].list;
		if(!list) {
		    list = [];
		    catMap[category] = {list:list, max:0};
		    cats.push(category);
		}
		catMap[category].max = Math.max(catMap[category].max,value);
		list.push(r);
	    });
	    let html = HU.open(TABLE,[CLASS,'display-colorboxes-table','cellpadding',5]);
	    let tableWidth=this.getProperty("tableWidth",300);
	    cats.sort((a,b)=>{
		return catMap[b].max - catMap[a].max;
	    });

	    cats.forEach(cat=>{
		let length = catMap[cat].list.length;
		let label = HU.span(["field-id",categoryField.getId(),
				     "field-value",cat], cat);
		let row = HU.open(TR,['valign','top'],HU.td(['align','right',CLASS,'display-colorboxes-header'],label+ "("+length+")"));
		row+=	  HU.open(TD,[WIDTH,'${tableWidth}']);
		if(colorBy.index) {
		    catMap[cat].list.sort((a,b)=>{
			return b.getData()[colorBy.index]-a.getData()[colorBy.index];
		    });
		}
		catMap[cat].list.map((record,idx)=>{
		    let color = "#ccc";
		    if(colorBy.index) {
			color =  colorBy.getColor(record.getData()[colorBy.index], record) || color;
		    }
		    row +=HU.div([TITLE,"",RECORD_ID, record.getId(), CLASS,"display-colorboxes-box",STYLE,HU.css('background', color)],"");
		});
		row+=HU.close(TD,TR);
		html+=row;
	    });

	    html +=HU.close(TABLE);
            this.displayHtml(html);
	    colorBy.displayColorTable(500);
	    if(!this.getProperty("tooltip"))
		this.setProperty("tooltip","${default}");
	    this.makeTooltips(this.find(".display-colorboxes-box"),records);
	    this.addFieldClickHandler(null, records);
	}
    })
}



function RamaddaPercentchangeDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_PERCENTCHANGE, properties);
    let myProps = [
	{label:'Percent Change'},
	{p:'template',ex:'${date1} ${date2} ${value1} ${value2} ${percent} ${per_hour} ${per_day} ${per_week} ${per_month} ${per_year}'},
	{p:'fieldLabel',ex:''},
	{p:'sortFields',ex:'false'},
	{p:'highlightPercent',ex:'50'},
	{p:'highlightPercentPositive',ex:'50'},
	{p:'highlightPercentNegative',ex:'-50'},
	{p:'highlightColor',ex:''},
	{p:'highlightColorPositive',ex:''},
	{p:'highlightColorNegative',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
            let allFields = this.getData().getRecordFields();
            let fields = this.getSelectedFields(allFields);
	    fields = this.getFieldsByType(fields, "numeric");
	    let  record1 = records[0];
	    let  record2 = records[records.length-1];
	    let template = this.getProperty("template",null);
	    let headerTemplate = this.getProperty("headerTemplate","");
	    let footerTemplate = this.getProperty("footerTemplate","");
	    let date1 = record1.getDate();
	    let date2 = record2.getDate();
	    let label1 ="Start Value";
	    let label2 ="End Value";
	    let hours = 1;
	    let days = 1;
	    let years = 1;
	    let months = 1;
	    if(date1)
		label1 = this.formatDate(date1);
	    if(date2)
		label2 = this.formatDate(date2);
	    if(date1 && date2) {
		let diff = date2.getTime() - date1.getTime();
		days = diff/1000/60/60/24;
		hours = days*24;
		years = days/365;
		months = years*12;
	    }
            let html =  "";
	    if(template) {
		html= headerTemplate;
	    } else {
		html += HU.open(TABLE, [CLASS, "stripe nowrap ramadda-table", ID, this.domId("percentchange")]);
		html += HU.open(THEAD, []);
		html += "\n";
		html += HU.tr([], HU.th([STYLE,HU.css('text-align','center')], this.getProperty("fieldLabel", "Field")) + HU.th([STYLE,HU.css('text-align','center')], label1) + HU.th([STYLE,HU.css('text-align','center')], label2)
			      + HU.th([STYLE,HU.css('text-align','center')], "Percent Change"));
		html += HU.close(THEAD);
		html += HU.open(TBODY, []);
	    }
	    let tuples= [];
	    fields.map(f=>{
		let val1 = 0;
		for(let i=0;i<records.length;i++) {
		    let val = records[i].getValue(f.getIndex());
		    if(!isNaN(val)) {
			val1 = val;
			break;
		    }
		}
		
		let val2 = 0;
		for(let i=records.length-1;i>=0;i--) {
		    let val = records[i].getValue(f.getIndex());
		    if(!isNaN(val)) {
			val2 = val;
			break;
		    }
		}

		let percent = parseInt(1000*(val2-val1)/val1)/10;
		//		val1 = record1.getValue(f.getIndex());
		//		val2 = record2.getValue(f.getIndex());
		tuples.push({field:f,val1:val1,val2:val2,percent:percent});
	    });

	    if(this.getProperty("sortFields",true)) {
		tuples.sort((a,b)=>{
		    return -(a.percent-b.percent);
		})
	    }
	    let highlightPercent = this.getProperty("highlightPercent",NaN);
	    let highlightPercentPositive = this.getProperty("highlightPercentPositive",highlightPercent);
	    let highlightPercentNegative = this.getProperty("highlightPercentNegative",-highlightPercent);
	    let highlightColor = this.getProperty("highlightColor","#ccc"||"#FFFEEC");
	    let posColor = this.getProperty("highlightColorPositive",highlightColor);
	    let negColor = this.getProperty("highlightColorNegative",highlightColor);
	    tuples.map(t=>{
		if(template) {
		    let h = template.replace("${field}", this.getFieldLabel(t.field)).replace("${value1}",this.formatNumber(t.val1)).replace("${value2}",this.formatNumber(t.val2)).replace("${percent}",this.formatNumber(t.percent)).replace("${date1}",label1).replace("${date2}",label2).replace("${difference}", this.formatNumber(t.val2-t.val1));
		    
		    h = h.replace(/\${per_hour}/g,this.formatNumber(t.percent/hours));
		    h = h.replace(/\${per_day}/g,this.formatNumber(t.percent/days));
		    h = h.replace(/\${per_week}/g,this.formatNumber(t.percent/(days/7)));
		    h = h.replace(/\${per_month}/g,this.formatNumber(t.percent/months));
		    h = h.replace(/\${per_year}/g,this.formatNumber(t.percent/years));
		    html+=h;
		} else {
		    let style = "";
		    if(!isNaN(highlightPercentPositive))
			if(t.percent>highlightPercentPositive)
			    style += HU.css('background', posColor);
		    if(!isNaN(highlightPercentNegative))
			if(t.percent<highlightPercentNegative)
			    style += HU.css('background', negColor);
		    
		    html += HU.tr([STYLE,style], HU.td([], this.getFieldLabel(t.field)) + 
				  HU.td(["align","right"], this.formatNumber(t.val1)) +
				  HU.td(["align","right"], this.formatNumber(t.val2))
				  + HU.td(["align","right"], t.percent+"%"));
		}
	    });

	    if(template) {
		html+= footerTemplate;
	    } else {
		html += HU.close(TBODY);
		html += HU.close(TABLE);
	    }
	    this.setContents(html); 
            HU.formatTable("#" + this.domId("percentchange"), {ordering:false
								  //scrollY: this.getProperty("tableSummaryHeight", tableHeight)
								 });
	},
    })
}



function RamaddaDatatableDisplay(displayManager, id, properties) {
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_DATATABLE, properties);
    let myProps = [
	{label:'Data Table'},
	{p:'columnSelector',ex:'date_day|date_hour|date_dow|date_month|date_year'},
	{p:'selectors',ex:'date_day,date_hour,date_dow,date_month,date_year,date_fieldid'},
	{p:'columnSelector',ex:'date_day|date_hour|date_dow|date_month'},
	{p:'rowSelector',ex:'date_day|date_hour|date_dow|date_month'},
	{p:'checkedIcon',ex:'fa-checked'},
	{p:'checkedTooltipHeader',ex:'${numberChecked}'},
	{p:'dataCheckers',ex:'match|notmatch|lessthan|greaterthan|equals|notequals(field=field,value=value,label=label,enabled=false) '}, 
	{p:'showColumnSelector',ex:'false'},
	{p:'showRowSelector',ex:'false'},
	{p:'showValues',ex:'false'},
	{p:'showColors',ex:'false'},
	{p:'showRowTotals',ex:'false'},
	{p:'showColumnTotals',ex:'false'},
	{p:'slantHeader',ex:'true'}
	];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        updateUI: function() {
            this.setDisplayMessage(this.getLoadingMessage());
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let colors = this.getColorTable(true);
	    if (!colors) colors = Utils.getColorTable("blues",true);
	    let checkers = this.getDataFilters(this.getProperty("dataCheckers"));
	    let cells = {};
	    let countFields= this.getFieldsByIds(null, this.getProperty("countFields"));

	    let selectors;
	    let fieldMap = {};
	    if(this.getProperty("selectors")) {
		selectors = [];
		let labels = {"date_day":"Day","date_dow":"Day of Week","date_hour":"Hour","date_month":"Month","date_year":"Year"};
		this.getProperty("selectors").split(",").map(s=>{
		    let label = labels[s];
		    if(!label) {
			let field = this.getFieldById(null,s);
			if(field) {
			    label = this.getFieldLabel(field);
			    fieldMap[s] = field;
			}
		    }
		    if(label) 
			selectors.push([s,label]);
		});
	    } else {
		selectors  =   [["date_day","Day"],["date_dow","Day of Week"],["date_hour","Hour"],["date_month","Month"],["date_year","Year"]];
	    }

	    let columnSelector = this.getProperty("columnSelector",selectors[0][0]);
	    let rowSelector = this.getProperty("rowSelector",selectors[1][0]);
	    let getValues =(s=>{
		let values = [];
		if(s =="date_dow") {
		    Utils.dayNamesShortShort.map((d,i)=>{
			values.push({id:i,label:d});
		    });
		}  else if(s =="date_hour") {
		    let tmp =["12&nbsp;AM","1","2","3","4","5","6","7","8","9","10","11",
			      "12&nbsp;PM","1","2","3","4","5","6","7","8","9","10","11"];
		    for(let i=0;i<24;i++)
			values.push({id:i,label:tmp[i]});
		}  else if(s =="date_day") {
		    for(let day=1;day<=31;day++)
			values.push({id:day,label:String(day)});
		}  else if(s =="date_month") {
		    Utils.monthNames.map((m,i)=>{
			values.push({id:i,label:m});
		    });
		}  else if(s =="date_year") {
		    let years =[];
		    let seen = {};
		    records.map(r=>{
			let year = r.getDate().getUTCFullYear();
			if(!seen[year]) {
			    years.push(year);
			    seen[year] = true;
			}
		    });
		    years.sort();
		    years.map((y,i)=>{
			values.push({id:y,label:String(y)});
		    });
		} else {
		    let field = fieldMap[s];
		    if(field) {
			let seen = {};
			let isNumber = false;
			this.getColumnValues(records, field).values.map(d=>{
			    isNumber = Utils.isNumber(d);
			    if(!Utils.isDefined(seen[d])) {
				seen[d] = true;
				values.push({id:d,label:String(d)});
			    }
			});
			values.sort((a,b) =>{
			    if(isNumber) {
				return a.id-b.id;
			    }
			    return a.label.localeCompare(b.label);
			});
		    }
		}
		return values;
	    });
	    let columns =getValues(columnSelector);
	    let rows =getValues(rowSelector);
	    let getId =((s,r,l)=>{
		if(s =="date_dow")  {
		    return l[r.getDate().getDay()].id;
		} else if(s =="date_hour") {
		    return l[r.getDate().getUTCHours()].id;
		} else if(s =="date_day") {
		    return  l[r.getDate().getUTCDate()-1].id;
		} else if(s =="date_month") {
		    return  l[r.getDate().getUTCMonth()].id;
		} else if(s =="date_year") {
		    return r.getDate().getUTCFullYear();
		} else {
		    let field = fieldMap[s];
		    if(field) {
			return r.getValue(field.getIndex());
		    }
		}
		return "null";
	    });

	    records.map((r,i)=>{
		let row =getId(rowSelector,r,rows);
		let column =getId(columnSelector,r,columns);
		let key = row+"-" +column;
		let cell = cells[key];
		if(!cell) {
		    cell = cells[key]={
			checked:[],
			row:row,
			column:column,
			count:0,
			records:[],
			countFields:{}
		    };
		    countFields.forEach(f=>{
			cell.countFields[f.getId()] = {
			    values:[],
			    counts:{}
			};
		    });
		}

		if(checkers && checkers.length>0) {
		    if(this.checkDataFilters(checkers, r)) {
			cell.checked.push(r);
		    }
		}

		countFields.forEach(f=>{
		    //f=>in_or_out
		    let v = r.getValue(f.getIndex());
		    //v=incoming or outgoing
		    let cf = cell.countFields[f.getId()];
		    if(!cf.counts[v]) {
			cf.counts[v] = 0;
			cf.values.push(v);
		    }
		    cf.counts[v]++;
		});
		cell.count++;
		cell.records.push(r);
	    });


	    let min = 0;
	    let max  = 0;
	    let cnt = 0;
	    for(a in cells) {
		let cell = cells[a];
		min = cnt==0?cell.count:Math.min(cell.count,min);
		max = cnt==0?cell.count:Math.max(cell.count,max);
		cnt++;
		//		console.log("cell: "+ cell.row +" " + cell.column +" #:" + cell.count);
		countFields.forEach(f=>{
		    let cf = cell.countFields[f.getId()];
		    cf.values.sort();
		    cf.values.forEach(v=>{
			//			console.log("\t" + v +" = " + cf.counts[v] +" " + cell.row +" " + cell.column);
		    });
		    
		});
	    }


	    let showValues = this.getProperty("showValues", true);
	    let showColors = this.getProperty("showColors", true);
	    let cellCount = columns.length;
	    let maxRowValue = 0;
	    let maxColumnValue = 0;
	    let columnTotals = {};
	    let rowTotals = {};
	    rows.map(row=>{
		let rowTotal = 0;
		columns.map(column=>{
		    let key = row.id +"-" +column.id;
		    if(cells[key]) {
			rowTotal+=cells[key].count;
		    }
		});
		rowTotals[row.id] = rowTotal;
		maxRowValue = Math.max(maxRowValue, rowTotal);
	    });
	    columns.map(column=>{
		let columnTotal = 0;
		rows.map(row=>{
		    let key = row.id +"-" +column.id;
		    if(cells[key]) {
			columnTotal+=cells[key].count;
		    }
		});
		columnTotals[column.id] = columnTotal;
		maxColumnValue = Math.max(maxColumnValue, columnTotal);
	    });

	    let showRowTotals = this.getProperty("showRowTotals",true);
	    let showColumnTotals = this.getProperty("showColumnTotals",true);
	    let width = Math.round(100/cellCount);
	    let table = "";
	    table+=HU.open('tr',['valign','bottom']) + HU.td([],"");
	    let needToRotate = this.getProperty("slantHeader",false);
	    let topSpace = 0;
	    columns.map(column=>{
		let label = column.label;
		if(label.length>15) {
		    needToRotate = true;
		    topSpace = Math.max(topSpace,Math.round(label.length*3));
		    topSpace = 80;
		}
	    });
	    
	    columns.map(column=>{
		let label = column.label;
		if(needToRotate) {
		    if(label.length>20) {
			label = label.substring(0,20)+"...";
		    }
		    label = label.replace(/ /g,SPACE).replace("-",SPACE);
		    label = HU.div(["tootltip",column.label,CLASS,"display-datatable-header-slant"],label);
		}		    
		table+=HU.td([CLASS,'display-datatable-header','align','center'],label);
	    });
	    table+=HU.close(TR);

	    rows.map(row=>{
		let name = HU.div([],row.label.replace(/ /g,SPACE));
		table+=HU.open(TR) + HU.td([CLASS,"display-datatable-name","align","right", "width","100"],name);
		columns.map(column=>{
		    let key = row.id+"-" +column.id;		    
		    let inner = "";
		    let style = "";
		    let marker = "";
		    let cell = cells[key];
		    let extra1 = "";
		    let extra2 = "";
		    if(cell) {
			if(showValues) 
			    inner = HU.div([CLASS,"display-datatable-value"],cell.count);
			extra2 = HU.div(["data-key",key,CLASS,"display-datatable-counts"]);
			if(cell.checked.length) {
			    extra1= HU.getIconImage(this.getProperty("checkedIcon","fa-check"),[TITLE,"","data-key",key,CLASS,"display-datatable-checked"]);
			}
			if(showColors) {
                            let percent = (cell.count - min) / (max - min);
                            let ctIndex = parseInt(percent * colors.length);
                            if (ctIndex >= colors.length) ctIndex = colors.length - 1;
                            else if (ctIndex < 0) ctIndex = 0;
                            style = HU.css('background-color', colors[ctIndex]);
			}
		    }
		    let cellHtml = extra1 +extra2+inner;
		    table += HU.td([CLASS,'display-datatable-cell','align','right', STYLE,style,'width',width +'%'], cellHtml);
		});
		if(showRowTotals) {
		    let total = rowTotals[row.id];
		    let dim = Math.round(total/maxRowValue*100);
		    let bar = HU.div([CLASS, "display-datatable-summary-row",STYLE,HU.css('width', dim+'px')],total);
		    table += HU.td([WIDTH,100,"valign","top"],bar);
		}
		table += HU.close(TR);
	    });
	    if(showColumnTotals) {
		table+=HU.open(TR,['valign','top']) + HU.td();
		columns.map(column=>{
		    let total = columnTotals[column.id];
		    let dim = Math.round(total/maxColumnValue*100);
		    let bar = HU.div([CLASS, "display-datatable-summary-column",STYLE,HU.css('height', dim+'px')],total);
		    table += HU.td([],bar);

		});
	    }
	    table+=HU.close(TR);
	    table+=HU.open(TR,[],HU.td());
	    table+=HU.td(['colspan',cellCount,CLASS,'display-datatable-footer','align','center',ID,this.domId("ct")]);
	    table+=HU.close(TR,TABLE);

	    if(topSpace>0) {
		table  = HU.div([STYLE,HU.css('margin-top', topSpace+'px')], table);
	    }

	    let html ="";	
	    let headerRow = HU.open(TR);
	    if(this.getProperty("showRowSelector",true)) {
		headerRow+=  HU.td([CLASS,"display-datatable-selector","width","align","center"],HU.select("",[ID,this.domId("rowSelector")],
											     selectors,
												rowSelector,15));
	    }
	    if(this.getProperty("showColumnSelector",true)) {
		headerRow+=  HU.td(["colspan",columns.length, CLASS,"display-datatable-selector","width","90%","align","center"],  HU.select("",[ID,this.domId("columnSelector")],
														selectors,
														columnSelector));
	    }

	    let mainTable = HU.open(TABLE,[STYLE,HU.css('font-size', this.getProperty("fontSize",'8pt')),CLASS,'display-colorboxes-table', 'cellpadding',0,'cellspacing',0,  WIDTH,'100%']);
	    mainTable+=HU.tr([],headerRow);
	    mainTable+=table;
//	    html+=header;
	    html+=mainTable;

	    this.setContents(html);


	    let _this = this;
	    this.jq("rowSelector").change(function() {
		_this.setProperty("rowSelector",$(this).val());
		_this.updateUI();
	    });	    
	    this.jq("columnSelector").change(function() {
		_this.setProperty("columnSelector",$(this).val());
		_this.updateUI();
	    });

	    let pieWidth=this.getProperty("pieWidth", 30);
	    this.find(".display-datatable-counts").each(function() {
		let key = $(this).attr("data-key");	
		let cell = cells[key];
		countFields.forEach(f=>{
		    let html = _this.getFieldLabel(f)+HU.tag(BR);
		    let cf = cell.countFields[f.getId()];
		    let data=[];
		    cf.values.forEach(v=>{
			data.push([v,cf.counts[v]]);
			html+= v +":" + cf.counts[v]+SPACE + HU.tag(BR);
		    });
		    let id = _this.domId(cell.row+"-"+cell.column+"-" + f.getId());
		    $(this).append(HU.div([CLASS,"display-datatable-piechart",ID,id,TITLE,"", STYLE,HU.css(WIDTH, pieWidth+'px',HEIGHT, pieWidth+'px')]));
		    drawPieChart(_this, "#"+id,pieWidth,pieWidth,data);
		    $("#" + id).tooltip({
			content: function() {
			    return html;
			}
		    });
		});
	    });
	    

	    this.find(".display-datatable-checked").tooltip({
		content: function() {
		    let key = $(this).attr("data-key");	
		    let cell = cells[key];
		    let checked = cell.checked;
		    if(checked.length) {
			let tooltip = _this.getProperty("tooltip","${default}");
			if(tooltip =="") return null;
			let tt = _this.getProperty("checkedTooltipHeader",HU.b('#Items: ${numberChecked}') +HU.close(BR));
			tt = tt.replace("${numberChecked}", checked.length);
			checked.map(r=>{
			    if(tt!="") tt += HU.open(DIV,[CLASS,'ramadda-hline']);
			    tt+= _this.getRecordHtml(r,null,tooltip);
			});
			return HU.div([CLASS, "display-datatable-tooltip"],tt);
		    }
		    return null;

		},
	    });
	    if(showColors) {
		this.displayColorTable(colors, "ct", min,max,{});
	    }
	},
    })
}


function RamaddaSparklineDisplay(displayManager, id, properties) {
    const ID_INNER = "inner";
    if(!properties.groupBy)
	properties.displayInline = true;
    if(!Utils.isDefined(properties.showDisplayTop))
	properties.showDisplayTop = false;
    if(!Utils.isDefined(properties.showDisplayBottom))
	properties.showDisplayBottom = false;

    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_SPARKLINE, properties);
    let myProps = [
	{label:'Sparkline'},
	{p:'showDate',ex:'true'},
	{p:'showMin',ex:'true'},
	{p:'showMax',ex:'true'},
	{p:'labelStyle',ex:''},			
	{p:'sparklineWidth',d:60},
	{p:'sparklineHeight',d:20},
	{p:'sparklineLineColor',ex:'#000'},
	{p:'sparklineBarColor',ex:'MediumSeaGreen'},
	{p:'sparklineCircleColor',ex:'#000'},
	{p:'sparklineCircleRadius',ex:'1'},
	{p:'sparklineLineWidth',ex:'1'},
	{p:'sparklineShowLines',ex:'true'},
	{p:'sparklineShowBars',ex:'true'},
	{p:'sparklineShowCircles',ex:'true'},
	{p:'sparklineShowEndPoints',ex:'true'},
	{p:'sparklineEndPointRadius',ex:'2'},
	{p:'sparklineEndPoint1Color',ex:''},
	{p:'sparklineEndPoint1Color',ex:'steelblue'},
	{p:'sparklineEndPointRadius',ex:'2'},
	{p:'sparklineEndPoint2Color',ex:''},
	{p:'sparklineEndPoint2Color',ex:'tomato'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	//Overwrite so we just have undecorated text
        getLoadingMessage: function(msg) {
	    return "Loading...";
	},
	updateUI: function() {
	    let w = this.getPropertySparklineWidth(60);
	    let h = this.getPropertySparklineHeight(20);
	    let records = this.filteredRecords = this.filterData();
	    if(!records) return;



	    let field = this.getFieldById(null, this.getProperty("field"));
	    if(field==null) {
		this.setDisplayMessage("No field specified");
		return;
	    }
	    let t1 = new Date();

	    let showDate = this.getPropertyShowDate();
	    let id = this.domId(ID_INNER);
	    let colorBy = this.getColorByInfo(records);
	    let groupByField = this.getFieldById(null,this.getProperty("groupBy"));
	    let groups = groupByField?RecordUtil.groupBy(records, this, null, groupByField):null;
	    let col = this.getColumnValues(records, field);
	    let min = col.min;
	    let max = col.max;
	    if(this.getProperty("useAllRecords")) {
		let col2 = this.getColumnValues(this.getRecords(), field);
		min  = col2.min;
		max = col2.max;
	    }

	    if(groups) {
		let labelPosition = this.getProperty("labelPosition","bottom");
		html = HU.div([ID,this.domId(ID_INNER)]);
		this.setContents(html); 
		groups.values.forEach((value,idx)=>{
		    let grecords = groups.map[value];
		    let gid = id+"_"+ +idx;
		    let c = HU.div([CLASS,"display-sparkline-sparkline",ID,gid,STYLE,HU.css('width', w+'px','height', h+  'px')]);
		    let label = HU.div([CLASS,"display-sparkline-header"], value);
		    if(labelPosition == "top")
			c = label + HU.tag(BR) + c;
		    else if(labelPosition == "bottom")
			c =  c + HU.tag(BR) + label;
		    $("#"+id).append(HU.div([STYLE,HU.css('display','inline-block','margin','4px')],c));
		    let gcol = this.getColumnValues(grecords, field);
		    drawSparkLine(this, "#"+gid,w,h,gcol.values,grecords,min,max,colorBy);
		});		
	    } else {
		html = HU.div([CLASS,"display-sparkline-sparkline",ID,this.domId(ID_INNER),STYLE,HU.css('width', w+'px','height', h+'px')]);
		if(showDate) {
		    html = HU.div([CLASS,"display-sparkline-date"],this.formatDate(records[0].getTime())) + html+
			HU.div([CLASS,"display-sparkline-date"],this.formatDate(records[records.length-1].getTime()))
		}
		let left = this.getProperty("showMin")? HU.div([CLASS,"display-sparkline-value",STYLE, this.getPropertyLabelStyle("")],this.formatNumber(col.values[0])):"";
		let right = this.getProperty("showMax",true)? HU.div([CLASS,"display-sparkline-value",STYLE, this.getPropertyLabelStyle("")],this.formatNumber(col.values[col.values.length-1])):"";
		if(left!=""  || right!="")
		    html = HU.leftCenterRight(left,html,right,"1%","99%","1%",null,"padding:2px 2px;");
		this.setContents(html); 
		drawSparkLine(this, "#"+id,w,h,col.values,records,min,max,colorBy);
	    }
	    let t2 = new Date();
//	    Utils.displayTimes("sparkline",[t1,t2],true);

	}
    });
}


function RamaddaPointimageDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width="200";
    properties.displayInline = true;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_POINTIMAGE, properties);
    let myProps = [
	{label:'Point Image'},
	{p:'cellShape',ex:'rect|circle'},
	{p:'cellSize',ex:'4'},
	{p:'cellFilled',ex:'false'},
	{p:'cellColor',ex:'false'},
	{p:'doHeatmap',ex:'true'},
	{p:'padding',ex:'5'},
	{p:'borderColor',ex:'#ccc'},
	{p:'showTooltips',ex:'false'},
	{p:'colorBy',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER,myProps, {
        needsData: function() {
            return true;
        },
        getLoadingMessage: function(msg) {
	    return "Loading...";
	},
	findClosest: function(records, e) {
	    let closest = null;
	    let minDistace = 0;
	    let cnt = 0;
	    let seen = {};
	    //	    console.log("find closest");
	    records.map((r,i) =>{
		let coords = r[this.getId()+"_coordinates"]
		let dx = coords.x-e.offsetX;
		let dy = coords.y-e.offsetY;
		let d = Math.sqrt(dx*dx+dy*dy);
		//		if(!seen[r.getValue(0)]) {
		//		    console.log("\t" +r.getValue(0) +" cx:" + coords.x +" cy:" + coords.y+" ex:" + e.offsetX +" ey:" + e.offsetY +" dx:" +dx +" dy:" +dy +" d:" + d);
		//		    seen[r.getValue(0)]  =true;
		//		}
		if(i==0) {
		    closest = r;
		    minDistance=d;
		} else {
		    if(d<minDistance) {
			minDistance = d;
			closest=r;
			//			console.log("\tclosest:" + minDistance +" " + r.getValue(0));
		    }
		}
	    });
	    return closest;
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    if(this.getProperty("borderColor")) {
		$("#"+this.getProperty(PROP_DIVID)).css("border","1px solid " + this.getProperty("borderColor"));
	    }
	    let bounds ={};
	    RecordUtil.getPoints(records, bounds);
	    let ratio = (bounds.east-bounds.west)/(bounds.north-bounds.south);
	    let style = this.getProperty("padding")?HU.css('padding',+this.getProperty("padding")+"px") : "";
	    let html = HU.div([ID,this.domId("inner"),STYLE,style]);
	    this.setContents(html); 
	    let pad = 10;
	    let w = Math.round(this.jq("inner").width());
	    let h = Math.round(w/ratio);
            let divid = this.getProperty(PROP_DIVID);
	    //	    $("#"+ divid).css("height",h+pad);
	    html = HU.div([ID,this.domId("inner"),STYLE,HU.css('width', w +'height', h+'px') + style]);
	    html = HU.div([ID,this.domId("inner")]);
	    //this.getContents().css("height",h+pad);
	    this.setContents(html); 
	    let colorBy = this.getColorByInfo(records);
	    bounds = RecordUtil.expandBounds(bounds,0.1);
	    let args =$.extend({colorBy:colorBy, w:w, h:h,cell3D:this.getProperty("cell3D"),bounds:bounds},
			       this.getDefaultGridByArgs());

	    args.doHeatmap=true;
	    let fields = this.getFields();
	    let img = Gfx.gridData(this.getId(),fields, records,args);
	    this.jq("inner").html(HU.image(img,[TITLE,"",ID,this.domId("image")]));
	    this.jq("inner").append(HU.div([ID,this.domId("tooltip"),STYLE,HU.css('z-index:','2000','display','none','position','absolute','background','#fff','border','1px solid #ccc','padding','0px')]));
	    let _this = this;
	    if(this.getProperty("showTooltips",true)) {
		this.jq("image").mouseout(function( event ) {
		    _this.jq("tooltip").hide();
		});
		this.jq("image").mousemove(function( event ) {
		    let closest = _this.findClosest(records,event);
		    if(closest) {
			let html =  HU.div([STYLE,HU.css('max-height','400px','overflow-y','auto')], _this.getRecordHtml(closest));
			_this.jq("tooltip").html(html);
			_this.jq("tooltip").show();
		    }
		});
	    }
	    this.jq("image").click(e=> {
		_this.mouseEvent = event;
		let closest = this.findClosest(records,e);
		if(closest)
		    this.propagateEventRecordSelection({record: closest});
	    });
	}
    });
}


function RamaddaCanvasDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CANVAS, properties);
    let myProps = [
	{label:'Canvas'},
	{p:'canvasWidth',d:100,ex:"100",tt:'Canvas width'},
	{p:'canvasHeight',d:100,ex:"100",tt:'Canvas height'},
	{p:'canvasStyle',d:"",ex:"",tt:'Canvas CSS style'},
	{p:'titleTemplate',tt:'Template to show as title'},
	{p:'topTitleTemplate',tt:'Template to show as top title'},	
	{p:'urlField',tt:'Url Field'},
	{p:'iconField',tt:'Icon Field'},
	{p:'highlightStyle',tt:'Highlight Style'},
	{p:'unHighlightStyle',tt:'Unhighlight Style'},	
	{p:'canvasOrigin',d:"sw",ex:"center",tt:'Origin point for drawing glyphs'},
	{label:'label glyph',p:"glyph1",ex:"type:label,pos:sw,dx:10,dy:-10,label:field_colon_ ${field}_nl_field2_colon_ ${field2}"},
	{label:'rect glyph', p:"glyph1",ex:"type:rect,pos:sw,dx:10,dy:0,colorBy:field,width:150,height:100"},
	{label:'circle glyph',p:"glyph1",ex:"type:circle,pos:n,dx:10,dy:-10,fill:true,colorBy:field,width:20,baseWidth:5,sizeBy:field"},
	{label:'3dbar glyph', p:"glyph1",ex:"type:3dbar,pos:sw,dx:10,dy:-10,height:30,width:8,baseHeight:5,sizeBy:field"},
	{label:'gauge glyph',p:"glyph1",ex:"type:gauge,color:#000,pos:sw,width:50,height:50,dx:10,dy:-10,sizeBy:field,sizeByMin:0"},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let _this = this;
	    let records = this.filterData();
	    let fields = this.getFields();
	    if(!records) return;
	    if(records.length==0) {
		this.setDisplayMessage(this.getNoDataMessage());
		return;
	    }
	    let style = this.getPropertyCanvasStyle("");
	    let highlightStyle = this.getPropertyHighlightStyle("");
	    let unHighlightStyle = this.getPropertyUnHighlightStyle("");
	    let columns = this.getProperty("columns");
	    let html = "";
	    let canvasWidth = this.getPropertyCanvasWidth();
	    let canvasHeight = this.getPropertyCanvasHeight();
	    let titleTemplate= this.getPropertyTitleTemplate();
	    let topTitleTemplate= this.getPropertyTopTitleTemplate();
	    let urlField = this.getFieldById(null,this.getPropertyUrlField());
	    let iconField = this.getFieldById(null,this.getPropertyIconField());	    
	    let doingHighlight = this.getFilterHighlight();
	    records.forEach((record,idx)=>{
		let highlight =  record.isHighlight(this);
		let cid = this.domId("canvas_" + idx);
		let canvasClass = "display-canvas-canvas";
		let canvasStyle = style;
		if(doingHighlight) {
		    if(highlight) {
			canvasClass+= " display-canvas-canvas-highlight ";
			canvasStyle+= " " + highlightStyle;
		    } else {
			canvasClass+= " display-canvas-canvas-unhighlight ";
			canvasStyle+= " " + unHighlightStyle;
		    }
		}

		let c = HU.tag("canvas",[CLASS,canvasClass, STYLE,canvasStyle, 	
				 WIDTH,canvasWidth,HEIGHT,canvasHeight,ID,cid]);
		let icon = iconField? HU.image(record.getValue(iconField.getIndex()))+"&nbsp;":"";
		let topTitle  = topTitleTemplate?
		    HU.div([CLASS,"display-canvas-title"],
			   icon+this.getRecordHtml(record, null, topTitleTemplate)):icon;
		let title  = titleTemplate?
		    HU.div([CLASS,"display-canvas-title"], 
			   this.getRecordHtml(record, null, titleTemplate)):"";	
		let div =  HU.div([TITLE,"",CLASS,"display-canvas-block", RECORD_INDEX,idx,RECORD_ID, record.getId()], topTitle+c+title);
		if(urlField) {
		    let url = record.getValue(urlField.getIndex());
		    if(Utils.stringDefined(url))
			div = HU.href(url,div);
		}
		html+=div;
	    });
	    this.setContents(html);
	    let glyphs=[];
	    let cnt = 1;
	    while(cnt<11) {
		let attr = this.getProperty("glyph" + (cnt++));
		if(!attr)
		    continue;
		glyphs.push(new Glyph(this,1.0, fields,records,{
		    canvasWidth:canvasWidth,
		    canvasHeight: canvasHeight
		},attr));
	    }
	    let opts = {};
	    let originX = 0;
	    let originY=this.getPropertyCanvasOrigin()=="center"?canvasHeight/2:canvasHeight;
	    records.forEach((record,idx)=>{
		let cid = this.domId("canvas_" + idx);
		let canvas = document.getElementById(cid);
		let ctx = canvas.getContext("2d");
		glyphs.forEach(glyph=>{
		    glyph.draw(opts, canvas, ctx, originX,originY,{record:record});
		});
	    });
	    let blocks = this.find(".display-canvas-block");
	    this.makeTooltips(blocks,records,null,"${default}");
	}
    });
}


function RamaddaFieldtableDisplay(displayManager, id, properties) {
    const ID_TABLE = "fieldtable";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_FIELDTABLE, properties);
    let myProps = [
	{label:'Field Table'},
	{p:'field',ex:''},
	{p:'labelField',ex:'field'},
	{p:'columnWidth',ex:'150'},
	{p:'tableHeight',ex:'300'},
	{p:'markerShape',ex:'circle|rect|triangle|bar|arrow|dart|bar'},
	{p:'markerSize',ex:'16'},
	{p:'markerFill',ex:'#64CDCC'},
	{p:'markerStroke',ex:'#000'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
	    if(fields.length==0) 
		fields = this.getFieldsByType(null, "numeric");
	    let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    if(!labelField) labelField = this.getFieldsByType(null, "string")[0];
	    let html = HU.open(TABLE,[CLASS, "", "border",0,ID,this.domId(ID_TABLE)]);
	    html += HU.open(THEAD);
	    let width = this.getProperty("columnWidth",150)
	    html += HU.open(TR,[]);
	    html+=HU.td(["width",width],
			HU.div([CLASS,"display-fieldtable-header"],labelField?this.getFieldLabel(labelField):""));
	    let columns = {};
	    fields.forEach(f=>{
		columns[f.getId()] = this.getColumnValues(records, f);
	    });

	    fields.forEach(f=>{
		html+=HU.th(["width",width],HU.div([CLASS,"display-fieldtable-header"],this.getFieldLabel(f)));
	    });
	    html += HU.close(TR,THEAD);
	    html += HU.open(TBODY);


	    let shape = this.getProperty("markerShape","bar");
	    let canvasInfo = [];
	    let colorBys = {};
	    let cnt = 0;
	    let cw = this.getProperty("markerSize",16);

	    fields.forEach(f=>{
		colorBys[f.getId()] = this.getColorByInfo(records,f);
	    });

	    records.forEach((r,idx)=>{
		let label  = labelField?r.getValue(labelField.getIndex()):"#"+(idx+1);
		let hdrAttrs = [CLASS,"display-fieldtable-rowheader"];
		if(labelField) {
		    hdrAttrs.push("field-id");
		    hdrAttrs.push(labelField.getId());
		    hdrAttrs.push("field-value");
		    hdrAttrs.push(r.getValue(labelField.getIndex()));
		}
		html += HU.open(TR,["valign","center",RECORD_INDEX,idx,RECORD_ID, r.getId(),CLASS,"display-fieldtable-row"]);
		html+=HU.td([STYLE,HU.css('vertical-align','center'),'align','right'],HU.div(hdrAttrs,label));
		fields.forEach(f=>{
		    let v = r.getValue(f.getIndex());
		    let c = columns[f.getId()];
		    let contents = "";
		    if(isNaN(v) || c.min == c.max) return;
		    let perc = 100*(v-c.min)/(c.max-c.min);
		    let cid = this.domId("cid" + (cnt++));
		    let cinfo = {
			id: cid,
			v: v,
			percent: perc,
			field:f,
			record:r,
			colorBy: colorBys[f.getId()]
		    };
		    canvasInfo.push(cinfo);
		    let canvasWidth = cw;
		    let left =  perc+"%";
		    if(shape == "bar") {
			canvasWidth = perc*width;
			left = 0;
		    }
		    let cstyle = HU.css('position','absolute','top','0%','left',left,'margin-top','-' + (cw/2)+'px');
		    let inner = HU.tag("canvas",[TITLE,"Value:" + v +"   Range:" + c.min +" - " + c.max,STYLE,cstyle, 
						 "width",canvasWidth,"height",cw,ID,cid]);
		    contents +=HU.div([STYLE,HU.css('position','absolute','left','0px','right', cw+'px')],
				      inner);
		    html+=HU.td(["data-order", v, STYLE,HU.css('vertical-align','middle'),ALIGN,"right",TITLE, "Range:" + c.min +" - " + c.max],HU.div([STYLE,"position:relative;width:"+width+"px;" + "height:1px;margin-left:10px; margin-right:10px;border:1px solid #ccc;"],contents));
		    
		});
		html += HU.close(TR);
	    });

	    html += HU.close(TBODY);
	    html += HU.open(TFOOT);
	    html+=HU.open(TR);
	    html+=HU.td([],"");
	    fields.forEach((f,idx)=>{
		html+=HU.td([],HU.div([STYLE,HU.css('max-width', width+'px','overflow-x','auto'),ID, this.domId("footer-" + idx)],""));
	    });
	    html+=HU.close(TR);
	    html += HU.close(TFOOT);

	    html+=HU.close(TABLE);
	    this.setContents(html); 
	    let opts = {
		ordering:true
	    };
	    if(this.getProperty("tableHeight")) {
		opts.scrollY = this.getProperty("tableHeight");
	    }
	    if(this.getProperty("showColorTable")) {
		fields.forEach((f,idx)=>{
		    let colorBy = colorBys[f.getId()];
		    if(colorBy.index<0) return;
		    let domId = "footer-" + idx;
		    colorBy.displayColorTable(null,false,domId);
		});
	    }


            HU.formatTable("#" + this.domId(ID_TABLE), opts);
	    let rows = this.find(".display-fieldtable-row");
	    this.addFieldClickHandler(null, records,true);
	    let markerFill = this.getProperty("markerFill","#64CDCC");
	    let markerStroke = this.getProperty("markerStroke","#000");
	    canvasInfo.forEach(c=>{
		let canvas = document.getElementById(c.id);
		let ctx = canvas.getContext("2d");
		ctx.strokeStyle =markerStroke;
		ctx.fillStyle=c.colorBy.getColorFromRecord(c.record, markerFill);
		if(shape=="circle") {
		    ctx.beginPath();
		    ctx.arc(cw/2, cw/2, cw/2, 0, 2 * Math.PI);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="rect") {
		    ctx.fillRect(0,0,cw,cw);
		    ctx.strokeRect(0,0,cw,cw);
		} else if(shape=="bar") {
		    ctx.fillRect(0,0,c.percent/100*width,cw);
		    ctx.strokeRect(0,0,c.percent/100*width,cw);
		} else if(shape=="line") {
		    ctx.fillRect(cw/2-2,0,4,cw);
		} else if(shape=="triangle") {
		    ctx.beginPath();
		    ctx.moveTo(cw/2,0);
		    ctx.lineTo(cw,cw);
		    ctx.lineTo(0,cw);
		    ctx.lineTo(cw/2,0);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="dart") {
		    ctx.beginPath();
		    ctx.moveTo(1,0);
		    ctx.lineTo(cw-1,0);
		    ctx.lineTo(cw/2,cw/2);
		    ctx.lineTo(1,0);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="arrow") {
		    ctx.beginPath();
		    ctx.moveTo(0,0);
		    ctx.lineTo(cw/2,cw/2);
		    ctx.lineTo(cw-1,0);
		    ctx.stroke();

		}
		
	    });

	}
    });
}



function RamaddaDotstackDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, "dotstack", properties);
    let myProps = [
	{label:'Dot Stack'},
	{p:'categoryField',ex:'field'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let idToIndex = {};
	    records.forEach((r,idx)=>{
		idToIndex[r.getId()] = idx;
	    });
	    let hor = this.getProperty("orientation","horizontal") == "horizontal";
	    let categoryField = this.getFieldById(null, this.getProperty("categoryField"));
	    let html = "";
	    let groups = RecordUtil.groupBy(records, this, null, categoryField);
	    let colorBy = this.getColorByInfo(records);
	    let w = this.getProperty("boxWidth",4);
	    let cols = this.getProperty("boxColumns",10);
	    let xcnt = 0;
	    groups.values.sort((a,b)=>{
		return groups.map[b].length-groups.map[a].length;
	    });

	    groups.values.forEach((value,idx)=>{
		let rows = [];
		let row = [];
		rows.push(row);
		let grecords = groups.map[value];
		let col=0;
		grecords.forEach(r=>{
		    if(row.length>cols) {
			row=[];
			rows.push(row);
		    }
		    let c = colorBy.getColorFromRecord(r,"blue");
		    let box = HU.div(
			[TITLE,"", RECORD_ID, r.getId(),RECORD_INDEX,idToIndex[r.getId()],CLASS, "display-dotstack-dot",STYLE,HU.css('width', w+'px','height', w +'px','background', c)],"");
		    row.push(box);
		});
		html += HU.open(DIV,[CLASS,"display-dotstack-block"]);
		html+=HU.div([],this.getProperty("labelTemplate","${count}").replace("${count}", grecords.length));
		html += HU.open(TABLE);
		for(let i=rows.length-1;i>=0;i--) {
		    html += HU.tr([],HU.tds([],rows[i]));
		}
		html += HU.close(TABLE);
		html +=value;
		html += HU.close(DIV);
	    });
	    this.setContents(html); 
	    let dots = this.find(".display-dotstack-dot");
	    this.addFieldClickHandler(dots,records,false);
	    this.makeTooltips(dots,records,null,"${default}");
	    if(this.getProperty("tableHeight")) {
		opts.scrollY = this.getProperty("tableHeight");
	    }
	    if(this.getProperty("showColorTable")) {
		colorBy.displayColorTable(null,false,domId);
	    }
	}
    });
}


function RamaddaDotbarDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, "dotbar", properties);
    $.extend(this, SUPER);
    addRamaddaDisplay(this);
    let myProps = [
	{label:'Dot Bar'},
	{p:'keyField'},
	{p:'dotSize',d:16}
    ];
    this.defineSizeByProperties();
    defineDisplay(this, SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let keyField = this.getFieldById(null,this.getPropertyKeyField());
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
 	    if(fields.length==0) {
		fields = this.getPointData().getRecordFields();
	    }
	    let dotSize = this.getPropertyDotSize();
	    let sizeBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records);
	    let size = dotSize;
	    let cols = {};
	    let html = HU.open(TABLE,['width','100%']);
	    let t1 = new Date();
	    let selectedRecord;
	    let maxHeight = dotSize;
	    if(sizeBy.field)
		maxHeight=2*sizeBy.getMaxSize();
	    fields.forEach((f,idx)=>{
		if(!f.isFieldNumeric()) return;


		let cb = new  ColorByInfo(this,  fields, records, null,null, null, null,f);
		let cid = this.domId("dots"+idx);
		let column = this.getColumnValues(records, f);
		html += HU.open(TR, [VALIGN,'center']);
		html += HU.td([WIDTH,'10%', ALIGN,'right'],  HU.div([STYLE,HU.css('margin-right','8px')], this.getFieldLabel(f).replace(/ /g,SPACE)));
		html += HU.td([ALIGN,'right',WIDTH,'5%'],HU.div([STYLE, 'margin-right:10px;'],this.formatNumber(column.min)));
		html +=HU.open(TD);
		html+= HU.open(DIV,[STYLE, HU.css(HEIGHT,HU.getDimension(maxHeight), WIDTH,'100%','position','relative','margin-top','4px')]);
		html+=HU.div([STYLE,HU.css('position','absolute','left','0px','right','0px','top','50%','border-top','1px solid #ccc')]);
		html+=SPACE;
		records.forEach((r,idx2)=>{
		    let v = r.getValue(f.getIndex());
		    let c = cb.getColor(v,r);
		    let darkC = Utils.pSBC(-0.25,c);
		    if(column.min == column.max) return;
		    let perc = (v-column.min)/(column.max-column.min);
		    let clazz = 'display-dotbar-dot';
		    let selected = false;
		    let style = "";
		    if(keyField && this.selectedKey) {
			if(this.selectedKey == r.getValue(keyField.getIndex())) {
			    selected = true;
			}
		    } else if(idx2==this.selectedIndex) {
			selected = true;
		    }
		    let dotBorder = "2px solid " + darkC;
		    if(this.selectedIndex>=0) {
			if(!selected) {
			    dotBorder = "1px solid " + darkC;
			    c = "rgba(200,200,200,0.2)";
			} else {
			    dotBorder = "1px solid #000";
			}
		    }
		    if(selected) {
			selectedRecord = r;
			clazz += " display-dotbar-dot-select";
		    } else {
			if(this.getFilterHighlight()) {
			    if(!r.isHighlight(this)) {
				style = HU.css('z-index','10','border','1px solid #aaa');
			    }
			}
		    }
		    perc *=100;
		    let size = dotSize;
		    if(sizeBy.field) {
			size  = 2*sizeBy.getSize(r.getData(), dotSize);
			if(size<0) return;
			style+=HU.css(HEIGHT,HU.getDimension(size),WIDTH,HU.getDimension(size));
		    }
		    let top = maxHeight/2-size/2;
		    html +=  HU.span([RECORD_INDEX,idx2,RECORD_ID, r.getId(),CLASS,clazz,STYLE,HU.css('border',dotBorder, "background",c,"position",'absolute','top',HU.getDimension(top),'left', perc+'%')+style, RECORD_INDEX,idx2, TITLE,""]); 
		});

		html += HU.close(DIV,TD);
		html += HU.td([WIDTH, (dotSize*2)]);
		html += HU.td([ALIGN,"right", WIDTH,"5%"],HU.div([STYLE,HU.css('margin-left','10px')],this.formatNumber(column.max)));
		html+=HU.close(TR);
	    });
	    let t2 = new Date();
	    html+=HU.close(TABLE);
	    this.setContents(html); 
	    let t3 = new Date();
	    let dots = this.find(".display-dotbar-dot");
	    let t4 = new Date();
	    let _this = this;
	    dots.mouseleave(function() {
		dots.removeClass("display-dotbar-dot-highlight");
	    });
	    dots.mouseover(function() {
		let idx = $(this).attr(RECORD_INDEX);
		dots.removeClass("display-dotbar-dot-highlight");
		_this.find("[" + RECORD_INDEX+"=\"" + idx+"\"]").addClass( "display-dotbar-dot-highlight");
	    });
	    dots.click(function() {
		let idx = $(this).attr(RECORD_INDEX);
		let record = records[idx];
		if(!record) return;
		dots.removeClass("display-dotbar-dot-select");
		if(_this.selectedIndex ==  idx) {
		    _this.selectedIndex =  -1;
		    _this.updateUI();
		    return;
		}
		_this.selectedIndex =  idx;
		if(keyField)
		    _this.selectedKey = record.getValue(keyField.getIndex());
		_this.find("[" + RECORD_INDEX+"=\"" + idx+"\"]").addClass( "display-dotbar-dot-select");
		_this.hadClick = true;
		_this.propagateEventRecordSelection({record: record});
		_this.updateUI();
	    });	    //Do this later so other displays get this after they apply their data filter change
	    if(selectedRecord){
		setTimeout(()=>{
		    this.propagateEventRecordSelection({record: selectedRecord});
		},10);
	    }
	    this.makeTooltips(dots,records,null);
	    let t5 = new Date();
	    //	    Utils.displayTimes("t",[t1,t2,t3,t4,t5]);

	}
    });
}




function RamaddaDategridDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_DATEGRID, properties);
    $.extend(this, SUPER);
    addRamaddaDisplay(this);
    let myProps = [
	{label:'Date Box'},
	{p:'groupField'},
	{p:'boxSize',d:16},
	{p:'showStats',ex:'true',d:true,tt:'show starts per row'},
	{p:'showTotal',ex:'true',d:true,tt:'show the totals'},
	{p:'showMin',ex:'true',d:true,tt:'show min'},
	{p:'showMax',ex:'true',d:true,tt:'show max'},
	{p:'showAverage',ex:'true',d:false,tt:'show average'},				
	{p:'leftWidth',tt:'width of left column',d:'100px'},
	{p:'rightWidth',tt:'width of right column',d:'100px'},
 	{p:'leftLabel',tt:'Label for the left column'},
 	{p:'rightLabel',tt:'Label for the left column',d:'Total/Min/Max'},	
	{p:'dateHeaderStyle',tt:'Style to use for the date header'},
	{p:'dateStride',d:-1,tt:'The stride in hours to display the date label'},	
	{p:'numLabels',d:8,tt:'Hour many date labels to show if no dateStride given'},	
	{p:'boxStyle',tt:'Style to use for color boxes'},
	{p:'leftStyle',tt:'Style to use for left column'},
	{p:'rightStyle',tt:'Style to use for right column'},			

    ];
    this.defineSizeByProperties();
    defineDisplay(this, SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let groupField = this.getFieldById(null,this.getPropertyGroupField());
	    let size = this.getBoxSize();
	    let cats =[];
	    let colorBy = this.getColorByInfo(records);
	    let minDate= null, maxDate=null;
	    records.forEach(r=>{
		if(!minDate) {
		    minDate = maxDate = r.getDate();
		} else {
		    let d = r.getDate();
		    minDate = d.getTime()<minDate.getTime()?d:minDate;
		    maxDate = d.getTime()>maxDate.getTime()?d:maxDate;		    
		}
		let v = r.getValue(groupField.getIndex());
		let cat = cats[v];
		if(cat == null) {
		    cat = {
			records:[]
		    };
		    cats[v] = cat;
		}
		cat.records.push(r);
	    });
	    if(!this.dateFormat)
		this.dateFormat =  this.getProperty("dateFormat", "ddd mm/dd");
	    let showStats = this.getShowStats();
	    let leftWidth = HU.getDimension(this.getLeftWidth());
	    let rightWidth = HU.getDimension(this.getRightWidth());	    
	    let html = "";
	    let width = 400;
	    let dateRange = maxDate.getTime()-minDate.getTime();

	    let scaleX = d=>{
		return  (d.getTime()-minDate.getTime())/dateRange;
	    };
	    let height = "1.5em";
	    html="<div class=display-dategrid-table><table width=100% border=0 cellpadding=0 cellspacing=0>";

	    html+="<tr><td width='" + leftWidth+"'>" + HU.div([CLASS,"display-dategrid-header"],this.getLeftLabel(this.getFieldLabel(groupField))) +"</td>";
	    let dateHeaderStyle = this.getDateHeaderStyle("background:#eee;border-bottom:1px solid #888;");
	    let boxStyle = this.getBoxStyle("");
	    let leftStyle = this.getLeftStyle("");
	    let rightStyle = this.getRightStyle("");	    	    
	    let dateHeader = HU.open("div",[CLASS,'display-dategrid-dateheader',STYLE,dateHeaderStyle]) + SPACE;
	    let date  = minDate;
	    let dateStride = this.getDateStride(-1);
	    let dateDelta;
	    if(dateStride>0) {
		dateDelta = dateStride*1000*60*60;
	    } else {
		let hours = Math.round((maxDate.getTime()- minDate.getTime())/1000/60/60);
		let numLabels = this.getNumLabels();
		let hoursPerLabel =Math.round(hours/numLabels);
		dateDelta = hoursPerLabel*1000*60*60;
	    }
	    let rem =  minDate.getTime()%dateDelta;
	    date = new Date(minDate.getTime()-rem+dateDelta);

	    while(date.getTime()<=maxDate.getTime()) {
		let perc = (100*scaleX(date))+"%";
		let style = HU.css("left",perc,"top","0%","transform","translate(-50%, 0%)");
		dateHeader+=HU.div([CLASS,"display-dategrid-header display-dategrid-date",STYLE,style],this.formatDate(date))+"\n";

		date = new Date(date.getTime() +dateDelta);
	    }
	    dateHeader +="</div>";

	    html+=HU.td([],dateHeader);
	    if(showStats) {
		let dflt = [];
		if(this.getShowTotal()) dflt.push("Total");
		if(this.getShowMin()) dflt.push("Min");
		if(this.getShowMax()) dflt.push("Max");
		if(this.getShowAverage()) dflt.push("Avg");
		html+="<td width='" + rightWidth + "'>" + HU.div([CLASS,"display-dategrid-header display-dategrid-stats"], this.getRightLabel(Utils.join(dflt,"/"))) +"</td>";
	    }
	    html +="</tr>"
	    Object.keys(cats).sort(v=>{
		let cat = cats[v];
		let row = HU.open("div",[CLASS,"display-dategrid-row", STYLE,HU.css('height',height)]);
		let sorted = cat.records.sort((a,b)=>{
		    return a.getTime()-b.getTime();
		});
		let total = 0;
		let min=NaN;
		let max=NaN;
		
		for(let i=0;i<sorted.length;i++) {
		    let r = sorted[i];
		    let perc = scaleX(r.getDate());
		    let next = sorted[i+1];
		    let boxWidth="10p";
		    let right = perc+0.05;
		    if(next) {
			let nperc = scaleX(next.getDate());
			let diff = nperc - perc;
			right = (1-nperc);
		    }
		    perc = 100*perc+"%";
		    right = 100*right+"%";
		    let color =  colorBy.getColorFromRecord(r);
		    let cv = r.getValue(colorBy.index);
		    if(!isNaN(cv)) {
			total+=cv;
			min = Utils.min(min,cv);
			max = Utils.max(max,cv);			
		    }
		    row+=HU.div(["foo","bar", RECORD_ID,r.getId(),CLASS,"display-dategrid-box",TITLE,cv,STYLE,HU.css("left",perc,"right",right, "height",height,"background",color)+boxStyle],"&nbsp;");
		}
		row+="</div>\n";
		html+="<tr><td width='"+ leftWidth+"'>" +HU.div([STYLE,leftStyle,CLASS,"display-dategrid-rowlabel"], v)+"</td><td>" + row +"</td>"
		if(showStats) {
		    let stats = [];
		    if(this.getShowTotal())
			stats.push(this.formatNumber(total));
		    if(this.getShowMin())
			stats.push(this.formatNumber(min,null));
		    if(this.getShowMax())
			stats.push(this.formatNumber(max));


		    if(this.getShowAverage())
			stats.push(this.formatNumber(total/sorted.length));		    		    		    
		    html+=HU.td(["nowrap","true"],HU.div([STYLE, rightStyle,CLASS,"display-dategrid-stats"],Utils.join(stats,SPACE)));
		}
		html+="</tr>";
	    });
	    html += "</table></div>";
	    this.setContents(html); 
	    this.boxes = this.find(".display-dategrid-box");
	    this.addFieldClickHandler(this.boxes, records,false);
	    this.makeTooltips(this.boxes,records,null);
	    this.recordMap = this.makeIdToRecords(records);
	    this.records = records;
	    colorBy.displayColorTable();
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    if(!this.boxes) {
		return;
	    }
	    let matched = [];
	    let record = this.recordMap[args.record.getId()];
	    if(record) {
		matched.push(record);
	    } else {
		matched = this.findMatchingDates(args.record.getDate(), this.filteredRecords);
	    }
	    if(matched.length==0) {
		console.log("none");
		return;
	    }
	    this.boxes.removeClass("display-dategrid-box-highlight");
	    let boxMap ={};
	    this.boxes.each(function() {
		boxMap[$(this).attr(RECORD_ID)] = $(this);
	    });
	    matched.forEach(record=>{
		let box =  boxMap[record.getId()];
		if(box) box.addClass("display-dategrid-box-highlight");
	    });


	}
    });
}

/**
Copyright 2008-2021 Geode Systems LLC
*/



function RamaddaXlsDisplay(displayManager, id, properties) {

    var COORD_X = "xaxis";
    var COORD_Y = "yaxis";
    var COORD_GROUP = "group";


    var ID_SEARCH = "search";
    var ID_SEARCH_PREFIX = "table";
    var ID_SEARCH_EXTRA = "searchextra";
    var ID_SEARCH_HEADER = "searchheader";
    var ID_RESULTS = "results";
    var ID_DOWNLOADURL = "downloadurl";
    var ID_CONTENTS = "tablecontents";
    var ID_SEARCH_DIV = "searchdiv";
    var ID_SEARCH_FORM = "searchform";
    var ID_SEARCH_TEXT = "searchtext";
    var ID_TABLE_HOLDER = "tableholder";
    var ID_TABLE = "table";
    var ID_CHARTTOOLBAR = "charttoolbar";
    var ID_CHART = "chart";

    RamaddaUtil.inherit(this, new RamaddaDisplay(displayManager, id, "xls", properties));
    addRamaddaDisplay(this);


    this.url = properties.url;
    this.tableProps = {
        fixedRowsTop: 0,
        fixedColumnsLeft: 0,
        rowHeaders: true,
        colHeaders: true,
        headers: null,
        skipRows: 0,
        skipColumns: 0,
    };
    if (properties != null) {
        $.extend(this.tableProps, properties);
    }


    RamaddaUtil.defineMembers(this, {
        initDisplay: function() {
            this.createUI();
            this.setDisplayTitle("Table Data");
            var body =
                HtmlUtils.div(["id", this.getDomId(ID_SEARCH_HEADER)]) +
                HtmlUtils.div(["id", this.getDomId(ID_TABLE_HOLDER)]) +
                HtmlUtils.div(["id", this.getDomId(ID_CHARTTOOLBAR)]) +
                HtmlUtils.div(["id", this.getDomId(ID_CHART)]);
            this.setContents(body);
            this.loadTableData(this.url);
        },
    });


    RamaddaUtil.defineMembers(this, {
        currentSheet: 0,
        currentData: null,
        columnLabels: null,
        startRow: 0,
        groupIndex: -1,
        xAxisIndex: -1,
        yAxisIndex: -1,
        header: null,
        cellSelected: function(row, col) {
            this.startRow = row;
            if (this.jq("params-xaxis-select").attr("checked")) {
                this.xAxisIndex = col;
            } else if (this.jq("params-group-select").attr("checked")) {
                this.groupIndex = col;
            } else {
                this.yAxisIndex = col;
            }
            var label = "";
            var p1 = "";
            var p2 = "";

            this.setAxisLabel(COORD_X, this.getHeading(this.xAxisIndex, true));
            this.setAxisLabel(COORD_GROUP, this.getHeading(this.groupIndex, true));
            this.setAxisLabel(COORD_Y, this.getHeading(this.yAxisIndex, true));
        },
        getAxisLabelId: function(root) {
            return "params-" + root + "-label"
        },
        setAxisLabel: function(fieldId, lbl) {
            fieldId = this.getAxisLabelId(fieldId);
            var id = HtmlUtils.getUniqueId();
            if (lbl.length > 25) {
                lbl = lbl.substring(0, 25) + "...";
            }
            if (lbl.trim() != "") {
                lbl = HtmlUtils.span(["id", id, "class", "ramadda-tag-box"], "&nbsp;&nbsp;" + lbl + "&nbsp;&nbsp;");
            }
            this.jq(fieldId).html(lbl);
        },
        loadSheet: function(sheetIdx) {

            var all = $("[id^=" + this.getDomId("sheet_") + "]");
            var sel = $("#" + this.getDomId("sheet_") + sheetIdx);

            all.css('font-weight', 'normal');
            sel.css('font-weight', 'bold');

            all.css('border', '1px #ccc solid');
            sel.css('border', '1px #666 solid');

            this.currentSheet = sheetIdx;
            var sheet = this.sheets[sheetIdx];
	    let rows;
            if (sheet) {
                rows = sheet.rows.slice(0);
                if (rows.length > 0) {
                    this.header = rows[0];
                }
            }

	    if(!rows) {
		this.displayHtml(this.getMessage("No data"));
		return;
	    }
            var html = "";
            var _this = this;
            var args = {
                contextMenu: true,
                stretchH: 'all',
                colHeaders: true,
                rowHeaders: true,
                minSpareRows: 1,
                afterSelection: function() {
                    if (arguments.length > 2) {
                        for (var i = 0; i < arguments.length; i++) {
                            //                                console.log("a[" + i +"]=" + arguments[i]);
                        }
                        var row = arguments[0];
                        var col = arguments[1];
                        _this.cellSelected(row, col);
                    }
                },
            };
            $.extend(args, this.tableProps);
            if (this.tableProps.useFirstRowAsHeader) {
                var headers = rows[0];
                args.colHeaders = headers;
                rows = rows.splice(1);
            }
            for (var i = 0; i < this.tableProps.skipRows; i++) {
                rows = rows.splice(1);
            }

            if (rows.length == 0) {
                this.displayMessage("No data found");
                this.jq(ID_RESULTS).html("");
                return;
            }

            this.jq(ID_RESULTS).html("Found: " + rows.length);
            args.data = rows;
            this.currentData = rows;

            if (this.tableProps.headers != null) {
                args.colHeaders = this.tableProps.headers;
            }

            if (this.getProperty("showTable", true)) {
                this.jq(ID_TABLE).handsontable(args);
            }

        },
        getDataForSheet: function(sheetIdx, args) {
            var sheet = this.sheets[sheetIdx];
            var rows = sheet.rows.slice(0);
            if (rows.length > 0) {
                this.header = rows[0];
            }

            if (this.tableProps.useFirstRowAsHeader) {
                var headers = rows[0];
                if (args) {
                    args.colHeaders = headers;
                }
                rows = rows.splice(1);
            }
            for (var i = 0; i < this.tableProps.skipRows; i++) {
                rows = rows.splice(1);
            }
            return rows;
        },

        makeChart: function(chartType, props) {
            if (typeof google == 'undefined') {
                this.jq(ID_CHART).html("No google chart available");
                return;
            }

            if (props == null) props = {};
            var xAxisIndex = Utils.getDefined(props.xAxisIndex, this.xAxisIndex);
            var groupIndex = Utils.getDefined(props.groupIndex, this.groupIndex);
            var yAxisIndex = Utils.getDefined(props.yAxisIndex, this.yAxisIndex);

            //                console.log("y:" + yAxisIndex +" props:" + props.yAxisIndex);

            if (yAxisIndex < 0) {
                alert("You must select a y-axis field.\n\nSelect the desired axis with the radio button.\n\nClick the column in the table to chart.");
                return;
            }

            var sheetIdx = this.currentSheet;
            if (!(typeof props.sheet == "undefined")) {
                sheetIdx = props.sheet;
            }

            var rows = this.getDataForSheet(sheetIdx);
            if (rows == null) {
                this.jq(ID_CHART).html("There is no data");
                return;
            }


            //remove the first header row
            var rows = rows.slice(1);

            for (var i = 0; i < this.startRow - 1; i++) {
                rows = rows.slice(1);
            }

            var subset = [];
            console.log("x:" + xAxisIndex + " " + " y:" + yAxisIndex + " group:" + groupIndex);
            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var row = [];
                var idx = 0;
                if (xAxisIndex >= 0) {
                    row.push(rows[rowIdx][xAxisIndex]);
                } else {
                    row.push(rowIdx);
                }
                if (yAxisIndex >= 0) {
                    row.push(rows[rowIdx][yAxisIndex]);
                }
                subset.push(row);
                if (rowIdx < 2)
                    console.log("row:" + row);
            }
            rows = subset;

            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var cols = rows[rowIdx];


                for (var colIdx = 0; colIdx < cols.length; colIdx++) {
                    var value = cols[colIdx] + "";
                    cols[colIdx] = parseFloat(value.trim());
                }
            }


            var lbl1 = this.getHeading(xAxisIndex, true);
            var lbl2 = this.getHeading(yAxisIndex, true);
            var lbl3 = this.getHeading(groupIndex, true);
            this.columnLabels = [lbl1, lbl2];


            var labels = this.columnLabels != null ? this.columnLabels : ["Field 1", "Field 2"];
            rows.splice(0, 0, labels);
            /*
            for(var rowIdx=0;rowIdx<rows.length;rowIdx++) {
                var cols = rows[rowIdx];
                var s = "";
                for(var colIdx=0;colIdx<cols.length;colIdx++) {
                    if(colIdx>0)
                        s += ", ";
                    s += "'" +cols[colIdx]+"'" + " (" + (typeof cols[colIdx]) +")";
                }
                console.log(s);
                if(rowIdx>5) break;
            }
            */

            var dataTable = google.visualization.arrayToDataTable(rows);
            var chartOptions = {};
            var width = "95%";
            $.extend(chartOptions, {
                legend: {
                    position: 'top'
                },
            });

            if (this.header != null) {
                if (xAxisIndex >= 0) {
                    chartOptions.hAxis = {
                        title: this.header[xAxisIndex]
                    };
                }
                if (yAxisIndex >= 0) {
                    chartOptions.vAxis = {
                        title: this.header[yAxisIndex]
                    };
                }
            }

            var chartDivId = HtmlUtils.getUniqueId();
            var divAttrs = ["id", chartDivId];
            if (chartType == "scatterplot") {
                divAttrs.push("style");
                divAttrs.push("width: 450px; height: 450px;");
            }
            this.jq(ID_CHART).append(HtmlUtils.div(divAttrs));

            if (chartType == "barchart") {
                chartOptions.chartArea = {
                    left: 75,
                    top: 10,
                    height: "60%",
                    width: width
                };
                chartOptions.orientation = "horizontal";
                this.chart = new google.visualization.BarChart(document.getElementById(chartDivId));
            } else if (chartType == "table") {
                this.chart = new google.visualization.Table(document.getElementById(chartDivId));
            } else if (chartType == "motion") {
                this.chart = new google.visualization.MotionChart(document.getElementById(chartDivId));
            } else if (chartType == "scatterplot") {
                chartOptions.chartArea = {
                    left: 50,
                    top: 30,
                    height: 400,
                    width: 400
                };
                chartOptions.legend = 'none';
                chartOptions.axisTitlesPosition = "in";
                this.chart = new google.visualization.ScatterChart(document.getElementById(chartDivId));
            } else {
                $.extend(chartOptions, {
                    lineWidth: 1
                });
                chartOptions.chartArea = {
                    left: 75,
                    top: 10,
                    height: "60%",
                    width: width
                };
                this.chart = new google.visualization.LineChart(document.getElementById(chartDivId));
            }
            if (this.chart != null) {
                this.chart.draw(dataTable, chartOptions);
            }
        },

        addNewChartListener: function(makeChartId, chartType) {
            var _this = this;
            $("#" + makeChartId + "-" + chartType).button().click(function(event) {
                console.log("make chart:" + chartType);
                _this.makeChart(chartType);
            });
        },

        makeSheetButton: function(id, index) {
            var _this = this;
            $("#" + id).button().click(function(event) {
                _this.loadSheet(index);
            });
        },
        clear: function() {
            this.jq(ID_CHART).html("");
            this.startRow = 0;
            this.groupIndex = -1;
            this.xAxisIndex = -1;
            this.yAxisIndex = -1;
            this.setAxisLabel(COORD_GROUP, "");
            this.setAxisLabel(COORD_X, "");
            this.setAxisLabel(COORD_Y, "");
        },
        getHeading: function(index, doField) {
            if (index < 0) return "";
            if (this.header != null && index >= 0 && index < this.header.length) {
                var v = this.header[index];
                v = v.trim();
                if (v.length > 0) return v;
            }
            if (doField)
                return "Field " + (index + 1);
            return "";
        },
        showTableData: function(data) {
            var _this = this;

            this.data = data;
            this.sheets = this.data.sheets;
            this.columns = data.columns;



            var buttons = "";
            for (var sheetIdx = 0; sheetIdx < this.sheets.length; sheetIdx++) {
                var id = this.getDomId("sheet_" + sheetIdx);
                buttons += HtmlUtils.div(["id", id, "class", "ramadda-xls-button-sheet"],
                    this.sheets[sheetIdx].name);

                buttons += "\n";
            }

            var weight = "12";

            var tableHtml = "<table width=100% style=\"max-width:1000px;\" > ";
            if (this.sheets.length > 1) {
                weight = "10";
            }

            tableHtml += "<tr valign=top>";

            if (this.sheets.length > 1) {
                //                    tableHtml += HtmlUtils.openTag(["class","col-md-2"]);
                tableHtml += HtmlUtils.td(["width", "140"], HtmlUtils.div(["class", "ramadda-xls-buttons"], buttons));
                weight = "10";
            }


            var makeChartId = HtmlUtils.getUniqueId();

            var tableWidth = this.getProperty("tableWidth", "");
            var tableHeight = this.getProperty("tableHeight", "500px");

            var style = "";
            if (tableWidth != "") {
                style += " width:" + tableWidth + ";";
            }
            style += " height: " + tableHeight + ";";
            style += " overflow: auto;";
            tableHtml += HtmlUtils.td([], HtmlUtils.div(["id", this.getDomId(ID_TABLE), "class", "ramadda-xls-table", "style", style]));


            tableHtml += "</tr>";
            tableHtml += "</table>";

            var chartToolbar = "";
            var chartTypes = ["barchart", "linechart", "scatterplot"];
            for (var i = 0; i < chartTypes.length; i++) {
                chartToolbar += HtmlUtils.div(["id", makeChartId + "-" + chartTypes[i], "class", "ramadda-xls-button"], "Make " + chartTypes[i]);
                chartToolbar += "&nbsp;";
            }

            chartToolbar += "&nbsp;";
            chartToolbar += HtmlUtils.div(["id", this.getDomId("removechart"), "class", "ramadda-xls-button"], "Clear Charts");


            chartToolbar += "<p>";
            chartToolbar += "<form>Fields: ";
            chartToolbar += "<input type=radio checked name=\"param\" id=\"" + this.getDomId("params-yaxis-select") + "\"> y-axis:&nbsp;" +
                HtmlUtils.div(["id", this.getDomId("params-yaxis-label"), "style", "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "&nbsp;&nbsp;&nbsp;";
            chartToolbar += "<input type=radio  name=\"param\" id=\"" + this.getDomId("params-xaxis-select") + "\"> x-axis:&nbsp;" +
                HtmlUtils.div(["id", this.getDomId("params-xaxis-label"), "style", "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "&nbsp;&nbsp;&nbsp;";
            chartToolbar += "<input type=radio  name=\"param\" id=\"" + this.getDomId("params-group-select") + "\"> group:&nbsp;" +
                HtmlUtils.div(["id", this.getDomId("params-group-label"), "style", "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "</form>";

            if (this.getProperty("showSearch", true)) {
                var results = HtmlUtils.div(["style", "display:inline-block;", "id", this.getDomId(ID_RESULTS)], "");
                var download = HtmlUtils.div(["style", "display:inline-block;", "id", this.getDomId(ID_DOWNLOADURL)]);
                var searchDiv = HtmlUtils.div(["id", this.getDomId(ID_SEARCH_DIV), "class", "ramadda-xls-search-form"]);


                var search = "";
                search += HtmlUtils.openTag("form", ["action", "#", "id", this.getDomId(ID_SEARCH_FORM)]);
                search += HtmlUtils.image(icon_tree_closed, ["id", this.getDomId(ID_SEARCH + "_open")]);
                search += "\n";
                search += HtmlUtils.input(ID_SEARCH_TEXT, this.jq(ID_SEARCH_TEXT).val(), ["size", "60", "id", this.getDomId(ID_SEARCH_TEXT), "placeholder", "Search"]);
                search += "<input type=submit name='' style='display:none;'>";

                search += HtmlUtils.openTag("div", ["id", this.getDomId(ID_SEARCH_EXTRA), "class", "ramadda-xls-search-extra"], "");
                if (this.columns) {
                    var extra = HtmlUtils.openTag("table", ["class", "formtable"]);
                    for (var i = 0; i < this.columns.length; i++) {
                        var col = this.columns[i];
                        var id = ID_SEARCH_PREFIX + "_" + col.name;
                        var widget = HtmlUtils.input(id, this.jq(id).val(), ["id", this.getDomId(id), "placeholder", "Search"]);
                        extra += HtmlUtils.formEntry(col.name.replace("_", " ") + ":", widget);
                    }
                    extra += HtmlUtils.closeTag("table");
                    search += extra;
                }


                if (this.searchFields) {
                    var extra = HtmlUtils.openTag("table", ["class", "formtable"]);
                    for (var i = 0; i < this.searchFields.length; i++) {
                        var col = this.searchFields[i];
                        var id = ID_SEARCH_PREFIX + "_" + col.name;
                        var widget = HtmlUtils.input(id, this.jq(id).val(), ["id", this.getDomId(id), "placeholder", "Search"]);
                        extra += HtmlUtils.formEntry(col.label + ":", widget);
                    }
                    extra += HtmlUtils.closeTag("table");
                    search += extra;
                }




                search += "\n";
                search += HtmlUtils.closeTag("div");
                search += "\n";
                search += HtmlUtils.closeTag("form");

                this.jq(ID_SEARCH_HEADER).html(HtmlUtils.leftRight(searchDiv, results + " " + download));

                this.jq(ID_SEARCH_DIV).html(search);

                if (!this.extraOpen) {
                    this.jq(ID_SEARCH_EXTRA).hide();
                }


                this.jq(ID_SEARCH + "_open").button().click(function(event) {
                    _this.jq(ID_SEARCH_EXTRA).toggle();
                    _this.extraOpen = !_this.extraOpen;
                    if (_this.extraOpen) {
                        _this.jq(ID_SEARCH + "_open").attr("src", icon_tree_open);
                    } else {
                        _this.jq(ID_SEARCH + "_open").attr("src", icon_tree_closed);
                    }
                });

            }


            if (this.getProperty("showTable", true)) {
                this.jq(ID_TABLE_HOLDER).html(tableHtml);
                chartToolbar += "<br>";
                if (this.getProperty("showChart", true)) {
                    this.jq(ID_CHARTTOOLBAR).html(chartToolbar);
                }
            }

            if (this.getProperty("showSearch", true)) {
                this.jq(ID_SEARCH_FORM).submit(function(event) {
                    event.preventDefault();
                    _this.loadTableData(_this.url, "Searching...");
                });
                this.jq(ID_SEARCH_TEXT).focus();
                this.jq(ID_SEARCH_TEXT).select();
            }


            for (var i = 0; i < chartTypes.length; i++) {
                this.addNewChartListener(makeChartId, chartTypes[i]);
            }
            this.jq("removechart").button().click(function(event) {
                _this.clear();
            });

            for (var sheetIdx = 0; sheetIdx < this.sheets.length; sheetIdx++) {
                var id = this.getDomId("sheet_" + sheetIdx);
                this.makeSheetButton(id, sheetIdx);
            }
            var sheetIdx = 0;
            var rx = /sheet=([^&]+)/g;
            var arr = rx.exec(window.location.search);
            if (arr) {
                sheetIdx = arr[1];
            }
            this.loadSheet(sheetIdx);


            if (this.defaultCharts) {
                for (var i = 0; i < this.defaultCharts.length; i++) {
                    var dflt = this.defaultCharts[i];
                    this.makeChart(dflt.type, dflt);
                }
            }
            this.setAxisLabel("params-yaxis-label", this.getHeading(this.yAxisIndex, true));

            this.displayDownloadUrl();

        },
        displayMessage: function(msg, icon) {
            if (!icon) {
                icon = icon_information;
            }
            var html = HtmlUtils.hbox([HtmlUtils.image(icon, ["align", "left"]),
                HtmlUtils.inset(msg, 10, 10, 5, 10)]);
            html = HtmlUtils.div(["class", "note"], html);
            this.jq(ID_TABLE_HOLDER).html(html);
        },
        displayDownloadUrl: function() {
            var url = this.lastUrl;
            if (url == null) {
                this.jq(ID_DOWNLOADURL).html("");
                return
            }
            url = url.replace("xls_json", "media_tabular_extractsheet");
            url += "&execute=true";
            var img = HtmlUtils.image(ramaddaBaseUrl + "/icons/xls.png", ["title", "Download XLSX"]);
            this.jq(ID_DOWNLOADURL).html(HtmlUtils.href(url, img));
        },
        loadTableData: function(url, message) {
            this.url = url;
            if (!message) message = this.getLoadingMessage();
            this.displayMessage(message, icon_progress);
            var _this = this;

            var text = this.jq(ID_SEARCH_TEXT).val();
            if (text && text != "") {
                url = url + "&table.text=" + encodeURIComponent(text);
            }
            if (this.columns) {
                for (var i = 0; i < this.columns.length; i++) {
                    var col = this.columns[i];
                    var id = ID_SEARCH_PREFIX + "_" + col.name;
                    var text = this.jq(id).val();
                    if (text) {
                        url = url + "&table." + col.name + "=" + encodeURIComponent(text);
                    }
                }
            }

            if (this.searchFields) {
                for (var i = 0; i < this.searchFields.length; i++) {
                    var col = this.searchFields[i];
                    var id = ID_SEARCH_PREFIX + "_" + col.name;
                    var text = this.jq(id).val();
                    if (text) {
                        url = url + "&table." + col.name + "=" + encodeURIComponent(text);
                    }
                }
            }

            this.lastUrl = url;

	    let  load = async function() {
		if(!this.loadedJS) {
		    await Utils.importJS(ramaddaBaseHtdocs + "/lib/jquery.handsontable.full.min.js");
		    await Utils.importCSS(ramaddaBaseHtdocs + "/lib/jquery.handsontable.full.min.css");
		    this.loadedJS = true;
		}
		var jqxhr = $.getJSON(url, function(data) {
                    if (GuiUtils.isJsonError(data)) {
                        _this.displayMessage("Error: " + data.error);
                        return;
                    }
		    try {
			_this.showTableData(data);

		    } catch(exc) {
                        _this.displayMessage("Error: " + exc);
			this.handleError("Error:" + exc, exc);
		    }
                })
                .fail(function(jqxhr, textStatus, error) {
                    var err = textStatus + ", " + error;
                    _this.displayMessage("An error occurred: " + error);
                    console.log("JSON error:" + err);
                });
	    }
	    load();
	}
    });

}
/**
   Copyright 2008-2021 Geode Systems LLC
*/


const DISPLAY_PLOTLY_RADAR = "radar";
const DISPLAY_PLOTLY_WINDROSE = "windrose";
const DISPLAY_PLOTLY_DENSITY = "density";
const DISPLAY_PLOTLY_DOTPLOT = "dotplot";
const DISPLAY_PLOTLY_SPLOM = "splom";
const DISPLAY_PLOTLY_PROFILE = "profile";
const DISPLAY_PLOTLY_3DSCATTER = "3dscatter";
const DISPLAY_PLOTLY_3DMESH = "3dmesh";
const DISPLAY_PLOTLY_TREEMAP = "ptreemap";
const DISPLAY_PLOTLY_TERNARY = "ternary";
const DISPLAY_PLOTLY_SUNBURST= "sunburst";
const DISPLAY_PLOTLY_TEXTCOUNT = "textcount";
const DISPLAY_PLOTLY_COMBOCHART = "combochart";
const DISPLAY_PLOTLY_PARCOORDS = "parcoords";

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_RADAR,
    label: "Radar",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_WINDROSE,
    label: "Wind Rose",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_SUNBURST,
    label: "Sunburst",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"sunburst.png")                            
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_DENSITY,
    label: "Density",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_COMBOCHART,
    label: "Combo Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"combochart.png")                        
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_PARCOORDS,
    label: "Parallel Coords",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_DOTPLOT,
    label: "Dot Plot",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"dotplot.png")                    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_SPLOM,
    label: "Splom",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip("A scatterplot matrix","splom.png")    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_3DSCATTER,
    label: "3D Scatter",
    requiresData: true,
    forUser: false,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_PROFILE,
    label: "Profile",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"profile.png")                    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_3DMESH,
    label: "3D Mesh",
    requiresData: false,
    forUser: false,
    category: CATEGORY_RADIAL_ETC
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_TEXTCOUNT,
    label: "Text Count",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Shows counts of certain patterns","textcount.png","Given a text field show the number of <br>times certain word patterns occur")                                    
});

//Ternary doesn't work
//addGlobalDisplayType({type: DISPLAY_PLOTLY_TERNARY, label:"Ternary",requiresData:true,forUser:true,category:CATEGORY_RADIAL_ETC});
//Treempap doesn't work
//addGlobalDisplayType({type: DISPLAY_PLOTLY_PTREEMAP, label:"Tree Map",requiresData:true,forUser:true,category:CATEGORY_RADIAL_ETC});


function RamaddaPlotlyDisplay(displayManager, id, type, properties) {
    const ID_PLOTY = "plotly";
    let SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    //Dynamically load plotly
    if(!window.Plotly) {
	let url = ramaddaBaseUrl+"/lib/plotly/plotly-latest.min.js";
        var imports = "<script src='" + url+"'></script>";
        $(imports).appendTo("head");
    }
    RamaddaUtil.inherit(this, SUPER);
    RamaddaUtil.defineMembers(this, {
	getRequirement:function() {
	    return "Plotly";
	},
        needsData: function() {
            return true;
        },
        setDimensions: function(layout, widthDelta) {
            //                var width  = parseInt(this.getProperty("width","400").replace("px","").replace("%",""));
            var height = parseInt(this.getProperty("height", "400").replace("px", "").replace("%", ""));
            //                layout.width = width-widthDelta;
            layout.height = height;
	    if(!layout.margin) layout.margin={};
	    [["l","marginLeft"],["r","marginRight"],["t","marginTop"],["b","marginBottom"]].map(t=>{
		if(Utils.isDefined(this.getProperty(t[1])))
		    layout.margin[t[0]]  = this.getProperty(t[1]);
	    });

        },
        pointDataLoaded: function(pointData, url, reload) {
            SUPER.pointDataLoaded.call(this, pointData, url, reload);
	    /*
              if (this.dataCollection)
              this.displayManager.propagateEventRecordSelection(this,
              this.dataCollection.getList()[0], {
              index: 0
              });
	    */

        },
        displayData: function() {
            this.updateUI();
        },
        pageHasLoaded: function() {
            SUPER.pageHasLoaded.call(this);
            this.updateUI();
        },

        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        makeAxis: function(title, tickangle) {
            return {
                title: title,
                titlefont: {
                    size: 20
                },
                tickangle: tickangle,
                tickfont: {
                    size: 15
                },
                tickcolor: 'rgba(0,0,0,0)',
                ticklen: 5,
                showline: true,
                showgrid: true
            };
        },
        getDisplayStyle: function() {
            return "";
        },
        makePlot: function(data, layout) {
            this.clearHtml();
	    let html = 
		HtmlUtils.div(["id",this.getDomId(ID_HEADER)],"") +
		HtmlUtils.div(["id", this.getDomId("tmp"), "style", this.getDisplayStyle()], "") +
		HtmlUtils.div(["id",this.getDomId(ID_FOOTER)],"");
	    this.setContents(html);
            //For some reason plotly won't display repeated times in the DISPLAY div
            var plot = Plotly.plot(this.getDomId("tmp"), data, layout,{displayModeBar: false});
            var myPlot = document.getElementById(this.getDomId("tmp"));
	    if(myPlot) {
		this.addEvents(plot, myPlot);
	    }
	    return myPlot;
        },
        handleClickEvent: function(data) {
	    if(data.points && data.points.length>0) {
		let record = data.points[0].record;
		if(!record) {
		    var index = data.points[0].pointIndex;
		    record = this.indexToRecord[index];
		}
		//		console.log("index:" + index +" record:"+  record);
		if(record) {
		    this.propagateEventRecordSelection({record: record});
		}
	    }
	},
        addEvents: function(plot, myPlot) {
	    let _this = this;
            myPlot.on('plotly_click', function(data) {
		_this.handleClickEvent(data);
            });

	}
    });
}



function RamaddaRadialDisplay(displayManager, id, type, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, type, properties));
    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'barpolar';
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) {
                return;
            }
            var fields = this.getSelectedFields(this.getData().getRecordFields());
	    var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
	    var theta;
	    var thetaType;
	    if(this.getProperty("useDates")) {
		var tmp = this.getDateValues(records);
		theta=[];
		var dateFormat = this.getProperty("dateFormat", "yyyyMMdd");
		thetaType = "category";
		tmp.map(d=>{
		    theta.push(Utils.formatDateWithFormat(d,dateFormat));
		});
	    } else {
		var thetaField = this.getFieldById(null, this.getProperty("thetaField"));
		if (thetaField) {
		    theta = this.getColumnValues(records, thetaField).values;
		}
	    }
            var values = [];
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            var plotData = [];
            for (var i = 0; i < numericFields.length; i++) {
                var field = numericFields[i];
                var column = this.getColumnValues(records, field);
		if(!theta) {
		    theta = [];
		    var cnt = 0;
		    for(var cnt=0;cnt<column.values.length;cnt++)
			theta.push(cnt*360/column.values.length);
		}
                min = Math.min(min, column.min);
                max = Math.max(max, column.max);
		var values = column.values;
                plotData.push({
                    type: this.getPlotType(),
                    r: values,
                    theta: theta,
                    fill: 'toself',
                    name: field.getLabel(),
                });
            }

            layout = {
                polar: {
                    angularaxis: {
			type:"category"
		    },
                    radialaxis: {
                        visible: true,
                        range: [min, max]
                    }
                },
            }
	    if(thetaType) {
		layout.polar.angularaxis  ={
		    type:thetaType
		};
	    }
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}

function RamaddaRadarDisplay(displayManager, id, properties) {
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaRadialDisplay(displayManager, id, DISPLAY_PLOTLY_RADAR, properties));

    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'scatterpolar';
        },
    });
    addRamaddaDisplay(this);
}

function RamaddaWindroseDisplay(displayManager, id, properties) {
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaRadialDisplay(displayManager, id, DISPLAY_PLOTLY_WINDROSE, properties));
    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'barpolar';
        },
    });
    addRamaddaDisplay(this);
}




function RamaddaDensityDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "600px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_DENSITY, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length < 2) {
                this.displayError("No numeric fields specified");
                return;
            }

            var x = this.getColumnValues(records, numericFields[0]);
            var y = this.getColumnValues(records, numericFields[1]);
            var markers = {
                x: x.values,
                y: y.values,
                mode: 'markers',
                name: "",
                marker: {
                    color: this.getProperty("pointColor", 'rgb(102,0,0)'),
                    size: parseInt(this.getProperty("markerSize", "4")),
                    opacity: 0.4
                },
                type: 'scatter'
            };
            var density = {
                x: x.values,
                y: y.values,
                name: 'density',
                ncontours: 20,
                colorscale: 'Hot',
                reversescale: true,
                type: 'histogram2dcontour'
            };
            var plotData = [];
            if (this.getProperty("showDensity", true))
                plotData.push(density);
            if (this.getProperty("showPoints", true))
                plotData.push(markers);
            var layout = {
                showlegend: true,
                autosize: true,
                margin: {
                    t: 50
                },
                hovermode: 'closest',
                bargap: 0,
                xaxis: {
                    domain: [x.min, x.max],
                    showline: this.getProperty("showLines", true),
                    showgrid: this.getProperty("showLines", true),
                    title: fields[0].getLabel()
                },
                yaxis: {
                    domain: [y.min, y.max],
                    showline: this.getProperty("showLines", true),
                    showgrid: this.getProperty("showLines", true),
                    title: fields[1].getLabel()
                },
            };
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}


function RamaddaPlotly3DDisplay(displayManager, id, type, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, type, properties));

    RamaddaUtil.defineMembers(this, {
        addEvents: function(plot, myPlot) {
            myPlot.on('plotly_click', function() {
                //                        alert('You clicked this Plotly chart!');
            });
        },

        getDisplayStyle: function() {
            return "border: 1px #ccc solid;";
        },
        get3DType: function() {
            //                'mesh3d'
            return 'scatter3d';
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var stringField = this.getFieldByType(fields, "string");
            var fields = this.getFieldsByType(fields, "numeric");
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length < 3) {
                this.displayError("Don't have 3 numeric fields specified");
                return;
            }
            var x = this.getColumnValues(records, fields[0]);
            var y = this.getColumnValues(records, fields[1]);
            var z = this.getColumnValues(records, fields[2]);

            var trace1 = {
                x: x.values,
                y: y.values,
                z: z.values,
                mode: 'markers',
                marker: {
                    size: 12,
                    line: {
                        color: 'rgba(217, 217, 217, 0.14)',
                        width: 0.5
                    },
                    opacity: 0.8
                },
                type: this.get3DType()
            };


            var plotData = [trace1];


            var layout = {
                scene: {
                    xaxis: {
                        backgroundcolor: "rgb(200, 200, 230)",
                        gridcolor: "rgb(255, 255, 255)",
                        showbackground: true,
                        zerolinecolor: "rgb(255, 255, 255)",
                        title: fields[0].getLabel(),
                    },
                    yaxis: {
                        backgroundcolor: "rgb(230, 200,230)",
                        gridcolor: "rgb(255, 255, 255)",
                        showbackground: true,
                        zerolinecolor: "rgb(255, 255, 255)",
                        title: fields[1].getLabel(),
                    },
                    zaxis: {
                        backgroundcolor: "rgb(230, 230,200)",
                        gridcolor: "rgb(255, 255, 255)",
                        showbackground: true,
                        zerolinecolor: "rgb(255, 255, 255)",
                        title: fields[2].getLabel(),
                    }
                },
                margin: {
                    l: 0,
                    r: 0,
                    b: 50,
                    t: 50,
                    pad: 4
                },
            };
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}


function Ramadda3dmeshDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "100%",
        height: "100%",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotly3DDisplay(displayManager, id, DISPLAY_PLOTLY_3DMESH, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        get3DType: function() {
            return 'mesh3d';
        },
    });
}



function Ramadda3dscatterDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "100%",
        height: "100%",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotly3DDisplay(displayManager, id, DISPLAY_PLOTLY_3DSCATTER, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        get3DType: function() {
            return 'scatter3d';
        },
    });
}



function RamaddaSunburstDisplay(displayManager, id, properties) {
    $.extend(this, {
        width: "500",
        height: "500",
    });
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_SUNBURST, properties);
    let myProps = [
	{label:'Sunburst Display'},
	{p:'parentField',ex:''},
	{p:'labelField',ex:''},
	{p:'idField',ex:''},
	{p:'valueField',ex:''},
	{p:'nodeFields',ex:''},
	{p:'treeRoot',ex:'some label'},
	{p:'doTopColors',ex:'true'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDisplayStyle: function() {
            return "";
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var parentField = this.getFieldById(null, this.getProperty("parentField"));
	    var valueField = this.getFieldById(null, this.getProperty("valueField"));
	    var labelField = this.getFieldById(null, this.getProperty("labelField"));
	    let roots=null;
	    try {
		roots = this.makeTree();
	    } catch(error) {
                this.setContents(this.getMessage(error.toString()));
		return;
	    }

	    let ids = [];
	    let labels = [];
	    let parentNodes= [];

	    let parents = [];
	    let values=[];
	    //descend and calculate values
	    let calcValue = function(node) {
		if(node.children.length==0) {
		    if(node.record) {
			var value = node.record.getValue(valueField.getIndex());
			node.value = value;
			return value;
		    }
		    return 0;
		}
		let sum = 0;
		node.children.map(child=>{
		    sum += calcValue(child);
		});
		node.value = sum;
		if(node.record){
		    node.record.setValue(valueField.getIndex(),sum);
		}
		return sum;
	    }
	    if(valueField) {
		roots.map(calcValue);
	    }
	    this.myRecords = [];
	    let recordList =  this.myRecords;
	    let makeList = function(node) {
		recordList.push(node.record);
		if(valueField)
		    values.push(node.value);
		parentNodes.push(node.parent);
		ids.push(node.id);
		labels.push(node.label);
		parents.push(node.parent==null?"":node.parent.id);
		node.children.map(makeList);
	    }
	    roots.map(makeList);
            var colors = this.getColorTable(true);
	    let doTopColors= this.getProperty("doTopColors",true);
	    if(!colors) {
		var colorMap = Utils.parseMap(this.getProperty("colorMap"));
		if(colorMap) {
		    colors = [];
		    let dfltIdx =0;
		    let dflt = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
		    ids.map((id,idx)=>{
			if(doTopColors && parentNodes[idx]!=null)  return;
			let color = colorMap[id];
			if(!color) {
			    color = colorMap[labels[idx]];
			}
			if(!color) {
			    if(dfltIdx>=dflt.length) dfltIdx = 0;
			    color = dflt[dfltIdx];
			    dfltIdx++;
			}
			colors.push(color);
		    });
		}
	    }

	    var data = [{
		type: "sunburst",
		ids:ids,
		labels: labels,
		parents: parents,
		outsidetextfont: {size: 20, color: "#377eb8"},
		leaf: {opacity: 0.4},
		marker: {
		    line: {width: 1}
		},
		branchvalues: 'total'
	    }];
	    if(valueField) {
		data[0].values = values;
	    }
	    var layout = {
		margin: {l: 0, r: 0, b: 0, t: 0},
		width: +this.getProperty("width"),
		height: +this.getProperty("height"),
	    };
	    if(colors) {
		if(!doTopColors) {
		    data[0].marker.colors = colors;
		} else {
		    layout.sunburstcolorway= colors;
		    layout.extendsunburstcolors= true;
		    layout.extendsunburstcolorway= true;
		}
	    }

	    var myPlot =  this.makePlot(data, layout);
	    myPlot.on('plotly_sunburstclick', d=>{this.handleSunburstClickEvent(d)});
        },
        handleSunburstClickEvent: function(data) {
	    if(!data.points || data.points.length<=0) {
		return;
	    }
	    var pointNumber = data.points[0].pointNumber;
	    var record = this.myRecords[pointNumber];
	    //	    console.log(pointNumber +" " + record);
	    if(record) {
		this.propagateEventRecordSelection({record: record});
	    }
	},

    });
}



function RamaddaTernaryDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TERNARY, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var stringField = this.getFieldByType(fields, "string");
            var fields = this.getFieldsByType(fields, "numeric");
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length < 3) {
                this.displayError("Don't have 3 numeric fields specified");
                return;
            }

            var rawData = [];
            var a = this.getColumnValues(records, fields[0]);
            var b = this.getColumnValues(records, fields[1]);
            var c = this.getColumnValues(records, fields[2]);
            for (var i = 0; i < a.length; i++) {
                rawData.push({
                    a: 100 * a[i] / a.max,
                    b: 100 * b[i] / b.max,
                    c: 100 * c[i] / c.max,

                    label: stringField ? stringField.getLabel() : "Point " + (i + 1)
                });
            }
            var xrawData = [{
                a: 75,
                b: 25,
                c: 0,
                label: 'point 1'
            }, {
                a: 70,
                b: 10,
                c: 20,
                label: 'point 2'
            }, {
                a: 75,
                b: 20,
                c: 5,
                label: 'point 3'
            }, {
                a: 5,
                b: 60,
                c: 35,
                label: 'point 4'
            }, {
                a: 10,
                b: 80,
                c: 10,
                label: 'point 5'
            }, {
                a: 10,
                b: 90,
                c: 0,
                label: 'point 6'
            }, {
                a: 20,
                b: 70,
                c: 10,
                label: 'point 7'
            }, {
                a: 10,
                b: 20,
                c: 70,
                label: 'point 8'
            }, {
                a: 15,
                b: 5,
                c: 80,
                label: 'point 9'
            }, {
                a: 10,
                b: 10,
                c: 80,
                label: 'point 10'
            }, {
                a: 20,
                b: 10,
                c: 70,
                label: 'point 11'
            }, ];


            var plotData = [{
                type: 'scatterternary',
                mode: 'markers',
                a: rawData.map(function(d) {
                    return d.a;
                }),
                b: rawData.map(function(d) {
                    return d.b;
                }),
                c: rawData.map(function(d) {
                    return d.c;
                }),
                text: rawData.map(function(d) {
                    return d.label;
                }),
                marker: {
                    symbol: 100,
                    color: '#DB7365',
                    size: 14,
                    line: {
                        width: 2
                    }
                },
            }];
            var layout = {
                ternary: {
                    sum: 100,
                    aaxis: this.makeAxis(fields[0].getLabel(), 0),
                    baxis: this.makeAxis(fields[1].getLabel(), 45),
                    caxis: this.makeAxis(fields[2].getLabel(), -45),
                    bgcolor: '#fff1e0'
                },
                annotations: [{
                    showarrow: false,
                    text: this.getProperty("chartTitle", ""),
                    x: 1.0,
                    y: 1.3,
                    font: {
                        size: 15
                    }
                }],
                paper_bgcolor: '#fff1e0',
            };


            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}


function RamaddaDotplotDisplay(displayManager, id, properties) {

    $.extend(this, {
        width: "600px",
        height: "400px",
    });
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_DOTPLOT, properties);
    let myProps = [
	{label:'Dotplot Display'},
	{p:'fields',ex:''},
	{p:'labelField',ex:''},	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDisplayStyle: function() {
            return "";
        },

        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
            var pointData = this.getData();
            if (pointData == null) return;
            let allFields = pointData.getRecordFields();
            let stringField = this.getFieldById(allFields,this.getLabelField());
            if (!stringField) {
		stringField = this.getFieldByType(allFields, "string");
	    }

            if (!stringField) {
                stringField = allFields[0];
            }

	    let fields   = this.getFieldsByIds(null, this.getPropertyFields("",true));
            if (fields.length == 0) {
		fields = this.getFieldsByType(allFields, "numeric");
	    }
            if (fields.length == 0) {
		fields = this.getFieldsByType(allFields, "date");
	    }
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }

            let labels = null;
            let labelName = "";
            if (stringField) {
                labels = this.getColumnValues(records, stringField).values;
                labelName = stringField.getLabel();
            }
            var colors = this.getColorTable(true);
            if (!colors)
                colors = ['rgba(156, 165, 196, 0.95)', 'rgba(204,204,204,0.95)', 'rgba(255,255,255,0.85)', 'rgba(150,150,150,0.95)']
            var plotData = [];
            var colorBy = this.getColorByInfo(records);
	    var  didColorBy = false;
            for (i in fields) {
                var color = i >= colors.length ? colors[0] : colors[i];
                var field = fields[i];
                var values = this.getColumnValues(records, field).values;
                if (colorBy.index >= 0) {
		    color = [];
		    records.map(record=>{
			var value = record.getData()[colorBy.index];
			didColorBy = true;
			color.push(colorBy.getColor(value, record));
                    })
		}
                if (!labels) {
                    labels = [];
                    for (var j = 0; j < values.length; j++) {
                        labels.push("Point " + (j + 1));
                    }
                }
                plotData.push({
                    type: 'scatter',
                    x: values,
                    y: labels,
                    mode: 'markers',
                    name: field.getLabel(),
                    marker: {
                        color: color,
                        line: {
                            color: 'rgba(156, 165, 196, 1.0)',
                            width: 1,
                        },
                        symbol: 'circle',
                        size: 16
                    }
                });
            }



            var layout = {
                title: '',
                yaxis: {
                    title: this.getProperty("yAxisTitle", labelName),
                    showline: this.getProperty("yAxisShowLine", true),
                    showgrid: this.getProperty("yAxisShowGrid", true),
                },
                xaxis: {
                    title: this.getProperty("xAxisTitle", fields[i].getLabel()),
                    showgrid: this.getProperty("xAxisShowGrid", false),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
                },
                margin: {
                    l: this.getProperty("marginLeft", 140),
                    r: this.getProperty("marginRight", 40),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 20),
                },
                legend: {
                    font: {
                        size: 10,
                    },
                    yanchor: 'middle',
                    xanchor: 'right'
                },
                paper_bgcolor: this.getProperty("chart.fill", 'rgb(254, 247, 234)'),
                plot_bgcolor: this.getProperty("chartArea.fill", 'rgb(254, 247, 234)'),
                hovermode: 'closest'
            };
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
	    if(didColorBy) {
		colorBy.displayColorTable();
	    }

        },
    });
}


function RamaddaProfileDisplay(displayManager, id, properties) {
//    if(!properties.width) properties.width="400px";
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_PROFILE, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    this.defineProperties([
	{label:'Profile Properties'},
	{p:'indexField',d:null,ex:''},
	{p:'fields',d:null,ex:''},
	{p:'profileMode',d:'lines',ex:'lines|markers|lines+markers'},
	{p:'yAxisTitle',d:'Pressure- Digiquartz',ex:''},
	{p:'yAxisShowLine',d:'true',ex:'false'},
	{p:'yAxisShowGrid',d:'true',ex:'false'},
	{p:'xAxisTitle',d:'',ex:''},
	{p:'xAxisShowGrid',d:'true',ex:'false'},
	{p:'xAxisShowLine',d:'true',ex:'false'},
	{p:'yAxisReverse',d:false,ex:'true'},
	{p:'marginLeft',d:'60',ex:'60'},
	{p:'marginRight',d:'100',ex:'100'},
	{p:'marginBottom',d:'50',ex:'50'},
	{p:'marginTop',d:'100',ex:'100'},
	{p:'showLegend',d:'true',ex:'false'},
	{p:'legendYAnchor',d:null,ex:'top|middle|bottom'},
	{p:'legendXAnchor',d:null,ex:'right|center|left'},
	{p:'chart.fill',d:'rgb(254, 247, 234)',ex:'color'},
	{p:'chartArea.fill',d:'rgb(254, 247, 234)',ex:'color'},
	{p:'xAxis2Title',d:'Conductivity',ex:''},
    ]);

    RamaddaUtil.defineMembers(this, {
        getDisplayStyle: function() {
            return "";
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
//	    this.writePropertyDef = "";
	    let indexField = this.getFieldById(null,this.getProperty("indexField"));
	    if(indexField==null) {
                this.setContents(this.getMessage("No indexField specified"));
		return;
	    }
            let fields = this.getSelectedFields(this.getData().getRecordFields());
            if (fields.length == 0) {
		let tmp = this.getFieldsByType(null, "numeric");
		if(tmp.length>0) fields.push(tmp[0]);
	    }
            if (fields.length == 0) {
                this.setContents(this.getMessage("No fields found"));
		return;
	    }
            let index = this.getColumnValues(records, indexField).values;
            let data = [];
            fields.forEach((field,idx)=>{
		let x = this.getColumnValues(records, field).values;
		let trace =   {
		    y: index,
		    x: x,
		    type: 'scatter',
		    mode: this.getProperty("profileMode",'lines'),
                    name: field.getLabel(),
                    marker: {
                        line: {
                            color: 'rgba(156, 165, 196, 1.0)',
                            width: 1,
                        },
                        symbol: 'circle',
                        size: 16
                    }
		};
		if(idx>0)
		    trace.xaxis="x2";
		data.push(trace);
	    });

	    let labelName = indexField.getLabel();
            let layout = {
                yaxis: {
		    autorange: this.getProperty("yAxisReverse",false)?"reversed":null,
                    title: this.getProperty("yAxisTitle", labelName),
                    showline: this.getProperty("yAxisShowLine", true),
                    showgrid: this.getProperty("yAxisShowGrid", true),
                },
                xaxis: {
                    title: this.getProperty("xAxisTitle", fields[0].getLabel()),
                    showgrid: this.getProperty("xAxisShowGrid", true),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
		},
                margin: {
                    l: this.getProperty("marginLeft", 60),
                    r: this.getProperty("marginRight", 100),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 100),
                },
                legend: {
                    font: {
                        size: 10,
                    },
                    yanchor: this.getProperty("legendYAnchor"),
                    xanchor: this.getProperty("legendXAnchor"),
                },
                showlegend: this.getProperty("showLegend",true),
                paper_bgcolor: this.getProperty("chart.fill", 'rgb(254, 247, 234)'),
		paper_bgcolor: this.getProperty("chart.fill", 'transparent'),		
                plot_bgcolor: this.getProperty("chartArea.fill", 'rgb(254, 247, 234)'),
                hovermode: 'closest'
            };
	    if(fields.length>1) {
                layout.xaxis2 =  {
		    overlaying: 'x', 
		    side: 'top',
                    title: this.getProperty("xAxis2Title", fields[1].getLabel()),
                    showgrid: this.getProperty("xAxisShowGrid", true),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
                };
	    }
            this.setDimensions(layout, 2);
            this.makePlot(data, layout);
	    if(this.writePropertyDef)
		console.log(this.writePropertyDef);
	    this.writePropertyDef=null;
        },
    });
}



function RamaddaSplomDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "600px",
        height: "600px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_SPLOM, properties));

    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        setDimensions: function(layout, widthDelta) {
            var width = parseInt(this.getProperty("width", "400").replace("px", "").replace("%", ""));
            var height = parseInt(this.getProperty("height", "400").replace("px", "").replace("%", ""));
            layout.width = width - widthDelta;
            layout.height = height;
        },
        makeAxis: function() {
            return {
                showline: false,
                zeroline: false,
                gridcolor: this.getProperty("gridColor", "white"),
                ticklen: 2,
                tickfont: {
                    size: this.getProperty("tickFontSize", 12)
                },
                titlefont: {
                    size: this.getProperty("titleFontSize", 12)
                }
            }
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            if (fields.length == 0) {
                fields = this.getData().getRecordFields();
            }
            var labels;
            if (this.getProperty("labels"))
                labels = this.getProperty("labels").split(",");

            var dataObj = {
                type: 'splom',
                dimensions: [],
                marker: {
                    size: parseInt(this.getProperty("markerSize", 5)),
                    line: {
                        color: this.getProperty("lineColor", 'white'),
                        width: 0.5
                    }
                }
            };


            var colorByField = this.getFieldById(fields, this.getProperty("colorBy"));
            var colorBy = this.getProperty("colorBy");
            if (colorBy) {
                var colorByField = this.getFieldById(fields, colorBy);
                if (colorByField) {
                    var obj = this.getColumnValues(records, colorByField);
                    var colors = this.getColorTable();
                    if (!colors) colors = Utils.getColorTable("blue_white_red");
                    var colorscale = [];
                    var min = parseFloat(this.getProperty("colorByMin", obj.min));
                    var max = parseFloat(this.getProperty("colorByMax", obj.max));
                    if (Utils.isDefined(colors.min)) {
                        var clippedColors = [];
                        for (var i = 0; i < colors.colors.length; i++) {
                            var percent = i / colors.colors.length;
                            var value = colors.min + (colors.max - colors.min) * percent;
                            if (value >= min && value <= max)
                                clippedColors.push(colors.colors[i]);
                        }
                        colors = clippedColors;
                    }
                    if (colors.colors) colors = colors.colors;
                    var range = max - min;
                    var colorValues = [];
                    for (var i = 0; i < obj.values.length; i++) {
                        var value = obj.values[i];
                        var percent = (value - min) / range;
                        colorValues.push(percent);
                    }
                    for (var i = 0; i < colors.length; i++) {
                        var value = i / colors.length;
                        var next = (i + 1) / colors.length;
                        colorscale.push([value, colors[i]]);
                        colorscale.push([next, colors[i]]);
                    }
                    dataObj.marker.color = colorValues;
                    dataObj.marker.colorscale = colorscale;
                }

                this.displayColorTable(colors, ID_DISPLAY_BOTTOM, min, max);
            }

            var stringField = this.getFieldByType(fields, "string");
            if (stringField) {
                var l = this.getColumnValues(records, stringField).values;
                dataObj.text = [];
                for (var i = 0; i < l.length; i++)
                    dataObj.text.push(stringField.getLabel() + ": " + l[i]);
            }

            var plotData = [dataObj];
            var layout = {
                autosize: false,
                hovermode: 'closest',
                dragmode: 'select',
                plot_bgcolor: this.getProperty("bgColor", 'rgba(240,240,240, 0.95)'),
                margin: {
                    l: this.getProperty("marginLeft", 140),
                    r: this.getProperty("marginRight", 40),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 20),
                },
            }

            var cnt = 0;
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (!field.isFieldNumeric()) continue;
                var values = this.getColumnValues(records, field).values;
                var label;
                if (labels && i < labels.length)
                    label = labels[i];
                else
                    label = field.getUnitLabel();
                dataObj.dimensions.push({
                    label: label,
                    values: values
                });
                var key = "axis" + (cnt == 0 ? "" : "" + (cnt + 1));
                layout["x" + key] = this.makeAxis();
                layout["y" + key] = this.makeAxis();
                cnt++;
            }
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}



function RamaddaPTreemapDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TREEMAP, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var selectedFields = this.getSelectedFields(this.getData().getRecordFields());
            var field = this.getFieldByType(selectedFields, "numeric");
            if (!field) {
                this.displayError("No numeric field specified");
                return;
            }
            var values = this.getColumnValues(records, field).values;
            // declaring arrays
            var shapes = [];
            var annotations = [];
            var counter = 0;

            // For Hover Text
            var x_trace = [];
            var y_trace = [];
            var text = [];

            //colors
            var colors = this.getColorTable();
            if (colors.colors) colors = colors.colors;

            // Generate Rectangles using Treemap-Squared
            var rectangles = Treemap.generate(values, 100, 100);

            for (var i in rectangles) {
                var shape = {
                    type: 'rect',
                    x0: rectangles[i][0],
                    y0: rectangles[i][1],
                    x1: rectangles[i][2],
                    y1: rectangles[i][3],
                    line: {
                        width: 2
                    },
                    fillcolor: colors[counter]
                };
                shapes.push(shape);
                var annotation = {
                    x: (rectangles[i][0] + rectangles[i][2]) / 2,
                    y: (rectangles[i][1] + rectangles[i][3]) / 2,
                    text: String(values[counter]),
                    showarrow: false
                };
                annotations.push(annotation);

                // For Hover Text
                x_trace.push((rectangles[i][0] + rectangles[i][2]) / 2);
                y_trace.push((rectangles[i][1] + rectangles[i][3]) / 2);
                text.push(String(values[counter]));

                // Incrementing Counter
                counter++;
            }

            // Generating Trace for Hover Text
            var trace0 = {
                x: x_trace,
                y: y_trace,
                text: text,
                mode: 'text',
                type: 'scatter'
            };

            var layout = {
                height: 700,
                width: 700,
                shapes: shapes,
                hovermode: 'closest',
                annotations: annotations,
                xaxis: {
                    showgrid: false,
                    zeroline: false
                },
                yaxis: {
                    showgrid: false,
                    zeroline: false
                }
            };

            var data = {
                data: [trace0]
            };
            this.setDimensions(layout, 2);
            this.makePlot([trace0], layout);
        },
    });





}
function TextcountDisplay(displayManager, id, properties) {
    let SUPER  =  new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TEXTCOUNT, properties);
    let myProps = [
	{label:'Text Count Display'},
	{p:'patterns',ex:'foo,bar'},
	{p:'labels',ex:'Foo,Bar'},
	{p:'textField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDialogContents: function(tabTitles, tabContents) {
	    let html = HtmlUtils.div(["id",this.getDomId("dialog_set_pattern")],"Change patterns") + "<br>" +
		HtmlUtils.textarea("",Utils.join(this.patternList||[],"\n"),["id", this.getDomId("dialog_patterns"),"rows","10"]);

	    
            tabTitles.push("Patterns");
            tabContents.push(html);
            SUPER.getDisplayDialogContents.call(this, tabTitles, tabContents);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
	    let _this = this;
            this.jq("dialog_set_pattern").button().click(function() {
		_this.patterns = _this.jq("dialog_patterns").val().trim().replace(/\n/g,",");
		_this.updateUI();
            });

        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
	    let patterns = this.getProperty("patterns");
	    if(patterns == null) {
		this.setContents(this.getMessage("No patterns specified"));
		return;
	    }
	    this.patternList = patterns.split(",");
	    let labels = this.getProperty("labels");
	    if(labels) {
		labels = labels.split(",");
	    }

	    this.textField = this.getFieldById(null, this.getProperty("textField"));
	    if(!this.textField) {
		this.textField = this.getFieldByType(null, "string");
	    }
	    if(!this.textField) {
		this.setContents(this.getMessage("No text field in data"));
		return;
	    }

	    let count = [];
	    let matchers = [];
	    this.patternList.map(p=>{
		count.push(0);
		matchers.push(new TextMatcher(p));
	    });

            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var record = records[rowIdx];
                var row = record.getData();
		var value = record.getValue(this.textField.getIndex());
		matchers.map((m,index)=>{
		    if(m.matches(value)) {
			count[index]++;
		    }
		});
	    }

	    let data = [{
		type: 'bar',
		x: count,
		y: labels?labels:this.patternList,
		orientation: 'h',
	    }];
	    let layout = {
		margin: {
		    l: 100,
		    r: 50,
		    b: 50,
		    t: 10,
		    padding:4
		},
	    };
	    if(Utils.isDefined(this.properties.height)) {
		layout.height = +this.properties.height;
	    }

            this.makePlot(data, layout);
        },
        handleClickEvent: function(data) {
	    if(!data.points || data.points.length<=0) {
		return;
	    }
	    var pointNumber = data.points[0].pointNumber;
	    var pattern = this.patternList[pointNumber];
	    var args = {
		fieldId: this.textField.getId(),
		value: pattern
	    };
	    this.propagateEvent(DisplayEvent.filterChanged, args);
	},

    });
}



function CombochartDisplay(displayManager, id, properties) {
    let SUPER  =  new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_COMBOCHART, properties);
    let myProps = [
	{label:'Combo Chart'},
	{p:'fields',ex:''},
 	{p:'&lt;field&gt;.axisSide',ex:'right|left'},
	{p:'&lt;field&gt;.axisTitle',ex:''},
	{p:'&lt;field&gt;.chartType',ex:'scatter|bar'},
	{p:'chartType',ex:'scatter|bar'},
	{p:'&lt;field&gt;.chartColor',ex:''},
	{p:'chartType',ex:''},
	{p:'xAxisTitle',ex:''},
	{p:'xAxisShowGrid',ex:''},
	{p:'xAxisShowLine',ex:''},
	{p:'legendBackground',ex:''},
	{p:'legendBorder',ex:''},
	{p:'chartBackground',ex:''},
	{p:'plotBackground',ex:''},
	{p:'marginLeft',ex:''},
	{p:'marginRight',ex:''},
	{p:'marginBottom',ex:''},
	{p:'marginTop',ex:''},
	{p:'chartPad',ex:''},
    ];	
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
            let records = this.filterData();
            if (!records) return;
	    var layout = {
                xaxis: {
                    title: this.getProperty("xAxisTitle", "Time"),
                    showgrid: this.getProperty("xAxisShowGrid", false),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)',
		  
		},
                legend: {
                    font: {
                        size: 10,
                    },
		    bgcolor: this.getProperty("legendBackground",'rgba(255,255,255,0)'),
		    bordercolor: this.getProperty("legendBorder",'rgba(255,255,255,0)'),
		    x: 0,
		    y: 1.0,

                },
		margin: {
                    l: this.getProperty("marginLeft", 50),
                    r: this.getProperty("marginRight", 50),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 0),
		    pad: this.getProperty("chartPad", 4),
		},
		paper_bgcolor: this.getProperty("chartBackground", 'rgb(255,255,255,0)'),
		plot_bgcolor: this.getProperty("plottBackground", 'rgb(255,255,255,0)'),
	    };
	    let fields   = this.getFieldsByIds(null, this.getPropertyFields("",true));
	    var data = [];
	    var domain = [];
	    records.map((r,idx)=>{
		domain.push(r.getTime());
	    });
	    let right =  true;
	    fields.map((field,idx)=>{
		let values = this.getColumnValues(records, field).values;
		var trace = {
		    x: domain,
		    y: values,
		    name: field.getLabel(),
		    type: this.getProperty(field.getId()+".chartType",this.getProperty("chartType",'scatter')),
		    marker: {color: this.getProperty(field.getId()+".chartColor",this.getProperty("chartColor"))},
		};
		if(idx>0) {
		    trace.yaxis = "y" + (idx+1);
		}
		data.push(trace);
		var yAxisId = idx>0?"yaxis"+(idx+1):"yaxis";
		var axis = {
		    title: this.getProperty(field.getId()+".axisTitle" ,field.getLabel()), 
		    titlefont: {color: 'rgb(0,0,0)'},
		    tickfont: {color: 'rgb(0,0,0,)'},
		    side: this.getProperty(field.getId()+".axisSide",
					   this.getProperty("axisSide", right?'right':'left'))
		};
		if(idx>0)
		    axis.overlaying='y';
		layout[yAxisId] = axis;
		right = !right;
	    });
            this.setDimensions(layout);
            this.makePlot(data, layout);
	}
    });
}





function RamaddaParcoordsDisplay(displayManager, id, properties) {
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_PARCOORDS, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
	    let fields   = this.getFieldsByIds(null, this.getPropertyFields(""));
            if (fields.length == 0) {
                this.displayError("No fields specified");
                return;
            }
	    let dimensions =[];
	    let maxLabelLength = this.getProperty("maxLabelLength",200/fields.length);
	    fields.map(f=>{
		let col = this.getColumnValues(records, f)
		let values = col.values;
		let ticktext = null;
		let tickvals = null;
		if(f.isString()) {
		    let tmpValues = [];
		    let seen = {};
		    ticktext =[];
		    tickvals =[];
		    let cnt = 1;
		    values.map(v=>{
			if(!seen[v]) {
			    seen[v] = cnt++;
			    ticktext.push(v);
			    tickvals.push(seen[v]);
			}
			tmpValues.push(seen[v]);
		    });
		    values = tmpValues;
		}

		let label = this.getProperty(f.getId()+".label",f.getLabel());
		if(label.length>maxLabelLength)
		    label = label.substring(0,maxLabelLength-1)+"...";
		let dim  = {
		    label:label,
		    values:values
		};
		if(this.getProperty(f.getId()+".constraintrange")) {
		    dim.constraintrange = this.getProperty(f.getId()+".constraintrange").split(",");
		}
		if(this.getProperty(f.getId()+".tickvals")) {
		    dim.tickvals = this.getProperty(f.getId()+".tickvals").split(",");
		}
		if(this.getProperty(f.getId()+".ticktext")) {
		    dim.ticktext = this.getProperty(f.getId()+".ticktext").split(",");
		} else {
		    dim.ticktext = ticktext;
		    dim.tickvals = tickvals;		    
		}
		dimensions.push(dim);
	    });

	    let color = this.getProperty("color", 'blue');
	    let colorByField = this.getFieldById(null, this.getProperty("colorBy"));
	    let line = {};
	    let ct = null;
	    let ctMin=0,ctMax=0;
            if (colorByField) {
		let colorValues =   this.getColumnValues(records, colorByField);
		ctMin = colorValues.min;
		ctMax = colorValues.max;
		line.color  = colorValues.values;
		ct = this.getColorTable(true,null,null);
		if(ct) {
		    let colors = [];
		    let step   = 1/(ct.length-1);
		    ct.map((c,idx)=>{
			let v = idx*step;
			colors.push([v,c]);
		    });
		    line.colorscale = colors;
		}
	    }

	    var trace = {
		type: 'parcoords',
		line: line,
		dimensions:dimensions,
	    };

	    var data = [trace]	    
	    let layout  = {
		margin: {
		    l:175,
		    t:50,
		    b:25
		}
	    };
	    this.setDimensions(layout, 2);
	    
            this.makePlot(data, layout);
	    if(ct)
		this.displayColorTable(ct, ID_COLORTABLE,ctMin,ctMax);

        },
    });
}
/**
   Copyright 2008-2021 Geode Systems LLC
*/



const DISPLAY_THREE_GLOBE = "three_globe";
addGlobalDisplayType({
    type: DISPLAY_THREE_GLOBE,
    forUser: true,
    label: "3D Globe",
    requiresData: true,
    category: CATEGORY_MAPS
});

const DISPLAY_THREE_GRID = "three_grid";
addGlobalDisplayType({
    type: DISPLAY_THREE_GRID,
    forUser: true,
    label: "3D Grid",
    requiresData: true,
    category: CATEGORY_CHARTS,
});

var ramaddaLoadedThree=false;
var ramaddaLoadedThreeGlobe=false;

function RamaddaThree_Base(displayManager, id, type,properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    let myProps = [];
    defineDisplay(this, SUPER, myProps, {
	parseInt:function(v,dflt) {
	    if(typeof v == "number") return v;
	    if(!v) return  dflt;
	    if(v.match("rgb")) v = Utils.rgbToHex(v);
	    if(v.startsWith("#")) v = v.substring(1);
	    if(!v.startsWith("0x")) v = '0x' + v;
	    return parseInt(Number(v), 10);
	},
	getScene() {
	    return this.scene;
	},
	getControls() {
	    return this.controls;
	},
    });

}


function RamaddaThree_globeDisplay(displayManager, id, properties) {
    const ID_CONTAINER = "container";
    const ID_GLOBE = "globe";
    const ID_POPUP = "popup";
    const ID_POSITION_BUTTON = "positionbutton";        
    let positions = {
"Base":{
position: {x:6.048899205465489e-21,y:1.832130202344028e-20,z:250},
up: {x:1.546799663044268e-22,y:1,z:-7.328520809376114e-23}
},
"North America":{
position: {x:-185.0051316412852,y:166.36750886777244,z:-24.391663730099083},
up: {x:0.6540380289233074,y:0.7458336330441189,z:0.12635841302550785}
},
"South America":{
position: {x:-220.53665870332205,y:-71.90185405284046,z:93.24004264123046},
up: {x:-0.2051500901346411,y:0.9474654144116881,z:0.24540319682399764}
},
"Europe":{
position: {x:76.01040670390248,y:193.37167151814756,z:139.03170403539133},
up: {x:-0.286288586763548,y:0.6309644429890481,z:-0.7210566668247681}
},
"Asia":{
position: {x:215.9418144948879,y:118.22041784669743,z:-43.50937320632211},
up: {x:-0.4872587496088534,y:0.8718613869731202,z:-0.04936226124191964}
},
"Africa":{
position: {x:82.50264441171257,y:6.133419606337622,z:235.91459223415376},
up: {x:-0.005217856566188513,y:0.9996943480371796,z:-0.024165770738191875}
},
"Australia":{
position: {x:166.64046097372514,y:-104.10022198889281,z:-154.57716696953614},
up: {x:0.32825699830271454,y:0.9086541300046129,z:-0.25806009976525474}
},
"Pacific":{
position: {x:-50.02109926067879,y:70.1629622786457,z:-293.1352563989274},
up: {x:0.578136747554258,y:0.8103545388010297,z:0.09530699120186392}
},
"North Atlantic":{
position: {x:-137.7219663374266,y:134.93931772927482,z:159.1352899859414},
up: {x:0.3485760134063413,y:0.8418048847668705,z:-0.4121399020482765}
},
	"South Pole":{
	    position: {x:0,y:-249.99925472592855,z:-0.6104395794518828},
	    up: {x:0.9999999999999998,y:0,z:0}
	}, 
	"North Pole":{
	    position: {x:12.435991378990524,y:249.68975620440986,z:0.6097253513751638},
	    up: {x:-0.9987620026286266,y:0.049743817204226284,z:0.00012147100820090829}
	},
    }


    let myProps = [
        {label:'3D Globe Attributes'},
	{p:"globeWidth",d:800},
	{p:"globeHeight",d:400},
	{p:"baseImage",d:"earth-blue-marble.jpg",ex:"earth-blue-marble.jpg|earth-day.jpg|earth-dark.jpg|world-boundaries.png|caida.jpg|white.png|lightblue.png|black.png"},
	{p:"globeBackgroundImage",ex:"night-sky.png|white.png|lightblue.png|black.png"},
	{p:'backgroundColor',d:'#CAE1FF',ex:'#ffffff'},
	{p:"initialPosition",ex:"North America|South America|Europe|Asia|Africa|Australia|South Pole|North Pole"},
	{p:'linked',ex:true,tt:"Link location with other globes"},
	{p:'linkGroup',ex:'some_name',tt:"Globe groups to link with"},
	{p:'mapColor',d:'blue'},	
	{p:'showGraticules',ex:true},
	{p:'showAtmosphere',d:true,ex:'false'},
	{p:'atmosphereColor',d:'#fff',ex:'red'},	    	    
	{p:'atmosphereAltitude',d:0.25,ex:0.5},
	{p:'ambientLight',d:'ffffff',ex:'ffffff'},
	{p:'ambientIntensity',d:1,ex:'1'},
	{p:'directionalIntensity',d:1},		
	{p:'directionalLight1',ex:'ffffff'},
	{p:'directionalIntensity1',ex:'0.5'},
	{p:'directionalPosition1',ex:'0,1,0'},
	{p:'directionalLight2',ex:'ffffff'},
	{p:'directionalIntensity2',ex:'0.5'},		
	{p:'directionalPosition2',ex:'0,1,0'},

	{p:'initialAltitude',d:250,ex:500},
	{p:'color',d:'blue',ex:'red'},
	{p:'showPoints',d:true,ex:'false'},
	{p:'showSpheres',ex:true},			
	{p:'pointRadius',d:1,ex:'1'},
	{p:'pointResolution',d:12},
	{p:'heightField',tt:'field to map height to'},
	{p:'heightMin',d:0,tt:'min height range that heightField value percent is mapped to'},
	{p:'heightMax',d:0.5},
	{p:'radiusField',tt:'field to map radius to'},
	{p:'radiusMin',d:1},
	{p:'radiusMax',d:5},
	{p:'labelFields',tt:'fields for the label'},
	{p:'labelColor',d:'red',ex:'red'},
	{p:'labelSize',d:0.5},
	{p:'labelDotRadius',d:0.1},
	{p:'labelResolution',d:3},
	{p:'labelIncludeDot',d:true},		
	{p:'latField1',tt:'Field id for segments'},
	{p:'lonField1',tt:'Field id for segments'},
	{p:'latField2',tt:'Field id for segments'},
	{p:'lonField2',tt:'Field id for segments'},
	{p:'lineWidth',d:0.1},
	{p:'lineAltitude',d:0.05},	
	{p:'showEndPoints',d:true},	
	{p:'polygonField',tt:'field that holds polygons'},

	{p:'geojson',tt:'base layer map or used for chloropleth display',ex:'us_states.geojson|us_counties.geojson|countries.geojson|entryid|url'},
	{p:'polygonNameField',tt:'Field to match with the name field in the geojson map, e.g., state'},
	{p:'polygonAltitude',d:0.01},

	{p:'selectedDiv',ex:'div id to show selected record'},
	{p:'doPopup',d:true,ex:'',tt:''},
	{p:'centerOnFilterChange',d:true,ex:false,tt:'Center map when the data filters change'},	
    ];
    const SUPER = new RamaddaThree_Base(displayManager, id, DISPLAY_THREE_GLOBE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        initDisplay:  function() {
            SUPER.initDisplay.call(this);
        },
	dataFilterChanged: function(args) {
	    SUPER.dataFilterChanged.call(this,args);
	    if(!this.getCenterOnFilterChange()) return;
	    if(!this.filteredRecords) return;
	    if(this.filteredRecords.length==0) return;
	    this.viewRecords(this.filteredRecords);
	},
	viewRecords:function(records) {
	    let bounds = RecordUtil.getBounds(records);
	    let lat = bounds.south+(bounds.north-bounds.south)/2;
	    let lng = bounds.west+(bounds.east-bounds.west)/2;
	    this.globe.pointOfView({lat: lat,
				    lng: lng,
				    alt:10000});

	},

        updateUI: async function() {
	    if(!window["THREE"]) {
		if(!ramaddaLoadedThree) {
                    ramaddaLoadedThree = true;
//		    Utils.importJS(ramaddaBaseHtdocs+"/lib/three/three.min.js");
		    Utils.importJS("//unpkg.com/three");		    
		}
		setTimeout(()=>{this.updateUI()},100);
		return
	    }	    

	    if(!window["Globe"]) {
		if(!ramaddaLoadedThreeGlobe) {
                    ramaddaLoadedThreeGlobe = true;
		    Utils.importJS("//unpkg.com/globe.gl");
		}
		setTimeout(()=>{this.updateUI()},100);
		return
	    }	    


            SUPER.updateUI.call(this);
	    this.jq(ID_POPUP).hide();
	    let records =this.filterData();
	    if(!records) return;
	    this.filteredRecords = records;

	    if(!this.globe) {
		this.createGlobe();
	    }

            let colorBy = this.getColorByInfo(records);
	    let dfltColor = this.getColor();
	    let pointData = [];

	    let heightField = this.getFieldById(null, this.getHeightField());
	    let heights;
	    if(heightField) {
		heights = this.getColumnValues(records, heightField);
	    }
	    let heightMin = this.getHeightMin();
	    let heightMax = this.getHeightMax();	    
	    let getHeight=record=>{
		if(!heights) return 0;
		let v = heightField.getValue(record);
		let percent = (v-heights.min)/(heights.max-heights.min);
		let height = heightMin+percent*(heightMax-heightMin);
		return height;
	    }


	    let radiusField = this.getFieldById(null, this.getProperty("radiusField"));
	    let radiuss;
	    if(radiusField) {
		radiuss = this.getColumnValues(records, radiusField);
	    }
	    let radiusMin = this.getRadiusMin();
	    let radiusMax = this.getRadiusMax();	    
	    let getRadius=record=>{
		if(!radiuss || !record) return this.getPointRadius();
		let v = radiusField.getValue(record);
		let percent = (v-radiuss.min)/(radiuss.max-radiuss.min);
		let radius = radiusMin+percent*(radiusMax-radiusMin);
		return radius;
	    }

	    let labelFields = this.getFieldsByIds(null, this.getProperty("labelFields"));
	    if(labelFields && labelFields.length) {
		let labelData = [];
		let labelColor = this.getLabelColor();
		records.forEach((record,idx)=>{
		    let label = "";
		    labelFields.forEach((f,idx) =>{
			if(idx>0) label+=" ";
			label+=f.getValue(record);
		    });
		    labelData.push({
			record:record,
			label: label,
			lat:record.getLatitude(),
			lng:record.getLongitude(),
			color:labelColor
		    });
		});
		this.globe.labelsData(labelData)
		    .labelLat(d => d.lat)
		    .labelLng(d => d.lng)
		    .labelText(d => d.label)
		    .labelColor(d => d.color)
		    .labelDotRadius(this.getLabelDotRadius())
		    .labelSize(this.getLabelSize())		
		    .labelResolution(this.getLabelResolution());
		this.globe.labelIncludeDot(this.getLabelIncludeDot());
	    }

	    let polygonField = this.getFieldById(null, this.getProperty("polygonField"));
	    let latField1 = this.getFieldById(null, this.getProperty("latField1"));
	    let lonField1 = this.getFieldById(null, this.getProperty("lonField1"));
	    let latField2 = this.getFieldById(null, this.getProperty("latField2"));
	    let lonField2 = this.getFieldById(null, this.getProperty("lonField2"));	    	    
	    if(latField1 && lonField1  && latField2 && lonField2) { 
		let arcsData = [];
		let showEndPoints = this.getShowEndPoints();
		records.forEach((record,idx)=>{
		    let color=colorBy.getColorFromRecord(record, dfltColor);
		    arcsData.push({
			startLat:latField1.getValue(record),
			startLng:lonField1.getValue(record),
			endLat:latField2.getValue(record),
			endLng:lonField2.getValue(record),			
			color:color,
			record:record
		    });

		    if(showEndPoints) {
			pointData.push({
			    height:0,
			    lat:latField1.getValue(record),
			    lng:lonField1.getValue(record),
			    color:color,
			    radius:this.getPointRadius(0.5),
			    record:record,
			});
			pointData.push({
			    height:0,
			    lat:latField2.getValue(record),
			    lng:lonField2.getValue(record),
			    color:color,
			    radius:this.getPointRadius(0.5),
			    record:record,
			});
		    }
		});

		this.globe.arcsData(arcsData)
		    .arcStroke(+this.getLineWidth())
		    .arcAltitude(this.getLineAltitude())
		    .arcColor('color')
//		    .arcDashLength(() => Math.random())
		    .arcDashGap(0);
	    } else if(polygonField) {
		let polygonColorTable = this.getColorTable(true, "polygonColorTable",null);
		let delimiter;
		let first = !this.didit;
		if(!this.didit) {
		    this.didit = true;
		}
		let latlon = this.getProperty("latlon",true);
		let pathData = [];
		let pData = [];
		let cidx=0;
		records.forEach((record,idx)=>{
		    let color = dfltColor;
		    if(polygonColorTable) {
			if(cidx>=polygonColorTable.length) cidx=0;
			color=polygonColorTable[cidx++];
		    }

//		    if(idx>=5) return;
		    let poly = [];
		    let polyObj = {
			points:poly,
			record:record,
			color:color,
		    };
		    pathData.push(polyObj);
		    let s = polygonField.getValue(record);
		    if(!delimiter) {
			[";",","].forEach(d=>{
			    if(s.indexOf(d)>=0) delimiter = d;
			});
		    }
		    let toks  = s.split(delimiter);
		    let p = [];
		    for(let pIdx=0;pIdx<toks.length;pIdx+=2) {
			let lat = parseFloat(toks[pIdx]);
			let lon = parseFloat(toks[pIdx+1]);
			if(!latlon) {
			    let tmp =lat;
			    lat=lon;
			    lon=tmp;
			}
			poly.push([lat,lon,1]);
			if(pIdx==0 || pIdx==toks.length-2) {
			    let pt = {
				lat:lat,
				lng:lon,
				color:color,
				height:getHeight(record),
				radius:this.getPointRadius(),
				record:record,
			    };
			    pointData.push(pt);
			}
		    }
		});
		this.globe.pathsData(pathData)
		    .pathPoints((d) => {return d.points;})		
		    .pathColor((d) => {return [d.color,d.color]})		
		    .pathDashLength(0.01)
		    .pathDashGap(0.0)
		    .pathPointAlt((d) => {return 0.0;}) ;
	    } else {
		records.forEach((record,idx)=>{
		    let pt = {
			lat:record.getLatitude(),
			lng:record.getLongitude(),		    
			color:colorBy.getColorFromRecord(record, dfltColor),
			height:getHeight(record),
			radius:getRadius(record),
			record:record,
		    };
		    pointData.push(pt);
		});

	    }


	    if(pointData.length>0) {
		if(this.getShowSpheres()) {
		    this.globe.customLayerData(pointData)
			.customThreeObject(d => new THREE.Mesh(
			    new THREE.SphereBufferGeometry(d.radius),
			    new THREE.MeshLambertMaterial({ color: d.color })
			))
			.customThreeObjectUpdate((obj, d) => {
			    Object.assign(obj.position, this.globe.getCoords(d.lat, d.lng, d.height+0.01));
			});
		} else if(this.getShowPoints()) {
		  this.globe.pointsData(pointData)
			.pointAltitude('height')
			.pointColor('color')
			.pointRadius('radius')
			.pointResolution(this.getPointResolution());
		} else {
//		    console.log("Not showing spheres or points");
		}
	    }

	    if(this.getProperty("geojson")) {
		let nameField = this.getFieldById(null, this.getPolygonNameField());
		if(nameField) {
		    this.addGeojsonLayer(records);
		}
	    }


	    if(colorBy.isEnabled()) {
		colorBy.displayColorTable();
	    }
	    if(!this.getInitialPosition()) {
		this.viewRecords(records);
	    }
	    this.callHook("updateUI");

        },
	getScene() {
	    return this.globe.scene();
	},
	getControls() {
	    return this.globe.controls();
	},
	setPosition:function(pos) {
	    if((typeof pos=="string") && pos.trim().startsWith("{")) {
		pos = this.parsePosition(pos);
	    }
	    let scope = this.getControls();
	    if(pos.target)
		scope.target.copy(pos.target);
	    if(pos.position)
		scope.object.position.copy(pos.position);
	    if(pos.up)
		scope.object.up.copy(pos.up);
	    if(pos.zoom)
		scope.object.zoom = pos.zoom;
	    scope.object.updateProjectionMatrix();
//	    _eye.subVectors( scope.object.position, scope.target );
	    scope.object.lookAt( scope.target );
	},
	getDataObjects: function(recordMap) {
	    let dataObjects = [];
	    let f= (object,idx)=>{
		if(object.__data && object.__data.record) {
		    if(recordMap) {
			let id = object.__data.record.getId();
			if(!recordMap[id]) recordMap[id]=[];
			recordMap[id].push(object);
		    }
		    dataObjects.push(object);
		}
		if(object.children && object.children.length) {
		    object.children.forEach(f);
		}
	    }
	    this.getScene().children.forEach(f);
	    return dataObjects;
	},

	listScene: function() {
	    this.getScene().children.forEach(obj=>{
		console.log(obj.type);
		console.dir(obj);
	    });
	},
	addLights:function() {
	    if(this.addedLight) return;
	    this.addedLight = true;

	    //turn off any directionallight
	    this.getScene().children.filter(obj=>{
		return obj.type=="DirectionalLight" || obj.type=="AmbientLight";
	    }).forEach(obj=>{
//		console.log("removing " + obj.type);
		this.getScene().remove(obj);
	    });

	    let ambientLight = this.getAmbientLight();
	    if(ambientLight && ambientLight!="none") {
//		console.log("adding ambient light:" + ambientLight);
		this.getScene().add(new THREE.AmbientLight(this.parseInt(ambientLight), this.getAmbientIntensity()));
	    }
	    
	    for(let i=1;i<10;i++) {
		let light = this.getProperty("directionalLight"+ i);
		if(!Utils.isDefined(light) || light=="none") {
		    continue;
		}
//		console.log("adding directional light:" + light);
		let dl = new THREE.DirectionalLight(this.parseInt(light),
						    this.getProperty("directionalIntensity"+ i,
								     this.getDirectionalIntensity()));
		let pos = this.getProperty("directionalPosition" + i,"0,1,0").split(",");
		dl.position.set(+pos[0],+pos[1],+pos[2]);
		this.getScene().add(dl);
	    }
	},
	createGlobe:function() {
	    let _this = this;
	    let popup = HU.div([CLASS,"display-three-globe-popup",ID,this.domId(ID_POPUP),STYLE,HU.css("display","none","position","absolute","left","60%","top","0px")],"");
	    let pos = HU.div([TITLE,"Select Position", CLASS,"ramadda-clickable", ID,this.domId(ID_POSITION_BUTTON),STYLE,HU.css("position","absolute","left","10px","top","10px","z-index","1000")],HU.getIconImage("fa-globe"));
	    let globe = HU.div([STYLE,HU.css("position","relative")],
			       pos +
			       popup +
			       HU.div([ID, this.domId(ID_GLOBE)]));
	    let html = HU.center(globe);
	    html  = globe;
	    this.setContents(html);
	    this.jq(ID_POPUP).click(()=>{
		this.jq(ID_POPUP).hide();
	    });
		

	    this.jq(ID_POSITION_BUTTON).click(()=>{
		let html = "";
		for(a in positions) {
		    html+=HU.div([CLASS,"ramadda-clickable","place",a],a);
		}
		html=HU.div([STYLE,HU.css("margin","5px")],html);
		let dialog = HU.makeDialog({content:html,anchor:this.jq(ID_POSITION_BUTTON)});
		dialog.find(".ramadda-clickable").click(function() {
		    _this.setPosition(positions[$(this).attr("place")]);
		    dialog.remove();
		});
	    });
	    //Initial example code from https://github.com/vasturiano/three-globe

	    let domGlobe = document.getElementById(this.domId(ID_GLOBE));
	    let w  = this.getGlobeWidth();
	    let h = this.getGlobeHeight();

	    this.globe = Globe()(domGlobe);	    	    
	    this.globe.onGlobeReady(()=>this.addLights());
	    this.globe.width(w);
	    this.globe.height(h);
	    this.globe.showGraticules(this.getShowGraticules())
		.showAtmosphere(this.getShowAtmosphere())
		.atmosphereColor(this.getAtmosphereColor())	    	    
		.atmosphereAltitude(this.getAtmosphereAltitude());

	    let baseImage = this.getImageUrl(this.getBaseImage());
	    if(baseImage) {
		this.globe.globeImageUrl(baseImage);
	    }
	    let bgImage = this.getImageUrl(this.getGlobeBackgroundImage());
	    if(bgImage) {
		this.globe.backgroundImageUrl(bgImage);
	    }
	    let bg = this.getBackgroundColor();
	    if(bg) {
		this.globe.backgroundColor(bg);
	    }


	    try {
		let canvas = this.jq(ID_GLOBE).find('canvas');
		canvas.attr('tabindex','1');
		canvas.mouseover(()=>{
		    this.mouseOver = true;
		});
		canvas.mouseout(()=>{
		    this.mouseOver = false;
		});		

		domGlobe.addEventListener('keydown', (e) => {
		    if(e.code=="KeyD") {
			//debug
			this.listScene();
			return
		    }

		    if(e.code=="KeyP") {
			let name = prompt("Name:");
			if(!name) return;
			let attrs = ["x","y","z"];
			let  pos =  "{position: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.position[a]);
			    pos+="},\nup: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.up[a]);
			pos+="}}";
			let state = '"'+name+'":' + pos;
			console.log(state);
			Utils.copyToClipboard(pos.replace(/\n/g,""));
		    }

		    if(e.code=="KeyR") {
			let pos = positions[this.getInitialPosition() || "North America"] || this.getInitialPosition();
			if(pos) {
			    this.setPosition(pos);
			}
		    }
		});
	    } catch(err) {
		console.error("Error creating trackball control:" + err);
		console.log("ctor:");console.log(THREE.TrackballControls);
		console.error(err.stack);
	    }

	    let handleMouseEvent=this.handleMouseEvent = object=>{
		this.jq(ID_POPUP).hide();
		let record = object.record;
		if(!record) return;
		this.propagateEventRecordSelection({record: record})
		this.showRecord(record);
	    };


	    if(this.getProperty("geojson")) {
		let nameField = this.getFieldById(null, this.getPolygonNameField());
		if(!nameField) {
		    this.addGeojsonLayer();
		}
	    }

	    this.globe.onPointClick(handleMouseEvent);
	    this.globe.onArcClick(handleMouseEvent);
	    this.globe.onPathClick(handleMouseEvent);
	    this.globe.onLabelClick(handleMouseEvent);
	    this.globe.onGlobeClick(()=>{this.jq(ID_POPUP).hide();});
	    let linked  = this.getLinked();
	    let linkGroup  = this.getLinkGroup();
	    this.globe.onZoom(()=>{
		//Only propagate zoom if its from the user
		if(!this.mouseOver) return;
		if(this.zooming) return;
		let globeDisplays = 
		    Utils.displaysList.filter(d=>{
			if(d.getId() == this.getId()) return false;
			if(d.type!=DISPLAY_THREE_GLOBE) return false;
			if(!d.getLinked()) return false;
			if(!d.globe) return false;
			if(d.getLinkGroup() && this.getLinkGroup() && d.getLinkGroup()!=this.getLinkGroup()) return false;
			if(d.zooming) return false;
			return true;
		    });
		this.zooming = true;
		globeDisplays.forEach(d=>{
		    let pos =  this.getControls().object.position;
		    d.zooming = true;
		    d.getControls().object.position.set(pos.x,pos.y,pos.z);		    
		    d.zooming = false;
		});
		this.zooming = false;
	    });


	    if(this.getInitialPosition()) {
		let posArg = this.getInitialPosition();
		let pos = positions[posArg];
		if(!pos && posArg.startsWith("{")) {
		    pos = this.parsePosition(posArg);
		}

		if(!pos) {
		    console.error("Unknown initial position:" + this.getInitialPosition());
		    return;
		}
		this.setPosition(pos);
	    }

	    this.callHook("createGlobe");
	},

	parsePosition: function(pos) {
	    if(pos && (typeof pos=="string") && pos.startsWith("{")) {
		//A hack to wrap keys with quotes
		pos = pos.replace("position","\"position\"").replace("up","\"up\"").replace(/x/g,"\"x\"").replace(/y/g,"\"y\"").replace(/z/g,"\"z\"");
		try {
		    return JSON.parse(pos);
		} catch(err) {
		    console.err("Error parsing position:" + err+"\n" + pos);
		}
	    }
	    return null;
	},
	showRecord: function(record) {
	    if(this.getDoPopup()) {
		let html = this.getRecordHtml(record);
		this.jq(ID_POPUP).html(html);
		this.jq(ID_POPUP).show(1000);
		return;
	    }
	    if(this.getSelectedDiv()) {
		let html = this.getRecordHtml(record);
		$("#" + this.getSelectedDiv()).html(html);
	    }
	},

	addGeojsonLayer:function(records) {
	    let nameField = this.getFieldById(null, this.getPolygonNameField());
            let colorBy = null;
	    if(records) colorBy = this.getColorByInfo(records);
	    let url = this.getMapUrl(this.getProperty("geojson"));
	    let strokeColor= this.getMapColor();
	    $.getJSON(url, json=>{
		//		    console.log(json.features.length);
		//		    json.features.forEach(f=>{console.log(f.properties.NAME);});
		let aliases = {
		    "united states of america":"united states" ,
		    "czechia":"czech republic",
		    'swaziland':'eswatini',
		    'south korea':'korea (rep.)',
		    'north korea':'korea (dem. people s rep.)',
		    'eq. guinea':'guinea',
		    'gambia':'gambia the',
		    'congo':'congo (rep.)',
		    'democratic republic of the congo':'congo (dem. rep.)',
		    'ivory coast':'cote d\'ivoire'
		}
		let nameMap = {};
		if(nameField) {
		    records.forEach(record=>{
			let name = nameField.getValue(record);
//			console.log("name:" +name);
			nameMap[name] = record;
			nameMap[name.toLowerCase()] = record;
			nameMap[name.toUpperCase()] = record;			    			    
		    });
		}
		let logCnt = 0;
		json.features.forEach(f=>{
		    if(!f.properties) {
			if(logCnt++<50)
			    console.error("No properties in feature");
			return;
		    }
		    let seen = {};
		    let names = [f.properties.SOVEREIGNT, f.properties.name, f.properties.NAME, f.properties.ADMIN].filter(name=>{
			if(seen[name])return false;
			seen[name] = true;
			return name});
		    if(names.length==0) {
			if(logCnt++<50)
			    console.log("Could not find name in feature:" +JSON.stringify(f.properties));
			return;
		    }
		    let record = null;
		    names.every(name=>{
			record=nameMap[name];
			if(record) return false;
			return true;
		    });

		    if(!record) {
			names.every(name=>{
			    let alias = aliases[name.toLowerCase()];
			    if(!alias) return true;
 			    record = nameMap[alias];
			    if(record) return false;
			    return true;
			});
		    }

		    if(!record) {
//			this.handleLog("Could not find record for feature:" +names);
			return;
		    }
		    f.record=record;
		    if(colorBy && colorBy.isEnabled()) {
			f.color = colorBy.getColorFromRecord(record, null);
		    }
		});

		let alt = this.getPolygonAltitude();
		this.globe.polygonsData(json.features)
		    .polygonStrokeColor(()=>strokeColor)
		    .polygonCapColor((f)=>f.color || "transparent")
		    .polygonSideColor((f)=>f.color||"transparent")		    
		    .polygonAltitude(alt);


		if(nameField) {
		    let tooltip = this.getProperty("tooltip");
		    if(tooltip) {
			this.globe.polygonLabel(f=>{
			    if(!f.record) return null;
			    let html =  this.getRecordHtml(f.record);
			    html = HU.div([CLASS,"display-three-globe-popup"], html);
			    return html;
			});
		    }

		    this.globe.onPolygonHover(
			hoverD => {
			    this.globe
				.polygonAltitude(d => d === hoverD ? 0.08 : alt)
			})
			    .polygonsTransitionDuration(300);
		    //				.polygonCapColor(d => d === hoverD ? 'steelblue' : d.color)
		}

	    }).fail(err=>{
		console.error("failed to load json:" + url);
	    });
	    if(nameField) {
		this.globe.onPolygonClick(this.handleMouseEvent);
	    }
	},
	getImageUrl:function(image) {
	    if(!image) return null;
	    if(!image.startsWith("http") && !image.startsWith("/")) image = ramaddaBaseHtdocs+"/images/maps/" + image;
	    return image;
	},
	getMapUrl:function(url) {
	    if(!url) return null;
	    if(!url.startsWith("http") && !url.startsWith("/")) {
		//entry id e.g., 41d9b105-d61b-4fc1-8198-8e75c49b1a24
		if(url.trim().match(/.*[0-9a-z]+-[0-9a-z]+-[0-9a-z]+-[0-9a-z]+-[0-9a-z]+.*/)) {

		    url = ramaddaBaseUrl +'/entry/get?entryid=' + url;
		} else {
		    url = ramaddaBaseHtdocs+"/resources/" + url;
		}
	    }
	    return url;
	},	
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    let record = args.record;
	    this.globe.pointOfView({lat: record.getLatitude(),lng:record.getLongitude(),alt:10000});
	    let coords = this.globe.getCoords(args.record.getLatitude(),args.record.getLongitude());
	    if(this.selectedObjects) {
		this.selectedObjects.forEach(object=>{
		    object.material.color.setHex(object.__oldcolor);
		});
	    }
	    let map = {};
	    this.getDataObjects(map);
	    let objects = map[args.record.getId()];
	    this.selectedObjects = objects;
	    if(!objects) return;
	    objects.forEach(object=>{
		object.__oldcolor =  object.material.color.getHex();
		object.material.color.setRGB(1,0,0);
	    });

	}
    });
}


function RamaddaThree_gridDisplay(displayManager, id, properties) {
    const ID_CONTAINER = "container";
    const ID_GRID = "grid";
    const ID_POPUP = "popup";
    const ID_POSITION_BUTTON = "positionbutton";        
    const CAMERA_ANGLE = 45;
    let myProps = [
        {label:'3D Grid Attributes'},
	{p:"gridWidth",d:400},
	{p:"gridHeight",d:400},
	{p:'backgroundColor',d:'#CAE1FF',ex:'#ffffff'},
	{p:'canvasBorder',d:'1px solid #ccc'},
	{p:'shape',d:"box",ex:'box|cylinder'},
	{p:'heightField',tt:'field to scale height by'},
	{p:'heightScale',d:10,tt:'scale factor'},	
	{p:'doPopup',d:true,ex:'',tt:''},
	{p:'doImages',ex:true},
    ];
    const SUPER = new RamaddaThree_Base(displayManager, id, DISPLAY_THREE_GRID, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        initDisplay:  function() {
            SUPER.initDisplay.call(this);
        },
	dataFilterChanged: function(args) {
	    SUPER.dataFilterChanged.call(this,args);
	},
        updateUI: async function() {
            if(!ramaddaLoadedThree) {
                ramaddaLoadedThree = true;
		await Utils.importJS(ramaddaBaseHtdocs+"/lib/three/three.min.js");
		await Utils.importJS(ramaddaBaseHtdocs+"/lib/three/controls/OrbitControls.js");
            }
	    if(!window["THREE"]) {
		setTimeout(()=>{this.updateUI()},100);
		return
	    }	    
	    if(!THREE.OrbitControls) {
		setTimeout(()=>{this.updateUI()},100);
		return
	    }

            SUPER.updateUI.call(this);
	    this.jq(ID_POPUP).hide();
	    if(!this.shapes) {
		this.createScene();
	    }

	    this.shapes.forEach(shape=>{
		this.scene.remove(shape);
	    });

	    let records =this.filterData();
	    if(!records) return;
	    this.filteredRecords = records;

//	    records = [...records,...records,...records,...records,...records]
//	    records = [...records,...records,...records,...records,...records]	    


	    let sqrt = Math.ceil(Math.sqrt(records.length));
	    let cubeWidth = 1;
	    let cubeSpace = cubeWidth/2;	    
	    let rectWidth = sqrt*(cubeWidth+cubeSpace);
	    let topRadius = cubeWidth;
	    let bottomRadius = cubeWidth;	    

	    if(!this.initCamera) {
		this.initCamera = true;
		let h = (rectWidth/2)/Math.tan(Utils.toRadians(CAMERA_ANGLE/2));
		this.camera.position.set(0,0,h*2);
//		this.addChecker(rectWidth);
	    }
	    let initX = ((cubeWidth+cubeSpace)*-sqrt/2);
	    let initY = -initX;
	    let x = initX;
	    let y= initY;
	    let colCnt = 0;

            let colorBy = this.getColorByInfo(records);
	    let colorBys = [];
	    if(this.colorByFields) {
		let fields = this.getFields();
		this.colorByFields.forEach(field=>{
//		    function ColorByInfo(display, fields, records, prop,colorByMapProp, defaultColorTable, propPrefix, theField, props,lastColorBy) {
		    let cb = new ColorByInfo(this,fields,records,null,null,null,null,field);
		    colorBys.push(cb);
		})
	    }
	    let bounds = RecordUtil.getBounds(records);

	    let heightBy;
	    let heightScale = this.getHeightScale();
	    if(this.getProperty("heightField")) {
		heightBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records,"heightField");
	    }

	    if(colorBys.length==0) colorBys=[colorBy];
	    colorBys=[colorBy];	    
	    let doImages = this.getDoImages();
	    let imageFields = this.getFieldsByType(null,"image");
	    const loader = new THREE.TextureLoader();
	    let shape  = this.getShape();
	    shapeWidth = 0.5;
	    let doGeo = false;
	    records.forEach((record,idx)=>{	
		if(x>-initX) {
		    y-=(cubeWidth+cubeSpace);
		    x  = initX;
		}

		if(doGeo) {
		    let percentX = (record.getLongitude()-bounds.west)/bounds.getWidth();
		    x = initX+percentX*rectWidth;
		    let percentY = (record.getLatitude()-bounds.south)/bounds.getHeight();
		    y = (initY+percentY*rectWidth/this.aspectRatio)-rectWidth/this.aspectRatio
		}
		
		if(doImages) {
		    let geometry = new THREE.BoxGeometry(cubeWidth,cubeWidth,cubeWidth);
		    const materials = [];
		    imageFields.forEach(f=>{
			let image = f.getValue(record);
//			image = "https://ramadda.org/repository/metadata/view/Screenshot_2021-10-19_at_13-51-39_Point_Data_Collection.png?element=1&entryid=90e2c8e8-7e24-4f6b-9f0c-134fbd690999&metadata_id=b34d307a-7e7c-4a62-8c1e-1e1cd5637b2b";
//			image = 'https://localhost:8430/repository/images/logo.png';
			if(Utils.stringDefined(image)) {
			    materials.push(new THREE.MeshBasicMaterial({map: loader.load(image)}));
			}
		    });
		    let cube = new THREE.Mesh(geometry, materials);
		    cube.position.x = x;
		    cube.position.y = y;		
		    this.scene.add(cube);
		    this.shapes.push(cube); 
		} else {
		    let materials = [];
/*
		    for(let i=0;i<colorBys.length;i++) {
			let color = colorBys[i].getColorFromRecord(record, null);
			let material = new THREE.MeshLambertMaterial( { color: this.parseInt(color,0xff0000) } );
			materials.push(this.parseInt(color,0xff0000));
		    }
*/
		    let color = colorBy.getColorFromRecord(record, null);
		    let material = new THREE.MeshLambertMaterial( { color: this.parseInt(color,0xff0000) } );
		    let height = cubeWidth;
		    if(heightBy) {
			let percent;
			let func = perc =>{percent = perc;}
			let h = heightBy.getSize(record.getData(),0,func);
			if(!isNaN(percent))
			    height = height+percent*height*heightScale;
		    }

		    let geometry;
		    if(shape=="box") {
			geometry = new THREE.BoxGeometry(shapeWidth,shapeWidth,height);
		    } else {
			geometry = new THREE.CylinderGeometry(topRadius,bottomRadius,height,32);
		    }
		    let cube = new THREE.Mesh(geometry, material);
		    if(shape=="box") {
		    } else {
			cube.rotation.x = Utils.toRadians(90);
		    }
//		    cube.position.set(x,y,0);
		    cube.position.x=x;
		    cube.position.y = y;		
		    cube.position.z = height/2;
		    this.scene.add(cube);
		    cube.__record = record;
		    this.shapes.push(cube);
		}
		x+=cubeWidth+cubeSpace;
	    });
	    /*
	    var geometry = new THREE.CylinderBufferGeometry( 0, 10, 30, 4, 1 );
	    var material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
	    for ( var i = 0; i < 500; i ++ ) {
		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.x = ( Math.random() - 0.5 ) * 1000;
		mesh.position.y = ( Math.random() - 0.5 ) * 1000;
		mesh.position.z = ( Math.random() - 0.5 ) * 1000;
		mesh.updateMatrix();
		mesh.matrixAutoUpdate = false;
		this.scene.add( mesh );
	    }
	    */

	    if(colorBy.isEnabled()) {
		colorBy.displayColorTable();
	    }
	    this.callHook("updateUI");
        },
	addChecker:function(width) {
	    const planeSize = width*1.1;
	    const loader = new THREE.TextureLoader();
	    const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
	    texture.wrapS = THREE.RepeatWrapping;
	    texture.wrapT = THREE.RepeatWrapping;
	    texture.magFilter = THREE.NearestFilter;
	    const repeats = planeSize / 2;
	    texture.repeat.set(repeats, repeats);
	    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
	    const planeMat = new THREE.MeshPhongMaterial({
		map: texture,
		side: THREE.DoubleSide,
	    });
	    const mesh = new THREE.Mesh(planeGeo, planeMat);
//	    mesh.rotation.x = Math.PI * -.5;
	    this.scene.add(mesh);
	},

	createScene: function() {
	    let popup = HU.div([CLASS,"display-three-globe-popup",ID,this.domId(ID_POPUP),STYLE,HU.css("display","none","position","absolute","left","60%","top","0px")],"");
	    let grid = HU.div([STYLE,HU.css("position","relative")],
			      popup +
			      HU.div([STYLE,HU.css("min-width","200px","min-height","200px"), ID, this.domId(ID_GRID)]));
	    let html = HU.center(grid);
	    this.setContents(html);
	    this.scene = new THREE.Scene();
	    //fov,aspect ratio, near plane, far plane
	    let w = this.getGridWidth();
	    let h  = this.getGridHeight();
	    this.aspectRatio = w/h;
	    const AMOUNT = 6;
	    const WIDTH = ( w / AMOUNT ) * window.devicePixelRatio;
	    const HEIGHT = ( h / AMOUNT ) * window.devicePixelRatio;

	    this.camera = new THREE.PerspectiveCamera(CAMERA_ANGLE,w/h,0.1,1000);
	    this.camera = new THREE.OrthographicCamera( -100,100,100,-100, 0.1, 1000 );
	    this.camera.position.set(0,0,100);

	    var axes = new THREE.AxisHelper(1000);            this.scene.add(axes);

	    this.renderer = new THREE.WebGLRenderer({antialias:true,alpha: true});
	    this.renderer.setClearColor(this.getBackgroundColor());
	    this.renderer.setSize(w,h);
	    this.controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
	    this.controls.minDistance = 0;
	    this.controls.maxDistance = 1000;
	    this.controls.target.set( 0, 0, 5 );
	    this.controls.update();
	    this.jq(ID_GRID).append(this.renderer.domElement);
	    
	    let addLight=(v,x,y,z,i) =>{
		i=0.01;
		if(!Utils.isDefined(i)) i=1;
//		var light = new THREE.PointLight(this.parseInt(v),i);
		let light = new THREE.DirectionalLight(this.parseInt(v));
		light.position.set(x,y,z);
		this.getScene().add(light);
	    }
	    addLight(0xffffff,-1,1,1);
//	    addLight(0xffffff,1,1,1);
//	    addLight(0xffffff,-1,-1,1);
//	    addLight(0xffffff,1,-1,1);	    
	    var light = new THREE.AmbientLight( 0xffffff,0.5);
	    this.scene.add( light );
	    light = new THREE.HemisphereLight( 0xffffff,0xffffbb,1.0);
//	    this.scene.add( light );	    


	    let _this = this;
	    let canvas = this.jq(ID_GRID).find('canvas');
	    canvas.attr('tabindex','1');
	    canvas.css("border",this.getCanvasBorder());
	    this.renderer.domElement.addEventListener('keydown', (e) => {
		    if(e.code=="KeyP") {
			let name = prompt("Name:");
			if(!name) return;
			let attrs = ["x","y","z"];
			let  pos =  "{position: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.position[a]);
			    pos+="},\nup: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.up[a]);
			pos+="}}";
			let state = '"'+name+'":' + pos;
			Utils.copyToClipboard(pos.replace(/\n/g,""));
		    }

		    if(e.code=="KeyR") {
			_this.controls.reset();
//			let pos = positions[this.getInitialPosition() || "North America"];
//			if(pos) {			    this.setPosition(pos);			}
		    }
		});



	    let cnt = 0;
	    let handleMouseEvent=event=>{
		this.jq(ID_POPUP).hide();
		event.preventDefault();
		if(!event.shiftKey || event.which != 1)  return;
		let r = new THREE.Raycaster();
		let mouse = {
		    x: ( event.offsetX / w) * 2 - 1,
		    y : - ( event.offsetY / h) * 2 + 1
		};
		r.setFromCamera( mouse, this.camera ); 
		let intersects = r.intersectObjects(this.shapes,true);
		if(intersects.length==0) {
		    console.log("nothing found");
		    return;
		}
		let minDistance = NaN;
		let minObject = null;
		intersects.forEach(o=>{
		    if(minObject==null || minDistance>o.distance) {
			minObject = o.object;
			minDistance = o.distance;
		    }
		});
//		console.dir(minObject);
		let getRecord = o=>{
		    if(o.__record) return o.__record;
		    if(o.parent) return getRecord(o.parent);
		    return null;
		};
		let record = getRecord(minObject);
		if(!record) {
		    console.log("Could not find record");
		    return;
		}
		console.log("record:" + record);
		this.propagateEventRecordSelection({record: record})
		if(this.getDoPopup()) {
		    let html = this.getRecordHtml(record);
		    this.jq(ID_POPUP).html(html);
		    this.jq(ID_POPUP).show(1000);
		    return;
		}
		if(this.getSelectedDiv()) {
		    let html = this.getRecordHtml(record);
		    $("#" + this.getSelectedDiv()).html(html);
		}
	    };
	    this.renderer.domElement.addEventListener( 'mouseup', handleMouseEvent, false );
	    _this.renderer.render( _this.scene, _this.camera );
	    this.shapes = [];
	    if(!this.animating) {
		this.animating = true;
		function animate() {
		    requestAnimationFrame( animate );
		    _this.controls.update();
		    _this.shapes.forEach((shape,idx)=>{
//			shape.rotation.x+=0.01
//			shape.rotation.y+=0.01
//			if(idx==0) console.log(shape.rotation.x);
		    });
		    _this.renderer.render( _this.scene, _this.camera );
		}
		animate();
	    }

	}	    
    });
}
