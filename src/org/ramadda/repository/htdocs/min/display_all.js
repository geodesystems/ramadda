var build_date="RAMADDA build date: Thu Jun 19 16:43:54 MDT 2025";

/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/

$.extend(Utils,{
    makeRGBColortable:function() {
	let rgb = [];
	for(let i=0;i<arguments.length;i+=3) {
	    rgb.push('rgb(' + arguments[i]+','+arguments[i+1]+','+arguments[i+2]+')');
	}
	return rgb;
    },
    smoothColorTable: function(a,steps) {
        if(!steps) steps= 100;
        let incr = 1/steps;
        let c =[];
        for(let i=0;i<=1;i+=incr) {
            let color = getColor(a,i);
            c.push(c);
        }
        return c;
    },
    interpColors: function(scale,perc) {
        for(let i=0;i<scale.length-1;i++) {
            let p1 = scale[i];
            let p2 = scale[i+1];
            if(perc>=p1[0] && perc<=p2[0]) {
                let c1=scale[i][1];
                let c2=scale[i+1][1];
                let perc2 = (perc-p1[0])/(p2[0]-p1[0]);
                let m1 = c1.match(/rgb\((.*) *, *(.*) *, *(.*)\)/);
                let m2 = c2.match(/rgb\((.*) *, *(.*) *, *(.*)\)/);
                if(m1&&m2) {
                    let cc1=Math.round(+m1[1]+perc2*(+m2[1]- +m1[1]));
                    let cc2=Math.round(+m1[2]+perc2*(+m2[2]- +m1[2]));
                    let cc3=Math.round(+m1[3]+perc2*(+m2[3]- +m1[3]));
                    return "rgb(" + cc1+"," + cc2 +"," + cc3+")";
                }
                m1 = c1.match(/#(..)(..)(..)/);
                m2 = c2.match(/#(..)(..)(..)/);
                let pad = v=>{return v.length==1?"0"+v:v}
                if(m1&&m2) {
                    m1 = m1.map(v=>parseInt(v,16));
                    m2 = m2.map(v=>parseInt(v,16));
                    let cc1=Math.round(+m1[1]+perc2*(+m2[1]- +m1[1]));
                    let cc2=Math.round(+m1[2]+perc2*(+m2[2]- +m1[2]));
                    let cc3=Math.round(+m1[3]+perc2*(+m2[3]- +m1[3]));
                    return "#" + pad(cc1.toString(16))+ pad(cc2.toString(16)) + pad(cc3.toString(16));
                }
                return null;
            }
        }
    },
    getColorTable: function(name, justColors) {
        var ct = this.ColorTables[name];
        if (ct && justColors) return ct.colors;
        return ct;
    },
    displayAllColorTables: function(domId) {
        var cnt = 0;
        var html = '<table width=50% >';
        var code = '';
	Utils.AllColorTables.forEach(ct=>{
            if(ct.category) {
                html += HU.tr([],HU.td(['colspan','3'],'<br>' + HU.h3(ct.category)));
		return
            }
            code +='new ColorTable(\'' + ct.id +'\',\'' + ct.id +'\', new String[]{\n';
            for(var i=0;i<ct.colors.length;i++) {
                code +='\'' + ct.colors[i]+'\',';
            }
            code += '});\n';
            html += HU.tr([],
			  HU.td(['width','10%'],HU.b(HU.span([ATTR_CLASS,'colortable-id'],ct.id))) +
			  HU.td(['align','right'],HU.space(2)+ct.colors.length+'&nbsp;') +
			  HU.td([], HU.div(['id', domId + '_' + cnt, ATTR_STYLE, 'overflow-x:hidden;max-width:500px;width:100%;'], '')) );
            cnt++;
	    html+='\n';
        });
        html+='</table>';

        //        Utils.makeDownloadFile('colortables.java',code);
        $('#' + domId).html(html);
        cnt = 0;
	Utils.AllColorTables.forEach(ct=>{
            if(ct.category) {
		return;
	    }
	    
            this.displayColorTable(ct, domId + '_' + cnt, 0, 1, {
                showRange: false,
                height: '20px'
            });
            cnt++;
        });
	Utils.initCopyable('.colortable-id',{title:'Click to copy color table ID',ack:'Color table ID copied to clipboard'});
    },
    getColorTablePopup: function(wikiEditor, itemize,label,showToggle,attr,value) {
        let popup = "<div class=wiki-editor-popup-items>"
        let items = [];
        let item;
	showToggle = Utils.isDefined(showToggle)?showToggle:true;
	Utils.AllColorTables.forEach(colortable=>{
            if(colortable.category) {
                item = HU.div([ATTR_STYLE,"text-decoration: underline;font-weight:bold"],colortable.category);
                popup+=item;
                items.push(item);
		return;
            }
            let ct = Utils.getColorTableDisplay(colortable,  0, 1, {
                showRange: false,
                height: "20px"
            });
	    let attrs = [ATTR_STYLE,HU.css('margin-bottom','2px','width','400px'),TITLE,colortable.id,CLASS, "ramadda-colortable-select","colortable",colortable.id];
	    if(attr) attrs.push(attr,value);
            ct = HU.div(attrs,ct);
            if(wikiEditor) {
                let call = "WikiUtil.insertText(" + HU.squote(wikiEditor.getId()) +","+HU.squote("colorTable=" + colortable.id)+")";
                item = HU.onClick(call,ct);
                popup+=item;
                items.push(item);
            } else {
                items.push(ct);
                popup+=ct;
            }
        });
        popup+="</div>";
	if(showToggle)
            popup = HU.toggleBlock(HU.div([CLASS,"wiki-editor-popup-header"], label??"Color Table"),popup);
        if(itemize) return items;
        return popup;
    },

    displayColorTable: function(ct, domId, min, max, args) {
        if (!ct) return;
        let html = this.getColorTableDisplay(ct,min,max,args);
        jqid(domId).html(html);
    },
    getColorTableDisplay: function(ct,  min, max, args) {
        if (!ct) return null;
        if (ct.colors) ct = ct.colors;
        //Handle d3
        if(ct.length && Array.isArray(ct[0]))
            ct = ct[ct.length-1];
        let options = {
            height: "15px",
            showRange: true,
            showColorTableDots:false,
            decimals:-1,
            horizontal:true,
            colorWidth:"20px",
            stride:1,
	    dotWidth:null,
	    showLabels:true
        }
        if (args) $.extend(options, args);
	let colorInfo={};
        if (options.stringValues && options.stringValues.length) {
            options.showRange = false;
            ct = [];
            let seenColor = {};
            options.stringValues.forEach(v=>{
                let style = "";
                if(!colorInfo[v.color]) {
                    colorInfo[v.color] = {
			label:'',
			titles:[]
		    };
                    ct.push(v.color);
                }  else {
                    style = HU.css("border-top","1px solid #ccc");
                }
		let info = colorInfo[v.color];
                let value = v.value;
                if(value=="") value = "&lt;blank&gt;";
                info.label+=HU.div([ATTR_TITLE,v.value,ATTR_STYLE,style],value);
		info.titles.push(value);
            });
        }



	let clazz = " display-colortable " +(!options.tooltips && options.showColorTableDots?"display-colortable-dots"+(options.horizontal?'-h':''):"");
	if(!options.horizontal)
	    clazz+=' display-colortable-vertical';
        let divargs = [CLASS, clazz];
        if(Utils.isDefined(options.width)) {
            divargs.push(STYLE);
            divargs.push(HU.css(WIDTH, HU.getDimension(String(options.width))));
        }
        
        let html = HU.open(DIV, divargs);
	if(!options.horizontal && Utils.stringDefined(options.title))
	    html+=HU.div([ATTR_CLASS,'display-colortable-title'],options.title);
	    


        if(!options.showColorTableDots) {
            html+= HU.open('table',['cellpadding',0,'cellspacing',0,'width','100%','border',0]);
            html +='<tr>';
        }
        let formatter = n=>{
	    if(typeof n == "string") return n;
	    n = parseFloat(n);
	    if(isNaN(n)) return '';
            if(options.decimals>=0)
                return number_format(n,options.decimals);
            return  this.formatNumberComma(n);
        };

        if (options.showRange) {
            if(!options.showColorTableDots) {
                if(options.horizontal) 
                    html += "<td width=1%>" + formatter(min) + "&nbsp;</td>";
                else
                    html += formatter(min) + "<br>"
            }   else {
            }
        }
        let step = (max - min) / ct.length;
        let nums = [];
	let maxNums = ct.length;
	if(options.tooltips && options.tooltips.length>0 && options.tooltips.length<ct.length)  {
	    maxNums = options.tooltips.length;
	}
        if(!options.showColorTableDots || options.horizontal || options.tooltips) {
            for (var i = 0; i < maxNums; i+=options.stride) nums.push(i);
        } else {
            for (var i = maxNums-1; i>=0;i=i-options.stride) nums.push(i);
        }
	
        let tdw = (100 / nums.length) + "%";
        nums.forEach((i,idx)=>{
            let extra = "";
            let val = min + step * i;
            let attrs = [];
            if(options.showColorTableDots) {
                let val2 = min + step * (i+1);
                let label = options.tooltips?options.tooltips[idx]:formatter(val)+ "-" + formatter(val2);
		let color = ct[i];

		if(options.stringValues)  {
		    label = options.stringValues[idx]?.value;
		    color = options.stringValues[idx]?.color??color;
		}

                let delim = SPACE;
//		if(!options.horizontal && !options.tooltips)                    delim="<br>";
		let dotStyle = HU.css("background", color);
		if(options.dotWidth) dotStyle+=HU.css('width',HU.getDimension(options.dotWidth),
						      'height',HU.getDimension(options.dotWidth));
		if(options.tooltips) {
                    html += HU.div(['label',label,"data-value",val,'style','width:100%;display:inline-block;',
				    ATTR_CLASS,"display-colortable-dot-item",ATTR_TITLE,label],
				   HU.div([ "data-value",val,"class", "display-colortable-dot", "style", dotStyle]) + delim + label);
		} else {
		    let dot = HU.span([ "data-value",val,"class", "display-colortable-dot", "style", dotStyle]);
		    let item;
		    if(!options.horizontal) {
//			item = HU.hbox([dot, SPACE, label]);
			item = dot+ SPACE+ label;
		    } else {
			item = dot + delim + label;
		    }
                    html += HU.div([ATTR_CLASS,"display-colortable-dot-item",ATTR_TITLE,label], item);
		}
//                if(!options.horizontal) html +="<br>";
		return;
            } 
            let label;
	    let title='';
	    let info = colorInfo[ct[i]];

            if (options.showRange) {
                attrs.push(ATTR_TITLE);
                attrs.push(title=formatter(val));
            } else if(options.tooltips) {
		let tt = options.tooltips[idx];
		if(tt)
		    attrs.push(ATTR_TITLE,tt,'data-title',tt,'foo',tt);
	    }
	    if(info) {
		title  =Utils.join(info.titles,'/')
		label = info.label;
	    }
	    if(!label)
		label = options.labels?options.labels[idx]:"";
            let fg = Utils.getForegroundColor(ct[i]);
	    let labelStyle=HU.css('padding-left','4px','padding-right','4px',
				  'background', ct[i], ATTR_WIDTH,"100%",
				  "min-height", options.height,'color',fg);
            if(options.labelStyle) {
		labelStyle+=options.labelStyle;
            }
            if(options.horizontal) {
                html += HU.td(["data-value",val,
			       ATTR_TITLE,title??'',
			       ATTR_CLASS, "display-colortable-slice",	
			       ATTR_STYLE, HU.css('min-width','1px','height','1.5em','background', ct[i],"color",fg),
			       ATTR_WIDTH, tdw], '');
	    } else {
		attrs.push(ATTR_STYLE);
		attrs.push(labelStyle);
                html += HU.div(["data-value",val,ATTR_CLASS, "display-colortable-slice",
				ATTR_STYLE, HU.css("background",ct[i])],
			       HU.div(attrs, label||""));
	    }
        });
        if(!options.showColorTableDots) {
            if (options.showRange) {
                if(options.horizontal) 
                    html += HU.td([ATTR_WIDTH,'1%'], formatter(max) + SPACE);
                else
                    html += formatter(max) + "<br>"
            }
            if(options.horizontal) 
                html += "</tr></table>";
        }
        html += HU.close(DIV);
        html += HU.open(DIV, [CLASS, "display-colortable-extra"]);
        if (options.showLabels && Object.keys(colorInfo).length && options.horizontal && !options.showColorTableDots) {
            let tdw = (100 / ct.length) + "%";
            html += "<div style='width:100%;vertical-align:top;text-align:center;'>"
            let colCnt =0;
            let bin ={};
            ct.forEach(color=>{
		let info = colorInfo[color];
                let cell = HU.div(["style","padding:2px;vertical-align:top;display:inline-block;width:" + tdw+";max-width:" + tdw+";overflow-x:auto;"],info?info.label:'');
                html+=cell;
//              bin[colCnt]+="<div style='border-top:1px solid #eee;'></div>";
            });
            html+="</div>"
        }
        html += HU.close(DIV);

        return html;
    },
    addColorTables(tables) {
	Utils.AllColorTables.push(...tables);
	tables.forEach(ct=>{
	    if(ct.category) return;
	    if(!ct.id) {
		console.dir('Bad colorable:',ct);
		return;
	    }
	    let id = ct.id;
	    Utils.ColorTables[id] = ct;
	});
    }
});


Utils.ColorTables =  {};
Utils.AllColorTables =  [];

var defaultColorTables=[
{"category":"Ramps"},
{"id":"grayscale","colors":["rgb(0,0,0)","rgb(1,1,1)","rgb(2,2,2)","rgb(3,3,3)","rgb(4,4,4)","rgb(5,5,5)","rgb(6,6,6)","rgb(7,7,7)","rgb(8,8,8)","rgb(9,9,9)","rgb(10,10,10)","rgb(11,11,11)","rgb(12,12,12)","rgb(13,13,13)","rgb(14,14,14)","rgb(15,15,15)","rgb(16,16,16)","rgb(17,17,17)","rgb(18,18,18)","rgb(19,19,19)","rgb(20,20,20)","rgb(21,21,21)","rgb(22,22,22)","rgb(23,23,23)","rgb(24,24,24)","rgb(25,25,25)","rgb(26,26,26)","rgb(27,27,27)","rgb(28,28,28)","rgb(29,29,29)","rgb(30,30,30)","rgb(31,31,31)","rgb(32,32,32)","rgb(33,33,33)","rgb(34,34,34)","rgb(35,35,35)","rgb(36,36,36)","rgb(37,37,37)","rgb(38,38,38)","rgb(39,39,39)","rgb(40,40,40)","rgb(41,41,41)","rgb(42,42,42)","rgb(43,43,43)","rgb(44,44,44)","rgb(45,45,45)","rgb(46,46,46)","rgb(47,47,47)","rgb(48,48,48)","rgb(49,49,49)","rgb(50,50,50)","rgb(51,51,51)","rgb(52,52,52)","rgb(53,53,53)","rgb(54,54,54)","rgb(55,55,55)","rgb(56,56,56)","rgb(57,57,57)","rgb(58,58,58)","rgb(59,59,59)","rgb(60,60,60)","rgb(61,61,61)","rgb(62,62,62)","rgb(63,63,63)","rgb(64,64,64)","rgb(65,65,65)","rgb(66,66,66)","rgb(67,67,67)","rgb(68,68,68)","rgb(69,69,69)","rgb(70,70,70)","rgb(71,71,71)","rgb(72,72,72)","rgb(73,73,73)","rgb(74,74,74)","rgb(75,75,75)","rgb(76,76,76)","rgb(77,77,77)","rgb(78,78,78)","rgb(79,79,79)","rgb(80,80,80)","rgb(81,81,81)","rgb(82,82,82)","rgb(83,83,83)","rgb(84,84,84)","rgb(85,85,85)","rgb(86,86,86)","rgb(87,87,87)","rgb(88,88,88)","rgb(89,89,89)","rgb(90,90,90)","rgb(91,91,91)","rgb(92,92,92)","rgb(93,93,93)","rgb(94,94,94)","rgb(95,95,95)","rgb(96,96,96)","rgb(97,97,97)","rgb(98,98,98)","rgb(99,99,99)","rgb(100,100,100)","rgb(101,101,101)","rgb(102,102,102)","rgb(103,103,103)","rgb(104,104,104)","rgb(105,105,105)","rgb(106,106,106)","rgb(107,107,107)","rgb(108,108,108)","rgb(109,109,109)","rgb(110,110,110)","rgb(111,111,111)","rgb(112,112,112)","rgb(113,113,113)","rgb(114,114,114)","rgb(115,115,115)","rgb(116,116,116)","rgb(117,117,117)","rgb(118,118,118)","rgb(119,119,119)","rgb(120,120,120)","rgb(121,121,121)","rgb(122,122,122)","rgb(123,123,123)","rgb(124,124,124)","rgb(125,125,125)","rgb(126,126,126)","rgb(127,127,127)","rgb(128,128,128)","rgb(129,129,129)","rgb(130,130,130)","rgb(131,131,131)","rgb(132,132,132)","rgb(133,133,133)","rgb(134,134,134)","rgb(135,135,135)","rgb(136,136,136)","rgb(137,137,137)","rgb(138,138,138)","rgb(139,139,139)","rgb(140,140,140)","rgb(141,141,141)","rgb(142,142,142)","rgb(143,143,143)","rgb(144,144,144)","rgb(145,145,145)","rgb(146,146,146)","rgb(147,147,147)","rgb(148,148,148)","rgb(149,149,149)","rgb(150,150,150)","rgb(151,151,151)","rgb(152,152,152)","rgb(153,153,153)","rgb(154,154,154)","rgb(155,155,155)","rgb(156,156,156)","rgb(157,157,157)","rgb(158,158,158)","rgb(159,159,159)","rgb(160,160,160)","rgb(161,161,161)","rgb(162,162,162)","rgb(163,163,163)","rgb(164,164,164)","rgb(165,165,165)","rgb(166,166,166)","rgb(167,167,167)","rgb(168,168,168)","rgb(169,169,169)","rgb(170,170,170)","rgb(171,171,171)","rgb(172,172,172)","rgb(173,173,173)","rgb(174,174,174)","rgb(175,175,175)","rgb(176,176,176)","rgb(177,177,177)","rgb(178,178,178)","rgb(179,179,179)","rgb(180,180,180)","rgb(181,181,181)","rgb(182,182,182)","rgb(183,183,183)","rgb(184,184,184)","rgb(185,185,185)","rgb(186,186,186)","rgb(187,187,187)","rgb(188,188,188)","rgb(189,189,189)","rgb(190,190,190)","rgb(191,191,191)","rgb(192,192,192)","rgb(193,193,193)","rgb(194,194,194)","rgb(195,195,195)","rgb(196,196,196)","rgb(197,197,197)","rgb(198,198,198)","rgb(199,199,199)","rgb(200,200,200)","rgb(201,201,201)","rgb(202,202,202)","rgb(203,203,203)","rgb(204,204,204)","rgb(205,205,205)","rgb(206,206,206)","rgb(207,207,207)","rgb(208,208,208)","rgb(209,209,209)","rgb(210,210,210)","rgb(211,211,211)","rgb(212,212,212)","rgb(213,213,213)","rgb(214,214,214)","rgb(215,215,215)","rgb(216,216,216)","rgb(217,217,217)","rgb(218,218,218)","rgb(219,219,219)","rgb(220,220,220)","rgb(221,221,221)","rgb(222,222,222)","rgb(223,223,223)","rgb(224,224,224)","rgb(225,225,225)","rgb(226,226,226)","rgb(227,227,227)","rgb(228,228,228)","rgb(229,229,229)","rgb(230,230,230)","rgb(231,231,231)","rgb(232,232,232)","rgb(233,233,233)","rgb(234,234,234)","rgb(235,235,235)","rgb(236,236,236)","rgb(237,237,237)","rgb(238,238,238)","rgb(239,239,239)","rgb(240,240,240)","rgb(241,241,241)","rgb(242,242,242)","rgb(243,243,243)","rgb(244,244,244)","rgb(245,245,245)","rgb(246,246,246)","rgb(247,247,247)","rgb(248,248,248)","rgb(249,249,249)","rgb(250,250,250)","rgb(251,251,251)","rgb(252,252,252)","rgb(253,253,253)","rgb(254,254,254)","rgb(255,255,255)"]},
{"id":"inversegrayscale","colors":["rgb(255,255,255)","rgb(255,255,255)","rgb(254,254,254)","rgb(253,253,253)","rgb(252,252,252)","rgb(251,251,251)","rgb(250,250,250)","rgb(249,249,249)","rgb(248,248,248)","rgb(247,247,247)","rgb(246,246,246)","rgb(245,245,245)","rgb(244,244,244)","rgb(243,243,243)","rgb(242,242,242)","rgb(241,241,241)","rgb(240,240,240)","rgb(239,239,239)","rgb(238,238,238)","rgb(237,237,237)","rgb(236,236,236)","rgb(235,235,235)","rgb(234,234,234)","rgb(233,233,233)","rgb(232,232,232)","rgb(231,231,231)","rgb(230,230,230)","rgb(229,229,229)","rgb(228,228,228)","rgb(227,227,227)","rgb(226,226,226)","rgb(225,225,225)","rgb(224,224,224)","rgb(223,223,223)","rgb(222,222,222)","rgb(221,221,221)","rgb(220,220,220)","rgb(219,219,219)","rgb(218,218,218)","rgb(217,217,217)","rgb(216,216,216)","rgb(215,215,215)","rgb(214,214,214)","rgb(213,213,213)","rgb(212,212,212)","rgb(211,211,211)","rgb(210,210,210)","rgb(209,209,209)","rgb(208,208,208)","rgb(207,207,207)","rgb(206,206,206)","rgb(205,205,205)","rgb(204,204,204)","rgb(203,203,203)","rgb(202,202,202)","rgb(201,201,201)","rgb(200,200,200)","rgb(199,199,199)","rgb(198,198,198)","rgb(197,197,197)","rgb(196,196,196)","rgb(195,195,195)","rgb(194,194,194)","rgb(193,193,193)","rgb(192,192,192)","rgb(191,191,191)","rgb(190,190,190)","rgb(189,189,189)","rgb(188,188,188)","rgb(187,187,187)","rgb(186,186,186)","rgb(185,185,185)","rgb(184,184,184)","rgb(183,183,183)","rgb(182,182,182)","rgb(181,181,181)","rgb(180,180,180)","rgb(179,179,179)","rgb(178,178,178)","rgb(177,177,177)","rgb(176,176,176)","rgb(175,175,175)","rgb(174,174,174)","rgb(173,173,173)","rgb(172,172,172)","rgb(171,171,171)","rgb(170,170,170)","rgb(169,169,169)","rgb(168,168,168)","rgb(167,167,167)","rgb(166,166,166)","rgb(165,165,165)","rgb(164,164,164)","rgb(163,163,163)","rgb(162,162,162)","rgb(161,161,161)","rgb(160,160,160)","rgb(159,159,159)","rgb(158,158,158)","rgb(157,157,157)","rgb(156,156,156)","rgb(155,155,155)","rgb(154,154,154)","rgb(153,153,153)","rgb(152,152,152)","rgb(151,151,151)","rgb(150,150,150)","rgb(149,149,149)","rgb(148,148,148)","rgb(147,147,147)","rgb(146,146,146)","rgb(145,145,145)","rgb(144,144,144)","rgb(143,143,143)","rgb(142,142,142)","rgb(141,141,141)","rgb(140,140,140)","rgb(139,139,139)","rgb(138,138,138)","rgb(137,137,137)","rgb(136,136,136)","rgb(135,135,135)","rgb(134,134,134)","rgb(133,133,133)","rgb(132,132,132)","rgb(131,131,131)","rgb(130,130,130)","rgb(129,129,129)","rgb(128,128,128)","rgb(127,127,127)","rgb(126,126,126)","rgb(125,125,125)","rgb(124,124,124)","rgb(123,123,123)","rgb(122,122,122)","rgb(121,121,121)","rgb(120,120,120)","rgb(119,119,119)","rgb(118,118,118)","rgb(117,117,117)","rgb(116,116,116)","rgb(115,115,115)","rgb(114,114,114)","rgb(113,113,113)","rgb(112,112,112)","rgb(111,111,111)","rgb(110,110,110)","rgb(109,109,109)","rgb(108,108,108)","rgb(107,107,107)","rgb(106,106,106)","rgb(105,105,105)","rgb(104,104,104)","rgb(103,103,103)","rgb(102,102,102)","rgb(101,101,101)","rgb(100,100,100)","rgb(99,99,99)","rgb(98,98,98)","rgb(97,97,97)","rgb(96,96,96)","rgb(95,95,95)","rgb(94,94,94)","rgb(93,93,93)","rgb(92,92,92)","rgb(91,91,91)","rgb(90,90,90)","rgb(89,89,89)","rgb(88,88,88)","rgb(87,87,87)","rgb(86,86,86)","rgb(85,85,85)","rgb(84,84,84)","rgb(83,83,83)","rgb(82,82,82)","rgb(81,81,81)","rgb(80,80,80)","rgb(79,79,79)","rgb(78,78,78)","rgb(77,77,77)","rgb(76,76,76)","rgb(75,75,75)","rgb(74,74,74)","rgb(73,73,73)","rgb(72,72,72)","rgb(71,71,71)","rgb(70,70,70)","rgb(69,69,69)","rgb(68,68,68)","rgb(67,67,67)","rgb(66,66,66)","rgb(65,65,65)","rgb(64,64,64)","rgb(63,63,63)","rgb(62,62,62)","rgb(61,61,61)","rgb(60,60,60)","rgb(59,59,59)","rgb(58,58,58)","rgb(57,57,57)","rgb(56,56,56)","rgb(55,55,55)","rgb(54,54,54)","rgb(53,53,53)","rgb(52,52,52)","rgb(51,51,51)","rgb(50,50,50)","rgb(49,49,49)","rgb(48,48,48)","rgb(47,47,47)","rgb(46,46,46)","rgb(45,45,45)","rgb(44,44,44)","rgb(43,43,43)","rgb(42,42,42)","rgb(41,41,41)","rgb(40,40,40)","rgb(39,39,39)","rgb(38,38,38)","rgb(37,37,37)","rgb(36,36,36)","rgb(35,35,35)","rgb(34,34,34)","rgb(33,33,33)","rgb(32,32,32)","rgb(31,31,31)","rgb(30,30,30)","rgb(29,29,29)","rgb(28,28,28)","rgb(27,27,27)","rgb(26,26,26)","rgb(25,25,25)","rgb(24,24,24)","rgb(23,23,23)","rgb(22,22,22)","rgb(21,21,21)","rgb(20,20,20)","rgb(19,19,19)","rgb(18,18,18)","rgb(17,17,17)","rgb(16,16,16)","rgb(15,15,15)","rgb(14,14,14)","rgb(13,13,13)","rgb(12,12,12)","rgb(11,11,11)","rgb(10,10,10)","rgb(9,9,9)","rgb(8,8,8)","rgb(7,7,7)","rgb(6,6,6)","rgb(5,5,5)","rgb(4,4,4)","rgb(3,3,3)","rgb(2,2,2)","rgb(1,1,1)"]},
{"id":"lightgrayscale","colors":["rgb(62,62,62)","rgb(69,69,69)","rgb(75,75,75)","rgb(82,82,82)","rgb(88,88,88)","rgb(95,95,95)","rgb(102,102,102)","rgb(108,108,108)","rgb(115,115,115)","rgb(121,121,121)","rgb(128,128,128)","rgb(135,135,135)","rgb(141,141,141)","rgb(148,148,148)","rgb(155,155,155)","rgb(161,161,161)","rgb(168,168,168)","rgb(174,174,174)","rgb(181,181,181)","rgb(188,188,188)","rgb(194,194,194)","rgb(201,201,201)","rgb(207,207,207)","rgb(214,214,214)","rgb(221,221,221)","rgb(227,227,227)","rgb(234,234,234)","rgb(240,240,240)","rgb(247,247,247)","rgb(254,254,254)"]},
{"id":"blues","colors":["rgb(255,255,255)","rgb(246,246,255)","rgb(237,237,255)","rgb(228,228,255)","rgb(219,219,255)","rgb(211,211,255)","rgb(202,202,255)","rgb(193,193,255)","rgb(184,184,255)","rgb(175,175,255)","rgb(167,167,255)","rgb(158,158,255)","rgb(149,149,255)","rgb(140,140,255)","rgb(131,131,255)","rgb(123,123,255)","rgb(114,114,255)","rgb(105,105,255)","rgb(96,96,255)","rgb(87,87,255)","rgb(79,79,255)","rgb(70,70,255)","rgb(61,61,255)","rgb(52,52,255)","rgb(43,43,255)","rgb(35,35,255)","rgb(26,26,255)","rgb(17,17,255)","rgb(8,8,255)","rgb(0,0,255)"]},
{"id":"plotly_blues","colors":["rgb(5,10,172)","rgb(6,11,173)","rgb(7,13,173)","rgb(8,14,174)","rgb(9,16,174)","rgb(10,17,175)","rgb(11,19,175)","rgb(12,20,176)","rgb(13,21,176)","rgb(14,23,177)","rgb(15,24,177)","rgb(16,26,178)","rgb(17,27,178)","rgb(18,29,179)","rgb(19,30,179)","rgb(20,31,180)","rgb(21,33,180)","rgb(22,34,181)","rgb(23,36,181)","rgb(24,37,182)","rgb(25,39,182)","rgb(26,40,183)","rgb(27,41,183)","rgb(28,43,184)","rgb(29,44,184)","rgb(30,46,185)","rgb(31,47,185)","rgb(32,49,186)","rgb(33,50,186)","rgb(34,51,187)","rgb(35,53,187)","rgb(36,54,188)","rgb(37,56,188)","rgb(38,57,189)","rgb(39,59,189)","rgb(40,60,190)","rgb(42,63,194)","rgb(44,65,197)","rgb(46,68,201)","rgb(48,71,205)","rgb(50,73,208)","rgb(52,76,212)","rgb(54,79,216)","rgb(56,81,219)","rgb(58,84,223)","rgb(60,87,227)","rgb(62,89,230)","rgb(64,92,234)","rgb(66,95,238)","rgb(68,97,241)","rgb(70,100,245)","rgb(72,102,245)","rgb(74,104,245)","rgb(76,106,245)","rgb(78,108,245)","rgb(80,110,245)","rgb(82,112,245)","rgb(84,114,245)","rgb(86,116,245)","rgb(88,118,245)","rgb(90,120,245)","rgb(92,122,245)","rgb(93,123,245)","rgb(95,125,246)","rgb(96,127,246)","rgb(98,129,246)","rgb(100,130,246)","rgb(101,132,246)","rgb(103,134,247)","rgb(104,135,247)","rgb(106,137,247)","rgb(110,140,246)","rgb(114,143,245)","rgb(117,145,244)","rgb(121,148,243)","rgb(125,151,242)","rgb(129,154,242)","rgb(133,156,241)","rgb(136,159,240)","rgb(140,162,239)","rgb(144,165,238)","rgb(148,167,237)","rgb(152,170,236)","rgb(155,173,235)","rgb(159,176,234)","rgb(163,179,233)","rgb(167,181,233)","rgb(171,184,232)","rgb(174,187,231)","rgb(178,190,230)","rgb(182,192,229)","rgb(186,195,228)","rgb(190,198,227)","rgb(193,201,226)","rgb(197,203,225)","rgb(201,206,224)","rgb(205,209,224)","rgb(209,212,223)","rgb(212,214,222)","rgb(216,217,221)"]},
{"id":"plotly_greens","colors":["rgb(0,68,27)","rgb(0,71,28)","rgb(0,75,30)","rgb(0,78,31)","rgb(0,81,32)","rgb(0,84,34)","rgb(0,88,35)","rgb(0,91,37)","rgb(0,94,38)","rgb(0,98,39)","rgb(0,101,41)","rgb(0,104,42)","rgb(0,107,43)","rgb(1,110,45)","rgb(4,113,47)","rgb(7,115,49)","rgb(10,117,51)","rgb(13,120,53)","rgb(15,122,55)","rgb(18,125,57)","rgb(21,127,59)","rgb(24,129,61)","rgb(27,132,63)","rgb(29,134,65)","rgb(32,137,67)","rgb(35,139,69)","rgb(37,142,71)","rgb(40,144,73)","rgb(42,147,75)","rgb(45,149,77)","rgb(47,152,79)","rgb(49,154,81)","rgb(52,157,82)","rgb(54,159,84)","rgb(57,162,86)","rgb(59,165,88)","rgb(61,167,90)","rgb(64,170,92)","rgb(67,172,94)","rgb(71,174,96)","rgb(75,176,98)","rgb(79,178,100)","rgb(83,180,102)","rgb(87,182,104)","rgb(92,184,106)","rgb(96,186,108)","rgb(100,188,110)","rgb(104,190,112)","rgb(108,192,114)","rgb(112,194,116)","rgb(116,196,118)","rgb(120,198,121)","rgb(123,199,124)","rgb(127,201,127)","rgb(130,203,130)","rgb(134,204,133)","rgb(138,206,136)","rgb(141,208,139)","rgb(145,209,142)","rgb(148,211,145)","rgb(152,213,148)","rgb(156,214,151)","rgb(159,216,154)","rgb(163,218,156)","rgb(166,219,159)","rgb(169,220,162)","rgb(172,221,165)","rgb(175,223,168)","rgb(178,224,171)","rgb(181,225,174)","rgb(184,227,177)","rgb(187,228,180)","rgb(190,229,183)","rgb(193,230,186)","rgb(196,232,189)","rgb(199,233,192)","rgb(201,234,195)","rgb(204,235,197)","rgb(206,236,200)","rgb(209,237,202)","rgb(211,238,205)","rgb(213,239,207)","rgb(216,240,210)","rgb(218,241,212)","rgb(221,242,215)","rgb(223,243,218)","rgb(225,244,220)","rgb(228,245,223)","rgb(230,245,225)","rgb(231,246,227)","rgb(233,246,228)","rgb(234,247,230)","rgb(235,248,232)","rgb(237,248,233)","rgb(238,249,235)","rgb(240,249,237)","rgb(241,250,238)","rgb(243,250,240)","rgb(244,251,242)","rgb(246,251,243)"]},
{"id":"plotly_ylorrd","colors":["rgb(128,0,38)","rgb(133,0,38)","rgb(138,0,38)","rgb(143,0,38)","rgb(148,0,38)","rgb(152,0,38)","rgb(157,0,38)","rgb(162,0,38)","rgb(167,0,38)","rgb(172,0,38)","rgb(177,0,38)","rgb(182,0,38)","rgb(187,0,38)","rgb(191,1,38)","rgb(194,3,37)","rgb(197,5,36)","rgb(200,7,35)","rgb(203,9,34)","rgb(206,11,34)","rgb(209,14,33)","rgb(212,16,32)","rgb(215,18,31)","rgb(218,20,30)","rgb(221,22,30)","rgb(224,24,29)","rgb(227,26,28)","rgb(229,30,29)","rgb(231,34,30)","rgb(233,38,31)","rgb(235,43,32)","rgb(237,47,34)","rgb(239,51,35)","rgb(241,55,36)","rgb(243,59,37)","rgb(245,63,38)","rgb(247,68,39)","rgb(249,72,40)","rgb(251,76,41)","rgb(252,81,43)","rgb(252,86,44)","rgb(252,91,46)","rgb(252,96,47)","rgb(252,101,48)","rgb(252,106,50)","rgb(253,111,51)","rgb(253,116,53)","rgb(253,121,54)","rgb(253,126,56)","rgb(253,131,57)","rgb(253,136,59)","rgb(253,141,60)","rgb(253,144,61)","rgb(253,147,63)","rgb(253,150,64)","rgb(253,153,65)","rgb(253,156,66)","rgb(253,159,68)","rgb(254,162,69)","rgb(254,165,70)","rgb(254,168,72)","rgb(254,171,73)","rgb(254,174,74)","rgb(254,177,75)","rgb(254,180,78)","rgb(254,183,81)","rgb(254,186,84)","rgb(254,189,88)","rgb(254,192,91)","rgb(254,195,94)","rgb(254,198,98)","rgb(254,201,101)","rgb(254,205,105)","rgb(254,208,108)","rgb(254,211,111)","rgb(254,214,115)","rgb(254,217,118)","rgb(254,219,121)","rgb(254,220,125)","rgb(254,222,128)","rgb(254,223,131)","rgb(254,225,135)","rgb(254,227,138)","rgb(255,228,142)","rgb(255,230,145)","rgb(255,231,148)","rgb(255,233,152)","rgb(255,235,155)","rgb(255,236,158)","rgb(255,238,162)","rgb(255,239,165)","rgb(255,241,169)","rgb(255,242,172)","rgb(255,243,176)","rgb(255,245,179)","rgb(255,246,183)","rgb(255,248,186)","rgb(255,249,190)","rgb(255,251,193)","rgb(255,252,197)","rgb(255,254,200)"]},
{"id":"plotly_reds","colors":["rgb(220,220,220)","rgb(221,219,217)","rgb(223,218,214)","rgb(224,216,211)","rgb(225,215,207)","rgb(226,214,204)","rgb(228,213,201)","rgb(229,211,198)","rgb(230,210,195)","rgb(231,209,192)","rgb(233,208,189)","rgb(234,206,185)","rgb(235,205,182)","rgb(236,204,179)","rgb(238,203,176)","rgb(239,201,173)","rgb(240,200,170)","rgb(241,199,166)","rgb(243,198,163)","rgb(244,196,160)","rgb(245,195,157)","rgb(245,193,154)","rgb(245,192,152)","rgb(245,190,149)","rgb(245,188,147)","rgb(245,186,144)","rgb(245,185,141)","rgb(245,183,139)","rgb(245,181,136)","rgb(245,179,134)","rgb(245,178,131)","rgb(245,176,128)","rgb(245,174,126)","rgb(245,172,123)","rgb(245,170,121)","rgb(245,169,118)","rgb(245,167,115)","rgb(245,165,113)","rgb(245,163,110)","rgb(245,162,108)","rgb(245,160,105)","rgb(244,157,104)","rgb(243,155,102)","rgb(242,152,101)","rgb(241,150,100)","rgb(239,147,99)","rgb(238,145,97)","rgb(237,142,96)","rgb(236,140,95)","rgb(235,137,93)","rgb(234,135,92)","rgb(233,132,91)","rgb(232,130,90)","rgb(230,127,88)","rgb(229,125,87)","rgb(228,122,86)","rgb(227,120,84)","rgb(226,117,83)","rgb(225,115,82)","rgb(224,112,81)","rgb(223,110,79)","rgb(222,107,78)","rgb(220,105,77)","rgb(219,102,75)","rgb(218,100,74)","rgb(217,97,73)","rgb(216,95,72)","rgb(215,92,70)","rgb(214,90,69)","rgb(213,87,68)","rgb(211,85,66)","rgb(210,82,65)","rgb(209,80,64)","rgb(208,77,63)","rgb(207,75,61)","rgb(206,72,60)","rgb(205,70,59)","rgb(204,67,58)","rgb(203,65,56)","rgb(201,62,55)","rgb(200,60,54)","rgb(199,57,52)","rgb(198,55,51)","rgb(197,52,50)","rgb(196,50,49)","rgb(195,47,47)","rgb(194,45,46)","rgb(193,42,45)","rgb(191,40,43)","rgb(190,37,42)","rgb(189,35,41)","rgb(188,32,40)","rgb(187,30,38)","rgb(186,27,37)","rgb(185,25,36)","rgb(184,22,34)","rgb(182,20,33)","rgb(181,17,32)","rgb(180,15,31)","rgb(179,12,29)"]},
{"id":"plotly_bluered","colors":["rgb(0,0,255)","rgb(3,0,252)","rgb(5,0,250)","rgb(8,0,247)","rgb(10,0,245)","rgb(13,0,242)","rgb(15,0,240)","rgb(18,0,237)","rgb(20,0,235)","rgb(23,0,232)","rgb(25,0,230)","rgb(28,0,227)","rgb(31,0,224)","rgb(33,0,222)","rgb(36,0,219)","rgb(38,0,217)","rgb(41,0,214)","rgb(43,0,212)","rgb(46,0,209)","rgb(48,0,207)","rgb(51,0,204)","rgb(54,0,201)","rgb(56,0,199)","rgb(59,0,196)","rgb(61,0,194)","rgb(64,0,191)","rgb(66,0,189)","rgb(69,0,186)","rgb(71,0,184)","rgb(74,0,181)","rgb(77,0,178)","rgb(79,0,176)","rgb(82,0,173)","rgb(84,0,171)","rgb(87,0,168)","rgb(89,0,166)","rgb(92,0,163)","rgb(94,0,161)","rgb(97,0,158)","rgb(99,0,156)","rgb(102,0,153)","rgb(105,0,150)","rgb(107,0,148)","rgb(110,0,145)","rgb(112,0,143)","rgb(115,0,140)","rgb(117,0,138)","rgb(120,0,135)","rgb(122,0,133)","rgb(125,0,130)","rgb(128,0,127)","rgb(130,0,125)","rgb(133,0,122)","rgb(135,0,120)","rgb(138,0,117)","rgb(140,0,115)","rgb(143,0,112)","rgb(145,0,110)","rgb(148,0,107)","rgb(150,0,105)","rgb(153,0,102)","rgb(156,0,99)","rgb(158,0,97)","rgb(161,0,94)","rgb(163,0,92)","rgb(166,0,89)","rgb(168,0,87)","rgb(171,0,84)","rgb(173,0,82)","rgb(176,0,79)","rgb(179,0,76)","rgb(181,0,74)","rgb(184,0,71)","rgb(186,0,69)","rgb(189,0,66)","rgb(191,0,64)","rgb(194,0,61)","rgb(196,0,59)","rgb(199,0,56)","rgb(201,0,54)","rgb(204,0,51)","rgb(207,0,48)","rgb(209,0,46)","rgb(212,0,43)","rgb(214,0,41)","rgb(217,0,38)","rgb(219,0,36)","rgb(222,0,33)","rgb(224,0,31)","rgb(227,0,28)","rgb(230,0,25)","rgb(232,0,23)","rgb(235,0,20)","rgb(237,0,18)","rgb(240,0,15)","rgb(242,0,13)","rgb(245,0,10)","rgb(247,0,8)","rgb(250,0,5)","rgb(252,0,3)"]},
{"id":"plotly_ylgnbu","colors":["rgb(8,29,88)","rgb(10,31,93)","rgb(13,33,98)","rgb(15,35,102)","rgb(17,36,107)","rgb(20,38,112)","rgb(22,40,117)","rgb(24,42,122)","rgb(27,44,126)","rgb(29,46,131)","rgb(31,47,136)","rgb(34,49,141)","rgb(36,51,146)","rgb(37,54,149)","rgb(37,57,150)","rgb(36,60,152)","rgb(36,64,154)","rgb(36,67,155)","rgb(36,70,157)","rgb(35,74,158)","rgb(35,77,160)","rgb(35,81,162)","rgb(35,84,163)","rgb(34,87,165)","rgb(34,91,166)","rgb(34,94,168)","rgb(34,98,170)","rgb(33,102,172)","rgb(33,106,174)","rgb(32,110,176)","rgb(32,114,178)","rgb(32,118,180)","rgb(31,123,181)","rgb(31,127,183)","rgb(30,131,185)","rgb(30,135,187)","rgb(30,139,189)","rgb(29,143,191)","rgb(30,146,192)","rgb(33,149,192)","rgb(36,152,193)","rgb(39,155,193)","rgb(42,158,193)","rgb(45,161,194)","rgb(48,164,194)","rgb(51,167,194)","rgb(53,170,195)","rgb(56,173,195)","rgb(59,176,195)","rgb(62,179,196)","rgb(65,182,196)","rgb(70,184,195)","rgb(75,186,195)","rgb(80,188,194)","rgb(85,189,193)","rgb(90,191,192)","rgb(95,193,192)","rgb(100,195,191)","rgb(105,197,190)","rgb(110,199,190)","rgb(115,200,189)","rgb(120,202,188)","rgb(125,204,187)","rgb(130,206,187)","rgb(136,208,186)","rgb(141,211,186)","rgb(147,213,185)","rgb(153,215,184)","rgb(159,217,184)","rgb(164,220,183)","rgb(170,222,183)","rgb(176,224,182)","rgb(182,226,182)","rgb(187,229,181)","rgb(193,231,181)","rgb(199,233,180)","rgb(202,234,183)","rgb(205,235,186)","rgb(208,237,189)","rgb(211,238,192)","rgb(214,239,195)","rgb(217,240,198)","rgb(220,241,201)","rgb(223,243,204)","rgb(226,244,207)","rgb(229,245,210)","rgb(232,246,213)","rgb(235,247,216)","rgb(238,248,217)","rgb(239,249,217)","rgb(241,249,217)","rgb(242,250,217)","rgb(243,251,217)","rgb(245,251,217)","rgb(246,252,217)","rgb(248,252,217)","rgb(249,253,217)","rgb(251,253,217)","rgb(252,254,217)","rgb(254,254,217)"]},
{"id":"plotly_electric","colors":["rgb(0,0,0)","rgb(2,0,7)","rgb(4,0,13)","rgb(6,0,20)","rgb(8,0,27)","rgb(10,0,33)","rgb(12,0,40)","rgb(14,0,47)","rgb(16,0,53)","rgb(18,0,60)","rgb(20,0,67)","rgb(22,0,73)","rgb(24,0,80)","rgb(26,0,87)","rgb(28,0,93)","rgb(30,0,100)","rgb(34,0,100)","rgb(37,0,100)","rgb(41,0,100)","rgb(44,0,100)","rgb(48,0,100)","rgb(52,0,100)","rgb(55,0,100)","rgb(59,0,100)","rgb(62,0,100)","rgb(66,0,100)","rgb(70,0,100)","rgb(73,0,100)","rgb(77,0,100)","rgb(80,0,100)","rgb(84,0,100)","rgb(88,0,100)","rgb(91,0,100)","rgb(95,0,100)","rgb(98,0,100)","rgb(102,0,100)","rgb(106,0,100)","rgb(109,0,100)","rgb(113,0,100)","rgb(116,0,100)","rgb(120,0,100)","rgb(122,5,95)","rgb(124,9,90)","rgb(126,14,85)","rgb(128,18,80)","rgb(130,23,75)","rgb(132,27,70)","rgb(134,32,65)","rgb(136,36,60)","rgb(138,41,55)","rgb(140,45,50)","rgb(142,50,45)","rgb(144,54,40)","rgb(146,59,35)","rgb(148,63,30)","rgb(150,68,25)","rgb(152,72,20)","rgb(154,77,15)","rgb(156,81,10)","rgb(158,86,5)","rgb(160,90,0)","rgb(164,96,0)","rgb(167,101,0)","rgb(171,107,0)","rgb(174,112,0)","rgb(178,118,0)","rgb(181,123,0)","rgb(185,129,0)","rgb(188,134,0)","rgb(192,140,0)","rgb(195,145,0)","rgb(199,151,0)","rgb(202,156,0)","rgb(206,162,0)","rgb(209,167,0)","rgb(213,173,0)","rgb(216,178,0)","rgb(220,184,0)","rgb(223,189,0)","rgb(227,195,0)","rgb(230,200,0)","rgb(231,203,11)","rgb(233,205,22)","rgb(234,208,33)","rgb(235,210,44)","rgb(236,213,55)","rgb(238,215,66)","rgb(239,218,77)","rgb(240,220,88)","rgb(241,223,99)","rgb(243,225,110)","rgb(244,228,121)","rgb(245,230,132)","rgb(246,233,143)","rgb(248,235,154)","rgb(249,238,165)","rgb(250,240,176)","rgb(251,243,187)","rgb(253,245,198)","rgb(254,248,209)"]},
{"id":"plotly_viridis","colors":["#440154","#450558","#45085b","#460c5f","#471062","#471366","#481769","#481a6c","#481e6f","#482171","#472474","#472877","#472b7a","#472e7c","#46317e","#45347f","#443781","#433a83","#433e85","#424186","#414387","#404688","#3e4989","#3d4c89","#3c4f8a","#3b528b","#3a548b","#39578c","#375a8c","#365d8c","#355f8d","#33628d","#32658d","#31678d","#30698d","#2f6c8e","#2e6e8e","#2d708e","#2c738e","#2b758e","#2a788e","#297b8e","#287d8e","#27808e","#26828e","#25858e","#24878d","#24898d","#238c8d","#228e8c","#21918c","#21938b","#20958b","#20988a","#209a8a","#1f9c89","#1f9f88","#20a187","#21a386","#23a685","#24a883","#25aa82","#27ac81","#29af7f","#2db17d","#30b37b","#34b579","#38b777","#3bba75","#3fbc73","#44be70","#49c06e","#4ec26b","#53c468","#58c666","#5dc863","#62ca5f","#68cc5c","#6ece58","#74cf54","#7bd151","#81d34d","#87d549","#8dd645","#94d741","#9ad83c","#a1da38","#a7db34","#aedc2f","#b5dd2c","#bcde28","#c3df24","#c9e021","#d0e11d","#d7e219","#dee31b","#e4e41d","#eae41f","#f0e521","#f7e623"]},
{"id":"plotly_cividis","colors":["rgb(0,32,76)","rgb(0,34,80)","rgb(0,35,85)","rgb(0,37,89)","rgb(0,39,94)","rgb(0,40,98)","rgb(0,42,102)","rgb(0,44,104)","rgb(0,46,105)","rgb(0,47,106)","rgb(0,49,108)","rgb(0,51,109)","rgb(2,52,110)","rgb(8,54,110)","rgb(15,56,109)","rgb(21,58,109)","rgb(28,60,109)","rgb(35,62,108)","rgb(40,64,108)","rgb(44,66,108)","rgb(47,67,108)","rgb(51,69,107)","rgb(55,71,107)","rgb(58,73,107)","rgb(61,75,107)","rgb(64,77,107)","rgb(67,79,107)","rgb(69,80,107)","rgb(72,82,107)","rgb(75,84,107)","rgb(77,86,107)","rgb(80,88,108)","rgb(83,89,108)","rgb(85,91,108)","rgb(88,93,109)","rgb(90,95,109)","rgb(93,96,109)","rgb(95,98,110)","rgb(97,100,110)","rgb(99,102,111)","rgb(101,104,111)","rgb(104,106,112)","rgb(106,108,113)","rgb(108,109,114)","rgb(110,111,114)","rgb(112,113,115)","rgb(115,115,116)","rgb(117,117,117)","rgb(119,119,117)","rgb(122,121,118)","rgb(124,123,119)","rgb(126,125,119)","rgb(129,127,120)","rgb(131,129,120)","rgb(134,131,120)","rgb(136,133,120)","rgb(139,135,120)","rgb(141,137,120)","rgb(144,138,120)","rgb(146,140,120)","rgb(149,142,120)","rgb(152,144,119)","rgb(154,146,119)","rgb(157,149,119)","rgb(159,151,118)","rgb(162,153,118)","rgb(164,155,117)","rgb(167,157,116)","rgb(169,159,116)","rgb(172,161,115)","rgb(175,164,114)","rgb(177,166,114)","rgb(180,168,113)","rgb(183,170,112)","rgb(185,172,111)","rgb(188,174,110)","rgb(191,176,109)","rgb(194,178,108)","rgb(196,181,107)","rgb(199,183,106)","rgb(202,185,105)","rgb(205,188,104)","rgb(208,190,102)","rgb(211,192,101)","rgb(213,195,99)","rgb(216,197,97)","rgb(219,199,96)","rgb(222,201,94)","rgb(224,203,92)","rgb(227,206,90)","rgb(230,209,88)","rgb(233,211,86)","rgb(237,214,84)","rgb(240,216,81)","rgb(243,219,79)","rgb(245,221,77)","rgb(247,223,76)","rgb(249,226,74)","rgb(251,228,72)","rgb(253,231,71)"]},
{id:'inferno',colors: Utils.makeRGBColortable(0,0,3,0,0,4,0,0,6,1,0,7,1,1,9,1,1,11,2,1,14,2,2,16,3,2,18,4,3,20,4,3,22,5,4,24,6,4,27,7,5,29,8,6,31,9,6,33,10,7,35,11,7,38,13,8,40,14,8,42,15,9,45,16,9,47,18,10,50,19,10,52,20,11,54,22,11,57,23,11,59,25,11,62,26,11,64,28,12,67,29,12,69,31,12,71,32,12,74,34,11,76,36,11,78,38,11,80,39,11,82,41,11,84,43,10,86,45,10,88,46,10,90,48,10,92,50,9,93,52,9,95,53,9,96,55,9,97,57,9,98,59,9,100,60,9,101,62,9,102,64,9,102,65,9,103,67,10,104,69,10,105,70,10,105,72,11,106,74,11,106,75,12,107,77,12,107,79,13,108,80,13,108,82,14,108,83,14,109,85,15,109,87,15,109,88,16,109,90,17,109,91,17,110,93,18,110,95,18,110,96,19,110,98,20,110,99,20,110,101,21,110,102,21,110,104,22,110,106,23,110,107,23,110,109,24,110,110,24,110,112,25,110,114,25,109,115,26,109,117,27,109,118,27,109,120,28,109,122,28,109,123,29,108,125,29,108,126,30,108,128,31,107,129,31,107,131,32,107,133,32,106,134,33,106,136,33,106,137,34,105,139,34,105,141,35,105,142,36,104,144,36,104,145,37,103,147,37,103,149,38,102,150,38,102,152,39,101,153,40,100,155,40,100,156,41,99,158,41,99,160,42,98,161,43,97,163,43,97,164,44,96,166,44,95,167,45,95,169,46,94,171,46,93,172,47,92,174,48,91,175,49,91,177,49,90,178,50,89,180,51,88,181,51,87,183,52,86,184,53,86,186,54,85,187,55,84,189,55,83,190,56,82,191,57,81,193,58,80,194,59,79,196,60,78,197,61,77,199,62,76,200,62,75,201,63,74,203,64,73,204,65,72,205,66,71,207,68,70,208,69,68,209,70,67,210,71,66,212,72,65,213,73,64,214,74,63,215,75,62,217,77,61,218,78,59,219,79,58,220,80,57,221,82,56,222,83,55,223,84,54,224,86,52,226,87,51,227,88,50,228,90,49,229,91,48,230,92,46,230,94,45,231,95,44,232,97,43,233,98,42,234,100,40,235,101,39,236,103,38,237,104,37,237,106,35,238,108,34,239,109,33,240,111,31,240,112,30,241,114,29,242,116,28,242,117,26,243,119,25,243,121,24,244,122,22,245,124,21,245,126,20,246,128,18,246,129,17,247,131,16,247,133,14,248,135,13,248,136,12,248,138,11,249,140,9,249,142,8,249,144,8,250,145,7,250,147,6,250,149,6,250,151,6,251,153,6,251,155,6,251,157,6,251,158,7,251,160,7,251,162,8,251,164,10,251,166,11,251,168,13,251,170,14,251,172,16,251,174,18,251,176,20,251,177,22,251,179,24,251,181,26,251,183,28,251,185,30,250,187,33,250,189,35,250,191,37,250,193,40,249,195,42,249,197,44,249,199,47,248,201,49,248,203,52,248,205,55,247,207,58,247,209,60,246,211,63,246,213,66,245,215,69,245,217,72,244,219,75,244,220,79,243,222,82,243,224,86,243,226,89,242,228,93,242,230,96,241,232,100,241,233,104,241,235,108,241,237,112,241,238,116,241,240,121,241,242,125,242,243,129,242,244,133,243,246,137,244,247,141,245,248,145,246,250,149,247,251,153,249,252,157,250,253,160,252,254,164)},
{id:'plasma',colors: Utils.makeRGBColortable(12,7,134,16,7,135,19,6,137,21,6,138,24,6,139,27,6,140,29,6,141,31,5,142,33,5,143,35,5,144,37,5,145,39,5,146,41,5,147,43,5,148,45,4,148,47,4,149,49,4,150,51,4,151,52,4,152,54,4,152,56,4,153,58,4,154,59,3,154,61,3,155,63,3,156,64,3,156,66,3,157,68,3,158,69,3,158,71,2,159,73,2,159,74,2,160,76,2,161,78,2,161,79,2,162,81,1,162,82,1,163,84,1,163,86,1,163,87,1,164,89,1,164,90,0,165,92,0,165,94,0,165,95,0,166,97,0,166,98,0,166,100,0,167,101,0,167,103,0,167,104,0,167,106,0,167,108,0,168,109,0,168,111,0,168,112,0,168,114,0,168,115,0,168,117,0,168,118,1,168,120,1,168,121,1,168,123,2,168,124,2,167,126,3,167,127,3,167,129,4,167,130,4,167,132,5,166,133,6,166,134,7,166,136,7,165,137,8,165,139,9,164,140,10,164,142,12,164,143,13,163,144,14,163,146,15,162,147,16,161,149,17,161,150,18,160,151,19,160,153,20,159,154,21,158,155,23,158,157,24,157,158,25,156,159,26,155,160,27,155,162,28,154,163,29,153,164,30,152,165,31,151,167,33,151,168,34,150,169,35,149,170,36,148,172,37,147,173,38,146,174,39,145,175,40,144,176,42,143,177,43,143,178,44,142,180,45,141,181,46,140,182,47,139,183,48,138,184,50,137,185,51,136,186,52,135,187,53,134,188,54,133,189,55,132,190,56,131,191,57,130,192,59,129,193,60,128,194,61,128,195,62,127,196,63,126,197,64,125,198,65,124,199,66,123,200,68,122,201,69,121,202,70,120,203,71,119,204,72,118,205,73,117,206,74,117,207,75,116,208,77,115,209,78,114,209,79,113,210,80,112,211,81,111,212,82,110,213,83,109,214,85,109,215,86,108,215,87,107,216,88,106,217,89,105,218,90,104,219,91,103,220,93,102,220,94,102,221,95,101,222,96,100,223,97,99,223,98,98,224,100,97,225,101,96,226,102,96,227,103,95,227,104,94,228,106,93,229,107,92,229,108,91,230,109,90,231,110,90,232,112,89,232,113,88,233,114,87,234,115,86,234,116,85,235,118,84,236,119,84,236,120,83,237,121,82,237,123,81,238,124,80,239,125,79,239,126,78,240,128,77,240,129,77,241,130,76,242,132,75,242,133,74,243,134,73,243,135,72,244,137,71,244,138,71,245,139,70,245,141,69,246,142,68,246,143,67,246,145,66,247,146,65,247,147,65,248,149,64,248,150,63,248,152,62,249,153,61,249,154,60,250,156,59,250,157,58,250,159,58,250,160,57,251,162,56,251,163,55,251,164,54,252,166,53,252,167,53,252,169,52,252,170,51,252,172,50,252,173,49,253,175,49,253,176,48,253,178,47,253,179,46,253,181,45,253,182,45,253,184,44,253,185,43,253,187,43,253,188,42,253,190,41,253,192,41,253,193,40,253,195,40,253,196,39,253,198,38,252,199,38,252,201,38,252,203,37,252,204,37,252,206,37,251,208,36,251,209,36,251,211,36,250,213,36,250,214,36,250,216,36,249,217,36,249,219,36,248,221,36,248,223,36,247,224,36,247,226,37,246,228,37,246,229,37,245,231,38,245,233,38,244,234,38,243,236,38,243,238,38,242,240,38,242,241,38,241,243,38,240,245,37,240,246,35,239,248,33)},



{"category":"Map Ramps"},
{"id":"white_blue","colors":["rgb(244,252,254)","rgb(101,239,255)","rgb(50,227,255)","rgb(0,169,204)","rgb(0,122,153)"]},
{"id":"blue_green","colors":["#f7fcfd","#e5f5f9","#ccece6","#99d8c9","#66c2a4","#41ae76","#238b45","#006d2c","#00441b"]},
{"id":"blue_purple","colors":["#f7fcfd","#e0ecf4","#bfd3e6","#9ebcda","#8c96c6","#8c6bb1","#88419d","#810f7c","#4d004b"]},
{"id":"green_blue","colors":["#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4","#4eb3d3","#2b8cbe","#0868ac","#084081"]},
{"id":"orange_red","colors":["#fff7ec","#fee8c8","#fdd49e","#fdbb84","#fc8d59","#ef6548","#d7301f","#b30000","#7f0000"]},
{"id":"purple_blue","colors":["#fff7fb","#ece7f2","#d0d1e6","#a6bddb","#74a9cf","#3690c0","#0570b0","#045a8d","#023858"]},
{"id":"purple_blue_green","colors":["#fff7fb","#ece2f0","#d0d1e6","#a6bddb","#67a9cf","#3690c0","#02818a","#016c59","#014636"]},
{"id":"purple_red","colors":["#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f"]},
{"id":"red_purple","colors":["#fff7f3","#fde0dd","#fcc5c0","#fa9fb5","#f768a1","#dd3497","#ae017e","#7a0177","#49006a"]},
{"id":"yellow_green","colors":["#ffffe5","#f7fcb9","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#006837","#004529"]},
{"id":"yellow_green_blue","colors":["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58"]},
{"id":"yellow_orange_brown","colors":["#ffffe5","#fff7bc","#fee391","#fec44f","#fe9929","#ec7014","#cc4c02","#993404","#662506"]},
{"id":"yellow_orange_red","colors":["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#fc4e2a","#e31a1c","#bd0026","#800026"]},
{"id":"oranges","colors":["#fdd0a2","#fdae6b","#fd8d3c","#f16913","#d94801","#a63603","#7f2704"]},
{"id":"purples","colors":["#fcfbfd","#efedf5","#dadaeb","#bcbddc","#9e9ac8","#807dba","#6a51a3","#54278f","#3f007d"]},
{"id":"reds","colors":["#fff5f0","#fee0d2","#fcbba1","#fc9272","#fb6a4a","#ef3b2c","#cb181d","#a50f15","#67000d"]},
{"id":"greens","colors":["#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#006d2c","#00441b"]},
{"id":"map_grays","colors":["#ffffff","#f0f0f0","#d9d9d9","#bdbdbd","#969696","#737373","#525252","#252525","#000000"]},
{"id":"d3_schemeBuGn","colors":["#f7fcfd","#e5f5f9","#ccece6","#99d8c9","#66c2a4","#41ae76","#238b45","#006d2c","#00441b"]},
{"id":"d3_schemeBuPu","colors":["#f7fcfd","#e0ecf4","#bfd3e6","#9ebcda","#8c96c6","#8c6bb1","#88419d","#810f7c","#4d004b"]},
{"id":"d3_schemeGnBu","colors":["#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4","#4eb3d3","#2b8cbe","#0868ac","#084081"]},
{"id":"d3_schemeGreens","colors":["#f7fcf5","#e5f5e0","#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#006d2c","#00441b"]},
{"id":"d3_schemeGreys","colors":["#ffffff","#f0f0f0","#d9d9d9","#bdbdbd","#969696","#737373","#525252","#252525","#000000"]},
{"id":"d3_schemeOrRd","colors":["#fff7ec","#fee8c8","#fdd49e","#fdbb84","#fc8d59","#ef6548","#d7301f","#b30000","#7f0000"]},
{"id":"d3_schemeOranges","colors":["#fff5eb","#fee6ce","#fdd0a2","#fdae6b","#fd8d3c","#f16913","#d94801","#a63603","#7f2704"]},
{"id":"d3_schemePuBu","colors":["#fff7fb","#ece7f2","#d0d1e6","#a6bddb","#74a9cf","#3690c0","#0570b0","#045a8d","#023858"]},
{"id":"d3_schemePuBuGn","colors":["#fff7fb","#ece2f0","#d0d1e6","#a6bddb","#67a9cf","#3690c0","#02818a","#016c59","#014636"]},
{"id":"d3_schemePuRd","colors":["#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f"]},
{"id":"d3_schemePurples","colors":["#fcfbfd","#efedf5","#dadaeb","#bcbddc","#9e9ac8","#807dba","#6a51a3","#54278f","#3f007d"]},
{"id":"d3_schemeReds","colors":["#fff5f0","#fee0d2","#fcbba1","#fc9272","#fb6a4a","#ef3b2c","#cb181d","#a50f15","#67000d"]},
{"id":"d3_schemeYlGn","colors":["#ffffe5","#f7fcb9","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#006837","#004529"]},
{"id":"d3_schemeYlGnBu","colors":["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58"]},
{"id":"d3_schemeRdPu","colors":["#fff7f3","#fde0dd","#fcc5c0","#fa9fb5","#f768a1","#dd3497","#ae017e","#7a0177","#49006a"]},
{"category":"Divergent"},
{"id":"red_blue","colors":["rgb(234,12,48)","rgb(234,12,48)","rgb(234,12,48)","rgb(26,12,234)","rgb(26,12,234)","rgb(26,12,234)"]},
{"id":"blue_red","colors":["rgb(26,12,234)","rgb(26,12,234)","rgb(26,12,234)","rgb(234,12,48)","rgb(234,12,48)","rgb(234,12,48)"]},
{"id":"blue_white_red","colors":["rgb(0,0,255)","rgb(2,2,255)","rgb(4,4,255)","rgb(6,6,255)","rgb(8,8,255)","rgb(10,10,255)","rgb(12,12,255)","rgb(14,14,255)","rgb(16,16,255)","rgb(18,18,255)","rgb(20,20,255)","rgb(22,22,255)","rgb(24,24,255)","rgb(26,26,255)","rgb(28,28,255)","rgb(30,30,255)","rgb(32,32,255)","rgb(34,34,255)","rgb(36,36,255)","rgb(38,38,255)","rgb(40,40,255)","rgb(42,42,255)","rgb(44,44,255)","rgb(46,46,255)","rgb(48,48,255)","rgb(50,50,255)","rgb(52,52,255)","rgb(54,54,255)","rgb(56,56,255)","rgb(58,58,255)","rgb(60,60,255)","rgb(62,62,255)","rgb(64,64,255)","rgb(66,66,255)","rgb(68,68,255)","rgb(70,70,255)","rgb(72,72,255)","rgb(74,74,255)","rgb(76,76,255)","rgb(78,78,255)","rgb(80,80,255)","rgb(82,82,255)","rgb(84,84,255)","rgb(86,86,255)","rgb(88,88,255)","rgb(90,90,255)","rgb(92,92,255)","rgb(94,94,255)","rgb(96,96,255)","rgb(98,98,255)","rgb(100,100,255)","rgb(102,102,255)","rgb(104,104,255)","rgb(106,106,255)","rgb(108,108,255)","rgb(110,110,255)","rgb(112,112,255)","rgb(114,114,255)","rgb(116,116,255)","rgb(118,118,255)","rgb(120,120,255)","rgb(122,122,255)","rgb(124,124,255)","rgb(126,126,255)","rgb(128,128,255)","rgb(130,130,255)","rgb(132,132,255)","rgb(134,134,255)","rgb(136,136,255)","rgb(138,138,255)","rgb(140,140,255)","rgb(142,142,255)","rgb(144,144,255)","rgb(146,146,255)","rgb(148,148,255)","rgb(150,150,255)","rgb(152,152,255)","rgb(154,154,255)","rgb(156,156,255)","rgb(158,158,255)","rgb(160,160,255)","rgb(162,162,255)","rgb(164,164,255)","rgb(166,166,255)","rgb(168,168,255)","rgb(170,170,255)","rgb(172,172,255)","rgb(174,174,255)","rgb(176,176,255)","rgb(178,178,255)","rgb(180,180,255)","rgb(182,182,255)","rgb(184,184,255)","rgb(186,186,255)","rgb(188,188,255)","rgb(190,190,255)","rgb(192,192,255)","rgb(194,194,255)","rgb(196,196,255)","rgb(198,198,255)","rgb(200,200,255)","rgb(202,202,255)","rgb(204,204,255)","rgb(206,206,255)","rgb(208,208,255)","rgb(210,210,255)","rgb(212,212,255)","rgb(214,214,255)","rgb(216,216,255)","rgb(218,218,255)","rgb(220,220,255)","rgb(222,222,255)","rgb(224,224,255)","rgb(226,226,255)","rgb(228,228,255)","rgb(230,230,255)","rgb(232,232,255)","rgb(234,234,255)","rgb(236,236,255)","rgb(238,238,255)","rgb(240,240,255)","rgb(242,242,255)","rgb(244,244,255)","rgb(246,246,255)","rgb(248,248,255)","rgb(250,250,255)","rgb(252,252,255)","rgb(252,251,254)","rgb(252,249,252)","rgb(252,247,250)","rgb(252,245,248)","rgb(252,243,246)","rgb(252,241,244)","rgb(252,239,242)","rgb(252,237,240)","rgb(252,235,238)","rgb(252,233,236)","rgb(252,231,234)","rgb(252,229,232)","rgb(252,227,230)","rgb(252,225,228)","rgb(252,223,226)","rgb(252,221,224)","rgb(252,219,222)","rgb(252,217,220)","rgb(252,215,218)","rgb(252,213,216)","rgb(252,211,214)","rgb(252,209,212)","rgb(252,207,210)","rgb(252,205,208)","rgb(252,203,206)","rgb(252,202,204)","rgb(252,200,202)","rgb(252,198,200)","rgb(252,196,198)","rgb(252,194,196)","rgb(252,192,194)","rgb(252,190,192)","rgb(252,188,190)","rgb(252,186,188)","rgb(252,184,186)","rgb(252,182,184)","rgb(252,180,182)","rgb(252,178,180)","rgb(252,176,178)","rgb(252,174,176)","rgb(252,172,174)","rgb(253,170,172)","rgb(253,168,170)","rgb(253,166,168)","rgb(253,164,166)","rgb(253,162,164)","rgb(253,160,162)","rgb(253,158,160)","rgb(253,156,158)","rgb(253,154,156)","rgb(253,153,154)","rgb(253,151,152)","rgb(253,149,150)","rgb(253,147,148)","rgb(253,145,146)","rgb(253,143,144)","rgb(253,141,142)","rgb(253,139,140)","rgb(253,137,138)","rgb(253,135,136)","rgb(253,133,134)","rgb(253,131,132)","rgb(253,129,131)","rgb(253,127,129)","rgb(253,125,127)","rgb(253,123,125)","rgb(253,121,123)","rgb(253,119,121)","rgb(253,117,119)","rgb(253,115,117)","rgb(253,113,115)","rgb(253,111,113)","rgb(253,109,111)","rgb(253,107,109)","rgb(253,105,107)","rgb(253,104,105)","rgb(253,102,103)","rgb(253,100,101)","rgb(253,98,99)","rgb(253,96,97)","rgb(253,94,95)","rgb(253,92,93)","rgb(253,90,91)","rgb(254,88,89)","rgb(254,86,87)","rgb(254,84,85)","rgb(254,82,83)","rgb(254,80,81)","rgb(254,78,79)","rgb(254,76,77)","rgb(254,74,75)","rgb(254,72,73)","rgb(254,70,71)","rgb(254,68,69)","rgb(254,66,67)","rgb(254,64,65)","rgb(254,62,63)","rgb(254,60,61)","rgb(254,58,59)","rgb(254,56,57)","rgb(254,55,55)","rgb(254,53,53)","rgb(254,51,51)","rgb(254,49,49)","rgb(254,47,47)","rgb(254,45,45)","rgb(254,43,43)","rgb(254,41,41)","rgb(254,39,39)","rgb(254,37,37)","rgb(254,35,35)","rgb(254,33,33)","rgb(254,31,31)","rgb(254,29,29)","rgb(254,27,27)","rgb(254,25,25)","rgb(254,23,23)","rgb(254,21,21)","rgb(254,19,19)","rgb(254,17,17)","rgb(254,15,15)","rgb(254,13,13)","rgb(254,11,11)","rgb(254,9,9)"]},
{"id":"red_white_blue","colors":["rgb(254,9,9)","rgb(254,11,11)","rgb(254,13,13)","rgb(254,15,15)","rgb(254,17,17)","rgb(254,19,19)","rgb(254,21,21)","rgb(254,23,23)","rgb(254,25,25)","rgb(254,27,27)","rgb(254,29,29)","rgb(254,31,31)","rgb(254,33,33)","rgb(254,35,35)","rgb(254,37,37)","rgb(254,39,39)","rgb(254,41,41)","rgb(254,43,43)","rgb(254,45,45)","rgb(254,47,47)","rgb(254,49,49)","rgb(254,51,51)","rgb(254,53,53)","rgb(254,55,55)","rgb(254,56,57)","rgb(254,58,59)","rgb(254,60,61)","rgb(254,62,63)","rgb(254,64,65)","rgb(254,66,67)","rgb(254,68,69)","rgb(254,70,71)","rgb(254,72,73)","rgb(254,74,75)","rgb(254,76,77)","rgb(254,78,79)","rgb(254,80,81)","rgb(254,82,83)","rgb(254,84,85)","rgb(254,86,87)","rgb(254,88,89)","rgb(253,90,91)","rgb(253,92,93)","rgb(253,94,95)","rgb(253,96,97)","rgb(253,98,99)","rgb(253,100,101)","rgb(253,102,103)","rgb(253,104,105)","rgb(253,105,107)","rgb(253,107,109)","rgb(253,109,111)","rgb(253,111,113)","rgb(253,113,115)","rgb(253,115,117)","rgb(253,117,119)","rgb(253,119,121)","rgb(253,121,123)","rgb(253,123,125)","rgb(253,125,127)","rgb(253,127,129)","rgb(253,129,131)","rgb(253,131,132)","rgb(253,133,134)","rgb(253,135,136)","rgb(253,137,138)","rgb(253,139,140)","rgb(253,141,142)","rgb(253,143,144)","rgb(253,145,146)","rgb(253,147,148)","rgb(253,149,150)","rgb(253,151,152)","rgb(253,153,154)","rgb(253,154,156)","rgb(253,156,158)","rgb(253,158,160)","rgb(253,160,162)","rgb(253,162,164)","rgb(253,164,166)","rgb(253,166,168)","rgb(253,168,170)","rgb(253,170,172)","rgb(252,172,174)","rgb(252,174,176)","rgb(252,176,178)","rgb(252,178,180)","rgb(252,180,182)","rgb(252,182,184)","rgb(252,184,186)","rgb(252,186,188)","rgb(252,188,190)","rgb(252,190,192)","rgb(252,192,194)","rgb(252,194,196)","rgb(252,196,198)","rgb(252,198,200)","rgb(252,200,202)","rgb(252,202,204)","rgb(252,203,206)","rgb(252,205,208)","rgb(252,207,210)","rgb(252,209,212)","rgb(252,211,214)","rgb(252,213,216)","rgb(252,215,218)","rgb(252,217,220)","rgb(252,219,222)","rgb(252,221,224)","rgb(252,223,226)","rgb(252,225,228)","rgb(252,227,230)","rgb(252,229,232)","rgb(252,231,234)","rgb(252,233,236)","rgb(252,235,238)","rgb(252,237,240)","rgb(252,239,242)","rgb(252,241,244)","rgb(252,243,246)","rgb(252,245,248)","rgb(252,247,250)","rgb(252,249,252)","rgb(252,251,254)","rgb(252,252,255)","rgb(250,250,255)","rgb(248,248,255)","rgb(246,246,255)","rgb(244,244,255)","rgb(242,242,255)","rgb(240,240,255)","rgb(238,238,255)","rgb(236,236,255)","rgb(234,234,255)","rgb(232,232,255)","rgb(230,230,255)","rgb(228,228,255)","rgb(226,226,255)","rgb(224,224,255)","rgb(222,222,255)","rgb(220,220,255)","rgb(218,218,255)","rgb(216,216,255)","rgb(214,214,255)","rgb(212,212,255)","rgb(210,210,255)","rgb(208,208,255)","rgb(206,206,255)","rgb(204,204,255)","rgb(202,202,255)","rgb(200,200,255)","rgb(198,198,255)","rgb(196,196,255)","rgb(194,194,255)","rgb(192,192,255)","rgb(190,190,255)","rgb(188,188,255)","rgb(186,186,255)","rgb(184,184,255)","rgb(182,182,255)","rgb(180,180,255)","rgb(178,178,255)","rgb(176,176,255)","rgb(174,174,255)","rgb(172,172,255)","rgb(170,170,255)","rgb(168,168,255)","rgb(166,166,255)","rgb(164,164,255)","rgb(162,162,255)","rgb(160,160,255)","rgb(158,158,255)","rgb(156,156,255)","rgb(154,154,255)","rgb(152,152,255)","rgb(150,150,255)","rgb(148,148,255)","rgb(146,146,255)","rgb(144,144,255)","rgb(142,142,255)","rgb(140,140,255)","rgb(138,138,255)","rgb(136,136,255)","rgb(134,134,255)","rgb(132,132,255)","rgb(130,130,255)","rgb(128,128,255)","rgb(126,126,255)","rgb(124,124,255)","rgb(122,122,255)","rgb(120,120,255)","rgb(118,118,255)","rgb(116,116,255)","rgb(114,114,255)","rgb(112,112,255)","rgb(110,110,255)","rgb(108,108,255)","rgb(106,106,255)","rgb(104,104,255)","rgb(102,102,255)","rgb(100,100,255)","rgb(98,98,255)","rgb(96,96,255)","rgb(94,94,255)","rgb(92,92,255)","rgb(90,90,255)","rgb(88,88,255)","rgb(86,86,255)","rgb(84,84,255)","rgb(82,82,255)","rgb(80,80,255)","rgb(78,78,255)","rgb(76,76,255)","rgb(74,74,255)","rgb(72,72,255)","rgb(70,70,255)","rgb(68,68,255)","rgb(66,66,255)","rgb(64,64,255)","rgb(62,62,255)","rgb(60,60,255)","rgb(58,58,255)","rgb(56,56,255)","rgb(54,54,255)","rgb(52,52,255)","rgb(50,50,255)","rgb(48,48,255)","rgb(46,46,255)","rgb(44,44,255)","rgb(42,42,255)","rgb(40,40,255)","rgb(38,38,255)","rgb(36,36,255)","rgb(34,34,255)","rgb(32,32,255)","rgb(30,30,255)","rgb(28,28,255)","rgb(26,26,255)","rgb(24,24,255)","rgb(22,22,255)","rgb(20,20,255)","rgb(18,18,255)","rgb(16,16,255)","rgb(14,14,255)","rgb(12,12,255)","rgb(10,10,255)","rgb(8,8,255)","rgb(6,6,255)","rgb(4,4,255)","rgb(2,2,255)","rgb(0,0,255)"]},
{"id":"red_white_green","colors":["rgb(255,0,0)","rgb(255,5,5)","rgb(255,10,10)","rgb(255,15,15)","rgb(255,20,20)","rgb(255,25,25)","rgb(255,30,30)","rgb(255,35,35)","rgb(255,40,40)","rgb(255,45,45)","rgb(255,50,50)","rgb(255,55,55)","rgb(255,60,60)","rgb(255,66,66)","rgb(255,71,71)","rgb(255,76,76)","rgb(255,81,81)","rgb(255,86,86)","rgb(255,91,91)","rgb(255,96,96)","rgb(255,101,101)","rgb(255,106,106)","rgb(255,111,111)","rgb(255,116,116)","rgb(255,121,121)","rgb(255,126,126)","rgb(255,132,132)","rgb(255,137,137)","rgb(255,142,142)","rgb(255,147,147)","rgb(255,152,152)","rgb(255,157,157)","rgb(255,162,162)","rgb(255,167,167)","rgb(255,172,172)","rgb(255,177,177)","rgb(255,182,182)","rgb(255,187,187)","rgb(255,193,193)","rgb(255,198,198)","rgb(255,203,203)","rgb(255,208,208)","rgb(255,213,213)","rgb(255,218,218)","rgb(255,223,223)","rgb(255,228,228)","rgb(255,233,233)","rgb(255,238,238)","rgb(255,243,243)","rgb(255,248,248)","rgb(251,246,245)","rgb(247,244,242)","rgb(243,242,239)","rgb(239,240,236)","rgb(235,238,233)","rgb(231,236,230)","rgb(227,234,226)","rgb(223,231,223)","rgb(219,229,220)","rgb(215,227,217)","rgb(210,225,214)","rgb(206,223,211)","rgb(202,221,207)","rgb(198,219,204)","rgb(194,216,201)","rgb(190,214,198)","rgb(186,212,195)","rgb(182,210,192)","rgb(178,208,189)","rgb(174,206,185)","rgb(169,204,182)","rgb(165,201,179)","rgb(161,199,176)","rgb(157,197,173)","rgb(153,195,170)","rgb(149,193,166)","rgb(145,191,163)","rgb(141,189,160)","rgb(137,187,157)","rgb(133,184,154)","rgb(128,182,151)","rgb(124,180,147)","rgb(120,178,144)","rgb(116,176,141)","rgb(112,174,138)","rgb(108,172,135)","rgb(104,169,132)","rgb(100,167,129)","rgb(96,165,125)","rgb(92,163,122)","rgb(87,161,119)","rgb(83,159,116)","rgb(79,157,113)","rgb(75,154,110)","rgb(71,152,106)","rgb(67,150,103)","rgb(63,148,100)","rgb(59,146,97)","rgb(55,144,94)","rgb(51,142,91)"]},
{"id":"plotly_rdbu","colors":["rgb(5,10,172)","rgb(8,14,174)","rgb(11,17,176)","rgb(14,21,178)","rgb(17,25,181)","rgb(19,28,183)","rgb(22,32,185)","rgb(25,35,187)","rgb(28,39,189)","rgb(31,43,191)","rgb(34,46,193)","rgb(37,50,196)","rgb(40,54,198)","rgb(43,57,200)","rgb(45,61,202)","rgb(48,64,204)","rgb(51,68,206)","rgb(54,72,208)","rgb(57,75,211)","rgb(60,79,213)","rgb(63,83,215)","rgb(66,86,217)","rgb(68,90,219)","rgb(71,93,221)","rgb(74,97,223)","rgb(77,101,226)","rgb(80,104,228)","rgb(83,108,230)","rgb(86,112,232)","rgb(89,115,234)","rgb(92,119,236)","rgb(94,122,238)","rgb(97,126,241)","rgb(100,130,243)","rgb(103,133,245)","rgb(106,137,247)","rgb(112,141,243)","rgb(117,144,239)","rgb(123,148,236)","rgb(128,151,232)","rgb(134,155,228)","rgb(140,158,224)","rgb(145,162,220)","rgb(151,165,217)","rgb(156,169,213)","rgb(162,172,209)","rgb(168,176,205)","rgb(173,179,201)","rgb(179,183,198)","rgb(184,186,194)","rgb(190,190,190)","rgb(193,188,184)","rgb(196,186,178)","rgb(199,184,173)","rgb(202,182,167)","rgb(205,180,161)","rgb(208,178,155)","rgb(211,176,149)","rgb(214,174,144)","rgb(217,172,138)","rgb(220,170,132)","rgb(221,167,128)","rgb(222,165,124)","rgb(223,162,119)","rgb(224,160,115)","rgb(225,157,111)","rgb(226,155,107)","rgb(227,152,103)","rgb(228,150,98)","rgb(229,147,94)","rgb(230,145,90)","rgb(228,140,88)","rgb(227,136,86)","rgb(225,131,84)","rgb(223,127,82)","rgb(221,122,80)","rgb(220,118,78)","rgb(218,113,76)","rgb(216,109,73)","rgb(214,104,71)","rgb(213,100,69)","rgb(211,95,67)","rgb(209,91,65)","rgb(207,86,63)","rgb(206,82,61)","rgb(204,77,59)","rgb(202,73,57)","rgb(201,68,55)","rgb(199,64,53)","rgb(197,59,51)","rgb(195,55,49)","rgb(194,50,47)","rgb(192,46,45)","rgb(190,41,42)","rgb(188,37,40)","rgb(187,32,38)","rgb(185,28,36)","rgb(183,23,34)","rgb(181,19,32)","rgb(180,14,30)"]},
{"id":"blue_green_red","colors":["rgb(0,0,255)","rgb(8,17,246)","rgb(17,35,237)","rgb(26,52,228)","rgb(35,70,219)","rgb(43,87,211)","rgb(52,105,202)","rgb(61,123,193)","rgb(70,140,184)","rgb(79,158,175)","rgb(87,175,167)","rgb(96,193,158)","rgb(105,211,149)","rgb(114,228,140)","rgb(123,246,131)","rgb(131,246,123)","rgb(140,228,114)","rgb(149,211,105)","rgb(158,193,96)","rgb(167,175,87)","rgb(175,158,79)","rgb(184,140,70)","rgb(193,123,61)","rgb(202,105,52)","rgb(211,87,43)","rgb(219,70,35)","rgb(228,52,26)","rgb(237,35,17)","rgb(246,17,8)","rgb(255,0,0)"]},
{"id":"red_green_blue","colors":["rgb(255,0,0)","rgb(246,17,8)","rgb(237,35,17)","rgb(228,52,26)","rgb(219,70,35)","rgb(211,87,43)","rgb(202,105,52)","rgb(193,123,61)","rgb(184,140,70)","rgb(175,158,79)","rgb(167,175,87)","rgb(158,193,96)","rgb(149,211,105)","rgb(140,228,114)","rgb(131,246,123)","rgb(123,246,131)","rgb(114,228,140)","rgb(105,211,149)","rgb(96,193,158)","rgb(87,175,167)","rgb(79,158,175)","rgb(70,140,184)","rgb(61,123,193)","rgb(52,105,202)","rgb(43,87,211)","rgb(35,70,219)","rgb(26,52,228)","rgb(17,35,237)","rgb(8,17,246)","rgb(0,0,255)"]},
{"id":"d3_schemeBrBG","colors":["#543005","#8c510a","#bf812d","#dfc27d","#f6e8c3","#f5f5f5","#c7eae5","#80cdc1","#35978f","#01665e","#003c30"]},
{"id":"d3_schemePRGn","colors":["#40004b","#762a83","#9970ab","#c2a5cf","#e7d4e8","#f7f7f7","#d9f0d3","#a6dba0","#5aae61","#1b7837","#00441b"]},
{"id":"d3_schemePiYG","colors":["#8e0152","#c51b7d","#de77ae","#f1b6da","#fde0ef","#f7f7f7","#e6f5d0","#b8e186","#7fbc41","#4d9221","#276419"]},
{"id":"d3_schemePuOr","colors":["#2d004b","#542788","#8073ac","#b2abd2","#d8daeb","#f7f7f7","#fee0b6","#fdb863","#e08214","#b35806","#7f3b08"]},
{"id":"d3_schemeRdYlBu","colors":["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]},
{"id":"d3_schemeRdBu","colors":["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#f7f7f7","#d1e5f0","#92c5de","#4393c3","#2166ac","#053061"]},
{"id":"d3_schemeRdGy","colors":["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#ffffff","#e0e0e0","#bababa","#878787","#4d4d4d","#1a1a1a"]},
{"id":"d3_schemeRdYlGn","colors":["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"]},
{"id":"d3_schemeSpectral","colors":["#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"]},
{"category":"Categorical"},
    {"id":"gpt50","colors":["rgb(31,119,180)","rgb(255,127,14)","rgb(255,187,120)","rgb(174,199,232)","rgb(44,160,44)","rgb(152,223,138)","rgb(214,39,40)","rgb(255,152,150)","rgb(148,103,189)","rgb(197,176,213)","rgb(140,86,75)","rgb(196,156,148)","rgb(227,119,194)","rgb(247,182,210)","rgb(127,127,127)","rgb(199,199,199)","rgb(188,189,34)","rgb(219,219,141)","rgb(23,190,207)","rgb(158,218,229)","rgb(218,60,60)","rgb(230,197,197)","rgb(3,81,0)","rgb(146,143,143)","rgb(140,0,140)","rgb(153,153,153)","rgb(0,80,90)","rgb(230,143,143)","rgb(0,0,0)","rgb(250,215,215)","rgb(0,100,0)","rgb(78,238,148)","rgb(205,0,90)","rgb(255,228,225)","rgb(139,58,98)","rgb(238,238,238)","rgb(205,92,92)","rgb(75,0,130)","rgb(255,235,205)","rgb(0,0,139)","rgb(139,0,139)","rgb(0,0,255)","rgb(238,130,238)","rgb(0,139,139)","rgb(0,100,0)","rgb(189,183,107)","rgb(139,0,0)","rgb(233,150,122)","rgb(143,188,143)","rgb(72,61,139)"]},
    {"id":"gpt100","colors":["#1f77b4","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#aec7e8","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf","#9edae5","#393b79","#5254a3","#6b6ecf","#9c9ede","#637939","#8ca252","#b5cf6b","#cedb9c","#8c6d31","#bd9e39","#e7ba52","#e7cb94","#843c39","#ad494a","#d6616b","#e7969c","#7b4173","#a55194","#ce6dbd","#de9ed6","#3182bd","#6baed6","#9ecae1","#c6dbef","#e6550d","#fd8d3c","#fdae6b","#fdd0a2","#31a354","#74c476","#a1d99b","#c7e9c0","#756bb1","#9e9ac8","#bcbddc","#dadaeb","#636363","#969696","#bdbdbd","#d9d9d9"]},
{id:'cats256',colors:["rgb(31,119,179)","rgb(255,126,14)","rgb(43,160,43)","rgb(214,38,40)","rgb(147,103,188)","rgb(140,86,75)","rgb(226,119,193)","rgb(126,126,126)","rgb(188,188,33)","rgb(22,189,207)","rgb(58,1,130)","rgb(0,66,1)","rgb(15,255,168)","rgb(93,0,63)","rgb(188,188,255)","rgb(216,175,161)","rgb(184,0,128)","rgb(0,77,82)","rgb(107,100,0)","rgb(124,1,0)","rgb(96,38,255)","rgb(255,255,154)","rgb(86,73,100)","rgb(140,184,147)","rgb(147,251,255)","rgb(1,130,103)","rgb(144,255,0)","rgb(130,0,160)","rgb(172,137,68)","rgb(91,52,0)","rgb(255,191,242)","rgb(255,110,117)","rgb(121,140,255)","rgb(221,0,255)","rgb(80,86,70)","rgb(0,68,137)","rgb(255,191,96)","rgb(255,1,140)","rgb(189,200,207)","rgb(175,151,181)","rgb(182,86,0)","rgb(1,112,0)","rgb(205,135,255)","rgb(28,214,70)","rgb(191,235,195)","rgb(121,151,181)","rgb(165,96,137)","rgb(110,137,86)","rgb(188,124,117)","rgb(138,40,68)","rgb(0,172,255)","rgb(142,212,255)","rgb(75,109,119)","rgb(0,212,177)","rgb(147,0,242)","rgb(138,149,0)","rgb(93,91,158)","rgb(253,223,186)","rgb(0,147,158)","rgb(255,219,0)","rgb(0,170,121)","rgb(82,0,103)","rgb(0,0,145)","rgb(10,93,61)","rgb(165,226,117)","rgb(98,59,65)","rgb(198,198,137)","rgb(255,158,181)","rgb(205,79,107)","rgb(255,7,214)","rgb(138,58,5)","rgb(126,61,112)","rgb(255,73,1)","rgb(96,43,165)","rgb(28,0,255)","rgb(230,223,255)","rgb(170,59,175)","rgb(216,156,0)","rgb(163,163,158)","rgb(63,105,255)","rgb(70,73,12)","rgb(123,105,133)","rgb(107,151,140)","rgb(255,154,117)","rgb(131,91,255)","rgb(124,107,70)","rgb(128,182,84)","rgb(188,0,73)","rgb(253,147,255)","rgb(93,0,24)","rgb(137,209,209)","rgb(156,140,211)","rgb(218,109,66)","rgb(138,87,0)","rgb(59,80,105)","rgb(75,107,59)","rgb(237,207,216)","rgb(207,237,255)","rgb(170,21,0)","rgb(223,255,79)","rgb(255,42,86)","rgb(209,73,158)","rgb(112,124,184)","rgb(89,128,0)","rgb(0,228,253)","rgb(119,75,149)","rgb(103,212,140)","rgb(61,58,114)","rgb(172,65,63)","rgb(214,161,102)","rgb(193,105,205)","rgb(105,89,93)","rgb(135,172,237)","rgb(160,165,105)","rgb(209,170,230)","rgb(135,0,98)","rgb(0,253,219)","rgb(103,40,24)","rgb(179,66,255)","rgb(14,89,196)","rgb(22,135,66)","rgb(144,211,0)","rgb(205,121,0)","rgb(249,89,255)","rgb(91,116,102)","rgb(142,174,179)","rgb(156,124,140)","rgb(70,0,198)","rgb(107,77,45)","rgb(165,109,70)","rgb(158,137,114)","rgb(168,175,202)","rgb(205,140,167)","rgb(0,253,100)","rgb(145,121,0)","rgb(255,98,161)","rgb(244,255,216)","rgb(1,140,240)","rgb(19,172,160)","rgb(91,45,89)","rgb(137,133,158)","rgb(207,204,186)","rgb(212,175,196)","rgb(219,221,109)","rgb(207,255,244)","rgb(0,100,133)","rgb(0,105,98)","rgb(168,65,103)","rgb(45,151,196)","rgb(168,116,255)","rgb(38,186,93)","rgb(87,182,0)","rgb(202,255,167)","rgb(163,121,170)","rgb(255,188,147)","rgb(137,226,193)","rgb(15,200,255)","rgb(212,0,196)","rgb(98,109,137)","rgb(105,133,142)","rgb(75,77,82)","rgb(170,96,103)","rgb(121,181,212)","rgb(43,89,22)","rgb(154,0,36)","rgb(189,209,242)","rgb(137,110,103)","rgb(105,165,107)","rgb(133,84,103)","rgb(174,205,186)","rgb(135,153,126)","rgb(202,219,0)","rgb(154,3,144)","rgb(235,188,26)","rgb(235,156,209)","rgb(112,0,110)","rgb(177,161,49)","rgb(202,107,147)","rgb(65,70,163)","rgb(228,140,137)","rgb(212,68,0)","rgb(198,138,202)","rgb(182,149,151)","rgb(212,31,117)","rgb(114,75,204)","rgb(103,77,0)","rgb(103,33,56)","rgb(56,86,79)","rgb(110,186,170)","rgb(133,58,49)","rgb(165,211,151)","rgb(184,175,142)","rgb(216,228,223)","rgb(170,0,223)","rgb(202,193,219)","rgb(255,223,140)","rgb(226,82,77)","rgb(102,105,110)","rgb(255,0,28)","rgb(82,45,114)","rgb(77,144,107)","rgb(168,109,17)","rgb(255,158,38)","rgb(94,163,175)","rgb(200,133,86)","rgb(145,89,151)","rgb(163,161,255)","rgb(253,186,186)","rgb(36,42,135)","rgb(219,230,168)","rgb(151,242,167)","rgb(103,147,214)","rgb(186,91,63)","rgb(58,93,145)","rgb(54,79,47)","rgb(38,124,149)","rgb(137,149,154)","rgb(207,179,86)","rgb(0,70,100)","rgb(94,93,47)","rgb(142,142,65)","rgb(172,63,19)","rgb(105,149,59)","rgb(161,61,133)","rgb(191,182,186)","rgb(172,198,103)","rgb(100,105,207)","rgb(145,175,0)"]},






{"id":"rainbow","colors":["red","orange","yellow","green","blue","indigo","violet"]},
{"id":"cats","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf","#ffd800","#DFA25A","#4B0082","#7BCCC4","#ADDD8E"]},
{"id":"nice","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"]},
{"id":"nice2","colors":["#1f77b4","#ff7f0e"]},
{"id":"nice3","colors":["#1f77b4","#ff7f0e","#2ca02c"]},
{"id":"nice4","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728"]},
{"id":"nice5","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd"]},
{"id":"nice6","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b"]},
{"id":"nice7","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2"]},
{"id":"nice8","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f"]},
{"id":"nice9","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#1B1B1B"]},
{"id":"nice10","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#A0CBE8","#4B0082"]},
{"id":"schemecategory","colors":["rgb(31, 119, 180)","rgb(255, 127, 14)","rgb(44, 160, 44)","rgb(214, 39, 40)","rgb(148, 103, 189)","rgb(140, 86, 75)","rgb(227, 119, 194)","rgb(127, 127, 127)","rgb(188, 189, 34)"]},
{"id":"schemeaccent","colors":["rgb(127, 201, 127)","rgb(190, 174, 212)","rgb(253, 192, 134)","rgb(255, 255, 153)","rgb(56, 108, 176)","rgb(240, 2, 127)","rgb(191, 91, 23)","rgb(102, 102, 102)"]},
{"id":"schemedark","colors":["rgb(27, 158, 119)","rgb(217, 95, 2)","rgb(117, 112, 179)","rgb(231, 41, 138)","rgb(102, 166, 30)","rgb(230, 171, 2)","rgb(166, 118, 29)","rgb(102, 102, 102)"]},
{"id":"schemeset1","colors":["rgb(228, 26, 28)","rgb(55, 126, 184)","rgb(77, 175, 74)","rgb(152, 78, 163)","rgb(255, 127, 0)","rgb(166, 86, 40)","rgb(247, 129, 191)","rgb(153, 153, 153)"]},
{"id":"schemeset2","colors":["rgb(141, 211, 199)","rgb(255, 255, 179)","rgb(190, 186, 218)","rgb(251, 128, 114)","rgb(128, 177, 211)","rgb(253, 180, 98)","rgb(179, 222, 105)","rgb(252, 205, 229)","rgb(217, 217, 217)","rgb(188, 128, 189)","rgb(204, 235, 197)","rgb(255, 237, 111)"]},
{"id":"d3_schemeAccent","colors":["#7fc97f","#beaed4","#fdc086","#ffff99","#386cb0","#f0027f","#bf5b17","#666666"]},
{"id":"d3_schemeCategory10","colors":["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"]},
{"id":"d3_schemePaired","colors":["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928"]},
{"id":"d3_schemePastel1","colors":["#fbb4ae","#b3cde3","#ccebc5","#decbe4","#fed9a6","#ffffcc","#e5d8bd","#fddaec","#f2f2f2"]},
{"id":"d3_schemePastel2","colors":["#b3e2cd","#fdcdac","#cbd5e8","#f4cae4","#e6f5c9","#fff2ae","#f1e2cc","#cccccc"]},
{"id":"googlecharts","colors":["#3366CC","#DC3912","#FF9900","#109618","#990099","#3B3EAC","#0099C6","#DD4477","#66AA00","#B82E2E","#316395","#994499","#22AA99","#AAAA11","#6633CC","#E67300","#8B0707","#329262","#5574A6","#3B3EAC"]},
{"id":"d3_schemeDark2","colors":["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"]},
{"id":"d3_schemeTableau10","colors":["#4e79a7","#f28e2c","#e15759","#76b7b2","#59a14f","#edc949","#af7aa1","#ff9da7","#9c755f","#bab0ab"]},
{"id":"d3_schemeCategory20b","colors":["#393b79","#5254a3","#6b6ecf","#9c9ede","#637939","#8ca252","#b5cf6b","#cedb9c","#8c6d31","#bd9e39","#e7ba52","#e7cb94","#843c39","#ad494a","#d6616b","#e7969c","#7b4173","#a55194","#ce6dbd","#de9ed6"]},
{"id":"d3_schemeCategory20c","colors":["#3182bd","#6baed6","#9ecae1","#c6dbef","#e6550d","#fd8d3c","#fdae6b","#fdd0a2","#31a354","#74c476","#a1d99b","#c7e9c0","#756bb1","#9e9ac8","#bcbddc","#dadaeb","#636363","#969696","#bdbdbd","#d9d9d9"]},
{"id":"d3_schemeCategory20","colors":["#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf","#9edae5"]},
{"category":"Mixed"},
{"id":"plotly_picnic","colors":["rgb(0,0,255)","rgb(5,15,255)","rgb(10,31,255)","rgb(15,46,255)","rgb(20,61,255)","rgb(26,77,255)","rgb(31,92,255)","rgb(36,107,255)","rgb(41,122,255)","rgb(46,138,255)","rgb(51,153,255)","rgb(56,158,255)","rgb(61,163,255)","rgb(66,168,255)","rgb(71,173,255)","rgb(77,179,255)","rgb(82,184,255)","rgb(87,189,255)","rgb(92,194,255)","rgb(97,199,255)","rgb(102,204,255)","rgb(107,204,255)","rgb(112,204,255)","rgb(117,204,255)","rgb(122,204,255)","rgb(128,204,255)","rgb(133,204,255)","rgb(138,204,255)","rgb(143,204,255)","rgb(148,204,255)","rgb(153,204,255)","rgb(158,204,255)","rgb(163,204,255)","rgb(168,204,255)","rgb(173,204,255)","rgb(179,204,255)","rgb(184,204,255)","rgb(189,204,255)","rgb(194,204,255)","rgb(199,204,255)","rgb(204,204,255)","rgb(209,209,255)","rgb(214,214,255)","rgb(219,219,255)","rgb(224,224,255)","rgb(230,230,255)","rgb(235,235,255)","rgb(240,240,255)","rgb(245,245,255)","rgb(250,250,255)","rgb(255,255,255)","rgb(255,250,255)","rgb(255,245,255)","rgb(255,240,255)","rgb(255,235,255)","rgb(255,229,255)","rgb(255,224,255)","rgb(255,219,255)","rgb(255,214,255)","rgb(255,209,255)","rgb(255,204,255)","rgb(255,199,255)","rgb(255,194,255)","rgb(255,189,255)","rgb(255,184,255)","rgb(255,178,255)","rgb(255,173,255)","rgb(255,168,255)","rgb(255,163,255)","rgb(255,158,255)","rgb(255,153,255)","rgb(255,148,250)","rgb(255,143,245)","rgb(255,138,240)","rgb(255,133,235)","rgb(255,127,229)","rgb(255,122,224)","rgb(255,117,219)","rgb(255,112,214)","rgb(255,107,209)","rgb(255,102,204)","rgb(255,102,194)","rgb(255,102,184)","rgb(255,102,173)","rgb(255,102,163)","rgb(255,102,153)","rgb(255,102,143)","rgb(255,102,133)","rgb(255,102,122)","rgb(255,102,112)","rgb(255,102,102)","rgb(255,92,92)","rgb(255,82,82)","rgb(255,71,71)","rgb(255,61,61)","rgb(255,51,51)","rgb(255,41,41)","rgb(255,31,31)","rgb(255,20,20)","rgb(255,10,10)"]},
{"id":"plotly_rainbow","colors":["rgb(150,0,90)","rgb(138,0,99)","rgb(126,0,108)","rgb(114,0,116)","rgb(102,0,125)","rgb(90,0,134)","rgb(78,0,143)","rgb(66,0,152)","rgb(54,0,160)","rgb(42,0,169)","rgb(30,0,178)","rgb(18,0,187)","rgb(6,0,196)","rgb(0,1,202)","rgb(0,3,207)","rgb(0,5,211)","rgb(0,7,215)","rgb(0,9,220)","rgb(0,11,224)","rgb(0,13,229)","rgb(0,15,233)","rgb(0,17,237)","rgb(0,19,242)","rgb(0,21,246)","rgb(0,23,251)","rgb(0,25,255)","rgb(0,35,255)","rgb(0,45,255)","rgb(0,55,255)","rgb(0,66,255)","rgb(0,76,255)","rgb(0,86,255)","rgb(0,96,255)","rgb(0,106,255)","rgb(0,116,255)","rgb(0,127,255)","rgb(0,137,255)","rgb(0,147,255)","rgb(2,156,251)","rgb(5,164,242)","rgb(9,173,234)","rgb(12,181,226)","rgb(16,189,217)","rgb(19,197,209)","rgb(23,206,200)","rgb(26,214,192)","rgb(30,222,184)","rgb(33,230,175)","rgb(37,239,167)","rgb(40,247,158)","rgb(44,255,150)","rgb(53,255,138)","rgb(61,255,126)","rgb(70,255,114)","rgb(78,255,102)","rgb(87,255,90)","rgb(95,255,78)","rgb(104,255,66)","rgb(112,255,54)","rgb(121,255,42)","rgb(130,255,30)","rgb(138,255,18)","rgb(147,255,6)","rgb(155,254,0)","rgb(163,252,0)","rgb(172,251,0)","rgb(180,249,0)","rgb(188,247,0)","rgb(197,246,0)","rgb(205,244,0)","rgb(213,242,0)","rgb(222,241,0)","rgb(230,239,0)","rgb(238,237,0)","rgb(247,236,0)","rgb(255,234,0)","rgb(255,224,0)","rgb(255,214,0)","rgb(255,204,0)","rgb(255,195,0)","rgb(255,185,0)","rgb(255,175,0)","rgb(255,165,0)","rgb(255,155,0)","rgb(255,145,0)","rgb(255,136,0)","rgb(255,126,0)","rgb(255,116,0)","rgb(255,107,0)","rgb(255,98,0)","rgb(255,89,0)","rgb(255,80,0)","rgb(255,71,0)","rgb(255,62,0)","rgb(255,53,0)","rgb(255,44,0)","rgb(255,36,0)","rgb(255,27,0)","rgb(255,18,0)","rgb(255,9,0)"]},
{"id":"plotly_portland","colors":["rgb(12,51,131)","rgb(12,54,133)","rgb(12,58,135)","rgb(12,61,138)","rgb(12,65,140)","rgb(12,68,142)","rgb(12,71,144)","rgb(11,75,146)","rgb(11,78,149)","rgb(11,82,151)","rgb(11,85,153)","rgb(11,88,155)","rgb(11,92,157)","rgb(11,95,160)","rgb(11,99,162)","rgb(11,102,164)","rgb(11,105,166)","rgb(11,109,168)","rgb(11,112,171)","rgb(10,116,173)","rgb(10,119,175)","rgb(10,122,177)","rgb(10,126,179)","rgb(10,129,182)","rgb(10,133,184)","rgb(10,136,186)","rgb(19,139,181)","rgb(29,142,176)","rgb(38,145,170)","rgb(47,148,165)","rgb(56,151,160)","rgb(66,154,155)","rgb(75,157,150)","rgb(84,160,144)","rgb(94,163,139)","rgb(103,166,134)","rgb(112,169,129)","rgb(121,172,124)","rgb(131,175,118)","rgb(140,178,113)","rgb(149,181,108)","rgb(158,184,103)","rgb(168,187,98)","rgb(177,190,92)","rgb(186,193,87)","rgb(196,196,82)","rgb(205,199,77)","rgb(214,202,72)","rgb(223,205,66)","rgb(233,208,61)","rgb(242,211,56)","rgb(242,208,56)","rgb(242,206,56)","rgb(242,203,56)","rgb(242,200,56)","rgb(242,197,56)","rgb(242,195,56)","rgb(242,192,56)","rgb(242,189,56)","rgb(242,187,56)","rgb(242,184,56)","rgb(242,181,56)","rgb(242,178,56)","rgb(242,176,56)","rgb(242,173,56)","rgb(242,170,56)","rgb(242,167,56)","rgb(242,165,56)","rgb(242,162,56)","rgb(242,159,56)","rgb(242,157,56)","rgb(242,154,56)","rgb(242,151,56)","rgb(242,148,56)","rgb(242,146,56)","rgb(242,143,56)","rgb(241,138,55)","rgb(240,134,54)","rgb(239,129,53)","rgb(238,125,52)","rgb(237,120,51)","rgb(236,116,50)","rgb(235,111,49)","rgb(234,107,48)","rgb(233,102,47)","rgb(232,98,46)","rgb(231,93,45)","rgb(230,89,44)","rgb(229,84,42)","rgb(228,80,41)","rgb(227,75,40)","rgb(226,71,39)","rgb(225,66,38)","rgb(224,62,37)","rgb(223,57,36)","rgb(222,53,35)","rgb(221,48,34)","rgb(220,44,33)","rgb(219,39,32)","rgb(218,35,31)"]},
{"id":"plotly_jet","colors":["rgb(0,0,131)","rgb(0,5,134)","rgb(0,10,137)","rgb(0,14,140)","rgb(0,19,143)","rgb(0,24,147)","rgb(0,29,150)","rgb(0,34,153)","rgb(0,38,156)","rgb(0,43,159)","rgb(0,48,162)","rgb(0,53,165)","rgb(0,58,168)","rgb(0,64,172)","rgb(0,72,175)","rgb(0,80,179)","rgb(1,87,182)","rgb(1,95,185)","rgb(1,103,189)","rgb(1,111,192)","rgb(2,119,196)","rgb(2,126,199)","rgb(2,134,202)","rgb(2,142,206)","rgb(2,150,209)","rgb(3,158,213)","rgb(3,165,216)","rgb(3,173,219)","rgb(3,181,223)","rgb(3,189,226)","rgb(4,197,230)","rgb(4,204,233)","rgb(4,212,236)","rgb(4,220,240)","rgb(4,228,243)","rgb(5,236,247)","rgb(5,243,250)","rgb(5,251,253)","rgb(10,255,250)","rgb(20,255,240)","rgb(30,255,229)","rgb(40,255,219)","rgb(50,255,209)","rgb(60,255,199)","rgb(70,255,189)","rgb(80,255,178)","rgb(90,255,168)","rgb(100,255,158)","rgb(110,255,148)","rgb(120,255,138)","rgb(130,255,127)","rgb(140,255,117)","rgb(150,255,107)","rgb(160,255,97)","rgb(170,255,87)","rgb(180,255,76)","rgb(190,255,66)","rgb(200,255,56)","rgb(210,255,46)","rgb(220,255,36)","rgb(230,255,25)","rgb(240,255,15)","rgb(250,255,5)","rgb(255,250,0)","rgb(255,240,0)","rgb(255,229,0)","rgb(254,219,0)","rgb(254,209,0)","rgb(254,199,0)","rgb(254,189,0)","rgb(254,178,0)","rgb(253,168,0)","rgb(253,158,0)","rgb(253,148,0)","rgb(253,138,0)","rgb(253,127,0)","rgb(252,117,0)","rgb(252,107,0)","rgb(252,97,0)","rgb(252,87,0)","rgb(252,76,0)","rgb(251,66,0)","rgb(251,56,0)","rgb(251,46,0)","rgb(251,36,0)","rgb(251,25,0)","rgb(250,15,0)","rgb(250,5,0)","rgb(245,0,0)","rgb(235,0,0)","rgb(226,0,0)","rgb(216,0,0)","rgb(206,0,0)","rgb(196,0,0)","rgb(187,0,0)","rgb(177,0,0)","rgb(167,0,0)","rgb(157,0,0)","rgb(148,0,0)","rgb(138,0,0)"]},
{"id":"plotly_hot","colors":["rgb(0,0,0)","rgb(8,0,0)","rgb(15,0,0)","rgb(23,0,0)","rgb(31,0,0)","rgb(38,0,0)","rgb(46,0,0)","rgb(54,0,0)","rgb(61,0,0)","rgb(69,0,0)","rgb(77,0,0)","rgb(84,0,0)","rgb(92,0,0)","rgb(100,0,0)","rgb(107,0,0)","rgb(115,0,0)","rgb(123,0,0)","rgb(130,0,0)","rgb(138,0,0)","rgb(146,0,0)","rgb(153,0,0)","rgb(161,0,0)","rgb(169,0,0)","rgb(176,0,0)","rgb(184,0,0)","rgb(192,0,0)","rgb(199,0,0)","rgb(207,0,0)","rgb(215,0,0)","rgb(222,0,0)","rgb(230,0,0)","rgb(231,7,0)","rgb(232,14,0)","rgb(233,21,0)","rgb(233,28,0)","rgb(234,35,0)","rgb(235,42,0)","rgb(236,49,0)","rgb(237,56,0)","rgb(238,63,0)","rgb(238,70,0)","rgb(239,77,0)","rgb(240,84,0)","rgb(241,91,0)","rgb(242,98,0)","rgb(243,105,0)","rgb(243,112,0)","rgb(244,119,0)","rgb(245,126,0)","rgb(246,133,0)","rgb(247,140,0)","rgb(248,147,0)","rgb(248,154,0)","rgb(249,161,0)","rgb(250,168,0)","rgb(251,175,0)","rgb(252,182,0)","rgb(253,189,0)","rgb(253,196,0)","rgb(254,203,0)","rgb(255,210,0)","rgb(255,211,6)","rgb(255,212,13)","rgb(255,213,19)","rgb(255,215,26)","rgb(255,216,32)","rgb(255,217,38)","rgb(255,218,45)","rgb(255,219,51)","rgb(255,220,57)","rgb(255,221,64)","rgb(255,222,70)","rgb(255,224,77)","rgb(255,225,83)","rgb(255,226,89)","rgb(255,227,96)","rgb(255,228,102)","rgb(255,229,108)","rgb(255,230,115)","rgb(255,231,121)","rgb(255,233,128)","rgb(255,234,134)","rgb(255,235,140)","rgb(255,236,147)","rgb(255,237,153)","rgb(255,238,159)","rgb(255,239,166)","rgb(255,240,172)","rgb(255,242,179)","rgb(255,243,185)","rgb(255,244,191)","rgb(255,245,198)","rgb(255,246,204)","rgb(255,247,210)","rgb(255,248,217)","rgb(255,249,223)","rgb(255,251,230)","rgb(255,252,236)","rgb(255,253,242)","rgb(255,254,249)"]},
{"id":"plotly_blackbody","colors":["rgb(0,0,0)","rgb(11,0,0)","rgb(23,0,0)","rgb(35,0,0)","rgb(46,0,0)","rgb(58,0,0)","rgb(69,0,0)","rgb(81,0,0)","rgb(92,0,0)","rgb(103,0,0)","rgb(115,0,0)","rgb(126,0,0)","rgb(138,0,0)","rgb(149,0,0)","rgb(161,0,0)","rgb(172,0,0)","rgb(184,0,0)","rgb(196,0,0)","rgb(207,0,0)","rgb(219,0,0)","rgb(230,0,0)","rgb(230,11,0)","rgb(230,21,0)","rgb(230,32,0)","rgb(230,42,0)","rgb(230,53,0)","rgb(230,63,0)","rgb(230,74,0)","rgb(230,84,0)","rgb(230,95,0)","rgb(230,105,0)","rgb(230,116,0)","rgb(230,126,0)","rgb(230,137,0)","rgb(230,147,0)","rgb(230,158,0)","rgb(230,168,0)","rgb(230,179,0)","rgb(230,189,0)","rgb(230,200,0)","rgb(230,210,0)","rgb(231,212,9)","rgb(232,213,17)","rgb(233,215,26)","rgb(233,216,34)","rgb(234,218,43)","rgb(235,219,51)","rgb(236,221,60)","rgb(237,222,68)","rgb(238,224,77)","rgb(238,225,85)","rgb(239,227,94)","rgb(240,228,102)","rgb(241,230,111)","rgb(242,231,119)","rgb(243,233,128)","rgb(243,234,136)","rgb(244,236,145)","rgb(245,237,153)","rgb(246,239,162)","rgb(247,240,170)","rgb(248,242,179)","rgb(248,243,187)","rgb(249,245,196)","rgb(250,246,204)","rgb(251,248,213)","rgb(252,249,221)","rgb(253,251,230)","rgb(253,252,238)","rgb(254,254,247)","rgb(255,255,255)","rgb(252,253,255)","rgb(249,251,255)","rgb(245,249,255)","rgb(242,248,255)","rgb(239,246,255)","rgb(236,244,255)","rgb(233,242,255)","rgb(230,240,255)","rgb(226,238,255)","rgb(223,237,255)","rgb(220,235,255)","rgb(217,233,255)","rgb(214,231,255)","rgb(211,229,255)","rgb(207,227,255)","rgb(204,226,255)","rgb(201,224,255)","rgb(198,222,255)","rgb(195,220,255)","rgb(192,218,255)","rgb(188,216,255)","rgb(185,215,255)","rgb(182,213,255)","rgb(179,211,255)","rgb(176,209,255)","rgb(173,207,255)","rgb(169,205,255)","rgb(166,204,255)","rgb(163,202,255)"]},
{"id":"bright38","colors":["rgb(254,0,225)","rgb(188,0,254)","rgb(165,0,254)","rgb(134,0,254)","rgb(111,0,254)","rgb(81,0,254)","rgb(58,0,254)","rgb(28,0,254)","rgb(0,2,254)","rgb(0,33,254)","rgb(0,56,254)","rgb(0,78,254)","rgb(0,139,254)","rgb(0,169,254)","rgb(0,208,254)","rgb(0,231,254)","rgb(0,254,231)","rgb(0,254,200)","rgb(0,254,169)","rgb(0,254,139)","rgb(0,254,109)","rgb(0,254,79)","rgb(0,254,39)","rgb(0,254,0)","rgb(42,254,0)","rgb(88,254,0)","rgb(126,254,0)","rgb(164,254,0)","rgb(195,254,0)","rgb(226,254,0)","rgb(254,243,0)","rgb(254,199,0)","rgb(254,167,0)","rgb(254,137,0)","rgb(254,106,0)","rgb(254,68,0)","rgb(254,30,0)","rgb(254,0,0)"]},
{"category":"Earth"},
{"id":"plotly_earth","colors":["rgb(0,0,130)","rgb(0,18,135)","rgb(0,36,140)","rgb(0,54,145)","rgb(0,72,150)","rgb(0,90,155)","rgb(0,108,160)","rgb(0,126,165)","rgb(0,144,170)","rgb(0,162,175)","rgb(0,180,180)","rgb(4,183,166)","rgb(8,186,152)","rgb(12,189,138)","rgb(16,192,124)","rgb(20,195,110)","rgb(24,198,96)","rgb(28,201,82)","rgb(32,204,68)","rgb(36,207,54)","rgb(40,210,40)","rgb(50,211,41)","rgb(59,212,41)","rgb(69,213,42)","rgb(78,214,42)","rgb(88,215,43)","rgb(97,216,43)","rgb(107,217,44)","rgb(116,218,44)","rgb(126,219,45)","rgb(135,220,45)","rgb(145,221,46)","rgb(154,222,46)","rgb(164,223,47)","rgb(173,224,47)","rgb(183,225,48)","rgb(192,226,48)","rgb(202,227,49)","rgb(211,228,49)","rgb(221,229,50)","rgb(230,230,50)","rgb(224,222,48)","rgb(219,214,47)","rgb(213,206,45)","rgb(208,198,44)","rgb(202,190,42)","rgb(197,182,41)","rgb(191,174,39)","rgb(186,166,38)","rgb(180,158,36)","rgb(175,150,35)","rgb(169,142,33)","rgb(164,134,32)","rgb(158,126,30)","rgb(153,118,29)","rgb(147,110,27)","rgb(142,102,26)","rgb(136,94,24)","rgb(131,86,23)","rgb(125,78,21)","rgb(120,70,20)","rgb(123,75,26)","rgb(127,79,32)","rgb(130,84,38)","rgb(134,89,44)","rgb(137,93,49)","rgb(140,98,55)","rgb(144,102,61)","rgb(147,107,67)","rgb(150,112,73)","rgb(154,116,79)","rgb(157,121,85)","rgb(161,126,91)","rgb(164,130,96)","rgb(167,135,102)","rgb(171,139,108)","rgb(174,144,114)","rgb(177,149,120)","rgb(181,153,126)","rgb(184,158,132)","rgb(188,163,138)","rgb(191,167,143)","rgb(194,172,149)","rgb(198,176,155)","rgb(201,181,161)","rgb(204,186,167)","rgb(208,190,173)","rgb(211,195,179)","rgb(215,200,185)","rgb(218,204,190)","rgb(221,209,196)","rgb(225,213,202)","rgb(228,218,208)","rgb(231,223,214)","rgb(235,227,220)","rgb(238,232,226)","rgb(242,237,232)","rgb(245,241,237)","rgb(248,246,243)","rgb(252,250,249)"]},
{"id":"topographic","colors":["rgb(20,170,42)","rgb(20,170,42)","rgb(27,174,35)","rgb(35,179,28)","rgb(43,184,22)","rgb(51,188,15)","rgb(59,193,9)","rgb(67,198,2)","rgb(70,200,0)","rgb(71,199,0)","rgb(72,199,1)","rgb(73,198,1)","rgb(74,198,2)","rgb(75,197,2)","rgb(76,197,3)","rgb(78,197,3)","rgb(79,196,4)","rgb(80,196,4)","rgb(81,195,5)","rgb(82,195,5)","rgb(83,194,6)","rgb(85,194,6)","rgb(86,194,7)","rgb(87,193,7)","rgb(88,193,8)","rgb(89,192,8)","rgb(90,192,9)","rgb(92,191,9)","rgb(93,191,10)","rgb(94,191,10)","rgb(95,190,11)","rgb(96,190,11)","rgb(97,189,12)","rgb(98,189,12)","rgb(100,188,13)","rgb(101,188,13)","rgb(102,188,14)","rgb(103,187,14)","rgb(104,187,15)","rgb(105,186,15)","rgb(107,186,16)","rgb(108,185,16)","rgb(109,185,17)","rgb(110,185,17)","rgb(111,184,18)","rgb(112,184,18)","rgb(114,183,19)","rgb(115,183,19)","rgb(116,182,20)","rgb(117,182,21)","rgb(118,182,21)","rgb(119,181,22)","rgb(120,181,22)","rgb(122,180,23)","rgb(123,180,23)","rgb(124,179,24)","rgb(125,179,24)","rgb(126,179,25)","rgb(127,178,25)","rgb(129,178,26)","rgb(130,177,26)","rgb(131,177,27)","rgb(132,176,27)","rgb(133,176,28)","rgb(134,176,28)","rgb(136,175,29)","rgb(137,175,29)","rgb(138,174,30)","rgb(139,174,30)","rgb(140,173,31)","rgb(141,173,31)","rgb(143,173,32)","rgb(144,172,32)","rgb(145,172,33)","rgb(146,171,33)","rgb(147,171,34)","rgb(148,170,34)","rgb(149,170,35)","rgb(151,170,35)","rgb(152,169,36)","rgb(153,169,36)","rgb(154,168,37)","rgb(155,168,37)","rgb(156,167,38)","rgb(158,167,38)","rgb(159,167,39)","rgb(160,166,39)","rgb(161,166,40)","rgb(162,165,40)","rgb(163,165,41)","rgb(165,165,42)","rgb(165,165,42)","rgb(165,165,43)","rgb(165,165,44)","rgb(165,165,45)","rgb(166,166,46)","rgb(166,166,47)","rgb(166,166,48)","rgb(166,166,49)","rgb(166,166,50)","rgb(167,167,51)","rgb(167,167,52)","rgb(167,167,53)","rgb(167,167,54)","rgb(167,167,55)","rgb(168,168,56)","rgb(168,168,57)","rgb(168,168,58)","rgb(168,168,59)","rgb(169,169,60)","rgb(169,169,61)","rgb(169,169,62)","rgb(169,169,63)","rgb(169,169,64)","rgb(170,170,65)","rgb(170,170,66)","rgb(170,170,67)","rgb(170,170,68)","rgb(170,170,68)","rgb(171,171,69)","rgb(171,171,70)","rgb(171,171,71)","rgb(171,171,72)","rgb(172,172,73)","rgb(172,172,74)","rgb(172,172,75)","rgb(172,172,76)","rgb(172,172,77)","rgb(173,173,78)","rgb(173,173,79)","rgb(173,173,80)","rgb(173,173,81)","rgb(173,173,82)","rgb(174,174,83)","rgb(174,174,84)","rgb(174,174,85)","rgb(174,174,86)","rgb(175,175,87)","rgb(175,175,88)","rgb(175,175,89)","rgb(175,175,90)","rgb(175,175,91)","rgb(176,176,92)","rgb(176,176,93)","rgb(176,176,94)","rgb(176,176,95)","rgb(176,176,95)","rgb(177,177,96)","rgb(177,177,97)","rgb(177,177,98)","rgb(177,177,99)","rgb(178,178,100)","rgb(178,178,101)","rgb(178,178,102)","rgb(178,178,103)","rgb(178,178,104)","rgb(179,179,105)","rgb(179,179,106)","rgb(179,179,107)","rgb(179,179,108)","rgb(179,179,109)","rgb(180,180,110)","rgb(180,180,111)","rgb(180,180,112)","rgb(180,180,113)","rgb(181,181,114)","rgb(181,181,115)","rgb(181,181,116)","rgb(181,181,117)","rgb(181,181,118)","rgb(182,182,119)","rgb(182,182,120)","rgb(182,182,121)","rgb(182,182,121)","rgb(182,182,122)","rgb(183,183,123)","rgb(183,183,124)","rgb(183,183,125)","rgb(183,183,126)","rgb(184,184,127)","rgb(184,184,128)","rgb(184,184,129)","rgb(184,184,130)","rgb(184,184,131)","rgb(185,185,132)","rgb(185,185,133)","rgb(185,185,134)","rgb(185,185,135)","rgb(185,185,136)","rgb(186,186,137)","rgb(186,186,138)","rgb(186,186,139)","rgb(186,186,140)","rgb(186,186,141)","rgb(187,187,142)","rgb(187,187,143)","rgb(187,187,144)","rgb(187,187,145)","rgb(188,188,146)","rgb(188,188,147)","rgb(188,188,148)","rgb(188,188,148)","rgb(188,188,149)","rgb(189,189,150)","rgb(189,189,151)","rgb(189,189,152)","rgb(189,189,153)","rgb(189,189,154)","rgb(190,190,155)","rgb(190,190,156)","rgb(190,190,157)","rgb(190,190,158)","rgb(191,191,159)","rgb(191,191,160)","rgb(191,191,161)","rgb(191,191,162)","rgb(191,191,163)","rgb(192,192,164)","rgb(192,192,165)","rgb(192,192,166)","rgb(192,192,167)","rgb(192,192,168)","rgb(193,193,169)","rgb(193,193,170)","rgb(193,193,171)","rgb(193,193,172)","rgb(194,194,173)","rgb(194,194,174)","rgb(194,194,175)","rgb(194,194,175)","rgb(194,194,176)","rgb(195,195,177)","rgb(195,195,178)","rgb(195,195,179)","rgb(195,195,180)","rgb(195,195,181)","rgb(196,196,182)","rgb(196,196,183)","rgb(196,196,184)","rgb(196,196,185)","rgb(197,197,186)","rgb(197,197,187)","rgb(197,197,188)","rgb(197,197,189)","rgb(197,197,190)","rgb(198,198,191)","rgb(198,198,192)","rgb(198,198,193)","rgb(198,198,194)","rgb(198,198,195)","rgb(199,199,196)","rgb(199,199,197)","rgb(199,199,198)","rgb(199,199,199)","rgb(255,255,255)"]},
{"id":"precipitation","colors":["rgba(255,255,255,0)","rgb(6,13,255)","rgb(13,26,255)","rgb(20,40,255)","rgb(26,53,255)","rgb(33,67,255)","rgb(40,80,255)","rgb(46,93,255)","rgb(53,107,255)","rgb(60,120,255)","rgb(67,134,255)","rgb(73,147,255)","rgb(80,161,255)","rgb(87,174,255)","rgb(93,187,255)","rgb(100,201,255)","rgb(107,214,255)","rgb(114,228,255)","rgb(120,241,255)","rgb(127,255,255)","rgb(127,255,229)","rgb(129,253,223)","rgb(130,251,216)","rgb(132,249,210)","rgb(133,247,203)","rgb(135,245,197)","rgb(137,243,190)","rgb(138,241,184)","rgb(140,239,177)","rgb(142,237,171)","rgb(143,235,164)","rgb(145,233,158)","rgb(146,231,152)","rgb(148,229,145)","rgb(150,227,139)","rgb(151,225,132)","rgb(153,224,126)","rgb(154,222,119)","rgb(156,220,113)","rgb(158,218,106)","rgb(159,216,100)","rgb(161,214,93)","rgb(163,212,87)","rgb(164,210,81)","rgb(166,208,74)","rgb(167,206,68)","rgb(169,204,61)","rgb(171,202,55)","rgb(172,200,48)","rgb(174,198,42)","rgb(175,196,35)","rgb(177,194,29)","rgb(179,193,22)","rgb(180,191,16)","rgb(182,189,10)","rgb(183,187,3)","rgb(185,185,0)","rgb(187,183,0)","rgb(188,181,0)","rgb(190,179,0)","rgb(192,177,0)","rgb(193,175,0)","rgb(195,173,0)","rgb(196,171,0)","rgb(198,169,0)","rgb(200,167,0)","rgb(201,165,0)","rgb(203,163,0)","rgb(204,162,0)","rgb(206,160,0)","rgb(208,158,0)","rgb(209,156,0)","rgb(211,154,0)","rgb(213,152,0)","rgb(214,150,0)","rgb(216,148,0)","rgb(217,146,0)","rgb(219,144,0)","rgb(221,142,0)","rgb(222,140,0)","rgb(224,138,0)","rgb(225,136,0)","rgb(227,134,0)","rgb(229,132,0)","rgb(230,131,0)","rgb(232,129,0)","rgb(234,127,0)","rgb(235,125,0)","rgb(237,123,0)","rgb(238,121,0)","rgb(240,119,0)","rgb(242,117,0)","rgb(243,115,0)","rgb(245,113,0)","rgb(246,111,0)","rgb(248,109,0)","rgb(250,107,0)","rgb(251,105,0)","rgb(253,103,0)","rgb(255,101,0)"]},
{"id":"humidity","colors":["rgb(255,255,0)","rgb(228,255,0)","rgb(201,255,0)","rgb(174,255,0)","rgb(147,255,0)","rgb(120,255,0)","rgb(93,255,0)","rgb(67,255,0)","rgb(40,255,0)","rgb(13,255,0)","rgb(0,248,13)","rgb(0,234,40)","rgb(0,221,67)","rgb(0,208,93)","rgb(0,194,120)","rgb(0,181,147)","rgb(0,167,174)","rgb(0,154,201)","rgb(0,140,228)","rgb(0,127,255)"]},
{"id":"airquality","min":0,"max":300,"colors":["rgb(140,223,91)","rgb(139,224,92)","rgb(141,225,90)","rgb(144,224,90)","rgb(145,226,90)","rgb(146,226,89)","rgb(149,227,90)","rgb(151,226,88)","rgb(153,227,88)","rgb(153,228,88)","rgb(156,228,88)","rgb(157,228,86)","rgb(158,229,87)","rgb(161,230,86)","rgb(162,229,86)","rgb(164,230,85)","rgb(165,231,85)","rgb(167,231,85)","rgb(168,232,85)","rgb(172,233,84)","rgb(173,233,84)","rgb(175,234,83)","rgb(176,234,84)","rgb(179,235,83)","rgb(179,235,83)","rgb(182,235,83)","rgb(183,236,83)","rgb(186,236,83)","rgb(187,237,83)","rgb(189,238,82)","rgb(191,238,83)","rgb(193,238,82)","rgb(196,240,81)","rgb(197,240,82)","rgb(198,241,82)","rgb(202,240,82)","rgb(203,242,82)","rgb(204,242,82)","rgb(208,243,83)","rgb(209,242,81)","rgb(211,244,82)","rgb(213,245,82)","rgb(215,244,82)","rgb(217,245,81)","rgb(218,246,82)","rgb(221,247,82)","rgb(223,245,82)","rgb(224,247,81)","rgb(226,247,82)","rgb(228,248,82)","rgb(230,249,82)","rgb(232,250,82)","rgb(234,250,83)","rgb(237,251,82)","rgb(238,251,83)","rgb(241,252,83)","rgb(241,252,83)","rgb(245,253,84)","rgb(246,253,84)","rgb(249,254,84)","rgb(251,254,85)","rgb(252,255,84)","rgb(255,254,85)","rgb(255,252,83)","rgb(255,250,82)","rgb(254,249,83)","rgb(253,247,81)","rgb(254,244,81)","rgb(253,243,80)","rgb(252,241,80)","rgb(253,239,80)","rgb(253,236,78)","rgb(252,235,78)","rgb(251,234,78)","rgb(252,231,77)","rgb(251,228,76)","rgb(250,227,76)","rgb(251,225,76)","rgb(249,222,75)","rgb(249,221,73)","rgb(250,220,73)","rgb(248,217,73)","rgb(248,216,73)","rgb(248,213,71)","rgb(247,212,71)","rgb(248,209,70)","rgb(247,207,70)","rgb(248,205,69)","rgb(246,203,69)","rgb(247,201,69)","rgb(245,199,68)","rgb(246,197,67)","rgb(245,195,67)","rgb(245,194,66)","rgb(245,191,66)","rgb(245,190,65)","rgb(245,188,64)","rgb(244,187,64)","rgb(243,184,63)","rgb(245,182,63)","rgb(243,181,62)","rgb(243,179,62)","rgb(244,177,62)","rgb(244,174,60)","rgb(243,173,61)","rgb(242,172,60)","rgb(243,169,60)","rgb(242,166,58)","rgb(241,166,59)","rgb(242,164,58)","rgb(241,161,58)","rgb(241,159,56)","rgb(242,158,56)","rgb(240,156,56)","rgb(240,154,56)","rgb(241,153,55)","rgb(240,151,55)","rgb(241,149,53)","rgb(240,147,54)","rgb(240,146,53)","rgb(239,143,52)","rgb(240,141,52)","rgb(238,138,52)","rgb(239,136,51)","rgb(238,135,51)","rgb(238,133,50)","rgb(238,130,50)","rgb(238,128,49)","rgb(239,127,48)","rgb(237,126,49)","rgb(237,124,48)","rgb(238,121,47)","rgb(237,120,47)","rgb(237,119,47)","rgb(238,116,47)","rgb(237,114,45)","rgb(237,113,46)","rgb(236,112,45)","rgb(237,110,45)","rgb(237,107,44)","rgb(236,107,44)","rgb(237,104,44)","rgb(236,102,44)","rgb(236,101,42)","rgb(236,99,43)","rgb(235,97,42)","rgb(235,96,42)","rgb(236,95,42)","rgb(235,94,42)","rgb(236,92,41)","rgb(235,91,41)","rgb(236,89,41)","rgb(235,88,40)","rgb(235,85,41)","rgb(234,84,40)","rgb(235,83,40)","rgb(235,81,40)","rgb(235,81,39)","rgb(235,78,40)","rgb(235,77,39)","rgb(236,76,38)","rgb(234,75,39)","rgb(234,73,38)","rgb(235,71,38)","rgb(234,71,38)","rgb(234,70,38)","rgb(235,68,38)","rgb(235,66,37)","rgb(235,66,37)","rgb(234,65,37)","rgb(235,64,37)","rgb(235,62,36)","rgb(234,62,37)","rgb(235,61,36)","rgb(234,59,37)","rgb(234,58,35)","rgb(234,58,36)","rgb(233,57,36)","rgb(233,57,36)","rgb(234,56,36)","rgb(234,55,36)","rgb(235,55,35)","rgb(233,54,36)","rgb(235,54,35)","rgb(233,54,35)","rgb(234,53,36)","rgb(233,52,36)","rgb(233,51,36)","rgb(231,50,37)","rgb(230,51,36)","rgb(228,50,38)","rgb(227,50,37)","rgb(226,50,37)","rgb(223,51,39)","rgb(221,50,39)","rgb(221,49,40)","rgb(218,50,41)","rgb(217,50,43)","rgb(216,49,44)","rgb(215,48,44)","rgb(213,49,46)","rgb(211,50,47)","rgb(210,49,49)","rgb(208,48,49)","rgb(205,49,51)","rgb(204,49,53)","rgb(203,48,55)","rgb(201,48,56)","rgb(199,49,58)","rgb(197,48,59)","rgb(196,49,62)","rgb(195,49,63)","rgb(192,49,65)","rgb(192,49,67)","rgb(190,50,69)","rgb(189,50,71)","rgb(186,50,73)","rgb(185,50,75)","rgb(183,50,78)","rgb(182,51,79)","rgb(180,51,81)","rgb(178,52,83)","rgb(178,51,86)","rgb(176,52,87)","rgb(174,52,89)","rgb(171,53,92)","rgb(170,54,94)","rgb(170,53,95)","rgb(167,55,97)","rgb(165,55,100)","rgb(166,55,103)","rgb(163,55,104)","rgb(161,56,107)","rgb(159,57,109)","rgb(159,57,111)","rgb(157,57,112)","rgb(155,59,115)","rgb(154,59,117)","rgb(151,59,120)","rgb(150,60,121)","rgb(150,61,124)","rgb(146,61,126)","rgb(144,62,128)","rgb(145,63,130)","rgb(142,64,133)","rgb(142,64,134)","rgb(138,65,137)","rgb(139,66,138)","rgb(136,66,142)","rgb(135,67,144)","rgb(132,67,146)","rgb(133,67,144)","rgb(132,65,143)","rgb(132,66,141)","rgb(132,64,140)","rgb(132,63,137)","rgb(131,62,134)","rgb(130,62,133)","rgb(130,61,132)","rgb(130,59,130)","rgb(129,59,128)","rgb(129,58,127)","rgb(130,57,125)","rgb(129,55,122)","rgb(129,55,122)","rgb(128,55,120)","rgb(129,54,118)","rgb(128,52,115)","rgb(127,52,114)","rgb(128,51,113)","rgb(127,49,111)","rgb(126,49,108)","rgb(127,48,107)","rgb(125,47,106)","rgb(125,47,103)","rgb(125,46,102)","rgb(125,45,101)","rgb(126,44,98)","rgb(124,43,97)","rgb(125,43,95)","rgb(123,42,93)","rgb(124,41,92)","rgb(122,40,90)","rgb(123,39,88)","rgb(123,38,87)","rgb(123,38,84)","rgb(122,37,84)","rgb(122,36,81)","rgb(123,35,79)","rgb(121,36,79)","rgb(120,34,76)","rgb(122,33,74)","rgb(121,33,73)","rgb(119,33,71)","rgb(121,31,70)","rgb(120,30,67)","rgb(120,30,66)","rgb(119,30,65)","rgb(120,29,63)","rgb(119,28,60)","rgb(119,28,59)","rgb(119,27,57)","rgb(118,26,56)","rgb(118,26,54)","rgb(119,26,52)","rgb(116,24,51)","rgb(116,24,49)","rgb(117,24,47)","rgb(116,23,47)","rgb(117,23,44)","rgb(116,22,43)","rgb(117,22,41)","rgb(114,21,39)","rgb(115,20,38)","rgb(114,20,38)","rgb(115,20,38)","rgb(115,20,38)","rgb(115,21,37)","rgb(115,20,38)","rgb(115,20,37)","rgb(116,20,37)","rgb(114,21,38)","rgb(114,20,37)","rgb(116,20,37)","rgb(115,21,37)","rgb(114,21,38)","rgb(116,20,38)","rgb(115,19,37)","rgb(115,20,38)","rgb(115,21,38)","rgb(116,20,38)","rgb(115,20,37)","rgb(115,20,38)","rgb(116,20,37)","rgb(115,19,38)","rgb(115,20,37)","rgb(116,20,37)","rgb(114,20,37)","rgb(114,20,38)","rgb(115,20,37)","rgb(115,20,38)","rgb(116,20,37)","rgb(115,20,38)","rgb(116,20,37)","rgb(114,20,37)","rgb(115,20,38)","rgb(114,20,38)","rgb(115,20,38)","rgb(115,20,38)","rgb(115,21,37)","rgb(115,20,38)","rgb(115,20,37)","rgb(116,20,37)","rgb(114,21,38)","rgb(114,20,37)","rgb(116,20,37)","rgb(115,21,37)","rgb(114,21,38)","rgb(116,20,38)","rgb(115,19,37)","rgb(115,20,38)","rgb(115,21,38)","rgb(116,20,38)","rgb(115,20,37)","rgb(115,20,38)","rgb(116,20,37)","rgb(115,19,38)","rgb(115,20,37)","rgb(116,20,37)","rgb(114,20,37)","rgb(114,20,38)","rgb(115,20,37)","rgb(115,20,38)"]},
{"id":"temperature","min":-90,"max":45,"colors":["rgb(0,0,250)","rgb(0,2,250)","rgb(0,5,250)","rgb(0,8,250)","rgb(0,11,250)","rgb(0,14,250)","rgb(0,16,250)","rgb(0,19,250)","rgb(0,22,250)","rgb(0,25,250)","rgb(0,28,250)","rgb(0,30,250)","rgb(0,33,250)","rgb(0,36,250)","rgb(0,39,250)","rgb(0,42,250)","rgb(0,44,250)","rgb(0,47,250)","rgb(0,50,250)","rgb(0,53,250)","rgb(0,56,250)","rgb(0,58,250)","rgb(0,61,250)","rgb(0,64,250)","rgb(0,67,250)","rgb(0,70,250)","rgb(0,73,250)","rgb(0,75,250)","rgb(0,78,250)","rgb(0,81,250)","rgb(0,84,250)","rgb(0,87,250)","rgb(0,89,250)","rgb(0,92,250)","rgb(0,95,250)","rgb(0,98,250)","rgb(0,101,250)","rgb(0,103,250)","rgb(0,106,250)","rgb(0,109,250)","rgb(0,112,250)","rgb(0,115,250)","rgb(0,117,250)","rgb(0,120,250)","rgb(0,123,250)","rgb(0,126,250)","rgb(0,129,250)","rgb(0,132,250)","rgb(0,134,250)","rgb(0,137,250)","rgb(0,140,250)","rgb(0,143,250)","rgb(0,146,250)","rgb(0,148,250)","rgb(0,151,250)","rgb(0,154,250)","rgb(0,157,250)","rgb(0,160,250)","rgb(0,162,250)","rgb(0,165,250)","rgb(0,168,250)","rgb(0,171,250)","rgb(0,174,250)","rgb(0,176,250)","rgb(0,179,250)","rgb(0,182,250)","rgb(0,185,250)","rgb(0,188,250)","rgb(0,191,250)","rgb(0,193,250)","rgb(0,196,250)","rgb(0,199,250)","rgb(0,202,250)","rgb(0,205,250)","rgb(0,207,250)","rgb(0,210,250)","rgb(0,213,250)","rgb(0,216,250)","rgb(0,219,250)","rgb(0,221,250)","rgb(0,224,250)","rgb(0,227,250)","rgb(0,230,250)","rgb(0,233,250)","rgb(0,235,250)","rgb(0,238,250)","rgb(0,241,250)","rgb(0,244,250)","rgb(0,247,250)","rgb(0,255,255)","rgb(0,255,203)","rgb(0,255,152)","rgb(0,255,101)","rgb(0,255,50)","rgb(0,255,0)","rgb(22,255,0)","rgb(45,255,0)","rgb(68,255,0)","rgb(91,255,0)","rgb(113,255,0)","rgb(136,255,0)","rgb(159,255,0)","rgb(182,255,0)","rgb(205,255,0)","rgb(255,255,0)","rgb(255,247,0)","rgb(255,240,0)","rgb(255,232,0)","rgb(255,225,0)","rgb(255,217,0)","rgb(255,210,0)","rgb(255,202,0)","rgb(255,195,0)","rgb(255,187,0)","rgb(255,180,0)","rgb(255,172,0)","rgb(255,165,0)","rgb(255,157,0)","rgb(255,150,0)","rgb(255,142,0)","rgb(255,135,0)","rgb(255,127,0)","rgb(255,120,0)","rgb(255,112,0)","rgb(255,105,0)","rgb(255,97,0)","rgb(255,90,0)","rgb(255,82,0)","rgb(255,75,0)","rgb(255,67,0)","rgb(255,60,0)","rgb(255,52,0)","rgb(255,45,0)","rgb(255,37,0)","rgb(255,30,0)"]},
{"id":"wind_comps","colors":["rgb(0,0,179)","rgb(10,24,187)","rgb(20,48,194)","rgb(31,73,202)","rgb(41,97,210)","rgb(52,122,218)","rgb(62,146,226)","rgb(73,170,234)","rgb(83,195,242)","rgb(94,219,249)","rgb(64,207,243)","rgb(64,212,222)","rgb(64,218,201)","rgb(64,223,180)","rgb(64,228,159)","rgb(64,233,138)","rgb(64,238,117)","rgb(64,243,96)","rgb(64,248,75)","rgb(64,254,54)"]},
{"id":"windspeed","colors":["rgb(0,0,250)","rgb(0,12,250)","rgb(0,25,250)","rgb(0,37,250)","rgb(0,50,250)","rgb(0,62,250)","rgb(0,75,250)","rgb(0,87,250)","rgb(0,100,250)","rgb(0,112,250)","rgb(0,125,250)","rgb(0,137,250)","rgb(0,150,250)","rgb(0,162,250)","rgb(0,175,250)","rgb(0,187,250)","rgb(0,200,250)","rgb(0,212,250)","rgb(0,225,250)","rgb(0,237,250)","rgb(0,255,255)","rgb(0,255,234)","rgb(0,255,214)","rgb(0,255,193)","rgb(0,255,173)","rgb(0,255,152)","rgb(0,255,132)","rgb(0,255,111)","rgb(0,255,91)","rgb(0,255,70)","rgb(0,255,0)","rgb(20,255,0)","rgb(41,255,0)","rgb(61,255,0)","rgb(82,255,0)","rgb(102,255,0)","rgb(123,255,0)","rgb(143,255,0)","rgb(164,255,0)","rgb(184,255,0)","rgb(255,255,0)","rgb(255,247,0)","rgb(255,240,0)","rgb(255,232,0)","rgb(255,225,0)","rgb(255,217,0)","rgb(255,210,0)","rgb(255,202,0)","rgb(255,195,0)","rgb(255,187,0)","rgb(255,180,0)","rgb(255,172,0)","rgb(255,165,0)","rgb(255,157,0)","rgb(255,150,0)","rgb(255,142,0)","rgb(255,135,0)","rgb(255,127,0)","rgb(255,120,0)","rgb(255,112,0)","rgb(255,105,0)","rgb(255,97,0)","rgb(255,90,0)","rgb(255,82,0)","rgb(255,75,0)","rgb(255,67,0)","rgb(255,60,0)","rgb(255,52,0)","rgb(255,45,0)","rgb(255,37,0)"]},
{"id":"dbz","colors":["rgb(1,57,255)","rgb(0,140,255)","rgb(1,209,255)","rgb(1,255,232)","rgb(1,255,171)","rgb(1,255,79)","rgb(43,255,0)","rgb(166,255,2)","rgb(227,255,1)","rgb(255,198,0)","rgb(255,168,1)","rgb(255,145,1)","rgb(255,130,1)","rgb(255,107,0)","rgb(255,84,0)","rgb(255,7,0)"]},
{"id":"dbz_nws","colors":["rgb(0,0,0)","rgb(0,255,255)","rgb(135,206,235)","rgb(0,0,255)","rgb(0,255,0)","rgb(50,205,50)","rgb(34,139,34)","rgb(238,238,0)","rgb(238,220,130)","rgb(238,118,33)","rgb(255,48,48)","rgb(176,48,96)","rgb(176,48,96)","rgb(186,85,211)","rgb(255,0,255)","rgb(255,255,255)"]},
{"category":"Fixed"},
{"id":"black","colors":["#000"]},
{"id":"white","colors":["#fff"]},
{"id":"red","colors":["red"]},
{"id":"green","colors":["green"]},
{"id":"blue","colors":["blue"]}
];

Utils.addColorTables(defaultColorTables);

/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/

function AreaWidget(display,arg) {
    this.arg=arg;
    this.createTime  = new Date();
    const ID_CONTAINS = "mapcontains";
    const ID_NORTH = "north";
    const ID_SOUTH = "south";
    const ID_EAST = "east";
    const ID_WEST = "west";
    const ID_SETTINGS = "mapsettings";
    const ID_AREA_LINK = "arealink";
    const ID_MAP_SHOW = "showmap";
    const ID_MAP_POPUP_WRAPPER = "mappopupwrapper";    
    const ID_MAP_POPUP = "mappopup";    
    const ID_CLEAR = "mapclear";    
    const ID_SET_LOCATION="mapsetlocation";



    let mapContains = this.arg?null:Utils.stringDefined(HU.getUrlArgument("map_contains"))?HU.getUrlArgument("map_contains")=='true':true;
    $.extend(this, {
	areaContains: mapContains,
        display: display,
	domId:function(id) {
	    if(this.arg!=null)
		id =  this.arg+'_'+ id;
	    return this.display.domId(id);
	},
	jq:function(id) {
	    return jqid(this.domId(id));
	},
        initHtml: function() {
	    this.jq(ID_SETTINGS).click(()=>{
		this.showSettings();
	    });
	    this.jq(ID_MAP_SHOW).click(()=>{
		this.showMap();
	    });

	    let params = {};
	    this.map =  new RepositoryMap(this.domId(ID_MAP_POPUP), params);
	    this.map.setSelection(this.arg?this.domId(''):this.display.getId(),true,1);
	},
        showSettings: function() {
	    let _this = this;
	    let html = "";
	    html+= HU.div([CLASS,"ramadda-clickable",TITLE, "Use my location",ID,this.domId(ID_SET_LOCATION)],
			  HU.getIconImage("fas fa-compass") + SPACE + "Use my location");
            html += HU.div([CLASS,"ramadda-clickable",TITLE, "Clear form",ID,this.domId(ID_CLEAR)],
			  HU.getIconImage("fas fa-eraser") + SPACE + "Clear form");
	    html+= HU.div([TITLE, "Search mode: checked - contains, unchecked - overlaps"],
			  HtmlUtils.checkbox("",[ID, this.domId(ID_CONTAINS)], this.areaContains) +HU.tag("label",[CLASS,"ramadda-clickable","for",this.domId(ID_CONTAINS)], SPACE + "Contains"));
	    html = HU.div([STYLE,"margin:5px;"], html);
	    this.settingsDialog = HU.makeDialog({content:html,anchor:this.jq(ID_SETTINGS),draggable:false,header:true});
	    this.jq(ID_CONTAINS).change(function(e) {
		_this.areaContains = $(this).is(':checked');
	    });
	    this.jq(ID_SET_LOCATION).click(()=>{
		this.settingsDialog.remove();
		this.useMyLocation();
	    });
	    this.jq(ID_CLEAR).click(()=>{
		this.settingsDialog.remove();
		this.areaClear();
	    });	    
	},
        getHtml: function() {
	    let bounds =  this.arg?null:HU.getUrlArgument("map_bounds");
	    let n="",w="",s="",e="";
	    if(bounds) {
		[n,w,s,e]  = bounds.split(",");
	    }
            let callback = this.display.getGet();
            let settings = HU.div([TITLE,"Settings",CLASS,"ramadda-clickable",ID,this.domId(ID_SETTINGS)],HU.getIconImage("fas fa-cog"));
	    let showMap = HU.div([CLASS,"ramadda-clickable",ID,this.domId(ID_MAP_SHOW),TITLE,"Show map selector"], HtmlUtils.getIconImage("fas fa-globe"));

	    let input = (id,place,title,v)=>{
		return HtmlUtils.input(id, v, ["placeholder", place, ATTR_CLASS, "input display-area-input", "size", "5", ATTR_ID,
						this.domId(id), ATTR_TITLE, title]);
	    };
            let areaForm = HtmlUtils.openTag(TAG_TABLE, [ATTR_CLASS, "display-area"]);
            areaForm += HtmlUtils.tr([],
				     HtmlUtils.td(["align", "center"],
						  HtmlUtils.leftCenterRight("",
									    input(ID_NORTH, " N","North",n),showMap, "20%", "60%", "20%")));

            areaForm += HtmlUtils.tr([], HtmlUtils.td([],
						      input(ID_WEST, " W", "West",w) +
						      input(ID_EAST, " E", "East",e)));

            areaForm += HtmlUtils.tr([],
				     HtmlUtils.td(["align", "center"],
						  HtmlUtils.leftCenterRight("", input(ID_SOUTH,  " S", "South",s), settings, "20%", "60%", "20%")));


            areaForm += HtmlUtils.closeTag(TAG_TABLE);
            areaForm += HU.div([ID,this.domId(ID_MAP_POPUP_WRAPPER),STYLE,HU.css("display","none")],SPACE+"Shift-drag: select region. Cmd-drag: move region" +
				HU.div([ID,this.domId(ID_MAP_POPUP),STYLE,HU.css("width","400px","height","300px")]));
            return areaForm;
        },
	showMap: function() {
	    let anchor = this.jq(ID_MAP_SHOW);
	    this.dialog = HU.makeDialog({contentId:this.domId(ID_MAP_POPUP_WRAPPER),anchor:anchor,draggable:true,header:true});
	    this.map.selectionPopupInit();
	    this.map.getMap().updateSize();
	},
        areaClear: function() {
            $("#" + this.domId(ID_NORTH)).val("");
            $("#" + this.domId(ID_WEST)).val("");
            $("#" + this.domId(ID_SOUTH)).val("");
            $("#" + this.domId(ID_EAST)).val("");
            this.display.areaClear();
        },
        useMyLocation: function() {
            if (navigator.geolocation) {
                let _this = this;
                navigator.geolocation.getCurrentPosition(function(position) {
                    _this.setUseMyLocation(position);
                });
            } else {}
        },
        setUseMyLocation: function(position) {
            let lat = position.coords.latitude;
            let lon = position.coords.longitude;
            let offset = 5.0;
            if (this.display.myLocationOffset)
                offset = parseFloat(this.display.myLocationOffset);

            $("#" + this.domId(ID_NORTH)).val(lat + offset);
            $("#" + this.domId(ID_WEST)).val(lon - offset);
            $("#" + this.domId(ID_SOUTH)).val(lat - offset);
            $("#" + this.domId(ID_EAST)).val(lon + offset);
            if (this.display.submitSearchForm)
                this.display.submitSearchForm();
        },
        areaLinkClick: function() {
            this.linkArea = !this.linkArea;
            let image = root + (this.linkArea ? "/icons/link.png" : "/icons/link_break.png");
            $("#" + this.domId(ID_AREA_LINK)).attr("src", image);
            if (this.linkArea && this.lastBounds) {
                let b = this.lastBounds;
                $("#" + this.domId(ID_NORTH)).val(MapUtils.formatLocationValue(b.top));
                $("#" + this.domId(ID_WEST)).val(MapUtils.formatLocationValue(b.left));
                $("#" + this.domId(ID_SOUTH)).val(MapUtils.formatLocationValue(b.bottom));
                $("#" + this.domId(ID_EAST)).val(MapUtils.formatLocationValue(b.right));
            }
        },
        linkArea: false,
        lastBounds: null,
        handleEventMapBoundsChanged: function(source, args) {
            bounds = args.bounds;
            this.lastBounds = bounds;
            if (!args.force && !this.linkArea) return;
            $("#" + this.domId(ID_NORTH)).val(MapUtils.formatLocationValue(bounds.top));
            $("#" + this.domId(ID_WEST)).val(MapUtils.formatLocationValue(bounds.left));
            $("#" + this.domId(ID_SOUTH)).val(MapUtils.formatLocationValue(bounds.bottom));
            $("#" + this.domId(ID_EAST)).val(MapUtils.formatLocationValue(bounds.right));
        },
	getContains: function() {
	    return this.jq(ID_CONTAINS).is(':checked');
	},
        getValues: function(settings) {
	    return {
		north:this.jq(ID_NORTH).val(),
		west:this.jq(ID_WEST).val(),		
		south:this.jq(ID_SOUTH).val(),
		east:this.jq(ID_EAST).val(),
	    }
	},
        setSearchSettings: function(settings) {
	    let n = this.display.getFieldValue(this.domId(ID_NORTH), null);
	    let w = this.display.getFieldValue(this.domId(ID_WEST), null);	    
	    let s = this.display.getFieldValue(this.domId(ID_SOUTH), null);
	    let e = this.display.getFieldValue(this.domId(ID_EAST), null);
            settings.setAreaContains(this.areaContains);
            settings.setBounds(n,w,s,e);
	    let now = new Date();
	    let okToAddToUrl = now.getTime()-this.createTime.getTime()>5000;
	    if(okToAddToUrl) 
		HU.addToDocumentUrl("map_contains",this.areaContains);
	    if(Utils.stringDefined(n,w,s,e)) {
		if(okToAddToUrl) 
		    HU.addToDocumentUrl("map_bounds",[n||"",w||"",s||"",e||""].join(","));
	    } else {
		HU.removeFromDocumentUrl("map_bounds");
	    }
        },
    });
}



function DateRangeWidget(display, what) {
    const ID_DATE_START = "date_start";
    const ID_DATE_END = "date_end";
    let startLabel, endLabel;
    this.what = what||"date";
    if(what == "createdate") {
	startLabel = "Create start";
	endLabel = "Create end";	
    } else {
	startLabel = "Start date";
	endLabel = "End date";	
    }

    this.baseId = this.what;
    RamaddaUtil.inherit(this, {
        display: display,
        initHtml: function() {
	    let args= HtmlUtils.makeClearDatePickerArgs({dateFormat: "yy-mm-dd",changeMonth:true,changeYear:true});
            $("#" + this.baseId +ID_DATE_START).datepicker(args);
            $("#" + this.baseId +ID_DATE_END).datepicker(args);
        },
        setSearchSettings: function(settings) {
            let start = $("#"+ this.baseId +ID_DATE_START).val();
            let end =  $("#"+ this.baseId +ID_DATE_END).val();
	    HU.addToDocumentUrl(this.baseId+ID_DATE_START,Utils.stringDefined(start)?start:null);
	    HU.addToDocumentUrl(this.baseId+ID_DATE_END,Utils.stringDefined(end)?end:null);		    	    
	    if(this.what=="createdate")
		settings.setCreateDateRange(start, end);
	    else
		settings.setDateRange(start, end);
        },
        getHtml: function() {
	    let start = HU.getUrlArgument(this.baseId+ID_DATE_START);
	    let end = HU.getUrlArgument(this.baseId+ID_DATE_END);	    
            let html = HtmlUtils.input(this.baseId +ID_DATE_START, start||"", [CLASS, "display-date-input", "placeholder", " " +startLabel, TITLE, startLabel, ATTR_ID,
									this.baseId +ID_DATE_START, 
							  ]) + " - " +
                HtmlUtils.input(this.baseId +ID_DATE_END, end||"", [CLASS, "display-date-input", "placeholder",  " " +endLabel, TITLE,endLabel,ATTR_ID,
							       this.baseId +ID_DATE_END, 
						 ]);
            return html;
        }
    });
}



function drawSparkline(display, dom,w,h,data, records,min,max,colorBy,params) {
    if(w<0 || h<0) {
	return;
    }

    let opts = {
	theMargin:{ top: 0, right: 0, bottom: 0, left: 0 },
	flipYAxis:false,
	drawAxis:true,
	drawAxisLabels:false,	
	axisWidth:1,
	axisColor:'#ccc',
    }
    if(params) {
	if(params.margin) $.extend(opts.theMargin,params.margin);
	$.extend(opts,params);
    }
    const INNER_WIDTH  = w - opts.theMargin.left - opts.theMargin.right;
    const INNER_HEIGHT = h - opts.theMargin.top - opts.theMargin.bottom;
    const BAR_WIDTH  = w / data.length;
    const x    = d3.scaleLinear().domain([0, data.length]).range([0, INNER_WIDTH]);
    let y = !opts.flipYAxis?
	d3.scaleLinear().domain([min, max]).range([INNER_HEIGHT, 0]):
	d3.scaleLinear().domain([max, min]).range([INNER_HEIGHT, 0]);    
    const recty    = d3.scaleLinear().domain([min, max]).range([0,INNER_HEIGHT]);

    let tt = d3.select("body").append("div")	
	.attr(CLASS, "sparkline-tooltip")				
	.style("opacity", 0);

    const svg = d3.select(dom).append('svg')
	  .attr('width', w)
	  .attr('height', h)
	  .append('g')
	  .attr('transform', 'translate(' + opts.theMargin.left + ',' + opts.theMargin.top + ')');
    const line = d3.line()
	  .x((d, i) => x(i))
	  .y(d => y(d));

    let lineColor = opts.lineColor||display.getSparklineLineColor();
    let barColor = opts.barColor ||display.getSparklineBarColor();
    let circleColor = opts.circleColor ||display.getSparklineCircleColor();
    let circleRadius = opts.circleRadius ||display.getSparklineCircleRadius();
    let lineWidth = opts.lineWidth ||display.getSparklineLineWidth();
    let defaultShowEndPoints = false;
    let getColor = (d,i,dflt)=>{
	return colorBy?colorBy.getColorFromRecord(records[i], dflt):dflt;
    };
    let showBars = opts.showBars|| display.getSparklineShowBars();
    if(opts.drawAxisLabels) {
	let minLabel= opts.flipYAxis?Utils.formatNumber(max):Utils.formatNumber(min);	
	let maxLabel = opts.flipYAxis?Utils.formatNumber(min):Utils.formatNumber(max);	
	svg.append('text')
	    .attr("x", 5) 
	    .attr("y", h-5) 
	    .attr("text-anchor", "left") 
	    .attr('font-size','8pt')
	    .text(minLabel);
	svg.append('text')
	    .attr("x", 5) 
	    .attr("y", 0+10) 
	    .attr("text-anchor", "left") 
	    .attr('font-size','8pt')
	    .text(maxLabel);	
    }

    if(opts.drawAxis) {
	svg.append('line')
	    .attr('x1',0)
	    .attr('y1', 0)
	    .attr('x2', 0)
	    .attr('y2', h)    
	    .attr("stroke-width", opts.axisWidth)
    	    .attr("stroke", opts.axisColor);

	svg.append('line')
	    .attr('x1',0)
	    .attr('y1', h)
	    .attr('x2', w)
	    .attr('y2', h)    
	    .attr("stroke-width", opts.axisWidth)
    	    .attr("stroke", opts.axisColor);
    }
    


    let getNum = n=>{
	if(isNaN(n)) return 0;
	return n;
    };

    if(showBars) {
	defaultShowEndPoints = false;
	svg.selectAll('.bar').data(data)
	    .enter()
	    .append('rect')
	    .attr(ATTR_CLASS, 'bar')
	    .attr('x', (d, i) => getNum(x(i)))
	    .attr('y', d => getNum(y(d)))
	    .attr('width', BAR_WIDTH)
	    .attr('height', d => getNum(h-y(d)))
	    .attr('fill', (d,i)=>getColor(d,i,barColor))
	    .style("cursor", "pointer")
    }


    if(opts.showLines|| display.getSparklineShowLines()) {
	svg.selectAll('line').data(data).enter().append("line")
	    .attr('x1', (d,i)=>{return x(i)})
	    .attr('y1', (d,i)=>{return y(d)})
	    .attr('x2', (d,i)=>{return x(i+1)})
	    .attr('y2', (d,i)=>{return y(i<data.length-1?data[i+1]:data[i])})
	    .attr("stroke-width", lineWidth)
            .attr("stroke", (d,i)=>{
		if(isNaN(d)) return "rgba(0,0,0,0)";
		return getColor(d,i,lineColor)
	    })
	    .style("cursor", "pointer");
    }


    if(opts.showCircles || display.getSparklineShowCircles()) {
	svg.selectAll('circle').data(data).enter().append("circle")
	    .attr('r', (d,i)=>{return isNaN(d)?0:circleRadius})
	    .attr('cx', (d,i)=>{return getNum(x(i))})
	    .attr('cy', (d,i)=>{return getNum(y(d))})
	    .attr('fill', (d,i)=>getColor(d,i,circleColor))
	    .style("cursor", "pointer");
    }



    if(opts.showEndpoints || display.getSparklineShowEndPoints(defaultShowEndPoints)) {
	let fidx=0;
	while(isNaN(data[fidx]) && fidx<data.length) fidx++;
	let lidx=data.length-1;
	while(isNaN(data[lidx]) && lidx>=0) lidx--;	
	svg.append('circle')
	    .attr('r', opts.endPointRadius|| display.getSparklineEndPointRadius())
	    .attr('cx', x(fidx))
	    .attr('cy', y(data[fidx]))
	    .attr('fill', opts.endPoint1Color || display.getSparklineEndPoint1Color() || getColor(data[0],0,display.getSparklineEndPoint1Color()));
	svg.append('circle')
	    .attr('r', opts.endPointRadius|| display.getSparklineEndPointRadius())
	    .attr('cx', x(lidx))
	    .attr('cy', y(data[lidx]))
	    .attr('fill', opts.endPoint2Color || display.getSparklineEndPoint2Color()|| getColor(data[data.length-1],data.length-1,display.getSparklineEndPoint2Color()));
    }
    let _display = display;
    let doTooltip = display.getSparklineDoTooltip()  || opts.doTooltip;
    svg.on("click", function(event) {
	let coords = d3.pointer(event);
	if(records) {
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(record)
		_display.propagateEventRecordSelection({select:true,record: record});
	}
    });



    if(doTooltip) {
	svg.on("mouseover", function(event) {
	    if(!records) return;
	    let coords = d3.pointer(event);
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(!record) return;
	    let html = _display.getRecordHtml(record);
	    let ele = $(dom);
	    let offset = ele.offset().top + ele.height();
	    let left = ele.offset().left;
	    tt.transition().duration(200).style("opacity", .9);		
	    tt.html(html)
		.style("left", left + "px")		
		.style("top", offset + "px");	
	})
	    .on("mouseout", function(d) {		
		tt.transition()		
		    .duration(500)		
		    .style("opacity", 0);
	    });
    }
}



function drawDots(display, dom,w,h,data, range, colorBy,attrs, margin) {
    attrs = attrs ||  {};
    margin = margin || { top: 0, right: 0, bottom: 0, left: 0 };
    const INNER_WIDTH  = w - margin.left - margin.right;
    const INNER_HEIGHT = h - margin.top - margin.bottom;
    const x    = d3.scaleLinear().domain([range.minx, range.maxx]).range([0, INNER_WIDTH]);
    const y    = d3.scaleLinear().domain([range.miny, range.maxy]).range([INNER_HEIGHT, 0]);
    let tt = d3.select("body").append("div").attr(CLASS, "sparkline-tooltip").style("opacity", 0);
    const svg = d3.select(dom).append('svg')
	  .attr('width', w)
	  .attr('height', h)
	  .append('g')
//	  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    let circleColor = attrs.circleColor ||display.getProperty("sparklineCircleColor","#000");
    let circleRadius = attrs.circleRadius ||display.getProperty("sparklineCircleRadius",1);
    let getColor = (d,i,dflt)=>{
	return "#000"
//	return colorBy?colorBy.getColorFromRecord(records[i], dflt):dflt;
    };
    console.log(JSON.stringify(range));

    let getNum = n=>{
	if(isNaN(n)) return 0;
	return n;
    };

    
    let recordMap = {};
    
    svg.selectAll('circle').data(data).enter().append("circle")
	.attr('r', (d,i)=>{return circleRadius})
	.attr('cx', (d,i)=>{return getNum(x(d.x))})
	.attr('cy', (d,i)=>{return getNum(y(d.y))})
	.attr('fill', (d,i)=>{return getColor(d,i,circleColor)})
	.attr(RECORD_ID, (d,i)=>{
	    recordMap[d.record.getId()] =d.record;
	    return d.record.getId()})
	.style("cursor", "pointer");

    let _display = display;
    let doTooltip = display.getProperty("sparklineDoTooltip", true)  || attrs.doTooltip;
    svg.on("click", function(event) {
	let coords = d3.pointer(event);
	if(records) {
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(record)
		_display.propagateEventRecordSelection({select:true,record: record});
	}
    });


    if(doTooltip) {
	svg.on("mouseover", function(event) {
	    d3.select(this).attr("r", 10).style("fill", "red");
	    let ele = $(dom);
	    ele.attr('r', 20);
	    if(true) return
	    let record = recordMap[ele.attr(RECORD_ID)];
	    console.log(ele.attr(RECORD_ID) +" " + record);
	    let coords = d3.pointer(event);
	    if(!record) return;
	    let html = _display.getRecordHtml(record);
	    let offset = ele.offset().top + ele.height();
	    let left = ele.offset().left;
	    tt.transition().duration(200).style("opacity", .9);		
	    tt.html(html)
		.style("left", left + "px")		
		.style("top", offset + "px");	
	})
	    .on("mouseout", function(d) {		
		tt.transition()		
		    .duration(500)		
		    .style("opacity", 0);
	    });
    }
}




function drawPieChart(display, dom,width,height,array,min,max,colorBy,attrs) {
    if(!attrs) attrs = {};
    let margin = Utils.isDefined(attrs.margin)?attrs.margin:4;
    let colors = attrs.pieColors||Utils.ColorTables.cats.colors;
    let colorMap = attrs.colorMap;
    if(!colorMap) {
	colorMap  = {};
	array.forEach((tuple,idx)=>{
	    let key = tuple[0];
	    colorMap[key] = colors[idx%colors.length];
	})
    }

    let radius = Math.min(width, height) / 2 - margin
    let svg = d3.select(dom)
	.append("svg")
	.attr("width", width)
	.attr("height", height)
	.append("g")
	.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    let data = {};
    array.forEach(tuple=>{
	data[tuple[0]] = tuple[1];
    })


    // Compute the position of each group on the pie:
    let pie = d3.pie().value(function(d) {return d.value; })
    let data_ready = pie(Utils.makeKeyValueList(data));

    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svg
	.selectAll('whatever')
	.data(data_ready)
	.enter()
	.append('path')
	.attr('d', d3.arc()
	      .innerRadius(0)
	      .outerRadius(radius)
	     )
	.attr('fill', function(d){
	    return colorMap[d.data.key];
	})
	.attr("stroke", "black")
	.style("stroke-width", "1px")
	.style("opacity", 0.7)
}



function Annotations(display,records) {
    this.display = display;
    if(!records) records = this.display.filterData();
    let pointData = this.display.getPointData();
    let fields = pointData.getRecordFields();
    this.labelField = this.display.getFieldById(null,this.display.getProperty("annotationLabelField"));
    this.fields = this.display.getFieldsByIds(null,this.display.getProperty("annotationFields"));
    let prop = this.display.getProperty("annotations");
    if(prop) this.fields = [];
    this.map = {}
    let add = (record,index,annotation)=>{
	console.log(record.getDate());
	annotation.record = record;
	if(!this.map[index])
	    this.map[index] = [];
	this.map[index].push(annotation);
	if(!this.map[record.getId()])
	    this.map[record.getId()] = [];
	this.map[record.getId()].push(annotation);	
    }
    if(!prop) return;
    this.annotations=[];
    this.legend = "";
    let labelCnt = 0;
    let toks = prop.split(";");
    this.hasRange = false;
    for(let i=0;i<toks.length;i++) {
	let toks2 = toks[i].split(",");
	//index,label,description,url
	if(toks2.length<2) continue;
	let index = toks2[0].trim();
	let label = toks2[1];
	if(label.trim() == "") {
	    labelCnt++;
	    label  =""+labelCnt;
	}
	let desc = toks2.length<2?"":toks2[2];
	let url = toks2.length<3?null:toks2[3];
	let isDate = false;
	let annotation = {label: label,description: desc,toString:function() {return this.label+" " + this.description;}   };
	this.annotations.push(annotation);
	if(index.match(/^#[0-9]+$/)) {
	    index = parseFloat(index);
	} else {
	    let index2 = null;
	    if(index.indexOf(":")>=0) {
		index2 = index.split(":")[1];
		index = index.split(":")[0];
	    }
	    let desc2=null;
	    if(index=="today") {
		index = new Date();
	    } else {
		index = Utils.parseDate(index,false);
	    }
	    if(index2) {
		this.hasRange = true;
 		if(index2=="today") {
		    index2 = Utils.formatDateYYYYMMDD(new Date());
		} else {
		    index2 = Utils.parseDate(index2,false);
		}
		desc  = desc||(this.display.formatDate(index)+"-"+ this.display.formatDate(index2));
		annotation.index2 = index2.getTime();
	    } else {
		desc  = desc||this.display.formatDate(index)
	    }
	    isDate = true;
	}
	annotation.index = isDate?index.getTime():index;
	let legendLabel = desc;

	if(url!=null) {
	    legendLabel = HU.href(url, legendLabel,["target","_annotation"]);
	}
	this.legend+= HU.b(label)+":" + legendLabel+" ";
    }
    for(let aidx=0;aidx<this.annotations.length;aidx++) {
	let annotation = this.annotations[aidx];
	let minIndex = null;
	let minRecord = null;
	let minDistance = null;
	for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
	    let ele = records[rowIdx];
	    let record = ele.record?ele.record:ele;
	    let row = this.display.getDataValues(records[rowIdx]);
	    let index = row[0];
	    if(index.v) index=  index.v;
	    if(record) index = record.getTime();
	    let distance =  Number.MAX_VALUE;
	    if(annotation.index2) {
		//range
 		if(index>=annotation.index && index<=annotation.index2) {
		    distance = 0;
		} else {
		    distance = Math.min(Math.abs(annotation.index-index),Math.abs(annotation.index2-index));
		}
		if(distance==0) {
		    add(record,rowIdx,annotation);
		}
	    } else {
		distance = Math.abs(annotation.index-index);
	    }
	    if(minIndex == null) {
		minIndex = rowIdx;
		minDistance = distance;
		minRecord = record;
	    } else {
		if(distance<minDistance) {
		    minIndex = rowIdx;
		    minDistance = distance;
		    minRecord = record;
		}
	    }
	}
	if(minIndex!=null) {
	    add(minRecord,minIndex,annotation);

	}
    }
}

Annotations.prototype = {
    isEnabled: function() {
	return this.annotations!=null;
    },
    getAnnotations: function() {
	return this.annotations;
    },

    getAnnotationsFor: function(rowIdx) {
	return this.map[rowIdx];
    },
    getAnnotationFromDate: function(date) {
	let distance =  Number.MAX_VALUE;
	let minAnnotation = null;
	let minDistance = null;
	let time = date.getTime();
	for(let aidx=0;aidx<this.annotations.length;aidx++) {
	    let annotation = this.annotations[aidx];
	    if(annotation.index2) {
 		if(time>=annotation.index && time<=annotation.index2) {
		    return annotation;
		}
	    } else {
		distance = Math.abs(annotation.index-time);
		if(minAnnotation == null) {
		    minAnnotation = annotation;
		    minDistance = distance;
		} else {
		    if(distance<minDistance) {
			minAnnotation = annotation;
			minDistance = distance;
		    }
		}
	    }
	}
	return minAnnotation;
    },
    getLegend: function() {
	return this.legend;
    },
    getShowLegend: function() {
	return 	this.display.getProperty("showAnnotationsLegend");
    },
    hasFields: function() {
	return this.fields && this.fields.length>0;
    },
    getFields: function() {
	return this.fields;
    }
    

}



let Gfx = {
    gridData: function(gridId,fields, records,args) {
	

	if(!args) args = {};
	if(isNaN(args.cellSize) || args.cellSize == null)
	    args.cellSize = args.cellSizeX;
	if(isNaN(args.cellSizeX) || args.cellSizeX == null)
	    args.cellSizeX= args.cellSize;
	if(isNaN(args.cellSizeY) || args.cellSizeY == null)
	    args.cellSizeY= args.cellSizeX;
	let opts = {
	    shape:"rect",
	    color:"blue",
	    w:800,
	    h:400,
	    scale:1,
	    cellSize:2,
	    cellSizeX:2,
	    cellSizeY:2,
	    operator:"average"
	}
	$.extend(opts,args);
//	opts.cellSizeX=2;	opts.cellSizeY=2;	opts.cellSize=2;
	let id = HtmlUtils.getUniqueId();
	opts.scale=+opts.scale;
	let scale = opts.scale;
//	scale=1;
	opts.w*=opts.scale;
	opts.h*=opts.scale;
	$(document.body).append('<canvas style="display:none;" id="' + id +'" width="' + opts.w+'" height="' + opts.h +'"></canvas>');
	let canvas = document.getElementById(id);
	let ctx = canvas.getContext("2d");
	//	ctx.strokeStyle= "#000";
//	ctx.fillStyle= "rgba(255,0,0,0.25)";	
//	ctx.fillRect(0,0,canvas.width,canvas.height);

	let cnt = 0;
	let earthWidth = args.bounds.east-args.bounds.west;
	let earthHeight= args.bounds.north-args.bounds.south;
	ctx.font = opts.cellFont || "8pt Arial;"
	let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
	gradient.addColorStop(0,'white');
	gradient.addColorStop(1,'red');

	let scaleX = (lat,lon)=>{
	    return Math.floor(opts.w*(lon-args.bounds.west)/earthWidth);
	};
	let scaleY;
	if(opts.display && opts.display.map) {
	    //Get the global bounds so we can map down to the image
	    let n1 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,85));
	    let s1 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,-85));
	    let n2 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,opts.bounds.north));
	    let s2 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,opts.bounds.south));
//	    console.log("n1:" + n1 +" s2:" + s1 +" n2:" + n2 +" s2:" + s2 +" bounds:" + JSON.stringify(opts.bounds));
	    scaleY = (lat,lon)=> {
		let pt = opts.display.map.transformLLPoint(MapUtils.createLonLat(lon,lat));
		let dy = n2.lat-pt.lat;
		let perc = dy/(n2.lat-s2.lat)
		return Math.floor(perc*opts.h);
	    };
	} else {
	    scaleY= (lat,lon)=> {
		return Math.floor(opts.h*(args.bounds.north-lat)/earthHeight);		
	    }
	}
	ctx.lineStyle = "#000";
	if(opts.doHeatmap) {
	    let cols = Math.floor(opts.w/opts.cellSizeX);
	    let rows = Math.floor(opts.h/opts.cellSizeY);
	    let points = [];
	    records.forEach((record,idx)=>{
		let lat = record.getLatitude();
		let lon = record.getLongitude();
		let x = scaleX(lat,lon);
		let y = scaleY(lat,lon);
//		console.log("x:" + x +" " + y +" lat:" + lat +" " + lon);
		record[gridId+"_coordinates"] = {x:x,y:y};
		let colorValue = 0;
		if(opts.colorBy && opts.colorBy.index>=0) {
		    colorValue = record.getValue(opts.colorBy.index);
		}
		let lengthValue = 0;
		if(opts.lengthBy && opts.lengthBy.index>=0) {
		    lengthValue = record.getValue(opts.lengthBy.index);
		}		
		x =Math.floor(x/opts.cellSizeX);
		y =Math.floor(y/opts.cellSizeY);
		if(x<0) x=0;
		if(y<0) y=0;
		if(x>=cols) x=cols-1;
		if(y>=rows) y=rows-1;
		points.push({x:x,y:y,colorValue:colorValue,r:record});
//		console.log(x+" " + y +" " + colorValue);
	    });


	    let grid = Gfx.gridPoints(rows,cols,points,args);
	    opts.cellSizeX = +opts.cellSizeX;
	    opts.cellSizeY = +opts.cellSizeY;
	    this.applyFilter(opts,grid);
	    //get the new min/max from the filtered grid
	    let mm = this.getMinMaxGrid(grid,v=>v.v);
	    if(opts.colorBy) {
		if(!Utils.isDefined(opts.display.getProperty("colorByMin")))  {
		    opts.colorBy.setRange(mm.min,mm.max);
		}  
		opts.colorBy.index=0;
	    }

	    let countThreshold = opts.display.getProperty("hmCountThreshold",opts.operator=="count"?1:0);
	    let glyph = new Glyph(opts.display,
				  scale,
				  fields,
				  records,
				  {type:opts.shape,
				   canvasWidth:canvas.width,
				   canvasHeight: canvas.height,
				   colorByInfo:opts.colorBy,
				   width: opts.cellSizeX,
				   height: opts.cellSizeY,
				   stroke:false,
				   pos:"c",
				   dx:opts.cellSizeX/2,
				   dy:opts.cellSizeY/2,				   
				  },
				  "");
	    for(let rowIdx=0;rowIdx<rows;rowIdx++)  {
		let row = grid[rowIdx];
		for(let colIdx=0;colIdx<cols;colIdx++)  {
		    let cell = row[colIdx];
		    let v = cell.v;
		    if(isNaN(v)) continue;
		    let x = colIdx*opts.cellSizeX;
		    let y = rowIdx*opts.cellSizeY;
		    if(cell.count>=countThreshold)
			glyph.draw(opts, canvas, ctx, x,y,{
			    colorValue:cell.v,
			    col:colIdx,row:rowIdx,cell:cell, grid:grid});
		}
	    }
	} else {
	    records.sort((a,b)=>{return b.getLatitude()-a.getLatitude()});
	    let glyphs=[];
	    let cnt = 1;
	    while(cnt<11) {
		let attr = opts.display.getProperty("glyph" + (cnt++));
		if(!attr)
		    continue;
		glyphs.push(new Glyph(opts.display,scale, fields,records,{
		    canvasWidth:canvas.width,
		    canvasHeight: canvas.height
		},attr));
	    }
	    glyphs.forEach(glyph=>{
		records.forEach((record,idx)=>{
		    let lat = record.getLatitude();
		    let lon = record.getLongitude();
		    let x = scaleX(lat,lon);
		    let y = scaleY(lat,lon);
		    record[gridId+"_coordinates"] = {x:x,y:y};
		    let colorValue = opts.colorBy? record.getData()[opts.colorBy.index]:null;
		    let lengthValue = opts.lengthBy? record.getData()[opts.lengthBy.index]:null;
		    glyph.draw(opts, canvas, ctx, x,y,{colorValue:colorValue, lengthValue:lengthValue,record:record},idx<10);
		});
	    });
	}

	let alpha = opts.display.getProperty("colorTableAlpha",-1);
	//add in the color table alpha
	if(alpha>0) {
	    let image = ctx.getImageData(0, 0, opts.w, opts.h);
	    let imageData = image.data,
		length = imageData.length;
	    for(let i=3; i < length; i+=4){  
		if(imageData[i]) {
		    imageData[i] = alpha*255;
		}
	    }
	    image.data = imageData;
	    ctx.putImageData(image, 0, 0);
	}

	let img =  canvas.toDataURL("image/png");
	canvas.parentNode.removeChild(canvas);
	return img;
    },
    gridPoints: function(rows,cols,points,args) {
	let debug = displayDebug.gridPoints;
	let values = [];
	for(let rowIdx=0;rowIdx<rows;rowIdx++)  {
	    let row = [];
	    values.push(row);
	    for(let colIdx=0;colIdx<cols;colIdx++)  {
		row.push({v:NaN,count:0,total:0,min:NaN,max:NaN,t:""});
	    }
	}

	points.forEach((p,idx)=>{
	    let cell = values[p.y][p.x];
	    cell.min = cell.count==0?p.colorValue:Math.min(cell.min,p.colorValue);
	    cell.max = cell.count==0?p.colorValue:Math.max(cell.max,p.colorValue);
	    cell.count++;
	    cell.total += p.colorValue;
	});


	let minValue = NaN;
	let maxValue = NaN;
	let maxCount=0;
	let minCount=0;

	for(let rowIdx=0;rowIdx<rows;rowIdx++)  {
	    for(let colIdx=0;colIdx<cols;colIdx++)  {
		let cell = values[rowIdx][colIdx];
		if(cell.count==0) continue;
		let v;
		if(args.operator=="count")
		    v = cell.count;
		else if(args.operator=="min")
		    v =  cell.min;
		else if(args.operator=="max")
		    v =  cell.max;
		else if(args.operator=="total")
		    v =  cell.total;
		else
		    v =  cell.total/cell.count;
		cell.v = v;
		if(!isNaN(v)) {
		    minValue = isNaN(minValue)?v:Math.min(minValue,v);
		    maxValue = isNaN(maxValue)?v:Math.max(maxValue,v);
		}
		maxCount = Math.max(maxCount, cell.count);
		minCount = minCount==0?cell.count:Math.min(minCount, cell.count);
	    }
	}	
	if(debug)
	    console.log("operator:" + args.operator +" values:" + minValue +" - " + maxValue +" counts:" + minCount +" - " + maxCount);
	values.minValue = minValue;
	values.maxValue = maxValue;
	values.minCount = minCount;
	values.maxCount = maxCount;
	return values;
    },


    
    //This gets the value at row/col if its defined. else 0
    //    sum+=this.getGridValue(src,rowIdx,colIdx,t[0],t[1],t[2],cnt); 
    getGridValue:function(src,row,col,mult,total,goodones) {
	if(row>=0 && row<src.length && col>=0 && col<src[row].length) {
	    if(isNaN(src[row][col])) return 0;
	    total[0]+=mult;
	    goodones[0]++;
	    return src[row][col]*mult;
	}
	return 0;
    },
    applyKernel: function(src, kernel) {
	let result = this.cloneGrid(src,null,0);
	for(let rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = result[rowIdx];
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		//		if(isNaN(row[colIdx])) continue;
		if(isNaN(row[colIdx])) row[colIdx] = 0;
		let total =[0];
		let goodones =[0];
		let sum = 0;
		kernel.every(t=>{
		    sum+=this.getGridValue(src,rowIdx+t[0],colIdx+t[1],t[2],total,goodones); 
		    return true;
		});
		if(goodones[0]>0)
		    row[colIdx] = sum/total[0];
		else
		    row[colIdx] = NaN;
	    }
	}
	return result;
    },
    blurGrid: function(type, src) {
	let kernels = {
	    average5: [
		[0,1,0],
		[1,1,1],
		[0,1,0],
	    ],
	    average9: [
		[1,1,1],
		[1,1,1],
		[1,1,1],
	    ],
	    average25:[
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
	    ],
	    average49:[
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
	    ],
	    gauss9:[
		[0.077847,0.123317,0.077847],
		[0.123317,0.195346,0.123317],
		[0.077847,0.123317,0.077847]
	    ],
	    gauss25:[
		[0.003765,0.015019,0.023792,0.015019,0.003765],
		[0.015019,0.059912,0.094907,0.059912,0.015019],
		[0.023792,0.094907,0.150342,0.094907,0.023792],
		[0.015019,0.059912,0.094907,0.059912,0.015019],
		[0.003765,0.015019,0.023792,0.015019,0.003765],
	    ],
	    gauss49: [
		[0.00000067 ,0.00002292 ,0.00019117 ,0.00038771 ,0.00019117 ,0.00002292 ,0.00000067],
		[0.00002292 ,0.00078633 ,0.00655965 ,0.01330373 ,0.00655965 ,0.00078633 ,0.00002292],
		[0.00019117 ,0.00655965 ,0.05472157 ,0.11098164 ,0.05472157 ,0.00655965 ,0.00019117],
		[0.00038771 ,0.01330373 ,0.11098164 ,0.22508352 ,0.11098164 ,0.01330373 ,0.00038771],
		[0.00019117 ,0.00655965 ,0.05472157 ,0.11098164 ,0.05472157 ,0.00655965 ,0.00019117],
		[0.00002292 ,0.00078633 ,0.00655965 ,0.01330373 ,0.00655965 ,0.00078633 ,0.00002292],
		[0.00000067 ,0.00002292 ,0.00019117 ,0.00038771 ,0.00019117 ,0.00002292 ,0.00000067]
	    ]
	}
	let a = kernels[type];
	if(!a) {
	    if(type.startsWith("average"))
		a=kernels.average5;
	    else if(type.startsWith("gauss"))
		a=kernels.gauss9;
	}
	if(!a) return src;
	return this.applyKernel(src, this.makeKernel(a));
    },
    makeKernel: function(kernel) {
	let a = [];
	let mid = (kernel.length-1)/2;
	for(let rowIdx=0;rowIdx<kernel.length;rowIdx++) {
	    let row = kernel[rowIdx];
	    let rowOffset = rowIdx-mid;
	    for(let colIdx=0;colIdx<row.length;colIdx++) {
		let colOffset = colIdx-mid;
		a.push([rowOffset,colOffset,kernel[rowIdx][colIdx]]);
	    }
	}
	return a;
    },
    printGrid: function(grid) {
	console.log("grid:");
	for(let rowIdx=0;rowIdx<grid.length;rowIdx++)  {
	    let row = grid[rowIdx];
	    let h = "";
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		if(Utils.isDefined(row[colIdx].v))
		    h+=row[colIdx].v+",";
		else
		    h+=row[colIdx]+",";
	    }
	    console.log(h);
	}
    },
    applyFilter(opts, grid) {
	if(!opts.filter || opts.filter=="" || opts.filter=="none") {
	    return;
	}

	let copy = this.cloneGrid(grid,v=>v.v);
	let filtered = copy;
	let filterPasses = opts.display.getProperty("hmFilterPasses",1);
	for(let i=0;i<filterPasses;i++) {
	    filtered = this.blurGrid(opts.filter,filtered);
	}
	let filterThreshold = opts.display.getProperty("hmFilterThreshold",-999);
	for(let rowIdx=0;rowIdx<grid.length;rowIdx++)  {
	    let row = grid[rowIdx];
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		let cell = row[colIdx];
		let filterValue = filtered[rowIdx][colIdx];
		if(filterThreshold!=-999) {
		    if(filterValue<filterThreshold)
			filterValue = cell.v;
		}
		cell.v = filterValue;
	    }
	}
    },
    getMinMaxGrid: function(src,valueGetter) {
	let min = NaN;
	let max = NaN;
	for(let rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = src[rowIdx];
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		let v = row[colIdx]
		if(valueGetter) v = valueGetter(v,rowIdx,colIdx);
		if(isNaN(v)) continue;
		min = isNaN(min)?v:Math.min(min,v);
		max = isNaN(max)?v:Math.max(max,v);
	    }
	}
	return {min:min,max:max};
    },



    cloneGrid: function(src,valueGetter,dflt) {
	let dest = [];
	let hasDflt = Utils.isDefined(dflt);
	for(let rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = src[rowIdx];
	    let nrow=[];
	    dest.push(nrow);
	    for(let colIdx=0;colIdx<row.length;colIdx++)  {
		let v = row[colIdx]
		if(valueGetter) v = valueGetter(v,rowIdx,colIdx);
		if(hasDflt)
		    nrow.push(dflt);
		else
		    nrow.push(v);
	    }
	}
	return dest;
    },
    convertGeoToPixel:function(lat, lon,bounds,mapWidth,mapHeight) {
	let mapLonLeft = bounds.west;
	let mapLonRight = bounds.east;
	let mapLonDelta = mapLonRight - mapLonLeft;
	let mapLatBottom = bounds.south;
	let mapLatBottomDegree = mapLatBottom * Math.PI / 180;
	let x = (lon - mapLonLeft) * (mapWidth / mapLonDelta);
	lat = lat * Math.PI / 180;
	let worldMapWidth = ((mapWidth / mapLonDelta) * 360) / (2 * Math.PI);
	let mapOffsetY = (worldMapWidth / 2 * Math.log((1 + Math.sin(mapLatBottomDegree)) / (1 - Math.sin(mapLatBottomDegree))));
	let y = mapHeight - ((worldMapWidth / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat)))) - mapOffsetY);
	return [x, y];
    },
}


/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/



function DisplayAnimation(display, enabled,attrs) {
    let dflt = {
    };
    attrs = attrs||{};
    $.extend(dflt,attrs);
    const ID_RUN = "animrun";
    const ID_ANIM_NEXT = "animnext";
    const ID_ANIM_PREV= "animprev";
    const ID_BEGIN= "animbegin";
    const ID_END= "animend";
    const ID_SLIDER = "slider";
    const ID_TICKS = "ticks";
    const ID_TOOLTIP = "tooltip";    
    const ID_SHOWALL = "showall";
    const ID_WINDOW = "window";
    const ID_STEP = "step";        
    const ID_SETTINGS = "settings";
    const ID_FASTER = "faster";
    const ID_SLOWER = "slower";
    const ID_RESET = "reset";    
    const ID_ANIMATION_LABEL = "animationlabel";
    const MODE_FRAME = "frame";
    const MODE_SLIDING = "sliding";
    $.extend(this,{
	display:display,
	enabled: enabled,
	targetDiv:attrs.targetDiv,
	baseDomId:attrs.baseDomId,
	labelSize:display.getProperty("animationLabelSize","12pt"),
	labelStyle:display.getProperty("animationLabelStyle",""),
	labelTemplate:display.getProperty("animationLabelTemplate"),
        running: false,
        inAnimation: false,
        begin: null,
        end: null,
        dateMin: null,
        dateMax: null,
        dateRange: 0,
        dateFormat: display.getProperty("animationDateFormat", display.getProperty("dateFormat", "yyyymmdd")),
        mode: display.getProperty("animationMode", "cumulative"),
        startAtBeginning: display.getProperty("animationStartAtBeginning", true),	
        startAtEnd: display.getProperty("animationStartAtEnd", false),
        useIndex: display.getProperty("animationUseIndex",false),
        speed: parseInt(display.getProperty("animationSpeed", 500)),
        dwell: parseInt(display.getProperty("animationDwell", 1000)),
	getEnabled: function() {
	    return this.enabled;
	},
        toggleAnimation: function() {
	    this.running = !this.running;
	    if(this.btnRun)
		this.btnRun.html(HtmlUtils.getIconImage(this.running ? "fa-stop" : "fa-play"));
	    if (this.running)
		this.startAnimation();
	},
        getDomId: function(id) {
	    return this.domId(id);
	},
        domId: function(id) {
	    return this.display.getDomId(id+(this.baseDomId?this.baseDomId:""));
	},
	jq: function(id) {
	    return this.display.jq(id+(this.baseDomId?this.baseDomId:""));
	},
	setBeginEnd: function(date) {
	    this.setBegin(date);
	    this.setEnd(date);	    
	},
	setBegin: function(date) {
	    this.begin = this.makeDate(date);
	},
	setEnd: function(date) {
	    this.end = this.makeDate(date);
	},
	makeIndex:function(idx) {
	    return {
		wrapper:true,
		isIndex:true,
		index:idx,
		getTime:function() {return this.value;},
		value:idx};
	},

	makeDate: function(date) {
	    if(!date) return null;
	    if(this.useIndex) {
		return this.makeIndex(Utils.isDefined(date.index)?date.index:date.getTime());
	    }

	    if(date.wrapper) date = date.date;
	    return {
		wrapper:true,
		date:date,
		value:date.getTime(),
		getTime:function() {return this.value;}
	    }
	},
	init: function(dateMin, dateMax, records) {
	    let debug = false;
	    if(debug)
		console.log("animation.init:" +dateMin +" " + dateMax +" " +(records?"#records:" + records.length: "no records") );
	    let _this = this;
	    this.records = records;
	    if(this.useIndex) {
		this.dateMin = this.makeIndex(0);
		this.dateMax = this.makeIndex(records.length-1);		
	    } else {
		this.dateMin = this.makeDate(dateMin);
		this.dateMax = this.makeDate(dateMax);
	    }
	    let beginDate = this.dateMin;
	    let endDate = this.dateMax;	    
	    this.setBegin(beginDate);
	    this.setEnd(endDate);
	    if(!this.dateMin) return;
	    this.dates=[];
	    let seen = {};
	    this.dateToRecordMap = {};
	    records.every((r,idx)=>{
		if(this.useIndex) {
		    this.dates.push(this.makeIndex(idx));
		    this.dateToRecordMap[idx] = r;
		    return true;
		}
		let date = r.getDate();
		if(!date) return;
		if(!seen[date]) {
		    seen[date] = true;
		    this.dates.push(this.makeDate(date));
		    this.dateToRecordMap[date] = r;
		}
		return true;
	    });
	    this.dates.sort(function(a,b) {
		return a.value - b.value;
	    });
	    	

            this.dateRange = this.dateMax.getTime() - this.dateMin.getTime();
	    this.steps= parseFloat(this.display.getProperty("animationSteps", 60));
	    this.setWindow();
	    this.frameIndex = 0;
	    if(!this.display.getProperty("animationStartShowAll",false)) { 
		this.resetRange();
	    }
	    let sliderValues = this.mode != MODE_FRAME?[this.begin.getTime(),this.end.getTime()]:[this.begin.getTime()];
	    let tooltipFunc = {
		    mouseleave: function(e) {
			if(_this.tooltip)
			    _this.tooltip.hide();
		    },
		    mousemove: function(e) {
			if(!_this.tooltip) return;
			if(e.offsetX>=0) {
			    let parentWidth = _this.tooltip.parent().width();
			    let parentLeft = _this.tooltip.parent().offset().left; 
			    let percent = (e.pageX-parentLeft)/parentWidth;
			    let dttm = new Date(_this.dateMin.getTime() + percent*_this.dateRange);
			    dttm = _this.formatAnimationDate(dttm,_this.tooltipDateFormat);
			    if(!_this.makeSlider) {
				dttm+="<br>+/-:zoom";
			    }
			    _this.tooltip.html(dttm);
			    _this.tooltip.show();
			    _this.tooltip.position({
				of: e.target,
				my: "left top",
				at: "left+" + e.offsetX +" bottom",
				collision: "fit fit"
			    });
			}
		    }};

	    if(this.makeSlider) {
		let slider = this.slider = this.jq(ID_SLIDER).slider({
		    range: _this.mode != MODE_FRAME,
		    min: _this.dateMin.getTime(),
		    max: _this.dateMax.getTime(),
		    values: sliderValues,
		    create: function() {
			_this.sliderHandleLeft = $(".ui-slider-handle:eq(0)");
			_this.sliderHandleRight = $(".ui-slider-handle:eq(1)");
			if(_this.sliderHandleLeft.length &&_this.sliderHandleRight.length) {
			    _this.sliderHandleLeft.attr(ATTR_TITLE,'Shift-drag to move both');
			    _this.sliderHandleRight.attr(ATTR_TITLE,'Shift-drag to move both');
			}
		    },
		    slide: function( event, ui ) {
			_this.stopAnimation();
			_this.checkSliderValues(event,ui);
			_this.setSliderValues(ui.values);
			_this.updateLabels();
		    },
		    stop: function(event,ui) {
			_this.checkSliderValues(event,ui);
			_this.stopAnimation();
			_this.setSliderValues(ui.values);
			_this.dateRangeChanged(true);
		    }
		});
		this.jq(ID_SLIDER).on(tooltipFunc);
	    } else {
		this.jq(ID_TICKS).on(tooltipFunc);
	    }
	    this.updateTicks();
	    if(debug)console.log("animation.init-3");
	    this.updateLabels();
	    if(debug)console.log("animation.init-done");
	},
	checkSliderValues:function(event,ui) {
	    if(event.shiftKey && this.lastSliderValues) {
		let left= this.sliderHandleLeft[0]==ui.handle;
		if(left) {
		    let delta=ui.values[0]-this.lastSliderValues[0];
		    ui.values[1]+=delta;
		} else {
		    let delta=ui.values[1]-this.lastSliderValues[1];
		    ui.values[0]+=delta;
		}
		this.slider.slider("values", ui.values);
	    }
	    this.lastSliderValues=ui.values;
	},
	resetRange: function() {
	    if(this.display.getProperty("animationInitRange")) {
		let toks = Utils.split(this.display.getProperty("animationInitRange"),",");
		let beginIdx = 0;
		let idx=0;
		if(toks[0].trim()=='begin')  idx=0;
		else  idx=+toks[0];
		if(idx<0) idx=this.records.length+idx;
		let record = this.records[idx];
		if(record)	this.setBegin(record.getTime());
		if(toks.length>1) {
		    if(toks[1].trim()=='end')  idx=this.records.length-1;
		    else idx=+toks[1];
		    record = this.records[idx];
		    if(record)   this.setEnd(record.getTime());
		}
		return
	    }



	    if(this.startAtEnd) {
		this.setBegin(this.dateMax);
		this.setEnd(this.dateMax);
		if (this.mode == MODE_FRAME) {
		    this.frameIndex = this.dates.length-1;
		}		    
	    } else   if(this.startAtBeginning) {
		this.setBegin(this.dateMin);
		this.setEnd(new Date(this.begin.getTime()+this.window));
	    }
	    if (this.mode == MODE_FRAME) {
		this.setEnd(this.begin);
	    }
	},
	setWindow: function() {
	    let window = this.display.getProperty("animationWindow");
	    let step = this.display.getProperty("animationStep", window);
	    if (window) {
		this.window = DataUtils.timeToMillis(window);
	    } else if(this.steps>0){
		if(this.useIndex) {
		    this.window = 1;
		} else {
		    this.window = this.dateRange / this.steps;
		}
	    }
	    if (step) {
		this.step = DataUtils.timeToMillis(step);
	    } else {
		this.step = this.window;
	    }
	},
	getIndex: function() {
	    return this.frameIndex;
	},
	getBeginTime: function() {
	    return this.begin;
	},
	handleEventAnimationChanged(args) {
	    this.setBegin(args.begin);
	    this.setEnd(args.end);
	    this.stopAnimation();
	    this.applyAnimation();
	},
	setSliderValues: function(v) {
	    let debug = false;
	    if(debug)
		console.log(this.display.type+" animation.setSliderValues");
	    if(this.mode != MODE_FRAME) {
		this.setBegin(new Date(v[0]));
		this.setEnd(new Date(v[1]));
	    } else {
		let sliderDate = new Date(v[0]);
		let closest = this.dates[0];
		let dist = 0;
		let closestIdx=0;
		this.dates.forEach((d,idx)=>{
		    if(Math.abs(d.value-sliderDate.getTime()) < Math.abs(closest.getTime()-sliderDate.getTime())) {
			closest = d;
			closestIdx = idx;
		    }
		});
		this.setBegin(closest);
		this.setEnd(closest);
		this.frameIndex = closestIdx;
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    let element = $("#" + this.display.getId()+"-"+args.record.getId());
	    if(this.ticks)
		this.ticks.removeClass("display-animation-tick-highlight");
	    if(args.highlight) {
		element.addClass("display-animation-tick-highlight");
	    } else {
		element.removeClass("display-animation-tick-highlight");
	    }
	},
	makeControls:function() {
	    this.tickHeight = this.display.getProperty("animationHeight","15px");
	    this.makeSlider = this.display.getProperty("animationMakeSlider",true);
            let buttons =  "";
	    let showButtons  = this.display.getProperty("animationShowButtons",true);
	    let showSlider = display.getProperty("animationShowSlider",true);
	    let showLabel = display.getProperty("animationShowLabel",true);	    
	    if(showButtons) {
		let short = display.getProperty("animationWidgetShort",false);
		buttons +=   HtmlUtils.span([ID, this.getDomId(ID_SETTINGS),TITLE,"Settings"], HtmlUtils.getIconImage("fas fa-cog")); 
		if(!short)
		    buttons +=   HtmlUtils.span([ID, this.getDomId(ID_BEGIN),TITLE,"Go to beginning"], HtmlUtils.getIconImage("fa-fast-backward")); 
		buttons += HtmlUtils.span([ID, this.getDomId(ID_ANIM_PREV), TITLE,"Previous"], HtmlUtils.getIconImage("fa-step-backward")); 
		if(!short)
		    buttons +=HtmlUtils.span([ID, this.getDomId(ID_RUN),  TITLE,"Run/Stop"], HtmlUtils.getIconImage("fa-play")); 
		buttons +=HtmlUtils.span([ID, this.getDomId(ID_ANIM_NEXT), TITLE,"Next"], HtmlUtils.getIconImage("fa-step-forward"));
		if(!short)
		    buttons +=HtmlUtils.span([ID, this.getDomId(ID_END), TITLE,"Go to end"], HtmlUtils.getIconImage("fa-fast-forward"));
	    }

	    if(showLabel) {
		if(showButtons) {
		    buttons+=HtmlUtils.span([ID, this.getDomId(ID_ANIMATION_LABEL), CLASS, "display-animation-label",STYLE,this.labelStyle+HU.css("font-size",this.labelSize)]);
		} else {
		    buttons+=HtmlUtils.div([ID, this.getDomId(ID_ANIMATION_LABEL), CLASS, "display-animation-label",STYLE,this.labelStyle+HU.css("text-align","center","font-size",this.labelSize)]);
		}
	    }
            buttons = HtmlUtils.div([ CLASS,"display-animation-buttons"], buttons);
	    if(showSlider) {
		let style= HU.css("height",this.tickHeight) +display.getProperty("animationSliderStyle","");
		let tooltip  = HU.div([ID,this.getDomId(ID_TOOLTIP),CLASS,"display-animation-tooltip"],"");
		let tickContainerStyle = HU.css("height",this.tickHeight);
		if(!this.makeSlider) {
		    tickContainerStyle += HU.css("background","efefef","border","1px solid #aaa");
		}
		if(!this.makeSlider) {
		    style+=HU.css("cursor","move");
		}
		buttons +=   HtmlUtils.div([CLASS,"display-animation-slider",STYLE,style,ID,this.getDomId(ID_SLIDER)],
					   tooltip + HtmlUtils.div([STYLE, tickContainerStyle,CLASS,"display-animation-ticks","tabindex","0",ID,this.getDomId(ID_TICKS)]));
	    }
	    this.html = HtmlUtils.div([STYLE,this.display.getProperty("animationStyle")], buttons);
	    if(this.display.getProperty("animationShow",true)) {
		if(this.targetDiv) this.targetDiv.append(this.html);
		else this.jq(ID_TOP_LEFT).append(this.html);
	    }
	    if(!this.makeSlider) {
		let _this = this;
		this.jq(ID_TICKS).mouseenter(function(event) {
		    $(this).focus();
		});
		this.lastKeyTime = 0;
		let ticks = this.jq(ID_TICKS);
		ticks.mousedown(function(e) {
		    _this.mouseIsDown = true;
		    let parentOffset = $(this).parent().offset(); 
		    _this.mouseX = e.pageX - parentOffset.left;
		});

		ticks.mousemove(function(e) {
		    if(!_this.mouseIsDown) return;
		    var parentOffset = $(this).parent().offset(); 
		    var relX = e.pageX - parentOffset.left;
		    let range = _this.dateMax.getTime() - _this.dateMin.getTime();
		    let width = $(this).width();
		    let dx = (_this.mouseX-relX);
		    var parentOffset = $(this).parent().offset(); 
		    _this.mouseX = e.pageX - parentOffset.left;
		    if(dx==0) return;
		    let dt = range*dx/width 
		    if(!_this.originaDateMin) {
			_this.originaDateMin = _this.dateMin;
			_this.originaDateMax = _this.dateMax;		
		    }
		    _this.dateMin = _this.makeDate(new Date(_this.dateMin.getTime()+dt));
		    _this.dateMax = _this.makeDate(new Date(_this.dateMax.getTime()+dt));			
		    _this.updateTicks();
		    _this.updateLabels();

		});
		ticks.mouseup(function(e) {
		    _this.mouseIsDown = false;
		});
		ticks.keypress(function(event) {
		    let now = new Date();
		    let diff = now.getTime()-_this.lastKeyTime;
		    _this.lastKeyTime = now.getTime();
		    if(event.which==43)
			_this.zoom(true);
		    else if(event.which==45)
			_this.zoom(false);		    
		    else if(event.which==61)
			_this.zoomReset();

		});

		this.jq(ID_TICKS).bind('xwheel', function(e){		    
		    $(this).focus();
		    if(e.originalEvent.deltaY<0) {
			let range = _this.dateMax.getTime() - _this.dateMin.getTime();
			let newRange = range*0.9;
			let diff = range-newRange;
			_this.dateMin = _this.makeDate(new Date(_this.dateMin.getTime()+diff));
			_this.dateMax = _this.makeDate(new Date(_this.dateMax.getTime()-diff));			
			_this.updateTicks();
			_this.updateLabels();
		    } else if(e.originalEvent.deltaY>0) {
			//zoom out 
		    } else {
		    }
		    e.stopPropagation();
		    e.stopImmediatePropagation();
		    e.preventDefault();
		});

	    }

	    if(this.display.getProperty("animationTooltipShow",false)) {
		this.tooltip = this.jq(ID_TOOLTIP);
		this.tooltipDateFormat = this.display.getProperty("animationTooltipDateFormat");
	    }


	    let _this  =this;
            this.jq(ID_SETTINGS).button().click(function(){
		let window = _this.display.getProperty("animationWindow");
		let step = _this.display.getProperty("animationStep", window);		
		let clazz = "ramadda-hoverable ramadda-clickable";
		let html = HU.div([ID,_this.domId(ID_FASTER),TITLE, "Faster", CLASS,clazz], "Faster") +	
	    HU.div([ID,_this.domId(ID_SLOWER),TITLE, "Slower", CLASS,clazz], "Slower")		+
		    HU.div([ID,_this.domId(ID_RESET),TITLE, "Reset", CLASS,clazz], "Reset") +
		    HU.div([ID,_this.domId(ID_SHOWALL),TITLE, "Show all", CLASS,clazz], "Show all");
		if(window) {
		    html+=HU.div([TITLE, "Window, e.g., 1 week, 2 months, 3 days, 2 weeks, etc"], "Window:<br>" +SPACE2 + HU.input("",window,[ID,_this.domId(ID_WINDOW),"size","10"]));
		    html+=HU.div([TITLE, "Step, e.g., 1 week, 2 months, 3 days, 2 weeks, etc"], "Step:<br>" +SPACE2+ HU.input("",step,[ID,_this.domId(ID_STEP),"size","10"]));
		}
		html=HU.div([STYLE,HU.css("margin","4px")], html);
		_this.dialog = HU.makeDialog({content:html,anchor:$(this),draggable:false,header:false});

		let key = (e)=>{
		    if(Utils.isReturnKey(e)) {
			_this.dialog.hide();
			_this.display.setProperty("animationWindow",_this.jq(ID_WINDOW).val());
			_this.display.setProperty("animationStep",_this.jq(ID_STEP).val());			
			_this.setWindow();
			_this.resetRange();
			_this.dateRangeChanged();
		    }
		};
		_this.jq(ID_WINDOW).keyup(key);
		_this.jq(ID_STEP).keyup(key);
		_this.jq(ID_FASTER).click(()=>{
		    _this.dialog.hide();
		    _this.speed = _this.speed*0.75;
		});
		_this.jq(ID_SLOWER).click(()=>{
		    _this.dialog.hide();
		    _this.speed = _this.speed*1.5;
		});

		_this.jq(ID_RESET).click(()=>{
		    _this.dialog.hide();
		    _this.speed =  parseInt(_this.display.getProperty("animationSpeed", 500));
		    _this.resetRange();
		    _this.inAnimation = false;
		    _this.stopAnimation();
		    _this.dateRangeChanged();
		});		
		_this.jq(ID_SHOWALL).click(()=>{
		    _this.dialog.hide();
		    _this.setBegin(_this.dateMin);
		    _this.setEnd(_this.dateMax);
		    _this.inAnimation = false;
		    _this.stopAnimation();
		    _this.dateRangeChanged();
		});		

	    });
            this.btnRun = this.jq(ID_RUN);
            this.btnPrev = this.jq(ID_ANIM_PREV);
            this.btnNext = this.jq(ID_ANIM_NEXT);
            this.btnBegin = this.jq(ID_BEGIN);
            this.btnEnd = this.jq(ID_END);
            this.label = this.jq(ID_ANIMATION_LABEL);
            this.btnRun.button().click(() => {
                this.toggleAnimation();
            });
            this.btnBegin.button().click(() => {
		let diff = this.getDiff();
		let fullRange = this.fullRange();
		this.setBegin(this.dateMin);
		if (this.mode == MODE_SLIDING) {
		    this.end = this.makeDate(new Date(this.begin.getTime()+(fullRange?this.window:diff)));
		} else if (this.mode == MODE_FRAME) {
		    this.frameIndex = 0;
		    let date = this.deltaFrame(0);
		    this.setBeginEnd(date);
		} else {
		    this.setEnd(new Date(this.dateMin.getTime()+this.window));
		}
		this.stopAnimation();
		this.dateRangeChanged();
            });
            this.btnEnd.button().click(() => {
		let diff = this.getDiff();
		let fullRange = this.fullRange();
		this.end = this.dateMax;
		if (this.mode == MODE_SLIDING) {
		    this.setBegin(new Date(this.end.getTime()-(fullRange?this.window:diff)));
		} else if (this.mode == MODE_FRAME) {
		    this.frameIndex = this.dates.length+1;
		    this.setBeginEnd(this.deltaFrame(0));
		} else {
		    this.setEnd(this.dateMax);
		}
		this.stopAnimation();
		this.dateRangeChanged();
            });
            this.btnPrev.button().click(() => {
		this.stopAnimation();
		this.doPrev();
            });
            this.btnNext.button().click(() => {
		this.stopAnimation();
		this.doNext();
            });

        },
	fullRange: function() {
	    return this.atBegin() && this.atEnd();
	},
	atEnd: function() {
	    return this.end.getTime()>=this.dateMax.getTime();
	},
	atBegin: function() {
	    return this.begin.getTime()<=this.dateMin.getTime();
	},	
	getDiff: function() {
	    return  this.end.getTime()-this.begin.getTime();
	},
	doPrev: function()  {
	    let diff = this.getDiff()||this.window;
	    diff = this.window||this.getDiff();
	    if (this.mode == MODE_SLIDING) {
		this.setBegin(new Date(this.begin.getTime()-diff));
		if(this.begin.getTime()<this.dateMin.getTime())
		    this.setBegin(this.dateMin);
		this.setEnd(new Date(this.begin.getTime()+diff));
	    } else if (this.mode == MODE_FRAME) {
		this.setBeginEnd(this.deltaFrame(-1));
	    } else {
		this.setEnd(new Date(this.end.getTime()-this.window));
		if(this.end.getTime()<=this.begin.getTime()) {
		    this.setEnd(new Date(this.begin.getTime()+this.window));
		}
	    }
	    this.dateRangeChanged();
	},
	doNext: function() {
	    let debug = false;
	    let wasAtEnd = this.atEnd();
//	    debug=true;
	    if(debug) console.log("animation.doNext:" + this.mode +" atEnd=" + wasAtEnd);

	    if (this.mode == MODE_SLIDING) {
		let window = this.window||this.getDiff();
		this.setBegin(new Date(this.begin.getTime()+this.step));
		this.setEnd(new Date(this.end.getTime()+this.step));
		//this.end.getTime()+this.window);		
		if(this.atEnd()) {
		    this.end = this.dateMax;
		    this.setBegin(new Date(this.end.getTime()-window));
		    this.inAnimation = false;
		    this.stopAnimation();
		}
	    } else if (this.mode == MODE_FRAME) {
		this.setBeginEnd(this.deltaFrame(1));
		if(this.running) {
		    if(wasAtEnd) {
			if(this.display.getProperty("animationLoop",true)) {
			    setTimeout(()=>{
				this.setBegin(this.dateMin);
				this.setEnd(this.dateMin);
				this.frameIndex=0;
				this.updateUI();
			    },this.dwell);
			    return;
			} else {
			    this.stopAnimation();
			}
		    }
		}
	    } else {
		this.end = this.makeDate(new Date(this.end.getTime()+this.window));
		if(this.atEnd()) {
		    this.end = this.dateMax;
		    this.inAnimation = false;
		    this.stopAnimation();
		}
	    }
	    this.dateRangeChanged();
	},
	//This gets called when another display propagates its animation times
	setTimes:function(times) {
	    if(!this.getEnabled()) return;
	    this.setBeginEnd(times[0],times[times.length-1]);
	    this.dates.every((date,idx)=>{
		if(date.getTime()==times[0].getTime()) {
		    this.frameIndex=idx;
		    return false;
		}
		return true;
	    });
	    
	    this.updateUI();
	    this.dateRangeChanged();
	},
	deltaFrame: function(delta) {
	    this.frameIndex+=delta;
	    if(!this.dates) return;
	    if(this.frameIndex>= this.dates.length) {
		this.frameIndex = this.dates.length-1;
	    }   else if(this.frameIndex<0) {
		this.frameIndex = 0;
	    }
	    return this.dates[this.frameIndex];
	},
	startAnimation: function() {
            if (!this.dateMax) return;
	    if (!this.inAnimation) {
                this.inAnimation = true;
                this.label.html("");
		if (this.mode == MODE_FRAME) {
		    this.frameIndex =0;
		    this.setBeginEnd(this.deltaFrame(0));
		    this.display.animationStart();
		    this.doNext();
		    return;
		}
                if(this.fullRange()) {
		    this.end = this.makeDate(new Date(this.begin.value+this.window));
		}
		this.display.animationStart();
            }
	    this.doNext();
        },
	stopAnimation:function() {
	    if(this.btnRun)
		this.btnRun.html(HtmlUtils.getIconImage("fa-play"));
            this.running = false;
	},
	setDateRange: function(begin,end) {
	    this.setBegin(begin);
	    this.setEnd(end);
	    this.stopAnimation();
	    this.updateUI();
	},
	dateRangeChanged: function(skipSlider) {
	    this.applyAnimation(skipSlider);
	    this.display.getDisplayManager().notifyEvent(DisplayEvent.animationChanged, this.display, {
		begin:this.begin,
		end: this.end
	    });
	    let record = this.dateToRecordMap[this.begin];
	    if(record && this.display.getProperty("animationPropagateRecordSelection",false)) {
		this.display.getDisplayManager().notifyEvent(DisplayEvent.recordSelection, this, {record:record});
	    }
	},
	applyAnimation: function(skipSlider) {
	    //Buffer the apply calls in case the user is clicking really fast
	    if(this.applyTimeout) {
		clearTimeout(this.applyTimeout);
	    }
	    this.applyTimeout = setTimeout(()=>{
		this.applyTimeout = null;
		this.display.animationApply(this);
		this.updateUI();
	    },20);
	},
	setRecordListHighlight: function(recordList) {
	    this.recordListHighlight = recordList;
	    this.updateTicks();
	},
	zoomReset: function() {
	    if(this.originaDateMin) {
		this.dateMax = this.originaDateMax;		
		this.dateMin = this.originaDateMin;
		this.updateTicks();
		this.updateLabels();
	    }
	},
	zoom: function(zoomin) {
	    let range = this.dateMax.getTime() - this.dateMin.getTime();
	    let newRange = range*(zoomin?0.9:1.1);
	    let diff = range-newRange;
	    if(!this.originaDateMin) {
		this.originaDateMin = this.dateMin;
		this.originaDateMax = this.dateMax;		
	    }
	    this.dateMin = this.makeDate(new Date(this.dateMin.getTime()+diff));
	    this.dateMax = this.makeDate(new Date(this.dateMax.getTime()-diff));			
	    this.updateTicks();
	    this.updateLabels();
	},
	updateTicks: function() {
	    let debug = false;
	    this.tickCount = 0;
	    if(!this.records || !this.display.getProperty("animationShowTicks",true)) return;
	    this.highlightRecords = {};
	    if(this.recordListHighlight) {
		this.recordListHighlight.forEach(r=>{
		    this.highlightRecords[r.getId()] = true;
		});
	    }
	    if(debug)console.log("animation.init making ticks: #records=" + records.length +" date:" + this.dateMin + " " + this.dateMax);
	    let tickStyle = this.display.getProperty("animationTickStyle","");
	    let ticks = "";
	    let min = this.dateMin.getTime();
	    let max = this.dateMax.getTime();
	    let p = 0;
	    let seenDate={};
	    let t1 = new Date();
	    for(let i=0;i<this.records.length;i++) {
		let record = this.records[i];
		let date;
		if(this.useIndex) {
		    date = i;
		}  else {
		    let dttm = record.getDate();
		    if(!dttm) continue;
		    date = record.getDate().getTime();
		    if(seenDate[date]) continue;
		    seenDate[date] = true;
		    if(debug)console.log("\ttick:" + record.getDate());
		}
		if(date<min) continue;
		if(date>max) continue;
		this.tickCount++;
		let perc = (date-min)/(max-min)*100;
		let tt = this.formatAnimationDate(record.getDate());
		let clazz = "display-animation-tick";
		if(this.highlightRecords[record.getId()]) {
		    clazz+=" display-animation-tick-highlight-base ";
		}
		ticks+=HtmlUtils.div([ID,this.display.getId()+"-"+record.getId(), CLASS,clazz,STYLE,HU.css("height",this.tickHeight,'left', perc+'%')+tickStyle,TITLE,tt,RECORD_ID,record.getId()],"");
	    }
	    let t2 = new Date();
	    this.jq(ID_TICKS).html(ticks);
	    let t3 = new Date();
	    if(debug)console.log("animation.init done making ticks");
	    let propagateHighlight = display.getProperty("animationHighlightRecord",false);
	    let propagateSelect = display.getProperty("animationSelectRecord",true);
	    this.ticks = this.jq(ID_TICKS).find(".display-animation-tick");
	    let _this = this;
	    this.display.makeTooltips(this.ticks, this.records,(open,record) =>{
		if(_this.display.animationLastRecordSelectTime) {
		    let now = new Date();
		    //If we recently selected a recordwith a click then don't do the highlight record from the mouse overs
		    //for a couple more seconds
		    if(now.getTime()-_this.display.animationLastRecordSelectTime.getTime()<1500) {
			return false;
		    }
		}
		if(record && propagateHighlight) {
		    if(propagateSelect) {
			_this.display.propagateEventRecordSelection({select:false,record: null});
		    }
		    this.display.handleEventRecordHighlight(this, {highlight: open,record:record, skipAnimation:true});
		}
		return true;
	    },null,propagateHighlight);
	    if(propagateSelect) {
		this.display.makeRecordSelect(this.ticks,this.display.makeIdToRecords(this.records),record=>{
		    _this.display.animationLastRecordSelectTime = new Date();
		});
	    }

	    let t4 = new Date();
//	    Utils.displayTimes("",[t1,t2,t3,t4],true);
	},
	updateUI: function(skipSlider) {
	    if(!skipSlider) {
		if(this.makeSlider) {
		    this.jq(ID_SLIDER).slider('values',0,this.begin.getTime());
		    this.jq(ID_SLIDER).slider('values',1,this.end.getTime());
		}
	    }
	    this.updateLabels();
            let windowEnd = this.end.getTime();
            if (windowEnd <= this.dateMax.getTime()) {
                if (this.running) {
                    setTimeout(() => {
			if(!this.running) return;
			this.doNext();
		    }, this.speed);
                }
            } else {
                this.running = false;
                this.inAnimation = false;
		if(this.btnRun)
                    this.btnRun.html(HtmlUtils.getIconImage("fa-play"));
            }
	},
	makeLabel: function(label) {
	    return HU.span([STYLE,HU.css("font-size",this.labelSize)+this.labelStyle],label);
	},

	applyLabelTemplate: function(records) {
	    if(!this.labelTemplate) return;
	    if(records &&records.length ) {
		let record = records[0];
		let label = this.display.applyRecordTemplate(record, null,null,this.labelTemplate);
		this.label.html(this.makeLabel(label));
	    }
	},

	updateLabels: function() {
	    if(!this.label) return;
	    if(!this.makeSlider) {
		this.label.html(HU.leftCenterRight(this.makeLabel(this.formatAnimationDate(this.dateMin)),this.makeLabel("# " +this.tickCount), this.makeLabel(this.formatAnimationDate(this.dateMax))));
	    } else {
		if(this.labelTemplate) {
		    //If there is a labelTemplate then the display will call applyLabelTemplate when
		    //it has filtered its records
		    return;
		}
		if (this.mode == MODE_FRAME && this.begin.getTime() == this.end.getTime()) {
		    this.label.html(this.makeLabel(this.formatAnimationDate(this.begin)));
		} else {
		    this.label.html(this.makeLabel(this.formatAnimationDate(this.begin) + " - " + this.formatAnimationDate(this.end)));
		}
	    }
	},
        formatAnimationDate: function(date,format,debug) {
	    if(Utils.isDefined(date.index)) return "#" +(date.index+1);
	    if(date.date) date = date.date;
	    let timeZoneOffset =this.display.getTimeZoneOffset();
	    let timeZone =this.display.getTimeZone();	    
	    if(timeZoneOffset) {
		if(debug) console.log("date before:" + date.toUTCString());
		date = Utils.createDate(date, -timeZoneOffset);
		if(debug) console.log("date after:" + date.toUTCString());
	    }
	    let fmt =  Utils.formatDateWithFormat(date,format||this.dateFormat,true);
	    if(timeZone) return fmt +" " + timeZone;
	    return fmt;
        },

    });
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/




function ColorByInfo(display, fields, records, prop,colorByMapProp, defaultColorTable, propPrefix, theField, props,lastColorBy) {
    this.properties = props || {};
    if(!prop) prop = "colorBy";
    if(Utils.isDefined(this.properties.minValue)) this.properties.hasMinValue = true;
    if(Utils.isDefined(this.properties.maxValue)) this.properties.hasMaxValue = true;    

    if ( !propPrefix ) {
	propPrefix = ["colorBy",""];
    } else if( !Array.isArray(propPrefix) ) {
	propPrefix = [propPrefix];
    }
    $.extend(this, {
	display:display,
	fieldProp: prop,
	fieldValue:display.getProperty(prop),
	propPrefix: propPrefix,
	colorHistory:{}
    });

    let colorByAttr = this.getProperty(prop||"colorBy", null);
    if(theField==null) {
	if(prop.getId) {
	    theField = prop;
	} else {
	    theField = display.getFieldById(null, colorByAttr);
	}
    }

    if(theField) {
	this.field = theField;
	propPrefix = [theField.getId()+".",""];
	colorByAttr =theField.getId();
	this.propPrefix.unshift(theField.getId()+".colorBy");
	this.propPrefix.push("colorBy");
    }

    $.extend(this, {
	display:display,
        id: colorByAttr,
	fields:fields,
        field: theField,
	colorThresholdField:display.getFieldById(null, display.getProperty("colorThresholdField")),
	literal:display.getProperty("colorByLiteral"),
	aboveColor: display.getProperty("colorThresholdAbove","red"),
	belowColor:display.getProperty("colorThresholdBelow","blue"),
	nullColor:display.getProperty("nullColor"),	
	excludeZero:this.getProperty(PROP_EXCLUDE_ZERO, false),
	overrideRange: this.getProperty("overrideColorRange",false),
	inverse: this.getProperty("Inverse",false),
	origRange:null,
	origMinValue:0,
	origMaxValue:0,
        minValue: 0,
        maxValue: 0,
	toMinValue: 0,
        toMaxValue: 100,
        isString: this.properties.isString,
        stringMap: null,
	colorByMap: {},
	colorByValues:[],
	colorByMinPerc: this.getProperty("MinPercentile", -1),
	colorByMaxPerc: this.getProperty("MaxPercentile", -1),
	colorByOffset: 0,
        pctFields:null,
	compareFields: display.getFieldsByIds(null, this.getProperty("CompareFields", "")),
    });
    //Reuse the last color map if there is one so the string->color stays the same
    if(lastColorBy && !lastColorBy.colorOverflow) {
//	this.lastColorByMap= lastColorBy.colorByMap;
    }
    
    if(this.fieldValue == "year") {
	let seen= {};
	this.dates = [];
	records.forEach(r=>{
	    let date = r.getDate();
	    if(!date) return;
	    let year = r.getDate().getUTCFullYear();
	    if(!seen[year]) {
		seen[year] = true;
		this.dates.push(year);
	    }
	});
	this.dates.sort();
	this.setRange(this.dates[0],this.dates[this.dates.length-1]);
    }


    this.convertAlpha = this.getProperty("convertColorAlpha",false);
    this.alphaMin = this.getProperty("alphaMin");
    this.alphaMax = this.getProperty("alphaMax");    
    this.hasAlphaMin = Utils.isDefined(this.alphaMin);
    this.hasAlphaMax = Utils.isDefined(this.alphaMax);    
    if(this.convertAlpha) {
	if(!Utils.isDefined(this.getProperty("alphaSourceMin"))) {
	    var min = 0, max=0;
	    records.forEach((record,idx)=>{
		var tuple = record.getData();
		if(this.compareFields.length>0) {
		    this.compareFields.map((f,idx2)=>{
			var v = tuple[f.getIndex()];
			if(isNaN(v)) return;
			min = idx==0 && idx2==0?v:Math.min(min,v);
			max = idx==0 && idx2==0?v:Math.max(max,v);
		    });
		} else if (this.index=0) {
		    var v = tuple[this.index];
		    if(isNaN(v)) return;
		    min = idx==0?v:Math.min(min,v);
		    max = idx==0?v:Math.max(max,v);
		}
	    });
	    this.alphaSourceMin = min;
	    this.alphaSourceMax = max;
	} else {
	    this.alphaSourceMin = +this.getProperty("alphaSourceMin",40);
	    this.alphaSourceMax = +this.getProperty("alphaSourceMax",80);
	}
	this.alphaTargetMin = +this.getProperty("alphaTargetMin",0); 
	this.alphaTargetMax = +this.getProperty("alphaTargetMax",1); 
    }

    this.convertIntensity = this.getProperty("convertColorIntensity",false);
    if(this.convertIntensity) {
	if(!Utils.isDefined(this.getProperty("intensitySourceMin"))) {
	    var min = 0, max=0;
	    records.forEach((record,idx)=>{
		var tuple = record.getData();
		if(this.compareFields.length>0) {
		    this.compareFields.map((f,idx2)=>{
			var v = tuple[f.getIndex()];
			if(isNaN(v)) return;
			min = idx==0 && idx2==0?v:Math.min(min,v);
			max = idx==0 && idx2==0?v:Math.max(max,v);
		    });
		} else if (this.index=0) {
		    var v = tuple[this.index];
		    if(isNaN(v)) return;
		    min = idx==0?v:Math.min(min,v);
		    max = idx==0?v:Math.max(max,v);
		}
	    });
	    this.intensitySourceMin = min;
	    this.intensitySourceMax = max;
	} else {
	    this.intensitySourceMin = +this.getProperty("intensitySourceMin",80);
	    this.intensitySourceMax = +this.getProperty("intensitySourceMax",40);
	}
	this.intensityTargetMin = +this.getProperty("intensityTargetMin",1); 
	this.intensityTargetMax = +this.getProperty("intensityTargetMax",0); 
    }

    if (this.display.percentFields != null) {
        this.pctFields = this.display.percentFields.split(",");
    }


    let colors = null;
    if(colorByAttr) {
	let c = this.display.getProperty(colorByAttr +".colors");
	if(c) colors = c.split(",");
    }



    if(!colors){
	colors = defaultColorTable || this.display.getColorTable(true,[this.properties.colorTableProperty,
								       colorByAttr +".colorTable",
								       "colorTable"]);
    }

    
//    if(!colors && this.hasField()) {
//	colors = this.display.getColorTable(true,"colorTable");
//    }

    if(!colors) {
	var c = this.getProperty(colorByAttr +".colors");
	if(c)
	    colors = c.split(",");
    }


    if(!colors) {
	colors = this.display.getColorTable(true);
    }
    this.colors = colors;


    if(this.hasField() && !colors) {
//	this.index = -1;
//	return;
    }
    let scolorScale = this.display.getColorScale();
    if(scolorScale) {
	//"9,14.99,palegreen,darkgreen;15,19.99,#ffc966,#ffa500;20, 24.99,red,darkred;25, 27.99,mediumpurple,purple";
	this.colorScale = [];
	scolorScale.split(";").forEach(tok=>{
	    let toks=tok.split(',');
	    this.colorScale.push({
		min:+toks[0],
		max:+toks[1],		
		color1:toks[2],
		color2:toks[3]
	    });
	});
	this.colorScaleInterval = (d) => {
	    for(let i=0;i<this.colorScale.length;i++) {
		let scale = this.colorScale[i];
		if (d <= scale.max) {
		    return d3.scaleLinear().domain([scale.min, scale.max]).range([scale.color1, scale.color2])(d);
		}
	    }
	    if(!isNaN(d))
		console.log('color scale miss',d);
	    return null;
	};
    }



    if (!this.colors && this.display.colors && this.display.colors.length > 0) {
        this.colors = source.colors;
        if (this.colors.length == 1 && Utils.ColorTables[this.colors[0]]) {
            this.colors = Utils.ColorTables[this.colors[0]].colors;
        }
    }

    if (this.colors == null) {
        this.colors = Utils.ColorTables.inversegrayscale.colors;
    }


    if(!this.field) {
	for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            if (field.getId() == this.id || ("#" + (i + 1)) == this.id) {
		this.field = field;
            }
	}
    }

    if(!this.field) {
	if(this.id == "hour")
	    this.timeField="hour";
	else if(this.id == "day")
	    this.timeField="day";	
    }


    if(this.field && this.field.isString()) this.isString = true;
    this.index = this.field != null ? this.field.getIndex() : -1;
    this.stringMap = this.display.getColorByMap(colorByMapProp);
    let uniqueValues = [];
    let seenValue = {};
    if(this.index>=0 || this.timeField) {
	let min = NaN;
	let max = NaN;
	records.forEach((record,idx)=>{
            let tuple = record.getData();
	    let v;
            if(this.timeField) {
		if(this.timeField=="hour")
		    v = record.getTime().getHours();
		else
		    v = record.getTime().getTime();
	    } else {
		v = tuple[this.index];		
	    }
            if (this.isString) {
		if(!seenValue[v]) {
		    seenValue[v] = true;
		    uniqueValues.push(v);
		}
		return;
	    }
            if (this.excludeZero && v === 0) {
		return;
            }
	    min = Utils.min(min,v);
	    max = Utils.max(max,v);
	});
	this.minValue =min;
	this.maxValue =max;	
	this.origRange = [min,max];
    }

    if(uniqueValues.length>0) {
	uniqueValues.sort((a,b)=>{
	    return a.toString().localeCompare(b.toString());
	});
	uniqueValues.forEach(v=>{
	    if (!Utils.isDefined(this.colorByMap[v])) {
		let index = this.colorByValues.length;
                let color;
		if(this.lastColorByMap && this.lastColorByMap[v]) {
		    color = this.lastColorByMap[v];
		    //			console.log("\tlast v:" + v +" c:" + color);
		} 	else {
		    if(index>=this.colors.length) {
			this.colorOverflow = true;
			index = index%this.colors.length;
			//			    console.log("\tmod index:" + index +" l:" + this.colors.length);
		    }
		    color = this.colors[index];
		    //			console.log("\tindex:" + index +" v:" + v +" c:" + color);
		}
                this.colorByValues.push({value:v,color:color});
		this.colorByMap[v] = color;
                this.setRange(1,  this.colorByValues.length, true);
	    }
	});
    }

    if (this.display.showPercent) {
        this.setRange(0, 100,true);
    }

    var steps = this.getProperty("Steps");

    if(steps) {
	this.steps = steps.split(",");
    }



    this.colorByLog = this.getProperty("Log", false);
    this.colorByLog10 = this.getProperty("Log10", false);
    this.colorByLog2 = this.getProperty("Log2", false);
    if(this.colorByLog) {
	this.colorByFunc = Math.log;
    }   else if(this.colorByLog10) {
	this.colorByFunc = Math.log10;
    }   else if(this.colorByLog2) {
	this.colorByFunc = Math.log2;
    }

    this.setRange(this.getProperty("Min", this.minValue),
		  this.getProperty("Max", this.maxValue), true);

    this.range = this.maxValue - this.minValue;
    this.toMinValue = this.getProperty("ToMin", this.toMinValue);
    this.toMaxValue = this.getProperty("ToMax", this.toMaxValue);
    this.enabled = this.timeField!=null || (this.getProperty("doColorBy",true) && this.index>=0);
    this.initDisplayCalled = false;
}



ColorByInfo.prototype = {
    initDisplay: function() {
	this.filterHighlight = this.display.getFilterHighlight();
	this.initDisplayCalled = true;
    },
    getProperty: function(prop, dflt, debug) {
	if(this.properties[prop]) return this.properties[prop];
	if(this.debug) console.log("getProperty:" + prop);
	for(let i=0;i<this.propPrefix.length;i++) {
	    this.display.debugGetProperty = debug;
	    if(this.debug) console.log("\t" + this.propPrefix[i]+prop);
	    let v = this.display.getProperty(this.propPrefix[i]+prop);
	    this.display.debugGetProperty = false;
	    if(Utils.isDefined(v)) return v;
	}
	return dflt;
    },
    isEnabled: function() {
	return this.enabled ||this.getDoCount();
    },
    getField: function() {
	return this.field;
    },
    getColors: function() {
	return this.colors;
    },    
    displayColorTable: function(width,force, domId) {
	if(!this.getProperty('showColorTable',true)) return;
	domId = domId??ID_COLORTABLE;
	if(this.compareFields.length>0) {
	    let legend = "";
	    this.compareFields.forEach((f,idx)=>{
		legend += HtmlUtils.div([STYLE,HU.css('display','inline-block','width','15px','height','15px','background', this.colors[idx])]) +" " +
		    f.getLabel() +" ";
	    });
	    let dom = this.display.jq(domId);
	    dom.html(HtmlUtils.div([STYLE,HU.css('text-align','center','margin-top','5px')], legend));
	}
	if(!force && this.index<0) return;
	if(this.colorScale) {
	    let html = '<table width=100%><tr>';
	    let steps = 4;
	    let w = Math.round(parseFloat(100/(this.colorScale.length*steps)))+'%'
	    this.colorScale.forEach(s=>{
		for(let step=0;step<steps;step++) {
		    let value = s.min+(s.max-s.min)/steps*step;
		    let c =this.colorScaleInterval(value);
		    let contents='&nbsp';
		    if(step==0)
			contents =s.min;
		    else if(step==steps-1)
			contents =s.max;		    
		    let fg = Utils.getForegroundColor(c);
		    html+=HU.tag('td',[ATTR_CLASS,'display-colorscale-item',ATTR_TITLE,value,ATTR_WIDTH,w,ATTR_STYLE,HU.css('color',fg,'background',c)],contents);		    
		}
	    });
	    html += '</tr></table>';
	    this.display.displayColorTableHtml(html,domId);
	    return;
	}
	if(this.stringMap) {
	    let colors = [];
	    this.colorByValues= [];
	    for (var i in this.stringMap) {
		let color = this.stringMap[i];
		this.colorByValues.push({value:i,color:color});
		colors.push(color);
	    }
	    this.display.displayColorTable(colors, domId, this.origMinValue, this.origMaxValue, {
		field: this.field,
		colorByInfo:this,
		width:width,
		stringValues: this.colorByValues});
	} else {
	    let colors = this.colors;
	    if(this.getProperty("clipColorTable",true) && this.colorByValues.length) {
		var tmp = [];
		for(var i=0;i<this.colorByValues.length && i<colors.length;i++) 
		    tmp.push(this.colors[i]);
		colors = tmp;
	    }
	    let cbs = this.colorByValues.map(v=>{return v;});
	    cbs.sort((a,b)=>{
		return a.value.toString().localeCompare(b.value.toString());
	    });
	    let getValue = v=>{
		if(this.doingDates) return new Date(v);
		return v;
	    }
	    this.display.displayColorTable(colors, domId, getValue(this.origMinValue),
					   getValue(this.origMaxValue), {
		label:this.getDoCount()?'Count':null,
		field: this.field,
		colorByInfo:this,
		width:width,
		stringValues: cbs
	    });
	}
    },
    resetRange: function() {
	if(this.origRange) {
	    this.setRange(this.origRange[0],this.origRange[1]);
	}
    },
    setRange: function(minValue,maxValue, force) {
	if(this.display.getColorByAllRecords() && !force) {
	    return;
	}
	if(this.display.getProperty("useDataForColorRange") && this.origRange) {
	    minValue = this.origRange[0];
	    maxValue = this.origRange[1];	    
	}	    

	if(displayDebug.colorTable)
	    console.log(" setRange: min:" + minValue + " max:" + maxValue);
	if(!force && this.overrideRange) return;
	this.origMinValue = minValue;
	this.origMaxValue = maxValue;


	if (this.colorByFunc) {
	    if (minValue < 0) {
		this.colorByOffset =  -minValue;
	    } else if(minValue == 0) {
		this.colorByOffset =  1;
	    }
//	    if(minValue>0)
		minValue = this.colorByFunc(minValue + this.colorByOffset);
//	    if(maxValue>0)
		maxValue = this.colorByFunc(maxValue + this.colorByOffset);
	}
	this.minValue = minValue;
	this.maxValue = maxValue;
	this.range = this.maxValue -this.minValue;
	if(!this.origRange) {
	    this.origRange = [minValue, maxValue];
	}
//	console.log("min/max:" + this.minValue +" " + this.maxValue);
    },
    getValuePercent: function(v) {
	let perc =   (v - this.minValue) / this.range;
	if(this.inverse) perc = 1-perc;
	return perc;
    },
    scaleToValue: function(v) {
	let perc = this.getValuePercent(v);
	return this.toMinValue + (perc*(this.toMaxValue-this.toMinValue));
    },
    getDoCount:function() {
	return this.doCount;
    },
    getDoTotal:function() {
	return this.doTotalCount;
    },
    getDoEnum:function() {
	return this.doEnum;
    },
    setDoEnum:function(v) {
	this.isString=true;
	this.doEnum=v;
    },            
    setDoTotal:function(v) {
	this.doTotalCount=v;
    },
    setDoCount:function(min,max) {
	this.doCount = true;
        this.minValue = min;
	this.maxValue = max;
	this.range = this.maxValue-this.minValue;
	this.origMinValue=min;
	this.origMaxValue=max;
    },
    isValueOk:function(v) {
	if(this.properties.hasMinValue && v<this.properties.minValue) return false;
	if(this.properties.hasMaxValue && v>this.properties.maxValue) return false;		    
	if(isNaN(v)) return false;
	return true;
    },
    doAverage:function(records) {
	let total = 0;
	let cnt = 0;
	records.forEach(r=>{
	    let v = r.getData()[this.index];
	    if(!this.isValueOk(v)) return;
	    total+= v;
	    cnt++;
	});
	return  total/cnt;
    },
    processEnum:function(records) {
	let counts={};
	records.forEach(r=>{
	    let v = r.getData()[this.index];
	    if(!counts[v]) {
		counts[v] = 0;
	    }
	    counts[v]++;
	});
	let maxCount=0;
	let maxValue = null;
	
	Object.keys(counts).forEach(v=>{
	    if(counts[v]>maxCount) {
		maxValue=v;
		maxCount=counts[v];
	    }
	});
	return  maxValue;
    },

    doTotal:function(records) {
	let total = 0;
	let cnt = 0;
	records.forEach(r=>{
	    let v = r.getData()[this.index];
	    if(!this.isValueOk(v)) return;
	    total+= v;
	    cnt++;
	});
	return  total;
    },    
    getColorFromRecord: function(record, dflt, checkHistory,debug) {
	this.lastValue = NaN;
	if(!this.initDisplayCalled)   this.initDisplay();
	if(this.filterHighlight && !record.isHighlight(this.display)) {
	    return this.display.getUnhighlightColor();
	}

	let records = record;
	if(!Array.isArray(records)) records=[records];
	else record = records[0];
	if(this.colorThresholdField && this.display.selectedRecord) {
	    let v=this.display.selectedRecord.getValue(this.colorThresholdField.getIndex());
	    let v2=records[0].getValue(this.colorThresholdField.getIndex());
	    if(v2>v) return this.aboveColor;
	    else return this.belowColor;
	}

	if (this.index >= 0 || this.getDoCount()) {
	    let value;
	    if(this.getDoEnum()) {
		value = this.processEnum(records);
	    } else if(records.length>1) {
		value =  this.getDoTotal()?this.doTotal(records):this.doAverage(records);
	    } else {
		value= records[0].getData()[this.index];
	    }
	    //check if it is a date
	    if(value?.getTime) {
		value = value.getTime();
		this.doingDates = true;
	    }
	    value = this.getDoCount()?records.length:value;
	    record.setDisplayProperty(this.display.getId(),'colorByValue',value);
	    this.lastValue = value;
	    return  this.getColor(value, record,checkHistory);
	} else if(this.timeField) {
	    let value;
	    if(this.timeField=="hour") {
		value = records[0].getTime().getHours();
	    }  else {
		value = records[0].getTime().getTime();
	    }
	    this.lastValue = value;
//	    console.log(value);
	    return  this.getColor(value, records[0],checkHistory);
	} 
	if(this.fieldValue == "year") {
	    if(records[0].getDate()) {
		let value = records[0].getDate().getUTCFullYear();
		this.lastValue = value;
		return this.getColor(value, records[0]);
	    }
	}
	return dflt;
    },
    hasField: function() {
	return this.index>=0;
    },
    getColor: function(value, pointRecord, checkHistory) {
	if(this.literal) {
	    value = String(value);
	    if(value.indexOf('(')) {
		value = value.replace(/\(.*\)/,'');
	    }
	    return value;
	}
	if(this.colorScaleInterval)
	    return this.colorScaleInterval(value);
	let c = this.getColorInner(value, pointRecord);
	if(c==null) c=this.nullColor;
	return c;
    },

    getColorInner: function(value, pointRecord,debug) {
//	if(debug) console.log(value);
	if(!this.initDisplayCalled)   this.initDisplay();

	if(this.filterHighlight && pointRecord && !pointRecord.isHighlight(this.display)) {
	    return this.display.getUnhighlightColor();
	}

	let percent = 0.5;
        if (this.showPercent) {
            let total = 0;
            let data = pointRecord.getData();
            for (let j = 0; j < data.length; j++) {
                let ok = this.fields[j].isNumeric() && !this.fields[j].isFieldGeo();
                if (ok && this.pctFields != null) {
                    ok = this.pctFields.indexOf(this.fields[j].getId()) >= 0 ||
                        this.pctFields.indexOf("#" + (j + 1)) >= 0;
                }
                if (ok) {
                    total += data[j];
                }
            }
            if (total != 0) {
                percent =  value / total * 100;
                percent = (percent - this.minValue) / (this.maxValue - this.minValue);
            }
        } else {
            let v = value;
	    if(this.stringMap) {
		let color = this.stringMap[value];
		if(!Utils.isDefined(color)) {
		    return this.stringMap["default"];
		}
		return color;
	    }
            if (this.isString) {
                color = this.colorByMap[v];
		if(color) return color;
            }
	    let tmp = v;
            v += this.colorByOffset;
            if (this.colorByFunc && v>0) {
                v = this.colorByFunc(v);
            }
            percent = this.range?(v - this.minValue) / this.range:0.5;
//	    console.log(this.display.getName(),v,percent,this.range,this.minValue);
//	    if(tmp>3 && tmp<6)
//		console.log("ov:" + tmp  +" v:" + v + " perc:" + percent);
        }


	let index=0;
	if(this.steps) {
	    for(;index<this.steps.length;index++) {
		if(value<=this.steps[index]) {
		    break;
		}
	    }
	} else {
	    index = parseInt(percent * this.colors.length);
	}
//	console.log("v:" + value +" index:" + index +" colors:" + this.colors);
        if (index >= this.colors.length) index = this.colors.length - 1;
        else if (index < 0) index = 0;
	if(this.stringMap) {
	    let color = this.stringMap[value];
	    if(!Utils.isDefined(color)) {
		return this.stringMap["default"];
	    }
	    return color;
	} else {
	    return this.colors[index];
	}
	return null;
    },
    convertColor: function(color, colorByValue) {
	color = this.convertColorIntensity(color, colorByValue);
	color = this.convertColorAlpha(color, colorByValue);
	return color;
    },
    convertColorIntensity: function(color, colorByValue) {
	if(!this.convertIntensity) return color;
	percent = (colorByValue-this.intensitySourceMin)/(this.intensitySourceMax-this.intensitySourceMin);
	intensity=this.intensityTargetMin+percent*(this.intensityTargetMax-this.intensityTargetMin);
	let result =  Utils.pSBC(intensity,color);
	//		    console.log(color +" " + result +" intensity:" + intensity +" min:" + this.intensityTargetM
	return result || color;
    },
    xcnt:0,
    convertColorAlpha: function(color, colorByValue) {
	if(this.hasAlphaMin) {
	    if(colorByValue<=this.alphaMin) {
		let result =  Utils.addAlphaToColor(color, 0.0);
		return result || color;
	    }

	}

	if(this.hasAlphaMax) {
	    if(colorByValue>=this.alphaMax) {
		let result =  Utils.addAlphaToColor(color, 0.0);
		return result || color;
	    }
	}	


	if(!this.convertAlpha) {
	    return color;
	}
	percent = (colorByValue-this.alphaSourceMin)/(this.alphaSourceMax-this.alphaSourceMin);
	alpha=this.alphaTargetMin+percent*(this.alphaTargetMax-this.alphaTargetMin);
	let result =  Utils.addAlphaToColor(color, alpha);
	return result || color;
    }
}


function SizeBy(display,records,fieldProperty) {
    this.display = display;
    if(!records) records = display.filterData();
    let pointData = this.display.getPointData();
    let fields = pointData?pointData.getRecordFields():[];
    $.extend(this, {
        id: this.display.getProperty(fieldProperty|| "sizeBy"),
        minValue: 0,
        maxValue: 0,
	threshold:parseFloat(this.display.getProperty('sizeByThreshold',NaN)),
        field: null,
        index: -1,
        isString: false,
        stringMap: {},
    });


    let sizeByMap = this.display.getProperty("sizeByMap");
    if (sizeByMap) {
        let toks = sizeByMap.split(",");
        for (let i = 0; i < toks.length; i++) {
            let toks2 = toks[i].split(":");
            if (toks2.length > 1) {
                this.stringMap[toks2[0]] = toks2[1];
            }
        }
    }

    for (let i = 0; i < fields.length; i++) {
        let field = fields[i];
        if (field.getId() == this.id || ("#" + (i + 1)) == this.id) {
            this.field = field;
	    if (field.isString()) this.isString = true;
        }
    }

    this.index = this.field != null ? this.field.getIndex() : -1;
    if (!this.isString && this.field) {
	let col = this.display.getColumnValues(records, this.field);
	this.minValue = col.min;
	this.maxValue =  col.max;
	if(Utils.isDefined(this.display.getProperty("sizeByMin"))) {
	    this.minValue = +this.display.getProperty("sizeByMin",0)
	}
	if(Utils.isDefined(this.display.getProperty("sizeByMax"))) {
	    this.maxValue = +this.display.getProperty("sizeByMax",0)
	}
    }

    if(this.display.getProperty("sizeBySteps")) {
	this.steps = [];
	this.display.getProperty("sizeBySteps").split(",").forEach(tuple=>{
	    let [value,size] = tuple.split(":");
	    this.steps.push({value:+value,size:+size});
	});
    }
    this.radiusMin = parseFloat(this.display.getProperty("sizeByRadiusMin", -1));
    this.radiusMax = parseFloat(this.display.getProperty("sizeByRadiusMax", -1));
    this.offset = 0;
    this.sizeByLog = this.display.getProperty("sizeByLog", false);
    this.origMinValue =   this.minValue;
    this.origMaxValue =   this.maxValue; 

    this.maxValue = Math.max(this.minValue,this.maxValue);
    if (this.sizeByLog) {
	this.func = Math.log;
        if (this.minValue < 1) {
            this.offset = 1 - this.minValue;
        }
        this.minValue = this.func(this.minValue + this.offset);
        this.maxValue = this.func(this.maxValue + this.offset);
    }
}

SizeBy.prototype = {
    getMaxSize:function() {
	return this.getSizeFromValue(this.origMaxValue);
    },
    getSize: function(values, dflt, func) {
        if (this.index <= 0) {
	    return dflt;
	}
        let value = values[this.index];
	let size = this.getSizeFromValue(value,func,false);
	return size;
    },

    getSizeFromValue: function(value,func, debug) {	
	if(this.steps) {
	    if(value<=this.steps[0].value) return this.steps[0].size;
	    for(let i=1;i<this.steps.length;i++) {
		if(value>this.steps[i-1].value && value<=this.steps[i].value ) return this.steps[i].size;
	    }
	    return this.steps[this.steps.length-1].size;
	}
        if (this.isString) {
	    let size;
            if (Utils.isDefined(this.stringMap[value])) {
                let v = parseInt(this.stringMap[value]);
                size = v;
            } else if (Utils.isDefined(this.stringMap["*"])) {
                let v = parseInt(this.stringMap["*"]);
                size = v;
            } 
	    if(isNaN(size)) size =  this.radiusMin;
	    if(func) func(NaN,size);
	    return size;
        } else {
            let denom = this.maxValue - this.minValue;
            let v = value + this.offset;
            if (this.func) v = this.func(v);
            let percent = (denom == 0 ? NaN : (v - this.minValue) / denom);
	    let size;
            if (this.radiusMax >= 0 && this.radiusMin >= 0) {
                size =  Math.round(this.radiusMin + percent * (this.radiusMax - this.radiusMin));
            } else {
                size = 6 + parseInt(15 * percent);
            }
	    if(debug) console.log("min:" + this.minValue +" max:" + this.maxValue+ " value:" + value +" percent:" + percent +" v:" + v +" size:" + size);
	    if(isNaN(size)) size =  this.radiusMin;
	    if(func) func(percent, size);
	    return size;
        }
    },
    getLegend: function(cnt,bg,vert) {
	let html = "";
	if(this.index<0) return "";
	if(this.steps) {
	    this.steps.forEach(step=>{
		let dim = step.size*2+"px";
		let v = step.value;
		html += HU.div([CLASS,"display-size-legend-item"], HU.center(HU.div([STYLE,HU.css("height", dim,"width",dim,
												  "background-color",bg||"#bbb",
												  "border-radius","50%"
												 )])) + v);

		if(vert) html+="<br>";
	    });
	} else {
	    for(let i=0;i<=cnt;i++) {
		let v = this.origMinValue+ i/cnt*(this.origMaxValue-this.origMinValue);
		let size  =this.getSizeFromValue(v,null,false);
		if(isNaN(size) || size==0) continue;
		v = this.display.formatNumber(v);
		let dim = size*2+"px";
		html += HU.div([CLASS,"display-size-legend-item"], HU.center(HU.div([STYLE,HU.css("height", dim,"width",dim,
												  "background-color",bg||"#bbb",
												  "border-radius","50%"
												 )])) + v);

		if(vert) html+="<br>";
	    }
	}
	return HU.div([CLASS,"display-size-legend"], html);
    }

}

/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/



function Glyph(display, scale, fields, records, args, attrs) {
    var props = this.properties = this.p = {};
    $.extend(this,{
	display: display,
	records:records,
	type:"label",
	toString: function() {
	    return this.properties.type;
	}
    });


    $.extend(this.properties,{
	dx:0,
	dy:0,
	label:"",
	baseHeight:0,
	baseWidth:0,
	width:8,
	fill:true,
	stroke:true,
    });
    $.extend(this.properties,args??{});

    let cnt=0;
    attrs.split(",").forEach(attr=>{
	let toks = attr.split(":");
	let name = toks[0];
	let value="";
	if(!Utils.stringDefined(name) && !Utils.stringDefined(value)) return;
	if(cnt==0 && toks.length==1) {
	    value = name;
	    name='type';
	} else {
	    for(let i=1;i<toks.length;i++) {
		if(i>1) value+=":";
		value+=toks[i];
	    }
	}
	cnt++;
//	console.log('\t'+name+'='+ value);
	value = value.replace(/_nl_/g,"\n").replace(/_colon_/g,":").replace(/_comma_/g,",").replace(/\\n/g,'\n');
	//Check for the ${...} macros
//	if(name=='colorBy')  value = value.replace('\${','').replace('}','');

	if(value=="true") value=true;
	else if(value=="false") value=false;
	this.properties[name] = value;
    });

    if(props.glyphField|| props.defaultField ) {
	['requiredField','colorBy','label'].forEach(prop=>{
	    if(props[prop]) {
		props[prop] = props[prop].replace(/\${_field}/g,props.glyphField??props.defaultField);
	    }
	});
    }

    if(props.labelBy) {
	props.labelField=display.getFieldById(fields,props.labelBy);
	if(!props.labelField) {
	    console.log("Could not find label field: " + props.labelBy);
	}
    }



    if(props.type=="image") {
	props.imageField=display.getFieldById(fields,props.imageField);
	props.myImage= new Image();
    }
    props.scale = scale;
    if(props.height==null) {
	if(props.type == "3dbar")
	    props.height=20;
	else
	    props.height=8;
    }
    if(props.pos==null) {
	if(props.type == "3dbar")
	    props.color = "blue";
	else if(props.type == "rect") {
	    props.pos = "c";
	}
	else
	    props.pos = "nw";
    }	
    
    let cvrt= this.cvrt = s=>{
	if(!isNaN(+s)) return +s;
	s  = String(s);
	s = s.replace(/canvasWidth2/g,""+(props.canvasWidth/2)).replace(/canvasWidth/g,props.canvasWidth);
	s = s.replace(/cw2/g,""+(props.canvasWidth/2)).replace(/cw/g,props.canvasWidth);
	s = s.replace(/canvasHeight2/g,""+(props.canvasHeight/2)).replace(/canvasHeight/g,props.canvasHeight);
	s = s.replace(/ch2/g,""+(props.canvasHeight/2)).replace(/ch/g,props.canvasHeight);		
	s = s.replace(/width2/g,""+(props.width/2)).replace(/width/g,props.width);	
	s = s.replace(/height2/g,""+(props.height/2)).replace(/height/g,props.width);	
	try {
	    s = eval(s);
	} catch(err) {
	    console.error('error evaling glyph value:' + s,err);
	}
	return s;
    };
    props.width = cvrt(props.width);
    props.height = cvrt(props.height);

    props.dx = cvrt(props.dx);
    props.dy = cvrt(props.dy);    
    props.baseWidth = +props.baseWidth;
    props.width = (+props.width)*scale;
    props.height = (+props.height)*scale;
    props.dx = (+props.dx)*scale;
    props.dy = (+props.dy)*scale;
    if(props.sizeBy) {
	props.sizeByField=display.getFieldById(fields,props.sizeBy);
	if(!props.sizeByField) {
	    console.log("Could not find sizeBy field:" + props.sizeBy);
	} else  {
	    let colorProps = {
		Min:props.sizeByMin,
		Max:props.sizeByMax,
	    };
	    props.sizeByInfo =  new ColorByInfo(display, fields, records, props.sizeBy,props.sizeBy, null, props.sizeBy,props.sizeByField,colorProps);
	}
    }

    props.wasNaN = false;
    props.dontShow =false;
    if(!props.colorByInfo && props.colorBy) {
	props.colorByField=display.getFieldById(fields,props.colorBy);
	let ct = props.colorTable?display.getColorTableInner(true, props.colorTable):null;
	if(!props.colorByField) {
	    console.log("Could not find colorBy field:" + props.colorBy);
//	    console.log("Fields:" + fields);
	    props.dontShow =true;
	} else {
	    let colorByProps = {
		Min:props.colorByMin,
		Max:props.colorByMax,
	    };	    
	    props.colorByInfo =  new ColorByInfo(display, fields, records, props.colorBy,props.colorBy+".colorByMap", ct, props.colorBy,props.colorByField, colorByProps);
	}
    }

    if(props.requiredField) {
	if(!(this.theRequiredField = display.getFieldById(fields,props.requiredField))) {
	    props.dontShow = true;
	}
    }
}



Glyph.prototype = {
    okToShow:function() {
	return !this.properties.dontShow;
    },
    hadMissingValue:function() {
	return this.properties.wasNaN;
    },    
    getColorByInfo:function() {
	return this.properties.colorByInfo;
    },
    isImage: function() {
	return this.properties.type=='image';
    },

    draw: function(opts, canvas, ctx, x,y,args,debug) {

	let props = this.properties;
	if(props.dontShow)return;
	debug = props.debug??debug;
	let color =   null;
	if(props.colorByInfo) {
	    if(props.colorByField) {
		let v = args.record.getValue(props.colorByField.getIndex());
		if(isNaN(v)) props.wasNaN = true;
		color=  props.colorByInfo.getColor(v);
	    } else if(args.colorValue) {
		color=  props.colorByInfo.getColor(args.colorValue);
		color = props.colorByInfo.convertColor(color, args.colorValue);
	    }
	}
	let lengthPercent = 1.0;
	if(props.sizeByInfo) {
	    let v = args.record.getValue(props.sizeByField.getIndex());
	    if(isNaN(v)) props.wasNaN = true;
	    lengthPercent = props.sizeByInfo.getValuePercent(v);
	}

	if(args.alphaByCount && args.cell && args.grid) {
	    if(args.grid.maxCount!=args.grid.minCount) {
		let countPerc = (args.cell.count-args.grid.minCount)/(args.grid.maxCount-args.grid.minCount);
		color = Utils.addAlphaToColor(c,countPerc);
	    }
	}
	ctx.fillStyle =color || props.fillStyle || props.color || 'transparent';
	ctx.strokeStyle =props.strokeStyle ?? props.color ?? opts.strokeStyle ?? '#000';
	ctx.lineWidth=props.lineWidth??props.strokeWidth??opts.lineWidth??1;
	if(props.type=='label') {
	    let label = props.labelField?args.record.getValue(props.labelField.getIndex()):props.label;
	    if(label===null) {
		console.log('No label value');
		return;
	    }
	    let text = String(label);
	    if(args.record) {
		text = this.display.applyRecordTemplate(args.record, null,null,text,{
		    records:args.records,
		    findNonNan:args.findNonNan,
		    entryname:props.entryname,
		    unit:props.unit
		});
		if(text.indexOf('NaN')>=0) {
		    props.wasNaN = true;
		}
	    }

	    if(!isNaN(parseFloat(text))) {
		if(props.valueScale) {
		    text = text* +props.valueScale;
		}
		if(Utils.isDefined(props.decimals))
		    text = number_format(text,+props.decimals);
	    }
	    if(props.template) {
		text = props.template.replace('${value}',text);
	    }

	    text = text.replace(/\${.*}/g,'');
	    if(props.prefix) text = props.prefix.replaceAll('_space_',' ')+text
	    if(props.suffix) text = text+props.suffix.replaceAll('_space_',' ');
	    text = text.replace(/_nl_/g,'\n').replace(/\\n/g,'\n').split('\n');

	    //Normalize the font
	    if(props.font && props.font.match(/\d+(px|pt)$/)) {
		props.font = props.font +' sans-serif';
	    }

	    ctx.font = props.font ??  this.display.getProperty('glyphFont','12pt sans-serif');
	    ctx.fillStyle = ctx.strokeStyle =    color || props.color|| this.display.getProperty('glyphColor','#000');

	    if(debug) console.log('glyph label: font=' + ctx.font +' fill:' + ctx.fillStyle +' stroke:' + ctx.strokeStyle);


	    let h = 0;
	    let hgap = 3;
	    let maxw = 0;
	    let pady = +(props.pady??2);
	    text.forEach((t,idx)=>{
		let dim = ctx.measureText(t);
		if(idx>0) h+=hgap;
		maxw=Math.max(maxw,dim.width);
		h +=dim.actualBoundingBoxAscent+dim.actualBoundingBoxDescent;
	    });
	    let pt = Utils.translatePoint(x, y, maxw,  h, props.pos,{dx:props.dx,dy:props.dy});
	    if(debug) console.log('position:',{point:pt,x:x,y:y,text_width:maxw,text_height:h,pos:props.pos,dx:props.dx,dy:props.dy});
	    let bg = props.bg;
	    text.forEach(t=>{
		let dim = ctx.measureText(t);
		if(bg) {
		    ctx.fillStyle = bg;
		    let pad = +(props.bgpad??6);
		    if(debug) console.log('drawing background:' + bg +' padding:' + pad);
		    let rh = dim.actualBoundingBoxAscent+dim.actualBoundingBoxDescent;
		    let rw = dim.width;
		    ctx.fillRect(pt.x-pad,pt.y-rh-pad,rw+2*pad,rh+2*pad);
		}
		ctx.fillStyle = ctx.strokeStyle =    color || props.color|| this.display.getProperty('glyphColor','#000');
		dim = ctx.measureText(t);
		let offset =dim.actualBoundingBoxAscent+dim.actualBoundingBoxDescent;
		if(debug) console.log('draw text:' + t +' x:' + pt.x +' y:'+ (pt.y+offset));
		ctx.fillText(t,pt.x,pt.y+offset);
		pt.y += pady+dim.actualBoundingBoxAscent + dim.actualBoundingBoxDescent + hgap;
	    });
	} else 	if(props.type == 'circle') {
	    ctx.beginPath();
	    let w = props.width*lengthPercent+ props.baseWidth;
	    let pt = Utils.translatePoint(x, y, w,  w, props.pos,{dx:props.dx,dy:props.dy});
	    let cx = pt.x+w/2;
	    let cy = pt.y+w/2;
	    if(debug) console.log('draw circle',{cx:cx,cy:cy,w:w});
	    ctx.arc(cx,cy, w/2, 0, 2 * Math.PI);
	    if(props.fill)  {
		ctx.fill();
	    }
	    if(props.stroke) 
		ctx.stroke();
	} else if(props.type=='rect') {
	    let pt = Utils.translatePoint(x, y, props.width,  props.height, props.pos,{dx:props.dx,dy:props.dy});
	    if(props.fill)  
		ctx.fillRect(pt.x,pt.y, props.width, props.height);
	    if(props.stroke) 
		ctx.strokeRect(pt.x,pt.y, props.width, props.height);
	} else if(this.isImage()) {
	    let src = props.url;
	    if(!src && props.imageField) {
		src =  args.record.getValue(props.imageField.getIndex());
	    }
	    if(src) {
		src= src.replace('\${root}',ramaddaBaseUrl);
		props.width = +(props.width??50);
		props.height = +(props.height??50);		
		let pt = Utils.translatePoint(x, y, props.width,  props.height, props.pos,{dx:props.dx,dy:props.dy});
		if(props.debug) console.log('image glyph:' + src,{pos:props.pos,pt:pt,x:x,y:y,dx:props.dx,dy:props.dy,width:props.width,height:props.height});
		let i = new Image();
		i.src = src;
		let drawImage = () =>{
		    let a = ctx.globalAlpha;
		    if(Utils.isDefined(this.properties.imageAlpha))		    
			ctx.globalAlpha = this.properties.imageAlpha;		    
		    ctx.drawImage(i,pt.x,pt.y,props.width,props.width);
		    ctx.globalAlpha = a;		    
		}
		if(!i.complete) {
		    let loaded = false;
		    i.onload=()=>{
			drawImage();
			loaded=true;
		    }
		    return () =>{
			return loaded;
		    }
		} else {
		    drawImage();

		}
	    } else {
		console.log('No url defined for glyph image');
	    }
	} else 	if(props.type == 'gauge') {
	    let pt = Utils.translatePoint(x, y, props.width,  props.height, props.pos,{dx:props.dx,dy:props.dy});
	    ctx.fillStyle =  props.fillColor || '#F7F7F7';
	    ctx.beginPath();
	    let cx= pt.x+props.width/2;
	    let cy = pt.y+props.height;
	    ctx.arc(cx,cy, props.width/2,  1 * Math.PI,0);
	    ctx.fill();
	    ctx.strokeStyle =   '#000';
	    ctx.stroke();
	    ctx.beginPath();
	    ctx.beginPath();
	    let length = props.width/2*0.75;
            let degrees = (180*lengthPercent);
	    let ex = cx-props.width*0.4;
	    let ey = cy;
	    let ep = Utils.rotate(cx,cy,ex,ey,degrees);
	    ctx.strokeStyle =  props.color || '#000';
	    ctx.lineWidth=props.lineWidth||2;
	    ctx.moveTo(cx,cy);
	    ctx.lineTo(ep.x,ep.y);
	    ctx.stroke();
	    ctx.lineWidth=1;
	    props.showLabel = true;
	    if(props.showLabel && props.sizeByInfo) {
		ctx.fillStyle='#000';
		let label = String(props.sizeByInfo.minValue);
		ctx.font = props.font || '9pt arial'
		let dim = ctx.measureText(label);
		ctx.fillText(label,cx-props.width/2-dim.width-2,cy);
		ctx.fillText(props.sizeByInfo.maxValue,cx+props.width/2+2,cy);
	    }
	} else if(props.type=='line') {
	    let x1= this.cvrt(props.x1);
	    let y1= this.cvrt(props.y1);
 	    let x2= this.cvrt(props.x2);
	    let y2= this.cvrt(props.y2);	    	    
	    ctx.strokeStyle = props.strokeStyle||'#000';
	    ctx.beginPath();
	    ctx.moveTo(x1,y1);
	    ctx.lineTo(x2,y2);
	    ctx.stroke();
	} else if(props.type=='3dbar') {
	    let pt = Utils.translatePoint(x, y, props.width,  props.height, props.pos,{dx:props.dx,dy:props.dy});
	    let height = lengthPercent*(props.height) + parseFloat(props.baseHeight);
	    ctx.fillStyle =   color || props.color;
	    ctx.strokeStyle = props.strokeStyle||'#000';
	    this.draw3DRect(canvas,ctx,pt.x, 
			    canvas.height-pt.y-props.height,
			    +props.width,height,+props.width);
	    
	} else if(props.type=='axis') {
	    let pt = Utils.translatePoint(x, y, props.width,  props.height, props.pos,{dx:props.dx,dy:props.dy});
	    let height = lengthPercent*(props.height) + parseFloat(props.baseHeight);
	    ctx.strokeStyle = props.strokeStyle||'#000';
	    ctx.beginPath();
	    ctx.moveTo(pt.x,pt.y);
	    ctx.lineTo(pt.x,pt.y+props.height);
	    ctx.lineTo(pt.x+props.width,pt.y+props.height);
	    ctx.stroke();
	} else if(props.type == 'vector') {
	    if(!props.sizeByInfo) {
		console.log('make Vector: no sizeByInfo');
		return;
	    }
	    ctx.strokeStyle =   color || props.color;
	    let v = args.record.getValue(props.sizeByField.getIndex());
	    lengthPercent = props.sizeByInfo.getValuePercent(v);
	    let length = opts.cellSizeH;
	    if(opts.lengthBy && opts.lengthBy.index>=0) {
		length = opts.lengthBy.scaleToValue(v);
	    }
	    let x2=x+length;
	    let y2=y;
	    let arrowLength = opts.display.getArrowLength();
	    /*
	      if(opts.angleBy && opts.angleBy.index>=0) {
	      let perc = opts.angleBy.getValuePercent(v);
	      let degrees = (360*perc);
	      let rads = degrees * (Math.PI/360);
	      x2 = length*Math.cos(rads)-0* Math.sin(rads);
	      y2 = 0*Math.cos(rads)-length* Math.sin(rads);
	      x2+=x;
	      y2+=y;
	      }
	    */
	    if(opts.colorBy && opts.colorBy.index>=0) {
                let perc = opts.colorBy.getValuePercent(v);
                let degrees = (180*perc)+90;
		degrees = degrees*(Math.PI / 360)
                x2 = length*Math.cos(degrees)-0* Math.sin(degrees);
		y2 = 0*Math.cos(degrees)-length* Math.sin(degrees);
                x2+=x;
                y2+=y;
            }
	    //Draw the circle if no arrow
	    if(arrowLength<=0) {
		ctx.save();
		ctx.fillStyle='#000';
		ctx.beginPath();
		ctx.arc(x,y, 1, 0, 2 * Math.PI);
		ctx.fill();
		ctx.restore();
	    }
	    ctx.beginPath();
	    ctx.moveTo(x,y);
	    ctx.lineTo(x2,y2);
	    ctx.lineWidth=opts.display.getLineWidth();
	    ctx.stroke();
	    if(arrowLength>0) {
		ctx.beginPath();
		this.drawArrow(ctx, x,y,x2,y2,arrowLength);
		ctx.stroke();
	    }
	} else if(props.type=='tile'){
	    let crx = x+opts.cellSizeX/2;
	    let cry = y+opts.cellSizeY/2;
 	    if((args.row%2)==0)  {
		crx = crx+opts.cellSizeX/2;
		cry = cry-opts.cellSizeY/2;
	    }
	    let sizex = opts.cellSizeX/2;
	    let sizey = opts.cellSizeY/2;
	    ctx.beginPath();
	    let quarter = Math.PI/2;
	    ctx.moveTo(crx + sizex * Math.cos(quarter), cry + sizey * Math.sin(quarter));
	    for (let side=0; side < 7; side++) {
		ctx.lineTo(crx + sizex * Math.cos(quarter+side * 2 * Math.PI / 6), cry + sizey * Math.sin(quarter+side * 2 * Math.PI / 6));
	    }
	    ctx.strokeStyle = '#000';
	    //	    ctx.fill();
	    ctx.stroke();
	} else {
	    console.log('Unknown cell shape:' + props.type);
	}
    },
    draw3DRect:function(canvas,ctx,x,y,width, height, depth) {
	// Dimetric projection functions
	let dimetricTx = function(x,y,z) { return x + z/2; };
	let dimetricTy = function(x,y,z) { return y + z/4; };
	
	// Isometric projection functions
	let isometricTx = function(x,y,z) { return (x -z) * Math.cos(Math.PI/6); };
	let isometricTy = function(x,y,z) { return y + (x+z) * Math.sin(Math.PI/6); };
	
	let drawPoly = (function(ctx,tx,ty) {
	    return function() {
		let args = Array.prototype.slice.call(arguments, 0);
		// Begin the path
		ctx.beginPath();
		// Move to the first point
		let p = args.pop();
		if(p) {
		    ctx.moveTo(tx.apply(undefined, p), ty.apply(undefined, p));
		}
		// Draw to the next point
		while((p = args.pop()) !== undefined) {
		    ctx.lineTo(tx.apply(undefined, p), ty.apply(undefined, p));
		}
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
	    };
	})(ctx, dimetricTx, dimetricTy);
	
	// Set some context
	ctx.save();
	ctx.scale(1,-1);
	ctx.translate(0,-canvas.height);
	ctx.save();
	
	// Move our graph
	ctx.translate(x,y);  
	// Draw the "container"
	//back
	let  baseColor = ctx.fillStyle;
	//		drawPoly([0,0,depth],[0,height,depth],[width,height,depth],[width,0,depth]);
	//left
	//		drawPoly([0,0,0],[0,0,depth],[0,height,depth],[0,height,0]);
	//right
	ctx.fillStyle =    Utils.pSBC(-0.5,baseColor);
	drawPoly([width,0,0],[width,0,depth],[width,height,depth],[width,height,0]);
	ctx.fillStyle =    baseColor;
	//front
	drawPoly([0,0,0],[0,height,0],[width,height,0],[width,0,0]);
	//top		
	ctx.fillStyle =    Utils.pSBC(0.5,baseColor);
	drawPoly([0,height,0],[0,height,depth],[width,height,depth],[width,height,0]);
	ctx.fillStyle =    baseColor;
	ctx.restore();
	ctx.restore();
    },

    drawArrow:function(context, fromx, fromy, tox, toy,headlen) {
	let dx = tox - fromx;
	let dy = toy - fromy;
	let angle = Math.atan2(dy, dx);
	context.moveTo(fromx, fromy);
	context.lineTo(tox, toy);
	context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
	context.moveTo(tox, toy);
	context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
    },

}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/



var  displayDebug= {
    getProperty:false,
    loadPointJson:false,
    pointDataLoaded:false,
    notifyEvent:false,
    notifyEventAll:false,
    handleEventPropertyChanged:false,
    getSelectedFields:false,
    filterData:false,
    getStandardData:false,
    makeDataTable:false,
    checkSearchBar:false,
    handleNoData:false,
    displayMapUpdateUI:false,
    displayMapCreateMap:false,
    displayMapAddPoints:false,
    groupBy:false,
    gridPoints:false,
    setEntry:false,
    initMap:false,
    colorTable:false
}


const CATEGORY_CHARTS = "Basic Charts";
const CATEGORY_TABLE = "Tables";
const CATEGORY_MISC = "Misc Charts";
const CATEGORY_MAPS = "Maps";
const CATEGORY_IMAGES = "Images";
const CATEGORY_RADIAL_ETC = "Trees, etc";
const CATEGORY_TEXT = "Text";
const CATEGORY_ENTRIES = "Entries";
const CATEGORY_CONTROLS = "Controls";
const DISPLAY_CATEGORIES = [CATEGORY_CHARTS,CATEGORY_TABLE,CATEGORY_MAPS,CATEGORY_IMAGES,CATEGORY_MISC,CATEGORY_TEXT,CATEGORY_RADIAL_ETC,CATEGORY_CONTROLS,CATEGORY_ENTRIES];



//Ids of DOM components
const ID_BOTTOM = "bottom";
const ID_COLORTABLE = "colortable";
const ID_LEGEND = "legend";
const ID_FIELDS = "fields";
const ID_HEADER = "header";
const ID_HEADER0 = "header0";
const ID_HEADER1 = "header1";
const ID_HEADER2 = "header2";
const ID_HEADER2_PREFIX = "header2prefix";
const ID_HEADER2_PREPREFIX = "header2preprefix";
const ID_HEADER2_PREPREPREFIX = "header2prepreprefix";
const ID_HEADER2_SUFFIX = "header2suffix";
const ID_FILTERBAR = "filterbar";
const ID_TAGBAR = "tagbar";
const ID_TITLE = ATTR_TITLE;
const ID_TITLE_EDIT = "title_edit";
const ID_LEFT = "left";
const ID_RIGHT = "right";
const ID_TITLE_FIELD="titlefield";
const ID_TOP = "top";
const ID_TOP_RIGHT = "topright";
const ID_TOP_LEFT = "topleft";
const ID_DETAILS = "details";
const ID_DETAILS_SNIPPET = "snippet";
const ID_DISPLAY_CONTENTS = "contents";
const ID_DISPLAY_CONTAINER = "container";
const ID_DISPLAY_TOP = "top";
const ID_DISPLAY_BOTTOM = "bottom";
const ID_GROUP_CONTENTS = "group_contents";
const ID_DETAILS_MAIN = "detailsmain";
const ID_GROUPBY_FIELDS= "groupdbyfields";
const ID_TOOLBAR = "toolbar";
const ID_TOOLBAR_INNER = "toolbarinner";
const ID_LIST = "list";
const ID_DISPLAY_MESSAGE = "displaymessage";
const ID_DIALOG = "dialog";
const ID_DIALOG_TABS = "dialog_tabs";
const ID_FOOTER = "footer";
const ID_FOOTER_LEFT = "footer_left";
const ID_FOOTER_RIGHT = "footer_right";
const ID_MENU_BUTTON = "menu_button";
const ID_MENU_OUTER = "menu_outer";
const ID_MENU_INNER = "menu_inner";
const ID_DISPLAY_PROGRESS = "display_progress";
const ID_REPOSITORY = "repository";
const ID_REQUEST_PROPERTIES = "request_properties";
const ID_PAGE_COUNT = "pagecount";
const ID_PAGE_PREV = "pageprev";
const ID_PAGE_NEXT = "pagenext";
const ID_PAGE_LABEL = "pagelabel";
const ID_PAGE_BUTTONS = "pagebuttons";
const ID_FILTER_HIGHLIGHT = "filterhighlight";
const ID_FILTER_DATE = "filterdate";
const ID_FILTER_COUNT = "filtercount";
const ID_ENTRIES_MENU = "entries_menu";
const ID_ENTRIES_PREV = "entries_prev";
const ID_ENTRIES_NEXT = "entries_next";
const ID_NEXT = "next";
const ID_PREV = "prev";
const ID_PREVNEXT_LABEL = "prevnext_label";

const PROP_DISPLAY_FILTER = "displayFilter";
const PROP_EXCLUDE_ZERO = "excludeZero";
const PROP_EXCLUDE_NAN = "excludeUndefined";
const PROP_DIVID = "divid";
const PROP_FIELDS = "fields";
const PROP_LAYOUT_HERE = "layoutHere";
const PROP_HEIGHT = "height";
const PROP_WIDTH = "width";

const RECORD_INDEX = "recordindex";
const RECORD_ID = "recordid";
const TEXT_HIGHLIGHT_COLOR = "yellow";
const HIGHLIGHT_COLOR = "#436EEE";

const VALUE_NONE = "--none--";

var CLASS_HEADER_SPAN = "display-header-span";
var CLASS_HEADER_LABEL = "display-header-label";

const DisplayEvent = {
};

function displayDefineEvent(event,dflt) {
    if(!(dflt===false)) dflt=true;
    DisplayEvent[event] = {
	name:event,
	share: event+".share",
	accept: event+".accept",
	shareGroup: event+".shareGroup",
	acceptGroup: event+".acceptGroup",
	default:dflt,
	handler:"handleEvent" + event[0].toUpperCase() + event.substring(1),
	toString:function() {
	    return this.name;
	}
    }
}


displayDefineEvent("setEntry");
displayDefineEvent("filteredTimes",false);
displayDefineEvent("recordSelection");
displayDefineEvent("dateRange");
displayDefineEvent("recordList");
displayDefineEvent("recordHighlight");
displayDefineEvent("propertyChanged");
displayDefineEvent("pointDataLoaded");
displayDefineEvent("dataSelection");
displayDefineEvent("fieldsSelected");
displayDefineEvent("filterFieldsSelected");
displayDefineEvent("fieldsChanged");
displayDefineEvent("fieldValueSelected");
displayDefineEvent("entrySelection");
displayDefineEvent("entriesChanged");
displayDefineEvent("mapBoundsChanged",false);
displayDefineEvent("animationChanged");
displayDefineEvent("entryMouseOver");
displayDefineEvent("entryMouseOut");
displayDefineEvent("removeDisplay");
displayDefineEvent("filterChanged");
displayDefineEvent("filteredDataChanged",false);


var globalDisplayCount = 0;
var DISPLAY_COUNT=0;
function addGlobalDisplayProperty(name, value,displayType) {
    if (window.globalDisplayProperties == null) {
        window.globalDisplayProperties = {};
    }
    if(value==="true") value = true;
    else if(value==="false") value=false;
    if(displayType) name=displayType+'.' + name;
    window.globalDisplayProperties[name] = value;
}

function getGlobalDisplayProperty(name,displayType) {
    if (window.globalDisplayProperties == null) {
        return null;
    }

    if(displayType) {
	let name2=displayType+'.' + name;
	if(Utils.isDefined(window.globalDisplayProperties[name2])) {
	    return window.globalDisplayProperties[name2];
	}
    }
    return window.globalDisplayProperties[name];
}



function addGlobalDisplayType(type, front) {
    if (window.globalDisplayTypes == null) {
        window.globalDisplayTypes = [];
	window.globalDisplayTypesMap = {};
    }

    if(type.preview && !type.tooltip) {
	type.tooltip= makeDisplayTooltip(type.label,type.preview,type.desc);
    }
    if(type.type) {
	window.globalDisplayTypesMap[type.type] = type;
    }

    if(front) {
	window.globalDisplayTypes.unshift(type);
    } else {
	window.globalDisplayTypes.push(type);
    }
}


var RamaddaDisplayUtils = {
    sparklineProps:  [
	{label:'Sparkline'},
	{p:'showDate',ex:'true'},
	{p:'showMin',ex:'true'},
	{p:'showMax',ex:'true'},
	{p:'sparklineUseAllRecords',ex:'true',tt:'Use all of the records for the min/max.\nUseful for multiples'},	
	{p:'labelStyle',ex:''},			
	{p:'sparklineWidth',d:60, canCache:true},
	{p:'sparklineHeight',d:20, canCache:true},
	{p:'sparklineLineColor',d:'#000', canCache:true},
	{p:'sparklineBarColor',d:'MediumSeaGreen', canCache:true},
	{p:'sparklineCircleColor',d:'#000', canCache:true},
	{p:'sparklineCircleRadius',d:'1', canCache:true},
	{p:'sparklineLineWidth',d:'1', canCache:true},
	{p:'sparklineShowLines',d:true, canCache:true},
	{p:'sparklineShowBars',d:false, canCache:true},
	{p:'sparklineShowCircles',d:true, canCache:true},
	{p:'sparklineShowEndPoints',d:true, canCache:true},
	{p:'sparklineEndPointRadius',d:2, canCache:true},
	{p:'sparklineEndPoint1Color',d:'steelblue', canCache:true},
	{p:'sparklineEndPointRadius',d:'2', canCache:true},
	{p:'sparklineEndPoint2Color',d:'', canCache:true},
	{p:'sparklineEndPoint2Color',d:'tomato', canCache:true},
	{p:'sparklineDoTooltip',d:true, canCache:true},
    ],




    getCanvasProps: function() {
	return [
	    {p:'canvasWidth',d:100,ex:"100",tt:'Canvas width'},
	    {p:'canvasHeight',d:100,ex:"100",tt:'Canvas height'},
	    {p:'canvasOrigin',d:"sw",ex:"center",tt:'Origin point for drawing glyphs'},
	    {label:'label glyph',p:"glyph1",ex:'type:label,pos:sw,dx:10,dy:-10,label:field_colon_ ${field}_nl_field2_colon_ ${field2}'},
	    {label:'rect glyph', p:"glyph1",ex:'type:rect,pos:sw,dx:10,dy:0,colorBy:field,width:150,height:100'},
	    {label:'circle glyph',p:"glyph1",ex:'type:circle,pos:n,dx:10,dy:-10,fill:true,colorBy:field,width:20,baseWidth:5,sizeBy:field,#sizeByMin:0,#sizeByMax:100'},
	    {label:'3dbar glyph', p:"glyph1",ex:'type:3dbar,pos:sw,dx:10,dy:-10,height:30,width:8,baseHeight:5,sizeBy:field,#sizeByMin:0,#sizeByMax:100'},
	    {label:'gauge glyph',p:"glyph1",ex:'type:gauge,color:#000,pos:sw,width:50,height:50,dx:10,dy:-10,sizeBy:field,sizeByMin:0'}
	];
    },
    getGlyphs:function(display,fields,records, canvasWidth, canvasHeight) {
	let glyphs=[];
	let cnt = 1;
	if(!Utils.isDefined(canvasWidth)) {
	    canvasWidth = display.getProperty("canvasWidth",100);
	    canvasHeight = display.getProperty("canvasHeight",100);	    
	}
	while(cnt<11) {
	    let attr = display.getProperty("glyph" + (cnt++));
	    if(!attr)
		continue;
	    glyphs.push(new Glyph(display,1.0, fields,records,{
		canvasWidth:canvasWidth,
		canvasHeight: canvasHeight
	    },attr));
	}
	return glyphs;
    }

}



function makeDisplayTooltip(header,imgs,text) {
    let h =  "";
    if(header!=null) h +=HU.b(header);
    if(imgs) {
        if(!Array.isArray(imgs)) {
	    imgs  = [imgs];
	}
	let imgHtml = imgs.reduce((acc,img)=>{
	    if(!img.startsWith("/")) {
		img = RamaddaUtil.getUrl("/help/display/" + img);
	    }
	    return acc+"<img src="+ img +" width=250px><br>";
	},'');
//	if(h!="") h+="<br>";
	h+=HU.div([],imgHtml);
    }
    if(Utils.stringDefined(text)) h+=HU.div([],text);
    h  = h.replace(/"/g,"&quot;");
    return h;
}



let addDisplayListener = null;
function addRamaddaDisplay(display) {
    if(addDisplayListener) addDisplayListener(display);
    Utils.addDisplay(display);
    display.displayCount=globalDisplayCount++;
    return display;
}

async function ramaddaDisplaySetSelectedEntry(entryId, displays,except) {
    await getGlobalRamadda().getEntry(entryId, e => {
	displays = displays||Utils.displaysList;
	if(displays) {
		displays.forEach(d=>{
		    if(d==except) return
		    if(d.setEntry) d.setEntry(e);
		});
	}
    });
}


function ramaddaDisplayCheckLayout() {
    Utils.displaysList.forEach(d=>{
        if (d.checkLayout) {
	    let t1= new Date();
//	    console.log("before:" + d.type);
            d.checkLayout();
	    let t2= new Date();
//	    Utils.displayTimes("after:" + d.type,[t1,t2],true);
        }
    });
}


function getRamaddaDisplay(id) {
    let display =  Utils.displaysMap[id];
    if(display) return display;
    //Lazily set up the display map as when they are first created they don't have their getId() function defined yet
    Utils.displaysList.forEach(display=>{
	if(display.getId) {
	    Utils.displaysMap[display.getId()] = display;
	}
	if (display.displayId) {
            Utils.displaysMap[display.displayId] = display;
	}
    });
    return Utils.displaysMap[id];
}

function removeRamaddaDisplay(id) {
    let display = getRamaddaDisplay(id);
    if (display) {
        display.removeDisplay();
	Utils.removeDisplay(display);
    }
}

function displayGetFunctionValue(v) {
    if(v.getTime) {
	return v.getTime();
    }
    if(isNaN(v)) {
	if((typeof v) == "string")return v;
	return 0;
    }
    return v;
}

function ramaddaDisplayStepAnimation() {
    Utils.displaysList.forEach(d=>{
	if(d.getProperty && d.getAnimation)  {
	    if(d.getProperty("doAnimation")) {
		d.getAnimation().doNext();
	    }
	}
    });
}


function displayDefineMembers(display, props, members) {
    RamaddaUtil.defineMembers(display, members);
    if(props && display.defineProperties) display.defineProperties(props);
    return display;
}


function defineDisplay(display, SUPER, props, members) {
    RamaddaUtil.inherit(display, SUPER);
    displayDefineMembers(display, props, members);
    if(members.ctor) {
	display.ctor();
    }
    return display;
}



addGlobalDisplayType({
    type: "group",
    label: "Group",
    requiresData: false,
    forUser: true,
    category: "Basic Charts",
    tooltip: makeDisplayTooltip("Group",null,"This allows you to layout displays and share common attributes"),
    helpUrl:true

},true);


/**
   Base class for all displays oriented things
*/
function DisplayThing(argId, argProperties) {
    this.isDisplayThing = true;

    if (argProperties == null) {
        argProperties = {};
    }


    //check for booleans as strings
    for (let i in argProperties) {
        if (typeof argProperties[i] == "string") {
            if (argProperties[i] == "true") argProperties[i] = true;
            else if (argProperties[i] == "false") argProperties[i] = false;
        }
    }


    //Now look for the structured foo.bar=value
    for (let key in argProperties) {
        let toks = key.split(".");
        if (toks.length <= 1) {
            continue;
        }
	//let map = argProperties;
	// Don't this for now as it screws up doing something like colorTable.field=...
	let map = {};
        //graph.axis.foo=bar
        let v = argProperties[key];
        if (v == "true") v = true;
        else if (v == "false") v = false;
        for (let i = 0; i < toks.length; i++) {
            let tok = toks[i];
            if (i == toks.length - 1) {
                map[tok] = v;
                break;
            }
            let nextMap = map[tok];
            if (nextMap == null) {
                map[tok] = {};
                map = map[tok];
            } else {
                map = nextMap;
            }
        }
    }

    this.ignoreGlobals = argProperties.ignoreGlobals;

    this.displayId = null;

    displayDefineMembers(this,null, {
        objectId: argId,
        properties: argProperties,
        displayParent: null,
        getId: function() {
            return this.objectId;
        },
        setId: function(id) {
            this.objectId = id;
        },
        removeDisplay: function() {
	    if(this.dialogElement)  this.dialogElement.remove();
        },
	setEntry: function(entry) {
	},
	handleEntryMenu: async function(entryId) {
            await getGlobalRamadda().getEntry(entryId, e => {
		this.setEntry(e);
	    });

	},
	getEntriesMenu: function(argProperties) {
	    if(argProperties && argProperties.entryCollection) {
		let entries  = argProperties.entryCollection.split(",");
		this.changeEntries = [];
		let enums = [];
		entries.forEach(t=>{
		    let toks = t.split(":");
		    this.changeEntries.push(toks[0]);
		    enums.push([toks[0],toks[1]]);
		});
		let noun = this.getProperty("noun", "Data");
		let prev = HU.span([ATTR_CLASS,"display-changeentries-button", TITLE,"Previous " +noun, ATTR_ID, this.getDomId(ID_ENTRIES_PREV), TITLE,"Previous"], HU.getIconImage("fa-chevron-left"));
 		let next = HU.span([ATTR_CLASS, "display-changeentries-button", TITLE,"Next " + noun, ATTR_ID, this.getDomId(ID_ENTRIES_NEXT), TITLE,"Next"], HU.getIconImage("fa-chevron-right")); 
		let label = argProperties.changeEntriesLabel||"Select " + noun;
		if(label!="") label = label+"<br>";

		return  HU.center(HU.div([ATTR_CLASS,"display-filter"], label + prev +" " + HU.select("",[ATTR_ID, this.getDomId(ID_ENTRIES_MENU)],enums) +" " + next));
	    }
	    return "";
	},
        initializeEntriesMenu: function() {
	    this.jq(ID_ENTRIES_PREV).click(e=>{
		let index = this.jq(ID_ENTRIES_MENU)[0].selectedIndex;
		if(index<=0) {
		    index = this.changeEntries.length;
		}
		let entry  =this.changeEntries[index-1];
		this.jq(ID_ENTRIES_MENU).val(entry);
		this.handleEntryMenu(entry);
	    });
	    this.jq(ID_ENTRIES_NEXT).click(e=>{
		let index = this.jq(ID_ENTRIES_MENU)[0].selectedIndex;
		if(index>=this.changeEntries.length-1) {
		    index = 0;
		}
		let entry  =this.changeEntries[index+1];
		this.jq(ID_ENTRIES_MENU).val(entry);
		this.handleEntryMenu(entry);
	    });
	    this.jq(ID_ENTRIES_MENU).change(e=>{
		let entry = this.jq(ID_ENTRIES_MENU).val();
		this.handleEntryMenu(entry);
	    });
	},


        popup: function(srcId, popupId, srcObj, popup) {
            popup = popup || $("#"+popupId);
            let src = srcObj || $("#"+srcId);
            let myalign = 'left top';
            let atalign = 'left bottom';
            popup.show();
	    //	    console.log(srcObj +" " + srcId + " " + "pop:" + popup.length +" src:" + src.length);
            popup.position({
                of: src,
                my: myalign,
                at: atalign,
                collision: "none none"
            });
            //Do it again to fix a bug on safari
            popup.position({
                of: src,
                my: myalign,
                at: atalign,
                collision: "none none"
            });
            popup.draggable();
            popup.show();	    
        },

	initDialog: function() {
	},
        showDialog: function(text, from, initDialog) {
	    if(!this.dialogElement) {
		$(document.body).append(HU.div([ATTR_CLASS, "display-dialog",
						ATTR_ID,this.getDomId(ID_DIALOG)]));
		this.dialogElement = this.jq(ID_DIALOG);
	    }
	    this.dialogElement.html(this.makeDialog(text));
            this.popup(from || this.getDomId(ID_MENU_BUTTON), null,null, this.dialogElement);
	    if(initDialog) initDialog();
            else this.initDialog();
        },
        getShowMenu: function() {
	    if(this.getProperty('isContained',false)) {
		return false;
	    }
            if (Utils.isDefined(this.showMenu)) {
		return this.showMenu;
	    }
	    let dflt = false;
            if (this.displayParent != null) {
		dflt = this.displayParent.getProperty("showChildMenu",dflt);
	    }
	    let v = this.getProperty(PROP_SHOW_MENU, dflt);
	    return v;
        },
	canEdit:function() {
	    return this.getProperty("canEdit");
	},
        getShowTitle: function() {
            if (this.getProperty("showTitle")) {
		return this.getProperty("showTitle");
	    }
	    let dflt = false;
            if (this.displayParent != null) {
		dflt = this.displayParent.getShowChildTitle(dflt);
	    }
	    return this.getProperty("showTitle", dflt);
        },
        formatDate: function(date, args, useToStringIfNeeded) {
	    if(!date || !date.getTime) return "";
            try {
                return this.formatDateInner(date, args, useToStringIfNeeded);
            } catch (e) {
		console.log(e.stack);
                console.error("Error formatting date:\"" + date +"\" error:" +e);
                if (!date.getTime && date.v) date = date.v;
                return "" + date;
            }
        },
	dateProps:null,
	getDateProps:function() {
	    if(!this.dateProps) {
		this.dateProps = {
		    dateFormat:this.getProperty("dateFormat", this.getProperty("dateFormat2")),
		    dateSuffix:this.getProperty("dateSuffix"),
		    timeZone:this.getTimeZone(),
		    dateFormatDaysAgo:this.getProperty("dateFormatDaysAgo",false)
		}
	    }
	    return this.dateProps;
	},
        formatDateInner: function(date, args,useToStringIfNeeded) {
	    let info = this.getDateProps();
	    if(!info.dateFormat && useToStringIfNeeded) {
		return String(date);
	    }
            //Check for date object from charts
            if (!date.getTime && date.v) date = date.v;
	    if(date.getTime && isNaN(date.getTime())) return "Invalid date";
	    if(info.dateFormat) {
		let dttm = Utils.formatDateWithFormat(date,info.dateFormat,true);
		if(dttm) {
		    return String(dttm);
		}
	    }
            if (!date.toLocaleDateString) {
                return String(date);
            }
            let suffix;
            if (args && !Utils.isDefined(args.suffix))
                suffix = args.suffix;
            else
                suffix = info.dateSuffix;
            let timeZone = this.getTimeZone();
            if (!suffix && timeZone) suffix = timeZone;
	    return Utils.formatDate(date, args?args.options:null, {
                timeZone: timeZone,
                suffix: suffix
	    });
        },
        getUniqueId: function(base) {
            return HU.getUniqueId(base);
        },
        toString: function() {
            return "DisplayThing:" + this.getId();
        },
        domId: function(suffix) {
	    return this.getDomId(suffix);
	},
        getDomId: function(suffix) {
            return this.getId() + "_" + suffix;
        },
	gid: function(suffix) {
            return this.getId() + "_" + suffix;
        },
	find: function(selector) {
	    return this.getContents().find(selector);
	},
	getContents: function() {
	    return this.jq(ID_DISPLAY_CONTENTS);
	},
	getContainer: function() {
	    return this.jq(ID_DISPLAY_CONTAINER);
	},		
        jq: function(componentId) {
            return $("#" + this.getDomId(componentId));
        },
	selectboxit: function(selector, args) {
	    let opts = {
		showEffect: "fadeIn",
		showEffectSpeed: 400,
		hideEffect: "fadeOut",
		hideEffectSpeed: 400,
	    };
	    if(args) $.extend(opts,args);
            HtmlUtils.initSelect(selector,opts);
	},
        writeHtml: function(idSuffix, html) {
	    try {
		$("#" + this.getDomId(idSuffix)).html(html);
	    } catch(err) {
		console.log("writeHtml error:" + err);
		console.log("idSuffix:" + idSuffix);
		console.log("html:" + html);
	    }
        },
	defaultTemplateProps:null,
	getDefaultTemplateProps: function() {
	    if(!this.defaultTemplateProps) {
		this.defaultTemplateProps = {
		    iconField: this.getProperty("iconField"),
		    iconSize: parseFloat(this.getProperty("iconSize",16)),
		    colorBy:this.getProperty("colorBy"),
		    colorByMap: this.getColorByMap(),
		    iconMap: this.getIconMap(),
		    imageWidth:this.getProperty("imageWidth")
		}
	    }
	    return this.defaultTemplateProps;
	},
	getTemplateProps: function(fields) {
	    let dflt = this.getDefaultTemplateProps();
	    return {
		iconField: this.getFieldById(fields, dflt.iconField),
		iconSize: dflt.iconSize,
		colorBy:dflt.colorBy,
		colorByMap: dflt.colorByMap,
		iconMap: dflt.iconMap
	    }
	},
	macroHook: function(token,value) {
	    return null;
	},
	fieldFormats:{},
	formatFieldValue:function(f,record,v) {
	    let info = this.fieldFormats[f.getId()];
	    if(!info) {
		info = {
		    template: this.getProperty(f.getId()+".template")
		}
		this.fieldFormats[f.getId()] = info;
	    }
	    if(info.template) {
		let tv = this.applyRecordTemplate(record,this.getDataValues(record),null, info.template);
		tv = tv.replace(/\${value}/g, v);
		v = tv;
	    }
	    return v;
	},

	createCommandText:function(commandText,commandMap) {
	    let cmd='';
	    let macros = Utils.tokenizeMacros(commandText);
	    macros.tokens.forEach(token=>{
		if(token.type=='string') {
		    cmd+=token.s;
		    return;
		}
		commandMap[token.id] = token;
		if(token.tag=='attribute') {
		    if(!token.attrs.labels) {
			console.dir('No labels:',token);
			return;
		    }
		    let labels = token.attrs.labels.split(',');
		    cmd+=HU.select('',[ATTR_CLASS,'display-command','commandId',token.id],labels);
		    return;
		}
		console.dir('Unknown command token',token);
	    });
	    return cmd;
	},
	initCommandText:function(commandMap,div) {
	    let _this = this;
	    div.find('.display-command').change(function() {
		let commandId = $(this).attr('commandId');
		let command = commandMap[commandId];
		if(!command) {
		    console.log('Could not find command:' + commandId);
		    return;
		}
		//		    console.dir(command);
		let index = $(this).prop('selectedIndex');
		Object.keys(command.attrs).forEach(key=>{
		    if(key=='labels') return;
		    let list = command.attrs[key].split(',');
		    let value = list[index];
		    if(!value) {
			console.log('could not find command value in list:', list);
			return
		    }
		    _this.setProperty(key,value);
		});
		_this.updateUI();
	    });
	},

	applyRecordTemplate: function(record, row, fields, template, props,macros, debug) {
	    if(!row) row = this.getDataValues(record);
	    if(!fields) fields = record.getFields();
	    fields = this.getFields(fields);
	    if(!props) {
		props = this.getTemplateProps(fields);
	    }
	    if(!macros)
		macros = Utils.tokenizeMacros(template,{hook:(token,value)=>{return this.macroHook(record, token,value)},
							dateFormat:this.getDateProps().dateFormat});
	    let attrs = {};
	    if(props.iconMap && props.iconField) {
		let value = row[props.iconField.getIndex()];
		let icon = props.iconMap[value];
		if(icon) {
		    attrs[props.iconField.getId() +"_icon"] =  HU.image(icon,["width",props.iconSize]);
		}
	    }

	    let makeImage = (f, value) =>{
		let tokenAttrs  = macros.getAttributes(f.getId()+"_image");
		let imageAttrs = [];
		let width = tokenAttrs?tokenAttrs["width"]:null;
		if(width) {
		    imageAttrs.push("width");
		    imageAttrs.push(width);
		} else if(this.getDefaultTemplateProps().imageWidth) {
		    imageAttrs.push("width");
		    imageAttrs.push(this.getDefaultTemplateProps().imageWidth); 
		} else  {
		    imageAttrs.push("width");
		    imageAttrs.push("300");
		}
		imageAttrs.push(ATTR_STYLE);
		imageAttrs.push("vertical-align:top");
		return HU.image(value, imageAttrs);
	    };


	    let idToField = {}
	    fields.forEach(f=>idToField[f.getId()] = f);
	    //Look for a list
	    macros.tokens.forEach(t=>{
		if(!t.attrs) return;
		let debug = t.attrs['debug'];
		//check for numeric 
		let field;
		if(t.tag=="#") {
		    if(debug) console.log("checking for numeric");
		    for (let col = 0; col < fields.length; col++) {
			let f = fields[col];
			if(f.isNumeric()) {
			    field=f;
			    if(debug) console.log("found numeric:" + f);
			    break;
			}
		    }
		} else if(t.tag=='match' && (t.attrs['pattern'] || t.attrs['numeric'])) {
		    let pattern = t.attrs['pattern'];
		    let numeric = t.attrs['numeric'];
		    if(debug) console.log("checking for pattern:" + pattern +' or number:'+ numeric);
		    fields.every(f=>{
			if(numeric && f.isNumeric()){
			    field=f;
			    if(debug) console.log("found number:" + f);
			    return false;
			}
			if(pattern) {
			    if(f.getId().indexOf(pattern)>=0 || f.getLabel().indexOf(pattern)>=0 ||
			       f.getId().match(pattern) || f.getLabel().match(pattern)) {
				field =f;
				if(debug) console.log("found pattern:" + f);
				return false;
			    }
			}
			return true;
		    });
		} else if(t.tag) {
		    fields.every(f=>{
			if(f.getId().match(t.tag) || f.getLabel().match(t.tag)) {
			    field =f;
			    if(debug) console.log("found pattern:" + f);
			    return false;
			}
			return true;
		    });
		}
		if(field) {
		    t.tag = field.getId();
		    t.attrs['label'] = field.getLabel();
		    let unit = field.getUnit();
		    if(!unit) unit=props.unit;
		    if(!unit) unit='';
		    if(t.attrs.suffix) {
			t.attrs.suffix = String(t.attrs.suffix).replace('\${unit}', unit).replace('\${fieldName}',field.getLabel()).replace('\${fieldId}',field.getId());
		    }
		    if(t.attrs.prefix) {
			t.attrs.prefix = String(t.attrs.prefix).replace('\${unit}', unit).replace('\${fieldName}',field.getLabel()+": ").replace('\${fieldId}',field.getId()+": ");
		    }		    
		} else {
		    let unit = props.unit??'';
		    if(t.attrs.suffix) {
			t.attrs.suffix = String(t.attrs.suffix).replace('\${unit}', unit).replace('\${fieldName}','').replace('\${fieldId}','');
		    }
		    if(t.attrs.prefix) {
			t.attrs.prefix = String(t.attrs.suffix).replace('\${unit}', unit).replace('\${fieldName}','').replace('\${fieldId}','');
		    }

		}

		if(t.tag=="default") {
		    attrs[t.tag] =  this.getRecordHtml(record, fields, "${default}",t.attrs);
		} else if(t.tag=="entryname") {
		    attrs[t.tag] = props["entryname"];
		} else 	if(t.attrs["type"]=="list" && t.attrs["fields"]) {
		    let html = "<table class=display-table>";
		    t.attrs.fields.split(",").forEach(fieldName=>{
			let f = idToField[fieldName];
			let value = row[f.getIndex()];
			if(f.getType()=="image") {
			    value = makeImage(f,value);
			} else  if(f.getType()=="url") {
			    if(value!="") 
				value =  HU.href(value,value);
			}
			html+="<tr><td align=right><b>" +f.getLabel()+"</b>:</td><td>  " + value+"</td></tr>";
		    });
		    html +="</table>";
		    attrs[t.tag] = html;
		}
	    });


//	    debug = true;
	    for (let col = 0; col < fields.length; col++) {
		let f = fields[col];
		let mattrs  = macros.getAttributes(f.getId());
		if(mattrs && !mattrs['label']) mattrs['label'] = f.getLabel();
		let value = row[f.getIndex()];
		if(f.isNumeric() && isNaN(value) && props.findNonNan && props.records) {
		    for(let i=props.records.length-1;i>=0;i--) {
			value = f.getValue(props.records[i]);
			if(!isNaN(value)) break;
		    }
		}
		if(debug) console.log("macro:" + col +" field:" + f.getId() +" type:" +f.getType() + " value:" + value);
		if(props.iconMap) {
		    let icon = props.iconMap[f.getId()+"."+value];
		    if(icon) {
			s = s.replace("${" + f.getId() +"_icon}", HU.image(icon,["size",props.iconSize]));
		    }
		}
		if(f.getType()=="image") {
		    if(value && value.trim().length>1) {
			let tokenAttrs  = macros.getAttributes(f.getId()+"_image");
			let imageAttrs = [];
			let width = tokenAttrs?tokenAttrs["width"]:null;
			if(width) {
			    imageAttrs.push("width");
			    imageAttrs.push(width);
			} else if(this.getDefaultTemplateProps().imageWidth) {
			    imageAttrs.push("width");
			    imageAttrs.push(this.getDefaultTemplateProps().imageWidth); 
			} else  {
			    imageAttrs.push("width");
			    imageAttrs.push("100%");
			}
			imageAttrs.push(ATTR_STYLE);
			imageAttrs.push("vertical-align:top");
			let img =  HU.image(value, imageAttrs);

			attrs[f.getId() +"_image"] =  img;
			attrs[f.getId() +"_url"] =  value;
		    } else {
			attrs[f.getId() +"_url"] =  RamaddaUtil.getCdnUrl("/icons/blank.gif");
			attrs[f.getId() +"_image"] =  "";
		    }
		} else if(f.getType()=="movie") {
		    if(value && value.trim().length>0) {
			let movieAttrs = [];
			if(this.getProperty("movieWidth")) {
			    movieAttrs.push("width");
			    movieAttrs.push(this.getProperty("movieWidth"));
			}
			let movie =  HU.movie(value,movieAttrs);
			attrs[f.getId() +"_movie"] =  movie;
			attrs[f.getId() +"_url"] =  value;
		    }
		} else if(f.getType()=="url") {
		    if(value && value.trim().length>1) {
			let tokenAttrs  = macros.getAttributes(f.getId()+"_href");
			let label = tokenAttrs?tokenAttrs["label"]:null;
			attrs[f.getId() +"_href"] =  HU.href(value,label||value);
			attrs[f.getId()]=  value;
		    } else {
			attrs[f.getId() +"_href"] =  "";
			attrs[f.getId()] =  "";
		    }
		    continue;
		} else if(f.isDate) {
		    if(value) {
			attrs[f.getId()]= value;
		    }
		    continue;
		}
		let color;
		if(props.colorByMap) {
		    if(props.colorBy && props.colorBy == f.getId()) {
			color = props.colorByMap[value];
		    } else {
			color = props.colorByMap[f.getId()+"."+value];				    
		    }
		}
		if(color) {
		    attrs[f.getId()+"_color"] =  color;
		}
		attrs[f.getId()]=  value;
		if(f.isNumeric()) {
		    //TODO: nuke this
		    attrs[f.getId() +"_format"] = Utils.formatNumberComma(value);
		}
	    }
	    this.addMacroAttributes(macros,row,attrs);
	    let handler = (tag,value) =>{
		if(tag.attrs["display"] =="tags") {
		    let type = tag.tag;
		    let filter = this.filterMap[type];
		    let color = Utils.getEnumColor(type);
		    let result = "";
		    value = String(value).trim();
		    if(value=="") return "";
		    value.split(",").forEach(tagValue=>{
			result+= HU.div(["metadata-type",type,"metadata-value",tagValue,
					 ATTR_TITLE,tagValue,
					 ATTR_STYLE, HU.css("background", color),
					 ATTR_CLASS,"display-search-tag"],tagValue);
		    });
		    if(filter) result = filter.getLabel()+": " + result+"<br>";
		    return result;
		}
		return "Unknown tag handler:" + tag.attrs["handle"];
	    };
	    attrs.recordIndex = record.rowIndex+1;
	    return macros.apply(attrs,debug,handler);
	},
	addMacroAttributes:function(macros,row,attrs) {
	},
	getFields: function(fields) {
            if (!fields) {
		if(this.convertedFields) {
		    return this.convertedFields;
		} else {
                    let pointData = this.pointData || this.getData();
                    if (pointData == null) {
			return null;
		    }
                    fields = pointData.getRecordFields();
		}
	    }
	    return fields;
	},
	fieldLabelCache:{},
	getFieldLabel:function(field) {
	    if(this.fieldLabelCache[field.getId()])
		return this.fieldLabelCache[field.getId()].value;
	    let value=  this.getProperty(field.getId()+".label",field.getLabel());
	    this.fieldLabelCache[field.getId()] = {value:value};
	    return value;
	},
	getRecordUrlHtml: function(attrs, field, record) {
	    let value = record.getValue(field.getIndex());
	    if(!Utils.stringDefined(value)) return '';
	    if(!value.startsWith('http')) value = 'https://' + value;
	    let linkLabel = value||"Link";
	    linkLabel = linkLabel.replace(/^https?:\/\//,"");
	    linkLabel = linkLabel.replace(/\?.*/,"");
	    linkLabel = linkLabel.replace(/\/$/,"");	    
	    let label = attrs[field.getId()+".label"] || attrs["url.label"] ||attrs["label"] || linkLabel;
	    return  HU.href(value,label,["target","_link"]);
	},

	getSortedFields: function(fields) {
	    let anyGroups = fields.filter(f=>{
		if(f==null) return true;
		return f.getGroup()!=null;
	    }).length>0;

	    if(!anyGroups) return fields;
	    let groups = [];
	    let map = {};
	    for(let i=0;i<fields.length;i++) {
		let field = fields[i];
		if(field==null) continue;
		group = field.getGroup();
		if(group==null) {
		    group = group+"_"+ i;
		}
		if(!map[group]) {
		    map[group] = [];
		    groups.push(group);
		}
		map[group].push(field);
	    }
	    fields = [];
	    groups.forEach(group=>{
		fields = Utils.mergeLists(fields,map[group]);
	    });
	    return fields;
	},
	dfltRecordHtmlProps:null,
	getRecordHtmlProps:function() {
	    if(!this.dfltRecordHtmlProps) {
		let urlField = this.getFieldById(null, this.getProperty("urlField", "url"),false,true);
		let linkField = this.getFieldById(null,this.getProperty("linkField"))|| urlField;
		this.dfltRecordHtmlProps = {
		    urlField : urlField,
		    linkField : linkField,
		    titleField : this.getFieldById(null,this.getProperty("titleField")),
		    titleTemplate : this.getProperty("titleTemplate"),	    
		    descField : this.getFieldById(null,this.getProperty("descriptionField")),
		    showDate : this.getProperty("showDate", true),
		    showImage : this.getProperty("showImage", true),
		    showMovie : this.getProperty("showMovie", true),	    
		    showElevation : this.getProperty("showElevation",false),
		}
	    }
	    return this.dfltRecordHtmlProps;
	},
        getRecordHtml: function(record, fields, template, props, debug) {
	    props= props??{};
	    if(!props.labelStyle) props.labelStyle=this.getLabelStyle();
	    fields = this.getFields(fields);
	    if(!fields) return "";
	    let dflt = this.getRecordHtmlProps();
	    let link  =  dflt.linkField?record.getValue(dflt.linkField.getIndex()):null;
            let showGeo = this.getTooltipShowGeo();
	    if(template=="") return "";
	    if(!Utils.stringDefined(template))
		template = this.getProperty("recordTemplate");

	    if(Utils.stringDefined(template)) {
		if(!template.startsWith("${default") && template!="${fields}") {
		    return this.applyRecordTemplate(record,this.getDataValues(record), fields, template, null, null,debug);
		}
	    }
	    let ttf = this.getTooltipFields();
	    if(template=="${fields}") {
		fields = this.getFieldsByIds(null,ttf??this.getPropertyFields());
	    } else {
		if(ttf) {
		    fields = this.getFieldsByIds(null,ttf);
		}
	    }

	    let templateProps = {};
	    let itemsPerColumn=this.getItemsPerColumn();
	    let attrs={};
	    if(template) {
		attrs = Utils.tokenizeMacros(template,{hook:(token,value)=>{return this.macroHook(record, token,value)},dateFormat:this.getDateFormat()}).getAttributes("default")||{};
	    }
	    itemsPerColumn = attrs["itemsPerColumn"] || itemsPerColumn;
	    let maxWidth = attrs["maxWidth"]?? attrs["maxwidth"];
	    let values = "";
	    if(dflt.titleField || dflt.titleTemplate) {
		let title="";
		if(dflt.titleTemplate) {
		    let titleTemplate = this.applyTitleTemplate(dflt.titleTemplate);
		    if(!dflt.titleTemplate.startsWith("${default")) {
			title = this.getRecordHtml(record, fields, titleTemplate, {},debug);
		    }

		} else {
		    title = record.getValue(dflt.titleField.getIndex());
		    if(title.getTime)
			title = this.formatDate(title);
		    title = HU.center(HU.h3(title));
		}
		if(link)
		    title = HU.href(link,title,["target","_target"]);
		values+=title;
		link = null;
	    }

	    if(dflt.descField) {
		let desc = record.getValue(dflt.descField.getIndex());
		values+=desc;
	    }

	    let tooltipNots = {};
	    this.getTooltipNotFields().split(",").forEach(f=>{
		tooltipNots[f] = true;
	    });

	    let rows = [];
	    let hadDate = false;
	    let labelColAttrs = [];
	    if(this.getLabelColumnAttrs()) {
		labelColAttrs = this.getLabelColumnAttrs().split(",");
	    } else {
		labelColAttrs = ["align","right"];
	    }
	    let labelWidth = this.getLabelWidth();
	    fields= this.getSortedFields(fields);
	    let excludes = props.excludes?props.excludes.split(","):[];
	    let skipEmpty=props.skipEmpty=='true';
	    let group = null;
	    let includeDesc = this.getIncludeFieldDescriptionInTooltip();
	    let showTooltipUnit= this.getTooltipShowUnit();
            for (let doDerived = 0; doDerived < 2; doDerived++) {
                for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
		    let ok = true;
		    excludes.every(ex=>{
			[field.getLabel(), field.getId()].every(v=>{
			    if(v.toLowerCase().match(ex)) ok  = false;
			    return ok;
			});
			return ok;
		    });
		    if(!ok) continue;
		    if(tooltipNots[field.getId()]) continue;
		    if(attrs[field.getId()+".hide"]) {
			continue;
		    }
		    if(field==dflt.titleField || field==dflt.descField) continue;
                    if (doDerived == 0 && !field.derived) continue;
                    else if (doDerived == 1 && field.derived) continue;
                    if (!field.getForDisplay()) {
			continue;
		    }
		    if(field.isRecordDate()) {
			if(!dflt.showDate || hadDate) {
			    continue;
			}
			hadDate = true;
		    }
		    if(field.isFieldDate()) hadDate = true;
                    if (!showGeo) {
                        if (field.isFieldGeo()) {
                            continue;
                        }
                    }
		    if(group!=field.getGroup()) {
			group = field.getGroup();
			if(Utils.isDefined(group)) {
			    rows.push(HU.tr([],HU.td(["colspan","2"],HU.div([ATTR_CLASS,"ramadda-header-small"],group))));
			}
		    }
                    let initValue = record.getValue(field.getIndex());
                    let value = initValue;
                    let svalue = String(initValue);		    
		    if(skipEmpty && !Utils.stringDefined(svalue)) continue;
		    let fieldValue = value;
		    if(fieldValue)
			fieldValue = svalue.replace(/"/g,"'");
                    if (typeof value == "number") {
			value = this.formatNumber(value, field.getId());
		    } 
                    if (field.isFieldDate()) {
			value = this.formatDate(value);
		    }
		    if(field.getType() == "image" && value!="") {
			if(!dflt.showImage) continue;
			let imageAttrs = [];
			if(this.getImageWidth()) {
			    imageAttrs.push("width");
			    imageAttrs.push(this.getImageWidth());
			} else  {
			    imageAttrs.push("width");
			    imageAttrs.push("200");
			}
			imageAttrs.push("align");
			imageAttrs.push("top");
			value = HU.image(value,imageAttrs);
		    }
		    if(field.getType() == "movie" && value!="") {
			if(!dflt.showMovie) continue;
			let movieAttrs = [];
			movieAttrs.push("width");
			movieAttrs.push("200");
			value = HU.movie(value,movieAttrs);
		    }		    
		    if(field.getType() == "url" || svalue.match(/^http[^ ]+$/)) {
			value = this.getRecordUrlHtml(attrs, field, record);
		    }
		    let labelValue = field.getLabel();
		    labelValue = this.getProperty('label.'+field.getId(),labelValue);
		    if(showTooltipUnit)
			value = value + field.getUnitSuffix();
		    let tt;
		    if(!includeDesc) {
			tt = field.getDescription();
			if(tt) tt+=HU.getTitleBr();
		    }
		    tt = tt??"";
		    tt+=labelValue+"=" + svalue;
		    tt = tt.replace(/"/g,"'");
		    if(svalue.indexOf("\"")>=0) tt="";
		    if(value.length>100) {
			//Only if its not an image
			if(!String(value).match('<img')) {
			    value  = HU.div([ATTR_STYLE,HU.css("max-height","100px","overflow-y","auto")],value);
			}
		    }
		    let label = this.formatRecordLabel(labelValue)+":";
		    if(labelWidth) {
			label = HU.div([ATTR_STYLE,HU.css("max-width" ,HU.getDimension(labelWidth),"overflow-x","auto")], label); 
		    } 
		    label  = HU.div([TITLE,tt],label);
                    let row = HU.open(TR,['valign','top']);
		    let labelAttrs = [ATTR_CLASS,"display-record-table-label"]
		    if(props.labelStyle) labelAttrs.push(ATTR_STYLE,props.labelStyle);
		    let displayValue = value;
		    let valueStyle = HU.css('margin-left','5px','max-width','90vw');
		    if(maxWidth) {
			valueStyle+=HU.css('max-width',HU.getDimension(maxWidth,'px'));
		    }



		    row += HU.td(labelColAttrs,HU.div(labelAttrs, label));
		    row+='\n';
		    row += HU.td(["field-id",field.getId(),"field-value",fieldValue, "align","left"], HU.div([ATTR_STYLE,valueStyle], displayValue));
		    if(includeDesc) {
			row +=HU.td([],field.getDescription()??"");
		    }
                    row += HU.close('tr');
		    rows.push(row);
                }
            }
	    if(!hadDate && dflt.showDate) {
		if(record.hasDate()) {
                    let row = HU.open(TR,['valign','top']);
		    let label = this.formatRecordLabel("Date");
		    row += HU.td([],HU.b(label+":"));
		    row += HU.td(["align","left"], HU.div([ATTR_STYLE,HU.css('margin-left','5px')],
							  this.formatDate(record.getDate())));
		    row += HU.close(TR);
		    rows.push(row);
		}
	    }
            if (dflt.showElevation && record.hasElevation()) {
                rows.push(HU.tr([],HU.td([ALIGN,'right'],HU.b('Elevation:')) +
			       HU.td([ALIGN,'left'], number_format(record.getElevation(), 4, '.', ''))));
            }
	    let rowCnt = 0;
	    values += "<table><tr valign=top>";



	    let		lists   = Utils.splitList(rows,itemsPerColumn);
	    let tdStyle =lists.length>1?"margin-right:5px;":"";
	    lists.forEach(list=>{
		values += "<td><div style='" + tdStyle+"'><table>" + Utils.join(list,"") +"</table></div></td>";
	    });
            values += "</tr></table>";
	    if(this.getRecordHtmlStyle()){
		values = HU.div([ATTR_CLASS,"ramadda-shadow-box display-tooltip", ATTR_STYLE,this.getRecordHtmlStyle()], values);
	    }
	    
            return values;
        },
        formatRecordLabel: function(label) {
            label = label.replace(/!!/g, " -- ");
	    label = label.replace(/ /g,"&nbsp;");
            return label;
        },
        getFormValue: function(what, dflt) {
            let fromForm = $("#" + this.getDomId(what)).val();
            if (fromForm != null) {
                if (fromForm.length > 0) {
                    this.setProperty(what, fromForm);
                }
                if (fromForm == "none") {
                    this.setProperty(what, null);
                }
                return fromForm;
            }
            return this.getProperty(what, dflt);
        },

        getName: function() {
            return this.getFormValue("name", this.getId());
        },
        getEventSource: function() {
            return this.getFormValue("eventSource", "");
        },
        setDisplayParent: function(parent) {
            this.displayParent = parent;
        },
        getDisplayParent: function() {
            if (this.displayParent == null && this.getLayoutManager) {
                this.displayParent = this.getLayoutManager();
            }
            return this.displayParent;
        },
        removeProperty: function(key) {
            this.properties[key] = null;
        },
        setProperty: function(key, value) {
	    //            this[key] = value;
            this.properties[key] = value;
	    this.transientProperties[key]  = value;
	    this.propertiesCache[key] = value;
        },
        getSelfProperty: function(key, dflt) {
            if (this[key] != null) {
                return this[key];
            }
            return this.getProperty(key, dflt);
        },
        initTooltip: function() {
            //don't do this for now                $( document ).tooltip();
        },
	formatInfo: {},
        formatNumber: function(number, propPrefix,debug) {
	    propPrefix = propPrefix??'';
	    let info = this.formatInfo[propPrefix];
	    if(!info) {
		info = {
		    doFormatNumber:this.getProperty(propPrefix?[propPrefix+".doFormatNumber","doFormatNumber"]:"doFormatNumber",true),
		    fmt:this.getProperty(propPrefix?[propPrefix+".numberTemplate","numberTemplate"]:"numberTemplate"),
		    scale:this.getProperty(propPrefix?[propPrefix+".formatNumberScale","formatNumberScale"]:"formatNumberScale",1),
		    decimals:this.getProperty(propPrefix?[propPrefix+".formatNumberDecimals","formatNumberDecimals"]:"formatNumberDecimals",-1),
		    comma:this.getProperty(propPrefix?[propPrefix+".formatNumberComma","formatNumberComma"]:"formatNumberComma", false),
                    nanValue: this.getNanValue()
		}
		this.formatInfo[propPrefix] = info;
	    }
	    if(!info.doFormatNumber) {
		return number;
	    }
	    if(isNaN(number)) {
                return info.nanValue;
	    }
	    let f = this.formatNumberInner(number, propPrefix,info,debug);
	    if(info.fmt) f = info.fmt.replace("${number}", f);
	    f = String(f);
	    if(f.endsWith(".")) f = f.substring(0,f.length-1);
	    return f;
	},
        formatNumberInner: function(number,propPrefix,info,debug) {
	    number = +number;
	    number = number*info.scale;
            if (info.decimals>=0) {
		return number_format(number, info.decimals);
	    }
            if (info.comma) {
		return   Utils.formatNumberComma(number);
	    }
            return Utils.formatNumber(number,false,debug);
        },
        propertyDefined: function(key) {
            return Utils.isDefined(this.getProperty(key));
        },
        setPropertyOn: function(object, myProperty, objectProperty, dflt) {
            let prop = this.getProperty(myProperty, dflt);
            if (Utils.isDefined(prop) && prop != null) {
                object[objectProperty] = prop;
            }
        },
        getDisplayProp: function(source, prop, dflt) {
            if (Utils.isDefined(this[prop])) {
                return this[prop];
            }
            let prop2 = "map-" + prop;
            if (Utils.isDefined(source[prop2])) {
                return source[prop2];
            }
	    if(source.getProperty) {
		return source.getProperty(prop, dflt);
	    }
	    return null;
        },
        getPropertyFromUrl: function(key, dflt,checkKey) {
	    let fromUrl = HU.getUrlArgument('d'+this.displayCount+'.'+key,
					    'display'+ this.displayCount+'.' + key);
	    if(Utils.stringDefined(fromUrl)) {
//		console.log('from url full key:' + key + ' value:' + fromUrl);
		return fromUrl;
	    }
	    if(checkKey) {
		fromUrl = HU.getUrlArgument(key);
		if(fromUrl) {
//		    console.log('from url:' + key + ' value:' + fromUrl);
		    return fromUrl;
		}
	    }
	    let value = this.getProperty(key,dflt);
//	    console.log('NOT from url:' + key + ' property is dflt:' + (value==dflt)+ ' value:' +value);
	    return value;


	},
        addToDocumentUrl: function(key, value,skipPrefix) {
	    HU.addToDocumentUrl(
		(skipPrefix?'':'d'+ this.displayCount+'.') + key,value);
	},

	getPropertyFields: function(dflt) {
	    return this.getPropertyFromUrl(PROP_FIELDS,dflt);
	},
	transientProperties:{},
	getPropertyCounts:{},
	priorProps:{},
	getAliasForField:function(field) {
	    if(!this.aliasList) {
		this.aliasList  =[];
		Object.keys(this.properties).forEach(key=>{
		    key = String(key);
		    if(key.startsWith("alias.")) {
			let pattern = this.properties[key];
			key = key.substring("alias.".length);
			this.aliasList.push({alias:key,pattern:pattern});
		    }
		});
	    }
	    let list = [];
	    this.aliasList.forEach(alias=>{
		if(field.getId()==alias.pattern || field.getId().match(alias.pattern)) {
		    list.push(alias.alias)
		}
	    });
	    return list;
	},
	getFieldProperty:function(field,prop,dflt){
	    let v =   this.getProperty(field.getId()+'.'+prop);
	    if(Utils.isDefined(v)) return v;
	    //check for aliases properties
	    let aliases = this.getAliasForField(field);
	    aliases.every(alias=>{
		v =   this.getProperty(alias+'.'+prop);
		if(Utils.isDefined(v)) return false;		
		return true;
	    });
	    if(Utils.isDefined(v)) return v;
	    return this.getProperty(prop,dflt);
	},

	getTooltip:function(dflt) {
	    let tooltip = this.getProperty('tooltip',dflt);
	    if(tooltip=='none') tooltip=null;
	    return tooltip;
	},
        getProperty: function(key, dflt, skipThis, skipParent) {
	    let debug = displayDebug.getProperty;
	    if(!this.getPropertyCounts[key]) {
		this.getPropertyCounts[key]=0;
	    }
/*
  Don't try to optimize. It causes problems
	    if(typeof this.transientProperties[key]!='undefined') {
		if(debug) {
		    console.log("getProperty:" + key +"  dflt:"+ dflt +" transient:" + this.transientProperties[key]);
		}
		return   this.transientProperties[key];
	    }
*/

	    debug|=this.debugGetProperty;
	    this.getPropertyCount++;
	    this.getPropertyCounts[key]++;
//	    debug = this.getPropertyCounts[key]==1;
//	    if(debug)
//		console.log("getProperty:" + key +"  dflt:"+ dflt);
	    let value =  this.getPropertyInner(key,null,skipThis, skipParent,this);
	    if(debug) 
		console.log("getProperty:" + key +"  dflt:"+ dflt +" got:" + value);
	    if(this.writePropertyDef!=null) {
		if(!this.seenWriteProperty) this.seenWriteProperty = {};
		if(!this.seenWriteProperty[key]) {
		    let f = (v)=>{
			return v?"'" + v+"'":"null";
		    };
		    this.writePropertyDef+="{p:'" + key +"',d:" + f(dflt)+",wikiValue:" + f(value||dflt)+"},\n"
		    this.seenWriteProperty[key] = true;
		}
	    }
	    if(!Utils.isDefined(value)) {
//		if(debug)  console.log("\treturning dflt:" + dflt);
		value= dflt;
	    }
	    if(this.getPropertyCounts[key]>10) {
		//If we keep calling getProperty then set the transient property so on the next call we don't take the full hit
		this.transientProperties[key]  = Utils.isDefined(value)?value:null;
	    }
//	    if(debug)console.log("\treturning value:" + value);
//	    this.priorProps[key] = value;
	    return value;
	},
        getPropertyInner: function(keys, dflt,skipThis, skipParent,srcDisplay) {	    
	    let debug = displayDebug.getProperty;
	    debug = this.debugGetProperty;
	    srcDisplay = srcDisplay??this;
	    if(!Array.isArray(keys)) keys = [keys];
//	    debug = keys.includes('iconSize');

	    for(let i=0;i<keys.length;i++) {
		let key = keys[i];
//		if(key == "colorTable") debug = true;
		if(debug) console.log("getProperty:" + key +" dflt:" + dflt);
		if(this.dynamicProperties) {
		    if(debug)
			console.log("key:" + key +" value:" +this.dynamicProperties[key]);
		    if(Utils.isDefined(this.dynamicProperties[key])) {
			return this.dynamicProperties[key];
		    }
		}
		let value = this.properties[key];
		if (value != null) {
		    if(debug) console.log("\tgot property from this.properties:" + value);
                    return value;
		}
	    }
	    
	    if(!skipParent) {
		let undefined = v=>{
		    return (v===null) || (v=== void 0);
		}
		let parent = this.displayParent;
		let displayManager = this.getDisplayManager?this.getDisplayManager():null;
		let typePrefix = this.type+'.';
		for(let i=0;i<keys.length;i++) {
		    let key = keys[i];
//		    debug = key=='showMenu' && this.type=='linechart';
		    if(debug) console.log(this.type,'looking for:' + key +' has parent:',parent!=null,' has display manager:',displayManager!=null);
		    let fromParent=null;
		    if (parent != null) {
			fromParent =  parent.getPropertyInner(typePrefix+key, dflt,skipThis,null, srcDisplay);
			if(debug) console.log("\tgetProperty from display parent using type prefix:" + fromParent);
			if (undefined(fromParent)) {
			    fromParent =  parent.getPropertyInner('inherit.'+key, dflt,skipThis,null, srcDisplay);
			    if(debug) console.log("\tgetProperty from display parent:" + fromParent);
			}
			if (undefined(fromParent)) {
			    fromParent =  parent.getPropertyInner(key, dflt,skipThis,null, srcDisplay);
			    if(debug) console.log("\tgetProperty from display parent using key:" + fromParent);
			}
		    }
		    if (undefined(fromParent) && displayManager) {
			fromParent=  displayManager.getPropertyInner('inherit.'+key);
			if(debug) console.log("\tgetProperty from display manager:" + fromParent);
			if (undefined(fromParent)) {
			    fromParent =  displayManager.getPropertyInner(typePrefix+key);
			    if(debug) console.log("\tgetProperty from display parent using type prefix:" + fromParent);
			}
			if (undefined(fromParent)) {
			    fromParent =  displayManager.getPropertyInner(key);
			    if(debug) console.log("\tgetProperty from display parent using key:" + fromParent);
			}
		    }


		    if(!undefined(fromParent)) {
			if(debug) console.log("\tgotProperty from parent:" + fromParent);
			return fromParent;
		    }
		}
	    }
	    if(!this.ignoreGlobals) {
		if(!skipParent) {
		    if (this.displayParent != null) {
			if(debug) console.log("\tgetProperty calling parent");
			return this.displayParent.getPropertyInner(keys, dflt, skipThis,null,srcDisplay);
		    }
		    if (this.getDisplayManager) {
			if(debug) console.log("\tgetProperty-5");
			return   this.getDisplayManager().getPropertyInner(keys,null,null,null,srcDisplay);
		    }
		}
		for(let i=0;i<keys.length;i++) {
		    let key = keys[i];
		    value = getGlobalDisplayProperty(key,srcDisplay?srcDisplay.type:this.type);
		    if (Utils.isDefined(value)) {
			if(debug) console.log("\tgetProperty-6:" + value);
			return value;
		    }
		}
	    }
	    if(debug) console.log("\tgetProperty-6 dflt:" + dflt);
            return dflt;
        },
    });
}




/**
   Base class for all displays 
*/
function RamaddaDisplay(argDisplayManager, argId, argType, argProperties) {

    const SUPER  = new DisplayThing(argId, argProperties);
    RamaddaUtil.inherit(this, SUPER);


    if(window.globalDisplayTypesMap) {
	this.typeDef = window.globalDisplayTypesMap[argType];
    }

    this._wikiTags  = [];
    
    this.propertiesCache = {};
    this.defineProperties = function(props) {
	let tagList = [];
	props.forEach(prop=>{
	    tagList.push(prop);
	    if(!prop.p) {
		return;
	    }
	    if(prop.p.indexOf("&")<0) {
		if(!Utils.isDefined(prop.doGetter) || prop.doGetter) {
		    let getFunc = (dflt,debug)=>{
			let checkCache = prop.canCache && !dflt;
			if(checkCache) {
			    if(this.propertiesCache[prop.p])
				return this.propertiesCache[prop.p].value; 
			}
			if(!Utils.isDefined(dflt)) dflt = prop.d;
			let value =  this.getProperty(prop.p,dflt);
			if(checkCache) {
			    this.propertiesCache[prop.p] = {value:value}; 
			}
			return value;
		    };
		    let funcName =  'getProperty' + prop.p.substring(0, 1).toUpperCase() + prop.p.substring(1);
		    if(!this[funcName])
			this[funcName] = getFunc;
		    funcName =  'get' + prop.p.substring(0, 1).toUpperCase() + prop.p.substring(1);
		    if(!this[funcName])
			this[funcName] = getFunc;
		}
	    }
	    prop.wikiValue = prop.wikiValue||prop.w;
	});
	this._wikiTags  = Utils.mergeLists(tagList,this._wikiTags);
    }

    let myProps = [
	{label:'Display'},
	{p:'fields',doGetter:false,
	 ex:'comma separated list of field ids or indices - e.g. #1,#4-#7,@2,@3 (use @ for numeric fields) or *'},
	{p:'notFields',ex:'regexp',tt:'regexp to not include fields'},		
	{p:'fieldsPatterns',ex:'comma separated list of regexp patterns to match on fields to display'},
	{p:'fieldAliases',canCache:true},
	{p:'prefixFields',tt:'Field to always add to the beginning of the list'},
	{p:'showMenu',ex:true},	      
	{p:'showMenuRight',ex:true},	      
	{p:'showTitle',ex:true},
	{p:'showChildTitle',canCache:true},
	{p:'showEntryIcon',ex:true},
	{p:'layoutHere',ex:true},
	{p:'headerCenter',ex:'false',tt:'Are the filter widgets centered'},
	{p:'headerDiv',tt:'div id of an alternate place to display the header'},
	{p:'footerDiv',tt:'div id of an alternate place to display the footer'},		
	{p:'width',doGetter:false,ex:'100%'},
	{p:'height',doGetter:false,ex:'400px'},
	{p:'noWrapper',ex:true,tt:'Don\'t make the header and footer. Just this core display'},
	{p:'imageWidth',canCache:true},		
	{p:'includeFieldDescriptionInTooltip',canCache:true,d:true},
	{p:'recordTemplate',doGetter:false,ex:'${default}',tt:'Template for popups etc. Can be ${default attrs} or \'${field} .. ${fieldn}...\''},
	{p:'recordHtmlStyle',canCache:true},
	{p:'labelStyle',ex:''},			
	{p:ATTR_TITLE,ex:''},
	{p:'titleTemplate',ex:'${title} - ${field1} Date range: ${recordDate_first format=yyyymmdd} - ${recordDate_last format=yyyymmdd}',
	 tt:'Template for title. Use ${title} for the default title. Use ${field} for field values of first record. Use ${field_first} for first record value. Use ${field_ast} for last record value '},	
	{p:'itemsPerColumn',canCache:true,d:50,tt:'How many items to show in each column in a tooltip'},
	{p:'labelColumnAttrs',canCache:true,ex:'align,right',tt:'Attributes of the label column in the record templates'},
	{p:'labelWidth',canCache:true,ex:'10',tt:'Width of labels the record templates'},	
	{p:'displayStyle',ex:'css styles',tt:'Specify styles for display'},
	{p:'outerDisplayStyle',ex:'css styles',tt:'Specify styles for the entire display'},
	{p:'displayInline',ex:'true'},
	{p:'showTopHeader',ex:'true'},	
	
	{p:'primaryPage',ex:'true',tt:'Set to true if you only want this display to show in the  primary for the entry '},
	{p:'titleBackground',ex:'color'},
	{p:'linkField',ex:''},
	{p:'titleField',ex:''},
	{p:'descriptionField',ex:''},
	{p:'textColor',ex:'color'},
	{p:'backgroundImage',ex:'',tt:'Image url to display in background'},
	{p:'background',ex:'color'},
	{p:'showProgress',ex:true},
	{p:'loadingMessage',ex:'',tt:'Message to show when loading data'},	
	{p:'inlineDataSrc',tt:'div id that holds the CSV inline'},
	{p:'showRecordPager',ex:true,tt:'Show the prev/next pager'},
	{p:'recordPagerNumber',d:100,tt:'How many records to show'},	
	{p:'noun',ex:'images'},
	{p:'sortFields',tt:'Comma separated list of fields to sort the data on'},
	{p:'sortAscending',ex:'true|false',d:true},
	{p:'showSortDirection',ex:true},		
	{p:'sortOnDate',ex:'true'},
	{p:'sortByFields',ex:'',tt:'Show sort by fields in a menu'},
	{p:'sortHighlight',ex:true,tt:'Sort based on highlight from the filters'},
	{p:'reverse',ex:'true',t:'Reverse the records'},
	{p:'selectUniqueFields',ex:'',tt:'Show list of fields to make data unique'},
	{p:'doEntries',ex:true,tt:'Make the children entries be data'},
	{p:'propagateDataReload',ex:'true',tt:'Propagate to other displays when the data is reloaded'},
	{p:'propagateFilteredTimes',ex:'true',tt:'Propagate to other displays the list of times when we have filtered data. The other displays need to have filteredTimes.accept=true '},
	{p:'addAttributes',ex:true,tt:'Include the extra attributes of the children'},
	{p:'orderby',ex:'date|fromdate|todate|name|number',tt:'When showing entries as data how to sort or order the entries'},
	{p:'ascending',ex:'true',tt:'When showing entries as data how to sort or order the entries'},		

	{p:'showDisplayFieldsMenu',ex:true},
	{p:'displayFieldsMenuMultiple',ex:true},
	{p:'displayFieldsMenuSide',ex:'left'},
	{p:'displayHeaderSide',ex:'left'},
	{p:'leftSideWidth',ex:'150px'},		
	{label:'Tooltips'},
	{p:'tooltip',doGetter:false,ex:'\"${default}\"'},
	{p:'tooltipDelay',d:1000},
	{p:'tooltipEffect',d:'fadeIn'},
	{p:'tooltipDuration',d:500},	
	{p:'tooltipImmediate',d:false,ex:'true',tt:'Show tooltip immediately'},	
	{p:'tooltipPositionMy',ex:'left top'},
	{p:'tooltipPositionAt',ex:'left bottom+2'},		
	{p:'tooltipCollision'},
	{p:'tooltipShowUnit',d:true,ex:'false'},
	{p:'tooltipFields',canCache:true},
	{p:'tooltipNotFields',d:''},
	{p:'tooltipShowGeo',tt:'show the record lat/lon in the tooltip',ex:'true'},
	{p:'showMapInTooltip',ex:true,tt:'Include a map inside the tooltip or map popup'},
	{p:'tooltipMapLayer',d:'osm',tt:'The map layer to use in the popup'},



	{p:'selectPopup',ex:'${default}',tt:'Template to use to make a popup when a record is selected'},
	{p:'selectPopupTitle'},
	{p:'headerText',ex:'blah blah ${command labels=\"log scale,linear scale\" xAxisType=log,linear} blah',
	 tt:'Text to show above the display. Can contain ${command ...} templates'},
	{p:'headerTextDiv',tt:'divid to put header text in'},



	{label:'Formatting'},
	{p:'dateFormat',canCache:true,
	 ex:'yyyy|yyyymmdd|yyyymmddhh|yyyymmddhhmm|yyyymm|yearmonth|monthdayyear|monthday|mon_day|mdy|hhmm'},
	{p:'dateFormatDaysAgo',ex:true},
	{p:'timeZone',canCache:true},
	{p:'timeZoneOffset',canCache:true,d:0},
	{p:'doFormatNumber',ex:false},
 	{p:'formatNumberDecimals',ex:0},
	{p:'formatNumberScale',ex:100},
	{p:'numberTemplate',ex:'${number}%'},
	{p:'nanValue',d:'--',canCache:true},
	{p:'&lt;field_id&gt;.&lt;format&gt;',ex:'...'},
	{label:'Data Requests'},
	{p:'remote',tt:'URL to an external RAMADDA entry',ex:''},
	{p:'request.startdate',tt:'Start date of data',ex:'yyyy-MM-dd or relative:-1 week|-6 months|-2 years|etc'},
	{p:'request.enddate',tt:'End date of data',ex:'yyyy-MM-dd or relative:-1 week|-6 months|-2 years|etc'},
	{p:'requestFields',ex:'date,stride,skip,limit,bounds,db columns...',
	 tt:'Comma separated list of fields for querying server side data'},
	{p:'requestFieldsDefault',d:true,tt:'Use the default date,stride,skip,limit fields'},
	{p:'requestFieldsShow',d:true,ex:'false',tt:'Show the request fields'},
	{p:'requestPrefix',ex:'search.', tt:'Prefix to prepend to the url argument'},
	{p:'requestFieldsLive',d:true,tt:'Is the request applied when a widget changes'},
	{p:'requestFieldsToggle',d:false,tt:'Put the request fields in a toggle'},
	{p:'requestFieldsToggleOpen',d:true,tt:'And leave the toggle open'},

	{p:'extraFields1',tt:'Extra request fields to show before',ex:'bounds'},
	{p:'extraFields2',tt:'Extra request fields to show after',ex:'bounds'},	
	{p:'request.&lt;field&gt;.multiple',ex:'true',tt:'Support multiple enumerated selections'},
	{p:'request.&lt;field&gt;.type',tt:'date,number,enumeration'},
	{p:'request.&lt;field&gt;.values',tt:'Comma separated list of enum values',
	 d:'0:None,1,2,3,4,5,6,7,8,9,10,15,20,30,40,50,75,100'},
	{p:'request.&lt;field&gt;.visible',d:true},
	{p:'request.&lt;field&gt;.default',tt:'Default value'},
	{p:'request.&lt;field&gt;_from.default',tt:'Default date from'},
	{p:'request.&lt;field&gt;_to.default',tt:'Default date to'},		
	{p:'request.&lt;field&gt;.multiple',d:false,tt:'For enums show multiples'},
	{p:'request.&lt;field&gt;.rows',d:4,tt:'For multiple enums how may rows to show'},
	{p:'request.&lt;field&gt;.includeNone',d:true,tt:'For enums include the none value'},		
	{p:'request.&lt;field&gt;.includeAll',d:true,tt:'For enums include the all value'},		
	{p:'request.&lt;field&gt;.triggerReload',d:true, tt:''},			
	{p:'request.&lt;field&gt;.title',tt:'Tooltip'},
	{p:'request.&lt;field&gt;.urlarg',t:'url arg to use'},	

	{label:'Filter Data'},
	{p:'headerLabel',ex:''},
	{p:'max',ex:'1000',tt:'Specify the max number of records to fetch from the server'},
	{p:'lastRecords',ex:'1',tt:'Only get the last N records from the server'},	
	{p:'maxRecords',tt:'only use this number of records'},
	{p:'fieldsNumeric',ex:true,tt:'Only get numeric fields'},
	{p:'filterFields',ex:''},
	{p:'filterFieldsToPropagate'},
	{p:'filterSetValueFieldId',tt:'when a record is selected in another display this is the field to set the filter value on the target display'},
	{p:'hideFilterWidget',ex:true},
	{p:'filterHighlight',d:false,ex:true,tt:'Highlight the records'},
	{p:'isMasterFilter',ex:true,tt:'Does this display provide filters for all the other displays'},
        {p:'showFilterTags',d: false,canCache:true},
        {p:'tagDiv',tt:'Div id to show tags in'},		
	{p:'showFilterHighlight',ex:false,tt:'show/hide the filter highlight widget'},
	{p:'unhighlightColor',d:'#eee', canCache:true},

	{p:'headerOrientation',ex:'vertical'},
	{p:'filterSliderImmediate',ex:true,tt:'Apply the change while sliding'},
	{p:'filterLogic',ex:'and|or',tt:'Specify logic to apply filters'},		
	{p:'&lt;field&gt;.type',ex:'enumeration|string|boolean'},
	{p:'&lt;field&gt;.filterShow',ex:'false'},
	{p:'&lt;field&gt;.filterLabel'},
	{p:'&lt;field&gt;.filterValue'},
	{p:'&lt;field&gt;.filterValueMin'},
	{p:'&lt;field&gt;.filterValueMax'},
	{p:'&lt;field&gt;.filterValues'},
	{p:'&lt;field&gt;.filterMultiple',ex:true},
	{p:'&lt;field&gt;.filterMultipleSize',ex:5},
	{p:'&lt;field&gt;.filterIncludeAll',ex:true},
	{p:'&lt;field&gt;.filterShowPopup',tt:'Show the popup dialog button',ex:true},
	{p:'&lt;field&gt;.filterDepends',ex:'other_field',tt:'Filter field that this filter depends on'},

	{p:'filterLive',ex:'true',tt:'Search live as the user presses a key'},
	{p:'&lt;field&gt;.filterLive',ex:'true',tt:'Search live as the user presses a key'},
	{p:'&lt;field&gt;.filterDateSelects',
	 ex:'-30 days:Last 30 days,-60 days:Last 60 days,-90 days:Last 90 days,ytd:Year to date,thisyear:This year,year_2022:2022',
	 tt:'Add a menu of select choices for dates'},	
	{p:'&lt;field&gt;.filterDateShowRange',ex:true},
	{p:'&lt;field&gt;.filterDateShowRadio',ex:true},

	{p:'filterDateSelectRadio',ex:true},
	{p:'filterShowCount',ex:false},
	{p:'filterShowTotal',ex:true},		
	{p:'&lt;field&gt;.filterLabel'},
	{p:'&lt;field&gt;.showFilterLabel'},
	{p:'&lt;field&gt;.filterLabelVertical',ex:true},
	{p:'filterLabelVertical',ex:true},				
	{p:'&lt;field&gt;.filterByStyle',ex:'background:white;'},
	{p:'&lt;field&gt;.filterSuggest',tt:'For text input popup a list of matching records',ex:true},
	{p:'&lt;field&gt;.includeAll',ex:true},
	{p:'&lt;field&gt;.filterSort',ex:true},
	{p:'&lt;field&gt;.filterSortCount',ex:true},		
	{p:'&lt;field&gt;.filterStartsWith',ex:true},
	{p:'&lt;field&gt;.filterDisplay',ex:'menu|tab|button|image'},
	{p:'&lt;field&gt;.filterOps',ex:'<,5000000,label1;>,5000000',tt:'Add menu with fixed filters'},
	{p:'excludeUndefined',ex:true,tt:'Exclude any records with an undefined value'},
	{p:'excludeZero',ex:true,tt:'Exclude any records with a 0 value'},
	{p:'filterPaginate',ex:'true',tt:'Show the record pagination'},
	{p:'pageCount',d:1000,tt:'How many records to show when paginating'},	
	{p:'recordSelectFilterFields',tt:'Set the value of other displays filter fields'},
	{p:'selectFields',ex:'prop:label:field1,...fieldN;prop:....'},
	{p:'dataFilters',canCache:true},
	{p:'match value', ex:"dataFilters=\"match(field=field,value=value,label=,enabled=);\"",tt:"Only show records that match"}, 		
	{p:"not match value",ex:"dataFilters=\"notmatch(field=field,value=value,label=,enabled=);\"",tt:"Only show records that dont match"},
	{p:'no missing values',ex:'dataFilters=\"nomissing(field=field,label=,enabled=);\"',tt:'Dont show missing values'},
	{p:'less than',ex:'dataFilters=\"lessthan(field=field,value=value,label=,enabled=);\"'},
	{p:'greater than',ex:'dataFilters=\"greaterthan(field=field,value=value,label=,enabled=);\"'},
	{p:'equals',ex:'dataFilters=\"equals(field=field,value=value,label=,enabled=);\"'},
	{p:'not equals',ex:'dataFilters=\"notequals(field=field,value=value,label=,enabled=);\"'},
	{p:'filterLatest',ex:'fields',tt:'Only show the latest records grouped by fields'},		
	{p:'filterDate',ex:'year',tt:'Show a simple pull down menu to select a year to display'},
	{p:'filterDateIncludeAll',ex:true,tt:'Include all years'},
	{p:'startDate',ex:'yyyy,MM,dd,hh,mm,ss',tt:'Filter data on date'},
	{p:'endDate',ex:'yyyy,MM,dd,hh,mm,ss',tt:'Filter data on date'},

	{label:'Events'},

	{p:DisplayEvent.filterChanged.share,ex:true,tt:'Share filter changed'},
	{p:DisplayEvent.filterChanged.accept,ex:true,tt:'Accept filter changed'},
	{p:DisplayEvent.filterChanged.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.filterChanged.acceptGroup,tt:'Only share in this group'},

	{p:DisplayEvent.filteredDataChanged.share,ex:true,tt:'Share filtered data changed'},
	{p:DisplayEvent.filteredDataChanged.accept,ex:true,tt:'Accept filtered data changed'},
	{p:DisplayEvent.filteredDataChanged.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.filteredDataChanged.acceptGroup,tt:'Only share in this group'},			




	{p:DisplayEvent.recordSelection.share,ex:true,tt:'Share record selection'},
	{p:DisplayEvent.recordSelection.accept,ex:true,tt:'Accept record selection'},
	{p:DisplayEvent.recordSelection.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.recordSelection.acceptGroup,tt:'Only share in this group'},
	{p:'selectNearestDate',tt:'find the closest record'},
	{p:'acceptDateRange',tt:'Accept date range changes'},	


	{p:DisplayEvent.recordHighlight.share,ex:true,tt:'Share record highlight'},
	{p:DisplayEvent.recordHighlight.accept,ex:true,tt:'Accept record highlight'},
	{p:DisplayEvent.recordHighlight.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.recordHighlight.acceptGroup,tt:'Only share in this group'},			

	{p:DisplayEvent.recordList.share,ex:true,tt:'Share record list'},
	{p:DisplayEvent.recordList.accept,ex:true,tt:'Accept record list'},
	{p:DisplayEvent.recordList.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.recordList.acceptGroup,tt:'Only share in this group'},


	{p:DisplayEvent.fieldsChanged.share,ex:true,tt:'Share fields changed'},
	{p:DisplayEvent.fieldsChanged.accept,ex:true,tt:'Accept fields changed'},
	{p:DisplayEvent.fieldsChanged.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.fieldsChanged.acceptGroup,tt:'Only share in this group'},

	{p:DisplayEvent.fieldsSelected.share,ex:true,tt:'Share fields selected'},
	{p:DisplayEvent.fieldsSelected.accept,ex:true,tt:'Accept fields selected'},
	{p:DisplayEvent.fieldsSelected.shareGroup,tt:'Only share in this group'},
	{p:DisplayEvent.fieldsSelected.acceptGroup,tt:'Only share in this group'},			

	{p:DisplayEvent.setEntry.share,ex:true,tt:'When displaying entries as data this shares the selected entry with other displays'},
	{p:DisplayEvent.setEntry.accept,ex:true,tt:'When displaying entries as data this accepts the new entry'},
	{p:DisplayEvent.setEntry.shareGroup,tt:'When sharing the entry this groups what displays to share with'},
	{p:DisplayEvent.setEntry.acceptGroup,tt:'When sharing the entry this must match with the shareGroup'},		

	{p:'acceptEventDataSelection',ex:true,tt:'accept new data coming from other displays'},
	{p:'recordSelectField',tt:'Field to match selection on instead of date'},

	{label:'Convert Data'},
	{p:'applyConvertAfter',ex:true},
	{p:'offset1',canCache:true},
	{p:'offset2',canCache:true},
	{p:'scale',canCache:true},
	{p:'unit',canCache:true},			
	{p:'binDate',ex:'day|month|year',tt:'Bin the dates'},
	{p:'binType',ex:'count|average|total'},
	{p:'groupBy',ex:'field',tt:'Group the data'},
	{p:'aggregateBy',tt:'Add an extra row for the aggregated rows'},
	{p:'aggregateOperator',ex:'sum|percent',tt:'Operator to apply on the aggregated rows'},
	{p:'aggregateOperator.fieldName',ex:'sum|percent',tt:'Operator to apply on the aggregated rows for the given field'},	
	{p:'convertData', label:'Derived data',
	 ex:'derived(field=new_field_id, function=foo*bar);',
	 tt:'Add derived field'},
	{p:'convertData',label:'Convert date',
	 ex:'roundDate(round=hour|day|week|month|year);'},
	{p:'convertData',label:'Filter date',
	 ex:'filterDate(one of month=0);',	 
	 tt:'Round the dates'},
	{p:'convertData',label:'Nominal time',
	 ex:'groupTime(field=field to group time on);',
	 tt:'Round the dates'},	
	{p:'convertData', label:'Replace',
	 ex:'replace(fields=field_ids, pattern=,with=);',
	 tt:'Replace pattern in text field'},
	{p:'convertData',label:'Merge rows',
	 ex:'mergeRows(keyFields=f1\\\\,f2, operator=count|sum|average, valueFields=);',
	 tt:'Merge rows together'},
	{p:'convertData',label:'Percent increase',
	 ex:'addPercentIncrease(replaceValues=false);',
	 tt:'Add percent increase'},
	{p:'convertData',label:'Doubling rate',
	 ex:'doublingRate(fields=f1\\\\,f2, keyFields=f3);',
	 tt:'Calculate # days to double'},
	{p:'convertData',label:'Add fixed',
	 ex:'addFixed(id=max_pool_elevation\\\\,value=3700,type=double);"',
	 tt:'add fixed value'},	
	{p:'convertData',label:'Accumulate data',
	 ex:'accum(fields=);',
	 tt:'Accumulate'},
	{p:'convertData',label:'Add an average field',
	 ex:'mean(fields=);',
	 tt:'Mean'},
	{p:'convertData',label:'Unique rows',
	 ex:'unique(groupFields=f1\\\\,f2,valueField=);',
	 tt:'Uniquify rows'},
	{p:'convertData',label:'Count uniques',
	 ex:'count(field=,sort=true);',
	 tt:'Count uniques'},
	{p:'convertData',label:'Unfurl',
	 ex:'unfurl(headerField=field to get header from,uniqueField=e.g. date,valueFields=);',
	 tt:'Unfurl'},
	{p:'convertData',label:'Rotate data',
	 ex:'rotateData(includeFields=true,includeDate=true,flipColumns=true);',
	 tt:'Rotate data'},
	{p:'convertData',label:'Prune where fields are all NaN',
	 ex:'prune(fields=);',
	 tt:'Prune'},		
	{p:'convertData',label:'Scale and offset',
	 ex:'accum(scale=1,offset1=0,offset2=0,unit=,fields=);',
	 tt:'(d + offset1) * scale + offset2'},		
	{p:'convertDataPost',label:'Same as above but after filtering is done',
	 tt:'Same as above but after filtering is done'},		
	{label:'Color'},
	{p:'colors',ex:'color1,...,colorN',tt:'Comma separated array of colors'},
	{p:'colorBy',ex:'',tt:'Field id to color by'},
	{p:'colorByFields',ex:'',tt:'Show color by fields in a menu'},
	{p:'colorByLog',ex:'true',tt:'Use a log scale for the color by'},
	{p:'colorByMap',ex:'value1:color1,...,valueN:colorN',tt:'Specify colors for color by text values'},
	{p:'colorByLiteral',ex:'true',tt:'use the value as a color'},
	{p:'colorTableAlpha',ex:0.5,tt:'Set transparency on color table values'},
	{p:'colorTableInverse',ex:true,tt:'Inverse the color table'},
	{p:'colorTablePruneLeft',ex:'N',tt:'Prune first N colors'},
	{p:'colorTablePruneRight',ex:'N',tt:'Prune last N colors'},
	{p:'colorByMin',ex:'value',tt:'Min scale value'},
	{p:'colorByMax',ex:'value',tt:'Max scale value'},
	{p:'colorScale',tt:'a semi-colon delimited list of min,max,color1,color2',
	 ex:'9,14.99,palegreen,darkgreen;15,19.99,#ffc966,#ffa500;20, 24.99,red,darkred;25, 27.99,mediumpurple,purple'},



	{p:'nullColor',ex:'transparent'},
	{p:'showColorTable',ex:'false',tt:'Display the color table'},
	{p:'colorTableLabel',ex:'${field}'},
	{p:'colorTableDisplayId',tt:'Dom id to where to place the color table'},
	{p:'colorTableDots',ex:true,tt:'Show as dots'},
	{p:'colorTableDotsWidth',ex:'24px'},
	{p:'colorTableDotsDecimals',ex:'0'},
	{p:'colorTableSide',ex:'bottom|right|left|top'},
	{p:'showColorTableStride',ex:1,tt:'How many colors should be shown'},
	{p:'colorByAllRecords',ex:true,tt:'use all records for color range'},
	{p:'convertColorIntensity',ex:true},
	{p:'intensitySourceMin',ex:'0'},
	{p:'intensitySourceMax',ex:100},
	{p:'intensityTargetMin',ex:1},
	{p:'intensityTargetMax',ex:0},
	{p:'convertColorAlpha',ex:true},
	{p:'alphaSourceMin',ex:0,tt:'map value into range then map it into transparency'},
	{p:'alphaSourceMax',ex:100,tt:'map value into range then map it into transparency'},
	{p:'alphaTargetMin',ex:0,tt:'map value into range then map it into transparency'},
	{p:'alphaTargetMax',ex:1,tt:'map value into range then map it into transparency'},
	{p:'alphaMin',ex:1,tt:'set to transparent any value below the alpha min'},
	{p:'alphaMax',ex:1,tt:'set to transparent any value above the alpha max'},	
	{label:'Animation'},
	{p:'doAnimation',ex:true},
	{p:'animationMode',ex:'sliding|frame|cumulative'},
	{p:'animationUseIndex',ex:'true'},
	{p:'animationInitRange',ex:'start idx,end idx  e.g. "-50,end" or "0,10" or "0,end"'},
	{p:'animationHighlightRecord',ex:true},
	{p:'animationHighlightRecordList',ex:true},
	{p:'animationPropagateRecordSelection',ex:true,tt:'If the animation is in frame mode then propagate the date'},
	{p:'animationAcceptRecordSelection',ex:true,tt:'change the animation date on record select'},
	{p:'acceptEventAnimationChange',ex:false},
	{p:'acceptDateRangeChange',ex:true},
	{p:'animationDateFormat',ex:'yyyy'},
	{p:'animationLabelTemplate'},
	{p:'animationLabelSize',ex:'12pt'},
	{p:'animationStyle'},				
	{p:'animationTooltipShow',ex:'true'},
	{p:'animationTooltipDateFormat',ex:'yyyymmddhhmm'},		
	{p:'animationWindow',ex:'1 day|2 weeks|3 months|1 year|2 decades|etc'},
	{p:'animationStep',ex:'1 day|2 weeks|3 months|1 year|2 decades|etc'},
	{p:'animationSpeed',ex:500},
	{p:'animationLoop',ex:true},
	{p:'animationDwell',ex:1000},
	{p:'animationStartShowAll',ex:true,tt:'Show full range at start'},
	{p:'animationShowButtons',ex:false},
	{p:'animationShowLabel',ex:false},
	{p:'animationShowSlider',ex:false},
	{p:'animationWidgetShort',ex:true},
	{p:'selectFirst',ex:true,tt:'Select the first record when animating so other displays will hilight it'},
	{p:'selectLast',ex:true,tt:'Select the last record when animating so other displays will hilight it'},
    ];

    displayDefineMembers(this,myProps, {
        displayReady: Utils.getPageLoaded(),
        type: argType,
        displayManager: argDisplayManager,
        filters: [],
        dataCollection: new DataCollection(),
        selectedCbx: [],
        entries: [],
        wikiAttrs: [TITLE, "showTitle", "showDetails", "minDate", "maxDate"],
	_properties:[],
	callHook:function(func,arg1,arg2,arg3,arg4) {
	    func = "hook_" + func;
	    func = this.getProperty(func,func);
	    if(func=="none") return null;
	    if(!window[func]) {
		func = this.type+"_"+func;
	    }
	    if(window[func]) {
//		console.log("calling:" + func);
		return window[func](this,arg1,arg2,arg3,arg4);
	    } else {
//		console.log("no hook:" + func);
	    }

	},

	getWikiEditorTags: function() {
	    return this._wikiTags;
	},
	getTypeDef: function() {
	    return this.typeDef;
	},
	getTypeLabel: function() {
	    if(!this.typeDef) return null;
	    return this.typeDef.label;
	},
	getTypeHelpUrl: function() {
	    if(!this.typeDef) return null;
	    let helpUrl = this.typeDef.helpUrl;
	    if(!helpUrl) return null;
	    if(helpUrl===true) {
		return "https://ramadda.org/repository/alias/help_" + this.typeDef.type;
	    }
	    return helpUrl;
	},
	defineSizeByProperties: function() {
	    this.defineProperties([
		{inlineLabel:'Size By'},
	    	{p:'sizeBy',ex:'field',tt:'Field to size points by'},
		{p:'sizeByLog',ex:true,tt:'Use log scale for size by'},
		{p:'sizeByMap', ex:'value1:size,...,valueN:size',tt:'Define sizes if sizeBy is text'},
		{p:'sizeByRadiusMin',ex:'2',tt:'Scale size by'},
		{p:'sizeByRadiusMax',ex:'20',tt:'Scale size by'},
		{p:'sizeByLegendSide',ex:'bottom|top|left|right'},,
		{p:'sizeByLegendStyle'},
		{p:'sizeByLegendLabel'},		
		{p:'sizeBySteps',ex:'value1:size1,v2:s2,...',tt:'Use steps for sizes'},
	    ]);
	},

        getDisplayManager: function() {
            return this.displayManager;
        },
        getLayoutManager: function() {
	    let displayManager = this.getDisplayManager();
	    if(!displayManager.getLayoutManager) return null;
            return displayManager.getLayoutManager();
        },

	createTagDialog: function(cbxs,  anchor,cbxChange, type,label) { 
	    let cbxInner = HU.div([ATTR_STYLE,HU.css("margin","5px", "width","600px;","max-height","300px","overflow-y","auto")],    Utils.wrap(cbxs,"",""));
	    let inputId = HU.getUniqueId("input_");
	    let input = HU.input("","",[ATTR_STYLE,HU.css("width","300px;"), ATTR_PLACEHOLDER,'Search for ' + label.toLowerCase(),ATTR_ID,inputId]);
	    let contents = HU.div([ATTR_STYLE,HU.css("margin","10px")], HU.center(input) + cbxInner);
	    if(!this.tagDialogs) this.tagDialogs = {};
	    if(this.tagDialogs[type]) this.tagDialogs[type].remove();
	    let dialog = HU.makeDialog({content:contents,anchor:anchor,title:label,
					draggable:true,header:true});
	    this.tagDialogs[type] = dialog;
	    dialog.find(":checkbox").change(cbxChange);
	    let tags = dialog.find(".display-search-tag");
	    $("#"+inputId).keyup(function(event) {
		let text = $(this).val().trim().toLowerCase();
		tags.each(function() {
		    if(text=="")
			$(this).show();
		    else {
			let tag = $(this).attr("tag");
			if(tag) {
			    tag = tag.toLowerCase();
			    if(tag.indexOf(text)>=0)
				$(this).show();
			    else
				$(this).hide();
			}
		    }
		});
	    });
	    return dialog;
	},
	getAnimationEnabled: function() {
	    return this.getProperty("doAnimation", false);
	},
	getAnimation: function() {
	    if(!this.animationControl) {
		this.animationControl = new DisplayAnimation(this,this.getAnimationEnabled());
	    }
	    return this.animationControl;
	},
        propagateEvent: function(event, data,notThis) {
	    this.getDisplayManager().notifyEvent(event,notThis?null:this,data);
        },
        displayError: function(msg) {
            this.displayHtml(HU.getErrorDialog(msg));
        },
        clearHtml: function() {
            this.displayHtml("");
        },
        displayHtml: function(html) {
            this.setContents(html);
        },
	getEventHandler:function(event) {
	    return this[event.handler];
	},
        notifyEvent: function(event, source, data) { 
	    let func = this.getEventHandler(event);
            if (func==null) {
		if(displayDebug.notifyEventAll)
		    console.log(this.type+".notifyEvent no event handler function:" + event.name  +" " + event.handler);
                return;
            }
	    if(displayDebug.notifyEvent) {
		console.log(this.getLogLabel() +".notifyEvent calling function:" + func.name);
	    }		
            func.apply(this, [source, data]);
        },
	wikify:function(wiki,entryId,wikiCallback,wikiError,containerId) {
	    if(containerId) {
		wikiCallback = html=>{this.addWikiHtml(jqid(containerId),html);};
		wikiError = html=>{jqid(containerId).html(html);};
	    } 
	    wikiError = wikiError ?? (error=>{this.handleError(error);});
	    let url = RamaddaUtil.getUrl("/wikify");
	    $.post(url,{
		doImports:"false",
		entryid:entryId??this.getProperty("entryId"),
		wikitext:wiki},
		   wikiCallback).fail(wikiError);
	},


	myDisplayCount:DISPLAY_COUNT++,
	logMsg:function(msg, time) {
	    let label = this.getLogLabel();
	    if(time) {
		let dt = new Date();
		label += dt.getMinutes()+":" + dt.getSeconds()+":"+ dt.getMilliseconds();
	    }
	    label+=": ";
	    console.log(label+msg);
	},
	getLogLabel: function() {
	    let label = this.type + ("#"+this.myDisplayCount);
	    let name = this.getProperty("name");
	    if(name) label+=" [" + name+"]";
	    return label;
	},
	getColorTableHorizontal: function() {
	    return this.getProperty("colorTableSide","bottom") == "bottom" || this.getProperty("colorTableSide","bottom") == "top";
	},
        displayColorTableHtml: function(html, domId){
	    domId = this.getColorTableDisplayId()?? this.domId(domId);
	    let dom = jqid(domId);
	    dom.html(html);
	},

        displayColorTable: function(ct, domId, min, max, args) {
	    domId = this.getColorTableDisplayId()?? this.domId(domId);
	    //Check if it is a date
	    if(min && min.getTime)  {min  =this.formatDate(min);}
	    if(max && max.getTime)  {max  =this.formatDate(max);}	    
	    if(!args) args = {};
	    let prefix = args.field?args.field.getId()+'.':'';
	    let getProperty = (id,dflt)=>{
		return this.getProperty(prefix+id,
					this.getProperty(id,dflt));
					
	    }

	    if(args.field) args.title=args.field.getLabel();
	    args.showColorTableDots = this.getProperty(prefix+'showColorTableDots',this.getColorTableDots(this.getProperty('showColorTableDots')));
	    args.dotWidth = getProperty('colorTableDotsWidth');
	    args.decimals = getProperty('colorTableDotsDecimals',-1);
	    args.showRange = getProperty('colorTableShowRange');
	    let labels = getProperty('colorTableLabels');
	    args.labels = labels?labels.split(','):null;
	    args.labelStyle=getProperty('colorTableLabelStyle');
	    args.horizontal= this.getColorTableHorizontal();
	    args.stride = getProperty('showColorTableStride',1);
            Utils.displayColorTable(ct, domId, min, max, args);
	    let label = args.label ?? this.getProperty((args.field?args.field.getId():'')+'.colorTableLabel',this.getColorTableLabel());
	    let dom = jqid(domId);
	    if(label) {
		if(args.field) label = label.replace('${field}', args.field.getLabel(false,true));
		if(args.showColorTableDots)
		    dom.prepend(HU.center(label));
		else
		    dom.append(HU.center(label));		
	    }
	    if(!args || !args.colorByInfo) return;
	    dom.find('.display-colortable-slice').css('cursor','pointer');
	    let _this = this;
	    if(!this.originalColorRange) {
		this.originalColorRange = [min,max];
	    }		
	    dom.find('.display-colortable-slice').click(function(e) {
		let val = $(this).attr('data-value');
		let html = '';
		let items = [];
		items.push(HU.b('Range: ') +  HU.input('',min,['size',4,ATTR_CLASS,'colortable-min']) + ' - ' +
			   HU.input('',max,['size',4,ATTR_CLASS,'colortable-max']));
		items.push(HU.div([ATTR_CLASS,'ramadda-clickable ramadda-menu-item','what','reset'],'Reset range'),
			   HU.div([ATTR_CLASS,'ramadda-clickable ramadda-menu-item','what','ussedata'],'Use data range'));
		items.push(HU.checkbox('colortableuselog',[ATTR_ID,'colortableuselog'],
				       _this.getProperty('colorByLog'),'Use Log Scale'));
		html = Utils.wrap(items,'<div style=margin-bottom:4px;>','</div>');
		html = HU.hbox([html, HU.space(3),HU.b('Color Table') +'<br>' +Utils.getColorTablePopup(null,null,null,false)]);
		html =HU.div([ATTR_STYLE,HU.css('padding','8px')], html);
		if(_this.colorTableDialog) _this.colorTableDialog.remove();
		let dialog =  _this.colorTableDialog = HU.makeDialog({content:html,title:'Color Table Settings',anchor:$(this),
					     draggable:true,header:true});

		let minInput =dialog.find('.colortable-min');
		let maxInput =dialog.find('.colortable-max');		
		minInput.keypress(function(event) {
		    let keycode = (event.keyCode ? event.keyCode : event.which);
                    if (keycode!= 13) return;
		    if(!Utils.isDefined(_this.getProperty('colorByMinOrig'))) {
			_this.setProperty('colorByMinOrig',_this.getProperty('colorByMin'));
		    }
		    _this.setProperty('colorByMin',$(this).val());
		    _this.setProperty('overrideColorRange', true);
		    _this.forceUpdateUI();
		});

		maxInput.keypress(function(event) {
		    let keycode = (event.keyCode ? event.keyCode : event.which);
                    if (keycode!= 13) return;
		    if(!Utils.isDefined(_this.getProperty('colorByMaxOrig'))) {
			_this.setProperty('colorByMaxOrig',_this.getProperty('colorByMax'));
		    }
		    _this.setProperty('colorByMax',$(this).val());
		    _this.setProperty('overrideColorRange', true);
		    _this.forceUpdateUI();
		});


		dialog.find('.ramadda-colortable-select').click(function() {
		    let ct = $(this).attr('colortable');
		    if(ct) {
			_this.setProperty('colorTable',ct);
			_this.forceUpdateUI();
		    }		    
		});
		dialog.find('#colortableuselog').change(function() {
		    _this.setProperty('colorByLog',$(this).is(':checked'));
		    _this.forceUpdateUI();
		});
		dialog.find('.ramadda-menu-item').button().click(function() {
		    let what = $(this).attr('what');
		    _this.setProperty('useDataForColorRange', false);
		    if(what == 'reset') {
			_this.setProperty('colorByMin',_this.getProperty('colorByMinOrig'));
			_this.setProperty('colorByMax',_this.getProperty('colorByMaxOrig'));
			_this.setProperty('overrideColorRange', false);
		    } else  if(what == 'ussedata') {
			_this.setProperty('useDataForColorRange', true);
		    }
		    _this.forceUpdateUI();
		    minInput.val(_this.getProperty('colorByMinOrig')??min);
		    maxInput.val(_this.getProperty('colorByMaxOrig')??max);
		});
	    });
        },
	getColorList:function() {
	    if(this.colorList && this.colorList.length>0) {
		return this.colorList;
	    }
	    if (this.getProperty("colors") && this.getProperty("colors")!="default") {
		let v = this.getProperty("colors");
		if(!Array.isArray(v)) {
		    v = v.split(",");
		}
		this.colorList =  v;
	    }
	    if(!this.colorList || this.colorList.length==0) {
		this.colorList= ['blue', 'red', 'green', 'orange', 'fuchsia', 'aqua',   'navy', 'brown','cadetblue','blueviolet','coral','cornflowerblue','darkcyan','darkgoldenrod','darkorange','darkseagreen'];
	    }
	    return this.colorList;
	},
        getColorTableName: function(names) {
	    if(names && !Array.isArray(names)) {
		names  = [names];
	    }
            let ct = null;
            if (names) {
		names.every(name=>{
                    ct = this.getProperty(name);
		    if(ct) {
			if(displayDebug.colorTable)
			    this.logMsg("getColorTableName: name:" + name +" ct1:"  + ct);
			return false;
		    }
		    return true;
		});
            } else {
		let colorBy = this.getProperty("colorBy");
		if(colorBy) {
                    ct = this.getProperty("colorTable." + colorBy);
		    if(ct && displayDebug.colorTable)
			this.logMsg("getColorTableName: " + "colorTable." + colorBy+" ct2:"  + ct);
		}
		if(!ct) {
                    ct = this.getProperty("colorBar", this.getProperty("colorTable"));
		    if(ct && displayDebug.colorTable)
			this.logMsg("getColorTableName: ct3:"  + ct);
		}
            }
            if (ct == "none") return null;
	    if(displayDebug.colorTable) this.logMsg("getColorTableName:" + names +" color table:" + ct);
            return ct;
        },
	getColorTable: function(justColors, names, dflt) {
	    if(names && !Array.isArray(names)) {
		names  = [names];
	    }
	    if(names) {
		names =names.filter(name=>{
		    return name!=null;
		});
	    }

	    if(names && justColors && this.dynamicProperties && names.includes("colorTable")) {
		let ct;
		let gotOne = false;
		names.every(name=>{
		    if(this.dynamicProperties[name])
			gotOne = true;
		    return !gotOne;
		});
		if(!gotOne && this.dynamicProperties['colors']) {
		    let colors = this.dynamicProperties['colors'];
		    if(!Array.isArray(colors)) {
			//Check for commas
			colors = colors.replace(/\\,/g,"_comma_");
			colors = colors.split(",");
			colors = colors.map(c=>{
			    return c.replace(/_comma_/g,",");
			});
			return colors;
		    }

		}
	    }
	    //Check the dynamic properties for
            let colorTable = this.getColorTableName(names);
            if (!colorTable) {
                colorTable = dflt;
            }

	    if(displayDebug.colorTable) this.logMsg("CT:" + names +" " + justColors +" name:" + colorTable);
	    return this.getColorTableInner(justColors, colorTable);
	},
	getColorTableInner: function(justColors, colorTable) {
	    let list;
            if (colorTable) {
                let ct = null;
 		if(colorTable.startsWith("colors:")) {
		    list = colorTable.substring("colors:".length).split(",");
                    return this.convertColors(list);
		}
                ct = Utils.ColorTables[colorTable];
                if (ct && justColors) {
		    return this.convertColors(ct.colors);
		}
                if (!ct && name) {
                    return this.convertColors(colorTable.split(","));
                }
                return ct;
            }
            if (this.getProperty("colors") && this.getProperty("colors")!="default") {
                let colors = this.getProperty("colors");
                if ((typeof colors) != "object") colors = colors.split(",");
		return this.convertColors(colors);
            }
            return null;
        },
	addAlpha: function(colors, alpha) {
	    if(!colors) return null;
	    alpha = Utils.isDefined(alpha)?alpha:this.getProperty("colorTableAlpha");
	    if(!Utils.isDefined(alpha)) return colors;
	    colors=  Utils.cloneList(colors);
	    let ac = [];
	    colors.forEach((c)=>{
		ac.push(Utils.addAlphaToColor(c,alpha));
	    });
	    return ac;
        },
        convertColors: function(colors) {
	    colors = this.addAlpha(colors);
	    if(this.getColorTableInverse()) {
		let tmp = [];
		for(let i=colors.length-1;i>=0;i--)
		    tmp.push(colors[i]);
		colors = tmp;
	    }
	    if(this.getProperty('colorTablePruneLeft')) {
		let tmp = [];
		for(let i=+this.getProperty('colorTablePruneLeft');i<colors.length;i++) {
		    tmp.push(colors[i]);
		}
		colors = tmp;
	    }
	    if(this.getProperty('colorTablePruneRight')) {
		let tmp = [];
		let d = +this.getProperty('colorTablePruneRight');
		for(let i=0;i<colors.length-d;i++) {
		    tmp.push(colors[i]);
		}
		colors = tmp;
	    }
	    return colors;
	},

        getColorByColors: function(records, dfltColorTable) {
            let colorBy = this.getProperty('colorBy');
            if (!colorBy) {
                return null;
            }
            let colorByField = this.getFieldById(fields, colorBy);
            if (!colorByField) {
                return null;
            }
            let obj = this.getColumnValues(records, colorByField);
            let colors = this.getColorTable();
            if (!colors) colors = Utils.getColorTable(dfltColorTable || 'blue_white_red');
            if (!colors) return null;
            let min = parseFloat(this.getProperty('colorByMin', obj.min));
            let max = parseFloat(this.getProperty('colorByMax', obj.max));
            if (colors.colors) colors = colors.colors;
            let range = max - min;
            let colorValues = [];
            for (let i = 0; i < obj.values.length; i++) {
                let value = obj.values[i];
                let percent = (value - min) / range;
                let index = parseInt(percent * colors.length);
                if (index >= colors.length) index = colors.length - 1;
                else if (index < 0) index = 0;
                colorValues.push(colors[index]);
            }
            return {
                colors: colorValues,
                min: min,
                max: max
            };
        },
	getDefaultGridByArgs: function() {
	    let doHeatmap=this.getProperty('doHeatmap',false);
	    let args =  {
		display:this,
		shape:this.getProperty('cellShape','rect'),
		color: this.getProperty('cellColor','blue'),
		stroke: !this.getProperty('cellFilled',true),
		cellSize: this.getProperty('cellSize',doHeatmap?0:4),
		cellSizeH: this.getProperty('cellSizeH',20),
		cellSizeHBase: this.getProperty('cellSizeHBase',0),
		cell3D:this.getProperty('cell3D',false),
		cellShowText:this.getProperty('cellShowText',false),
		cellLabels:Utils.split(this.getProperty('cellLabels')),
		cellFonts:Utils.split(this.getProperty('cellFonts')),
		cellLabelColors:Utils.split(this.getProperty('cellLabelColor')),
		cellLabelPositions:Utils.split(this.getProperty('cellLabelPositions')),
		cellLabelOffsetsX:Utils.split(this.getProperty('cellLabelOffsetsX')),
		cellLabelOffsetsY:Utils.split(this.getProperty('cellLabelOffsetsY')),
		doHeatmap:doHeatmap,
		operator:this.getProperty('hm.operator',this.getProperty('hmOperator','count')),
		filter:this.getProperty('hm.filter',this.getProperty('hmFilter'))
	    };
	    args.cellSizeX = +this.getProperty('cellSizeX',args.cellSize);
	    args.cellSizeY = +this.getProperty('cellSizeY',args.cellSize);
	    return args;
	},
	getIconMap: function() {
	    let iconMap;
	    let iconMapProp = this.getProperty('iconMap');
	    if (iconMapProp) {
                let toks = iconMapProp.split(',');
		iconMap = {};
                for (let i = 0; i < toks.length; i++) {
		    let toks2 = toks[i].split(':');
		    if (toks2.length > 1) {
                        iconMap[toks2[0]] = toks2[1];
		    }
		}
            }
	    return iconMap;
	},
	getColorByInfo: function(records, prop,colorByMapProp, defaultColorTable,propPrefix,lastColorBy,props) {
	    if(this.getColorByAllRecords()) {
		records = this.getRecords();
	    }
	    if(!records) return null;
	    let fields = this.getFields();
	    return new ColorByInfo(this, fields??[], records, prop,colorByMapProp, defaultColorTable, propPrefix,null,props,lastColorBy);
	},
	getColorByMap: function(prop) {
	    prop = this.getProperty(prop||'colorByMap');
	    this.debugGetProperty=false;
	    return Utils.parseMap(prop);
        },
        toString: function() {
            return  this.type + ' - ' + this.getId();
        },
        getType: function() {
            return this.type;
        },
        getClass: function(suffix) {
            if (suffix == null) {
                return this.getBaseClass();
            }
            return this.getBaseClass() + "-" + suffix;
        },
        getBaseClass: function() {
            return "display-" + this.getType();
        },
        setDisplayManager: function(cm) {
            this.displayManager = cm;
            this.setDisplayParent(cm.getLayoutManager());
        },
        setContents: function(contents,dontWrap) {
            this.clearDisplayMessage();
            if(!dontWrap)
		contents = HU.div([ATTR_STYLE,this.getProperty("displayInnerStyle",""),ATTR_CLASS, "display-contents-inner display-" + this.getType() + "-inner"], contents);
            this.writeHtml(ID_DISPLAY_CONTENTS, contents);
        },
        addEntry: function(entry) {
            this.entries.push(entry);
        },
        clearCachedData: function() {},
        setEntry: function(entry) {
	    if(displayDebug.setEntry)
		this.logMsg("setEntry:" + entry);
            this.entries = [];
            this.addEntry(entry);
            this.entry = entry;
            this.entryId = entry.getId();
            this.clearCachedData();
            if (this.properties.theData) {
		//Clear this out
		this.cacheUrl = null;
                this.dataCollection = new DataCollection();
                let attrs = {
                    entryId: this.entryId,
                    lat: this.getProperty("latitude"),
                    lon: this.getProperty("longitude"),
                };
		let oldUrl=  this.properties.theData.url;
		if(!oldUrl) {
		    oldUrl = this.getRamadda().getRoot() + "/entry/show?entryid=" + entry.getId() + "&output=points.product&product=points.json&max=5000";
		} else {
		    //this should work
		    oldUrl = oldUrl.replace(/entryid=.*?&/,"entryid=" + entry.getId()+"&");
		}
                this.properties.theData = this.data = new PointData(entry.getName(), null, null, oldUrl, attrs);
		this.startProgress();
		if(displayDebug.setEntry)
		    this.logMsg("setEntry: calling loadData:" + oldUrl);
                this.data.loadData(this);
            } else {
		this.callUpdateUI();
	    }
            let title = "";
            if (this.getShowTitle()) {
                this.jq(ID_TITLE).html(entry.getName());
            }
        },
        getTextColor: function(property, dflt) {
            if (property) return this.getProperty(property, this.getProperty("textColor",dflt));
            return this.getProperty("textColor", "#000");
        },
        getTitleHtml: function(title) {
            let titleToShow = "";
            if (this.getShowTitle()) {
                let titleStyle = HU.css("color" , this.getTextColor("titleColor","#000"));
                let bg = this.getProperty("titleBackground");
                if (bg) titleStyle += HU.css('background', bg,'padding','2px','padding-right','6px','padding-left','6px');
                titleToShow = this.getShowTitle() ? this.getDisplayTitle(title) : "";
		let entryId = this.getProperty("entryId") || this.entryId;
                if (entryId) {
                    titleToShow = HU.href(this.getRamadda().getEntryUrl(entryId), titleToShow, [ATTR_CLASS, "display-title",  ATTR_STYLE, titleStyle]);
		}
		titleToShow =HU.span([ATTR_ID,this.domId(ID_TITLE)],titleToShow);
            }

	    if(this.getProperty("showEntryIcon")) {
		let icon = this.getProperty("entryIcon");
		if(icon) titleToShow  = HU.image(icon) +" " + titleToShow;
	    }
            return titleToShow;
        },
        handleEventMapClick: function(source, args) {
            if (!this.dataCollection) return;
            let pointData = this.dataCollection.getList();
            for (let i = 0; i < pointData.length; i++) {
                pointData[i].handleEventMapClick(this, source, args.lon, args.lat);
            }
        },
	acceptEvent:function(event,dflt) {
	    return this.getProperty(event.accept,dflt);
	},
	shareEvent:function(event,dflt) {
	    return this.getProperty(event.share,dflt);
	},	
        handleEventMapBoundsChanged: function(source, args) {
	    if(this.acceptEvent(DisplayEvent.mapBoundsChanged,this.getProperty("acceptBoundsChange"))) {
		this.filterBounds  = args.bounds;
		this.callUpdateUI();
            }
        },

        handleEventFilterFieldsSelected: function(source, fields) {
	    if(fields.length>0 && (typeof fields[0] =="string")) {
		let tmp = [];
		fields.forEach(f=>{
		    f = this.getFieldById(null, f);
		    if(f) tmp.push(f);
		});
		fields=tmp;
	    }
	    let prop = "";
	    fields.forEach(f=>{
		if(prop!="") prop+=",";
		prop+=f.getId();
	    });

	    this.setProperty("filterFields",prop);
	    this.haveCalledUpdateUI = false;
            this.checkSearchBar();
        },


        handleEventFieldValueSelected: function(source, args) {
            this.setProperty("filterPattern", args.value);
            this.setProperty("patternFilterField", args.field.getId());
            this.callUpdateUI();
        },
        setDateRange: function(min, max, doDay) {
	    this.minDateObj = min;
	    this.maxDateObj = max;
	    this.dateRangeDoDay = doDay;
//	    console.log("setDateRange: " + this.minDateObj +" " + this.maxDateObj);
	},
        handleDateRangeChanged: function(source, prop) {
	    this.setDateRange(prop.minDate, prop.maxDate);
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().setDateRange(prop.minDate, prop.maxDate);
	    }
	    this.haveCalledUpdateUI = false;
	    this.dataFilterChanged();
	},
	displayFieldsChanged:  function(val, fromElsewhere) {
	    this.addToDocumentUrl(PROP_FIELDS,val);
	    this.setProperty(PROP_FIELDS,val);
	    this.callUpdateUI();
    
	    if(this.displayFieldsMenuEnums && fromElsewhere && this.getProperty("showDisplayFieldsMenu")) {
		let selected = [];
		this.jq("displayfields").val(val);
	    }
	},
        handleEventFilterChanged: function(source, prop) {
	    if(!this.acceptEvent(DisplayEvent.filterChanged, this.getProperty('acceptEventFilter',true))) {
		return;
	    }
	    this.haveCalledUpdateUI = false;
	    let properties = prop.properties;
	    if(!properties) {
		properties=[];
		properties.push(prop);
	    }
	    this.settingFilterValue = true;
	    properties.forEach(prop=> {
		let filter = this.filterMap?this.filterMap[prop.fieldId]:null;
		if(!filter) return;
		let widgetId = this.getFilterId(prop.fieldId);
		if(prop.id && prop.id.endsWith("date_from")) {
		    widgetId+="_date_from";
		} else 	if(prop.id && prop.id.endsWith("date_to")) {
		    widgetId+="_date_to";
		}
		if(prop.fieldId == "_highlight") {
		    this.jq(ID_FILTER_HIGHLIGHT).val(prop.value);
		    this.setProperty("filterHighlight", prop.value=="highlight");
		    this.dfltFilterHighlight = null;
		} else 	if(Utils.isDefined(prop.value2)) {
		    $("#" +widgetId+"_min").val(prop.value);
		    $("#" +widgetId+"_min").attr("data-value", prop.value);
		    $("#" +widgetId+"_max").val(prop.value2);
		    $("#" +widgetId+"_max").attr("data-value", prop.value2);
		} else {
		    filter.handleEventPropertyChanged(prop);
		}
	    });
	    this.settingFilterValue = false;
	    this.dataFilterChanged();
	},
        handleEventPropertyChanged: function(source, prop) {
	    let debug = displayDebug.handleEventPropertyChanged;
	    if(prop.property == "dateRange") {
		if(this.getProperty("acceptDateRangeChange")) {
		    this.handleDateRangeChanged(source, prop);
		}
		return;
	    }

	    if(prop.property == "displayFields") {
		if(!this.acceptEvent(DisplayEvent.fieldsChanged,!this.getProperty("acceptEventDisplayFieldsChange",false))) {
		    return;
		}
		this.displayFieldsChanged(prop.value, true);
		return
	    }

	    if(prop.property == "macroValue") {
		if(prop.entryId!= this.entryId) return;
		if(!this.getProperty("acceptRequestChangeEvent",true)) {
		    return;
		}
		let macros = this.getRequestMacros();
		let macro = null;
		macros.every(m=>{
		    if(m.isMacro(prop.id)) {
			macro = m;
			return false;
		    }
		    return true;
		});

		if(!macro) {
		    return;
		}
		if(macro.type=='date') return
		if(!this.getProperty("request." + macro.name + ".acceptChangeEvent",true)) {
		    return;
		}

		macro.setValue(prop);
		if(debug)
		    console.log(this.getId() +" event-reloading");
		this.reloadData();
		return;
	    }

            this.setProperty(prop.property, prop.value);
            this.callUpdateUI();
        },
        handleEventRecordList: function(source, args) {
	    if(this.getAnimationEnabled() && this.getProperty("animationHighlightRecordList")) {
		this.getAnimation().setRecordListHighlight(args.recordList);
	    }
	    if(this.getProperty("acceptEventRecordList",false)) {
		this.recordListOverride = args.recordList;
		this.haveCalledUpdateUI = false;
		this.callUpdateUI();
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    if(this.getAnimation().getEnabled() &&  !args.skipAnimation) {
		this.getAnimation().handleEventRecordHighlight(source, args);
	    }
	},
        handleEventAnimationChanged: function(source, args) {
	    if(!this.getProperty("acceptEventAnimationChange",true)) return;
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().handleEventAnimationChanged(args);
	    }
	},
        handleEventSetEntry: function(source, args) {
//	    this.logMsg("handleEventSetEntry ");
//	    console.dir(args);
	    if(this.acceptEvent(DisplayEvent.setEntry,this.getProperty(DisplayEvent.setEntry.acceptGroup,this.getProperty("acceptShareSelectedEntry",false)))) {
		if(displayDebug.setEntry)
		    console.log(this.type+".handleEventSetEntry calling setEntry:" + args.entry);
		this.setEntry(args.entry);
	    } else {
		if(displayDebug.setEntry)
		    console.log(this.type+".handleEventSetEntry not calling setEntry:" + args.entry);
	    }
	},
        propagateEventRecordSelection: function(args) {
	    if(this.getSelectPopup() && args.record) {
		let html = this.applyRecordTemplate(args.record,this.getDataValues(args.record),null, this.getSelectPopup());
		this.showDialog(html,null,null,this.getSelectPopupTitle());
	    }


	    if(displayDebug.notifyEvent)
		console.log(this.type+".propagateEventRecordSelection");
	    if(this.shareEvent(DisplayEvent.setEntry,this.getProperty(DisplayEvent.setEntry.shareGroup,this.getProperty("shareSelectedEntry")))) {
		let entryId = args.record.getValueFromField(ATTR_ID);
		if(displayDebug.setEntry)
		    console.log(this.type+" sharing entry:" + entryId);
		if(entryId) {
		    let _this = this;
		    setTimeout(async function(){
			await getGlobalRamadda().getEntry(entryId, entry => {
			    if(displayDebug.setEntry)
				console.log(_this.type+" calling notifyEvent with entry:" + entry);
			    _this.getDisplayManager().notifyEvent(DisplayEvent.setEntry, _this, {entry:entry});
			});
		    });
		}
	    }
	    if(this.shareEvent(DisplayEvent.recordSelection,true)) {
		this.getDisplayManager().notifyEvent(DisplayEvent.recordSelection, this, args);
	    }
	    if(this.getProperty("recordSelectFilterFields")) {
		let fields = this.getFieldsByIds(null,this.getProperty("recordSelectFilterFields"));
		if(fields && fields.length>0) {
		    let props = {
			properties:[]
		    };
		    fields.forEach(field=>{
			props.properties.push({
			    id:field.getId(),
			    fieldId: field.getId(),
			    value: args.record.getValue(field.getIndex())
			});
		    })
		    this.propagateEvent(DisplayEvent.filterChanged, props);
		}
	    }
	},
	findRecordIndex:function(records,record) {
	    let index =-1;
	    for(let i=0;i<records.length;i++) {
		if(records[i].getId() == record.getId()) {
		    index = i;
		    break;
		}
	    }
	    if(index<0 && this.getSelectNearestDate()) {
		let date = record.getDate();
		let nearestDate = null;
		let min =0;
		let nearestIndex = -1;
		for(let i=0;i<records.length;i++) {
		    let record = records[i];
		    let diff = Math.abs(date.getTime()-record.getDate().getTime());
		    if(nearestIndex==-1) {
			nearestIndex=0;
			nearestDate = record.getDate();
			min = diff;
			continue;
		    }
		    if(diff<min) {
			nearestIndex = i;
			min = diff;
		    }
		}
		index=nearestIndex;
	    }
	    return index;
	},

        handleEventRecordSelection: function(source, args) {
	    this.selectedRecord= args.record;
	    if(this.selectedRecord) {
		if(this.getProperty("colorThresholdField")) {
		    this.haveCalledUpdateUI = false;
		    this.callUpdateUI();
		}
		if(this.getAnimationEnabled() && source!=this.getAnimation()) {
		    if(this.getProperty("animationAcceptRecordSelection",false)) {
			let date = this.selectedRecord.getDate();
			if(date) 
			    this.getAnimation().setDateRange(date,date);
		    }
		}
		let fieldId = this.getFilterSetValueFieldId();
		if(fieldId) {
		    let field =this.getFieldById(null,fieldId);
		    if(field) {
			let value = field.getValue(this.selectedRecord);
			this.handleEventFilterChanged(this,{id:'',fieldId:field.getId(),value:value});
		    }
		}
	    }

            if (!source.getEntries) {
                return;
            }
            let entries = source.getEntries();
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let containsEntry = this.getEntries().indexOf(entry) >= 0;
                if (containsEntry) {
                    this.highlightEntry(entry);
                    break;
                }
            }
        },
        areaClear: function() {
            this.getDisplayManager().notifyEvent("areaClear", this);
        },
        handleEventEntryMouseover: function(source, args) {},
        handleEventEntryMouseout: function(source, args) {},
        handleEventFilteredTimes: function(source, args) {
	    let times=args.times;
	    if(!times) return;
	    this.getAnimation().setTimes(times);
	},
        handleEventEntrySelection: function(source, args) {
            let containsEntry = this.getEntries().indexOf(args.entry) >= 0;
            if (!containsEntry) {
                return;
            }
            if (args.selected) {
                this.jq(ID_TITLE).addClass("display-title-select");
            } else {
                this.jq(ID_TITLE).removeClass("display-title-select");
            }
        },
        highlightEntry: function(entry) {
            this.jq(ID_TITLE).addClass("display-title-select");
        },
        getEntries: function() {
            return this.entries;
        },
        getDisplayEntry: async function(callback) {
            let entries = this.getEntries();
            if (entries != null && entries.length > 0) {
                return Utils.call(callback, entries[0]);
            }
	    let entryId = this.entryId|| this.getProperty("entryId");
            if (entryId) {
                let entry;
                await this.getRamadda().getEntry(entryId, e => {
                    entry = e
                    Utils.call(callback, entry);
                });
            } else {
		Utils.call(callback, null);
	    }
        },
        hasEntries: function() {
            return this.entries != null && this.entries.length > 0;
        },
        getWaitImage: function() {
            return HU.image(RamaddaUtil.getCdnUrl("/icons/progress.gif"));
        },
	useDisplayMessage:function() {
	    return true;
	},
	setDisplayMessage:function(msg) {
	    if(this.dataLoadFailed) {
		return;
	    }
	    if(!Utils.stringDefined(msg)) {
		this.jq(ID_DISPLAY_MESSAGE).html("").hide();
		return;
	    }
	    let contents =  this.jq(ID_DISPLAY_CONTENTS);
	    let minHeight = contents.css("min-height");
	    if(!minHeight || minHeight=="0px") {
		contents.css("min-height","75px");
		contents.attr("display-set-minheight","true");
	    }
	    this.jq(ID_DISPLAY_MESSAGE).html(msg).show();
	},
	clearDisplayMessage:function() {
	    let contents =  this.jq(ID_DISPLAY_CONTENTS);
	    this.jq(ID_DISPLAY_MESSAGE).hide();
	    if(contents.attr("display-set-minheight")!=null) {
		contents.css("min-height","");
	    }
	},	
        getLoadingMessage: function(msg) {
	    if(this.getAcceptEventDataSelection()) {
		return "";
	    }

	    //Check if we didn't have any data specified
	    if(!msg && !this.getProperty("theData") && !this.getInlineDataSrc()) {
		msg = "No data specified"
	    }
	    if (!msg) msg = this.getProperty("loadingMessage", "icon_progress Loading data...");
	    if(msg=='') return '';
	    let plain = (msg=='icon_progress');
	    msg = msg.replace("icon_progress",HU.image(icon_progress));
	    if(plain) return msg;
	    if(this.useDisplayMessage()) {
		return SPACE+msg;
	    } 
            return HU.div([ATTR_STYLE, HU.css("text-align","center")], this.getMessage(SPACE + msg));
        },
	reloadData: function() {
	    this.dataLoadFailed = false;
	    this.startProgress();
	    this.haveCalledUpdateUI = false;
	    if(this.getProperty("okToLoadData",true))  {
		let pointData = this.dataCollection.getList()[0];
		pointData.loadData(this,true);
	    }
	},
        getMessage: function(msg) {
            return HU.div([ATTR_CLASS, "display-output-message"], msg);
        },
	getNoDataMessage: function() {
	    return this.getProperty("noDataMessage","No data available");
	},
        getFieldValue: function(id, dflt) {
            let jq = $("#" + id);
            if (jq.length > 0) {
                return jq.val();
            }
            return dflt;
        },
        getFieldValues: function(id, dflt) {
            let jq = $("#" + id);
            if (jq.length > 0) {
		let v = [];
		jq.each(function(){
		    v.push($(this).val());
		});
		return v;
            }
            return dflt;
        },

        getFooter: function() {
            return HU.div([ATTR_ID, this.getDomId(ID_FOOTER), ATTR_CLASS, "display-footer"],
			  HU.leftRight(HU.div([ATTR_ID, this.getDomId(ID_FOOTER_LEFT), ATTR_CLASS, "display-footer-left"], ""),
				       HU.div([ATTR_ID, this.getDomId(ID_FOOTER_RIGHT), ATTR_CLASS, "display-footer-right"], "")));
        },
        shouldSkipField: function(field) {
            if (this.skipFields && !this.skipFieldsList) {
                this.skipFieldsList = this.skipFields.split(",");
            }

            if (this.skipFieldsList) {
                return this.skipFieldsList.indexOf(field.getId()) >= 0;
            }
            return false;
        },
        fieldSelected: function(event) {
	    let _this = this;
            this.selectedFields = null;
            this.overrideFields = null;
	    this.userHasSelectedAField=true;
	    let fields = [];
	    this.fieldCheckboxes.each(function() {
                if ($(this).is(':checked')) {
		    let fieldId = $(this).attr('data-fieldid');
		    if(fieldId)
			fields.push(fieldId);
		}
	    });


            this.setProperty(PROP_FIELDS,Utils.join(fields,','));
//            this.removeProperty(PROP_FIELDS,Utils,);
            this.fieldSelectionChanged();
            if (event.shiftKey) {
                let fields = this.getSelectedFields();
                this.propagateEvent(DisplayEvent.fieldsSelected, fields);
            }
        },
        addFieldsCheckboxes: function(argFields) {
            if (!this.hasData()) {
                return;
            }
            let fixedFields = this.getPropertyFields()
            if (fixedFields != null) {
                if (fixedFields.length == 0) {
                    fixedFields = null;
                }
            }

	    let fieldsMap = null;
	    if(fixedFields!=null) {
		if(!Array.isArray(fixedFields)) fixedFields=fixedFields.split(",");
		fieldsMap = {};
		fixedFields.forEach(id=>{
		    //look for numeric field
		    if(id.startsWith("@")) {
			let index = parseInt(id.substring(1).trim())-1;
			let fidx=0;
			let fields = this.getFields();
			fields.every(field=>{
			    if(!field.isNumeric()) return true;
			    if(fidx==index) {
				fieldsMap[field.getId()]  = true;
				return false;
			    }
			    fidx++;
			    return true;
			});
			return
		    }


		    if(id.startsWith("#")) {
			let toks = id.split("-");
			if(toks.length==2) {
			    let idx1 = +toks[0].replace("#","");
			    let idx2 = +toks[1].replace("#","");			
			    for(let i=idx1;i<=idx2;i++) {
				fieldsMap["#"+i] = true;
			    }
			}
		    }
		    fieldsMap[id]  = true;
		});
	    }

	    let makeCheckboxes = this.showFieldsInDialog();
            let html = "";
            let checkboxClass = this.getId() + "_checkbox";
            let groupByClass = this.getId() + "_groupby";
            let dataList = this.dataCollection.getList();

            if (argFields != null) {
                this.overrideFields = [];
            }
            let seenLabels = {};


            let badFields = {};
            let flags = null;
            for (let collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                let pointData = dataList[collectionIdx];
                let fields = this.getFieldsToSelect(pointData);
                if (this.canDoGroupBy()) {
                    let allFields = pointData.getRecordFields();
                    let cnt = 0;
                    for (i = 0; i < allFields.length; i++) {
                        let field = allFields[i];
                        if (field.getType() != "string") continue;
                        if (cnt == 0) {
                            html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Group By");
                            html += HU.open(TAG_DIV, [ATTR_CLASS, "display-fields"]);
                            let on = this.groupBy == null || this.groupBy == "";
                            html += HU.tag(TAG_DIV, [ATTR_TITLE, "none"],
					   HU.radio("none", this.getDomId("groupby"), groupByClass, "none", !on) + " None");
                        }
                        cnt++;
                        let on = this.groupBy == field.getId();
                        let idBase = "groupby_" + collectionIdx + "_" + i;
                        field.radioId = this.getDomId(idBase);
                        html += HU.tag(TAG_DIV, [ATTR_TITLE, field.getId()],
				       HU.radio(field.radioId, this.getDomId("groupby"), groupByClass, field.getId(), on) + " " + field.getUnitLabel() + " (" + field.getId() + ")"
				      );
                    }
                    if (cnt > 0) {
                        html += HU.close(TAG_DIV);
                    }
                }


                let disabledFields = "";
                if ( /*this.canDoMultiFields() && */ fields.length > 0) {
                    let selected = this.getSelectedFields([]);
                    let selectedIds = [];
                    for (let i = 0; i < selected.length; i++) {
                        selectedIds.push(selected[i].getId());
                    }
                    html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Displayed Fields");
                    html += HU.open(TAG_DIV, [ATTR_CLASS, "display-fields"]);
                    for (let tupleIdx = 0; tupleIdx < fields.length; tupleIdx++) {
                        let field = fields[tupleIdx];
                        let idBase = "cbx_" + collectionIdx + "_" + tupleIdx;
                        field.checkboxId = this.getDomId(idBase);
                        let on = false;
                        let hasValues = (flags ? flags[field.getIndex()] : true);
//                        console.log(tupleIdx + " field: " + field.getId() + "has values:" + hasValues);
                        if (argFields != null) {
                            //console.log("argFields:" + argFields);
                            for (let fIdx = 0; fIdx < argFields.length; fIdx++) {
                                if (argFields[fIdx].getId() == field.getId()) {
                                    on = true;
//				    if(on)    console.log('ON-0',field.getId());
                                    this.overrideFields.push(field.getId());
                                    break;
                                }
                            }
                        } else if (selectedIds.length > 0) {
                            on = selectedIds.indexOf(field.getId()) >= 0;
//			    if(on)    console.log('ON-1',field.getId());

                        }
//			if(on)    console.log('on-0',field.getId());
			if(!on) {
			    if (fieldsMap != null) {
				on = fieldsMap[field.getId()];
				if (!on) {
                                    on = fieldsMap["#" + (tupleIdx + 1)];
				}
//				if(on) console.log('on-1',field.getId());
                            } else if (this.overrideFields != null) {
				on = this.overrideFields.indexOf(field.getId()) >= 0;
				if (!on) {
                                    on = (this.overrideFields.indexOf("#" + (tupleIdx + 1)) >= 0);
				}
//				if(on) console.log('on-2',field.getId());
                            } else {
				if (this.selectedCbx.indexOf(field.getId()) >= 0) {
                                    on = true;
//				    if(on) console.log('on-3',field.getId());
				} else if (this.selectedCbx.length == 0) {
                                    on = (tupleIdx == 0);
//				    if(on) console.log('on-4',field.getId());
				}
			    }
                        }
//			if(on)    console.log('ON',field.getId(),on);
                        let label = field.getUnitLabel();
                        if (seenLabels[label]) {
                            label = label + " " + seenLabels[label];
                            seenLabels[label]++;
                        } else {
                            seenLabels[label] = 1;
                        }

                        if (!hasValues) {
                            disabledFields += HU.div([], label);
                        } else {
                            if (field.derived) {
                                label += " (derived)";
                            }
                            let widget;
			    if(!makeCheckboxes) {
				html += HU.tag(TAG_DIV, [],label + ' - ' +field.getId());
			    } else {
				if (this.canDoMultiFields()) {
                                    widget = HU.checkbox(field.checkboxId, [ATTR_CLASS, checkboxClass,
									    'data-fieldid',field.getId(),
									    ATTR_TITLE,field.getId() +' - '+ field.getType()], on,label);
				    html += HU.tag(TAG_DIV, [ATTR_TITLE, field.getId()], widget);
				} else {
                                    widget = HU.radio(field.checkboxId, "field_radio", checkboxClass, "", on,
						      HU.attrs(['data-fieldid',field.getId()]));
				    html += HU.tag(TAG_DIV, [ATTR_TITLE, field.getId()],  widget + " " + label);
				}
			    }
                        }
                    }
                }
                if (disabledFields != "") {
                    html += HU.div([ATTR_STYLE, HU.css("border-top","1px #888  solid")], "<b>No Data Available</b>" + disabledFields);
                }
                html += HU.close(TAG_DIV);
            }
            this.writeHtml(ID_FIELDS, html);
            let _this = this;
            //Listen for changes to the checkboxes
	    this.fieldCheckboxes = $("." + checkboxClass);
	    this.fieldCheckboxes.click(function(event) {
                _this.fieldSelected(event);
            });

            $("." + groupByClass).change(function(event) {
                _this.groupBy = $(this).val();
                if (_this.displayData) {
                    _this.displayData();
                }
            });
        },
        fieldSelectionChanged: function() {
            this.setDisplayTitle();
            if (this.displayData) {
                this.clearCachedData();
                this.displayData();
            }
        },
        defaultSelectedToAll: function() {
            return true;
        },
        setSelectedFields: function(fields) {
            this.clearCachedData();
            this.selectedFields = fields;
            this.addFieldsCheckboxes(fields);
        },
        getSelectedFields: function(dfltList) {
	    let prefixFields = this.getProperty('prefixFields');
	    let debug = displayDebug.getSelectedFields || this.getProperty('debugFields');
	    if(debug)
		console.log(this.type +".getSelectedFields");
	    if(this.getBinDate()) {
		let binType = this.getBinType("total");
		let binCount = binType=="count";
		if(binCount) {
		    let fields = [];
		    fields.push(new RecordField({
			id:binType,
			label:this.getProperty("binDateLabel", this.getProperty("binCountLabel","Count")),
			type:"double",
			chartable:true
		    }));		    
		    return fields;
		} 
	    }

            this.debugSelected = debug;
            this.lastSelectedFields = this.getSelectedFieldsInner(dfltList);
	    let notFields = this.getProperty("notFields");
	    if(notFields) {
		this.lastSelectedFields = this.lastSelectedFields.filter(f=>{
		    if(f.getId().match(notFields) || f.getLabel().match(notFields)) return false;
		    return true;
		});
	    }


	    if(debug)
		console.log("\tsetting lastSelectedFields:" + this.lastSelectedFields);
            this.setDisplayTitle();
	    if(this.getBinDate()) {
		let binType = this.getProperty("binType","total");
		let fields = [];
		this.lastSelectedFields.forEach(field=>{
		    if(!field.isNumeric()) {
			fields.push(field);
		    } else {
			const prefix = binType;
			if(field.getId().startsWith(prefix)) {
			    fields.push(field);
			} else {
			    fields.push(new RecordField({
				id:prefix +"_"+ field.getId(),
				index:  field.getIndex(),
				label:this.getProperty("binDateLabel", Utils.camelCase(binType) +" of " + field.getLabel()),
				type:"double",
				chartable:field.isChartable()
			    }));
			}
		    }
		});
		this.lastSelectedFields = fields;
//		console.log("BIN DATE:" + this.lastSelectedFields);
	    }


	    let result =  Utils.cloneList(this.lastSelectedFields??[]);
	    if(prefixFields) {
		let p  =this.getFieldsByIds(null, prefixFields);
		if(p.length) result = [...p,...result];
	    }
	    return result;

        },
        getSelectedFieldsInner: function(dfltList) {
	    let debug = this.debugSelected;
//	    debug=true;
            if (debug) {
                console.log("getSelectedFieldsInner dflt:" + (dfltList ? dfltList : "null"));
                console.log("\tlast selected = " + this.lastSelectedFields);
	    }
            if (this.selectedFields) {
                if (debug)
                    console.log("\treturning this.selectedFields:" + this.selectedFields);
                return this.selectedFields;
            }
            let df = [];
            let dataList = this.dataCollection.getList();
            //If we have fixed fields then clear them after the first time
            let fixedFields = this.getPropertyFields();

            if (fixedFields && (typeof fixedFields) == "string") {
                fixedFields  = fixedFields.split(",");
	    }
	    if(fixedFields) {
		let tmpFields  = [];
		fixedFields.forEach(tok=>{
		    if(!tok.match("-")) {
			tmpFields.push(tok);
			return;
		    }
		    let pair = tok.split("-");
		    let i1 = parseFloat(pair[0].trim().substring(1));
		    let i2 = parseFloat(pair[1].trim().substring(1));
		    for(let i=i1;i<=i2;i++) tmpFields.push("#" + i);
		});
		fixedFields = tmpFields;
	    }


	    let aliases= {};
	    let tmp = this.getFieldAliases();
	    if(tmp) {
		tmp.split(",").forEach(tok=>{
		    [name,alias] =   tok.split(":");
		    aliases[alias] = name;
		});
	    }
            for (let collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                let pointData = dataList[collectionIdx];
		//A hack in case we already have a pointData set (e.g., in the case of a convertDataPost)
		if(this.pointData) pointData = this.pointData;
                let fields = this.getFieldsToSelect(pointData);
		//xxx
//		console.log(fields.map(f=>{return f.getId() + '-' + f.getLabel();}));
                if (fixedFields != null && fixedFields.length > 0) {
                    if (debug)
                        console.log("\thave fixed fields:" + fixedFields);
		    let selected = [];
                    for (let i = 0; i < fixedFields.length; i++) {
                        let sfield = fixedFields[i];
			if(sfield =="*") {
			    selected  =fields;
			    break;
			}
			let field = this.getFieldById(fields, sfield);
                        if(field) {
			    selected.push(field);
			}
                    }
		    if(this.getProperty("fieldsNumeric")) {
			selected = selected.filter(f=>f.isNumeric());
		    }		    
		    df = selected;
		}
	    }

            if (fixedFields != null && fixedFields.length > 0) {
                if (debug)
                    console.log("\tfrom fixed:" + df.length);
                return df;
            }


            if (debug)
                console.log("\tuser has selected");
            let fieldsToSelect = null;
            this.selectedCbx = [];
            for (let collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                fieldsToSelect = this.getFieldsToSelect(dataList[collectionIdx]);
            }

            if (df.length == 0) {
                if (this.lastSelectedFields && this.lastSelectedFields.length > 0) {
                    if (debug)
                        console.log("\tlastSelectedFields:" + this.lastSelectedFields);
                    return this.lastSelectedFields;
                }
            }
            if (df.length == 0) {
                df = this.getDefaultSelectedFields(fieldsToSelect, dfltList,this.debugSelected);
                if (debug)
                    console.log("\tusing default selected:" + df);
            }

            return df;
        },
        getDefaultSelectedFields: function(fields, dfltList,debugArg) {
	    let debug = debugArg||displayDebug.getDefaultSelectedFields;
	    if(debug)
		console.log("getDefaultSelectedFields");
	    let patterns = this.getProperty("fieldsPatterns");
	    if(patterns) {
		let allFields = this.getFields();
		if(allFields) {
		    let debugPatterns = false;
		    let matched=[];
		    if(debugPatterns)
			console.log("fields:" +allFields);
		    patterns.split(",").forEach(pattern=>{
			if(debugPatterns)
			    console.log("\tpattern:" + pattern);
			allFields.every(f=>{
			    if(!f.isFieldNumeric()) return true;
			    let id = f.getId().toLowerCase();
			    if(debugPatterns)
				console.log("\t\tid:" + id);
			    if(id.match(pattern)) {
				if(debugPatterns)
				    console.log("\t\tmatch");
				if(!matched.includes(f)) {
				    if(debugPatterns)
					console.log("\t\tadd to matched");
				    //				    console.log("\tmatches:"+ id);
				    matched.push(f);
				    return false;
				}
			    }
			    return true;
			});
		    });
		    if(debugPatterns)
			console.log("returning:" + matched);
		    if(matched.length)
			return matched;
		}
	    }
            if (this.defaultSelectedToAll()) {
		let allFields = this.getFields();
                let tmp = [];
		if(allFields) {
                    for (i = 0; i < allFields.length; i++) {
			let field = allFields[i];
			if (!field.isFieldGeo()) {
                            tmp.push(field);
			}
                    }
		}
		if(debug)
		    console.log("\treturning allFields:" + tmp);
                return tmp;
            }

            if (dfltList != null) {
		if(debug)
		    console.log("\treturning dfltList:" + dfltList);
                return dfltList;
            }
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.isNumeric() && !field.isFieldGeo()) return [field];
            }
            return [];
	},

	    
	sortRecords: function(records, sortFields,sortOnDate) {
	    if(this.getSortOnDate() || sortOnDate) {
		//Clone the list
		records = Utils.cloneList(records);
		records.sort(function(a, b) {
		    if (a.getDate() && b.getDate()) {
			if (a.getDate().getTime() < b.getDate().getTime()) return -1;
			if (a.getDate().getTime() > b.getDate().getTime()) return 1;
			return 0;
		    }
		});
	    }

	    if(sortOnDate) return records;


	    if(!sortFields) {
		let f = this.getProperty("sortFields", "", true);
		if(f=="${fields}") f = this.getProperty("fields", "", true);
		sortFields = this.getFieldsByIds(null, f);
		if(sortFields.length==0 && this.sortByFields && this.sortByFields.length>0) {
		    sortFields = [this.sortByFields[0]];
		}
	    }


	    if(sortFields.length>0) {
		records = Utils.cloneList(records);
		let sortAscending = this.getSortAscending();
		let cnt = 0;
		records.sort((a,b)=>{
		    let row1 = this.getDataValues(a);
		    let row2 = this.getDataValues(b);
		    let result = 0;
		    for(let i=0;i<sortFields.length;i++) {
			let sortField = sortFields[i];
			let v1 = row1[sortField.getIndex()];
			let v2 = row2[sortField.getIndex()];
//			console.log(v1,v2);
			if(sortField.isNumeric() || sortField.isFieldDate()) {
			    if(isNaN(v1) && isNaN(v2)) {
				result= 0;
			    } else if(isNaN(v1)) {
				result = sortAscending?-1:1;
			    } else if(isNaN(v2)) {
				result = sortAscending?1:-1;
			    } else {
				if(v1<v2) result = sortAscending?-1:1;
				else if(v1>v2) result = sortAscending?1:-1;
				else result = 0;
			    }
			} else {
			    result = String(v1).localeCompare(String(v2));
			    if(!sortAscending) result=-result;
			}
			if(result!=0) break;
		    }
		    return result;
		});
	    }

	    
	    /*
	    console.log("results " + sortFields);
	    records.forEach(record=>{
		let row1 = this.getDataValues(record);
		let sortField = sortFields[0];
		console.log('\t'+row1[1] +' '+ row1[sortField.getIndex()]);
		});
	    */
	    

	    if(this.getProperty("sortHighlight")) {
		records = Utils.cloneList(records);
		records.sort((a,b)=>{
		    let h1 = a.isHighlight(this);
		    let h2 = b.isHighlight(this);
		    if(h1 && !h2)
			return -1;		    
		    if(!h1 && h2)
			return 1;		    
		    return 0;
		});
	    }

	    if(this.getReverse()) {
		records = Utils.cloneList(records);
		let tmp = [];
		for(let i=records.length-1;i>=0;i--)
		    tmp.push(records[i]);
		records = tmp;
	    }

	    return records;
	},
        getFieldById: function(fields, id,debug,ignore,foo) {
	    //Support one arg
	    if(debug)
		console.log("getFieldById:" + id);
	    if(fields!=null && id==null) {
		if(typeof fields!="string") {
		    if(debug)
			console.log("\tbadfields:" + fields);
		    return null;
		}
		id = fields;
		fields=null;
	    }
            if (!id) {
		if(debug)
		    console.log("\tno id");
		return null;
	    }
	    id = String(id).trim();
	    if (!fields) {
                let pointData = this.getData();
                if (pointData == null) {
		    if(debug)
			console.log("\tno data");
		    return null;
		}
                fields = pointData.getRecordFields();
		if(debug) {
		    console.log("\tusing  fields:" + fields);
		}
            }
	    if (!fields) {
		return null;
	    }
	    let aliases= {};
	    let tmp = this.getFieldAliases();
	    if(tmp) {
		tmp.split(",").forEach(tok=>{
		    [name,alias] =   tok.split(":");
		    aliases[alias] = name;
		});
	    }
	    let theField = null;
	    id.split("|").every(fieldId=>{
		let alias = aliases[fieldId];
		let hasRegexp = fieldId.indexOf("*")>=0;
		let numericCnt = 0;
		for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
		    if(field.isFieldNumeric()) numericCnt++;
		    if(debug)	{
			console.log("\tField:" + field.getId());
		    }

		    if(fieldId=="#") {
			if(field.isFieldNumeric()) {
			    theField =  field;
			    return false;
			}
			continue;
		    }
		    if(fieldId==('@'+numericCnt)) {
			theField = field;
			return false;
		    }

                    if (field.getId() == fieldId || fieldId == ("#" + (i+1)) || field.getId()==alias) {
			theField =  field;
			if(debug)
			    console.log("\tgot it:" + theField);
			return false;
                    }
		    if(hasRegexp) {
			if(field.getId().match(fieldId)) {
			    theField =  field;
			    if(debug)
				console.log("\tgot it from pattern:" + theField);
			    return false;
			}
		    }
		}
		return true;
	    });
	    if(debug || displayDebug.getSelectedFields)
		console.log("\tgot:" + theField);
	    if(!theField && !ignore) {
		if(debug || displayDebug.getSelectedFields || this.getProperty('debugFields')) {
		    this.logMsg("can't find field field:" + id);
		    console.log(fields.reduce((acc,f)=>{
			return acc+' ' + f.getId();
		    },''));
		}

	    }
	    
            return theField;
        },

        getFieldsByIds: function(fields, ids) {
	    if (!fields) {
                let pointData = this.getData();
                if (pointData != null) {
                    fields = pointData.getRecordFields();

		}
            }

	    if(!fields) return [];

            let result = [];
            if (!ids) {
		return result;
	    }
	    if(ids=="*") return fields;
	    if(ids=="#") {
		return  fields.filter(f=>{
		    return !f.isFieldLongitude() &&
			!f.isFieldLatitude() &&
			f.isFieldNumeric();
		});
	    }
            if ((typeof ids) == "string")
                ids = ids.split(",");
            if (!fields) {
                let pointData = this.getData();
                if (pointData == null) {
		    return null;
		}
                fields = pointData.getRecordFields();
            }

            for (let i = 0; i < ids.length; i++) {
		let id = ids[i];
		//Check for numeric range
		if(id.startsWith("#")) {
		    let toks = id.split("-");
		    if(toks.length==2) {
			let idx1 = +toks[0].replace("#","");
			let idx2 = +toks[1].replace("#","");			
			for(let j=idx1;j<=idx2;j++) {
			    let f = this.getFieldById(fields, "#" + idx1);
			    if (f) result.push(f);
			}
			continue;
		    }
		}
                let f = this.getFieldById(fields, ids[i]);
                if (f) result.push(f);
            }
            return result;
        },

        getFieldByType: function(fields, type) {
            fields = this.getFieldsByType(fields, type);
            if (fields.length == 0) return null;
            return fields[0];
        },
        getFieldsByType: function(fields, type) {
            if (!fields) {
                let pointData = this.getData();
                if (pointData == null) return null;
                fields = pointData.getRecordFields();
            }
            let list = [];
            let numeric = (type == "numeric");
            let isString = (type == "string");
            for (a in fields) {
                let field = fields[a];
		if(field.isRecordDate()) continue;
                if (type == null) return field;
                if (numeric) {
                    if (field.isFieldNumeric()) {
                        list.push(field);
                    }
                } else if(isString) {
                    if (field.isFieldString()) {
                        list.push(field);
                    }
                    
                } else if (field.getType() == type) {
                    list.push(field);
                }
            }
            return list;
        },
	getDateValues: function(records) {
	    let dates = [];
	    records.forEach(r=>{
		dates.push(r.getDate());
	    });
	    return dates;
	},
        getColumnValues: function(records, field) {
            let values = [];
            let min = Number.MAX_VALUE;
            let max = Number.MIN_VALUE;
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let record = records[rowIdx];
                let row = record.getData();
                let value = row[field.getIndex()];
                values.push(value);
                if (Utils.isNumber(value) && !isNaN(value)) {
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
            return {
                values: values,
                min: min,
                max: max
            };
        },
        requiresGrouping:  function() {
            return false;
        },
	makeTree: function(records) {
	    if(records==null)  {
		records = this.getRecords();
            }
	    if(records==null)  return;
	    let treeTemplate = this.getProperty("treeTemplate");
	    let treeTooltip = this.getProperty("treeTooltip");
	    let roots = [];
	    let idToNode = {};
	    let nodes=[];
	    let idToRoot = {};
	    let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    let nodeFields = this.getFieldsByIds(null, this.getProperty("nodeFields"));
	    let treeRootLabel = this.getProperty("treeRoot");
	    let treeRoot = null;
	    if(treeRootLabel) {
		treeRoot = {id:treeRootLabel,label:treeRootLabel,children:[],parent:null};
		roots.push(treeRoot);
	    }
	    if(nodeFields.length>0) {
		let cnt = 0;
		let valueToNode = {};
		let parentId = "";
		records.forEach(r=>{
		    let label= labelField==null?id:r.getValue(labelField.getIndex());		
		    let parentId = null;
		    let parentNode= null;
		    //		    console.log("record:" + label);

		    nodeFields.forEach(nodeField=>{
			let id = r.getValue(nodeField.getIndex());
			let nodeId = parentId?parentId+"-"+id:id;
			let tmpNode = idToNode[nodeId];
			if(!tmpNode) {
			    tmpNode = {id:nodeId,label:id,children:[],parent:parentNode};
			    idToNode[nodeId] = tmpNode;
			    if(!parentNode) {
				if(treeRoot) {
				    tmpNode.parent = treeRoot;
				    treeRoot.children.push(tmpNode);
				} else {
				    roots.push(tmpNode);
				}
			    }
			    if(parentNode) {
				parentNode.children.push(tmpNode);
			    }
			}
			parentId = nodeId;
			parentNode = tmpNode;
		    });
		    let id= "leaf" + (cnt++);
		    let node = {id:id,label:label,children:[],record:r, parent:parentNode};
		    parentNode.children.push(node);
		    idToNode[id] = node;
		    nodes.push(node);
		});
		return roots;
	    }

	    //{label:..., id:...., record:...,	    children:[]}
            let parentField = this.getFieldById(null, this.getProperty("parentField"));
	    let idField = this.getFieldById(null, this.getProperty("idField"));
	    if(!parentField) {
		throw new Error("No parent field specified");
	    }
	    if(!idField) {
                throw new Error("No id field specified");
	    }
	    records.forEach(r=>{
		let parent = r.getValue(parentField.getIndex());
		let id = r.getValue(idField.getIndex());
		let label= labelField==null?id:r.getValue(labelField.getIndex());		
		let node = {id:id,label:label,children:[],record:r,parentId:parent, parent:null};
		if(treeTemplate) {
		    node.display = this.getRecordHtml(r, null, treeTemplate);
		}
		if(treeTooltip) {
		    node.tooltip = this.getRecordHtml(r, null, treeTooltip);
		}
		idToNode[id] = node;
		nodes.push(node);
		if(parent=="") {
		    //is a root
		    idToRoot[id]=node;
		    if(treeRoot) {
			node.parent = treeRoot;
			node.parentId = treeRoot.id;
			treeRoot.children.push(node);
		    } else {
			roots.push(node);
		    }
		}
	    });
	    nodes.forEach(node=>{
		let parentNode = idToNode[node.parentId];
		if(!parentNode) {
		    if(!idToRoot[node.id]) {
			throw new Error("No parent :" + node.parentId +" for node:" + node.label);
		    }
		    return;
		}
		node.parent= parentNode;
		parentNode.children.push(node);
	    });

	    return roots;
	},
	getSegments: function() {
	    let segments = this.getProperty("timeSegments");
	    if(!segments) return null;
	    let result = [];
	    let segmentList = segments.split(",");
	    segmentList.forEach((tok,segmentIdx)=>{
		let toks = tok.split(";");
		let name = toks[0];
		let start = Utils.parseDate(toks[1],false);
		let end = Utils.parseDate(toks[2],false);
		result.push({name: name, start:start,end:end});
	    });
	    return  result;
	},
	requiresGeoLocation: function() {
	    return false;
	},
	checkDataFilters: function(dataFilters, record) {
	    if(!dataFilters) {return true;}
	    for(let i=0;i<dataFilters.length;i++) {
		if(!dataFilters[i].isRecordOk(record)) return false;
	    }
	    return true;
	},
	getTheDataFilters: function(v) {
	    return DataUtils.getDataFilters(this, v || this.getDataFilters());
	},
	dfltFilterHighlight:null,
	getFilterHighlight: function() {
	    if(!this.dfltFilterHighlight) {
		this.dfltFilterHighlight = {
		    filterHighlight:this.getProperty("filterHighlight",false)
		}
	    }
	    return this.dfltFilterHighlight.filterHighlight;
	},
	getFilterTextMatchers: function() {
	    let highlight  = [];
	    if(this.filters) {
		for(let filterIdx=0;filterIdx<this.filters.length;filterIdx++) {
		    let filter = this.filters[filterIdx];
		    let widget =jqid(filter.getWidgetId());
		    if(widget.length==0 || !widget.val || widget.val()==null) continue;
		    let value = widget.val()??"";
		    if(!Utils.stringDefined(value)) continue;
		    let id = filter.getId();
		    if(id=='_text_') id=null;
		    highlight.push(new TextMatcher(value,id));
		}
	    }
	    return highlight;
	},

	filterDataPhase2:function(records) {
	    return records;
	},

	filterData: function(records, fields, args) {
            if (!records)  records =this.getRecords();
	    let filteredRecords = this.filterDataInner(records,fields, args);
	    if(filteredRecords) {
		if(this.getPropagateFilteredTimes()) {
		    if(filteredRecords.length!=records.length) {
			let times=[];
			let seen = {};
			filteredRecords.forEach(record=>{
			    let date = record.getDate();
			    if(!date) return;
			    if(!seen[date]) {
				seen[date] = true;
				times.push(date);
			    }
			});
			if(times.length) {
	                    this.propagateEvent(DisplayEvent.filteredTimes, {times:times});
			}
		    }
		}		    
	    }
	    if(this.shareEvent(DisplayEvent.filteredDataChanged,false)) {
		this.getDisplayManager().notifyEvent(DisplayEvent.filteredDataChanged, this, {
		    records:filteredRecords
		});
	    }

	    if(this.getApplyConvertAfter()) {
		let tmp = new  PointData("pointdata", this.originalPointData.recordFields, filteredRecords);
		//xxxx
		tmp = this.convertPointData(tmp);
		this.convertedFields = tmp.getRecordFields();
		filteredRecords = tmp.getRecords();
	    }	    


	    return filteredRecords
	},
        handleEventFilteredDataChanged: function(source, args) {
	    this.propagatedFilteredRecords = args.records;
	    if(args.records) {
		this.forceUpdateUI();
	    }
	},
	findUnique:function(records, ufield) {
	    if(!ufield) return records;
	    let umap = {};
	    let ulist = [];
	    for(let i=records.length-1;i>=0;i--) {
		let record = records[i];
		let v = record.getValue(ufield.getIndex());
		if(!Utils.isDefined(umap[v])) {
		    umap[v] = true;
		    ulist.push(record);
		}
	    }
	    return ulist;
	},
	filterDataInner: function(records, fields, args) {
	    if(this.propagatedFilteredRecords && this.originalPointData) {
//		console.log('filter data before',this.propagatedFilteredRecords[0].data);
		let tmp = new  PointData("pointdata", this.originalPointData.recordFields, this.propagatedFilteredRecords);
		tmp = this.convertPointData(tmp);
//		console.log('filter data after convert:',tmp.getRecords()[0].data);
		records =tmp.getRecords();
	    }

	    if(this.recordListOverride) {
		return this.recordListOverride;
	    }
	    let opts = {
		doGroup:false,
		skipFirst:false,
		applyDateRange: true,
		recordOk:null
	    }
	    if(args)
		$.extend(opts,args);
	    let debug =  displayDebug.filterData;
	    if(debug) this.logMsg("filterData");


	    if(this.getAnimationEnabled()) {
		if(this.getProperty("animationFilter", true)) {
		    this.setDateRange(this.getAnimation().begin, this.getAnimation().end);
		}
	    }


	    let highlight =  this.getFilterHighlight();
	    let startDate = this.getProperty("startDate");
	    let endDate = this.getProperty("endDate");
	    if(startDate) {
		this.startDateObject = Utils.createDate(startDate,+this.getTimeZoneOffset());
		if(debug)
		    this.logMsg(this.type +" start date:" + startDate + " dttm:" + this.startDateObject.toUTCString());
	    } 
	    if(endDate) {
		this.endDateObject = Utils.createDate(endDate,+this.getTimeZoneOffset());
		if(debug)
		    this.logMsg(this.type +"end date:" +this.endDateObject.toUTCString());
	    } 



	    let filterDate = this.getProperty("filterDate");
	    if(filterDate) {
		let date = $("#"+ this.getFilterId(ID_FILTER_DATE)).val();
		if(date) {
		    if(date=="all") {
			this.setDateRange(null,null);
		    } else {
			date = new Date(date);
			if(filterDate == "year") {
			    let end = date.getFullYear()+1;
			    this.setDateRange(new Date(date.getFullYear()+"-01-01"),
					      new Date(end+"-01-01"));
			} else if(filterDate == "day") {
			    let f = date.getUTCFullYear() + "-" + (date.getUTCMonth() + 1) +"-" + date.getUTCDate();
			    let dttm = new Date(f);
			    this.setDateRange(dttm,dttm, true);
			} else {
			    //TODO month and day
			}
		    }
		}
	    }


            if (!records) {
		return null;
	    }


            if (!fields) {
                fields = this.getFields();
            }
            if(opts.doGroup || this.requiresGrouping()) {
		let pointData = this.getData();
                records = pointData.extractGroup(this.dataGroup, records);
            }

	    if(debug)   this.logMsg("filter #records:" + records.length);
	    if(this.getProperty("filterLatest")) {
		let fields = this.getFieldsByIds(null,this.getProperty("filterLatest"));
		let max = {};
		let keyToRecord = {};
		let tmp = [];
		let keys = [];
		records.forEach(record=>{
		    if(!record.getTime()) return;
		    let key = "";
		    fields.forEach(f=>{
			key+="_" + record.getValue(f.getIndex());
		    });
		    let maxRecord = keyToRecord[key];
		    if(!maxRecord) {
			keyToRecord[key] = record;
			keys.push(key);
		    } else {
			if(record.getDate().getTime()>maxRecord.getDate().getTime()) keyToRecord[key] = record;
		    }
		});


		keys.forEach(key=>{
		    tmp.push(keyToRecord[key]);
		});
		records  =tmp;
	    }


	    records.forEach(r=>{
		r.clearHighlight(this);
	    });

//	    debug=true;
//	    if(debug)   this.logMsg("checking dates");
	    records = records.filter((record,idx)=>{
                let date = record.getDate();
		return this.dateInRange(date,idx,idx<5 && debug);
	    });
	    if(debug)   this.logMsg("filter Fields:" + this.filters.length +" #records:" + records.length);



//	    debug = this.type=='template';
	    if(this.filters.length) {
		let newData = [];
		let logic = this.getProperty("filterLogic","and");
		this.filters.forEach(f=>f.prepareToFilter(debug));
		if(debug)
		    this.logMsg("filter:" + this.filters.length+' #records:' + records.length);
		records.forEach((record,rowIdx)=>{
		    let _debug = rowIdx<5&&debug;
		    let allOk = true;
		    let anyOk = false;		    
		    this.filters.forEach(filter=>{
			if(!filter.isEnabled()) {
			    if(_debug) this.logMsg('filter not enabled');
			    return;
			}
			let filterOk = filter.isRecordOk(record, _debug);
			if(_debug) this.logMsg('Filter ok:' + filterOk);
			if(!filterOk) allOk = false;
			else anyOk = true;
		    });
		    let ok = logic=="and"?allOk:anyOk;
		    if(opts.skipFirst && rowIdx==0) {
			ok = true;
		    }
//		    this.logMsg("\trow:" + rowIdx+" ok:" + ok);
		    if(highlight) {
			newData.push(record);
			record.setHighlight(this, ok);
		    } else {
			record.clearHighlight(this);
			if(ok) {
			    newData.push(record);
			}
		    }
		});
		debug = false;
		records = newData;
	    }


	    if(debug)   this.logMsg("filterData-2 #records:" + records.length);

            let stride = parseInt(this.getProperty("stride", -1));
            if (stride < 0) {
		let maxSize = parseInt(this.getProperty("maxDisplayedPoints", -1));		
		if(maxSize>0 && records.length>0) {
		    stride = 1;
		    while(records.length/stride>maxSize) {
			stride++;
		    }
		}
	    }

            if (stride > 0) {
                let list = [];
                let cnt = 0;
                for (let i = 0; i < records.length; i += (stride + 1)) {
                    list.push(records[i]);
                }
                records = list;
		//		this.logMsg("stride: " + stride +"  size:" + list.length);
		if(debug)   this.logMsg("R-3:" + records.length);
            }



	    records = this.filterDataPhase2(records);
	    let maxRecords  = this.getMaxRecords();
	    if(Utils.isDefined(maxRecords)) {
		let tmp =[];
		records.every((r,idx)=>{
		    if(idx>=maxRecords) return false;
		    tmp.push(r);
		    return true;
		});
		records = tmp;
	    }




	    if(debug)   this.logMsg("filterData-3 #records:" + records.length);
	    if(this.getFilterPaginate()) {
		let skip = this.pageSkip||0;
		let count = +this.getPageCount();
		if(skip>0 || count<records.length) {
		    let tmp = [];
		    let newSkip = skip;
		    count = Utils.max(count, 1000);
		    while(true) {
			if(newSkip<records.length) break;
			newSkip-=count;
			if(newSkip<0) {
			    break;
			}
		    }
		    if(newSkip<0) newSkip=0;
		    if(newSkip!=skip)
			this.updatePaginateLabel(skip,count,records.length);
		    skip = newSkip;
		    this.logMsg("skip:" + skip +" count:" + count +" " + records.length);
		    for(let i=skip;i<records.length;i++) {
			tmp.push(records[i]);
			if(tmp.length>=count) break;
		    }
		    records=tmp;
		}
	    }


	    if(this.getProperty("binDate")) {
		let what = this.getProperty("binDate");
		let binType = this.getProperty("binType","total");
		let binCount = binType=="count";
		let binned = [];
		let record = records[0];
		let map ={};
		let counts ={};
		this.binRecordToRecords = {};
		let keyToRecord={};
		for (let i = 0; i < records.length; i++) {
		    let record = records[i];
		    let tuple = this.getDataValues(record);
		    let key;
		    let baseDate=null
		    if(what=="month") {
			key = record.getDate().getUTCFullYear() + "-" + (record.getDate().getUTCMonth() + 1);
		    } else if(what=="day") {
			key = record.getDate().getUTCFullYear() + "-" + (record.getDate().getUTCMonth() + 1) +"-" + record.getDate().getUTCDate();
		    } else if(what=="week") {
			let week = +Utils.formatDateWeek(record.getDate());
			key = record.getDate().getUTCFullYear()+"-"+week;
			let d =  (1 + (week - 1) * 7);
			baseDate = new Date(record.getDate().getUTCFullYear(), 0, d);			
		    } else {
			key = record.getDate().getUTCFullYear()+"";
		    }
		    if(!Utils.isDefined(map[key])) {
			counts[key]=1;
			let date = baseDate;
			if(!baseDate) {
			    date = Utils.parseDate(key);
			}
			let data = Utils.cloneList(record.getData());
			if(binCount) {
			    for(k=0;k<data.length;k++) data[k]=1;
			}
			let newRecord = new  PointRecord(fields, record.getLatitude(),record.getLongitude(),
							 record.getElevation(),date,data);

			keyToRecord[key] = newRecord;
			this.binRecordToRecords[newRecord.getId()] = {
			    records:[record],
			}

			map[key] = data;
			binned.push(newRecord);
		    } else {
			let newRecord = keyToRecord[key];
			this.binRecordToRecords[newRecord.getId()].records.push(record);
			counts[key]++;
			let tuple1 = map[key];
			if(binCount) {
			    for(k=0;k<tuple1.length;k++) tuple1[k]++;
			    continue;
			} 
			let tuple2 = record.getData();
			for(let j=0;j<tuple2.length;j++) {
			    let v = tuple2[j];
			    if((typeof v) !="number") continue;
			    if(isNaN(v)) continue;
			    if(isNaN(tuple1[j])) tuple1[j] = v;
			    else tuple1[j] +=v;
			}
		    }
		}
		if(binType == "average") {
		    for(key in counts) {
			let tuple = map[key];
			for(let j=0;j<tuple.length;j++) {
			    let v = tuple[j];
			    if((typeof v) !="number") continue;
			    if(isNaN(v)) continue;
			    tuple[j] = v/counts[key];
			}
		    }
		}

		records = binned;
	    }

	    if(debug)   this.logMsg("filterData-4 #records:" + records.length);
	    if(this.requiresGeoLocation()) {
		records = records.filter(r=>{return r.hasLocation();});
	    }
	    if(debug)   this.logMsg("filterData-5 #records:" + records.length);
	    let dataFilters = this.getTheDataFilters();
	    if(dataFilters.length) {
		if(debug)   this.logMsg("have filters:" + dataFilters);
//		console.time('filters');
		records = records.filter((r,idx)=> {
		    if(!this.checkDataFilters(dataFilters, r)) {
			return false;
		    } 
		    return true;
		});
//		console.timeEnd('filters');
	    }
	    if(debug)   this.logMsg("filterData-6 #records:" + records.length);

	    if(this.uniqueFields && this.uniqueFields.length>0) {
		let selected= this.jq('uniquefields').val();
		if(selected.length>0) {
		    let fields=this.uniqueFields.filter(f=>{
			return selected.includes(f.getId())
		    });
		    fields.forEach(ufield=>{
			records = this.findUnique(records, ufield);
		    });
		}
	    }

	    if(this.getProperty("uniqueField")) {
		let ufield =  this.getFieldById(null, this.getProperty("uniqueField"));
		records = this.findUnique(records, ufield);
	    }

	    


	    //	    let t2=  new Date();
	    //	    Utils.displayTimes("filterData",[t1,t2]);
	    records = this.sortRecords(records);

	    this.recordToIndex = {};
	    this.indexToRecord = {};
	    for(let i=0;i<records.length;i++) {
		let record = records[i];
		this.recordToIndex[record.getId()] = i;
		this.indexToRecord[i] = record;
	    }


	    let convertPost = this.getProperty("convertDataPost");
	    if(convertPost) {
		let pointData = this.getData();
		let newPointData = new  PointData("pointdata", pointData.getRecordFields(), records,null,{parent:pointData});
		this.pointData =  new CsvUtil().process(this, newPointData, convertPost);
		records = this.pointData.getRecords();
//		this.logMsg("post:" + this.pointData.getRecordFields());
	    }
	    if(debug)
		this.logMsg("filtered:" + records.length);
	    this.jq(ID_FILTER_COUNT).html("Count: " + records.length);
	    this.filteredRecords = records;
	    if(this.getSelectFirst()) {
		this.propagateEventRecordSelection({record:records[0]});
	    } else if(this.getSelectLast()) {
		this.propagateEventRecordSelection({record:records[records.length-1]});
	    }
	    if(opts.recordOk) {
		records=records.filter(record=>{
		    if(opts.recordOk(record)) return record;
		    return null;});
	    }

	    if(this.getShowRecordPager()) {
		let number = +this.getRecordPagerNumber();
		if(this.rowStartIndex>=records.length) {
		    this.rowStartIndex=Math.max(0, records.length-(records.length%number)-1);
		}
		let tmp = [];
		let rowIdx;
		let cnt = 0;
		for (rowIdx = this.rowStartIndex; (rowIdx < records.length) && (cnt<number); rowIdx++) {
		    cnt++;

		    let record = records[rowIdx];
		    tmp.push(record);
		}
		let header = "";
		if(this.rowStartIndex>0) {
		    header += HU.span([ATTR_ID,this.domId(ID_PREV)],"Previous")+" ";
		}

		if(rowIdx<records.length) {
		    header += HU.span([ATTR_ID,this.domId(ID_NEXT)],"Next") +" ";
		}
		header  += HU.span([ATTR_ID,this.domId(ID_PREVNEXT_LABEL)]);
		if(header!="") {
		    header = HU.div([ATTR_STYLE,HU.css('margin-right','10px', "display","inline-block")],header);
		    this.jq(ID_HEADER2_PREFIX).html(header);
		    this.jq(ID_HEADER2).css("text-align","left");
		}
		if(number<records.length) {
		    this.jq(ID_PREVNEXT_LABEL).html("Showing " + (this.rowStartIndex+1) +" - " +(this.rowStartIndex+cnt) +
						    " of " + records.length +" " + this.getNoun(""));
		}
		this.jq(ID_PREV).button().click(()=>{
		    this.rowStartIndex-=  +this.getRecordPagerNumber();
		    if(this.rowStartIndex<0) this.rowStartIndex=0;
		    this.forceUpdateUI();
		});
		this.jq(ID_NEXT).button().click(()=>{
		    let num = +this.getRecordPagerNumber();
		    this.rowStartIndex+=num;
		    this.forceUpdateUI();
		});
		records = tmp;
	    }


	    if(this.animationControl) {
		this.animationControl.applyLabelTemplate(records);
	    }


	    if(debug)   this.logMsg("filterData-final #records:" + records.length);

            return this.handleResult("filterData",records);
        },
	//TODO: this will support a handler pattern that allows for insertion
	//of custom functionality
	handleResult: function(type,data) {
	    return data;
	},
	getBinnedRecords: function(record) {
	    if(this.binRecordToRecords)
		return this.binRecordToRecords[record.getId()].records;
	    return record.parentRecords;
	},
        canDoGroupBy: function() {
            return false;
        },
        canDoMultiFields: function() {
            return true;
        },
        useChartableFields: function() {
            return false;
        },
        getFieldsToSelect: function(pointData) {
	    if(this.convertedFields) return this.convertedFields;
            if (this.useChartableFields())
                return pointData.getChartableFields(this);
            return pointData.getRecordFields();
        },
        getGet: function() {
            return "getRamaddaDisplay('" + this.getId() + "')";
        },
	assembleWikiText: function(type) {
	    let wiki =  "";
	    if(window.globalDisplayProperties) {
		for(key in window.globalDisplayProperties) {
		    wiki += '{{displayProperty name="' + key +'" value="' + window.globalDisplayProperties[key]+'"}}\n';

		}
	    }
            wiki += this.getWikiText();
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.getIsLayoutFixed()) {
                    continue;
                }
                wiki += display.getWikiText();
            }
	    return wiki;
	},
        showWikiText: function(type) {
	    let wiki =  this.assembleWikiText();
	    HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
	    wiki = wiki.replace(/</g,"&lt;").replace(/>/g,"&gt;");
	    wiki = HU.pre([ATTR_STYLE,HU.css("max-width","500px","max-height","400px","overflow-x","auto","overflow-y","auto")], wiki);
	    this.showDialog(wiki);
	},
        copyWikiText: function(type) {
	    Utils.copyText(this.assembleWikiText());
	    alert("Wiki text has been copied to the clipboard");
	},
        publish: function(type) {
            if (type == null) type = "wikipage";
            let args = [];
            let name = prompt("Name", "");
            if (name == null) return;
            args.push("name");
            args.push(name);

            args.push("type");
            args.push(type);


            let desc = "";
            //                let desc = prompt("Description", "");
            //                if(desc == null) return;

            let wiki = "";
            if (type == "wikipage") {
                wiki += "+section label=\"{{name}}\"\n${extra}\n";
            } else if (type == "blogentry") {
                wiki = "<wiki>\n";
            }
            wiki += desc;
	    wiki += this.assembleWikiText();
            if (type == "wikipage") {
                wiki += "-section\n\n";
            } else if (type == "blogentry") {}
            let from = "";
            let entries = this.getChildEntries();
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                from += entry.getId() + ",";
            }

            if (entries.length > 0) {
                args.push("entries");
                args.push(from);
            }

            if (type == "media_photoalbum") {
                wiki = "";
            }

            args.push("description_encoded");
            args.push(window.btoa(wiki));
            let url = HU.getUrl(RamaddaUtil.getUrl("/entry/publish"), args);
            window.open(url, '_blank');
        },
        getChildEntries: function(includeFixed) {
            let seen = {};
            let allEntries = [];
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (!includeFixed && display.getIsLayoutFixed()) {
                    continue;
                }
                if (display.getEntries) {
                    let entries = display.getEntries();
                    if (entries) {
                        for (let entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                            if (seen[entries[entryIdx].getId()] != null) {
                                continue;
                            }
                            seen[entries[entryIdx].getId()] = true;
                            allEntries.push(entries[entryIdx]);
                        }
                    }
                }
            }
            return allEntries;
        },
        copyDisplayedEntries: function() {
            let allEntries = [];
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.getIsLayoutFixed()) {
                    continue;
                }
                if (display.getEntries) {
                    let entries = display.getEntries();
                    if (entries) {
                        for (let entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                            allEntries.push(entries[entryIdx]);
                        }
                    }
                }
            }
            return this.copyEntries(allEntries);
        },
        defineWikiAttributes: function(list) {
            for (let i = 0; i < list.length; i++) {
                if (this.wikiAttrs.indexOf(list[i]) < 0) {
                    this.wikiAttrs.push(list[i]);
                }
            }
        },
        getWikiAttributes: function(attrs) {
            for (let i = 0; i < this.wikiAttrs.length; i++) {
                let v = this[this.wikiAttrs[i]];
                if (Utils.isDefined(v)) {
                    attrs.push(this.wikiAttrs[i]);
                    attrs.push(v);
                }
            }
        },
        getWikiText: function() {
            let attrs = [
			 "layoutHere", "false",
			 "type", this.type,
			 "column", this.getColumn(),
			 "row", this.getRow()
			];
	    if(this.getProperty("entryId")) {
		attrs.push("entry");
		attrs.push(this.getProperty("entryId"));
	    }
            this.getWikiAttributes(attrs);
            let entryId = null;
            if (this.getEntries) {
                let entries = this.getEntries();
                if (entries && entries.length > 0) {
                    entryId = entries[0].getId();
                }
            }
            if (!entryId) {
                entryId = this.entryId;
            }
            if (entryId) {
                attrs.push("entry");
                attrs.push(entryId);
            }
            let wiki = "{{display " + HU.attrs(attrs) + "}}\n\n"

            return wiki;
        },
        copyEntries: function(entries) {
            let allEntries = [];
            let seen = {};
            for (let entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                let entry = entries[entryIdx];
                if (seen[entry.getId()] != null) continue;
                seen[entry.getId()] = entry;
                allEntries.push(entry);
            }
            let from = "";
            for (let i = 0; i < allEntries.length; i++) {
                let entry = allEntries[i];
                from += entry.getId() + ",";
            }


            let url = RamaddaUtil.getUrl("/entry/copy?action.force=copy&from=" + from);
            window.open(url, '_blank');

        },
        entryHtmlHasBeenDisplayed: async function(entry) {
            if (entry.getIsGroup() /* && !entry.isRemote*/ ) {
                let theDisplay = this;
                let callback = function(entries) {
                    let html = HU.open(TAG_OL, [ATTR_CLASS, "display-entrylist-list", ATTR_ID, theDisplay.getDomId(ID_LIST)]);
                    html += theDisplay.getEntriesTree(entries);
                    html += HU.close(TAG_OL);
                    theDisplay.jq(ID_GROUP_CONTENTS + entry.getIdForDom()).html(html);
                    theDisplay.addEntrySelect();
                };
                await entry.getChildrenEntries(callback);
            }
        },
        getEntryHtml: function(entry, props) {
            let dfltProps = {
                showHeader: true,
                headerRight: false,
                showDetails: this.getShowDetails(),
		showImage:this.getProperty("showEntryImage")
            };
            $.extend(dfltProps, props);

            props = dfltProps;
            let menu = this.getEntryMenuButton(entry);
            let html = "";
            if (props.showHeader) {
                let left = menu + SPACE + entry.getLink(null, true, ["target","_entries"]);
                if (props.headerRight) html += HU.leftRight(left, props.headerRight);
                else html += left;
            }

            let divid = HU.getUniqueId("entry_");
            html += HU.div([ATTR_ID, divid], "");
            let metadata = entry.getMetadata();
	    //Don't this now since this gets shown in the embed details
	    if(dfltProps.showImage) {
		if (entry.isImage()) {
                    let img = HU.tag(TAG_IMG, ["src", entry.getImageUrl(), /*ATTR_WIDTH,"100%",*/
					       ATTR_CLASS, "display-entry-image"
					      ]);

                    html += HU.href(entry.getResourceUrl(), img,["download",null]) + "<br>";
		} else {
                    for (let i = 0; i < metadata.length; i++) {
			if (metadata[i].type == "content.thumbnail") {
                            let image = metadata[i].value.attr1;
                            let url;
                            if (image.indexOf("http") == 0) {
				url = image;
                            } else {
				url = RamaddaUtil.getUrl("/metadata/view/" + image + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + metadata[i].id + "&thumbnail=false");
                            }
                            html += HU.image(url, [ATTR_CLASS, "display-entry-thumbnail"]);
			}
                    }
		}
	    }
            if (entry.getIsGroup() /* && !entry.isRemote*/ ) {
                html += HU.div([ATTR_ID, this.getDomId(ID_GROUP_CONTENTS + entry.getIdForDom())], "" /*this.getWaitImage()*/ );
            }


            html += HU.formTable();

            if (props.showDetails) {
                if (entry.url) {
                    html += HU.formEntry("URL:", HU.href(entry.url, entry.url));
                }

                if (entry.remoteUrl) {
                    html += HU.formEntry("URL:", HU.href(entry.remoteUrl, entry.remoteUrl));
                }
                if (entry.remoteRepository) {
                    html += HU.formEntry("From:", HU.href(entry.remoteRepository.url, entry.remoteRepository.name));
                }
            }

            let columns = entry.getAttributes();

            if (entry.getFilesize() > 0) {
		let link =  entry.getFilename() + " " +HU.getIconImage('fas fa-download');
                html += HU.formEntry("File:", 
				     HU.href(entry.getResourceUrl(), link,["download",null]) + " " +
				     entry.getFormattedFilesize());
            }

            for (let colIdx = 0; colIdx < columns.length; colIdx++) {
                let column = columns[colIdx];
                let columnValue = column.value;
                if (column.getCanShow && !column.getCanShow()) {
                    continue;
                }
                if (Utils.isFalse(column.canshow)) {
                    continue;
                }

                if (column.isUrl && column.isUrl()) {
                    let tmp = "";
                    let toks = columnValue.split("\n");
                    for (let i = 0; i < toks.length; i++) {
                        let url = toks[i].trim();
                        if (url.length == 0) continue;
                        tmp += HU.href(url, url);
                        tmp += "<br>";
                    }
                    columnValue = tmp;
                }
                html += HU.formEntry(column.label + ":", columnValue);
            }

            html += HU.close(TAG_TABLE);
            return html;
        },

        getEntriesTree: function(entries, props) {
            if (!props) props = {};
	    let columns = this.getProperty('entryColumns', null);
	    let showSnippet = this.getProperty('showSnippetInList');
	    let metadataDisplay = RamaddaUtil.makeMetadataDisplay(this.getProperty('metadataDisplay'));
	    let mainMetadataDisplay = RamaddaUtil.makeMetadataDisplay(this.getProperty('mainMetadataDisplay'));	    
	    let nameStyle = this.getProperty('nameStyle','font-size:120%;color:#2178B5;');
	    let showIcon = this.getProperty('showIcon',true);
	    let showToggle = this.getProperty('showToggle',true);
	    let showThumbnail = this.getProperty('showThumbnail',false);	    	    
	    let showEntryType = this.getProperty('showEntryType',false);	    	    
	    let placeholderImage = this.getProperty('placeholderImage',RamaddaUtils.getCdnUrl('/images/placeholder.png'));
	    
            if (columns != null) {
                let columnNames = this.getProperty('columnNames', null);
                if (columnNames != null) {
                    columnNames = columnNames.split(',');
                }
                columns = columns.split(',');
                let ids = [];
                let names = [];
                for (let i = 0; i < columns.length; i++) {
                    let toks = columns[i].split(':');
                    let id = null,
                        name = null;
                    if (toks.length > 1) {
                        if (toks[0] == 'property') {
                            name = 'property';
                            id = columns[i];
                        } else {
                            id = toks[0];
                            name = toks[1];
                        }
                    } else {
                        id = columns[i];
                        name = id;
                    }
                    ids.push(id);
                    names.push(name);
                }
                columns = ids;
                if (columnNames == null) {
                    columnNames = names;
                }
                return this.getEntriesTable(entries, columns, columnNames);
            }
            let suffix = props.suffix;
            let domIdSuffix = '';
            if (!suffix) {
                suffix = 'null';
            } else {
                domIdSuffix = suffix;
                suffix = "'" + suffix + "'";
            }

            let handler = getHandler(props.handlerId);
            let showIndex = props.showIndex;
            let html = "";
            let rowClass = "entryrow_" + this.getId();
            let even = true;
            if (this.entriesMap == null)
                this.entriesMap = {};
	    let doWorkbench = this.getProperty("doWorkbench");
            for (let i = 0; i < entries.length; i++) {
                even = !even;
                let entry = entries[i];
		if(entry.displayHtml) {
		    html+=entry.displayHtml;
		    continue;
		}

                this.entriesMap[entry.getId()] = entry;
                let toolbar = this.makeEntryToolbar(entry, handler, props.handlerId);
                let entryMenuButton = doWorkbench?this.getEntryMenuButton(entry):"";

                let entryName = entry.getDisplayName(true);
                if (entryName.length > 100) {
                    entryName = entryName.substring(0, 99) + "...";
                }
                let icon = showIcon?entry.getIconImage([ATTR_TITLE, "View entry"]):'';
		entryName = HU.span([ATTR_STYLE,nameStyle],entryName);
                let entryIdForDom = entry.getIdForDom() + domIdSuffix;
                let entryId = entry.getId();
                let arrow = HU.image(icon_tree_closed, [ATTR_BORDER, "0",
							"tree-open", "false",
							ATTR_ID,
							this.getDomId(ID_TREE_LINK + entryIdForDom)
						       ]);
                let toggleCall = this.getGet() + ".toggleEntryDetails(event, '" + entryId + "'," + suffix + ",'" + props.handlerId + "');";
                let toggleCall2 = showToggle?this.getGet() + ".entryHeaderClick(event, '" + entryId + "'," + suffix + "); ":'';
                let open = showToggle?HU.onClick(toggleCall, arrow):'';
                let extra = "";
                if (showIndex) {
                    extra = "#" + (i + 1) + " ";
                }
                if (handler && handler.getEntryPrefix) {
                    extra += handler.getEntryPrefix(props.handlerId, entry);
                }

		entryName = icon + " " + entryName;
                let link = showToggle?HU.tag(TAG_A, ["target","_entries",ATTR_HREF, entry.getEntryUrl()], entryName):entryName;
		let main = entryMenuButton + " " + open + " " + extra + link;
                let left = HU.div([ATTR_CLASS, "display-entrylist-name"], main);
		if(showEntryType) {
		    left =  HU.leftRightTable(left,HU.span([ATTR_STYLE,'font-style:italic;'],entry.getTypeName()));
		}

		if(mainMetadataDisplay && mainMetadataDisplay.length) {
		    let mtd = RamaddaUtil.formatMetadata(entry,mainMetadataDisplay,{doBigText:false,wrapInDiv:false});
		    if(Utils.stringDefined(mtd)) {
			left +=HU.div([],mtd);
		    }
		}

		if(showThumbnail) {
		    let thumb = entry.getThumbnail();
		    if(!thumb) thumb = placeholderImage;
		    if(thumb) {
			thumb = HU.image(thumb,[ATTR_WIDTH,'80px',ATTR_STYLE,'margin-right:5px;']);
			thumb = HU.div([ATTR_STYLE,HU.css('max-height','100px','overflow-y','auto')], thumb);
			left = HU.table([ATTR_WIDTH,'100%'],
					HU.tr([ATTR_VALIGN,'top'],
					      HU.td([ATTR_WIDTH,'80px'],thumb +HU.td(left))));
						    
		    }
		}

		if(!showToggle) {
		    left= HU.href(entry.getEntryUrl(),left);
		}
		let snippet = entry.getSnippet()??'';
		if(showSnippet && Utils.stringDefined(snippet)) {
		    snippet = HU.div([ATTR_CLASS, "display-entrylist-details-snippet", ATTR_ID, this.getDomId(ID_DETAILS_SNIPPET + entryIdForDom)],snippet);
		    left+=snippet;
		    snippet = "";
		}
		let extraDetails ='';
		if(metadataDisplay && metadataDisplay.length) {
		    let mtd = RamaddaUtil.formatMetadata(entry,metadataDisplay);
		    if(Utils.stringDefined(mtd)) {
			extraDetails +=HU.div([],mtd);
		    }
		}

		let inner = HU.div([ATTR_CLASS, "display-entrylist-details-inner", ATTR_ID, this.getDomId(ID_DETAILS_INNER + entryIdForDom)], "");
                let details = HU.div([ATTR_ID, this.getDomId(ID_DETAILS + entryIdForDom), ATTR_CLASS, "display-entrylist-details"], 
				     HU.div([ATTR_CLASS, "display-entrylist-details-ancestors", ATTR_ID, this.getDomId(ID_DETAILS_ANCESTORS + entryIdForDom)], "") +
				     snippet +
				     HU.div([ATTR_CLASS, "display-entrylist-details-tags", ATTR_ID, this.getDomId(ID_DETAILS_TAGS + entryIdForDom)], "")+
				     extraDetails+
				     inner

				    );

                //                    console.log("details:" + details);
                let line;
                if (doWorkbench && this.getProperty("showToolbar", true)) {
                    line = HU.leftCenterRight(left, "", toolbar, "80%", "1%", "19%");
                } else {
                    line = left;
                }
                //                    line = HU.leftRight(left,toolbar,"60%","30%");
                let mainLine = HU.div(["onclick", toggleCall2, ATTR_ID, this.getDomId(ID_DETAILS_MAIN + entryIdForDom),  ATTR_ENTRYID, entryId], line);
		//mainline
                mainLine = HU.div([ATTR_CLASS, "display-entrylist-entry-main" + " " + "entry-main-display-entrylist-" + (even ? "even" : "odd"),
				   ATTR_ENTRYID, entryId], mainLine);
                line = HU.div([ATTR_CLASS, (even ? "ramadda-row-even" : "ramadda-row-odd"), ATTR_ID, this.getDomId("entryinner_" + entryIdForDom)], mainLine + details);


                html += HU.div([ATTR_ID,
				this.getDomId("entry_" + entryIdForDom),
				ATTR_ENTRYID, entryId, ATTR_CLASS, "display-entrylist-entry" + rowClass
			       ], line);
                html += "\n";
            }
            return html;
        },
        addEntrySelect: function() {
            let theDisplay = this;
            let entryRows = $("#" + this.getDomId(ID_DISPLAY_CONTENTS) + "  ." + this.getClass("entry-main"));

            entryRows.unbind();
            entryRows.mouseover(async function(event) {
                //TOOLBAR
                let entryId = $(this).attr(ATTR_ENTRYID);
                let entry;
                await theDisplay.getEntry(entryId, e => {
                    entry = e
                });
                if (!entry) {
                    console.log("no entry:" + entryId);
                    return;
                }
                theDisplay.propagateEvent("entryMouseover", {
                    entry: entry
                });


                if (true) return;
                let domEntryId = Utils.cleanId(entryId);
                let toolbarId = theDisplay.getEntryToolbarId(domEntryId);

                let toolbar = $("#" + toolbarId);
                toolbar.show();
                let myalign = 'right top+1';
                let atalign = 'right top';
                let srcId = theDisplay.getDomId(ID_DETAILS_MAIN + domEntryId);
                toolbar.position({
                    of: $("#" + srcId),
                    my: myalign,
                    at: atalign,
                    collision: "none none"
                });

            });
            entryRows.mouseout(async function(event) {
                let entryId = $(this).attr(ATTR_ENTRYID);
                let entry;
                await theDisplay.getEntry(entryId, e => {
                    entry = e
                });
                if (!entry) return;
                theDisplay.propagateEvent("entryMouseout", {
                    entry: entry
                });
                let domEntryId = Utils.cleanId(entryId);
                let toolbarId = theDisplay.getEntryToolbarId(entryId);
                let toolbar = $("#" + toolbarId);
                //TOOLBAR                        toolbar.hide();
            });

            if (this.madeList) {
                //                    this.jq(ID_LIST).selectable( "destroy" );
            }
            this.madeList = true;
            if (false) {
                this.jq(ID_LIST).selectable({
                    //                        delay: 0,
                    //                        filter: 'li',
                    cancel: 'a',
                    selected: async function(event, ui) {
                        let entryId = ui.selected.getAttribute(ATTR_ENTRYID);
                        theDisplay.toggleEntryDetails(event, entryId);
                        if (true) return;

                        theDisplay.hideEntryDetails(entryId);
                        let entry;
                        await this.getEntry(entryId, e => {
                            entry = e
                        });
                        if (entry == null) return;

                        let zoom = null;
                        if (event.shiftKey) {
                            zoom = {
                                zoomIn: true
                            };
                        }
                        theDisplay.selectedEntries.push(entry);
                        theDisplay.propagateEvent(DisplayEvent.entrySelection, {
                            entry: entry,
                            selected: true,
                            zoom: zoom
                        });
                        theDisplay.lastSelectedEntry = entry;
                    },
                    unselected: async function(event, ui) {
                        if (true) return;
                        let entryId = ui.unselected.getAttribute(ATTR_ENTRYID);
                        let entry;
                        await this.getEntry(entryId, e => {
                            entry = e
                        });
                        let index = theDisplay.selectedEntries.indexOf(entry);
                        //                            console.log("remove:" +  index + " " + theDisplay.selectedEntries);
                        if (index > -1) {
                            theDisplay.selectedEntries.splice(index, 1);
                            theDisplay.propagateEvent(DisplayEvent.entrySelection, {
                                entry: entry,
                                selected: false
                            });
                        }
                    },

                });
            }

        },
        getEntriesTable: function(entries, columns, columnNames) {
            if (this.entriesMap == null)
                this.entriesMap = {};
            let columnWidths = this.getProperty("columnWidths", null);
            if (columnWidths != null) {
                columnWidths = columnWidths.split(",");
            }
            let html = HU.open(TAG_TABLE, [ATTR_WIDTH, "100%", "cellpadding", "0", "cellspacing", "0"]);
            html += HU.open(TAG_TR, ["valign", "top"]);
            for (let i = 0; i < columnNames.length; i++) {
                html += HU.td([ATTR_ALIGN, "center", ATTR_CLASS, "display-entrytable-header"], columnNames[i]);
            }
            html += HU.close(TAG_TR);

            for (let i = 0; i < entries.length; i++) {
                html += HU.open(TAG_TR, ["valign", "top"]);
                let entry = entries[i];
                this.entriesMap[entry.getId()] = entry;
                for (let j = 0; j < columns.length; j++) {
                    let columnWidth = null;
                    if (columnWidths != null) {
                        columnWidth = columnWidths[j];
                    }
                    let column = columns[j];
                    let value = "";
                    if (column == "name") {
                        value = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], entry.getName());
                    } else if (column.match(".*property:.*")) {
                        let type = column.substring("property:".length);
                        let metadata = entry.getMetadata();
                        value = "";
                        for (let j = 0; j < metadata.length; j++) {
                            let m = metadata[j];
                            if (m.type == type) {
                                if (value != "") {
                                    value += "<br>";
                                }
                                value += m.value.attr1;
                            }
                        }
                    } else if (column == "description") {
                        value = entry.getDescription();
                    } else if (column == "date") {
                        value = entry.ymd;
                        if (value == null) {
                            value = entry.startDate;
                        }

                    } else {
                        value = entry.getAttributeValue(column);
                    }
                    let attrs = [ATTR_CLASS, "display-entrytable-cell"];
                    if (columnWidth != null) {
                        attrs.push(ATTR_WIDTH);
                        attrs.push(columnWidth);
                    }

                    html += HU.td(attrs, value);
                }
                html += HU.close(TAG_TR);
            }
            html += HU.close(TAG_TABLE);
            return html;
        },

        makeEntryToolbar: function(entry, handler, handlerId) {
            let get = this.getGet();
            let toolbarItems = [];
	    let props = "{showMenu:true,showTitle:true}";
            //                 toolbarItems.push(HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl(),"target","_"], 
            //                                                HU.image(RamaddaUtil.getCdnUrl("/icons/application-home.png"),["border",0,ATTR_TITLE,"View Entry"])));
            if (entry.getType().getId() == "type_wms_layer") {
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".addMapLayer(" + HU.sqt(entry.getId()) + ");"],
					 HU.image(RamaddaUtil.getCdnUrl("/icons/map.png"), ["border", 0, ATTR_TITLE, "Add Map Layer"])));

            }
            if (entry.getType().getId() == "geo_shapefile" || entry.getType().getId() == "geo_geojson") {
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".addMapLayer(" + HU.sqt(entry.getId()) + ");"],
					 HU.image(RamaddaUtil.getCdnUrl("/icons/map.png"), ["border", 0, ATTR_TITLE, "Add Map Layer"])));

            }

            let jsonUrl = this.getPointUrl(entry);
            if (jsonUrl != null) {
                jsonUrl = jsonUrl.replace(/\'/g, "_");
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
						 HU.sqt("table") + "," + HU.sqt(jsonUrl) + "," + props+");"
						],
					 HU.getIconImage("fa-table", [ATTR_TITLE, "Create Tabular Display"])));

                let x;
                toolbarItems.push(x = HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
 						     HU.sqt("linechart") + "," + HU.sqt(jsonUrl) + "," + props +");"
						    ],
					     HU.getIconImage("fa-chart-line", [ATTR_TITLE, "Create Chart"])));
		//		console.log("X:" + x);
            }
            toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
					     HU.sqt("entrydisplay") + "," + HU.sqt(jsonUrl) + "," + props +");"
					    ],
				     HU.getIconImage("fa-file", ["border", 0, ATTR_TITLE, "Show Entry"])));
            if (entry.getFilesize() > 0) {
                toolbarItems.push(HU.tag(TAG_A, [ATTR_HREF, entry.getResourceUrl(),"download",null],
					 HU.image(RamaddaUtil.getCdnUrl("/icons/download.png"), ["border", 0, ATTR_TITLE, "Download (" + entry.getFormattedFilesize() + ")"])));

            }


            let entryMenuButton = this.getEntryMenuButton(entry);
            let tmp = [];



            if (handler && handler.addToToolbar) {
                handler.addToToolbar(handlerId, entry, toolbarItems);
            }

            for (let i = 0; i < toolbarItems.length; i++) {
                tmp.push(HU.div([ATTR_CLASS, "display-entry-toolbar-item"], toolbarItems[i]));
            }
            toolbarItems = tmp;
            return HU.div([ATTR_CLASS, "display-entry-toolbar", ATTR_ID,
			   this.getEntryToolbarId(entry.getIdForDom())
			  ],
			  HU.join(toolbarItems, ""));
        },
        getEntryToolbarId: function(entryId) {
            let id = entryId.replace(/:/g, "_").replace(/\//g,"_").replace(/[\(\)]/g,"_");
            id = id.replace(/=/g, "_");
            return this.getDomId(ID_TOOLBAR + "_" + id);
        },

        hideEntryDetails: function(entryId) {
            //                let popupId = "#"+ this.getDomId(ID_DETAILS + entryId);
            //                $(popupId).hide();
            //                this.currentPopupEntry = null;
        },
        entryHeaderClick: function(event, entryId, suffix) {
            let target = event.target;
            //A hack to see if this was the div clicked on or a link in the div
            if (target.outerHTML) {
                if (target.outerHTML.indexOf("<div") != 0) {
                    return;
                }
            }
            this.toggleEntryDetails(event, entryId);
        },
	makeEntryTags:function(entry,groupThem,prefix,metadataMap) {
	    prefix = prefix||"";
	    let metadata = "";
	    let map = {};
	    let list = [];
	    entry.getMetadata().forEach(m=>{
		
		//Check for exclusions
		if(["content.pagestyle", "content.pagetemplate","content.thumbnail","content.attachment"].includes(m.type)) return;
		if(m.type.startsWith("map")) return;
		if(m.type.startsWith("spatial")) return;		
                let tt = m.label+": " + m.value.attr1;
                let label =String(m.value.attr1);
		if(m.type=="property") {
		    tt +=":" + m.value.attr2;
		    label +=":" + m.value.attr2;
		}
		if(label.length>20) label = label.substring(0,19) +"...";
		label = prefix +label;
		let id = Utils.getUniqueId("metadata_");
		let tag = HU.div(["metadata-type",m.type,"metadata-value", m.value.attr1,ID,id,
				  ATTR_CLASS,"display-search-tag",ATTR_TITLE, tt,
				  ATTR_STYLE, HU.css("background", getMetadataColor(m.type))],label);
		if(!groupThem)
		    metadata+= tag;
		else {
		    if(!map[m.type]) {
			map[m.type] = [];
			list.push(m);
		    }
		    map[m.type].push(tag);
		}
		if(metadataMap)
		    metadataMap[id] = m;
	    });
	    if(groupThem) {
		list.forEach(m=>{
		    metadata+=m.label +": " +map[m.type].join(" ");
		    metadata+="<br>";
		});
	    }

	    return metadata;
	},
	addSearchToTags: function() {
	    return true;
	},
	typeSearchEnabled:function() {
	    return true;
	},

        toggleEntryDetails: async function(event, entryId, suffix, handlerId, entry) {
	    if(!entry) {
		await this.getEntry(entryId, e => {
		    this.toggleEntryDetails(event, entryId, suffix, handlerId, e);
		});
		return;
	    }


//            console.log("toggleEntryDetails:" + entry.getName() +" " + entry.getId());
            if (suffix == null) suffix = "";
            let link = this.jq(ID_TREE_LINK + entry.getIdForDom() + suffix);
            let id = ID_DETAILS + entry.getIdForDom() + suffix;
            let details = this.jq(id);
            if (event && event.shiftKey) {
                let id = Utils.cleanId(entryId);
                let line = this.jq(ID_DETAILS_MAIN + id);
                if (!this.selectedEntriesFromTree) {
                    this.selectedEntriesFromTree = {};
                }
                let selected = line.attr("ramadda-selected") == "true";
                if (selected) {
                    line.removeClass("display-entrylist-entry-main-selected");
                    line.attr("ramadda-selected", "false");
                    this.selectedEntriesFromTree[entry.getId()] = null;
                } else {
                    line.addClass("display-entrylist-entry-main-selected");
                    line.attr("ramadda-selected", "true");
                    this.selectedEntriesFromTree[entry.getId()] = entry;
                }
                this.propagateEvent(DisplayEvent.entrySelection, {
                    "entry": entry,
                    "selected": !selected
                });
                return;
            }

            let open = link.attr("tree-open") == "true";
            if (open) {
                link.attr("src", icon_tree_closed);
            } else {
                link.attr("src", icon_tree_open);
            }
            link.attr("tree-open", open ? "false" : "true");

	    let handleContent = ()=>{
		if (open) {
                    details.hide();
		} else {
                    details.show();
		}
		if (event && event.stopPropagation) {
                    event.stopPropagation();
		}
	    }

            let _this = this;
            let hereBefore = details.attr("has-content") != null;
            details.attr("has-content", "true");
            if (hereBefore) {
		handleContent();
		return;
            } 
	    let detailsInner = this.jq(ID_DETAILS_INNER + entry.getIdForDom() + suffix);
	    let embedWiki=	(!entry.isRemote)?entry.getEmbedWikiText():null;

            if (!embedWiki && !entry.isSynth() && entry.getIsGroup() /* && !entry.isRemote*/ ) {
                detailsInner.html(HU.image(icon_progress));
                let callback = function(entries) {
                    _this.displayChildren(entry, entries, suffix, handlerId);
                };
                let entries = entry.getChildrenEntries(callback);
            } else {
		let details = this.getEntryHtml(entry, {
                    showHeader: false
                })
		let uid;
		if(Utils.stringDefined(embedWiki)) {
		    uid =this.getUniqueId("details");
		    details+=HU.div([ATTR_ID,uid,
				     ATTR_CLASS,'ramadda-button ramadda-clickable'],
				    'Details');
		    details+=HU.div([ATTR_ID,uid+'_contents',ATTR_CLASS,'display-entry-embed']);
		}
                detailsInner.html(details);

		if(uid) {
		    let open = false;
		    let shown=false;
		    jqid(uid).button().click(()=>{
			open=!open;
			let contents = jqid(uid+'_contents');
			if(!open) {
			    contents.hide();
			    return;
			}
			contents.show();
			if(shown) return;
			shown=true;
			contents.html(HU.div([ATTR_CLASS,'ramadda-image-loading']));
			this.wikify(embedWiki,entry.getId(),
				    (html)=>{
					this.addWikiHtml(contents, html);
				    },
				    (error)=>{
					contents.html(error);
				    });
		    });
		}
            }
	    handleContent();
	    let metadataMap  = {};
	    let prefix = entry.isSynth()?"":HU.getIconImage("fas fa-search") + SPACE;
	    if(!this.addSearchToTags()) prefix='';
	    if(!this.typeSearchEnabled()) prefix='';
	    let metadata = this.makeEntryTags(entry,false,prefix,metadataMap);
	    let bar = this.jq(ID_DETAILS_TAGS + entry.getIdForDom() + suffix);
	    let typeTag = $(HU.span([ATTR_CLASS,"display-search-tag"],prefix + "Type: " + entry.getType().getLabel())).appendTo(bar);
	    if(!entry.isSynth()) {
		typeTag.click(function() {
		    _this.typeTagClicked(entry.getType());
		});
	    }
	    let tags = $(metadata).appendTo(bar);
	    if(!entry.isSynth()) {
		tags.click(function() {
		    _this.metadataTagClicked(metadataMap[$(this).attr(ATTR_ID)]);
		});
	    }


	    if(!entry.isSynth() && this.getProperty("showEntryBreadcrumbs",true)) {
		let ancestorContent = "";
		let handleAncestor = ancestor=>{
		    if(!ancestor) {
			this.jq(ID_DETAILS_ANCESTORS + entry.getIdForDom() + suffix).html(ancestorContent);
		    } else {
			let href= ancestor.getLink(null, false,["target","_entries"]);
			if(ancestorContent!="")
			    href = href + HU.div([CLASS,"breadcrumb-delimiter"]);
			ancestorContent = href +  ancestorContent;
			ancestor.getParentEntry(handleAncestor);
		    }
		};
		entry.getParentEntry(handleAncestor);
	    }
        },
	addWikiHtml:function(container,html) {
	    let debug = true;
	    let js =[];
	    //Parse out any script tags 
	    let regexp = /<script *src=("|')?([^ "']+)("|')?.*?<\/script>/gs;
	    let array = [...html.matchAll(regexp)];
	    array.forEach(tuple=>{
		html = html.replace(tuple[0],'');
		let url = tuple[2];
		url = url.replace(/'/g,'');
		js.push(url);
	    });
	    //Run through any script tags and load them
	    let cb = ()=>{
		if(js.length==0 && js[0]==null) {
		    container.html(html);
		    return;
		}
		let url = js[0];
		js.splice(0,1);
		Utils.loadScript(url,cb);
	    };
	    cb();
	},


	metadataTagClicked:function(metadata) {
	},
	typeTagClicked:function(metadata) {
	},	
        getSelectedEntriesFromTree: function() {
            let selected = [];
            if (this.selectedEntriesFromTree) {
                for (let id in this.selectedEntriesFromTree) {
                    let entry = this.selectedEntriesFromTree[id];
                    if (entry != null) {
                        selected.push(entry);
                    }
                }
            }
            return selected;
        },
        displayChildren: function(entry, entries, suffix, handlerId) {
            if (!suffix) suffix = "";
            let detailsInner = this.jq(ID_DETAILS_INNER + entry.getIdForDom() + suffix);
            let details = this.getEntryHtml(entry, {
                showHeader: false,
		showImage:entries.length==0
            });
            if (entries.length == 0) {
                detailsInner.html(details);
            } else {
                let entriesHtml = details;
                if (this.getProperty('showDetailsForGroup')) {
                    entriesHtml += details;
                }
                entriesHtml += this.getEntriesTree(entries, {
                    handlerId: handlerId
                });
                detailsInner.html(entriesHtml);
                this.addEntrySelect();
            }
        },


        getEntryMenuButton: function(entry) {
            let menuButton = HU.onClick(this.getGet() + ".showEntryMenu(event, '" + entry.getId() + "');",
					HU.image(RamaddaUtil.getCdnUrl("/icons/menu.png"),
						 [ATTR_CLASS, "display-entry-toolbar-item", ATTR_ID, this.getDomId(ID_MENU_BUTTON + entry.getIdForDom())]));
            return menuButton;
        },
        setOriginalRamadda: function(e) {
            this.originalRamadda = e;
        },
        setRamadda: function(e) {
            this.ramadda = e;
        },	
        getRamadda: function() {
            if (this.ramadda != null) {
                return this.ramadda;
            }
            if (this.ramaddaBaseUrl != null) {
                this.ramadda = getRamadda(this.ramaddaBaseUrl);
                return this.ramadda;
            }
            return getGlobalRamadda();
        },
        getEntry: async function(entryId, callback) {
            if (this.entriesMap && this.entriesMap[entryId]) {
                return Utils.call(callback, this.entriesMap[entryId]);
            }
            let ramadda = this.getRamadda();
            let toks = entryId.split(",");
            if (toks.length == 2) {
                entryId = toks[1];
                ramadda = getRamadda(toks[0]);
            }
            let entry = null;
            if (this.entryList != null) {
                await this.entryList.getEntry(entryId, e => entry = e);
            }
            if (entry == null) {
                await ramadda.getEntry(entryId, e => entry = e);
            }

            if (entry == null) {
                await this.getRamadda().getEntry(entryId, e => entry = e);
            }
            return Utils.call(callback, entry);
        },
        addMapLayer: async function(entryId) {
            let entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                console.log("No entry:" + entryId);
                return;
            }
            this.getDisplayManager().addMapLayer(this, entry);
        },
        doit: function() {
            console.log("doit");
        },
        createDisplay: async function(entryId, displayType, jsonUrl, displayProps) {
            let entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                console.log("No entry:" + entryId);
                return null;
            }
            let props = {
                sourceEntry: entry,
                entryId: entry.getId(),
		//                showMenu: false,
		//                showTitle: false,
                showDetails: true,
                title: entry.getName(),
		layoutHere:false,
            };
            if (displayProps) {
		$.extend(props, displayProps);
	    }

            //TODO: figure out when to create data, check for grids, etc
            if (displayType != DISPLAY_ENTRYLIST) {
                if (jsonUrl == null) {
                    jsonUrl = this.getPointUrl(entry);
                }
                let pointDataProps = {
                    entry: entry,
                    entryId: entry.getId()
                };
                props.data = new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
            }
            if (this.lastDisplay != null) {
                props.column = this.lastDisplay.getColumn();
                props.row = this.lastDisplay.getRow();
            } else {
                props.column = this.getProperty("newColumn", this.getColumn());
                props.row = this.getProperty("newRow", this.getRow());
            }
            this.lastDisplay = this.getDisplayManager().createDisplay(displayType, props);
        },
        getPointUrl: function(entry) {
            //check if it has point data
            let service = entry.getService("points.json");
            if (service != null) {
                return service.url;
            }
            service = entry.getService("grid.point.json");
            if (service != null) {
                return service.url;
            }
            return null;
        },
        getEntryMenu: async function(entryId, callback) {
            let entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                return Utils.call(callback, "null entry");
            }

            let get = this.getGet();
            let menus = [];
            let fileMenuItems = [];
            let viewMenuItems = [];
            let newMenuItems = [];
            viewMenuItems.push(HU.tag(TAG_LI, [], HU.tag(TAG_A, ["href", entry.getEntryUrl(), "target", "_"], "View Entry")));
            if (entry.getFilesize() > 0) {
                fileMenuItems.push(HU.tag(TAG_LI, [], HU.tag(TAG_A, ["download",null, "href", entry.getResourceUrl()], "Download " + entry.getFilename() + " (" + entry.getFormattedFilesize() + ")")));
            }

            if (this.jsonUrl != null) {
                fileMenuItems.push(HU.tag(TAG_LI, [], "Data: " + HU.onClick(get + ".fetchUrl('json');", "JSON") +
					  HU.onClick(get + ".fetchUrl('csv');", "CSV")));
            }

	    let props = "{showMenu:true,showTitle:true}";
            let newMenu = "<a>New</a><ul>";
            newMenu += HU.tag(TAG_LI, [], HU.onClick(get + ".createDisplay('" + entry.getFullId() + "','entrydisplay',null,null," + props+");", "New Entry Display"));
            newMenuItems.push(HU.tag(TAG_LI, [], HU.onClick(get + ".createDisplay('" + entry.getFullId() + "','entrydisplay',null,null," + props+");", "New Entry Display")));

            //check if it has point data
            let pointUrl = this.getPointUrl(entry);
            //            console.log("entry:" + entry.getName() + " url:" + pointUrl);

            if (pointUrl != null) {
                let types = window.globalDisplayTypes;
                let catMap = {};
                if (types) {
                    for (let i = 0; i < types.length; i++) {
                        let type = types[i];

                        if (!type.requiresData || !type.forUser) continue;
                        if (!Utils.isDefined(catMap[type.category])) {
                            catMap[type.category] = "<li> <a>" + type.category + "</a><ul>\n";
                        }
                        pointUrl = pointUrl.replace(/\'/g, "_");
                        let call = get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," + HU.sqt(type.type) + "," + HU.sqt(pointUrl) + ",null," + props +");";
                        let li = HU.tag(TAG_LI, [], HU.tag(TAG_A, ["onclick", call], type.label));
                        catMap[type.category] += li + "\n";
                        newMenuItems.push(li);
                    }
                }

                for (a in catMap) {
                    newMenu += catMap[a] + "</li></ul>";
                }
            }


            if (fileMenuItems.length > 0)
                menus.push("<a>File</a>" + HU.tag(TAG_UL, [], HU.join(fileMenuItems)));
            if (viewMenuItems.length > 0)
                menus.push("<a>View</a>" + HU.tag(TAG_UL, [], HU.join(viewMenuItems)));
            if (newMenuItems.length > 0)
                menus.push(newMenu);

            let topMenus = "";
            for (let i = 0; i < menus.length; i++) {
                topMenus += HU.tag(TAG_LI, [], menus[i]);
            }

            let menu = HU.tag(TAG_UL, [ATTR_ID, this.getDomId(ID_MENU_INNER + entry.getIdForDom()), ATTR_CLASS, "sf-menu"],
			      topMenus);
            callback(menu);
        },
        showEntryMenu: async function(event, entryId) {
            let menu;
            await this.getEntryMenu(entryId, m => {
                menu = m
            });
            this.writeHtml(ID_MENU_OUTER, menu);
            let srcId = this.getDomId(ID_MENU_BUTTON + Utils.cleanId(entryId));
	    this.dialog = HU.makeDialog({content:menu,anchor:srcId,draggable:false,header:false});
            $("#" + this.getDomId(ID_MENU_INNER + Utils.cleanId(entryId))).superfish({
                speed: 'fast',
                delay: 300
            });
        },
        fetchUrl: function(as, url) {
            if (url == null) {
                url = this.jsonUrl;
            }
            url = this.getDisplayManager().getJsonUrl(url, this);
            if (url == null) return;
            if (as != null && as != "json") {
                url = url.replace("points.json", "points." + as);
            }
            window.open(url, '_blank');
        },
        getMenuItems: function(menuItems) {

        },
        getDisplayMenuSettings: function() {
            let get = "getRamaddaDisplay('" + this.getId() + "')";
            let moveRight = HU.onClick(get + ".moveDisplayRight();", "Right");
            let moveLeft = HU.onClick(get + ".moveDisplayLeft();", "Left");
            let moveTop = HU.onClick(get + ".moveDisplayTop();", "Top");
            let moveUp = HU.onClick(get + ".moveDisplayUp();", "Up");
            let moveDown = HU.onClick(get + ".moveDisplayDown();", "Down");


            let menu = HU.open(TABLE,[ATTR_CLASS,'formtable']) +
                "<tr><td align=right><b>Move:</b></td><td>" + moveTop + " " + moveUp + " " + moveDown + " " + moveRight + " " + moveLeft + "</td></tr>" +
                "<tr><td align=right><b>Row:</b></td><td> " + HU.input("", this.getProperty("row", ""), ["size", "7", ATTR_ID, this.getDomId("row")]) + " &nbsp;&nbsp;<b>Col:</b> " + HU.input("", this.getProperty("column", ""), ["size", "7", ATTR_ID, this.getDomId("column")]) + "</td></tr>" +
                "<tr><td align=right><b>Width:</b></td><td> " + HU.input("", this.getProperty("width", ""), ["size", "7", ATTR_ID, this.getDomId("width")]) + "  " + "<b>Height:</b> " + HU.input("", this.getProperty("height", ""), ["size", "7", ATTR_ID, this.getDomId("height")]) + "</td></tr>" +
                "</table>";
            let tmp =
                HU.checkbox(this.getDomId("showtitle"), [], this.getProperty("showTitle")) + " Title  " +
                HU.checkbox(this.getDomId("showdetails"), [], this.getProperty("showDetails")) + " Details " +
                "&nbsp;&nbsp;&nbsp;" +
                HU.onClick(get + ".askSetTitle();", "Set Title");
            menu += HU.formTable() + HU.formEntry("Show:", tmp) + HU.close(TABLE);
            return menu;
        },
        loadInitialData: function() {
	    if(!this.getProperty("okToLoadData",true)) return;
	    if(this.getInlineDataSrc()) {
		this.getData();
		return;
	    }



            if (!this.needsData() || this.properties.theData == null) {
                return;
            }
            if (this.getProperty("latitude")) {
                this.properties.theData.lat = this.getProperty("latitude");
                this.properties.theData.lon = this.getProperty("longitude", "-105");
            }
            if (this.properties.theData.hasData()) {
                this.addData(this.properties.theData);
                return;
            }



            this.properties.theData.loadData(this);
        },
        getData: function() {
            if (!this.hasData()) {
		//Inline data
		if (this.properties.theData) {
		    return this.properties.theData;
		} 
		if(this.getInlineDataSrc()) {
		    this.addData(makeInlineData(this,this.getInlineDataSrc()));
		} else {
		    return null;
		}
	    }
            let dataList = this.dataCollection.getList();
            return dataList[0];
        },
        hasData: function() {
            if (this.dataCollection == null) return false;
            return this.dataCollection.hasData();
        },
        getCreatedInteractively: function() {
            return this.createdInteractively == true;
        },
        needsData: function() {
            return false;
        },
        askSetTitle: function() {
            let t = this.getTitle(false);
            let v = prompt(TITLE, t);
            if (v != null) {
                this.title = v;
                this.setProperty(ATTR_TITLE, v);
                this.setDisplayTitle(this.title);
            }
        },
        getShowDetails: function() {
            return this.getSelfProperty("showDetails", true);
        },
        setShowDetails: function(v) {
            this.showDetails = v;
            if (this.showDetails) {
                this.jq(ID_DETAILS).show();
            } else {
                this.jq(ID_DETAILS).hide();
            }
        },
        setShowTitle: function(v) {
	    if(v==="true") v = true;
	    else if(v==="false") v = true;	    
            this.setProperty("showTitle", v);
            if (v) {
                this.jq(ID_TITLE).show();
            } else {
                this.jq(ID_TITLE).hide();
            }
        },
        setDisplayProperty: function(key, value) {
            this.setProperty(key, value);
            $("#" + this.getDomId(key)).val(value);
        },
        deltaColumn: function(delta) {
            let column = parseInt(this.getProperty("column", 0));
            column += delta;
            if (column < 0) column = 0;
            this.setDisplayProperty("column", column);
            this.getLayoutManager().layoutChanged(this);
	    this.jq("col").val(column);
        },
        deltaRow: function(delta) {
            let row = parseInt(this.getProperty("row", 0));
	    if(isNaN(row)) row = 0;
            row += delta;
            if (row < 0) row = 0;
            this.setDisplayProperty("row", row);
            this.getLayoutManager().layoutChanged(this);
	    this.jq("row").val(row);
        },
        moveDisplayRight: function() {
            if (this.getLayoutManager().isLayoutColumns()) {
                this.deltaColumn(1);
            } else {
                this.getLayoutManager().moveDisplayDown(this);
            }
        },
        moveDisplayLeft: function() {
            if (this.getLayoutManager().isLayoutColumns()) {
                this.deltaColumn(-1);
            } else {
                this.getLayoutManager().moveDisplayUp(this);
            }
        },
        moveDisplayUp: function() {
            if (this.getLayoutManager().isLayoutRows()) {
                this.deltaRow(-1);
            } else {
                this.getLayoutManager().moveDisplayUp(this);
            }
        },
        moveDisplayDown: function() {
            if (this.getLayoutManager().isLayoutRows()) {
                this.deltaRow(1);
            } else {
                this.getLayoutManager().moveDisplayDown(this);
            }
        },
        moveDisplayTop: function() {
            this.getLayoutManager().moveDisplayTop(this);
        },
        getDialogContents: function(tabTitles, tabContents) {
	    this.getDisplayDialogContents(tabTitles, tabContents);
        },
	showFieldsInDialog: function() {
	    return false;
	},
        getDisplayDialogContents: function(tabTitles, tabContents) {

            if (this.hasData()) {
	        let html = HU.div([ATTR_ID, this.domId(ID_FIELDS)],"");
		tabTitles.push("Fields");
		tabContents.push(html);
	    } 

            let get = this.getGet();
            let menuItems = [];
            this.getMenuItems(menuItems);
            let form = "<form>";

            form += this.getDisplayMenuSettings();
            for (let i = 0; i < menuItems.length; i++) {
                form += HU.div([ATTR_CLASS, "display-menu-item"], menuItems[i]);
            }
            form += "</form>";
            tabTitles.push("Display"); 
            tabContents.push(form);
        },	
        checkLayout: function() {
	},
	isActiveDisplay: function() {
            return this.getMainDiv().length;
	},
	handleWindowResize:function() {
	    if(this.isActiveDisplay()) {
		this.displayData();
	    } else {
		//TODO: remove this display from the global list?
		//		this.logMsg("not active");
	    }
	},
        displayData: function() {},
        setDisplayReady: function() {
//	    console.log("setDisplayReady");
	    let callUpdate = !this.displayReady;
            this.displayReady = true;
	    if(callUpdate) {
		this.callUpdateUI({force:true});
	    }
        },
        getDisplayReady: function() {
            return this.displayReady;
        },
        pageHasLoaded: function() {
	    if(!this.displayReady) {
		this.setDisplayReady(true);
	    }
        },
	checkFinished: function() {
	    return false;
	},
	getIsFinished() {
	    return this.isFinished;
	},
	setIsFinished() {
//	    console.log(this.type+" isFinished");
	    this.isFinished = true;
	},	
	isDisplayFinished: function() {
	    if(this.checkFinished()) {
		return this.getIsFinished();
	    }
            if (!this.hasData()) {
		if(this.needsData()) {
		    return false;
		}
	    }
	    return true;
	},
	doFinalInitialization:function() {
	},
        initDisplay: function() {
	    if(this.inError) return
            this.createUI();
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().makeControls();
            }
            this.checkSearchBar();
	    this.callUpdateUI({force:true});
	    if(this.getProperty("reloadSeconds")) {
		this.runReload();
	    }
        },
	runReload: function() {
	    setTimeout(() =>{
		this.reloadData();
		this.runReload();
	    }, this.getProperty("reloadSeconds")*1000);
	},
        getMainDiv: function() {
	    //Don't check the parent for the targetDiv
	    let divId = this.getProperty("targetDiv",this.getProperty(PROP_DIVID,null,null,true),null,true);
	    return $("#" + divId); 
	},
        getGroupDiv: function() {
	    return $("#" + this.getProperty("groupDiv"));
	},	
        createUI: function() {
	    let divId = this.getProperty("targetDiv",this.getProperty(PROP_DIVID,null,null,true),null,true);
            if (divId != null) {
                let html = this.getHtml();
//		console.log("*****",html,"*******");
		let div = $("#" + divId);
		let inline = this.getDisplayInline();
		if(inline) {
		    div.css("display","inline-block");
		    div.css("vertical-align","bottom");
		} 
		let width = this.getWidth("100%");
		if(!inline && width && width!="-1") {
                    div.css("width",HU.getDimension(width));
		}
		let commandText = this.getHeaderText();
		let commandMap = {};
		let headerDiv=div;
		if(commandText) {
		    let cmd= this.createCommandText(commandText, commandMap);
		    if(this.getHeaderTextDiv()) {
			headerDiv=jqid(this.getHeaderTextDiv());
			headerDiv.html(cmd);
		    } else {
			html = cmd+ html;
		    }
		}
		div.html(html);
		if(commandText)
		    this.initCommandText(commandMap,headerDiv);
            } else {
                console.log("error: no div defined for display:" + this.getType());
            }
        },
	getMenuButton:function() {
            let get = this.getGet();
            let button = HU.onClick(get + ".showDialog();",
				    HU.image(RamaddaUtil.getCdnUrl("/icons/downdart.png"),
					     [ATTR_TITLE,'Show display menu',ATTR_CLASS, "display-dialog-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)]));
	    button+=" ";
	    return button;
	},

        /*
          This creates the default layout for a display
          Its a table:
          <td>title id=ID_HEADER</td><td>align-right popup menu</td>
          <td colspan=2><div id=ID_DISPLAY_CONTENTS></div></td>
          the getDisplayContents method by default returns:
          <div id=ID_DISPLAY_CONTENTS></div>
          but can be overwritten by sub classes

          After getHtml is called the DisplayManager will add the html to the DOM then call
          initDisplay
          That needs to call setContents with the html contents of the display
        */
        getHtml: function() {
            let contents = this.getContentsDiv();
	    if(this.getNoWrapper()) return contents;

            let get = this.getGet();
            let button = "";
            if (this.getShowMenu() || this.getShowMenuRight()) {
                button = this.getMenuButton();
            }
            let title = "";
            if (this.getShowTitle()) {
                title = this.getTitle(false).trim();
            }

	    let rightContents='';
	    if(this.getShowMenuRight()) {
		rightContents =button;
		button='';
	    }
            let topLeft = "";
            if (button != "" || title != "") {
                let titleDiv = this.getTitleHtml(title);
                if (button == "") {
                    topLeft = titleDiv;
                } else {
                    topLeft = HU.div([ATTR_CLASS,"display-header"], button + SPACE + titleDiv);
                }
		
            }
            topLeft = HU.div([ATTR_ID, this.getDomId(ID_TOP_LEFT),ATTR_CLASS,"display-header-block"], topLeft);

	    let headerStyle = this.getProperty('headerStyle','');
	    let h2Separate = this.getAnimationEnabled();
	    let h1 = 	HU.div([ATTR_STYLE,headerStyle,ID,this.getDomId(ID_HEADER1),ATTR_CLASS,"display-header-block display-header1"], "");
	    let h2 = HU.div([ATTR_STYLE,headerStyle,ID,this.getDomId(ID_HEADER2),ATTR_CLASS,"display-header-block display-header2"], "");
            let topCenter = HU.div([ATTR_ID, this.getDomId(ID_TOP),ATTR_CLASS,"display-header-block"], h2Separate?"":h2);
            let topRight = HU.div([ATTR_ID, this.getDomId(ID_TOP_RIGHT)], rightContents);
	    let top =  this.getProperty("showHeader",true)?HU.leftCenterRight(topLeft, topCenter, topRight, null, null, null,{
                valign: "bottom"
            }):"";
	    //See if we are drawing the header somewhere else
	    if(this.getHeaderDiv()) {
		$('#'+ this.getHeaderDiv()).html(top);
		top='';
	    }

            let header = h1;
	    if(h2Separate) header+=h2;
	    top =  header +  top;	    
	    let colorTable = HU.div([ATTR_ID,this.getDomId(ID_COLORTABLE)]);
	    let rightInner="";
	    let leftInner="";

	    let bottom='';
	    let legend = HU.div([ATTR_ID,this.getDomId(ID_LEGEND)]);

	    let ctSide = this.getProperty("colorTableSide","bottom");
	    if(ctSide=="top") {
		top+=colorTable;
	    } else if(ctSide=="right") {
		rightInner += colorTable;
	    } else if(ctSide=="left") {
		leftInner += colorTable;
	    } else {
		bottom+=colorTable;
	    }
	    bottom += HU.div([ATTR_CLASS, "", ATTR_ID, this.getDomId(ID_BOTTOM)]);
	    bottom+=legend;
	    let leftStyle = "";
	    if(this.getProperty("leftSideWidth"))
		leftStyle = HU.css("width",HU.getDimension(this.getProperty("leftSideWidth")));
	    let left = HU.div([ATTR_ID, this.getDomId(ID_LEFT),ATTR_STYLE,leftStyle],leftInner);
	    let right = HU.div([ATTR_ID, this.getDomId(ID_RIGHT)],rightInner);
	    let sideWidth = "1px";
	    let centerWidth = "100%";	    
	    let h0 = 	HU.div([ATTR_ID,this.getDomId(ID_HEADER0),ATTR_CLASS,"display-header-block display-header0"], "");
	    //Gack! We set a transparent 1px border here because for some reason the google charts will have a little bit of scroll in them if we don't set a border	
            let table =   h0+HU.open('table', [ATTR_STYLE,this.isGoogleChart?"border:1px solid transparent;":'',ATTR_CLASS, 'display-ui-table', ATTR_WIDTH,'100%','border','0','cellpadding','0','cellspacing','0']);
	    if(this.getShowTopHeader(this.getProperty('showDisplayTop',true))) {
		table+= HU.tr([],HU.td([ATTR_WIDTH,sideWidth]) + HU.td([ATTR_WIDTH,centerWidth],top) +HU.td([ATTR_WIDTH,sideWidth]));
	    }
	    table+= HU.tr(["valign","top"],HU.td([ATTR_WIDTH,sideWidth],left) + HU.td([ATTR_WIDTH,centerWidth],contents) +HU.td([ATTR_WIDTH,sideWidth],right));
	    if(this.getProperty('showDisplayBottom',true)) {
		if(this.getFooterDiv(this.getProperty('bottomDiv'))) {
		    jqid(this.getFooterDiv(this.getProperty('bottomDiv'))).html(bottom);
		    bottom = "";
		}
		table+= HU.tr([],HU.td([ATTR_WIDTH,sideWidth]) + HU.td([ATTR_WIDTH,centerWidth],bottom) +HU.td([ATTR_WIDTH,sideWidth]));
	    }
	    table+=HU.close('table');
	    let message= HU.div([ATTR_ID,this.domId(ID_DISPLAY_MESSAGE),ATTR_CLASS,"display-output-message", ATTR_STYLE,HU.css("display","none","position","absolute","top","10px","left","50%",
									"-webkit-transform","translateX(-50%)","transform","translateX(-50%)")],"");
            let html =  HU.div([ATTR_CLASS, 'ramadda-popup', ATTR_STYLE,"display:none;", ATTR_ID, this.getDomId(ID_MENU_OUTER)], '');
            let style = this.getProperty('displayStyle', '');
            html += HU.div([ATTR_ID,this.domId(ID_DISPLAY_CONTAINER),'spellcheck', 'false',ATTR_CLASS, 'display-contents display-' + this.type +'-contents', ATTR_STYLE, HU.css('position','relative') + style],table + message);
            return html;
        },
        getWidthForStyle: function(dflt) {
            let width = this.getProperty("width", -1);
            if (width == -1) return dflt;
	    return HU.getDimension(width);
        },
        getHeightForStyle: function(dflt) {
            let height = this.getProperty("height", -1);
            if (height == -1) return dflt;
            if (new String(height).match("^[0-9]+$")) {
                height = height + "px";
	    }
            return height;
        },
        getContentsStyle: function() {

            let style = "";
            let height = this.getHeightForStyle();
            if (height) {
                style += HU.css(HEIGHT, height);
            }

            let maxheight = this.getProperty("maxHeight");
            if (maxheight) {
                style += HU.css("max-height", HU.getDimension(maxheight),"overflow-y","auto");
            }	    
            return style;
        },
	getContentsClass: function() {
	    return "ramadda-expandable-target display-contents-inner display-" + this.type;
	},
        getContentsDiv: function() {
            let style = this.getContentsStyle();
            style += this.getProperty("contentsStyle", "");
            let image = this.getProperty("backgroundImage");
            if (image) {
                image = HU.getEntryImage(this.entryId, image);
                style += HU.css("background-attachment","auto","background-size","100% auto","background-image","url('" + image + "')");
            }
            let background = this.getProperty("background");
            if (background)
                style += HU.css("background", background);
            let topBottomStyle = "";
	    //            let width = this.getWidthForStyle();
	    //            if (width) {
	    //                topBottomStyle += HU.css("width", width);
	    //            }
            let top = HU.div([ATTR_STYLE, topBottomStyle, ATTR_ID, this.getDomId(ID_DISPLAY_TOP)], "");
            let bottom = HU.div([ATTR_STYLE, topBottomStyle, ATTR_ID, this.getDomId(ID_DISPLAY_BOTTOM)], "");
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(expandedHeight)
		style+=HU.css(HEIGHT,expandedHeight);
	    if(!this.getProperty("showInnerContents",true)) {
		style+="display:none;";
	    }		
	    let contentsAttrs =[ATTR_CLASS, this.getContentsClass(), ATTR_STYLE, style, ATTR_ID, this.getDomId(ID_DISPLAY_CONTENTS)];

	    if(this.getProperty("expandableHeight")) {
		contentsAttrs.push("expandable-height");
		contentsAttrs.push(this.getProperty("expandableHeight"));
	    }
	    let mainDiv = HU.div(contentsAttrs, "");
	    if(this.getNoWrapper()) return mainDiv;

	    let contents =  top + "\n" +mainDiv + "\n" +bottom;
            return contents;
        },

        //Gets called before the displays are laid out
        prepareToLayout: function() {
            //Force setting the property from the input dom (which is about to go away)
            this.getColumn();
            this.getWidth();
            this.getHeight();
            this.getName();
            this.getEventSource();
        },
        getColumn: function() {
            return this.getFormValue("column", 0);
        },
        getRow: function() {
            return this.getFormValue("row", 0);
        },
        getWidth: function(dflt) {
            return this.getFormValue("width", dflt);
        },
        getHeight: function() {
            return this.getFormValue("height", 0);
        },
        getDisplayTitle: function(title) {
            if (!title) title = this.title != null ? this.title : "";
            let text = title;
            let fields = this.lastSelectedFields;
            if (fields && fields.length > 0)
                text = text.replace("{field}", fields[0].getLabel());
            else
                text = text.replace("{field}", HU.span([ATTR_ID,this.getDomId(ID_TITLE_FIELD)],"&nbsp;"));
            return text;
        },

        setDisplayTitle: function(title) {
            if (!Utils.stringDefined(title)) {
                title = this.getTitle(false).trim();
            }
            let text = this.getTitleHtml(title);
            if (this.getShowTitle()) {
                this.jq(ID_TITLE).show();
            } else {
                this.jq(ID_TITLE).hide();
            }
            this.writeHtml(ID_TITLE, text);
        },
	applyTitleTemplate:function(titleTemplate) {
	    let title = titleTemplate.replace(/\${title}/g,this.getProperty(ATTR_TITLE)??'');
	    let data = this.getPointData();
	    if (data && data.records && data.records.length)  {
		title = title.replace(/_first/g,'');
		title = this.applyRecordTemplate(data.records[0],null,null, title);
		title = title.replace(/_last/g,'');
		title = this.applyRecordTemplate(data.records[data.records.length-1],null,null, title);		    
	    }
	    title = title.replace(/\${.*?}/g,'');
	    return title;
	},
        getTitle: function(showMenuButton) {
            let prefix = "";
            if (showMenuButton && this.hasEntries()) {
                prefix = this.getEntryMenuButton(this.getEntries()[0]) + " ";
            }
	    

            let title = this.getProperty(ATTR_TITLE);
            let titleTemplate = this.getTitleTemplate();
            if (titleTemplate != null) {
		title = this.applyTitleTemplate(titleTemplate);
                return prefix + title;
            }
	    if(Utils.stringDefined(title))  return title;
            if (this.dataCollection == null) {
                return prefix;
            }
            let dataList = this.dataCollection.getList();
            title = "";
            for (let collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                let pointData = dataList[collectionIdx];
                if (collectionIdx > 0) title += "/";
                title += pointData.getName();
            }

            return prefix + title;
        },
        getIsLayoutFixed: function() {
            return this.getProperty(PROP_LAYOUT_HERE, true);
        },

        makeToolbar: function(props) {
            let toolbar = "";
            let get = this.getGet();
            let addLabel = props.addLabel;
            let images = [];
            let calls = [];
            let labels = [];
            if (!this.getIsLayoutFixed()) {
                calls.push("removeRamaddaDisplay('" + this.getId() + "')");
                images.push("fa-cut");
		labels.push("Delete display");
            }
            calls.push(get + ".copyDisplay();");
	    images.push("fa-copy");
            labels.push("Copy Display");
            if (this.jsonUrl != null) {
                calls.push(get + ".fetchUrl('json');");
                images.push(RamaddaUtil.getCdnUrl("/icons/json.png"));
                labels.push("Download JSON");

                calls.push(get + ".fetchUrl('csv');");
                images.push(RamaddaUtil.getCdnUrl("/icons/csv.png"));
                labels.push("Download CSV");
            }
            for (let i = 0; i < calls.length; i++) {
                let inner = HU.getIconImage(images[i], [ATTR_TITLE, labels[i], ATTR_CLASS, "display-dialog-header-icon"]);
                if (addLabel) inner += " " + labels[i] + "<br>";
                toolbar += HU.onClick(calls[i], inner);
            }
            return toolbar;
        },

	getHeader2:function() {
	    return "";
	},
	initHeader2:function() {
	},
	writeHeader:function(header,html) {
	    if(html=="") {
		this.jq(header).css("display","none");
	    } else {
		this.jq(header).css("display","inline-block");
	    }
	    this.jq(header).html(html);
	},

        //This keeps checking the width of the chart element if its zero
        //we do this for displaying in tabs
        checkLayout: function() {
            let d = this.jq(ID_DISPLAY_CONTENTS);
	    let w= d.width();
            if (this.lastWidth != w) {
		this.lastWidth = w;
                this.displayData();
            }
	},


        forceUpdateUI: function() {
	    this.haveCalledUpdateUI = false;
	    this.callUpdateUI();
	},
	callUpdateUI: function(args) {
	    args = args || {};
	    try {
		if(args.force)
		    this.haveCalledUpdateUI = false;
		this.updateUI(args);
	    } catch(err) {
		this.handleError("Error:" + err,err);
	    }
	},
        updateUI: function(args) {
	},
	getFilterId: function(id) {
	    return  this.getDomId("filterby_" + id);
	},
	getRequestMacros: function() {
	    if(!this.requestMacros) {
		this.requestMacros  = this.getRequestMacrosInner();
	    }
	    return this.requestMacros;
	},
	getRequestMacrosInner: function() {
	    if(this.getProperty('requestFieldsDefault')|| this.getProperty('requestFields')) {
		//clear them out
		this.requestMacros = null;
		[['requestFields','date,stride,skip,limit'],
		 ['requestFieldsToggleOpen',true],
		 ['request.date.type','daterange'],
		 ['request.stride.title','Specify a skip factor'],
		 ['request.stride.includeNone',false],
		 ['request.stride.type','enumeration'],
		 ['request.stride.values','0:None,1,2,3,4,5,6,7,8,9,10,15,20,30,40,50,75,100'],
		 ['request.stride.default',0],
		 ['request.limit.label','# Records'],
		 ['request.limit.title','Limit how many records to return'],
		 ['request.limit.size','4'],
		 ['request.skip.size','4'],
		 ['request.skip.type','skip'],		 
		 ['request.skip.default',this.getProperty('skip','0')],
		 ['request.limit.default',this.getProperty('max','20000')],
		 ['requestFieldsLive',false]].forEach(pair=>{
		     if(!Utils.isDefined(this.getProperty(pair[0]))) {
			 this.setProperty(pair[0],pair[1]);
		     }
		 });
	    }		


	    let macros =[];
	    let p = this.getProperty("requestFields","");
	    let e1 = this.getProperty("extraFields1","");
	    let e2 = this.getProperty("extraFields2","");
	    let list = Utils.mergeLists(e1.split(","),p.split(","),e2.split(","));
//	    if(p!="")console.log("requestFields=" + p);
	    list.forEach(macro=>{
		if(macro=="") return;
		macros.push(new RequestMacro(this, macro));
	    });
	    macros.forEach(macro=>{
		macro.initMacros(macros);
	    });


	    return macros;
	},
	applyRequestProperties: function(props) {
	    if(!props) return;
	    this.requestMacros = null;
	    this.dynamicProperties = props;
	    this.createRequestProperties();
	},
	createRequestProperties: function() {

	    let requestProps = "";
	    let macros = this.getRequestMacros();
	    let macroDateIds = [];
	    let live = this.getRequestFieldsLive();
	    let list = [];
	    let space = HU.space(2);
	    if(!live)
		requestProps+=HU.span([ATTR_CLASS,'ramadda-button-small',
				       ATTR_TITLE,'Reload data',ATTR_STYLE,'',ATTR_CLASS,'',ATTR_ID,this.domId('requestapply')],HU.getIconImage('fa-solid fa-rotate-right')) + space;

	    macros.forEach(macro=>{
		requestProps+=macro.getWidget(macroDateIds);
		if(macro.isVisible()) {
		    requestProps+=space;
		}
	    });
	    if(this.getRequestFieldsToggle()) {
		requestProps=HU.toggleBlock(this.getProperty('requestFieldsToggleLabel','Select') + HU.space(3),requestProps,
					    this.getProperty('requestFieldsToggleOpen',false),
					    {orientation:'horizontal'});
	    }
	    if(Utils.stringDefined(requestProps)) {
		let show = this.getRequestFieldsShow();
		if(!show) {
		    requestProps = HU.div([ATTR_STYLE,'display:none;'], requestProps);
		} 
		this.writeHeader(ID_REQUEST_PROPERTIES,  HU.div([],requestProps));
		if(!this.getRequestFieldsShow()) {
		    //Hide this so it doesn't screw up the spacing
//		    this.jq(ID_REQUEST_PROPERTIES).css(
		}
	    }
	    //Keep track of the values because there can be spurious changes triggered
	    //when the user clicks in a time range field
	    let valueMap = {}
	    let applyButton = this.jq('requestapply').button();
	    let applyRequest = ()=>{
		applyButton.css('background','');
		applyButton.css('border-color','');		    
		this.macroChanged();
		this.reloadData();
	    };
	    let macroChange = (macro,value,what,force,apply)=>{
		if(macro) macro.notifyChange();
		if(what) {
		    if(!force && value == valueMap[macro.urlarg+'_'+what]) {
			//console.log('duplicate:' + value);
			return
		    }
		    valueMap[macro.urlarg+'_'+what]  =value;
		    //console.dir('new value:' + macro.urlarg + ' ' + what +' :' +value+':')
		}

		if(this.settingMacroValue) return;
//		console.log('macro change-2',apply,live,macro.triggerReload);
		let reloaded = false;

		if((apply || live) && macro.triggerReload) {
		    reloaded=true;
		    applyRequest();
		} else {
		    applyButton.css('background','yellow');
		    applyButton.css('border-color','#000');		    
		}
		if(!macro.name) return;
		this.settingMacroValue = true;
		let args = {
		    entryId:this.entryId,
		    property: "macroValue",
		    id:macro.name,
		    what:what,
		    value: value
		};
		this.propagateEvent(DisplayEvent.propertyChanged, args);
		this.settingMacroValue = false;
	    };

	    applyButton.click(()=>{
		applyRequest();
	    });

	    let sliderFunc = function() {
		//		macroChangeinputFunc
	    };

	    macroDateIds.forEach(id=>{
		HU.datePickerInit(id);
	    });
	    this.jq(ID_HEADER2).find(".display-request-reload").click(()=>{
		macroChange({triggerReload:true});
	    });
	    macros.every(macro=>{
		macro.initWidget(macroChange);
		let  keyup =function(e,what,val,force) {
		      let keyCode = e.keyCode || e.which;
		      if (keyCode == 13) {
			  macroChange(macro, val,what,force,true);
		      }
		};

		$("#" + this.getDomId(macro.getId())+"," +
		  "#" + this.getDomId(macro.getId()+"_min")+ "," +
		  "#" + this.getDomId(macro.getId()+"_max")).keyup(function(e){
		      keyup(e,null,$(this).val())});
		if(macro.type == "bounds") {
		    this.jq(macro.getId()).change(function(e) {
			macroChange(macro,$(this).is(':checked'));
		    });
		}
		if(macro.type=="enumeration") {
		    this.jq(macro.getId()).change(function(e) {
			macroChange(macro, $(this).val());
		    });
		}
		this.jq(macro.getId()+"_min").change(function(e) {
		    //		    macroChange(macro, $(this).val(),"min");
		});
		this.jq(macro.getId()+"_max").change(function(e) {
		    //		    macroChange(macro, $(this).val(),"max");
		});
		let from = this.jq(macro.getId()+"_from");
		let to = this.jq(macro.getId()+"_to");
		if(from.length) {
		    //true->force the change
		    from.keyup(function(e){
			keyup(e,'from',$(this).val(),true)});
		    to.keyup(function(e){
			keyup(e,'to',$(this).val(),true)});		    


		    valueMap[macro.urlarg+'_from']  =from.val();
		    valueMap[macro.urlarg+'_to']  =to.val();		    
		    from.change(function(e) {
			macroChange(macro, $(this).val(),"from");
		    });
		    to.change(function(e) {
			macroChange(macro, $(this).val(),"to");
		    });
		}
		return true;
	    });
	},
	makeFilterWidget:function(name,label, widget, title) {
	    if(!label)
		return HU.div([ATTR_CLASS,"display-filter-widget"],widget);
	    label = this.makeFilterLabel(label,title)+(label.trim().length==0?" ":": ");
	    if(this.getFilterLabelVertical(this.getProperty(name+'.filterLabelVertical')))
		label = label+'<br>'+widget;							       
	    else
		label = label+widget;
	    return HU.div([ATTR_CLASS,"display-filter-widget"],label);
	},
	makeFilterLabel: function(label,tt,vertical) {
	    let clazz = "display-filter-label";
	    if(vertical)
		clazz+= " display-filter-label-vertical ";
	    let attrs = [ATTR_CLASS,clazz];
	    if(tt)  {
		attrs.push(TITLE);
		attrs.push(tt);
	    }
	    return HU.span(attrs,label);
	},

	stepFilterDateAnimation: function(inputFunc, dir){
	    let select = $("#" +this.getFilterId(ID_FILTER_DATE));
	    let index = select[0].selectedIndex;
	    let length = select.find('option').length;
	    index+=dir;
	    if(index>=length) {
		return;
//		index =0;
	    } else if(index<0) {
		return;
//		index = length-1;
	    }
	    select[0].selectedIndex = index;
	    inputFunc(select);
	    if(this.filterDatePlayingAnimation) {
		setTimeout(()=>{
		    this.stepFilterDateAnimation(inputFunc,1);
		},this.getProperty("filterDateAnimationSleep",1000));
	    }
	},

	addFilters: function(filters) {
	},
	initializeRangeSlider:function(jq, inputFunc, immediate) {
	    let _this = this;
	    jq.mousedown(function(){
		let id = $(this).attr(ID);
		//Do these like this in case we have a field that ends with _max
		let type = $(this).attr('data-type');
		if(id.endsWith("_min")) {
		    id = id.replace(/_min$/,"");
		} else if(id.endsWith("_max")) {
			id = id.replace(/_max$/,"");
		}
		let min = $("#" + id+"_min");
		let max = $("#" + id+"_max");
		let range = {
		    min: parseFloat(min.attr("data-min")),
		    max: parseFloat(max.attr("data-max"))};
		let smin =  String(min.attr("data-min")).replace(/.*\./,"");
		let smax =  String(max.attr("data-max")).replace(/.*\./,"");		
		let numDecimals = Math.max(2,Math.max(smin.length,smax.length));
		let minValue = parseFloat(min.val());
		let maxValue = parseFloat(max.val());
		if(minValue==parseInt(minValue) && maxValue==parseInt(maxValue))
		    numDecimals = 0;

		let html = HU.div([ATTR_ID,"filter-range",ATTR_STYLE,HU.css("width","200px")],"");
		let popup = HtmlUtils.getTooltip();
		popup.html(html);
		popup.show();

		popup.position({
		    of: min,
		    my: "left top",
		    at: "left bottom+2",
		    collision: "fit fit"
                });

		if(isNaN(minValue)) minValue = range.min;	
		if(isNaN(maxValue)) maxValue = range.max;
		let step = 1;
		if(type == "double" || parseInt(range.max)!=range.max || parseInt(range.min) != range.min) 
		    step = (range.max-range.min)/100000;
		$( "#filter-range" ).slider({
		    range: true,
		    min: range.min,
		    max: range.max,
		    step: step,
		    values: [minValue, maxValue],
		    slide: function( event, ui ) {
			let minv = String(Utils.roundDecimals(ui.values[0], numDecimals));
			let maxv = String(Utils.roundDecimals(ui.values[1], numDecimals));
			if(minv.endsWith(".")) minv = minv.replace(/\./,"");
			if(maxv.endsWith(".")) maxv = maxv.replace(/\./,"");			
			min.val(minv);
			max.val(maxv);
			min.attr("data-value",min.val());
			max.attr("data-value",max.val());
			if(immediate) {
			    inputFunc(min,max);
			}
		    },
		    stop: function() {
			let popup = HtmlUtils.getTooltip();
			popup.hide();
			_this.checkFilterField(max);
			inputFunc(min,max);
		    }
		});
	    });
	},
	getRecordFilter: function(fieldId) {
	    if(this.filters) {
		for(let i=0;i<this.filters.length;i++) {
		    let filter = this.filters[i];
		    if(filter.field && filter.field.getId() == fieldId) return filter;
		    if(filter.id == fieldId) return filter;		    
		}
	    }
	    return null;
	},
        checkSearchBar: function() {
            if (!this.hasData()) {
		return
	    }


	    let hideFilterWidget = this.getProperty("hideFilterWidget",false, true);
	    let vertical =  this.getProperty("headerOrientation","horizontal") == "vertical";
	    let filterClass = "display-filter";
	    let debug = displayDebug.checkSearchBar;
	    if(debug) console.log("checkSearchBar");
            let _this = this;

            let colorBy = this.getFieldById(null, this.getProperty("colorBy",""));
            this.colorByFields = this.getFieldsByIds(null, this.getProperty("colorByFields", "", true));
            this.sizeByFields = this.getFieldsByIds(null, this.getProperty("sizeByFields", "", true));
            this.sortByFields = this.getFieldsByIds(null, this.getProperty("sortByFields", "", true));	    

	    let pointData = this.getData();
            if (pointData == null) return;
            let fields= this.getFields();
            let records = this.getRecords();
	    records = this.sortRecords(records);
	    let header2="";
	    //	    header2 +=HU.div([ATTR_ID,this.getDomId("test")],"test");
	    if(this.getShowProgress(false)) {
		header2 += HU.div([ATTR_ID,this.getDomId(ID_DISPLAY_PROGRESS), ATTR_STYLE,HU.css("display","inline-block","margin-right","4px","min-width","20px")]);
	    }
	    let headerLabel  = this.getHeaderLabel();
	    if(Utils.stringDefined(headerLabel)) {
		header2 += HU.div([ATTR_CLASS,CLASS_HEADER_SPAN+' '+CLASS_HEADER_LABEL],headerLabel);
	    }
	    header2 += HU.div([ATTR_ID,this.getDomId(ID_HEADER2_PREPREPREFIX),ATTR_CLASS,CLASS_HEADER_SPAN],"");
	    header2 += HU.div([ATTR_ID,this.getDomId(ID_HEADER2_PREPREFIX),ATTR_CLASS,CLASS_HEADER_SPAN],"");
	    header2 += HU.div([ATTR_ID,this.getDomId(ID_HEADER2_PREFIX),ATTR_CLASS,CLASS_HEADER_SPAN],"");
	    header2 +=  this.getHeader2();
	    if(this.getProperty("pageRequest",false) || this.getFilterPaginate()) {
		
		header2 += HU.div([ATTR_CLASS,CLASS_HEADER_SPAN+" display-filter",ATTR_ID,this.getDomId(ID_PAGE_COUNT)]);
	    }
	    header2+=HU.div([ATTR_ID,this.getDomId(ID_REQUEST_PROPERTIES),ATTR_CLASS,CLASS_HEADER_SPAN],"");


	    if(this.getProperty("legendFields") || this.getProperty("showFieldLegend",false)) {
		let colors = this.getColorList();
		let fields =  this.getFieldsByIds(null, this.getProperty("legendFields", this.getPropertyFields(this.getProperty("sumFields"))));
		let html = "";
		let colorCnt = 0;
		fields.forEach((f)=>{
		    if(colorCnt>=colors.length) colorCnt = 0;
		    let color  = colors[colorCnt];
		    html += HU.div([ATTR_STYLE,HU.css("display","inline-block","width","8px","height","8px","background",color)]) +" " + f.getLabel() +"&nbsp;&nbsp; ";
		    colorCnt++;
		});
		header2+= HU.div([ATTR_CLASS,"display-field-legend"], html);

	    }

	    if(this.getProperty("showDisplayFieldsMenu",false)) {
		let displayFields =  pointData.getChartableFields();
		if(displayFields.length) {
		    let fields = this.getSelectedFields();
		    let selected =[];
		    fields.forEach(f=>selected.push(f.getId()));
		    let enums = [];
		    displayFields.forEach(field=>{
			if(field.isFieldGeo()) return;
			enums.push([field.getId(),field.getLabel()]);
		    });
		    let attrs = [ATTR_ID,this.getDomId("displayfields")];
		    if(this.getProperty("displayFieldsMenuMultiple",false)) {
			attrs.push("multiple");
			attrs.push("true");
			attrs.push("size");
			attrs.push("4");
		    }
		    this.displayFieldsMenuEnums = enums;
		    let html =  HU.span([ATTR_CLASS,filterClass],
				       this.makeFilterLabel("Display: ") + HU.select("",attrs,enums,selected))+SPACE;
		    let side = this.getProperty("displayFieldsMenuSide","top");
		    if(side == "left") {
			this.jq(ID_LEFT).append(html);
		    } else {
			//TODO: do the other sides
			header2+=html;
		    }
		}
	    }


	    let selectFields = this.getProperty("selectFields");
	    let selectFieldProps = [];
	    if(selectFields) {
		selectFields.split(";").forEach(t=>{
		    //htmlLayerField:Sparkline Field:field1,field2
		    let [prop,label,fields]  = t.split(":");
		    if(fields==null) {
			fields = label;
			label = Utils.makeLabel(prop);
		    }
		    let selectFields = this.getFieldsByIds(null,fields);
		    let enums = [];
		    selectFields.forEach(field=>{
			if(field.isFieldGeo()) return;
			enums.push([field.getId(),field.getLabel()]);
		    });
		    header2 += HU.span([ATTR_CLASS,filterClass],
				       (label==""?"":this.makeFilterLabel(label+": ")) + 
				       HU.select("",[ATTR_ID,this.getDomId("fieldselect_" + prop)],enums,this.getProperty(prop,"")))+SPACE;

		    selectFieldProps.push(prop);
		});
	    }


	    if(this.colorByFields.length>0) {
		let enums = [];
		this.colorByFields.forEach(field=>{
		    if(field.isFieldGeo()) return;
		    enums.push([field.getId(),field.getLabel(this)]);
		});
		let selected = colorBy?colorBy.getId():"";
		let label = this.makeFilterLabel(this.getProperty("colorByLabel", "Color by:&nbsp;"));
		header2 += HU.span([ATTR_CLASS,filterClass],
				   label+ HU.select("",[ATTR_ID,this.getDomId("colorbyselect")],enums,selected,20))+SPACE;
	    }
	    let sortAscending = this.getProperty("sortAscending",true);
	    if(this.sortByFields.length>0) {
		let enums = [];
		this.sortByFields.forEach(field=>{
		    if(field.isFieldGeo()) return;
		    let id = field.getId();
		    let label = field.getLabel();
		    if(Utils.stringDefined(field.getGroup())) {
			label = field.getGroup()+"-" + label;
		    }
		    let suffix1=this.getProperty('sortSuffixUp',' _uparrow_').replace('_uparrow_','&uarr;');
		    
		    let suffix2=this.getProperty('sortSuffixDown',' _downarrow_').replace('_downarrow_','&darr;');
		    if(field.isFieldString()) {
			suffix1 = "A-Z";
			suffix2 = "Z-A";
		    }
		    if(sortAscending || field.isFieldString()) {
			enums.push([id+"_up",label + " " + suffix1]);
			enums.push([id+"_down",label + " " + suffix2]);
		    } else {
			enums.push([id+"_down",label + " " + suffix2]);
			enums.push([id+"_up",label + " " + suffix1]);
		    }
		});
		header2 += HU.span([ATTR_CLASS,filterClass],
				   this.makeFilterLabel("Order: ") + HU.select("",[ATTR_ID,this.getDomId("sortbyselect")],enums,this.getProperty("sortFields","")))+SPACE;
	    }

	    
	    this.uniqueFields =
		this.getFieldsByIds(null, this.getSelectUniqueFields());
	    if(this.uniqueFields && this.uniqueFields.length>0) {
		let enums =[];
		this.uniqueFields.forEach(field=>{
		    if(field.isFieldGeo()) return;
		    let id = field.getId();
		    let label = field.getLabel();
		    enums.push([id,label]);
		});
		header2 += HU.span([ATTR_CLASS,filterClass],
				   this.makeFilterLabel("Unique: ") +
				   HU.select("",['multiple',true,'size',Math.min(this.uniqueFields.length,4),ATTR_ID,this.getDomId("uniquefields")],
					     enums,null))+SPACE;
	    }


	    if(this.getProperty("showSortDirection")) {
		header2 +=HU.select("",[ATTR_ID,this.getDomId("sortdirection")],[["up", "Sort Up"],["down","Sort Down"]],
				    sortAscending?"up":"down") + SPACE;
	    }


	    if(this.sizeByFields.length>0) {
		let enums = [];
		this.sizeByFields.forEach(field=>{
		    enums.push([field.getId(),field.getLabel()]);
		});
		header2 += HU.span([ATTR_CLASS,filterClass],
				   this.makeFilterLabel("Size by: ") + HU.select("",[ATTR_ID,this.getDomId("sizebyselect")],enums,this.getProperty("sizeBy","")))+SPACE;
	    }


	    let  highlight = this.getFilterHighlight();
	    if(this.getShowFilterHighlight()) {
		let enums =[["filter","Filter"],["highlight","Highlight"]];
		let select =  HU.select("",["fieldId","_highlight", ID,this.getDomId(ID_FILTER_HIGHLIGHT)],enums,!highlight?"filter":"highlight") + SPACE2;
		if(hideFilterWidget) {
		    select = HU.div([ATTR_STYLE,HU.css("display","none")], select);
		}
		header2+=select;
	    }


	    let dataFilterIds = [];
	    this.getTheDataFilters().forEach(f=>{
		if(!f.label) return;
		let cbxid = this.getDomId("datafilterenabled_" + f.id);
		dataFilterIds.push(cbxid);
		header2 +=  HU.checkbox(cbxid,[ATTR_ID,cbxid],f.enabled,
//					this.makeFilterLabel(f.label +"&nbsp;&nbsp;"));
					f.label +"&nbsp;&nbsp;");
	    });

	    if(this.getProperty("filterDate")) { 
		let type = this.getProperty("filterDate");
		//get dates
		let enums = [];
		if(this.getProperty("filterDateIncludeAll")) {
		    enums.push(["all","All"]);
		}
		let selected = null;
		let seen  = {};
		let dates  = [];
		records.forEach(record=>dates.push(record.getDate()));
		dates.sort(function(a,b) {
		    return a.getTime()-b.getTime();
		});
		dates.forEach(dttm=>{
		    let value = null;
		    if(type == "year") {
			value = dttm.getFullYear();
		    } else if(type== "day") {
			value = Utils.formatDateMonthDayYear(dttm);
		    }
		    if(!seen[value]) {
			selected = String(dttm);
			enums.push([String(dttm), value]);
			seen[value] = true;
		    }
		});

		let label = type=="year"?"Year":type=="month"?"Month":type=="day"?"Day":type;
		let style="";
		if(!this.getProperty("filterDateShow",true))
		    style +="display:none;";
		let selectId = this.getFilterId(ID_FILTER_DATE);
		
		label =  this.makeFilterLabel("Select " + label+": ");
		let prefix="";
		prefix += HU.div([ATTR_ID,this.getDomId("filterDateStepBackward"),ATTR_STYLE,HU.css("display","inline-block"),TITLE,"Step Back"],
 				 HU.getIconImage("fa-step-backward",[ATTR_STYLE,HU.css("cursor","pointer")])) +SPACE1;
		prefix+=HU.div([ATTR_ID,this.getDomId("filterDatePlay"),ATTR_STYLE,HU.css("display","inline-block"),TITLE,"Play/Stop Animation"],
			       HU.getIconImage("fa-play",[ATTR_STYLE,HU.css("cursor","pointer")])) + SPACE1;
		prefix += HU.div([ATTR_ID,this.getDomId("filterDateStepForward"),ATTR_STYLE,HU.css("display","inline-block"),TITLE,"Step Forward"],
 				 HU.getIconImage("fa-step-forward",[ATTR_STYLE,HU.css("cursor","pointer")])) +SPACE1;

		let widget =  HU.span([ATTR_CLASS,filterClass,ATTR_STYLE,style],
				      prefix +
				      HU.select("",["fieldId","filterDate", ATTR_ID,selectId],enums,selected))+SPACE;
		if(hideFilterWidget) {
		    widget = HU.div([ATTR_STYLE,HU.css("display","none")], widget);
		}
		header2+=widget;

	    }
	    

            let filterBy = this.getProperty("filterFields","").split(",").map(tok=>{return tok.trim();}); 
	    let fieldMap = {};
	    //Have this here so it can be used in the menu change events later. May cause problems if more than  one
	    let displayType = "";
	    this.filters = [];
	    this.filterMap = {};
	    this.addFilters(this.filters);
            if(filterBy.length>0) {
		let group = null;
                for(let i=0;i<filterBy.length;i++) {
		    if(filterBy[i]=="") continue;
		    if(filterBy[i].startsWith("group:")) {
			group = filterBy[i].substring(6);
			if(group=="none") group = null;
			continue;
		    }
		    let filter = new RecordFilter(this, filterBy[i]);
		    filter.group = group;
		    this.filters.push(filter);
		    this.filterMap[filter.getId()] = filter;
		}
		let searchBar = "";
		let bottom = [""];
		group = null;
		groupHtml = null;
		this.filters.forEach(filter=>{
		    if(!filter.isEnabled()) return;
		    let widget = filter.getWidget(fieldMap, bottom,records, vertical);
		    if(!vertical)
			widget = HU.span([ATTR_CLASS,'display-filter-container display-filter-'+ filter.displayType,ID,this.domId("filtercontainer_" + filter.id)], widget);
		    if(filter.group!=null) {
			if(filter.group!=group && groupHtml!=null) {
			    searchBar+=HU.toggleBlock(group,groupHtml,false);
			    groupHtml = null;
			}
			group = filter.group;
			if(groupHtml==null) {
			    groupHtml= "";
			}
			groupHtml+=widget;
			return;
		    }
		    if(groupHtml!=null) {
			searchBar+=HU.toggleBlock(group,groupHtml,false);
			groupHtml=null;
		    }
		    searchBar +=widget;
		});
		if(groupHtml!=null) searchBar+=HU.toggleBlock(group,groupHtml,false);
		style = (hideFilterWidget?"display:none;":"") + this.getProperty("filterByStyle","");
		if(this.getProperty("showFilterTotal",false)) {
		    searchBar+= HU.span([ATTR_CLASS,"display-filter-label",ID,this.getDomId(ID_FILTER_COUNT)],"");
		}
		let filterBar = searchBar+bottom[0] + HU.div([ATTR_ID,this.domId(ID_TAGBAR)],"");
		header2+=HU.div([ATTR_CLASS,CLASS_HEADER_SPAN+" " +  filterClass,ATTR_STYLE,style,ID,this.getDomId(ID_FILTERBAR)],filterBar);
	    }



	    if(vertical) {
		header2 = HU.div([ATTR_CLASS,"display-header-vertical"],header2);
	    } else {
		let style = HU.css('line-height','0px');
		if(this.getHeaderCenter(true)) style +=HU.css('text-align','center');
		else style +=HU.css('text-align','left');		
		header2=HU.div([ATTR_STYLE,style],   header2);
	    }
	    header2 = HU.leftRightTable(header2,
					HU.div([ATTR_ID,this.getDomId(ID_HEADER2_SUFFIX)],''));
	    					
	    let headerSide = this.getDisplayHeaderSide();
	    if(headerSide == "left") 
		this.jq(ID_LEFT).html(header2);
	    else if(headerSide == "right") 
		this.jq(ID_RIGHT).html(header2);	    	    
	    else
		this.jq(ID_HEADER2).html(header2);

	    this.initHeader2();
	    this.jq("test").button().click(()=>{
		this.haveCalledUpdateUI = false;
		this.callUpdateUI();
	    });
	    this.createRequestProperties();
 	    let inputFunc = (input, input2, value) =>{
		let debug = false;
		if(this.ignoreFilterChange) return;
		if(input.attr('ignore')) return;
                let id = input.attr(ID);
		if(!id) {
		    console.log("No ID attribute for filter");
		    return;
		}
		if(debug)
		    console.log(this.type+" filter change");

		let changedFilter;
		let changedFilterId;
		this.filters.every(filter=>{
		    if(filter.widgetId == id) {
			changedFilter = filter;
			changedFilterId = filter.id;
			return false;
		    }
		    return true;
		});

		if(debug)
		    console.log("changed filter:" + changedFilter)
		let dependentFilters =[];
		if(changedFilter) {
		    this.filters.forEach(filter=>{
			if(filter.depends == changedFilter.id) {
			    dependentFilters.push(filter);
			    let widget = $("#" + filter.widgetId);
			    this.ignoreFilterChange = true; 
			    filter.lastValue = widget.val();
			    widget.val(FILTER_ALL);
			    this.ignoreFilterChange = false; 
			}
		    });
		}


		if(!input2) {
		    if(id.endsWith("_min")) {
			input2 = $("#" + id.replace(/_min$/,"_max"));
		    } else if(id.endsWith("_max")) {
			let tmp = input;
			input =$("#" + id.replace(/_max$/,"_min"));
			input2 = tmp;
		    }
		}
		if(input.attr("isCheckbox")) {
		    let on = input.attr("onValue")||true;
		    let off = input.attr("offValue")||false;
		    if (input.is(':checked')) {
			value = on;
			console.log(_this.type +" cbx is checked value:" + value +" on:" + on +" off:" + off);
		    } else {
			value=off;
			console.log(_this.type +" cbx is not checked value:" + value +" on:" + on +" off:" + off);
		    }
		}
		if(!value) {
		    value = input.val();
		} 
		if(value===null || value==="") {
		    value = input.attr("data-value")  || input.val();
		}
		
		if(value==null) {
		    if(debug)
			console.log("no value:" + value);
		    return;
		}
		if(!Array.isArray(value) && input.attr("isButton")) {
		    //			console.log(_this.type +" " +Array.isArray(value));
		    let tmp = [];
		    value.split(",").forEach(v=>{
			tmp.push(v.replace(/_comma_/g,","));
		    });
		    value = tmp;
		}

                let fieldId = input.attr("fieldId");
		_this.checkFilterField(input);
		_this.haveCalledUpdateUI = false;
		if(_this.settingFilterValue) {
		    return;
		}
		_this.settingFilterValue = true;
		this.filteredRecords = null;
		if(debug)
		    console.log("calling dataFilterChanged");
		_this.dataFilterChanged();


		let records =[];
		let predecessorChanged = false;
		dependentFilters.forEach(filter=>{
		    if(this.filteredRecords == null )
			this.filteredRecords =  this.filterRecords();
		    let widget = filter.getWidget({}, [],this.filteredRecords);
		    this.jq("filtercontainer_" + filter.id).html(widget);
		    if(filter.initWidget)
			filter.initWidget(inputFunc);
		    if(filter.widgetId) {
			let widget = $("#" + filter.widgetId);
			if(!widget.length) {
			    console.log("Could not find dependent widget:" + filter.id);
			    return;
			}
			if(filter.lastValue) {
			    if(widget[0].options) {
				let values= $.map(widget[0].options,(option)=>{return option.value});
				if(!values.includes(filter.lastValue)) filter.lastValue = FILTER_ALL;
			    }
			    widget.val(filter.lastValue);
			}
			widget.change(function() {
			    inputFunc($(this));
			});
		    }
		    return true;
		});


		let urlKey = fieldId+".fv";
		let urlValue = value;
		if(input2) {
		    if(id.endsWith('_min')) {
			urlKey+='min';
		    } else   if(id.endsWith('_max')) {
			urlKey+='max';
			urlValue = input2.val();
		    }
		}
		if(this.getIsMasterFilter()) {
		    //true=>don't add the display id prefix
		    this.addToDocumentUrl(urlKey,urlValue,true);
		} else {
		    this.addToDocumentUrl(urlKey,urlValue);
		}
		let args = {
		    id:id,
		    fieldId: fieldId,
		    value: value
		};
		if(input2) {
		    args.value2 = input2.val();
		}
		_this.propagateEvent(DisplayEvent.filterChanged, args);
		_this.settingFilterValue = false;
            };

	    dataFilterIds.forEach(id=>{
		$("#" + id).click(function(e){
		    inputFunc($(this));
		});
	    });

	    
	    this.filters.forEach(f=>{
		if(f.initWidget)
		    f.initWidget(inputFunc);
	    });


	    this.jq(ID_FILTERBAR).find(".display-filter-items").each(function(){
		let parent = $(this);
		$(this).find(".display-filter-item").click(function(event){
		    let isAll = $(this).hasClass("display-filter-item-all");
		    let selectClazz = "display-filter-item-selected"
		    let wasSelected = $(this).hasClass(selectClazz);
		    let fieldId = $(this).attr("fieldId");
		    let multiples = _this.getProperty(fieldId +".filterMultiple",false);
		    if(!event.metaKey || isAll || !multiples) {
			parent.find(".display-filter-item").removeClass(selectClazz);
		    } else {
			parent.find(".display-filter-item-all").removeClass(selectClazz);
		    }
		    if(wasSelected) {
		//		    if(wasSelected  && event.metaKey) {
			$(this).removeClass(selectClazz);
		    } else {
			$(this).addClass(selectClazz);
		    }
		    let values = [];
		    parent.find("." + selectClazz).each(function() {
			values.push($(this).attr("data-value").replace(/,/g,"_comma_"));
		    });
		    if(values.length==0) {
			parent.find(".display-filter-item-all").addClass(selectClazz);
			values.push(FILTER_ALL);
		    }
		    let value =  Utils.join(values,",");
		    parent.attr("data-value", value);
		    $("#"+parent.attr(ID) +"_label").html(values.includes(FILTER_ALL)?SPACE:value);
		    inputFunc(parent,null, values);
		});

	    });
	    this.jq(ID_FILTERBAR).find(".display-filter-input").keyup(function(e) {
		if($(this).attr("istext")) return;
		let keyCode = e.keyCode || e.which;
		if (keyCode == 13) {return;}
		HtmlUtils.hidePopupObject();

		let input = $(this);
		let val = $(this).val().trim();
		if(val=="") return;
                let fieldId = $(this).attr("fieldId");
		let field = fieldMap[fieldId].field;
		let values = fieldMap[fieldId].values;
		let items=[];
		let regexp=null;
		try {
		    val = val.replace(/\./g,"\\.");
		    regexp = new RegExp("(" + val+")",'i');
		} catch(ignore) {
		    //todo
		}
		for(let i=0;i<values.length;i++) {
		    let text= values[i].toString();
		    let match  = regexp?text.match(regexp):text.indexOf(val)>=0;
		    if(match) {
			items.push([match[1], values[i]]);
		    }
		    if(items.length>30) break;
		}
		if(items.length>0) {
		    let html = "";
		    let itemCnt = 0;
		    items.forEach(item=>{
			let match = item[0];
			item =  item[1];
//			if(item.length>50) return;
			let label = item.replace(regexp,"<span style='background:" + TEXT_HIGHLIGHT_COLOR +";'>" + match +"</span>");
			item = item.replace(/\'/g,"\'");
			html+=HU.div([TITLE,item,ATTR_CLASS,"ramadda-hoverable ramadda-clickable display-filter-popup-item","item",item],label)+"\n";
			itemCnt++;
		    });	
		    if(itemCnt>0) {
			let popup =HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
			popup.html(HU.div([ATTR_STYLE,HU.css("margin","5px"), ATTR_CLASS, "ramadda-popup-inner ramadda-snippet-popup"], html));
			popup.show();
			popup.position({
			    of: $(this),
			    my: "left top",
			    at: "left bottom",
			});
			$(".display-filter-popup-item").click(function(){
			    HtmlUtils.hidePopupObject();
			    input.val($(this).attr("item"));
			    inputFunc(input);
			});
		    }
		}

	    });



	    this.initializeRangeSlider(this.jq(ID_FILTERBAR).find(".display-filter-range"), inputFunc, this.getProperty("filterSliderImmediate"));

	    this.jq(ID_FILTER_HIGHLIGHT).change(function() {
		_this.setProperty("filterHighlight", $(this).val()=="highlight");
		_this.dfltFilterHighlight = null;
		_this.haveCalledUpdateUI = false;
		inputFunc($(this));
	    });


	    $("#" + this.getFilterId(ID_FILTER_DATE)).change(function() {
		inputFunc($(this));
	    });
	    this.jq("filterDatePlay").click(function() {
		_this.filterDatePlayingAnimation = !_this.filterDatePlayingAnimation;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		$(this).html(HU.getIconImage(icon,[ATTR_STYLE,HU.css("cursor","pointer")]));
		if(_this.filterDatePlayingAnimation) {
		    _this.stepFilterDateAnimation(inputFunc,1);
		}
	    });
	    this.jq("filterDateStepBackward").click(function() {
		_this.filterDatePlayingAnimation = false;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		_this.jq("filterDatePlay").html(HU.getIconImage(icon,[ATTR_STYLE,HU.css("cursor","pointer")]));
		_this.stepFilterDateAnimation(inputFunc,-1);
	    });
	    this.jq("filterDateStepForward").click(function() {
		_this.filterDatePlayingAnimation = false;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		_this.jq("filterDatePlay").html(HU.getIconImage(icon,[ATTR_STYLE,HU.css("cursor","pointer")]));
		_this.stepFilterDateAnimation(inputFunc,1);
	    });

            this.jq("displayfields").change(function(){
		let val = $(this).val();
		if(Array.isArray(val)) {
		    val = val.join(",");
		}
		_this.displayFieldsChanged(val);
		_this.propagateEvent(DisplayEvent.propertyChanged, {
		    property:'displayFields',
		    value: val
		});
	    });


	    selectFieldProps.forEach(prop=>{
                this.jq("fieldselect_" + prop).change(function(){
		    _this.fieldSelectedChanged(prop,$(this).val());
		});
	    });


            this.jq("colorbyselect").change(function(){
		_this.colorByFieldChanged($(this).val());
	    });
	    this.jq('uniquefields').change(()=>{
		this.callUpdateUI();
	    });

            this.jq("sortbyselect").change(function(){
		let val = $(this).val();
		if(val.endsWith("_up")) {
		    _this.setProperty("sortAscending",true);
		    val = val.replace(/_up$/,"");
		} else {
		    val = val.replace(/_down$/,"");
		    _this.setProperty("sortAscending",false);
		}
		_this.sortByFieldChanged(val);
	    });
	    this.jq("sortdirection").change(function(){
		let val = $(this).val();
		_this.setProperty("sortAscending",val=="up");
		_this.forceUpdateUI();
	    });
            this.jq("sizebyselect").change(function(){
		_this.sizeByFieldChanged($(this).val());
	    });

            this.jq(ID_FILTERBAR).find("input").keyup(function(e){
		let keyCode = e.keyCode || e.which;
		if (keyCode == 13) {
		    inputFunc($(this));
		}
	    });
	    this.jq(ID_FILTERBAR).find("input:radio,select").change(function() {
		inputFunc($(this));
	    });
	    this.jq(ID_FILTERBAR).find("input:checkbox").change(function() {
		inputFunc($(this));
	    });
	    

	    let dates = [];
	    if(debug) console.log("checkSearchBar-getting filtered data");
	    let filteredRecords  = this.filterData();
	    if(debug) console.log("checkSearchBar-done getting filtered data");
	    if(filteredRecords) {
		this.initializeAnimation(filteredRecords);
	    }
	    if(debug) console.log("checkSearchBar-done");
        },
	initializeAnimation:function(filteredRecords) {
	    let debug = false;
	    if(!filteredRecords) filteredRecords = this.getRecords();
	    let dateInfo = this.getDateInfo(filteredRecords);
	    if(debug) console.log("initializeAnimation-1");
	    if (dateInfo.dateMax) {
		if(debug) console.log("initializeAnimationr-getAnimation");
		let animation = this.getAnimation();
		if(animation.getEnabled()) {
		    if(debug) console.log("initializeAnimation-calling animation.init");
		    //		    console.log("dateMin:" + dateMin.toUTCString());
		    animation.init(dateInfo.dateMin, dateInfo.dateMax,filteredRecords);
		    if(debug) console.log("initializeAnimation-done calling animation.init");
		    if(!this.minDateObj) {
			if(debug) console.log("initializeAnimation-calling setDateRange");
			if(this.getProperty("animationFilter", true)) {
			    this.setDateRange(animation.begin, animation.end);
			}
			if(debug) console.log("initializeAnimation-done calling setDateRange");
		    }
		}
	    }
	},


	getDateInfo:function(records) {
	    let dateMin = null;
	    let dateMax = null;
	    let dates =[];
	    records.every(record=>{
		if (dateMin == null) {
		    dateMin = record.getDate();
		    dateMax = record.getDate();
		} else {
		    let date = record.getDate();
		    if (date) {
			dates.push(date);
			if (date.getTime() < dateMin.getTime())
			    dateMin = date;
			if (date.getTime() > dateMax.getTime())
			    dateMax = date;
		    }
		}
		return true;
	    });
	    return { dateMin:dateMin, dateMax:dateMax, dates:dates};
	},
	    
	getHighlightColor: function() {
	    return this.getProperty("highlightColor", HIGHLIGHT_COLOR);
	},
	checkFilterField: function(f) {
	    let min = f.attr("data-min");
	    let max = f.attr("data-max");
	    let value = f.val();
	    if(Utils.isDefined(min)) {
		if(value != min) {
		    f.css("background",TEXT_HIGHLIGHT_COLOR);
		} else {
		    f.css("background","white");
		}
	    } else if(Utils.isDefined(max)) {
		if(value != max) {
		    f.css("background",TEXT_HIGHLIGHT_COLOR);
		} else {
		    f.css("background","white");
		}
	    }

	},
	fieldSelectedChanged: function(prop,val) {
	    this.setProperty(prop,val);
	    this.haveCalledUpdateUI = false;
	    this.callUpdateUI();
	},
	colorByFieldChanged:function(field) {
	    this.setProperty("colorBy", field);
	    this.callUpdateUI();
	},
	sortByFieldChanged:function(field) {
	    this.setProperty("sortFields", field);
	    this.callUpdateUI();
	},
	sizeByFieldChanged:function(field) {
	},
	someFieldChanged:function(type,field) {
	},	
	macroChanged: function() {
	    this.pageSkip = 0;
	},
	rowStartIndex:0,
	dataFilterChanged: function(args) {
	    this.rowStartIndex=0;
	    args = args||{};
	    args.dataFilterChanged = true;
	    this.callUpdateUI(args);
	},
	addFieldClickHandler: function(jq, records, addHighlight) {
	    let _this = this;
	    if(records) {
		if(!jq) jq = this.jq(ID_DISPLAY_CONTENTS);
		let map = this.makeIdToRecords(records);
		let func = function() {
		    if(addHighlight) {
			$(this).parent().find(".display-row-highlight").removeClass("display-row-highlight");
			$(this).addClass("display-row-highlight");
		    }
		    let record = records[$(this).attr(RECORD_INDEX)];
		    if(!record) record = map[$(this).attr(RECORD_ID)];
		    if(record)
			_this.propagateEventRecordSelection({record:record});
		};
		let children = jq.find("[" +RECORD_INDEX+"]");
		if(!children.length) children = jq.find("[" +RECORD_ID+"]");
		if(!children.length) children = jq;
		children.click(func);
	    }

	    if(this.getProperty("propagateValueClick",true)) {
		let _this = this;
		if(!jq) jq = this.jq(ID_DISPLAY_CONTENTS);
		jq.find("[field-id]").click(function() {
		    let fieldId = $(this).attr('field-id');
		    let args = {
			id:fieldId,
			fieldId: fieldId,
			value: $(this).attr("field-value")
		    };
		    _this.propagateEvent(DisplayEvent.filterChanged, args);
		});
	    }

	},
	makeIdToRecords: function(records) {
	    let idToRecord = {};
	    records.forEach(r=>idToRecord[r.getId()] = r);	    
	    return idToRecord;
	},
	makeTooltipClick: function(selector, records) {
	    let tooltipClick = this.getProperty("tooltipClick");
	    if(!tooltipClick) return;
	    selector.css("cursor","pointer");
	    let idToRecord = this.makeIdToRecords(records);
	    let _this = this;
	    selector.click(function() {
		let record = idToRecord[$(this).attr(RECORD_ID)];
		if(!record) return;
		if(_this.tooltipDialog) {
		    _this.tooltipDialog.remove();
		    _this.tooltipDialog = null;
		} 
		let tt =  _this.getRecordHtml(record,null,tooltipClick);
		tt = HU.div([ATTR_STYLE,HU.css("width","600px")], tt);
		_this.tooltipDialog =  HU.makeDialog({content:tt,anchor:$(this),
						      draggable:true,header:true});
		if(_this.getProperty("dialogListener"))
		    _this.getProperty("dialogListener")(this, _this.tooltipDialog);
		_this.initTemplatePopup(_this.tooltipDialog);
	    });
	},

	initTemplatePopup: function(dialog) {
	    let _this = this;
	    dialog.find(".display-search-tag").click(function() {
		let type = $(this).attr("metadata-type");
		if(type==null) return;
		let filter = _this.filterMap[type];
		if(filter==null) return;
		let value = $(this).attr("metadata-value");
		filter.toggleTag(value,true,null, true);
	    });

	},

	//Make sure to set the title attribute on the elements
	makeTooltips: function(selector, records, callback, tooltipArg,propagateHighlight) {		
	    let tooltipClick = this.getProperty("tooltipClick");
	    if(tooltipClick) {
		this.makeTooltipClick(selector,records);
	    }
	    if(!Utils.isDefined(propagateHighlight) || propagateHighlight==null)
		propagateHighlight = this.shareEvent(DisplayEvent.recordHighlight, this.getProperty("propagateEventRecordHighlight",false));
	    if(!this.getProperty("showTooltips",true)) {
		return;
	    }
	    let tooltip = tooltipArg ?? this.getTooltip();
	    if(tooltip==null || tooltip=='none') {
		return;
	    }
	    let _this = this;
	    let idToRecord = this.makeIdToRecords(records);
	    let tooltipFunc = {
		content: function() {
		    let record = idToRecord[$(this).attr(RECORD_ID)];
		    if(!record)  record = records[parseFloat($(this).attr(RECORD_INDEX))];
		    if(!record) return null;
		    let propagateOk = true;
		    if(callback && callback(true, record) === false) {
			propagateOk = false;
		    }
		    if(propagateOk && propagateHighlight) {
			_this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, _this, {highlight:true,record: record});
		    }
		    if(tooltip=="" || tooltip=="none") return null;
		    let style = _this.getProperty("tooltipStyle","font-size:10pt;");
		    let tt =  _this.getRecordHtml(record,null,tooltip);
		    if(style) tt=HU.div([ATTR_STYLE,style],tt);
		    return tt;
		},
		close: function(event,ui) {
		    let record = idToRecord[$(this).attr(RECORD_ID)];
		    if(!record)
			record = records[parseFloat($(this).attr(RECORD_INDEX))];
		    let propagateOk = true;
		    if(callback && callback(false, record) === false) {
			propagateOk = false;
		    }
		    if(propagateOk && propagateHighlight)
			_this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, _this, {highlight:false,record: record});
		},
		position: {
		    my: _this.getTooltipPositionMy("left top"),
		    at: _this.getTooltipPositionAt("left bottom+2"),
		    collision: _this.getTooltipCollision("flip")
		},
		classes: {
		    "ui-tooltip": _this.getProperty("tooltipClass", "ramadda-shadow-box  display-tooltip " + 'display-' + this.getType() +'-tooltip')
		}
	    };
	    if(this.getTooltipImmediate()) {
		$.extend(tooltipFunc,{show: false, hide:false});
	    } else {
		$.extend(tooltipFunc,{
		    show: {
			delay: parseFloat(_this.getTooltipDelay()),
			effect:this.getTooltipEffect(),
			duration: parseFloat(_this.getTooltipDuration()),
		    }});
	    }
	    if(selector.length>500) {
		//A hack to fix really slow tooltip calls when there are lots of elements
		selector.mouseenter(function() {
		    let tooltip = $(this).tooltip(tooltipFunc);
		    tooltip.tooltip('open');
		});
		selector.mouseleave(function() {
		    let tooltip = $(this).tooltip({});
		    tooltip.tooltip('close');
		});
	    } else {
		selector.tooltip(tooltipFunc);
	    }
	},
	makeRecordSelect: function(selector,idToRecords, callback) {
	    let _this = this;
	    selector.click(function(event){
		let record = idToRecords[$(this).attr(RECORD_ID)];
		if(!record) return;
		if(callback) callback(record);
		_this.propagateEventRecordSelection({select:true,record: record});
	    });
	},
	makePopups: function(selector, records, callback, popupTemplate) {
	    if(!popupTemplate)
		popupTemplate = this.getProperty("popupTemplate");
	    if(!popupTemplate) return;
	    let _this = this;
	    selector.click(function(event){
		let record = records[parseFloat($(this).attr(RECORD_INDEX))];
		if(!record) return;
		if(callback) callback(record);
		_this.propagateEventRecordSelection({select:true,record: record});
		_this.showRecordPopup($(this),record, callback,popupTemplate);
	    });
	},
	showRecordPopup: function(element, record, popupTemplate) {
	    if(!record) return;
	    if(!popupTemplate)
		popupTemplate = this.getProperty("popupTemplate");
	    if(!popupTemplate) return;
	    let _this = this;
	    HtmlUtils.hidePopupObject();
	    let html =  _this.getRecordHtml(record,null,popupTemplate);
	    html = HU.div([ATTR_CLASS, "display-popup " + _this.getProperty("popupClass",""),ATTR_STYLE, _this.getProperty("popupStyle","")],html);
	    let popup = HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
	    popup.html(html);
	    popup.show();
	    popup.position({
		of: element,
		my: _this.getProperty("popupPositionMy", "left top"),
		at: _this.getProperty("popupPositionAt", "left bottom+2"),
		collision: _this.getProperty("popupCollision", "none none")
	    });
	},
	animationStart: function(animation) {
	},
	animationApply: function(animation, skipUpdateUI) {
	    if(this.getProperty("animationFilter", true))
		this.setDateRange(animation.begin, animation.end);
	    if(!skipUpdateUI) {
		this.haveCalledUpdateUI = false;
		this.dataFilterChanged({source:"animation"});
	    }
	    this.propagateEvent(DisplayEvent.propertyChanged, {
		property: "dateRange",
		minDate: animation.begin,
		maxDate: animation.end
	    });
	},
        makeDialog: function(text) {
            let html = "";
	    if(!text) {
		let tabTitles = [];
		let tabContents = [];
		this.getDialogContents(tabTitles, tabContents);
		tabTitles.push("Edit");
		tabContents.push(this.makeToolbar({
                    addLabel: true
		}));
		let tabLinks = "<ul>";
		let tabs = "";
		for (let i = 0; i < tabTitles.length; i++) {
                    let id = this.getDomId("tabs") + i;
                    tabLinks += HU.tag("li", [], HU.tag("a", ["href", "#" + id],
							tabTitles[i]));
                    tabLinks += "\n";
                    let contents = HU.div([ATTR_CLASS, "display-dialog-tab"], tabContents[i]);
                    tabs += HU.div([ATTR_ID, id], contents);
                    tabs += "\n";
		}
		tabLinks += "</ul>\n";
		text =  HU.div([ATTR_ID, this.getDomId(ID_DIALOG_TABS)], tabLinks + tabs);
	    }
	    return text;
        },
        initDialog: function() {
            let _this = this;
            let updateFunc = function(e) {
                if (e && e.which != 13 && e.which!=0) {
                    return;
                }
		let changed = false;
		["column","row","width","height"].forEach(f=>{
                    if(_this[f] != _this.jq(f).val() && (_this[f] || _this.jq(f).val().trim()!="")) {
			changed = true;
			_this[f] = _this.jq(f).val();
		    }});
		

                if(changed) {
		    _this.getLayoutManager().doLayout();
		}
            };
	    ["column","row","width","height"].forEach(f=>{
		this.jq(f).blur(updateFunc);
		this.jq(f).keypress(updateFunc);
	    });

            this.jq("showtitle").change(function() {
                _this.setShowTitle(_this.jq("showtitle").is(':checked'));
            });
            this.jq("showdetails").change(function() {
                _this.setShowDetails(_this.jq("showdetails").is(':checked'));
            });
            this.jq(ID_DIALOG_TABS).tabs();

        },
        showDialog: function(text, from, initDialog, title) {
	    if(this.dialog) this.dialog.remove();
	    if(!this.dialogElement) {
//		$(document.body).append(HU.div([ATTR_CLASS, "display-dialog",ID,this.getDomId(ID_DIALOG)]));
//		this.dialogElement = this.jq(ID_DIALOG);
	    }
	    let html = this.makeDialog(text);
	    if(this.getProperty('dialogHook')) {
		html =this.getProperty('dialogHook')('contents',html);
	    }

	    let at = 'left bottom';
	    if(!from && this.jq(ID_MENU_BUTTON).length) {
		from=this.jq(ID_MENU_BUTTON);
	    }
	    if(!from) {
		from=this.jq(ID_DISPLAY_CONTENTS);
		at = 'left top';
	    }

	    this.dialog = HU.makeDialog({content:html,title:title||this.getTitle(),anchor:from,at:at,draggable:true,header:true});
	    if(initDialog) initDialog();
            else this.initDialog();
	    if(this.getProperty('dialogHook')) {
		this.getProperty('dialogHook')('init',this.dialog);
	    }
	    return this.dialog;
        },
        copyDisplay: function() {
            let newOne = {};
            $.extend(true, newOne, this);
            newOne.setId(newOne.getId() + this.getUniqueId("display"));
            addRamaddaDisplay(newOne);
            this.getDisplayManager().addDisplay(newOne);
        },
        removeDisplay: function() {
            this.getDisplayManager().removeDisplay(this);
	    if(this.dialogElement)  this.dialogElement.remove();
        },
        doingQuickEntrySearch: false,
        doQuickEntrySearch: function(request, callback) {
            if (this.doingQuickEntrySearch) return;
            let text = request.term;
            if (text == null || text.length <= 1) return;
            this.doingQuickEntrySearch = true;
            let searchSettings = new EntrySearchSettings({
                name: text,
                max: 10,
            });
            if (this.searchSettings) {
                searchSettings.clearAndAddType(this.searchSettings.entryType);
            }
	    let _this = this;
            let jsonUrl = this.getRamadda().getSearchUrl(searchSettings, OUTPUT_JSON);
            let handler = {
                entryListChanged: function(entryList) {
                    _this.doneQuickEntrySearch(entryList, callback);
                }
            };
            let entryList = new EntryList(this.getRamadda(), jsonUrl, handler, true);
        },
        doneQuickEntrySearch: function(entryList, callback) {
            let names = [];
            let entries = entryList.getEntries();
            for (let i = 0; i < entries.length; i++) {
                names.push(entries[i].getName());
            }
            callback(names);
            this.doingQuickEntrySearch = false;

        },
        handleWarning: function(message) {
	    if(!window.location.hash  || window.location.hash!="#fortest") {
		console.warn(message);
	    }
	},
        handleLog: function(message) {
	    if(!window.location.hash  || window.location.hash!="#fortest") {
		this.logMsg(message);
	    }
	},
        handleError: function(message, exc) {
	    this.setErrorMessage(message);
            console.error(this.type +" " + message);
	    if(exc && exc.stack) {
		let err = "";
		let limit=15;
		exc.stack.split("\n").every(line=>{
		    if(limit--<0) {
			err+="...\n";
			return false;
		    }
		    err+=line+"\n";
		    return true;
		});
		console.error(err);
	    }
        },
	setErrorMessage: function(msg) {
            this.setContents(this.getMessage(msg));
	},
	clearProgress: function() {
	    this.jq(ID_DISPLAY_PROGRESS).html("");
	},
	startProgress: function() {
	    if(this.jq(ID_DISPLAY_PROGRESS).length>0) 
		this.jq(ID_DISPLAY_PROGRESS).html(HU.image(icon_progress));
	    else {
		if(this.useDisplayMessage()) {
                    this.setDisplayMessage(this.getLoadingMessage());
		} else {
		    this.setContents(this.getLoadingMessage());
		}
	    }
	},
	handleNoData: function(pointData,reload) {
	    this.dataLoadFailed  =true;
	    let debug = displayDebug.handleNoData;
	    this.jq(ID_PAGE_COUNT).html("");
            if (!reload) {
		if(debug) console.log("\tno reload");
                this.addData(pointData);
                this.checkSearchBar();
            } else {
		if(!this.dataCollection)
		    this.dataCollection = new DataCollection();
		this.dataCollection.setData(pointData);
	    }
	    let message = this.getNoDataMessage();
	    this.setNoDataMessage(message);
	},
	setNoDataMessage:function(message) {
	    if(Utils.stringDefined(message)) {
		this.setContents(this.getMessage(this.getNoDataMessage()));
	    } else {
		this.setContents('');
	    }
	},
        pointDataLoadFailed: function(data) {
	    this.dataLoadFailed  =true;
	    this.clearProgress();
            this.inError = true;
            errorMessage = this.getProperty("errorMessage", null);
            if (errorMessage != null) {
                this.setContents(errorMessage);
                return;
            }
            let msg = "";
	    if(data && data.error) {
		msg = data.error;
		msg  = String(msg).replace(/</g,"&lt;").replace(/>/g,"&gt;");
	    } else   if (data && data.errorcode && data.errorcode == "warning") {
                msg = data.error;
		msg  = String(msg).replace(/</g,"&lt;").replace(/>/g,"&gt;");
            } else {
                msg = HU.b("An error has occurred:");
		msg+=' '+this.getLogLabel()+'<br>';
                if (!data) data = this.getNoDataMessage();
                let error = data.error ? data.error : data;
                error = error.replace(/<[^>]*>/g, "");
                let tmp = "";
                let lines = error.split("\n");
                let seen = {};
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    if (line == "") continue;
                    if (seen[line]) continue;
                    seen[line] = true;
                    tmp += line + "\n";
                }
		tmp = tmp.replace('Error:java.lang.RuntimeException:','');
		tmp = tmp.replace(/\\n/g,'<br>');
                error = tmp;
                error = HU.tag("pre", [ATTR_STYLE, HU.css("white-space","nowrap","max-height","300px","overflow-y","auto","max-width","600px","overflow-x","auto")], error);
                msg += error;
            }
	    
	    msg = msg.replace(/\n/g,"<br>");
	    this.setErrorMessage(msg);
        },
        //callback from the pointData.loadData call
        clearCache: function() {},
	handleEventDataSelection: function(source, args) {
	    if(this.getAcceptEventDataSelection()) {
		this.pointDataLoaded(args.data,"",true);
	    }
	},
	getRequirement:function() {
	    return null;
	},
	updatePaginateLabel:function(skip, count,max) {
	    let paginate = this.getFilterPaginate();
	    let label = count;
	    if(skip!=null && skip>0)
		label = String(skip+1)+"-"+(count+skip);
	    else if(count<max)
		label = "1" +"-"+count;
	    label = this.getProperty("pageRequestLabel","Showing: ${count}").replace("${count}",label);
	    this.jq(ID_PAGE_LABEL).html(label);
	    let gotAll=false;
	    if(paginate) {
	    } else {
	    }
	    let buttons = "";
	    if(skip!=null && skip>0) {
		buttons+= HU.getIconImage("fa-step-backward",[ATTR_ID,this.getDomId(ID_PAGE_PREV),ATTR_CLASS,"display-page-button",TITLE,"View previous"])
	    }  else if(!gotAll) {
		buttons+= HU.getIconImage("fa-step-backward",[ATTR_CLASS,"display-page-button fa-disabled"])
	    }
	    if(count<max) {
		buttons+= HU.getIconImage("fa-step-forward",[ATTR_ID,this.getDomId(ID_PAGE_NEXT),ATTR_CLASS,"display-page-button",TITLE,"View next"])
	    }  else if(!gotAll) {
		buttons+= HU.getIconImage("fa-step-forward",[ATTR_CLASS,"display-page-button fa-disabled"])
	    }
	    this.jq(ID_PAGE_BUTTONS).html(buttons);
	    let _this = this;
	    this.jq(ID_PAGE_NEXT).click(()=>{
		if(!this.pageSkip)
		    this.pageSkip=0;
		if(paginate) {
		    this.pageSkip+= +this.getPageCount();
		    _this.haveCalledUpdateUI = false;
		    _this.dataFilterChanged();
		    _this.updatePaginateLabel(this.pageSkip, count,max);			
		} else {
		    this.pageSkip+=max;
		    this.reloadData();
		}
	    });
	    this.jq(ID_PAGE_PREV).click(()=>{
		if(!this.pageSkip)
		    this.pageSkip=0;
		if(paginate) {
		    this.pageSkip-= +this.getPageCount();
		    if(this.pageSkip<0) this.pageSkip=0;
		    _this.haveCalledUpdateUI = false;
		    _this.updatePaginateLabel(this.pageSkip, count,max);			
		    _this.dataFilterChanged();
		} else {
		    this.pageSkip-=max;
		    if(this.pageSkip<0) this.pageSkip=0;
		    this.reloadData();
		}
	    });		
	},

        addData: async function(pointData,skipUpdateUI) {
            let records = pointData.getRecords();
            if (records && records.length > 0) {
                this.hasElevation = records[0].hasElevation();
            } else {
                this.hasElevation = false;
            }
	    this.originalPointData=pointData;
	    if(!this.getApplyConvertAfter()) {
		pointData = this.convertPointData(pointData);
	    }
            this.dataCollection.addData(pointData);
	    try {
		if(!skipUpdateUI)
		    this.updateUI();
	    } catch(err) {}
            let entry = pointData.entry;
            if (entry == null && pointData.entryId) {
                await this.getRamadda().getEntry(pointData.entryId, e => {
                    entry = e
                });
            }
            if (entry) {
                pointData.entry = entry;
                this.addEntry(entry);
            }
        },

	convertPointData: function(pointData) {
	    let originalPointData = pointData;
	    let segments = this.getSegments();
	    if(segments) {
                let dataList = pointData.getRecords();
		let newData  =[];
		let header = [];
		newData.push(header);
		let rowIdx = 0; 
		//timeSegments="Obama;2008-02-01;2016-01-31,Trump;2016-02-01;2020-01-31"
		segments.forEach((segment,segmentIdx)=>{
		    let name = segment.name;
		    header.push(name);
		    let start = segment.start;
		    let end = segment.end;
		    let cnt = 1;
	    	    for (; rowIdx <dataList.length; rowIdx++) {
			let record = dataList[rowIdx];
			if(record.getTime()<start.getTime()) {
			    continue;
			}
			if(record.getTime()>end.getTime()) {
			    break;
			}
			let value = record.getValue(1);
			let row=null;
			if(cnt>=newData.length) {
			    row = [];
			    for(let sidx=0;sidx<segments.length;sidx++) row.push(NaN);
			    newData.push(row);
			} else {
			    row = newData[cnt];
			}
			row[segmentIdx] = value;
			cnt++;
		    }
		});
		pointData = convertToPointData(newData);
		pointData.entryId = originalPointData.entryId;
	    }

	    try {
		pointData = new CsvUtil().process(this, pointData, this.getProperty("convertData"));
	    } catch(exc) {
		this.handleError("Error:" + exc, exc);
		return null;
	    }
	    return pointData;
	},

        pointDataLoaded: function(pointData, url, reload) {
//	    this.logMsg("pointDataLoaded: "+ url);
	    if(!this.cacheUrl && pointData.cacheUrl) {
		this.cacheUrl = pointData.cacheUrl;
	    }


	    this.dataLoadFailed  =false;
	    let debug = displayDebug.pointDataLoaded;
	    this.clearProgress();
            this.inError = false;
            this.clearCache();
	    if(debug)
		this.logMsg("pointDataLoad:" + this.getId() + " " + this.type +" #records:" + pointData.getRecords().length);
	    if(debug)
		console.log("\tclearing last selected fields");
	    let records = pointData.getRecords();
	    this.lastSelectedFields = null;
            if (!reload) {
		if(debug) console.log("\tcalling addData");
                this.addData(pointData,true);
		//		if(debug) console.log("\tcalling checkSearchBar");
                this.checkSearchBar();
		//		if(debug) console.log("\done calling checkSearchBar");
            } else {
		pointData = this.convertPointData(pointData);
		if(!this.dataCollection)
		    this.dataCollection = new DataCollection();
		if(debug) console.log("\tcalling setData");
		this.dataCollection.setData(pointData);
	    }
	    let paginate = this.getFilterPaginate();
	    if(this.getProperty("pageRequest") || paginate) {
		if(debug) console.log("\tupdating pageRequest");
		let count = pointData.getRecords().length;
		let skip = null;
		let skipToks = url?url.match(/skip=([0-9]+)/):null;
		if(skipToks) skip = +skipToks[1];
		let max = +this.getProperty("max",5000);
		//		console.log("max:" +max +" count:" + count +" skip:" + skip);
		let label = count;
		if(skip!=null && skip>0)
		    label = String(skip+1)+"-"+(count+skip);
		else if(count==max)
		    label = "1" +"-"+count;
		let pageInfo = this.getProperty("pageRequestLabel","Showing: ${count}").replace("${count}",label) +" ";
		let gotAll = !skip &&  count<max;

		if(skip!=null && skip>0) {
		    pageInfo+= HU.getIconImage("fa-step-backward",[ATTR_ID,this.getDomId(ID_PAGE_PREV),ATTR_CLASS,"display-page-button",TITLE,"View previous"])
		}  else if(!gotAll) {
		    pageInfo+= HU.getIconImage("fa-step-backward",[ATTR_CLASS,"display-page-button fa-disabled"])
		}
		if(count==max) {
		    pageInfo+= HU.getIconImage("fa-step-forward",[ATTR_ID,this.getDomId(ID_PAGE_NEXT),ATTR_CLASS,"display-page-button",TITLE,"View next"])
		}  else if(!gotAll) {
		    pageInfo+= HU.getIconImage("fa-step-forward",[ATTR_CLASS,"display-page-button fa-disabled"])
		}
		this.jq(ID_PAGE_COUNT).html(pageInfo+"&nbsp;&nbsp;");
		this.jq(ID_PAGE_NEXT).click(()=>{
		    if(!this.pageSkip)
			this.pageSkip=0;
		    this.pageSkip+=max;
		    this.reloadData();
		});
		this.jq(ID_PAGE_PREV).click(()=>{
		    if(!this.pageSkip)
			this.pageSkip=0;
		    this.pageSkip-=max;
		    if(this.pageSkip<0) this.pageSkip=0;
		    this.reloadData();
		});		
	    }

            if (url != null) {
                this.jsonUrl = url;
            } else {
                this.jsonUrl = null;
            }
            if (!this.getDisplayReady()) {
		if(debug)console.log("pointDataLoaded: display not ready");
                return;
            }

	    
	    if(!this.getDateProps().dateFormat) {
                pointData.getRecordFields().forEach(f=>{
		    if(f.isFieldDate() && f.getId() == "year") {
			this.setProperty("dateFormat","yyyy");
		    }
		});
	    }
	    
	    this.haveCalledUpdateUI = false;
	    if(debug) console.log("\tcalling updateUI");
	    if(reload && this.getAnimation().getEnabled()) {
		this.initializeAnimation();
	    }

	    try {
		let requirement = this.getRequirement();
		if(requirement) {
//		    console.log("waiting on:" + requirement);
		    HU.waitForIt(requirement,()=>{
			this.updateUI({reload:reload});
		    });
		} else {
		    this.updateUI({reload:reload});
		}
	    } catch(err) {
		this.handleError("Error creating display:<br>" + err,err);
		return;
	    }
	    if (!reload || this.getPropagateDataReload()) {
                this.lastPointData = pointData;
		if(debug) console.log("\tcalling propagateEvent");		
                this.propagateEvent(DisplayEvent.pointDataLoaded, pointData);
            }
        },
        getHasDate: function(records) {
            let lastDate = null;
            this.hasDate = false;
            for (j = 0; j < records.length; j++) {
                let record = records[j];
                let date = record.getDate();
                if (date == null) {
                    continue;
                }
                if (lastDate != null && lastDate.getTime() != date.getTime()) {
                    this.hasDate = true;
                    break
                }
                lastDate = date;
            }
            return this.hasDate;
        },
        dateInRange: function(date, idx, debug) {
	    if(debug) {
		this.logMsg("dateInRange: date:" + date +" minDate:" + this.minDateObj +" maxDate:" + this.maxDateObj);
	    }

//	    if(this.minDateObj)console.log("index:" +this.minDateObj.index +" " +this.maxDateObj.index)
	    if(this.minDateObj &&this.minDateObj.isIndex) {
		if(debug)
		    console.dir('min',this.minDateObj.index,idx);
		if(idx<this.minDateObj.index) return false;
	    }
	    if(this.maxDateObj &&this.maxDateObj.isIndex) {
		if(debug)
		    console.dir('max',this.maxDateObj.index,idx);
		if(idx>this.maxDateObj.index) return false;
		return true;
	    }	    

            if (date != null) {
		if(this.dateRangeDoDay && this.minDateObj) {
		    if(date.getUTCFullYear()!=this.minDateObj.getUTCFullYear() ||
		       date.getUTCMonth()!=this.minDateObj.getUTCMonth() ||
 		       date.getUTCDate()!=this.minDateObj.getUTCDate())  {
			return false;
		    }
		    
		} else {
                    if (this.minDateObj != null && date.getTime() < this.minDateObj.getTime()) {
			if(debug) {
			    console.log("minDate: " + date +"   " + this.minDateObj);
			}
			return false;
                    }
                    if (this.maxDateObj != null && date.getTime() > this.maxDateObj.getTime()) {
			if(debug) {
			    let diff = (this.maxDateObj.getTime()-date.getTime())/1000;
			}
			return false;
		    }
                }
		
//		let str =  date.toUTCString() +" " +(date.getTime() < this.startDateObject.getTime());
		if (this.startDateObject != null && date.getTime() < this.startDateObject.getTime()) {
		    if(debug) {
//			console.log("    startDate:\n\t" + date.getTime() +"\n\t" + this.startDateObject.getTime());
		    }
//		    console.log("skip " + str);
                    return false;
                }
//		console.log("no skip " + str +" " + date);
                if (this.endDateObject != null && date.getTime() > this.endDateObject.getTime()) {
		    if(debug) {
			console.log("    endDate:\n\t" + date.getTime() +"\n\t" + this.endDateObject.getTime());
		    }
                    return false;
                }
            }
	    if(debug) console.log('ok');
            return true;
        },
        getPointData: function() {
	    if(this.pointData) return this.pointData;
            if (this.dataCollection.getList().length == 0) return null;
            return this.dataCollection.getList()[0];
        },
	getRecords: function() {
            let pointData = this.getData();
            if (pointData == null) return null;
            return  pointData.getRecords();
        },
        //get an array of arrays of data 
        getDataValues: function(obj) {
            if (obj.tuple) return obj.tuple;
            else if (obj.getData) return obj.getData();
            return obj;
        },
	indexToRecord: {},
	recordToIndex: {},
	findMatchingDates: function(date, records, within) {
	    if(!Utils.isDefined(within)) within=0;
	    let good = [];
	    let millis = date.getTime();
	    records.forEach(r=>{
		let rd = r.getDate();
		if(!rd) return;
		let diff = Math.abs(rd.getTime()-millis);
		if(diff<=within) {
		    good.push(r);
		}
	    });
	    return good;
	},
	findMatchingIndex: function(record) {
	    let fail = {index:-1,record:null};
	    if(!record) return fail;
	    let recordSelectField=this.getRecordSelectField();
	    if(recordSelectField) {
		let f = this.getFieldById(null, recordSelectField);
		if(!f)    return fail;
		let v = f.getValue(record);
		if(!Utils.isDefined(v)) return fail;
		if(!this.filteredRecords) return fail;
		for(let i=0;i<this.filteredRecords.length;i++) {
		    if(v == f.getValue(this.filteredRecords[i])) {
			return {index:i,record:this.filteredRecords[i]};
		    }
		}
		return fail;

	    }
	    let index = this.recordToIndex[record.getId()];
	    if(Utils.isDefined(index)) {
		return {index:index, record:this.indexToRecord[index]}
	    }
	    if(!record.hasDate()) return -1;
	    return this.findClosestDate(record.getDate());
	},
	findClosestDate:function(date) {
	    let records =this.filteredRecords;
	    if(!records) {
		records = [];
		for(i in this.indexToRecord) {
		    records.push(this.indexToRecord[i]);
		}
	    }
	    let closest;
	    let min  =0;
	    records.forEach((r,idx)=>{
		if(!r.hasDate()) {
		    return -1;
		}
		let diff = Math.abs(date.getTime()-r.getDate().getTime());
		if(!closest) {
		    min = diff;
		    closest = r;
		} else {
		    if(diff<min) {
			min = diff;
			closest = r;
		    }
		}
	    });
	    if(!closest) 
		return {index:-1, record:null}
	    return {index:this.recordToIndex[closest.getId()], record:closest};
	},
        makeDataArray: function(dataList) {
	    if(!dataList) return null;
            if (dataList.length == 0) return dataList;
            let data = [];
            if (dataList[0].getData) {
                for (let i = 0; i < dataList.length; i++) {
		    data.push(dataList[i].getData()[0]);
		}
            } else if (dataList[0].tuple) {
                for (let i = 0; i < dataList.length; i++) {
                    data.push(dataList[i].tuple);
		}
            } else {
                data = dataList;
            }
            return data;
        },

        printFields: function(label, fields) {
            console.log(label);
            if (!fields) {
                console.log("   null fields");
                return;
            }

            for (a in fields)
                console.log("   " + fields[a].getId());
        },
	makeIndexValue: function(indexField, value, offset) {
	    return value+offset;
	},
        getStandardData: function(fields, args) {
	    let defaultIndexName= this.getProperty("indexName", "Index");
	    if(!args) args = {};
	    let debug = displayDebug.getStandardData;
	    if(debug) console.log("getStandardData:" + this.type +"  fields:" + fields);
	    let showUnit  = this.getProperty("showUnit",this.getProperty("showUnitInSeries",true));
	    this.recordToIndex = {};
	    this.indexToRecord = {};
            let pointData = this.getPointData();
            let excludeZero = this.getProperty(PROP_EXCLUDE_ZERO, false);
            let excludeNan = this.getProperty(PROP_EXCLUDE_NAN, false);	    
            if (fields == null) {
                fields = pointData.getRecordFields();
		if(debug) console.log("\tgetRecordFields: " + fields.length);
            } else {
		//		if(debug) console.log("\tfields 2: " + fields.length);
	    }
            props = {
                makeObject: true,
                includeIndex: true,
                includeIndexIfDate: false,
                groupByIndex: -1,
                raw: false,
            };
            if (args != null) {
                $.extend(props, args);
            }



            let groupByIndex = props.groupByIndex;
            let groupByList = [];
 	    let groupByValues = {};

	    let groupByRecords = [];
	    let groupByDate = this.getProperty("groupByDate");
	    let groupByFill = this.getProperty("groupByFill");
	    let groupByDateMap = {};
	    let groupByDates = [];

            let dataList = [];
            //The first entry in the dataList is the array of names
            //The first field is the domain, e.g., time or index
            let fieldNames = [];
            let fieldsForTuple = [];	    
	    if(this.getProperty("binDate")) {
		if(debug)
		    console.log("binning date");
		let binType = this.getProperty("binType","total");
		let binCount = binType=="count";
		if(binCount) {
		    let f = [];
		    fields.forEach((field)=>{
			f.push(new RecordField({
			    index:0,
			    id:field.getId(),
			    label:this.getProperty("binDateLabel", this.getProperty("binCountLabel","Count")),
			    type:"double",
			    chartable:true
			}));
		    });
		    fields=f;
		}
	    }

	    let seenDate = false;
	    fields  = fields.filter(f=>{
		if(f.isFieldDate()) {
		    if(seenDate  && f.isRecordDate()) return null;
		    seenDate = true;
		}
		return f;
	    });
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.isFieldNumeric() && field.isFieldDate()) {
                    //                        console.log("Skipping:" + field.getLabel());
                    //                        continue;
                }
                let name = field.getLabel(this);
                if (showUnit && field.getUnit() != null) {
                    name += " (" + field.getUnit() + ")";
                }
                //                    name = name.replace(/!!/g,"<br><hr>&nbsp;&nbsp;&nbsp;")
                name = name.replace(/!!/g, " -- ")
                fieldNames.push(name);
		fieldsForTuple.push(field);
            }
            if (props.makeObject) {
                dataList.push({
                    tuple: fieldNames,
		    fields:fieldsForTuple,
                    record: null
                });
            } else {
                dataList.push(fieldNames);
            }
            //console.log(fieldNames);



            groupByList.push("");
	    groupByRecords.push(null);
	    if(!this.minDateObj) {
		this.minDateObj = Utils.parseDate(this.minDate, false);
		if(debug)
		    console.log("getStandardData setting min date:" + this.minDateObj);
	    }
	    if(!this.minDateObj) {
		this.maxDateObj = Utils.parseDate(this.maxDate, true, this.minDateObj);
		if(debug)
		    console.log("getStandardData setting max date:" + this.maxDateObj);
	    }

            if (this.minDateObj == null && this.maxDateObj != null) {
                this.minDateObj = Utils.parseDate(this.minDate, false, this.maxDateObj);
            }



            let offset = 0;
            if (Utils.isDefined(this.offset)) {
                offset = parseFloat(this.offset);
            }

            let nonNullRecords = 0;
            let records = args.records?args.records:this.filterData();
	    if(debug)
		console.log("getStandardData #fields:" + fields.length +" #records:" + records.length);
            let allFields = pointData.getRecordFields();

            //Check if there are dates and if they are different
            this.hasDate = this.getHasDate(records);
            let date_formatter = null;
            let rowCnt = -1;
            let indexField = this.getFieldById(null,this.getProperty("indexField"));
	    let t1 = new Date();
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let record = records[rowIdx];
                let date = record.getDate();
                if (!this.dateInRange(date,rowIdx)) {
		    continue;
		}
                rowCnt++;
		this.recordToIndex[record.getId()] = rowCnt;
		this.indexToRecord[rowCnt] = record;
                let values = [];
                if (props && (props.includeIndex || props.includeIndexIfDate)) {
                    let indexName = null;
                    if (indexField) {
			let value = this.makeIndexValue(indexField,record.getValue(indexField.getIndex()),rowIdx);
                        values.push(value);
                        indexName = indexField.getLabel();
                    } else {
                        if (this.hasDate) {
			    let dttm = this.getDateValue(date, date_formatter);
                            values.push(dttm);
                            indexName = "Date";
                        } else {
                            if (!props.includeIndexIfDate) {
                                values.push(rowIdx);
				indexName = defaultIndexName;
                            }
                        }
                    }
                    if (indexName != null && rowCnt == 0) {
                        fieldNames.unshift(indexName);
                    }
                }

                let allNull = true;
                let allZero = true;
                let hasNumber = false;
		let hasNan = false;
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    if (field.isFieldNumeric() && field.isFieldDate()) {
                        //                            continue;
                    }
                    let value = record.getValue(field.getIndex());
                    if (offset != 0) {
                        value += offset;
                    }

		    //		    if(debug&& rowIdx<10)
		    //			console.log("   v:"+ value);
                    if (value != null) {
                        allNull = false;
                    }
                    if (typeof value == 'number') {
			if(excludeNan &&  isNaN(value))  {
			    hasNan=true;
			}
                        hasNumber = true;
                        if (value != 0) {
                            allZero = false;
                        }
                    }
                    if (field.isFieldDate()) {
                        value = this.getDateValue(value, date_formatter);
                    }
                    values.push(value);
		}


		if(hasNan) {
		    continue;
		}
                if (hasNumber && allZero && excludeZero) {
		    //		    console.log(" skipping due to zero: " + values);
                    continue;
                }
                //TODO: when its all null values we get some errors
                if (groupByIndex >= 0) {
		    let value = record.getValue(groupByIndex);
		    if(!groupByValues[value]) groupByValues[value] = true;
		    if(groupByDate)
			groupByList.push(record.getDate() +"-"+value);
		    else
			groupByList.push(value);
		    groupByRecords.push(record);
                }
                if (props.makeObject)
                    dataList.push({
                        tuple: values,
                        record: record
                    });
                else
                    dataList.push(values);
                if (!allNull) {
                    nonNullRecords++;
                }
	    }

	    let t2= new Date();
//	    console.log("#records:" + records.length);
//	    Utils.displayTimes("chart.standardData loop:",[t1,t2], true);
            if (nonNullRecords == 0) {
		//		console.log("Num non null:" + nonNullRecords);
		console.log(this.type+" no nonNull records");
		return [];
            }

            if (groupByIndex >= 0) {
                let groupToTuple = {};
                let groups = [];
                let agg = [];
                let title = [];
		let groupByCount = this.getProperty("groupByCount");
                title.push(props.groupByField.getLabel());
		if(groupByCount) {
		    title.push(this.getProperty("groupByCountLabel", "Count"));
		} else {
                    for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
			let field = fields[fieldIdx];
			if (field.getIndex() != groupByIndex) {
                            title.push(field.getLabel());
			}
                    }
		}
		//                agg.push(title);
		let groupByValueTuples = {};
                for (let rowIdx = 0; rowIdx < dataList.length; rowIdx++) {
                    let data = this.getDataValues(dataList[rowIdx]);
                    if (rowIdx == 0) {
                        continue;
                    }
                    let groupBy = groupByList[rowIdx];
		    let record = groupByRecords[rowIdx];
		    let groupByValue = record.getValue(groupByIndex);
                    let tuple = groupToTuple[groupBy];
                    if (tuple == null) {
                        tuple = new Array();
                        groups.push(groupBy);
			if(groupByDate) {
			    let dateList = groupByDateMap[record.getDate()];
			    if(dateList == null) {
				groupByDateMap[record.getDate()] = dateList = [];
				groupByDates.push(record.getDate());
			    }
			    dateList.push(tuple);
			}
			if(!groupByValueTuples[groupByValue]) groupByValueTuples[groupByValue] = [];
			groupByValueTuples[groupByValue].push(tuple)
			tuple.record = record;
                        agg.push(tuple);
                        tuple.push(groupByValue);
			if(groupByCount) {
			    tuple.push(0);
			} else {
                            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
				let field = fields[fieldIdx];
				if (field.getIndex() == groupByIndex) {
                                    continue;
				}
				tuple.push(0);
                            }
			}
                        groupToTuple[groupBy] = tuple;
                    }
                    let index = 0;
		    if(groupByCount) {
			tuple[1]++;
			continue;
		    }
                    for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                        let field = fields[fieldIdx];
                        if (field.getIndex() == groupByIndex) {
                            continue;
                        }
                        let dataValue = data[fieldIdx];
                        index++;
                        if (Utils.isNumber(dataValue)) {
                            if (typeof tuple[index] == "string") {
                                tuple[index] = 0;
                            }
                            tuple[index] += parseFloat(dataValue);
                        } else {
                            if (tuple[index] == 0) {
                                tuple[index] = "";
                            }
                            let s = tuple[index];
                            if (!Utils.isDefined(s)) {
                                s = "";
                            }
                            //Only concat string values for a bit
                            if (s.length < 150) {
                                if (!Utils.isDefined(dataValue)) {
                                    dataValue = "";
                                }
                                let sv = ("" + dataValue);
                                if (s.indexOf(sv) < 0) {
                                    if (s != "") {
                                        s += ", ";
                                    }
                                    s += sv;
                                    tuple[index] = s;
                                }
                            }

                        }
                    }
		}

		if(groupByFill) {
		    groupByDates.forEach(date=>{
			let dateList = groupByDateMap[date];
			let seen = {};
			dateList.forEach(tuple =>{
			    seen[tuple[0]] = true;
			});
			for(v in groupByValues) {
			    if(!seen[v]) {
				seen[v] = true;
				let tuple = [v,0];
				tuple.date = date;
				agg.push(tuple);
			    }
			}
		    });
		}

		if(this.getProperty("groupBySort")) {
		    agg.sort(function(a,b) {return b[1]-a[1]});
		}
		if(this.getProperty("groupByMaxNumber")) {
		    let cnt = +this.getProperty("groupByMaxNumber");
		    agg = agg.filter((t,idx)=>{
			return idx<cnt;
			
		    });

		}
		let tmp = [];
		tmp.push(title);
		agg.forEach(t=>tmp.push(t));
                return tmp;
            }

	    //	    console.log("display.getStandardData returning "+ dataList.length);
	    if(this.getProperty("movingAverageSteps")) {
		let steps = +this.getProperty("movingAverageSteps");
		let tmp = [dataList[i]];
		let isNumeric = dataList[1].tuple.map((v,idx)=>{return Utils.isNumber(v);});
		dataList.forEach((o,rowIdx)=>{
		    if(rowIdx==0) return;
		    let tuple = Utils.mergeLists(o.tuple);
		    tmp.push({
			record:o.record,
			tuple:tuple});
		    tuple[0] = "x"; tuple[1] = 5;
		    tuple.forEach((v,colIdx)=>{
			if(!isNumeric[colIdx]) return;
			tuple[colIdx]=5;
		    });
		});
		dataList = tmp;
	    }
            return dataList;
        },
        isGoogleLoaded: function() {
            if ((typeof google === 'undefined') || (typeof google.visualization === 'undefined') || (typeof google.visualization.DateFormat === 'undefined')) {
                return false;
            }
            return true;
        },
        initDateFormats: function() {
            if (!this.isGoogleLoaded()) {
                //                    console.log("google hasn't loaded");
                return false;
            }
            if (this.fmt_yyyy) return true;
            let tz = 0;
            this.timezone = this.getTimeZone();
            if (Utils.isDefined(this.timezone)) {
                tz = parseFloat(this.timezone);
            }
            this.fmt_yyyymmddhhmm = new google.visualization.DateFormat({
                pattern: "yyyy-MM-dd HH:mm Z",
                timeZone: tz
            });
            this.fmt_yyyymmdd = new google.visualization.DateFormat({
                pattern: "yyyy-MM-dd",
                timeZone: tz
            });
            this.fmt_yyyy = new google.visualization.DateFormat({
                pattern: "yyyy",
                timeZone: tz
            });
            return true;
        },
        getDateValue: function(arg) {
	    if(!arg) return {v:null,f:'NA'};
            if (!this.initDateFormats()) {
                return arg;
            }
            if (!(typeof arg == "object")) {
                date = new Date(arg);
            } else {
                date = arg;
            }
	    if(isNaN(date.getUTCFullYear())) return {v:date,f:"NA"};


	    if(this.getDateProps().dateFormatDaysAgo) {
		let now = new Date();
		let diff = Math.round((now.getTime()-date.getTime())/1000/60/60/24);
		return {v:date,f:diff+" days ago"};
	    }

            return  {
                v: date,
                f: this.formatDate(date)
            };
        },
        applyFilters: function(record, values) {
	    this.filters.forEach(filter=>{
                if (!filter.isRecordOk(record)) {
                    return false;
                }
            });
            return true;
        }
    });

    let filter = this.getProperty(PROP_DISPLAY_FILTER);
    if (filter != null) {
        //semi-colon delimited list of filter definitions
        //display.filter="filtertype:params;filtertype:params;
        //display.filter="month:0-11;
        let filters = filter.split(";");
        for (let i = 0; i < filters.length; i++) {
            filter = filters[i];
            let toks = filter.split(":");
            let type = toks[0];
            if (type == "month") {
                this.filters.push(new MonthFilter(toks[1]));
            } else {
                this.handleError("Unknown filter:" + type);
            }
        }
    }
}




function DisplayGroup(argDisplayManager, argId, argProperties, type) {
    const LAYOUT_TABLE = "table";
    const LAYOUT_HTABLE = "htable";
    const LAYOUT_TABS = "tabs";
    const LAYOUT_COLUMNS = "columns";
    const LAYOUT_ROWS = "rows";
    const SUPER = new RamaddaDisplay(argDisplayManager, argId, type||"group", argProperties);
    RamaddaUtil.inherit(this, SUPER);
    let myProps = [
	{label:'Group Properties'},
	{p:PROP_LAYOUT_TYPE,ex:Utils.join([LAYOUT_TABLE,LAYOUT_HTABLE,LAYOUT_TABS,LAYOUT_COLUMNS,LAYOUT_ROWS],",")},
	{p:PROP_LAYOUT_COLUMNS,d:1},
	{p:'targetDiv',tt:'Div id to put the displays in for this group'},
	]

    displayDefineMembers(this, myProps, {
        displays: [],
        layout: this.getProperty(PROP_LAYOUT_TYPE, LAYOUT_TABLE),
        columns: this.getProperty(PROP_LAYOUT_COLUMNS, 1),
        isLayoutColumns: function() {
            return this.layout == LAYOUT_COLUMNS;
        },
        getWikiText: function() {
            let attrs = ["layoutType", this.layout,
			 "layoutColumns",
			 this.columns,
			 "showMenu",
			 "false",
			 "groupDiv",			 
			 "$entryid_maindiv"
			];
            let wiki = "";
            wiki += "<div id=\"{{entryid}}_maindiv\"></div>\n";
            wiki += "{{group " + HU.attrs(attrs) + "}}\n"
            return wiki;
        },

        walkTree: function(func, data) {
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.walkTree != null) {
                    display.walkTree(func, data);
                } else {
                    func.call(data, display);
                }
            }
        },
        collectEntries: function(entries) {
            if (entries == null) entries = [];
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.collectEntries != null) {
                    display.collectEntries(entries);
                } else {
                    let displayEntries = display.getEntries();
                    if (displayEntries != null && displayEntries.length > 0) {
                        entries.push({
                            source: display,
                            entries: displayEntries
                        });
                    }
                }
            }
            return entries;
        },
        isLayoutRows: function() {
            return this.layout == LAYOUT_ROWS;
        },

        getPosition: function() {
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.getPosition) {
                    return display.getPosition();
                }
            }
        },
        getDisplays: function() {
            return this.displays;
        },
        notifyEvent: function(event, source, data) {
            let displays = this.getDisplays();
	    let debug = false;
	    //debug=event.name=='filteredDataChanged';

	    if(debug)
		console.log('notifyEvent',event,displays.length);
	    let group = (source!=null&&source.getProperty?source.getProperty(event.shareGroup):"");
	    if(displayDebug.notifyEvent)
		console.log("displayManager.notifyEvent:" + event);

            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display == source) {
		    if(debug) console.log('\tskipping source');
                    continue;
                }
		let acceptGroup = (display!=null&&display.getProperty?display.getProperty(event.acceptGroup):"");
		if(group) {
		    if(acceptGroup!=group)  {
			if(debug || displayDebug.notifyEvent)
			    console.log("\t" + display.type+" not in group:" + group);
			continue;
		    }
		} else if(acceptGroup) {
		    if(debug||displayDebug.notifyEvent)
			console.log("\t" + display.type+" incoming not in accept group:" + acceptGroup);
		    continue;
		}
		if(!display.acceptEvent(event,  event.default)) {
		    if(debug||displayDebug.notifyEvent)
			console.log("\t" + display.type+" not accepting");
		    continue;
		}
//		console.log("notifyEvent:" + display.type+" " + event +" group:" + group);
                let eventSource = display.getEventSource();
                if (eventSource != null && eventSource.length > 0) {
                    if (eventSource != source.getId() && eventSource != source.getName()) {
                        continue;
                    }
                }
		if(debug ||displayDebug.notifyEvent)
		    console.log("\t" + display.type+" calling notifyEvent:" + event);
                display.notifyEvent(event, source, data);
            }
        },
        getDisplaysToLayout: function() {
            let result = [];
            for (let i = 0; i < this.displays.length; i++) {
                if (this.displays[i].getIsLayoutFixed()) {
		    continue;
		}
                result.push(this.displays[i]);
            }
            return result;
        },
        pageHasLoaded: function(display) {
	    //Maybe we don't need to do this since the displays get called globally
	    //            for (let i = 0; i < this.displays.length; i++) {
	    //                this.displays[i].setDisplayReady(true);
	    //            }
            this.doLayout();
        },
        addDisplay: function(display) {
            this.displays.push(display);
            if (display.getIsLayoutFixed()) {
		display.initDisplay();
	    } else {
		if (Utils.getPageLoaded()) {
                    this.doLayout();
		}
	    }
        },
        layoutChanged: function(display) {
            this.doLayout();
        },
        removeDisplay: function(display) {
	    Utils.removeItem(this.displays,display);
            this.doLayout();
        },
        doLayout: function() {
	    let html = "";
            let colCnt = 100;
            let displaysToLayout = this.getDisplaysToLayout();
            let displaysToPrepare = this.displays;
	    displaysToPrepare.forEach(display=>{
                if (display.prepareToLayout != null) {
                    display.prepareToLayout();
                }
            });

            let weightIdx = 0;
            let weights = null;
            if (typeof this.weights != "undefined") {
                weights = this.weights.split(",");
            }

            for (let i=0; i < displaysToLayout.length; i++) {
                let divId = HU.getUniqueId("divid_");
                let div =  HU.div([ATTR_CLASS, " display-wrapper",ID,divId],"");
                displaysToLayout[i].setProperty(PROP_DIVID,divId);
                displaysToLayout[i].layoutDiv=div;
            }
            let tabId = HU.getUniqueId("tabs_");
            if (this.layout == LAYOUT_TABLE) {
                if  (displaysToLayout.length== 1) {
                    html += displaysToLayout[0].layoutDiv;
                } else {
                    let weight = 12 / this.columns;
                    let i = 0;
                    let map = {};
                    for (; i < displaysToLayout.length; i++) {
                        let d = displaysToLayout[i];
                        if (Utils.isDefined(d.column) && Utils.isDefined(d.row) && d.columns >= 0 && d.row >= 0) {
                            let key = d.column + "_" + d.row;
                            if (map[key] == null) map[key] = [];
                            map[key].push(d);
                        }
                    }

                    i = 0;
                    for (; i < displaysToLayout.length; i++) {
                        colCnt++;
                        if (colCnt >= this.columns) {
                            if (i > 0) {
                                html += HU.close(TAG_DIV);
                            }
                            html += HU.open("div", [ATTR_CLASS, "row"]);
                            colCnt = 0;
                        }
                        let weightToUse = weight;
                        if (weights != null) {
                            if (weightIdx >= weights.length) {
                                weightIdx = 0;
                            }
                            weightToUse = weights[weightIdx];
                            weightIdx++;
                        }
                        html += HU.div([ATTR_CLASS, "col-md-" + weightToUse + " display-wrapper display-cell"], displaysToLayout[i].layoutDiv);
			html+="\n";
		    }

                    if (i > 0) {
                        html += HU.close(TAG_DIV);
                    }
                }
	    } else if (this.layout == LAYOUT_HTABLE) {
                if  (displaysToLayout.length== 1) {
                    html += displaysToLayout[0].layoutDiv;
                } else {
                    let percent = Math.round((100 / this.columns))+"%";
                    let i = 0;
		    html+=HU.open(TABLE,[ATTR_WIDTH,'100%']);
		    let colCnt = 100;
                    for (let i =0;i < displaysToLayout.length; i++) {
                        colCnt++;
                        if (colCnt >= this.columns) {
                            if (i > 0) {
                                html += HU.close(TAG_TR);
                            }
                            html += HU.open("tr", ["valign", "top"]);
			    html+="\n";
                            colCnt = 0; 
                        }
			//Add in the max-width so the width of the td doesn't exceed the percent value
                        html += HU.td([ATTR_STYLE,"max-width:300px;", ATTR_WIDTH,percent], displaysToLayout[i].layoutDiv);
			html+="\n";
		    }
                    if (i > 0) {
                        html += HU.close(TAG_TR);
                    }
                }
            } else if (this.layout == LAYOUT_TABS) {
                html += HU.open(TAG_DIV, [ATTR_ID, tabId, ATTR_CLASS, "ui-tabs"]);
                html += HU.open(TAG_UL, []);
                let hidden = "";
                let cnt = 0;
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let label = display.getTitle(false);
                    if (label.length > 20) {
                        label = label.substring(0, 19) + "...";
                    }
                    html += HU.tag(TAG_LI, [], HU.tag(TAG_A, ["href", "#" + tabId + "-" + cnt], label));
                    hidden += HU.div([ATTR_ID, tabId + "-" + cnt, ATTR_CLASS, "ui-tabs-hide"], display.layoutDiv);
                    cnt++;
                }
                html += HU.close(TAG_UL);
                html += hidden;
                html += HU.close(TAG_DIV);
            } else if (this.layout == LAYOUT_ROWS) {
                let rows = [];
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let row = display.getRow();
                    if (("" + row).length == 0) row = 0;
                    while (rows.length <= row) {
                        rows.push([]);
                    }
                    rows[row].push(display.layoutDiv);
                }
                for (let i = 0; i < rows.length; i++) {
                    let cols = rows[i];
                    let width = Math.round(100 / cols.length) + "%";
                    html += HU.open(TAG_TABLE, ["border", "0", "width", "100%", "cellpadding", "0", "cellspacing", "0"]);
                    html += HU.open(TAG_TR, ["valign", "top"]);
                    for (let col = 0; col < cols.length; col++) {
                        let cell = cols[col];
                        cell = HU.div([ATTR_CLASS, "display-cell"], cell);
                        html += HU.tag(TAG_TD, ["width", width], cell);
                    }
                    html += HU.close(TAG_TR);
                    html += HU.close(TAG_TABLE);
                }
            } else if (this.layout == LAYOUT_COLUMNS) {
                let cols = [];
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let column = display.getColumn();
                    //                        console.log("COL:" + column);
                    if (("" + column).length == 0) column = 0;
                    while (cols.length <= column) {
                        cols.push([]);
                    }
                    cols[column].push(display.layoutDiv);
                    //                        cols[column].push("HTML");
                }
                html += HU.open(TAG_DIV, [ATTR_CLASS, "row"]);
                let width = Math.round(100 / cols.length) + "%";
                let weight = 12 / cols.length;
                for (let i = 0; i < cols.length; i++) {
                    let rows = cols[i];
                    let contents = "";
                    for (let j = 0; j < rows.length; j++) {
                        contents += rows[j];
                    }
                    let weightToUse = weight;
                    if (weights != null) {
                        if (weightIdx >= weights.length) {
                            weightIdx = 0;
                        }
                        weightToUse = weights[weightIdx];
                        weightIdx++;
                    }
                    html += HU.div([ATTR_CLASS, "col-md-" + weightToUse], contents);
                }
                html += HU.close(TAG_DIV);
            } else {
                html += "Unknown layout:" + this.layout;
            }

	    //If we don't  have any displays to show then hide us
	    if(!this.getShowMenu() && displaysToLayout.length==0) {
		//TODO: This hides the change entry group menu 
//		$("#" + this.getId()).hide();
	    } else {
		$("#" + this.getId()).show();
	    }
	    let div = this.getGroupDiv();
	    if(div.length>0) {
		div.html(html);
	    } else {
		this.writeHtml(ID_DISPLAYS, html);
	    }
            if (this.layout == LAYOUT_TABS) {
                $("#" + tabId).tabs({activate: HtmlUtil.tabLoaded});
            }
            this.initDisplays();
        }, 
	initDisplays: function() {
	    this.getDisplaysToLayout().forEach(display=>{
		try {
                    display.initDisplay();
		} catch (e) {
		    display.handleError("Error creating display:<br>" + e,e);
		}
            });
	},
        displayData: function() {},
        setLayout: function(layout, columns) {
            this.layout = layout;
            if (columns) {
                this.columns = columns;
            }
            this.doLayout();
        },
        askMinZAxis: function() {
            let v = prompt("Minimum axis value", "0");
            if (v != null) {
                v = parseFloat(v);
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMinZAxis) {
                        display.setMinZAxis(v);
                    }
                }
            }
        },

        askMaxZAxis: function() {
            let v = prompt("Maximum axis value", "0");
            if (v != null) {
                v = parseFloat(v);
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMaxZAxis) {
                        display.setMaxZAxis(v);
                    }
                }
            }
        },

        askMinDate: function() {
            let d = this.minDate;
            if (!d) d = "1950-0-0";
            this.minDate = prompt("Minimum date", d);
            if (this.minDate != null) {
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMinDate) {
                        display.setMinDate(this.minDate);
                    }
                }
            }
        },

        askMaxDate: function() {
            let d = this.maxDate;
            if (!d) d = "2020-0-0";
            this.maxDate = prompt("Maximum date", d);
            if (this.maxDate != null) {
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMaxDate) {
                        display.setMaxDate(this.maxDate);
                    }
                }
            }
        },


        titlesOff: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowTitle(false);
            }
        },
        titlesOn: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowTitle(true);
            }
        },
        detailsOff: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowDetails(false);
            }
            this.doLayout();
        },
        detailsOn: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowDetails(true);
            }
            this.doLayout();
        },

        deleteAllDisplays: function() {
            this.displays = [];
            this.doLayout();
        },
        moveDisplayUp: function(display) {
            let index = this.displays.indexOf(display);
            if (index <= 0) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(index - 1, 0, display);
            this.doLayout();
        },
        moveDisplayDown: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= this.displays.length) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(index + 1, 0, display);
            this.doLayout();
        },

        moveDisplayTop: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= this.displays.length) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(0, 0, display);
            this.doLayout();
        },


    });

}



/*
 */
function RamaddaFieldsDisplay(displayManager, id, type, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    defineDisplay(this, SUPER, [], {
        needsData: function() {
            return true;
        },
        initDisplay: function() {
            SUPER.initDisplay.call(this);
            if (this.needsData()) {
		if(this.useDisplayMessage()) {
                    this.setDisplayMessage(this.getLoadingMessage());
		} else {
                    this.setContents(this.getLoadingMessage());
		}
            }
            this.callUpdateUI();
        },
        updateUI: function(args) {
            this.addFieldsCheckboxes();
        },
        getWikiAttributes: function(attrs) {
            SUPER.getWikiAttributes.call(this, attrs);
            if (this.lastSelectedFields) {
                attrs.push(PROP_FIELDS);
                let v = "";
                for (let i = 0; i < this.lastSelectedFields.length; i++) {
                    v += this.lastSelectedFields[i].getId();
                    v += ",";
                }
                attrs.push(v);
            }
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            this.addFieldsCheckboxes();
        },
        getDialogContents: function(tabTitles, tabContents) {
            let height = "600";
//            let html = HU.div([ATTR_ID, this.getDomId(ID_FIELDS), ATTR_STYLE, HU.css("overflow-y","auto","max-height", height + "px")], "");
//            tabTitles.push("Fields");
//            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },
        handleEventFieldsSelected: function(source, fields) {
	    let tmp = [];
	    fields.forEach(f=>{
		let fieldId = f.getId?f.getId():f;
		f = this.getFieldById(null, fieldId);
		if(f) tmp.push(f);
	    });
	    fields=tmp;
//	    console.log("fields before:" + this.getSelectedFields());
//	    console.log("fields after:" + fields);

            this.overrideFields = null;
            this.removeProperty(PROP_FIELDS);
            this.setSelectedFields(fields);
            this.fieldSelectionChanged();
        },

        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        canDoMultiFields: function() {
            return true;
        }
    })
}



/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/



//Properties
const PROP_LAYOUT_TYPE = "layoutType";
const PROP_LAYOUT_COLUMNS = "layoutColumns";
const PROP_SHOW_MAP = "showMap";
const PROP_SHOW_MENU = "showMenu";
const PROP_FROMDATE = "fromDate";
const PROP_TODATE = "toDate";
const DISPLAY_MULTI = "multi";



//
//adds the display manager to the list of global display managers
//
function addDisplayManager(displayManager) {
    if (window.globalDisplayManagers == null) {
        window.globalDisplayManagers = {};
        // window.globalDisplayManager = null;
    }
    window.globalDisplayManagers[displayManager.getId()] = displayManager;
    window.globalDisplayManager = displayManager;
}




addGlobalDisplayType({
    type: DISPLAY_MULTI,
    label: "Multi Chart",
    requiresData: true,
    forUser: false,
    category: "Misc"
});





//
//This will get the currently created global displaymanager or will create a new one
//
function getOrCreateDisplayManager(id, properties, force) {
    if (!force) {
        var displayManager = getDisplayManager(id);
        if (displayManager != null) {
            return displayManager;
        }
        if (window.globalDisplayManager != null) {
            return window.globalDisplayManager;
        }
    }
    var displayManager = new DisplayManager(id, properties);
    if (window.globalDisplayManager == null) {
        window.globalDisplayManager = displayManager;
    }
    return displayManager;
}

//
//return the global display manager with the given id, null if not found
//
function getDisplayManager(id) {
    if (window.globalDisplayManagers == null) {
        return null;
    }
    var manager = window.globalDisplayManagers[id];
    return manager;
}



var ID_DISPLAYS = "displays";

//
//DisplayManager constructor
//

function DisplayManager(argId, argProperties) {

    var ID_MENU_BUTTON = "menu_button";
    var ID_MENU_CONTAINER = "menu_container";
    var ID_MENU_OUTER = "menu_outer";
    var ID_MENU_INNER = "menu_inner";


    RamaddaUtil.inherit(this, this.SUPER = new DisplayThing(argId, argProperties));
    addRamaddaDisplay(this);

    RamaddaUtil.initMembers(this, {
        dataList: [],
        displayTypes: [],
        initMapBounds: null,
    });


    RamaddaUtil.defineMembers(this, {
        group: new DisplayGroup(this, argId, argProperties),
        showmap: this.getProperty(PROP_SHOW_MAP, null),
        setDisplayReady: function() {
            SUPER.setDisplayReadyCall(this);
            this.getLayoutManager().setDisplayReady();
        },
        getLayoutManager: function() {
            return this.group;
        },
        collectEntries: function() {
            return  this.getLayoutManager().collectEntries();
        },
        getData: function() {
            return this.dataList;
        },
        handleEventFieldValueSelect: function(source, args) {
            this.notifyEvent(DisplayEvent.fieldValueSelected, source, args);
        },
        handleEventFieldsSelected: function(source, fields) {
            this.notifyEvent(DisplayEvent.fieldsSelected, source, fields);
        },
        handleEventPropertyChanged: function(source, prop) {
            this.notifyEvent(DisplayEvent.propertyChanged, source, prop);
        },
        handleEventEntriesChanged: function(source, entries) {
            this.notifyEvent(DisplayEvent.entriesChanged, source, entries);
        },
        handleEventMapBoundsChanged: function(source, bounds, forceSet) {
            var args = {
                "bounds": bounds,
                "force": forceSet
            };
            this.notifyEvent(DisplayEvent.mapBoundsChanged, source, args);
        },
        addMapLayer: function(source, entry) {
            this.notifyEvent("addMapLayer", source, {
                entry: entry
            });
        },
        propagateEventRecordSelection: function(source, pointData, args) {
            var index = args.index;
            if (pointData == null && this.dataList.length > 0) {
                pointData = this.dataList[0];
            }
            var fields = pointData.getRecordFields();
            var records = pointData.getRecords();
            if (records == null) {
                return;
            }
            if (index < 0 || index >= records.length) {
                console.log("propagateEventRecordSelection: bad index= " + index);
                return;
            }
            var record = records[index];
            if (record == null) return;
            var values = source?source.getRecordHtml(record, fields):"";
            if (source.recordSelectionCallback) {
                var func = source.recordSelectionCallback;
                if ((typeof func) == "string") {
                    func = window[func];
                }
                func({
                    display: source,
                    pointData: pointData,
                    index: index,
                    pointRecord: record
                });
            }
            var params = {
                index: index,
                record: record,
                html: values,
                data: pointData
            };
            this.notifyEvent(DisplayEvent.recordSelection, source, params);
            var entries = source.getEntries();
            if (entries != null && entries.length > 0) {
                this.handleEventEntrySelection(source, {
                    entry: entries[0],
                    selected: true
                });
            }
        },
        handleEventEntrySelection: function(source, props) {
            this.notifyEvent(DisplayEvent.entrySelection, source, props);
        },
        handleEventEntryMouseover: function(source, props) {
            this.notifyEvent(DisplayEvent.entryMouseover, source, props);
        },
        handleEventEntryMouseout: function(source, props) {
            this.notifyEvent(DisplayEvent.entryMouseout, source, props);
        },
        handleEventPointDataLoaded: function(source, pointData) {
            this.notifyEvent(DisplayEvent.pointDataLoaded, source, pointData);
        },
        ranges: {
            //               "TRF": [0,100],
        },
        setRange: function(field, range) {
            if (this.ranges[field.getId()] == null) {
                this.ranges[field.getId()] = range;
            }
        },
        getRange: function(field) {
            return this.ranges[field.getId()];
        },
        makeMainMenu: function() {
	    if(!this.getShowMenu()) {
		return "";
	    }
            //How else do I refer to this object in the html that I add 
            var get = "getDisplayManager('" + this.getId() + "')";
            var layout = "getDisplayManager('" + this.getId() + "').getLayoutManager()";
            var html = "";

            var newMenus = {};
            var cats = [];
            var displayTypes = [];
            if (window.globalDisplayTypes != null) {
                displayTypes = window.globalDisplayTypes;
            }
	    DISPLAY_CATEGORIES.forEach(category=>{
                newMenus[category] = [];
                cats.push(category);
	    });
            for (var i = 0; i < displayTypes.length; i++) {
                //The ids (.e.g., 'linechart' have to match up with some class function with the name 
                var type = displayTypes[i];
                if (Utils.isDefined(type.forUser) && !type.forUser) {
                    continue;
                }
		var category = type.category;
                if (!category) {
                    category = CATEGORY_MISC;
                }
                if (newMenus[category] == null) {
                    newMenus[category] = [];
                    cats.push(category);
                }
		let menuAttrs = ["onclick", get + ".userCreateDisplay('" + type.type + "');"];
		if(type.desc) {
		    menuAttrs.push(TITLE);
		    menuAttrs.push(type.desc);
		}
                newMenus[category].push(HU.tag(TAG_LI, [], HU.tag(TAG_A, menuAttrs, type.label)));
            }
            let newMenu = "";
            for (var i = 0; i < cats.length; i++) {
                var cat = cats[i];
		var menu = Utils.join(newMenus[cat],"");
                var subMenu = HU.tag("ul", [], menu);
                var catLabel = HU.tag(TAG_A, [], cat);
                newMenu += HU.tag(TAG_LI, [], catLabel + subMenu);
            }


            var publishMenu =
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('media_photoalbum');", "New Photo Album")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('wikipage');", "New Wiki Page")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('blogentry');", "New Blog Post")) + "\n";


            var fileMenu =
                HU.tag(TAG_LI, [], "<a>Publish</a>" + HU.tag("ul", [], publishMenu)) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".showWikiText();", "Show Text")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".copyWikiText();", "Copy Text")) + "\n" +		
                HU.tag(TAG_LI, [], HU.onClick(layout + ".copyDisplayedEntries();", "Save entries")) + "\n";


            var titles = HU.tag(TAG_DIV, [ATTR_CLASS, "ramadda-menu-block"], "Titles: " + HU.onClick(layout + ".titlesOn();", "On") + "/" + HU.onClick(layout + ".titlesOff();", "Off"));
            var dates = HU.tag(TAG_DIV, [ATTR_CLASS, "ramadda-menu-block"],
				      "Set date range: " +
				      HU.onClick(layout + ".askMinDate();", "Min") + "/" +
				      HU.onClick(layout + ".askMaxDate();", "Max"));
            var editMenu =
                HU.tag(TAG_LI, [], HU.tag(TAG_DIV, [ATTR_CLASS, "ramadda-menu-block"],
							"Set axis range :" +
							HU.onClick(layout + ".askMinZAxis();", "Min") + "/" +
							HU.onClick(layout + ".askMaxZAxis();", "Max"))) +
                HU.tag(TAG_LI, [], dates) +
                HU.tag(TAG_LI, [], titles) + "\n" +
                HU.tag(TAG_LI, [], HU.tag(TAG_DIV, [ATTR_CLASS, "ramadda-menu-block"], "Details: " + HU.onClick(layout + ".detailsOn();", "On", []) + "/" +
							HU.onClick(layout + ".detailsOff();", "Off", []))) +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".deleteAllDisplays();", "Delete all displays")) + "\n" +
                "";


            var table = HU.tag(TAG_DIV, [ATTR_CLASS, "ramadda-menu-block"], "Table: " +
				      HU.onClick(layout + ".setLayout('table',1);", "1 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',2);", "2 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',3);", "3 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',4);", "4 column"));
            var layoutMenu =
                HU.tag(TAG_LI, [], table) +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('rows');", "Rows")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('columns');", "Columns")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('tabs');", "Tabs"));


            var menuBar = HU.tag(TAG_LI, [], "<a>File</a>" + HU.tag("ul", [], fileMenu));
            menuBar += HU.tag(TAG_LI, [], "<a>Edit</a>" + HU.tag("ul", [], editMenu)) +
                HU.tag(TAG_LI, [], "<a>New</a>" + HU.tag("ul", [], newMenu)) +
                HU.tag(TAG_LI, [], "<a>Layout</a>" + HU.tag("ul", [], layoutMenu));


            var menu = HU.div([STYLE,"background:#fff;z-index:1000;", ATTR_CLASS, "xramadda-popup", ATTR_ID, this.getDomId(ID_MENU_OUTER)],
			      HU.tag("ul", [ATTR_ID, this.getDomId(ID_MENU_INNER), ATTR_CLASS, "sf-menu"], menuBar));

            html += menu;
            //                html += HU.tag(TAG_A, [ATTR_CLASS, "display-menu-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)],"&nbsp;");
            //                html+="<br>";
            return html;
        },
        hasGeoMacro: function(jsonUrl) {
	    if(!jsonUrl) return false;
            return jsonUrl.match(/(\${latitude})/g) != null;
        },
        getJsonUrl: function(jsonUrl, display, props) {
	    display.getRequestMacros().forEach(m=>{
		jsonUrl = m.apply(jsonUrl);
	    });
	    if(display.getAnimationEnabled()) {
		//Not now. Once was needed for gridded data
		//jsonUrl +='&doAnimation=true'
	    }
	    if(display.getProperty('dbSelect')) {
		jsonUrl +="&" + "dbSelect" +"=" +display.getProperty("select");
	    }
	    if(display.getProperty("requestArgs")) {
		let args = display.getProperty("requestArgs").split(",");
		for(let i=0;i<args.length;i+=2) {
		    jsonUrl +="&" + args[i] +"=" + args[i+1];
		}
	    }

	    if(display.pageSkip) {
		jsonUrl+="&skip=" + display.pageSkip;
	    }


            var fromDate = display.getProperty(PROP_FROMDATE);
            if (fromDate != null) {
                jsonUrl += "&fromdate=" + fromDate;
            }
            var toDate = display.getProperty(PROP_TODATE);
            if (toDate != null) {
                jsonUrl += "&todate=" + toDate;
            }


//	    jsonUrl=jsonUrl+"&FOO+BAR";
            let pattern = new RegExp(/startdate=([^&$]+)(&|$)/);
	    if(match = jsonUrl.match(pattern)) {
		let sep  = match[2];
//		jsonUrl = jsonUrl.replace(pattern,"startdate=-1 month" + sep);
//		console.log("URL:" + jsonUrl);
	    }

	    /*
	    if(display.getBounds) {
		let b = display.getBounds();
		//NWSE
		jsonUrl = HU.url(jsonUrl,["bounds",b.top+","+b.right+","+b.bottom+","+b.left]);
		console.log(b);
		console.log(jsonUrl);
	    }
	    //	    https://localhost:8430/repository/entry/show?entryid=89516542-f88f-43cf-98ce-f8ea2d3111b0&map_bounds=63.6307%2C-183.21358%2C29.38993%2C15.41923&zoomLevel=3&mapCenter=49.38817%2C-83.89717
*/

            if (this.hasGeoMacro(jsonUrl)) {
                var lon = props.lon;
                var lat = props.lat;

                if ((lon == null || lat == null) && this.map != null) {
                    var tuple = this.getPosition();
                    if (tuple != null) {
                        lat = tuple[0];
                        lon = tuple[1];
                    }
                }
                if (lon != null && lat != null) {
                    jsonUrl = jsonUrl.replace("${latitude}", lat.toString());
                    jsonUrl = jsonUrl.replace("${longitude}", lon.toString());
                }
            }
            jsonUrl = jsonUrl.replace("${numpoints}", 1000);
            return jsonUrl;
        },
        getDefaultData: function() {
            for (var i in this.dataList) {
                var data = this.dataList[i];
                var records = data.getRecords();
                if (records != null) {
                    return data;
                }
            }
            if (this.dataList.length > 0) {
                return this.dataList[0];
            }
            return null;
        },

        writeDisplay: function() {
            if (this.originalLocation == null) {
                this.originalLocation = document.location;
            }
            var url = this.originalLocation + "#";
            url += "&display0=linechart";
            for (var attr in document) {
                //                   if(attr.toString().contains("location")) 
                //                       console.log(attr +"=" + document[attr]);
            }
            document.location = url;

        },
        userCreateDisplay: function(type, props) {
            if (props == null) {
                props = {};
            }
            props.editMode = true;
            props.layoutHere = false;
            if (type == DISPLAY_LABEL && props.text == null) {
                var text = prompt("Text");
                if (text == null) return;
                props.text = text;
            }
            return this.createDisplay(type, props);
        },
        createDisplay: function(type, props) {

            if (props == null) {
                props = {};
            }

            if (props.data != null) {
		props.theData = props.data;
		props.data = null;
	    }

            if (props.theData != null && !props.theData.hasData()) {
                let haveItAlready = false;
                for (var i = 0; i < this.dataList.length; i++) {
                    let existingData = this.dataList[i];
                    if (existingData.equals(props.theData)) {
                        props.theData = existingData;
                        haveItAlready = true;
                        break;
                    }
                }
                if (!haveItAlready) {
                    this.dataList.push(props.theData);
                }
                //                console.log("data:" + haveItAlready);
            }

	    if(type==null || type.trim().length==0) return null;
            //            console.log("props:" + JSON.stringify(props));
            //Upper case the type name, e.g., linechart->Linechart
            var proc = type.substring(0, 1).toUpperCase() + type.substring(1);


            //Look for global functions  Ramadda<Type>Display, <Type>Display, <Type> 
            //e.g. - RamaddaLinechartDisplay, LinechartDisplay, Linechart 
            var classname = null;
            var names = ["Ramadda" + proc + "Display",
			 proc + "Display",
			 "Display"+ proc,
			 proc
			];
            var func = null;
            var funcName = null;
            var msg = "";
            for (var i = 0; i < names.length; i++) {
                msg += ("trying:" + names[i] + "\n");
                if (window[names[i]] != null) {
                    funcName = names[i];
                    func = window[names[i]];
                    break;
                }

            }

            if (func == null) {
                console.log("Error: could not find display function:" + type);
                //                    alert("Error: could not find display function:" + type);
                alert("Error: could not find display function:" + type + " msg: " + msg);
                return;
            }
            let displayId = props.displayId;
	    if(!displayId)  {
		displayId = this.getUniqueId("display");
	    }
            if (props.theData == null && this.dataList.length > 0) {
                props.theData = this.dataList[0];
            }
            props.createdInteractively = true;
            if (!props.entryId) {
                props.entryId = this.group.entryId;
            }
            let display = eval(" new " + funcName + "(this,'" + displayId + "', props);");
            if (display == null) {
                console.log("Error: could not create display using:" + funcName);
                alert("Error: could not create display using:" + funcName);
                return;
            }
	    if(props.dummy) return display;
            this.addDisplay(display);
	    display.doFinalInitialization();
            return display;
        },
        pageHasLoaded: function(display) {
            this.getLayoutManager().pageHasLoaded();
        },
        addDisplay: function(display) {
            display.setDisplayManager(this);
            this.getLayoutManager().addDisplay(display);
	    //Call loadInitialData a bit later so the display (e.g., the map) can be initialized
	    setTimeout(()=>{
		display.loadInitialData();
	    },1);
        },
	getDisplays: function() {
	    return this.getLayoutManager().getDisplays();
	},
        notifyEvent: function(event, source, data) {
            this.getLayoutManager().notifyEvent(event, source, data);
        },
        removeDisplay: function(display) {
            this.getLayoutManager().removeDisplay(display);
            this.notifyEvent(DisplayEvent.removeDisplay, this, display);
        },
	setEntry: function(entry) {
	    this.getLayoutManager().getDisplays().forEach(display=>{
		display.setEntry(entry);
	    });
	},
    });

    addDisplayManager(this);

    let displaysHtml = HU.div([ATTR_ID, this.getDomId(ID_DISPLAYS), ATTR_CLASS, "display-container",STYLE,HU.css("display","block")]);
    let html = HU.openTag(TAG_DIV,[ATTR_STYLE,"position:relative;"]);
    html += HU.div([ATTR_ID, this.getDomId(ID_MENU_CONTAINER)]);
    html +=  this.getEntriesMenu(argProperties);

    if(this.getShowMenu()) {
        html += HU.tag(TAG_A, [ATTR_CLASS, "display-menu-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)], SPACE);
    }
    let targetDiv = this.getProperty("target",this.getProperty("targetDiv"));
    let _this = this;
    if (targetDiv != null) {
	targetDiv = targetDiv.replace("${entryid}",this.getProperty("entryId"));
    }

    if (targetDiv != null) {
        $(document).ready(function() {
	    if(jqid(targetDiv).length==0) {
		console.log("Error: display group could not find targetDiv:" + targetDiv);
	    } else {
		$("#" + targetDiv).html(displaysHtml);
		_this.getLayoutManager().doLayout();
	    }
	});
    } else {
        html += displaysHtml;
    }
    html += HU.closeTag(TAG_DIV);
    let divid = this.getProperty("divId",this.getId());
    $("#" + divid).html(html)
    this.initializeEntriesMenu();

    this.jq(ID_MENU_BUTTON).html(HU.getIconImage("fas fa-cog",[TITLE,"Display menu"],[ATTR_STYLE,'color:#aaa;'] )).button({
	classes: {
	    "ui-button": "display-manager-button",
	}	
    }).click(function(event) {
	if(this.dialog) {
	    this.dialog.remove();
	}
        let html = _this.makeMainMenu();
	this.dialog = HU.makeDialog({content:html,title:"Displays",my:"left top",at:"left bottom",anchor:_this.jq(ID_MENU_BUTTON)});
        _this.jq(ID_MENU_INNER).superfish({
            //Don't set animation - it is broke on safari
            //                    animation: {height:'show'},
            speed: 'fast',
            delay: 300
        });


    });

}


function RamaddaMultiDisplay(displayManager, id, properties) {
    this.props = properties;
    let SUPER = new DisplayGroup(displayManager, id, properties, DISPLAY_MULTI);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        inInitDisplay: false,
        haveInited: false,
        needsData: function() {
            return true;
        },
        pointDataLoaded: function(pointData, url, reload) {
            SUPER.pointDataLoaded.call(this, pointData, url, reload);
            this.initDisplay();
        },
        processMacros: function(selectedFields, value, makeList) {
            if ((typeof value) != "string") return null;
            var toks = [];
            if (value.includes("${fieldLabel}")) {
                for (i = 0; i < selectedFields.length; i++) {
                    var v = value.replace("\${fieldLabel}", selectedFields[i].getLabel());
                    toks.push(v);
                }
            } else if (value.includes("${fieldId}")) {
                for (i = 0; i < selectedFields.length; i++) { 
                   var v = value.replace("\${fieldId}", selectedFields[i].getId());
                    toks.push(v);
                }
            } else if (value.includes("${fieldCnt}")) {
                var v = value.replace("\${fieldCnt}", selectedFields.length);
                toks.push(v);
            } else if (value.includes("${")) {

            } else {
                return null;
            }
            if (makeList) return toks;
            return Utils.join(toks, ",");
        },
        initDisplay: function() {
            try {
                this.initDisplayInner();
            } catch (e) {
                this.setContents(this.getMessage("An error occurred:" + e));
                console.log("An error occurred:" + e);
                console.log(e.stack);
            }
        },
        useChartableFields: function() {
            return false;
        },
        initDisplayInner: function() {
            SUPER.initDisplay.call(this);
            let records = this.filterData();
            if (!records) {
                this.setDisplayMessage(this.getLoadingMessage());
                return null;
            }

            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0) {
                this.setContents(this.getMessage("no fields"));
                return;
            }

            if (this.inInitDisplay) return;
            if (this.haveInited) return;
            this.haveInited = true;
            this.inInitDisplay = true;

            var props = {};
            var foreachMap = {};
            var foreachList = [];
            var cnt = 0;
            for (a in this.props) {
                if (a.startsWith("foreach_")) {
                    var value = this.props[a];
                    var toks;
                    var tmp = this.processMacros(fields, value, true);
                    if (tmp) {
                        toks = tmp;
                    } else {
                        toks = value.split(",");
                    }
                    a = a.substring(8);
                    if (toks.length > cnt) cnt = toks.length;
                    foreachMap[a] = toks;
                    foreachList.push({
                        attr: a,
                        toks: toks
                    });
                }
                if (a.startsWith("sub_")) {
                    var value = this.props[a];
                    a = a.substring(4);
                    var tmp = this.processMacros(fields, value, false);
                    if (tmp) {
                        value = tmp;
                    }
                    props[a] = value;
                }
            }
            var html = HU.div([ATTR_ID, this.getDomId(ID_DISPLAYS), ATTR_CLASS, "display-container"]);
            this.setContents(html);
            var groupProps = {
                target: this.getDomId(ID_DISPLAYS),
            }
            groupProps[PROP_LAYOUT_TYPE] = 'table';
            groupProps[PROP_LAYOUT_COLUMNS] = this.getProperty(PROP_LAYOUT_COLUMNS, "2");
            this.displayManager = new DisplayManager(this.getId() + "_manager", groupProps);


            props.layoutHere = false;
            if (this.props['data'])
                props['data'] = this.props['data'];
            var subType = this.getProperty("subType", "table");
            if (cnt == 0) cnt = 1;
            for (var i = 0; i < cnt; i++) {
                var dprops = {};
                $.extend(dprops, props);
                for (var j = 0; j < foreachList.length; j++) {
                    if (i < foreachList[j].toks.length) {
                        dprops[foreachList[j].attr] = foreachList[j].toks[i];
                    }
                }
                if (dprops['fields']) dprops['fields'] = dprops['fields'].split(",");
                this.displayManager.createDisplay(subType, dprops);
            }
            this.inInitDisplay = false;
        }
    });
}

/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


if (window.pointDataCache == null) {
    window.pointDataCache= {};
    //kick off a monitoring thread
    let monitor = ()=>{
	for(key in window.pointDataCache) {
	    let obj = window.pointDataCache[key];
	    let anyActive = false;
	    obj.displays.forEach(display=>{
		if(!display.isActiveDisplay || display.isActiveDisplay()) {
		    anyActive = true;
		}
	    });
	    if(!anyActive) {
		delete window.pointDataCache[key];
	    }
	}
	setTimeout(monitor,5000);
    };
    setTimeout(monitor,30000);    
}

function getPointDataCache() {
    return window.pointDataCache;
}

function getPointDataCacheObject(url){
    return  getPointDataCache()[url];
}


function DataCollection() {
    RamaddaUtil.defineMembers(this, {
        data: [],
        hasData: function() {
            for (var i = 0; i < this.data.length; i++) {
		if(this.data[i])
                    if (this.data[i].hasData()) return true;
            }
            return false;
        },
        getList: function() {
            return this.data;
        },
	setData: function(data) {
	    this.data = [data];
	},
        addData: function(data) {
            this.data.push(data);
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
            let anyHandled = false;
            for (let i = 0; i < this.data.length; i++) {
                if (this.data[i].handleEventMapClick(myDisplay, source, lon, lat)) {
                    anyHandled = true;
                }
            }
            return anyHandled;

        },


    });

}

function BasePointData(name, properties) {
    if (properties == null) properties = {};
    RamaddaUtil.defineMembers(this, {
        records: null,
        entryId: null,
        entry: null
    });

    $.extend(this, properties);

    RamaddaUtil.defineMembers(this, {
        name: name,
        properties: properties,
        initWith: function(thatPointData) {
            this.recordFields = thatPointData.recordFields;
            this.records = thatPointData.records;
            this.setGroupField();
	    return this;
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
            return false;
        },
        hasData: function() {
            return this.records != null && this.records.length>0 && this.recordFields!=null;
        },
        clear: function() {
            this.records = null;
            this.recordFields = null;
        },
        getProperties: function() {
            return this.properties;
        },
        getProperty: function(key, dflt) {
            let value = this.properties[key];
            if (value == null) return dflt;
            return value;
        },

        getRecordFields: function() {
            return this.recordFields;
        },
        addRecordField: function(field) {
            this.recordFields.push(field);
        },
        getRecords: function() {
            return this.records;
        },
        getNumericFields: function() {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (field.isNumeric()) numericFields.push(field);
            }
            return numericFields;
        },
        getChartableFields: function(display) {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            var skip = /(TIME|HOUR|MINUTE|SECOND|YEAR|MONTH|DAY|LATITUDE|LONGITUDE|^ELEVATION$)/g;
            var skip = /(xxxnoskip)/g;
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (!field.isNumeric() || !field.isChartable()) {
                    continue;
                }
                var ID = field.getId().toUpperCase();
                if (ID.match(skip)) {
                    continue;
                }
                numericFields.push(field);
            }

            return RecordUtil.sort(numericFields);
        },
        getNonGeoFields: function(display) {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            //                var skip = /(TIME|HOUR|MINUTE|SECOND|YEAR|MONTH|DAY|LATITUDE|LONGITUDE|ELEVATION)/g;
            var hadDate = false;
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (field.isFieldGeo()) {
                    continue;
                }
		//		console.log("F:" + field.getId());
                if (field.isFieldDate()) {
                    if (hadDate && field.getId() == "recordDate") {
                        continue;
                    }
                    hadDate = true;
                }

                //                    var ID = field.getId().toUpperCase() ;
                //                    if(ID.match(skip)) {
                //                        continue;
                //                    }
                numericFields.push(field);
            }
            return numericFields;
            //                return RecordUtil.sort(numericFields);
        },

        loadData: function(display) {},
        getName: function() {
            return this.name;
        },
        getTitle: function() {
            if (this.records != null && this.records.length > 0)
                return this.name + " - " + this.records.length + " points";
            return this.name;
        }
    });
}





function convertToPointData(array) {
    var fields = [];
    var records = [];
    var header = array[0];
    var samples = array[1];
    for(var i=0;i<header.length;i++) {
        let label = String(header[i]);
	let id = label.toLowerCase().replace(/[ ., ]+/g,"_");
        let sample =samples[i];
        let tof= typeof sample;
        let type;
        if(tof=="string")
            type = "string";
        else if(tof=="number")
            type = "double";
        else if(sample.getTime)
            type = "date";
        else 
            console.log("Unknown type:" + tof);
        fields.push(new RecordField({
            id:id,
	    index:i,
            label:label,
            type:type,
            chartable:true
        }));
    }
    for(var i=1;i<array.length;i++) {
        records.push(new  PointRecord(fields,NaN, NaN, NaN, null, array[i]));
    }
    return new  PointData("pointdata", fields, records,null,null);
}


/*
  This encapsulates some instance of point data. 
  name - the name of this data
  recordFields - array of RecordField objects that define the metadata
  data - array of Record objects holding the data
*/
function PointData(name, recordFields, records, url, properties) {
    RamaddaUtil.inherit(this, new BasePointData(name, properties));
    this.parentPointData = properties?properties.parent:null;

    RamaddaUtil.defineMembers(this, {
        recordFields: recordFields,
        records: records,
        url: url,
	baseUrl:url,
        loadingCnt: 0,
	getRootPointData: function() {
	    if(this.parentPointData)
		return this.parentPointData.getRootPointData();
	    return this;
	},
        getUrl: function() {
	    if(this.url) return this.url;
	    if(this.parentPointData) return this.parentPointData.getUrl();
	    return null;
	},
        getCacheUrl: function() {
	    let debug = displayDebug.loadPointJson;
	    if(!this.cacheUrl && this.display) {
		this.cacheUrl = this.display.cacheUrl;
		if(debug) {
		    console.log("getCacheUrl from display: "+ this.display.type +" " + this.cacheUrl);
		} 
	    }

	    if(!this.cacheUrl) {
		if(this.baseUrl) {
		    this.cacheUrl = this.baseUrl;
		} else  if(this.parentPointData) {
		    this.cacheUrl  =this.parentPointData.getCacheUrl();
		}
		if(this.cacheUrl) {
		    if(this.display && this.display.displayManager) {
			//Don't do this. we really want (?) to keep the cacheUrl fixed so when the data json is change
			//it is still applied to the original set of displays that share the original cache id
			//			let props = {lat: this.lat,lon: this.lon};
			//			this.cacheUrl = this.display.displayManager.getJsonUrl(this.cacheUrl, this.display, props);
		    }
		    if(this.display) {
			this.display.cacheUrl = this.cacheUrl;
		    }
		}
	    }
	    return this.cacheUrl;
	},	
        equals: function(that) {
	    if(this.jsonUrl) {
		return this.jsonUrl == that.jsonUrl;
	    }
            return this.url == that.url;
        },
        getIsLoading: function() {
            return this.loadingCnt > 0;
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
	    let url = this.getUrl();
            let cacheObject = getPointDataCacheObject(url);
            this.lon = lon;
            this.lat = lat;
	    ///repository/grid/json?entryid=3715ca8e-3c42-4105-96b1-da63e3813b3a&location.latitude=0&location.longitude=179.5
	    //	    initiallatitude=40&location.latitude=0&location.longitude=179.5
            if (myDisplay.getDisplayManager().hasGeoMacro(url)) {
		this.loadData(myDisplay, true);
                return true;
            }
            return false;
        },
        startLoading: function() {
            this.loadingCnt++;
        },
        stopLoading: function() {
            this.loadingCnt--;
        },
        setGroupField: function() {
            if(this.recordFields) {
                for(var i=0;i<this.recordFields.length;i++) {
                    var field = this.recordFields[i];
                    if(field.isFieldGroup()) {
                        this.groupField = field;
                        break;
                    }
                }
            }
        },
        extractGroup: function(group, records) {
            if(!this.groupField) return records;
            var groupData = this.getDataGroups(records);
            if(groupData.length==0) return records;
            if(!group) group = groupData[0];
            return records;
        },
        getDataGroups: function(records) {
            if(!this.groupData) {
                if(!records) return [];
                this.groupData= [];
                var groupField = this.getGroupField();
                if(!groupField) return this.groupData;
                var seen = {};
                for(var i=0;i<records.length;i++) {
                    var record = records[i];
                    var data;
                    if(record.tuple) 
                        data = record.tuple;
                    else if(record.record)
                        data = record.record.getData();
                    console.log("data:" + data);
                    var value = groupField.getValue(record);
                    if(!seen[value]) {
                        seen[value] = true;
                        this.groupData.push(value);
                    }
                }
            }
            console.log(this.groupData);
            return this.groupData;
        },
        getGroupField: function() {
            return this.groupField;
        },
        isGroup: function() {
            return this.getGroupField()!=null;
        },
        loadData: function(display, reload,callback) {
	    let root = this.getRootPointData();
            if (root.url == null) {
                console.log("No URL");
                return;
            }
	    jsonUrl = root.url;
	    this.display = display;
	    if(display && display.displayManager) {
		let props = {
                    lat: this.lat,
                    lon: this.lon,
		};
		jsonUrl = display.displayManager.getJsonUrl(root.url, display, props);
	    }
	    root.jsonUrl = jsonUrl;
            root.loadPointJson(jsonUrl, display, reload,callback);
        },
	getCacheObject: function() {
            let cacheObject = getPointDataCacheObject(this.getUrl());
	    if(!cacheObject) {
		let cacheUrl = this.getCacheUrl();
		if(cacheUrl) cacheObject = getPointDataCacheObject(cacheUrl);
	    }
	    return cacheObject;
	},

	removeFromCache:function(object) {
            let cacheObject = this.getCacheObject();
            if(cacheObject) {
		cacheObject.removeDisplay(object);
	    }
	},


	propagateEventDataChanged:function(source) {
            let cacheObject = this.getCacheObject();
            if(cacheObject) {
		let displays = cacheObject.displays;
		if(displays) {
		    displays.forEach(display=>{
			if(display==source) return;
			display.pointDataLoaded(this, this.url, true);
		    });
                }
	    }
	},

        loadPointJson: function(url, display, reload,callback) {
	    let debug =  displayDebug.loadPointJson;
	    let debug2 = false;
//	    debug = debug2 = true;
            let pointData = this;
            this.startLoading();
            let _this = this;
	    if(debug) {
		console.log("loadPointJson: "+ display.type +" " + display.getId() +" url:" + url);
	    } 
	    let cacheId = this.getCacheUrl();
	    if(display.getProperty && !display.getProperty("pointDataCacheOK",true)) {
		cacheId = HtmlUtils.getUniqueId();
	    }

            let cacheObject = getPointDataCacheObject(cacheId);
            if (cacheObject == null) {
                cacheObject = new PointDataCacheObject(url);
		if(debug)
                    console.log("\t**** created cache object: " +cacheId);
                getPointDataCache()[cacheId] = cacheObject;
            } else {
		if(cacheObject.pending.indexOf(display)>=0) {
		    if(debug)
			console.log("\tcache hit - display in pending list");
		    return;
		} else {
		    if(debug)
			console.log("\tcache hit - display not in pending list");
		}
	    }		
	    if(cacheObject.displays.indexOf(display)<0) {
		if(debug2)
		    console.log("adding to displays-1:" + display);
		cacheObject.displays.push(display);
	    }
	    //If we are reloading then clear the data
	    //Don't do this for now
	    if(reload) {
		//If its a reload then add all dependent displays to the pending listd
		cacheObject.pointData = null;
		cacheObject.pending = [];
		if(debug)
		    console.log("\treloading adding to pending:" + cacheObject.displays);
		cacheObject.displays.forEach(d=>{
		    if(debug)
			console.log("\tdisplay:" + d.type +" " + d.getId());
		    cacheObject.pending.push(d);
		});
	    } else {
		if(cacheObject.displays.indexOf(display)<0) {
		    if(debug2)
			console.log("adding to displays-2:" + display);
		    cacheObject.displays.push(display);
		}
		if (cacheObject.pointData != null) {
		    if(debug)
			console.log("\tdata was in cache:" +cacheObject.pointData.getRecords().length+" url:" + url);
		    if(callback)
			callback(cacheObject.pointData);
                    else
			display.pointDataLoaded(cacheObject.pointData, url, reload);
                    return;
		}
		cacheObject.pending.push(display);
		if (cacheObject.pending.length > 1) {
		    if(debug)
			console.log("\tWaiting on callback:" + cacheObject.pending.length +" " + url +" d:" + display);
                    return;
		}
	    }
            let fail = function(jqxhr, textStatus, error) {
                let err = textStatus;
		if(err) {
		    if(error)
			err += ": " + error;
		} else {
		    err = error;
		}

		//Check if the response is json
		if(jqxhr.responseText) {
		    try {
			let tmp = JSON.parse(jqxhr.responseText);
			if(tmp.error) err = tmp.error;
		    } catch(ignore) {
			//The response might be malformed JSON so check for the error line
			//"error":"..."}
			let match = jqxhr.responseText.match(/"error":"([^"]+)"/);
			if(match) {
			    err = match[1];
			}
		    }
		}
		console.log("Point data load error:" + url+" " + (err?err:""));
		cacheObject.pending.map(display=>{
                    display.pointDataLoadFailed(err);
		});
		cacheObject.pending=[];
		delete getPointDataCache()[url];
                pointData.stopLoading();
            }

            let success=function(data) {
		if(typeof data == "string") {
		    try {
			if(debug) console.log("parsing point data");
			data = JSON.parse(data);
		    } catch(exc) {
			console.log("Error:" + exc);
			if(data.length>1000) data = data.substring(0,999);
			console.log("data:" + data);
			display.displayError("Error loading data:" + exc+"<br>URL:"+ url);
			return;
		    }
		}
		if(debug) console.log("pointDataLoaded");
                if (GuiUtils.isJsonError(data)) {
		    if(debug)
			console.log("\tloadPointData failed");
		    console.log("loadPointData failed:" + url);
                    display.pointDataLoadFailed(data);
                    return;
                }
		if(data.errorcode == "nodata" || !data.fields) {
		    if(debug)
			console.log("\tno data:" + url);
		    let dummy = new PointData("", [],[]);
                    let pending = cacheObject.pending;
                    cacheObject.pending = [];
		    pending.forEach(d=>{
			d.handleNoData(dummy);
		    });
		    return;
		}
//		if(debug)  console.log("\tmaking point data");
		let t1 = new Date();
                let newData = makePointData(data, _this.derived, display,_this.url,callback);
		let t2 = new Date();
		if(debug)   Utils.displayTimes("makePointData #records: " + newData.getRecords().length,[t1,t2],true);
                let pointData = cacheObject.pointData = newData;
		if(data.properties) {
		    display.applyRequestProperties(data.properties);
		}
                let tmpPending = cacheObject.pending;
		if(debug) {
		    console.log("\tcalling pointDataLoaded on  " + tmpPending.length + " pending displays");
		}
                cacheObject.clearPending();

		if(callback) callback(pointData);
		else {
                    for (let i = 0; i < tmpPending.length; i++) {
			if(debug)
			    console.log("\t\t" + tmpPending[i] +" #:" + pointData.getRecords().length);
			tmpPending[i].pointDataLoaded(pointData, url, reload);
		    }
                }

		if(cacheObject.pointData.records && cacheObject.pointData.records.length) {
		    cacheObject.setSize(cacheObject.pointData.records.length*cacheObject.pointData.records[0].getData().length);
		}

		let size = 0;
		let cnt = 0;
		Object.keys(getPointDataCache()).map(key=>{
		    size+=getPointDataCache()[key].getSize();
		    cnt++;
		});
		if(debug) console.log("\tcache size:" + size +" #objects:" + cnt);
		//Size is just the number of rows*columns
		if(size>1000000) {
		    if(debug)
			console.log('\tclearing cache');
		    Object.keys(getPointDataCache()).map(key=>{
			let cacheObject = getPointDataCacheObject(key);
			if(cacheObject.pending.length==0) {
			    if(debug)console.log("\tdeleting from cache:" + key);
			    cacheObject.clearData();
			}
		    });
		}
                pointData.stopLoading();
	    }
	    let fullUrl = url;
	    if(!fullUrl.startsWith("http")) {
		let base = window.location.protocol + "//" + window.location.host;
		fullUrl = base+fullUrl;
	    }

	    //Handle the snapshot relative file
	    if(!url.startsWith("/") && !url.startsWith("http")) {
		let root = String(window.location).replace(/\/[^\/]+$/,"");
		url = root + "/" + url;
	    }
	    display.handleLog("data:" + url);
	    $.getJSON(url,success).fail(fail);
	    //$.getJSON(url, success,{crossDomain:true}).fail(fail);
        }

    });
    this.setGroupField();
}


function PointDataCacheObject(url) {
    $.extend(this, {
        pointData: null,
        pending: [],
	displays:[],
	size:0,
	url:url,
	toString:function() {
	    return "cache:" + (this.pointData==null?" no data ":" data:" +this.pointData.pdcnt +" " + this.pointData.getRecords().length) +" url:" + this.url;
	}
    });
}

PointDataCacheObject.prototype = {
    getSize:function() {
	return this.size;
    },
    setSize:function(size) {
	this.size =size;
    },
    removeDisplay:function(display) {
	Utils.removeItem(this.displays,display);
    },
    clearPending:function() {
        this.pending = [];
    },

    clearData:function() {
	this.setSize(0);
	this.pointData = null;
    }

}


function DerivedPointData(displayManager, name, pointDataList, operation) {
    RamaddaUtil.inherit(this, new BasePointData(name));
    RamaddaUtil.defineMembers(this, {
        displayManager: displayManager,
        operation: operation,
        pointDataList: pointDataList,
        loadDataCalls: 0,
        display: null,
        pointDataLoaded: function(pointData) {
            this.loadDataCalls--;
            if (this.loadDataCalls <= 0) {
                this.initData();
            }
        },
        equals: function(that) {
            if (that.pointDataList == null) return false;
            if (this.pointDataList.length != that.pointDataList.length) return false;
            for (let i in this.pointDataList) {
                if (!this.pointDataList[i].equals(that.pointDataList[i])) {
                    return false;
                }
            }
            return true;
        },
        initData: function() {
            let pointData1 = this.pointDataList[0];
            if (this.pointDataList.length == 1) {
                this.records = pointData1.getRecords();
                this.recordFields = pointData1.getRecordFields();
		console.log("initData:" + this.recordFields.length);
            } else if (this.pointDataList.length > 1) {
                let results = this.combineData(pointData1, this.pointDataList[1]);
                this.records = results.records;
                this.recordFields = results.recordFields;
		console.log("initData 2:" + this.recordFields.length);
            }
            this.setGroupField();
            this.display.pointDataLoaded(this);
        },

        combineData: function(pointData1, pointData2) {
            let records1 = pointData1.getRecords();
            let records2 = pointData2.getRecords();
            let newRecords = [];
            let newRecordFields;

            //TODO:  we really need visad here to sample

            if (records1.length != records2.length) {
                console.log("bad records:" + records1.length + " " + records2.length);
            }

            if (this.operation == "average") {
                for (let recordIdx = 0; recordIdx < records1.length; recordIdx++) {
                    let record1 = records1[recordIdx];
                    let record2 = records2[recordIdx];
                    if (record1.getDate() != record2.getDate()) {
                        console.log("Bad record date:" + record1.getDate() + " " + record2.getDate());
                        break;
                    }
                    let newRecord = $.extend(true, {}, record1);
                    let data1 = newRecord.getData();
                    let data2 = record2.getData();
                    for (let colIdx = 0; colIdx < data1.length; colIdx++) {
                        data1[colIdx] = (data1[colIdx] + data2[colIdx]) / 2;
                    }
                    newRecords.push(newRecord);
                }
                newRecordFields = pointData1.getRecordFields();
            } else if (this.operation == "other func") {}
            if (newRecordFields == null) {
                //for now just use the first operand
                newRecords = records1;
                newRecordFields = pointData1.getRecordFields();
            }
            return {
                records: newRecords,
                recordFields: newRecordFields
            };
        },
        loadData: function(display) {
            this.display = display;
            this.loadDataCalls = 0;
            for (let i in this.pointDataList) {
                let pointData = this.pointDataList[i];
                if (!pointData.hasData()) {
                    this.loadDataCalls++;
                    pointData.loadData(this);
                }
                if (this.loadDataCalls == 0) {
                    this.initData();
                }
            }
            //TODO: notify display
        }
    });
}





/*
  This class defines the metadata for a record column. 
  index - the index i the data array
  id - string id
  label - string label to show to user
  type - for now not used but once we have string or other column types we'll need it
  missing - the missing value forthis field. Probably not needed and isn't used
  as I think RAMADDA passes in NaN
  unit - the unit of the value
*/
function RecordField(props, source) {
    $.extend(this, {
        isDate: props.type == "date",
        isLatitude: false,
        isLongitude: false,
        isElevation: false,
	forDisplay:true
    });
    if(props.id) {
	//A hack. maybe use Utils.makeID?
	props.id = props.id.replace(/%/g,'');
    }
    $.extend(this, props);

    $.extend(this, {
        isGroup:props.group,
        properties: props
    });


    //check for extended attributes
    if(source && source.getProperty) {
	["type","label","unit"].forEach(t=>{
	    let ext = source.getProperty(props.id+"." + t);
	    if(ext) this[t] = ext;
	});
    }
    RamaddaUtil.defineMembers(this, {
	clone: function() {
	    let newField = {};
	    $.extend(newField,this);
	    return newField;
	},
	toString: function() {
	    return this.getId() +" type:" + this.getType() +" index:" + this.index;
	},
	getDescription: function() {
	    return this.description;
	},
	getForDisplay: function() {
	    return this.forDisplay;
	},
        getIndex: function() {
            return this.index;
        },
        getValue: function(record,dflt) {
	    let v;
	    if(record.getValue)
		v= record.getValue(this.index);
	    else
		v = record[this.index];
	    if(!v && !Utils.isDefined(v)) return dflt;
	    return v;
        },
	getGroup: function() {
	    return this.group;
	},
        getEnumeratedValues: function(row) {
	    return this.enumeratedValues;
	},
        isFieldGroup: function() {
            return this.isGroup;
        },
	isRecordDate: function() {
	    return this.getId()=="recordDate";
	},
        isFieldGeo: function() {
            return this.isFieldLatitude() || this.isFieldLongitude() || this.isFieldElevation();
        },
        isFieldLatitude: function() {
            return this.isLatitude || this.id.toLowerCase() == "latitude";
        },
        isFieldLongitude: function() {
            return this.isLongitude || this.id.toLowerCase() == "longitude";
        },
        isFieldElevation: function() {
            return this.isElevation || this.id.toLowerCase() == "elevation" || this.id.toLowerCase() == "altitude";
        },
        isFieldNumeric: function() {
            return this.isNumeric();
        },
        isFieldString: function() {
            return this.type == "string" || this.type == "enumeration" || this.type == "multienumeration";
        },
        isFieldAbsoluteString: function() {
            return this.type == "string";
        },
        isFieldBoolean: function() {
            return this.type == "boolean";
	},
        isFieldEnumeration: function() {
            return this.type == "enumeration" || this.type == "multienumeration";
        },
        isFieldMultiEnumeration: function() {
            return  this.type == "multienumeration";
        },	
        isFieldDate: function() {
            return this.isDate;
        },
        isChartable: function() {
            return this.chartable;
        },
        getSortOrder: function() {
            return this.sortorder;
        },
        getId: function() {
            return this.id;
        },
        getTypeLabel: function() {
            let type = "fa-font";
            if(this.isFieldGeo()) {
                type="fa-globe";
            } else if(this.isFieldNumeric()) {
                type="fa-hashtag";
            } else if(this.isFieldEnumeration()) {
                type="fa-list";
            }
            let tt = this.getType();
            return  HtmlUtils.span([ATTR_TITLE,tt,ATTR_CLASS,"fa " +type,ATTR_STYLE,"color:rgb(169, 169, 169);font-size:12pt;"]);
        },
        getUnitLabel: function() {
            return this.getLabel() + this.getUnitSuffix();
        },
        getUnitSuffix: function(plain) {
            if (this.unit && this.unit != "") {
		if(plain) return "[" + this.unit + "]";
                return "&nbsp;[" + this.unit + "]";
	    } 
            return "";
        },

        getLabel: function(display,addUnit) {
	    let label;
	    if(display) {
		label = display.getProperty(this.getId() +".label");
	    }

	    if(!label) {
		label = this.label;
	    }
	    if(!label) {
		if (this.label == null || this.label.length == 0) label = this.id;
	    }
	    if(addUnit && Utils.stringDefined(this.getUnit())) {
		label = label +' [' + this.getUnit() +']';
	    }
	    return label;

        },
        setLabel: function(l) {
            this.label = l;
        },
	canEdit: function() {
	    return this.canedit==true;
	},
        isBoolean: function() {
	    return this.type == "boolean";
	},

        isNumeric: function() {
	    return this.type == "double" || this.type == "integer";
	},
	isString: function() {
	    return this.type == "string" || this.isFieldEnumeration() || this.type =="url" || this.type == "image";
	},
        getType: function() {
            return this.type;
        },
        setType: function(t) {
            this.type = t;
        },	
        getMissing: function() {
            return this.missing;
        },
        setUnit: function(u) {
            this.unit = u;
        },
        getUnit: function() {
            return this.unit;
        }
    });

}



/*
  The main data record. This holds a lat/lon/elevation, time and an array of data
  The data array corresponds to the RecordField fields
*/
function PointRecord(fields,lat, lon, elevation, time, data, rowIdx,dateHasDate) {
    this.isPointRecord = true;
    $.extend(this, {
	rowIndex:rowIdx,
	fields:fields,
        latitude: lat,
        longitude: lon,
        elevation: elevation,
        recordTime: time,
        data: data,
	id: HtmlUtils.getUniqueId(),
    });
    if(!time && data && !dateHasDate) {
	data.every(d=>{
	    if(d && d.getTime) {
		this.recordTime = d;
		return false;
	    }
	    return true;
	});
    }
}


PointRecord.prototype =  {
    clone: function() {
	let newRecord = {};
	$.extend(newRecord,this);
	newRecord.data = [];
	this.data.map((v,idx)=>{newRecord.data[idx] = v;});
	return newRecord;
    },
    getRowIndex: function() {
	return this.rowIndex;
    },
    isHighlight: function(display) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	return this.highlightForDisplay[display];
    },
    getDisplayProperty: function(display,prop,dflt) {
	if(!this.displayProperties) this.displayProperties={};
	let props = this.displayProperties[display];
	if(!props) {
	    props = this.displayProperties[display] = {};
	}
	return props[prop] || dflt;
    },
    setDisplayProperty: function(display,prop,value) {
	if(!this.displayProperties) this.displayProperties={};
	let props = this.displayProperties[display];
	if(!props) {
	    props = this.displayProperties[display] = {};
	}
	props[prop] =value;
    },
    setHighlight:function(display, value) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	if(!value || this.highlightForDisplay[display] == null) {
	    this.highlightForDisplay[display] = value;
	}
    },
    clearHighlight:function(display) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	delete this.highlightForDisplay[display];
    },
    toString: function() {
	return "data:"  + this.data;
    },
    getId: function() {
	return this.id;
    },
    equals: function(that) {
	return this.id == that.id;
    },
    getData: function() {
        return this.data;
    },
    setData: function(d) {
        this.data = d;
    },    
    getFields: function() {
	return this.fields;
    },
    getValueFromField:function(id) {
	let value = null;
	this.fields.every(field=>{
	    if(field.getId()==id) {
		value = this.getValue(field.getIndex());
		return false;
	    }
	    return true;
	});
	return value;
    },

    allZeros: function() {
        let tuple = this.getData();
        let allZeros = false;
        let nums = 0;
        let nonZero = 0;
        for (let j = 0; j < tuple.length; j++) {
            if (typeof tuple[j] == "number") {
                nums++;
                if (!isNaN(tuple[j]) && tuple[j] != 0) {
                    nonZero++;
                    break;
                }
            }
        }
        if (nums > 0 && nonZero == 0) {
            return true;
        }
        return false;
    },
    getValue: function(index) {
        return this.data[index];
    },
    setValue: function(index,value) {
        this.data[index] = value;
    },
    push: function(v) {
        this.data.push(v);
    },
    hasDate: function() {
	return this.getDate()!=null;
    },
    hasLocation: function() {
        return this.latitude !=null && !isNaN(this.latitude);
    },
    hasElevation: function() {
        return this.elevation !=null && !isNaN(this.elevation);
    },
    setLocation: function(lat,lon) {
	this.latitude=lat;
	this.longitude=lon;
    },
    getLatitude: function() {
        return this.latitude;
    },
    getLongitude: function() {
        return this.longitude;
    },
    getTime: function() {
        return this.recordTime;
    },
    setTime: function(time) {
        return this.recordTime=time;
    },    
    getElevation: function() {
        return this.elevation;
    },
    getDate: function() {
        return this.recordTime;
    }
};


function makePointData(json, derived, source,url,callback) {

    let debug  =false;
    if(debug) console.log("makePointData");
    let fields = [];
    let latitudeIdx = -1;
    let longitudeIdx = -1;
    let elevationIdx = -1;
    let dateIdx = -1;
    let dateIndexes = [];

    let offsetFields = [];
    let lastField = null;
    for (let i = 0; i < json.fields.length; i++) {
        let field = json.fields[i];
        let recordField = new RecordField(field,source);
        if (recordField.isFieldNumeric()) {
            if (source.getProperty) {
                let offset1 = source.getProperty(recordField.getId() + ".offset1", source.getOffset1());
                let offset2 = source.getProperty(recordField.getId() + ".offset2", source.getOffset2());
                let scale = source.getProperty(recordField.getId() + ".scale", source.getScale());

                if (offset1 || offset2 || scale) {
                    let unit = source.getProperty(recordField.getId() + ".unit", source.getUnit());
                    if (unit) {
                        recordField.unit = unit;
                    }
                    let o = {
                        offset1: 0,
                        offset2: 0,
                        scale: 1
                    };
                    if (offset1) o.offset1 = parseFloat(offset1);
                    if (offset2) o.offset2 = parseFloat(offset2);
                    if (scale) o.scale = parseFloat(scale);
                    recordField.offset = o;
                    offsetFields.push(recordField);
                }
            }
        }


        lastField = recordField;
        fields.push(recordField);
        //        console.log("field:" + recordField.getId());
        if (recordField.isFieldLatitude()) {
            latitudeIdx = recordField.getIndex();
        } else if (recordField.isFieldLongitude()) {
            longitudeIdx = recordField.getIndex();
            //            console.log("Longitude idx:" + longitudeIdx);
        } else if (recordField.isFieldElevation()) {
            elevationIdx = recordField.getIndex();
            //            console.log("Elevation idx:" + elevationIdx);
        } else if (recordField.isFieldDate()) {
	    if(dateIdx==-1) dateIdx = recordField.getIndex();
	    dateIndexes.push(recordField.getIndex());
        }

    }

    if (derived) {
        let index = lastField.getIndex() + 1;
        for (let dIdx = 0; dIdx < derived.length; dIdx++) {
            let d = derived[dIdx];
            let label = d.label || d.name;
            let recordField = new RecordField({
                type: "double",
                index: (index + dIdx),
                chartable: true,
                id: d.name,
                label: label,
            });
            recordField.derived = d;
            fields.push(recordField);
        }
    }

    let pointRecords = [];
    let isArray = false;
    let hasGeo = false;
    let hasDate = false;
    let setDateFlags = false;
    let dateIsString = false;
//    console.log('pointdata #:' +json.data.length);
    json.data.forEach((tuple,rowIndex)=>{
	//	if(rowIndex>100) return;
	if(debug && rowIndex>0 && (rowIndex%10000)==0) console.log("\tprocessed:" + i);
	if(rowIndex==0) {
	    isArray = Array.isArray(tuple);
	    hasDate = !(typeof tuple.date === 'undefined');
	}
	let values;
	if(isArray)
	    values = tuple;
	else
            values = tuple.values;
        //lat,lon,alt,time,data values
        let date = null;
        if (isArray || !hasDate) {
            if (dateIdx >= 0) {
		if(!setDateFlags) {
		    dateIsString = (typeof values[dateIdx] == "string");
		    setDateFlags = true;
		}
		if(dateIsString) {
		    date = Utils.parseDate(values[dateIdx]);
		} else {
		    date = new Date(0);
		    date.setUTCMilliseconds(values[dateIdx]);
		}
            }
        } else {
            if (tuple.date != null && tuple.date != 0) {
		date = new Date(0);
		date.setUTCMilliseconds(tuple.date);
            }
        }
        if (isArray || (typeof tuple.latitude === 'undefined')) {
            if (latitudeIdx >= 0) 
               tuple.latitude = values[latitudeIdx];
            else
                tuple.latitude = NaN;
        }
        if (isArray || (typeof tuple.longitude === 'undefined')) {
            if (longitudeIdx >= 0)
                tuple.longitude = values[longitudeIdx];
            else
                tuple.longitude = NaN;
        }
        for (let j = 0; j < dateIndexes.length; j++) {
	    let index = dateIndexes[j];
	    let value = values[index];
	    values[index] = Utils.parseDate(value);
        }
        for (let col = 0; col < values.length; col++) {
            if(values[col]==null) {
                values[col] = NaN;
            } 
        }

        if (derived) {
            for (let dIdx = 0; dIdx < derived.length; dIdx++) {
                let d = derived[dIdx];
                if (!d.isRow) {
                    continue;
                }
                if (!d.compiledFunction) {
                    let funcParams = [];
                    let params = (d.columns.indexOf(";") >= 0 ? d.columns.split(";") : d.columns.split(","));
                    d.fieldsToUse = [];
                    for (let i = 0; i < params.length; i++) {
                        let param = params[i].trim();
                        funcParams.push("v" + (i + 1));
                        let theField = null;
                        for (let fIdx = 0; fIdx < fields.length; fIdx++) {
                            let f = fields[fIdx];
                            if (f.getId() == param) {
                                theField = f;
                                break;
                            }
                        }
                        d.fieldsToUse.push(theField);

                    }
                    let code = "";
                    for (let i = 0; i < funcParams.length; i++) {
                        code += "var v" + (i + 1) + "=args[" + i + "];\n";
                    }
                    let tmpFunc = d["function"];
                    if (tmpFunc.indexOf("return") < 0) tmpFunc = "return " + tmpFunc;
                    code += tmpFunc + "\n";
                    d.compiledFunction = new Function("args", code);
                    //                    console.log("Func:" + d.compiledFunction);
		}
                //TODO: compile the function once and call it
                let args = [];
                let anyNotNan = false;
                for (let fIdx = 0; fIdx < d.fieldsToUse.length; fIdx++) {
                    let f = d.fieldsToUse[fIdx];
                    let v = NaN;
                    if (f != null) {
                        v = values[f.getIndex()];
                        if (v == null) v = NaN;
                    }
                    if (!isNaN(v)) {
                        anyNotNan = true;
                    } else {}
                    args.push(v);
                }
                //                console.log("anyNot:" + anyNotNan);
                //                console.log(args);
                try {
                    let result = NaN;
                    if (anyNotNan) {
                        result = d.compiledFunction(args);
                        if (d.decimals >= 0) {
                            result = result.toFixed(d.decimals);
                        }
                        result = parseFloat(result);
                    } else {
                        //                        console.log("NAN");
                    }
                    //                    console.log("in:" + result +" out: " + result);
                    values.push(result);
                } catch (e) {
                    console.log("Error evaluating function:" + d["function"] + "\n" + e);
                    values.push(NaN);
                }
            }
	}

        for (let fieldIdx = 0; fieldIdx < offsetFields.length; fieldIdx++) {
            let field = offsetFields[fieldIdx];
            let offset = field.offset;
            let value = values[field.getIndex()];
            value = (value + offset.offset1) * offset.scale + offset.offset2;
            values[field.getIndex()] = value;
        }
	
        let record = new PointRecord(fields, tuple.latitude, tuple.longitude, tuple.elevation, date, values,rowIndex,dateIdx>=0);
        pointRecords.push(record);

    });




    if (source != null) {
        for (let i = 0; i < fields.length; i++) {
            let field = fields[i];
            let prefix = "field." + field.getId() + ".";
            if (Utils.isDefined(source[prefix + "unit"])) {
                field.setUnit(source[prefix + "unit"]);
            }
            if (Utils.isDefined(source[prefix + "label"])) {
                field.setLabel(source[prefix + "label"]);
            }
            if (Utils.isDefined(source[prefix + "scale"]) || Utils.isDefined(source[prefix + "offset1"]) || Utils.isDefined(source[prefix + "offset2"])) {
                let offset1 = Utils.isDefined(source[prefix + "offset1"]) ? parseFloat(source[prefix + "offset1"]) : 0;
                let offset2 = Utils.isDefined(source[prefix + "offset2"]) ? parseFloat(source[prefix + "offset2"]) : 0;
                let scale = Utils.isDefined(source[prefix + "scale"]) ? parseFloat(source[prefix + "scale"]) : 1;
                let index = field.getIndex();
                for (let rowIdx = 0; rowIdx < pointRecords.length; rowIdx++) {
                    let record = pointRecords[rowIdx];
                    let values = record.getData();
                    let value = values[index];
                    values[index] = (value + offset1) * scale + offset2;
                }
            }

        }
    }

    let name = json.name;
    if ((typeof name === 'undefined')) {
        name = "Point Data";
    }

    /*
      don't do this for now
    pointRecords.sort(function(a, b) {
        if (a.getDate() && b.getDate()) {
            if (a.getDate().getTime() < b.getDate().getTime()) return -1;
            if (a.getDate().getTime() > b.getDate().getTime()) return 1;
            return 0;
        }
    });
    */


    let pd =  new PointData(name, fields, pointRecords,url);
    return pd;
}





var ArrayUtil = {
    add: function(v1, v2) {
        if (isNaN(v1) || isNaN(v2)) return NaN;
        return v1 + v2;
    },
    average: function(values) {
        var sum = 0;
        if (values.length == 0) return 0;
        for (var i = 0; i < values.length; i++) {
            sum += values[i];
        }
        return sum / values.length;
    },
    percentIncrease: function(values) {
        var percents = [];
        var sum = 0;
        if (values.length == 0) return 0;
        var lastValue;
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            var incr = NaN;
            if (i > 0 && lastValue != 0) {
                incr = (v - lastValue) / lastValue;
            }
            lastValue = v;
            percents.push(incr * 100);
        }
        return percents;
    },
    movingAverage: function(values, props) {
        if (!props) {
            props = {};
        }
        if (!props.step) props.step = 5;
	if(values.length==0) return values;
        var newValues = [];
        console.log("STEP:" + props.step);
	let tupleGetter = values[0].tuple?v=>{return v.tuple}:v=>{return  v};
	let isNumeric = tupleGetter(values[0]).map((v,idx)=>{return Utils.isNumber(v);});
	dataList.forEach((o,rowIdx)=>{
		    if(rowIdx==0) return;
		    let tuple = Utils.mergeLists(o.tuple);
		    tmp.push({
			record:o.record,
			tuple:tuple});
		    tuple[0] = "x"; tuple[1] = 5;
		    tuple.forEach((v,colIdx)=>{
			if(!isNumeric[colIdx]) return;
			tuple[colIdx]=5;
		    });
		});
		dataList = tmp;



        for (var i = props.step; i < values.length; i++) {
            var total = 0;
            var cnt = 0;
            for (var j = i - props.step; j < i; j++) {
                if (values[j] == values[j]) {
                    total += values[j];
                    cnt++;
                }
            }
            var value = (cnt > 0 ? total / cnt : NaN);
            if (newValues.length == 0) {
                for (var extraIdx = 0; extraIdx < props.step; extraIdx++) {
                    newValues.push(value);
                }
            }
            newValues.push(value);
        }

        console.log("MovingAverage: values:" + values.length + " new:" + newValues.length);
        return newValues;
    },
    expMovingAverage: function(values, props) {
        if (!props) {
            props = {};
        }
        if (!props.step) props.step = 5;
        var sma = ArrayUtil.movingAverage(values, props);
        var mult = (2.0 / (props.step + 1));
        var newValues = [];
        console.log("STEP:" + props.step);
        for (var i = props.step; i < values.length; i++) {
            var total = 0;
            var cnt = 0;
            for (var j = i - props.step; j < i; j++) {
                if (values[j] == values[j]) {
                    total += values[j];
                    cnt++;
                }
            }
            var value = (cnt > 0 ? total / cnt : NaN);
            if (newValues.length == 0) {
                for (var extraIdx = 0; extraIdx < props.step; extraIdx++) {
                    newValues.push(value);
                }
            }
            newValues.push(value);
        }

        console.log("MovingAverage: values:" + values.length + " new:" + newValues.length);
        return newValues;
    },

    max: function(values) {
        var max = NaN;
        for (var i = 0; i < values.length; i++) {
            if (i == 0 || values[i] > max) {
                max = values[i];
            }
        }
        return max;
    },
    min: function(values) {
        var min = NaN;
        for (var i = 0; i < values.length; i++) {
            if (i == 0 || values[i] < min) {
                min = values[i];
            }
        }
        return min;
    },

}

var RecordUtil = {
    groupBy:function(records, display, dateBin, field) {
	let debug = displayDebug.groupBy;
	if(debug) console.log("groupBy",'date bin:',dateBin,' #records:', records.length);

	let groups ={
	    max:0,
	    values:[],
	    labels:[],
	    map:{},
	}
	records.forEach((record,idx)=>{
	    let key;
	    let label = null;
	    let date = record.getDate();
	    //	    if(debug && idx>0 && (idx%10000)==0) console.log("\trecord:" + idx);
	    if(field) {
		if(field=="latlon") {
		    key = label = record.getLatitude() +"/" + record.getLongitude(); 
		} else {
		    key = label = record.getValue(field.getIndex());
		}
	    } else {
		if(!date) {
		    return;
		}
		key = date;
		if(dateBin===true) {
		    //do the label later
		} else {
		    if(dateBin=="day") {
			key = new Date(label=date.getFullYear()+"-" + date.getUTCMonth() +"-" +date.getUTCDay())
		    } else if(dateBin=="month") {
			label=date.getFullYear()+"-" + date.getUTCMonth();
			key = new Date(label +"-01");
		    } else if(dateBin=="year") {
			label = date.getFullYear();
			key = new Date(date.getFullYear()+"-01-01");
		    } else if(dateBin=="decade") {
			let year = date.getFullYear();
			year = year-year%10;
			label = year+"s";
			key = new Date(year+"-01-01");
		    } else if(dateBin) {
			label = String(key);
		    }
		}
	    }
	    let array = groups.map[key];
	    if(!array) {
		if(debug) console.log("\tadding group:"  + key);
		array = groups.map[key] = [];
		groups.values.push(key);
		if(label==null)
		    label = display.formatDate(date,null,true);
		groups.labels.push(label);
	    } else {
//		if(debug) console.log("\tadded:" + key);
	    }
	    array.push(record);

	    groups.max = Math.max(groups.max, array.length);
	});
	return groups;
    },
    expandBounds: function(bounds, perc) {
	return new RamaddaBounds(
	    Math.min(90,bounds.north +(bounds.north-bounds.south)*perc),
	    Math.max(-180, bounds.west -(bounds.east-bounds.west)*perc),
	    Math.max(-90,bounds.south -(bounds.north-bounds.south)*perc),
	    Math.min(180,bounds.east +(bounds.east-bounds.west)*perc)
	);
    },
    convertBounds: function(bounds) {
	if(!bounds) return null;
	return new RamaddaBounds(bounds);
    },
    subset:function(records,bounds) {
	bounds = RecordUtil.convertBounds(bounds);
	//	console.log("subset:" + JSON.stringify(bounds));
	let cnt = 0;
	records =  records.filter((record,idx)=>{
	    let lat = record.getLatitude?record.getLatitude():record.r?record.r.getLatitude():record.y;
	    let lon = record.getLongitude?record.getLongitude():record.r?record.r.getLongitude():record.x;
	    let ok =   lat<= bounds.north &&
		lat>= bounds.south &&
		lon>= bounds.west &&
		lon<= bounds.east;
	    return ok;
	});
	return records;
    },
    getRanges: function(fields, records) {
        var maxValues = [];
        var minValues = [];
        for (var i = 0; i < fields.length; i++) {
            maxValues.push(NaN);
            minValues.push(NaN);
        }

        for (var row = 0; row < records.length; row++) {
            for (var col = 0; col < fields.length; col++) {
                var value = records[row].getValue(col);
                if (isNaN(value)) continue;
                maxValues[col] = (isNaN(maxValues[col]) ? value : Math.max(value, maxValues[col]));
                minValues[col] = (isNaN(minValues[col]) ? value : Math.min(value, minValues[col]));
            }
        }

        var ranges = [];
        for (var col = 0; col < fields.length; col++) {
            ranges.push([minValues[col], maxValues[col]]);
        }
        return ranges;
    },



    getElevationRange: function(fields, records) {
        var maxValue = NaN;
        var minValue = NaN;

        for (var row = 0; row < records.length; row++) {
            if (records[row].hasElevation()) {
                var value = records[row].getElevation();
                maxValue = (isNaN(maxValue) ? value : Math.max(value, maxValue));
                minValue = (isNaN(minValue) ? value : Math.min(value, minValue));
            }
        }
        return [minValue, maxValue];
    },


    slice: function(records, index) {
        var values = [];
        for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
            var row = records[rowIdx];
            if (row.getValue) {
                values.push(row.getValue(index));
            } else {
                values.push(row[index]);
            }
        }
        return values;
    },


    sort: function(fields) {
        fields = fields.slice(0);
        fields.sort(function(a, b) {
            var s1 = a.getSortOrder();
            var s2 = b.getSortOrder();
            return s1 < s2;
        });
        return fields;
    },
    getPoints: function(records, bounds) {
	let points = [];
	this.getBounds(records, bounds,points);
	return points;
    },
    getBounds: function(records, bounds,points) {
	bounds = bounds||{};
        if (records == null) {
	    return bounds;
	}
        var north = NaN,
            west = NaN,
            south = NaN,
            east = NaN;
	let errorCnt = 0;
	let outsideDateLine = false;
        for (j = 0; j < records.length; j++) {
            var record = records[j];
            if (!isNaN(record.getLatitude()) && !isNaN(record.getLongitude())) {
		if(record.getLatitude()==0) {
//		    console.log(record.getLatitude(),record.getLongitude());
		}
		if(record.getLongitude()>-150 && record.getLongitude()<150) outsideDateLine = true;
		if (j == 0) {
                    north = record.getLatitude();
                    south = record.getLatitude();
                    west = record.getLongitude();
                    east = record.getLongitude();
                } else {
                    north = Utils.max(north, record.getLatitude());
                    south = Utils.min(south, record.getLatitude());
                    west = Utils.min(west, record.getLongitude());
                    east = Utils.max(east, record.getLongitude());
                }
                if (record.getLongitude() < -180 || record.getLatitude() > 90) {
		    //		    if(errorCnt++<50)
		    //			console.log("bad location: index=" + j + " " + record.getLatitude() + " " + record.getLongitude());
                }
		if(points)
                    points.push({x:record.getLongitude(), y:record.getLatitude()});
            }
        }
        bounds.north = north;
        bounds.west = west;
        bounds.south = south;
        bounds.east = east;
	let finalBounds =  new RamaddaBounds(bounds);
	if(!outsideDateLine && west<-170 && east>170) {
	    bounds.insideDateLine = true
	    finalBounds.insideDateLine = true
	}
	return finalBounds;
    },

    findClosest: function(records, lon, lat, indexObj) {
        if (records == null) return null;
        var closestRecord = null;
        var minDistance = 1000000000;
        var index = -1;
        for (j = 0; j < records.length; j++) {
            var record = records[j];
            if (isNaN(record.getLatitude())) {
                continue;
            }
            var distance = Math.sqrt((lon - record.getLongitude()) * (lon - record.getLongitude()) + (lat - record.getLatitude()) * (lat - record.getLatitude()));
            if (distance < minDistance) {
                minDistance = distance;
                closestRecord = record;
                index = j;
            }
        }
        if (indexObj != null) {
            indexObj.index = index;
        }
        return closestRecord;
    },
    clonePoints: function(points) {
        var result = [];
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            result.push({x:point.x, y:point.y});
        }
        return result;
    }
};


function CsvUtil() {
    let eg = "convertData=\"derived(field=field_id, function=population*10);\nrotateData(includeFields=true,includeDate=true,flipColumns=true);\naddPercentIncrease(replaceValues=false);\"\n";
    $.extend(this, {
	process: function(display, pointData, cmds) {
	    this.display = display;
	    let theCmd;
	    try {
		let commands = DataUtils.parseCommands(cmds);
		commands.map(cmd=>{
		    theCmd =cmd;
		    if(this[cmd.command]) {
			let orig = pointData;
    			pointData = this[cmd.command](pointData, cmd.args);
			if(!pointData) pointData=orig;
			else pointData.entryId = orig.entryId;
		    } else {
			console.log("unknown command:" + cmd.command);
		    }
		});
	    } catch(e) {
		console.log("Error applying derived function:" + theCmd.command);
		console.log(e);
		console.log(e.stack);
	    }
	    return pointData;
	},
	help: function(pointData, args) {
	    console.log(eg);
	    return null;
	},
	furlData: function(pointData, args) {
	    /** TODO
		let records = pointData.getRecords(); 
		let header = this.display.getDataValues(records[0]);
		var newRecords  =[];
		var newFields = [];
		var lastRecord = dataList[dataList.length-1];
		var fields  = pointData.getRecordFields();
		var newData  =[];
		newData.push(["label","value"]);
		//		dataList.map(r=>{
		fields.map((f,idx)=>{
		let row = [f.getLabel(),lastRecord.getValue(f.getIndex())];
		newData.push();
		});
		pointData = convertToPointData(newData);
		pointData.entryId = originalPointData.entryId;
	    **/
	},
	derived: function(pointData, args) {
	    let records = pointData.getRecords(); 
	    let fields =  pointData.getRecordFields();
	    let newFields =  fields.slice();
	    let newRecords  =[];
	    let fieldArgs = args['field'] ?? args['fields']?? ("field_" + fields.length);
	    let units = Utils.split(args['units'] ?? args['unit']?? '',',');
	    Utils.split(fieldArgs,',',true,true).forEach((id,idx)=>{
		newFields.push(new RecordField({
		    id:id,
		    index:newFields.length,
		    label:Utils.makeLabel(id),
		    type:"double",
		    chartable:true,
		    unit: units[idx]
		}));
	    });
	    let func = args["function"];
	    if(!func) {
		console.log("No func specified in derived");
		return null;
	    }
	    func = func.replace(/_nl_/g, "\n").replace(/_semi_/g,";");
	    if(func.indexOf("return")<0) {
		func = "return " + func;
	    }
            let setVars = "";
            fields.forEach((field,idx)=>{
		if(/*field.isFieldNumeric() && */field.getId()!="") {
		    if(func.indexOf(field.getId())<0) return;
		    let varName = field.getId().replace(/^([0-9]+)/g,"v$1");
		    setVars += "\tvar " + varName + "=displayGetFunctionValue(args.values[\"" + field.getId() + "\"]);\n";
		}
            });

//	    setVars+="console.log('v:' + (max_pool_elevation-lake_reservoir_elevation));\n";
            let code = "function displayDerivedEval(args) {\n" + setVars +  func + "\n}";
            eval(code);
	    let funcState = {};		
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.data= record.data.slice();
		newRecord.fields =  newFields;
		newRecords.push(newRecord);
		funcState.values={};
		funcState.recordIndex = rowIdx;
		funcState.record = record;
		fields.map((field,idx)=>{
		    if(field.getId()!="") {
			funcState.values[field.getId()] = record.getValue(field.getIndex());
		    }
		});
		try {
		    let values = displayDerivedEval(funcState);
		    if(!Array.isArray(values)) values=[values];
		    values.forEach((value)=>{
			newRecord.data.push(value);
		    });
		} catch(exc) {
		    console.log("Error processing derived:" + exc);
		    newRecord.data.push(NaN);
		    throw exc;
		}
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	groupTrend: function(pointData, args) {
	    let records = pointData.getRecords(); 
	    let fields =  pointData.getRecordFields();
	    let field = this.display.getFieldById(fields, args.field);
	    if(!field) {
		throw new Error('Could not find groupTrend field:' +args.field);
	    }
	    let newFields =  fields.slice();
	    let newRecords  =[];
	    let id = args.newField || ("field_" + fields.length);
	    let type=args.type??'int';
            newFields.push(new RecordField({
		id:id,
		index:fields.length,
		label:Utils.makeLabel(id),
		type:type,
		chartable:true,
		unit: args.unit
            }));
	    let index=0;
	    let lastValue=-99999999;
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		let value = field.getValue(record);
		if(value<lastValue) {
		    index++;
		}
		lastValue=value;
		newRecord.data= record.data.slice();
		newRecord.fields =  newFields;
		newRecords.push(newRecord);
		if(type=='enumeration')
		    newRecord.data.push(String(index));
		else
		    newRecord.data.push(index);
		
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	groupTime: function(pointData, args) {
	    let records = pointData.getRecords(); 
	    let fields =  pointData.getRecordFields();
	    let field = this.display.getFieldById(fields, args.field);
	    if(!field) {
		throw new Error('Could not find nominal time field:' +args.field);
	    }
	    let newFields =  fields.slice();
	    let newRecords  =[];
	    let index=0;
	    let lastValue=-99999999;
	    let lastTime;
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		let value = field.getValue(record);
		if(value!=lastValue) {
		    lastTime = record.getTime();
		    lastValue = value;
		}
		newRecord.setTime(lastTime);
		newRecords.push(newRecord);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


	rotateData: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
	    let rotated = [];
	    for(var colIdx=0;colIdx<header.length;colIdx++) {
		rotated.push([]);
	    }
	    let includeFields =args["includeFields"] == "true";
	    let includeDate = args["includeDate"] == "true";
	    let flipColumns =args["flipColumns"]=="true";
	    let fields = pointData.getRecordFields();
	    if (!flipColumns && includeFields) {
                fields.map((f,colIdx)=>{
		    if(f.isRecordDate()) return;
		    rotated[colIdx].push(colIdx==0?args["fieldName"]||"Field":f.getLabel());
		});
	    }
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.display.getDataValues(records[rowIdx]);
		for(var colIdx=0;colIdx<row.length;colIdx++) {
		    let field = fields[colIdx];
		    if(field.isRecordDate()) {
			continue;
		    }
		    var value = row[colIdx];
		    if(value.f) value = value.f;
		    if(value.getTime) {
			value = this.display.formatDate(value);
		    }
		    if(!includeFields && rowIdx==0 && colIdx==0) value="";

		    if(flipColumns)
			rotated[colIdx].unshift(value);
		    else
			rotated[colIdx].push(value);
		}
            }
	    if (flipColumns && includeFields) {
                fields.map((f,colIdx)=>{
		    if(f.isRecordDate()) return;
		    rotated[colIdx].unshift(colIdx==0?args["fieldName"]||"Field":f.getLabel());
		});
	    }
	    return  convertToPointData(rotated);
	},
	addPercentIncrease: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let firstRecord= records[0];
	    let replaceValues = args["replaceValues"]=="true";
	    let newFields = [];
	    let fieldOk = f=>{
		return !f.isFieldGeo() && f.isNumeric();
	    };
	    fields.forEach((f,fieldIdx)=>{
		f = f.clone();
		let newField = f.clone();
		f.index = newFields.length;
		if(!fieldOk(newField)) {
		    newFields.push(f);
		    return;
		}
		if(!replaceValues) {
		    newFields.push(f);
		}
		newField.unit = "%";
		newField.index = newFields.length;
		newField.id = newField.id +"_percent";
		newField.label = newField.label+" % increase";
		newFields.push(newField);
	    });
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    records.forEach((record, rowIdx)=>{
		let data = [];
		let newRecord = record.clone();
		newRecord.data=data;
		newRecord.fields =newFields;
		newRecords.push(newRecord);
		fields.forEach((f,fieldIdx)=>{
		    let value = record.data[f.getIndex()];
		    if(!fieldOk(f)) {
			if(rowIdx==records.length-1) {
	//		    console.log(f +" ==" +  value);
			}
			data.push(value);
			return;
		    }
		    if(!replaceValues) {
			data.push(value);
		    }
		    if(rowIdx==0) {
			data.push(0);
		    } else {
			let basev = firstRecord.data[f.getIndex()];
			let perc = basev==0?0:(value-basev)/basev;
			data.push(perc);
			if(rowIdx==records.length-1) {
//			    console.log(f +" =" + basev +" " + value +" perc:" + perc);
			}
		    }
		}); 
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	unique: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let groupFields =  this.display.getFieldsByIds(fields, (args.groupFields||"").replace(/_comma_/g,","));
	    let valueField = this.display.getFieldById(fields,args.valueField);
	    let groups = {};
	    records.forEach((record, rowIdx)=>{
		let key ='';
		groupFields.forEach((f,fieldIdx)=>{
		    key+= record.data[f.getIndex()];
		    key+='_';
		});
		let group = groups[key];
		if(group==null) {
		    group = groups[key] = {};
		}
		let value = valueField!=null?record.data[valueField.getIndex()]:args.valueField=='_date'?record.getTime().getTime():'';

		if(group[value]) {
		    return;
		}
		group[value] = true;
		newRecords.push(record);
	    });
	    return   new  PointData("pointdata", fields, newRecords,null,{parent:pointData});
	},

	roundDate: function(pointData, args) {
            let fields  = pointData.getRecordFields();
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
	    let newRecords  =[];
	    let by = args.round??'day';
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let date = new Date(newRecord.getTime());
		if(by=='hour') {
		    date.setMinutes(0, 0, 0);
		} else 	if(by=='day') {
		    date.setHours(0, 0, 0, 0);
		} else if(by=='week') {
		    date.setHours(0, 0, 0, 0);
		    date.setDate(date.getDate() - date.getDay()); 
		} else if(by=='month') {
		    date.setHours(0, 0, 0, 0);
		    date.setDate(1); 
		} else if(by=='year') {
		    date.setHours(0, 0, 0, 0);
		    date.setMonth(0, 1);
		    date.setFullYear(date.getFullYear() + 1);		    
		} else {
		    console.log('unknown round date value:' + by);
		}
		newRecord.setTime(date);
	    });
	    return   new  PointData("pointdata", fields, newRecords,null,{parent:pointData});
	},
	filterDate: function(pointData, args) {
	    let hasMonth = Utils.isDefined(args.month);
	    let hasYear = Utils.isDefined(args.year);
	    let hasStartYear = Utils.isDefined(args.startyear);
	    let hasEndYear = Utils.isDefined(args.endyear);	    	    	    
	    let records = pointData.getRecords(); 
	    let newRecords  =[];
	    records.forEach((record, rowIdx)=>{
		let date = new Date(record.getTime());
		if(hasMonth && date.getMonth()!=args.month)  return;
		if(hasYear && date.getFullYear()!=args.year)  return;		
		if(hasStartYear && date.getFullYear()<args.startyear)  return;
		if(hasEndYear && date.getFullYear()>args.endyear)  return;
		newRecords.push(record.clone());
	    });
            let fields  = pointData.getRecordFields();
	    return   new  PointData("pointdata", fields, newRecords,null,{parent:pointData});
	},



	addFixed: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let value = args["value"];
	    let type = args["type"]||"double";
	    if(type == "double") value = parseFloat(value);
	    let id = args[ATTR_ID];
	    let label = args["label"]||Utils.makeLabel(id);	    	    
	    let newFields = [];
	    fields.forEach((f,fieldIdx)=>{
		newFields.push(f.clone());
	    });
	    newFields.push(new RecordField({
		id:id,
		index:newFields.length,
		label:label,
		type:type,
		chartable:true,
	    }));
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.data  =  [];
		record.data.forEach(d=>{newRecord.data.push(d)});
		newRecord.data.push(value);
		newRecords.push(newRecord);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	addBearing: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let newFields = [];
	    fields.forEach((f,fieldIdx)=>{
		f = f.clone();
		newFields.push(f);
	    });
	    let bearingField = new RecordField();
	    newFields.push(new RecordField({
		id:"bearing",
		index:newFields.length,
		label:"Bearing",
		type:"double",
		chartable:true,
	    }));
	    let pervPoint;
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.fields =newFields;
		newRecords.push(newRecord);
		let bearing = NaN;
		if(prevPoint) {
		    let point = {lat:newRecord.getLatitude(),lon: newRecord.getLongitude()};
		    bearing  = Utils.getBearing(prevPoint, point);
		    prevPoint = point;
		}
		newRecord.data.push(bearing);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	cut: function(pointData, args) {
	    let cut  = args.fields?args.fields.split(","):[];
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newFields = [];
	    let newRecords = [];
	    let indices = [];
	    fields.forEach((f,fieldIdx)=>{
//		console.log(f.getId());
		if(cut.indexOf(f.getId())>=0) return;
		f = f.clone();
		let newField = f.clone();
		indices.push(newField.index);
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.fields =newFields;
		let data= newRecord.data;
		let newData=[];
		indices.forEach(i=>{
		    newData.push(data[i]);
		});
		newRecord.data = newData;
		newRecords.push(newRecord);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	doAverage: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    var newRecords  =[];
	    var newFields = [];
	    var firstRow = records[0];
	    fields.forEach(f=>{
		var newField = f.clone();
		newFields.push(newField);
		newField.label = newField.label+" (avg)";
	    });
	    var sums=[];
	    fields.forEach(f=>{sums.push(0)});
	    var newRecord;
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		if(newRecord==null) {
		    newRecord = record.clone();
		    newRecords.push(newRecord);
		    newRecord.fields =newFields;
		    newRecord.parentRecords=[];
		}
		newRecord.parentRecords.push(record);
		fields.forEach((f,idx)=>{
		    if(!f.isNumeric()) return;
		    var v = record.data[f.getIndex()];
		    sums[idx]+=v;
		});
		fields.map((f,idx)=>{
		    if(!f.isNumeric()) return;
		    newRecord.data[idx] = sums[idx]/records.length;
		});
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	noop: function(pointData, args) {
	    return pointData;
	},
	doublingRate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields =  this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    let keyFields =  this.display.getFieldsByIds(allFields, (args.keyFields||"").replace(/_comma_/g,","));
	    let newRecords  =[]
	    let newFields = Utils.cloneList(allFields);
	    fields.map(f=>{
		if(!f.isNumeric()) return;
		let newField = f.clone();
		newField.id = newField.id+"_doubling";
		newField.unit = "days";
		newField.label = newField.label+" doubling";
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    let keys = [];
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		let key = "";
		keyFields.forEach(f=>{
		    key+="_"+record.getValue(f.getIndex());
		});
		keys.push(key);
	    }

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		let key = keys[rowIdx];
		newRecords.push(newRecord);
		newRecord.fields =newFields;
		fields.map((f,idx)=>{
		    if(!f.isNumeric()) return;
		    let v = record.getValue(f.getIndex());
		    let v2 = NaN;
		    let lastDate = null;
		    for (let j=rowIdx-1; j>=0; j--) {
			if(keyFields.length>0) {
			    let key2 = keys[j];
			    if(key!=key2) continue;
			}
			let record2 = records[j];
			v2 = record2.getValue(f.getIndex());
			if(v>=v2*2) {
			    lastDate  = record2.getDate();
			    break;
			}
		    }
		    let diff = NaN;
		    if(lastDate) {
			diff = (record.getDate().getTime()-lastDate.getTime())/1000/60/60/24;
		    }
		    newRecord.data.push(diff);
		});
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	scaleAndOffset: function(pointData,args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let unit = args.unit;
	    let scale = args.scale?parseFloat(args.scale):1;
	    let offset1 = args.offset1?parseFloat(args.offset1):0;
	    let offset2 = args.offset?parseFloat(args.offset):args.offset2?parseFloat(args.offset2):0;	    	    
	    let newRecords  =[]
	    let newFields = [];
	    let changedFields = {};
	    fields.forEach(f=>{changedFields[f.getId()]  =true});
	    allFields.map(f=>{
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) {
		    return;
		}
		if(changedFields[newField.getId()]) {
		    newField.unit = unit;
		}
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			d  = (d + offset1) * scale + offset2;
			newData[f.getIndex()]=d;
		    }
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	scaleAndOffset: function(pointData,args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let unit = args.unit;
	    let scale = args.scale?parseFloat(args.scale):1;
	    let offset1 = args.offset1?parseFloat(args.offset1):0;
	    let offset2 = args.offset?parseFloat(args.offset):args.offset2?parseFloat(args.offset2):0;	    	    
	    let newRecords  =[]
	    let newFields = [];
	    let changedFields = {};
	    fields.forEach(f=>{changedFields[f.getId()]  =true});
	    allFields.map(f=>{
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) {
		    return;
		}
		if(changedFields[newField.getId()]) {
		    newField.unit = unit;
		}
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			d  = (d + offset1) * scale + offset2;
			newData[f.getIndex()]=d;
		    }
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	replace: function(pointData,args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fieldString=(args.fields??'').replace(/_comma_/g,',');
	    let fields = this.display.getFieldsByIds(allFields, fieldString);
	    let pattern = args.pattern??'';
	    pattern = pattern.replace(/_quote_/g,'"');
	    pattern = new RegExp(pattern, "g");
	    let swith = args.with??'';
	    let newRecords  =[]
	    if(fields.length==0) {
		console.log('replace: no field found:' + args.fields);
	    }
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(field=>{
		    let s = String(data[field.getIndex()]);
		    s = s.replace(pattern,swith);
		    newData[field.getIndex()]=s;
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", allFields, newRecords,null,{parent:pointData});
	},


	function: function(pointData, args) {
	},
	accum: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    let suffix = args.suffix!=null?args.suffix:"_accum";
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    let totals =[];
	    allFields.map(f=>{
		totals.push(0);
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) return;
		newField.id = newField.id+suffix;
		newField.label = newField.label+suffix;
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			let x = d;
			totals[f.getIndex()]+=d;
			d = totals[f.getIndex()];
		    }
		    newData[f.getIndex()] = d;
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	aggregate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let groupField = this.display.getFieldById(allFields,args.groupBy);
	    if(!groupField) throw new Error("No groupBy defined: "+ args.groupBy +" args:" + JSON.stringify(args));
	    let includeRows = args.includeRows;
	    let fields;
	    let suffix = args.suffix!==null?args.suffix:"_accum";
	    suffix = "";
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    let totals =[];
	    let groupMap = {};
	    let groups = [];
	    let prop= (f,p)=>{
		let id = f.getId()+"." + p;
		if(Utils.isDefined(args[id])) return args[id];
		if(Utils.isDefined(this.display.getProperty(id))) return this.display.getProperty(id);
		return this.display.getProperty(p);		
	    };
	    fields.forEach(f=>{
		let newField = f.clone();
		newFields.push(newField);
		newField.id = newField.id+suffix;
		newField.label = newField.label+suffix;
		if(newField.isNumeric()) {
		    newField.weightedByField = this.display.getFieldById(allFields,prop(newField,"weightedByField"));
		    let op = prop(newField,"operator");
		    if(!op && newField.getUnit()=="%")
			op = "average";
	 	    newField.operator =op;
		}
	    });
	    records.forEach(record=>{
		let groupValue = groupField.getValue(record);
		let group = groupMap[groupValue];
		if(!group) {
		    group = groupMap[groupValue] = [];
		    groups.push(groupValue);
		}
		group.push(record);
	    });
	    groups.forEach(group=>{
		let newData = [];
		let rows = groupMap[group];
		newFields.forEach(f=>{
		    if(f.weightedByField) {
			f.weight = Utils.sumList(rows.map(record=>{return f.weightedByField.getValue(record);}));
		    }
		    if(f.isFieldNumeric()) newData.push(0);
		    else {
			if(f.getId()==groupField.getId()) 
			    newData.push(group);
			else
			    newData.push("");
		    }
		});
		let debug = group=="Delaware";
		rows.forEach((record,recordIdx)=>{
		    newFields.forEach((f,idx)=>{
			let v = f.getValue(record);
			if(f.isFieldNumeric()) {
			    if(!isNaN(v)) {
				
				if(f.operator=="average" && f.weightedByField) {
				    let weight = f.weightedByField.getValue(record);
				    let percent = weight/f.weight;
				    v= v*percent;
				}
				newData[idx]+=v;
			    }
			} else {
			    if(recordIdx==0)
				newData[idx] = v;
			    if(groupField.getId()==f.getId()) {
				newData[idx] = groupField.getValue(record);
			    }
			}
		    });
		});
	    	let newRecord = rows[0].clone();
		newRecords.push(newRecord);
		newFields.forEach(f=>{
		    if(!f.isNumeric()) {
			if(groupField.getId()!=f.getId())
			    newData[f.getIndex()]="";
			return;
		    }
		    let debug = group=="Delaware";
		    let d = newData[f.getIndex()]
		    if(!isNaN(d)) {
			if(f.operator=="average") {
			    if(!f.weightedByField) {
				d =  d/rows.length;
			    } 
			}
			let decimals = prop(f,"numberFormatDecimals");
			if(decimals!==null)
			    d = Utils.roundDecimals(d,decimals);
//			if(debug) console.log(f.getId() +" d:" + d);
			newData[f.getIndex()] = d;
		    }
		});
		newRecord.setData(newData);
		newRecord.isAggregate = true;
		newRecord.aggregateValue=group;
		if(includeRows) 
		    newRecords = Utils.mergeLists(newRecords, rows);

	    })
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


	mean: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    allFields.map(f=>{
		newFields.push(f.clone());
	    });
	    newFields.push(new RecordField({
		id:"mean",
		index:newFields.length,
		label:"Mean",
		type:"double",
		chartable:true,
	    }));

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		let total = 0;
		let fieldCnt = 0;
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    fieldCnt++;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			total+=d;
		    }
		});
		newData.push(total/fieldCnt);
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	count: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();

	    if(!args.field)
		throw new Error("No field specified");
	    let field = this.display.getFieldById(allFields, args.field);
	    let newFields = [];
	    let newField = field.clone();
	    newField.index=0;
	    newFields.push(newField);
	    newFields.push(new RecordField({
		id:"count",
		index:1,
		label:"Count",
		type:"integer",
		chartable:true,
	    }));

	    let counts = {};
	    let values = [];
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let value = field.getValue(record);
		if(!Utils.isDefined(counts[value])) {
		    counts[value]={
			count:0,
			records:[]
		    };
		    values.push(value);
		}
		counts[value].count++;
		counts[value].records.push(record);
	    }
	    let newRecords  =[]
	    if(args.sort) values.sort();
	    values.forEach(value=>{
		let newData = [value,counts[value].count];
		let newRecord = new  PointRecord(newFields,NaN,NaN, NaN, null, newData);
		newRecord.parentRecords=counts[value].records;
		newRecords.push(newRecord);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


	prune: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    allFields.map(f=>{
		newFields.push(f.clone());
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let data = record.getData();
		let newData=Utils.cloneList(data);
		let ok = false;
		let fieldCnt= 0;
		fields.every(f=>{
		    if(!f.isNumeric()) return true;
		    fieldCnt++;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			ok = true;
			return false;
		    }
		    return true;
		});
		if(ok)  {
		    let newRecord = record.clone();
		    newRecord.setData(newData);
		    newRecords.push(newRecord);
		}
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


	mergeRows: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let op = args.operator || "count";
	    let ops = {};
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    let altFields =  this.display.getFieldsByIds(fields, (args.altFields||"").replace(/_comma_/g,","));
	    let newFields = [];
	    let seen = {};
	    keyFields.forEach((f,idx)=>{
		seen[f.getId()] = true;
		let newField = f.clone();
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    let tmp =  this.display.getFieldsByIds(fields, (args["valueFields"]||"").replace(/_comma_/g,","));
	    if(args.valueFields==null) tmp=fields;
	    let valueFields = [];


	    tmp.forEach(f=>{
		if(!seen[f.getId()]) {
		    ops[f.getId()] = args[f.getId()+".operator"];
		    valueFields.push(f);
		}
	    });

	    valueFields.forEach((f,idx)=>{
		var newField = f.clone();
		newField.index = newFields.length;
		if(newField.isNumeric()) {
		    let label = args[newField.id+".label"];
		    newField.id = newField.id +"_" + (ops[f.getId()+".operator"] || op);
		    newField.label = label || Utils.makeLabel(newField.id);
		}
		newFields.push(newField);
	    });
	    //	    console.log("key fields:" + keyFields);
	    //	    console.log("value fields:" + valueFields);
	    if(op == "count") {
		newFields.push(new RecordField({
		    id:"count",
		    index:newFields.length,
		    label:"Count",
		    type:"double",
		    chartable:true,
		}));
		newFields.push(new RecordField({
		    id:"percent",
		    index:newFields.length,
		    label:"Percent",
		    type:"double",
		    chartable:true,
		}));		
	    }
//	    console.log("fields:" + newFields);
	    let keys = [];
	    let collection ={
	    };

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		let key = "";
		keyFields.forEach(f=>{
		    let v = record.getValue(f.getIndex());
		    if(v=="" && altFields.length>0) {
			altFields.forEach(f2=>{
			    v+=record.getValue(f1.getIndex()) +"-";
			});
		    }
		    key +=v+"-";
		});
		let obj = collection[key];
		if(!obj) {
		    keys.push(key);
		    obj = collection[key]= {
			count:0,
			sums: [],
			mins: [],
			maxs:[],
			records:[]
		    };
		    valueFields.forEach((f,idx)=>{
			obj.sums.push(0);
			obj.mins.push(NaN);
			obj.maxs.push(NaN);
		    });
		}
		valueFields.forEach((f,idx)=>{
		    let v = record.getValue(f.getIndex());
		    if(f.isNumeric() && !isNaN(v)) {
			obj.sums[idx]+=v;
			obj.mins[idx] = isNaN(obj.mins[idx])?v:Math.min(obj.mins[idx],v);
			obj.maxs[idx] = isNaN(obj.maxs[idx])?v:Math.max(obj.maxs[idx],v);
		    }
		});
		obj.count++;
		obj.records.push(record);
	    }
	    let newRecords = [];
	    let cnt = 0;
	    keys.forEach((key,idx)=>{
		let obj = collection[key];
		let data =[];
		let seen = {};
		let date = obj.records[0].getDate();
		let bounds = RecordUtil.getBounds(obj.records);
		let lat =  bounds.south+(bounds.north-bounds.south)/2;
		let lon =  bounds.west+(bounds.east-bounds.west)/2;
		if(key.indexOf("US")>=0) {
		    cnt++;
		    if(cnt==1) {
			//			console.log(obj.records.length +" " +bounds.west +" " + bounds.east +" " + lat  +" " +lon);
			obj.records.forEach(r=>{
			    //			    console.log(r.getValue(0) + " " + r.getLatitude() +" " + r.getLongitude())
			});
		    }
		}
		keyFields.forEach(f=>{
		    let v = obj.records[0].getValue(f.getIndex());
		    data.push(v);
		    seen[f.getId()]=true;
		});
		valueFields.forEach((f,idx)=>{
		    if(seen[f.getId()]) return;
		    if(!f.isNumeric()) {
			data.push(obj.records[0].getValue(f.getIndex()));
		    } else {
			if(op == "sum") 
			    data.push(obj.sums[idx]);
			else if(op == "average") 
			    data.push(obj.sums[idx]/obj.count);
			else if(op == "min") 
			    data.push(obj.mins[idx]);
			else if(op == "max") 
			    data.push(obj.maxs[idx]);
		    }
		});
		if(op == "count") {
		    data.push(obj.count);
		    data.push(Utils.trimDecimals(100*obj.count/records.length,1));		    
		}
		let newRecord = new  PointRecord(newFields,lat,lon, NaN, date, data);
		newRecords.push(newRecord);
	    });

	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	maxDate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    let seen = {};
	    let keys = [];
	    let collection ={
	    };

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		let key = "";
		keyFields.forEach(f=>{
		    key +=  record.getValue(f.getIndex())+"-";
		});
		let obj = collection[key];
		if(!obj) {
		    keys.push(key);
		    obj = collection[key]= {
			records:[]
		    };
		}
		obj.records.push(record);
	    }
	    let newRecords = [];
	    let cnt = 0;
	    keys.forEach((key,idx)=>{
		let records = collection[key].records;
		let maxRecord = null;
		let maxDate = null;
		records.forEach(r=>{
		    if(maxRecord==null || r.getDate().getTime()>maxDate) {
			maxDate = r.getDate().getTime();
			maxRecord = r;
		    }
		});
		newRecords.push(maxRecord);
	    });

	    return   new  PointData("pointdata", fields, newRecords,null,{parent:pointData});
	},

	unfurl: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let headerField =  this.display.getFieldById(fields, args.headerField||"");
	    let uniqueField =  this.display.getFieldById(fields, args.uniqueField||"");
	    let valueFields =  this.display.getFieldsByIds(fields, args.valueFields||"");
	    let includeFields =  this.display.getFieldsByIds(fields, args.includeFields||"");
	    let prefix = args.prefix||"";
	    if(!headerField) throw new Error("No headerField");
	    let uniqueIsDate = false;
	    if(!uniqueField) {
		if(args.uniqueField=="date") {
		    uniqueIsDate = true;
		} else {
		    throw new Error("No uniqueField");
		}
	    }
	    if(valueFields.length==0) throw new Error("No value fields");
	    /*
	      newFields.push(new RecordField({
	      id:"count",
	      index:newFields.length,
	      label:"Count",
	      type:"double",
	      chartable:true,
	      }));
	    */
	    let newColumns = [];
	    let newColumnMap = {};
	    let uniqueToRecords = {};
	    let rowMap = {};
	    let uniques = [];
	    let indexMap={};
	    records.forEach(record=>{
		let unfurlValue = record.getValue(headerField.getIndex());
		let uniqueValue = uniqueIsDate?record.getDate():record.getValue(uniqueField.getIndex());
		if(!newColumnMap[unfurlValue]) {
                    newColumnMap[unfurlValue] = true;
                    if (valueFields.length > 1) {
                        valueFields.forEach(f=>{
                            let label = unfurlValue + " - "
                                + f.getLabel();
                            newColumns.push(label);
                        });
                    } else {
			newColumns.push(unfurlValue);
		    }
		}
                let rowGroup    = rowMap[uniqueValue];
                if (rowGroup == null) {
                    rowMap[uniqueValue] =  rowGroup = [];
                    uniques.push(uniqueValue);
                }
                rowGroup.push(record);
	    });

	    //In case the new colum labels are numbers
	    newColumns.sort((a,b)=>{
		if(typeof a =="number" &&  typeof b =="number") {
		    return a-b;
		}
		return (""+a).localeCompare(""+b);
	    });
            newColumns.forEach((v,idx) => {
                indexMap[v] = idx;
            });

	    let newRecords = [];
	    let newFields = [];
	    let uniqueType = "string";
	    if(uniques[0]) {
		if(uniques[0].getTime)
		    uniqueType ="date";
		else if(typeof uniques[0] =="number")
		    uniqueType ="double";
		    
	    }
	    if(uniqueIsDate)
		newColumns = Utils.mergeLists(["date"], newColumns);
	    else
		newColumns = Utils.mergeLists([uniqueField.getId()], newColumns);
	    newColumns.forEach((c,idx)=>{
		if(idx>0)
		    c = prefix+""+c;
		else
		    c = ""+c;
		let label =Utils.makeLabel(c);
		let id  = Utils.makeId(c);
		let type = (idx==0?uniqueType:"double");
		newFields.push(new RecordField({
		    id:id,
		    index:newFields.length,
		    label:label,
		    type:type,
		    chartable:true,
		}));
	    });
	    uniques.forEach(u=>{
		let array = [];
		newColumns.forEach(c=>{
		    array.push("");
		});
                array[0] = u;
                let  includeCnt = 0;
                let rowValues  = null;
                let firstRow   = null;
                cnt = 0;
                rowMap[u].forEach(row=>{
                    if (firstRow == null) {
                        firstRow = row;
                    }
                    let colname = row.getValue(headerField.getIndex());
                    if (valueFields.length > 1) {
                        valueFields.forEach(f=>{
                            let label = colname + " - "  + f.getId();
                            let idx = indexMap[label];
                            if (idx == null) {
				return;
                            }
                            let value =  row.getValue(valueIndex);
                            array[1 + includeFields.length + idx] = value;
                        });
		    } else {
                        let idx = indexMap[colname];
                        if (idx == null) {
			    return;
                        }
                        let    valueIndex = valueFields[0].getIndex();
                        let value = row.getValue(valueIndex);
                        array[1 + includeFields.length + idx] = value;
                    }
                    cnt++;
		});

                includeFields.forEach(f=>{
                    array[1 + includeCnt] = firstRow.getValue(f.getIndex());
                    includeCnt++;
                });
		let newRecord = new  PointRecord(newFields,firstRow.getLatitude(),firstRow.getLongitude(), NaN, null, array);
//		console.log("lat:" + firstRow.getLatitude());
		newRecords.push(newRecord);
                cnt++;
            });
 	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


    });
}




var DataUtils = {
    timeMap: {
	century: 1000 * 60 * 60 * 24 * 365 * 100,
	centuries: 1000 * 60 * 60 * 24 * 365 * 100,	    
	decade: 1000 * 60 * 60 * 24 * 365 * 10,
	halfdecade: 1000 * 60 * 60 * 24 * 365 * 5,
	year: 1000 * 60 * 60 * 24 * 365 * 1,
	years: 1000 * 60 * 60 * 24 * 365 * 1,	    
	month: 1000 * 60 * 60 * 24 * 31,
	months: 1000 * 60 * 60 * 24 * 31,	    
	week: 1000 * 60 * 60 * 24 * 7,
	weeks: 1000 * 60 * 60 * 24 * 7,	    
	day: 1000 * 60 * 60 * 24 * 1,
	days: 1000 * 60 * 60 * 24 * 1,		    	    
	hour: 1000 * 60 * 60,
	hours: 1000 * 60 * 60,
	minute: 1000 * 60,
	minutes: 1000 * 60,	    
	second: 1000,
	seconds: 1000		    
    },
    //Convert the window to millis - e.g., '5 minutes', '10 days', etc
    timeToMillis:function(window) {
	window =(""+window).trim();
	let cnt = 1;
	let unit = "day";
	let toks = window.match("^([0-9]+)(.*)");
	if(toks) {
	    cnt = +toks[1];
	    unit  = toks[2].trim();
	} else {
	    toks = window.match("(^[0-9]+)$");
	    if(toks) {
		unit = "minute";
		cnt = +toks[1];
	    } else {
		unit = window;
	    }
	}
	let scale = 1;
	unit = unit.toLowerCase().trim();
	if(this.timeMap[unit]) {
	    scale = this.timeMap[unit];
	} else {
	    if(unit.endsWith("s"))
		unit = unit.substring(0, unit.length-1);
	    if(this.timeMap[unit]) {
		scale = this.timeMap[unit];
	    } else {
		console.log("Unknown unit:" + unit);
	    }
	}
	return  cnt*scale;
    },

    getCsv: function(fields, records,filter,max) {
	if(!Utils.isDefined(max)) max=-1;
	let csv = "";
	fields.forEach((f,idx)=>{
	    if(idx>0) csv+=",";
	    csv+=f.getId();
	});
	csv+="\n";
	let cnt=0;
	records.every(r=>{
	    if(filter && !filter(r)) {
		return true;
	    }
	    if(max>0 && cnt>=max) return false;
	    cnt++;
	    fields.forEach((f,idx)=>{
		let v = r.getValue(f.getIndex());
		if(v && v.getTime) {
		    v  =Utils.formatDateYYYYMMDDHHMM(v);
		} else {
		    v = String(v);
		}
		if(idx>0) csv+=",";
		let needToQuote = v.indexOf("\n")>=0 || v.indexOf(",")>=0;
		if(v.indexOf("\"")>=0) {
		    needToQuote = true;
		    v = v.replace(/\"/g,"\"\"");
		}
		if(needToQuote) {
		    v = "\"" + v +"\"";
		}
		csv+=v;
	    });
	    csv+="\n";
	    return true;
	});
	return csv;
    },
    getJson: function(fields, records, filename,filter,max) {
	if(!Utils.isDefined(max)) max=-1;
	let json = [];
	let cnt=0;
	records.every(r=>{
	    if(filter && !filter(r)) return true;
	    if(max>0 && cnt>=max) return false;
	    cnt++;

	    let obj = {};
	    json.push(obj);
	    fields.forEach((f,idx)=>{
		let v = r.getValue(f.getIndex());
		if(v && v.getTime) {
		    v  =Utils.formatDateYYYYMMDDHHMM(v);
		} else {
		    v = String(v);
		}
		obj[f.getId()] = v;
	    });
	    return true;
	});
	Utils.makeDownloadFile(filename, JSON.stringify(json,null,2));
    },


    parseCommands: function(commands) {
	let result = [];
	if(!commands) return result;
	commands.split(";").forEach(command=>{
	    command = command.trim();
	    let idx=command.indexOf("(");
	    let args = {};
	    if(idx>=0) {
		let rest = command.substring(idx+1).trim();
		command = command.substring(0,idx).trim();
		if(rest.endsWith(")")) rest = rest.substring(0,rest.length-1);
		let toks = [];
		let inQuote = false;
		let escape = false;
		let tok = "";
		for(let i=0;i<rest.length;i++) {
		    let c = rest[i];
		    if(c=="\\") {
			escape=true;
			continue;
		    }
		    if(escape) {
			tok += c;
			escape=false;
			continue;
		    }
		    if(c=="\'") {
			if(!inQuote) {
			    inQuote = true;
			} else {
			    inQuote = false;
			}
			tok += c;
			continue;
		    }
		    if(c == ",") {
			if(inQuote) {
			    tok += c;			    
			    continue;
			}
			toks.push(tok);
			tok = "";
			continue;
		    }
		    tok += c;			    
		}
		toks.push(tok);
		toks.forEach(arg=>{
		    arg =arg.trim();
		    let value = "";
		    let atoks = arg.match(/(.*)=(.*)/);
		    if(atoks) {
			arg=atoks[1];
			value= atoks[2];
		    }
		    arg = arg.trim();
		    value = value.trim();
		    //		    console.log("arg:" + arg +" v:" + value);
		    //Strip off quotes
		    value = value.replace(/^'/g,"").replace(/'$/g,"");
		    if(arg!="") {
			args[arg] = value;
		    }
		});
	    }
	    if(command!="") {
		result.push({command:command,args:args});
	    }
	});
	return result;
    },
    getDataFilters: function(display, prop) {
	let filters = [];
	if(!prop) return filters;
	let baseId = display.getId();
	let cnt = 0;
	DataUtils.parseCommands(prop).map(cmd=>{
	    let filterId = baseId+"_" + (cnt++);
	    let [type,fieldId,value,enabled,label,expr]  = [cmd.command,cmd.args.field,cmd.args.value,cmd.args.enabled,cmd.args.label,cmd.args.expr];
	    if(!Utils.isDefined(enabled))
		enabled = true;
	    else {
		enabled = enabled.trim()=="true" || enabled.trim()=="";
	    }
	    if(label) {
		var cbx =  display.jq("datafilterenabled_" + filterId);
		if(cbx.length) {
		    enabled = cbx.is(':checked');
		} 
	    }
	    if(type=="match" || type=="notmatch")
		value = new RegExp(value);
	    else
		value = +value;
	    let fields = null;
	    if(cmd.args.fields) {
		fields = display.getFieldsByIds(null, cmd.args.fields.replace(/:/g,","));
	    }
	    let allFields = display.getData().getRecordFields();
	    let field = display.getFieldById(null,fieldId);
	    filters.push({
		id:filterId,
		props:cmd.args,
		type:type.trim(),
		field:field,
		fields:fields?fields:field?[field]:null,
		allFields:allFields,
		value:value,
		label:label,
		enabled: enabled,
		expr:expr,
		getEnabled:function() {
		    return this.enabled && this.field!=null;
		},
		toString: function() {
		    return 'filter:' + this.field?.getId() +' '+ this.type +' ' + this.value;
		},
		isRecordOk: function(r) {
		    if(!this.getEnabled()) {
			return true;
		    }
		    let value = this.field?r.getValue(this.field.getIndex()):NaN;
		    if(this.type == "match") {
			return String(value).match(this.value);
		    } else if(this.type == "nomissing") {
			let fieldsToUse =null;
			if(this.fields) {
			    fieldsToUse = this.fields;
			} else if(this.field) {
			    fieldsToUse = [this.field];
			} else {
			    fieldsToUse = r.fields;
			}
			let ok = false;
			fieldsToUse.some(f=>{
			    if(field && !(field.isFieldLatitude() || f.isFieldLongitude()))
				if(f.isFieldLatitude() || f.isFieldLongitude()) return true;
			    if(f.isNumeric()) {
				let v  = r.getValue(f.getIndex());
				//				console.log("V:" + v);
				ok  =!isNaN(v);
			    }
			    return ok;
			});
			//			if(!ok) 
			//			    console.log("****** V:" +value + " v:" + this.value);
			return ok;
		    } else if(this.type == "notmatch") {
			return  !String(value).match(this.value);
		    } else if(this.type == "lessthan") {
			return  value<this.value;
		    } else if(this.type == "greaterthan") {
			return  value>this.value;
		    }  else if(this.type == "equals") {
			return  value==this.value;
		    }  else if(this.type == "notequals") {
			return value!=this.value;
		    }  else if(this.type == "bounds") {
			let lat =  r.getLatitude();
			let lon =  r.getLongitude();
			if(this.props.north && lat>+this.props.north) return false;
			if(this.props.south && lat<+this.props.south) return false;
			if(this.props.west && lon<+this.props.west)   return false;
			if(this.props.east && lon>+this.props.east) {return false;}
			return true;
		    }  else if(this.type == "eval") {
			//return true;
			//assume its inline code
			let code = "function dataFilterCall(){\n";
			this.allFields.every(f=>{
			    let value = r.getValue(f.getIndex());
			    if(typeof value == "string") value = "'" + value +"'";
			    else if(typeof value != "number") value = "'" + value +"'";
			    code+=f.getId() +"=" + value+";\n"
			    return true;
			});
			let expr = this.expr;
			if(expr == null) throw "No expr given in data filter";
			if(expr.indexOf("return")<0)  expr  = " return " + expr;
			code+=expr+"\n}\n";
			code +="var dataFilterValue = dataFilterCall();\n";
			eval(code);
			return dataFilterValue;
		    } else {
			console.log("Unknown filter:" + this.type);
			return true;
		    }

		}
	    });
	});
	return filters;
    },
}


function RequestMacro(display, macro) {
    this.display = display;
    let values = null;
    let enums = this.getProperty("request." +macro+".values");
    if(enums) {
	values =[]	
	let includeAll = false;
	if(this.getProperty("request." + macro+".includeAll",this.getProperty("request.includeAll",false))) {
	    values.push(["","All"]);
	    includeAll = true;
	}
	if(this.getProperty("request." + macro+".includeNone",this.getProperty("request.includeNone",true))) {
	    values.push([VALUE_NONE,"None"]);
	}
	if(this.getProperty("request." + macro+".includeDefault",this.getProperty("request.includeDefault",true))) {
	    values.push([VALUE_NONE,"Default"]);
	}	
	Utils.split(enums,",").forEach(tok=>{
	    let toks = tok.split(":");
	    let id = toks[0];
	    let label = Utils.join(toks,' ',1);
	    if(!includeAll && id=="_all_") return;
	    values.push([id,label||id]);
	});
    }

    let macroType = this.getProperty("request." +macro+".type",values!=null?"enumeration":macro=="bounds"?"bounds":"string");
    let dflt =this.getProperty("request." +macro+".default",null);
    if(dflt == null) {
	if(values && values.length>0  && macroType=="enumeration") {
	    dflt = values[0][0];
	} else {
	    dflt = "";
	}
	dflt = "";
    }
    if(dflt && macroType=="enumeration") {
	if(dflt.split)	dflt = dflt.split(",");
    }

    //    console.log(macro +" type:" + macroType +" v:" + values +' values:' + values);

    let prefix = this.getProperty("requestPrefix","");
    $.extend(this,{
	name: macro,
	values:values,
	urlarg: this.getProperty("request." +macro+".urlarg",prefix+macro),
	type:macroType,
	triggerReload:this.getProperty("request." +macro+".triggerReload",true),
	dflt:dflt,
	dflt_from:this.getProperty("request." +macro+"_from.default",""),		    
	dflt_to:this.getProperty("request." +macro+"_to.default",""),
	dflt_min:this.getProperty("request." +macro+"_min.default",""),		    
	dflt_max:this.getProperty("request." +macro+"_max.default",""),
	label:this.getProperty("request." +macro+".label",Utils.makeLabel(macro)),
	multiple:this.getProperty("request." +macro+".multiple",false),
	template:this.getProperty("request." +macro+".template"),
	multitemplate:this.getProperty("request." +macro+".multitemplate"),
	nonetemplate:this.getProperty("request." +macro+".nonetemplate"),		
	delimiter:this.getProperty("request." +macro+".delimiter"),
	rows:this.getProperty("request." +macro+".rows",3),
    });
}


RequestMacro.prototype = {
    getProperty: function(prop, dflt)   {
	return this.display.getProperty(prop, dflt);
    },
    isVisible: function() {
	return  this.getProperty('request.' +this.name +'.visible',
				 this.getProperty('macros.visible',true));
    },
    deltaSkip:function(positive,macroChange) {
	if(!this.limitMacro) return;
	let size = parseInt(this.limitMacro.getValue());
	let skip = parseInt(this.getValue());
	if(positive)
	    skip+=size;
	else
	    skip-=size;
	if(skip<0) skip=0;
	jqid(this.display.getDomId(this.getId())).val(skip);
	this.showSkipLabel();
	//let macroChange = (macro,value,what,force,apply)=>{
	macroChange(this,skip,'',true,true);
    },
    showSkipLabel:function() {
	if(this.limitMacro) {
	    let size = this.limitMacro.getValue();
	    let start = parseInt(this.getValue())+1;
	    let end = start+(parseFloat(size)-1);
	    let label;
	    if(this.display.getProperty('lastRecords')) {
		label =  'last ' + start + ' - '+ end;
	    }  else {
		label =  start + ' - '+ end;
	    }
	    jqid(this.display.getDomId(this.getId()+'_label')).html(label);
	}
    },
    isSkip:function() {
	return (this.type=='skip' || this.name=='skip');
    },
    initWidget: function(macroChange) {
	if(this.selectMenuId && this.values && this.values.length>5) {
	    let widgetId = this.display.getDomId(this.getId());
	    HU.makeSelectTagPopup(jqid(widgetId),{icon:true,makeButton:false,after:true});

	}


	//macroChange: (macro,value,what,force,apply)
	let _this =this;
	if(this.isSkip()) {
	    this.showSkipLabel();
	    jqid(this.display.getDomId(this.getId()+'_next')).button().click(()=>{
		this.deltaSkip(true,macroChange);
	    });
	    jqid(this.display.getDomId(this.getId()+'_prev')).button().click(()=>{
		this.deltaSkip(false,macroChange);
	    });	    
	}
    },
    initMacros: function(macros) {
	if(this.isSkip()) {
	    macros.every(macro=>{
		if(macro.name=='limit') {
		    this.limitMacro=macro;
		    macro.addChangeListener(this);
		    return false;
		}
		return true;
	    });
	}
    },
    macroChanged:function(macro) {
	if(this.isSkip()) {
	    this.showSkipLabel();
	}
    },
    notifyChange:function() {
	if(this.changeListeners)
	    this.changeListeners.forEach(macro=>{
		macro.macroChanged(this);
	    });
    },
    addChangeListener:function(macro) {
	if(!this.changeListeners) this.changeListeners=[];
	this.changeListeners.push(macro);
    },
    getWidget: function(dateIds) {
	let debug = false;
	let visible = this.isVisible();
	let style = visible?'':'display:none;';
	let widget;
	let label = this.label;
	let title = this.getProperty('request.' + this.name+'.title',null);
	if(debug)console.log(this.getId() +'.getWidget:' + label +' type:' + this.type);
	if(this.type=='bounds') {
	    widget = HU.checkbox(this.display.getDomId(this.getId()),[TITLE,title??'Reload with current bounds',ID,this.display.getDomId(this.getId())], false, 'In bounds');
	    label = null;
	} else if(this.isSkip()) {
	    widget = '';
	    let bstyle = 'padding:4px;padding-top:2px;padding-bottom:2px;margin-right:4px;';
	    let buttons =  
		HU.span([ATTR_TITLE,'Show previous',ATTR_STYLE,bstyle,
			 ATTR_CLASS, 'ramadda-clickable',
			 ATTR_ID,this.display.getDomId(this.getId()+'_prev')],
			HU.getIconImage('fas fa-angle-left')) +
		HU.span([ATTR_TITLE,'Show next',ATTR_STYLE,bstyle,
			 ATTR_CLASS, 'ramadda-clickable',
			 ATTR_ID,this.display.getDomId(this.getId()+'_next')],
			HU.getIconImage('fas fa-angle-right'));
	    widget += HU.span([ATTR_STYLE,HU.css('padding-right','8px')],buttons);

	    widget+=HU.span([ATTR_ID,this.display.getDomId(this.getId()+'_label')],'');
	    widget+=HU.input('',this.dflt,[ATTR_STYLE, HU.css('display','none'),
					   ATTR_ID,this.display.getDomId(this.getId())]);
			      
	    label="";
	} else if(this.type=='enumeration') {
 	    if(this.values && this.values.length>0) {
		let widgetId = this.display.getDomId(this.getId());
		let attrs = [ATTR_TITLE,title??'',ATTR_STYLE, style,
			     ATTR_ID,widgetId,ATTR_CLASS,'display-filter-input'];
		let values = this.values;
		if(this.dflt) {
		    let first = [];
		    let rest = [];
		    values.forEach(v=>{
			if(this.dflt.indexOf(v[0])>=0)  first.push(v);
			else rest.push(v);
		    });
		    values = Utils.mergeLists(first,rest);
		} else {
		}

		if(this.multiple) {
		    attrs.push('multiple');
		    attrs.push(null);
		    attrs.push('size');
		    attrs.push(Math.min(this.rows,values.length));
		} else {
//		    values = Utils.mergeLists([[VALUE_NONE,'--']],values);
		}
		let v = this.dflt;
		if(!Utils.stringDefined(v)) {
		    v = VALUE_NONE;
		}
		if(debug)
		    console.log('\tselect: dflt:' + this.dflt +' values:' + this.values);
		this.selectMenuId = widgetId;
		widget = HU.select('',attrs,values,v,30);
	    }
	} else if(this.type=='numeric' || this.type=='number') {
	    let minId = this.display.getDomId(this.getId()+'_min');
	    let maxId = this.display.getDomId(this.getId()+'_max');			    
	    widget = HU.input('','',[ATTR_TITLE,title??'','data-min', this.dflt_min, STYLE, style, ID,minId,'size',4,CLASS,'display-filter-input display-filter-range'],this.dflt_min) +
		' - ' +
		HU.input('','',[ATTR_TITLE,title??'','data-max', this.dflt_max, STYLE, style, ID,maxId,'size',4,CLASS,'display-filter-input display-filter-range'],this.dflt_max)
	    label = label+' range';
	} else if(this.type=='daterange') {
	    let fromId = this.display.getDomId(this.getId()+'_from');
	    let toId = this.display.getDomId(this.getId()+'_to');
	    dateIds.push(fromId);
	    dateIds.push(toId);
	    widget = HU.datePicker('',this.dflt_from,[ATTR_TITLE,title??'',CLASS,'display-filter-input',STYLE, style, 'name','',ID,fromId]) +
		' - ' +
		HU.datePicker('',this.dflt_to,[ATTR_TITLE,title??'',CLASS,'display-filter-input',STYLE, style, 'name','',ID,toId])
	    label = label+' range';
	} else if(this.type=='date') {
	    let fromId = this.display.getDomId(this.getId()+'_from');
	    dateIds.push(fromId);
	    widget = HU.datePicker('',this.dflt_from,[ATTR_TITLE,title??'',CLASS,'display-filter-input',STYLE, style, 'name','',ID,fromId]);
	} else {
	    let size = '10';
	    if(this.type=='number')
		size = '4';
	    size = this.getProperty("request." +this.name+".size",size),

	    widget = HU.input('',this.dflt,[ATTR_TITLE,title??'',ATTR_STYLE, style, ID,this.display.getDomId(this.getId()),'size',size,CLASS,'display-filter-input']);
	}
	if(!widget) return '';
	return (visible?this.display.makeFilterWidget(this.name,label,widget):widget);
    },
    isMacro: function(id) {
	return id == this.name;
    },
    getId: function() {
	return "macro_" + this.name;
    },
    getValue: function() {
	let widget = this.display.jq(this.getId());
	let value = this.dflt;
	if(widget.length!=0) {
	    value =  widget.val();
	} else {
	    if(this.type=="enumeration") {
		return VALUE_NONE;
	    }
	}
	this.display.setProperty("request." + this.name+".default",value);
	//	console.log(this.getId() +".getValue=" + value);
	return value;
    },
    setValue: function(prop) {
	let id = this.getId();
	if(prop.what == "min")
	    this.display.jq(i+"_min").val(prop.value);
	else if(prop.what == "max")
	    this.display.jq(id+"_max").val(prop.value);
	else if(prop.what == "from")
	    this.display.jq(id+"_from").val(prop.value);
	else if(prop.what == "to")
	    this.display.jq(id+"_to").val(prop.value);
	else {
//	    console.log(this.type +" macroChanged:" + prop.value +" " + this.display.jq(id).length);
	    this.display.jq(id).val(prop.value);
//	    console.log("after:" + this.display.jq(id).val());
	}
    },
    apply: function(url) {
	if(this.type == "bounds") {
	    if(this.display.getBounds && this.display.jq(this.getId()).is(':checked')) {
		let bounds = this.display.getBounds();
		if(bounds) {
		    bounds = RecordUtil.convertBounds(bounds);
		    ["north","south","east","west"].map(b=>{
			url+="&" + b+"=" +bounds[b];
		    });
		    
		}
	    }
	} else if(this.type=="numeric" || this.type=='number') {
	    let min = this.display.jq(this.getId()+"_min").val()||"";
	    let max = this.display.jq(this.getId()+"_max").val()||"";
	    this.dflt_min = min;
	    this.dflt_max = max;
	    if(Utils.stringDefined(min))
		url = url +"&" + HU.urlArg(this.urlarg+"_from",min);
	    if(Utils.stringDefined(max))
		url = url +"&" + HU.urlArg(this.urlarg+"_to",max);
	    this.display.setProperty("request." +this.name+"_min.default",min);
	    this.display.setProperty("request." +this.name+"_max.default",max);
	} else if(this.type=="daterange") {
	    let from = this.display.jq(this.getId()+"_from").val()||"";
	    let to = this.display.jq(this.getId()+"_to").val()||"";
	    this.dflt_from = from;
	    this.dflt_to = to;
	    this.display.setProperty("request." +this.name+"_from.default",from);
	    this.display.setProperty("request." +this.name+"_to.default",to);
	    if(from!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_fromdate",from);
	    if(to!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_todate",to);
	    //			    this.display.setProperty(this.name+".default",value);
	} else if(this.type=="date") {
	    let from = this.display.jq(this.getId()+"_from").val()||"";
	    this.dflt_from = from;
	    this.display.setProperty("request." +this.name+"_from.default",from);
	    if(from!="")
		url = url +"&" + HU.urlArg(this.urlarg,from);
	} else if(this.type=="enumeration") {
	    let value = this.getValue();
	    if(!Array.isArray(value)) {value=[value];}
	    if(value[0] == "_all_" || value[0] == "_none_" || value[0] == VALUE_NONE) return url;
	    if(value.length>0) {
		let regexp = new RegExp(this.urlarg+"=[^$&]*",'g');
		url = url.replace(regexp,"");
		let values = [];
		value.forEach(v=>{
		    if(this.template) v = this.template.replace(/\${value}/,v);
		    values.push(v);
		});
		if(this.delimiter) {
		    let arg = "";
		    values.forEach((v,idx)=>{
			if(idx>0) arg+=this.delimiter;
			arg+=v;
		    });
		    if(this.multitemplate && values.length>1) {
			arg =this.multitemplate.replace(/\${value}/,arg);
		    }
		    url = url +"&" + HU.urlArg(this.urlarg,arg);
		console.log("URL0:" + url);
		} else {
		    values.forEach(v=>{
			url = url +"&" + HU.urlArg(this.urlarg,v);
		    });
		}
	    } else {
	    }
	} else {
	    let value = this.getValue();
	    this.dflt  = value;
	    if(Utils.stringDefined(value)) {
		let regexp = new RegExp(this.urlarg+"=[^$&]*",'g');
		url = url.replace(regexp,"");
		url = url +"&" + HU.urlArg(this.urlarg,value);
	    }
	}
	return  url;
    }

}





function makeInlineData(display, src) {
    let csv = $("#"+src).html().trim();
    let lines = csv.split("\n");
    let fields = [];
    let samples = lines[1].split(",");
    let latField  =null, lonField=null,dateField=null;
    lines[0].split(",").forEach((tok,idx)=>{
	tok = tok.trim();
	let id = Utils.makeId(tok);
	let label = Utils.makeLabel(tok);
	let type = "string";
	let sample = samples[idx];
	if(display.getProperty(id+".label")) {
	    label =display.getProperty(id+".label");
	}
	if(display.getProperty(id+".type")) {
	    type =  display.getProperty(id+".type");
	    if(type=="enum") type = "enumeration";
	} else {
	    if(id=="date") {
		type="date";
	    } else {
		if(!isNaN(parseFloat(sample))) type = "double";
		//check for numeric
	    }
	}
	let field = new RecordField({
            id:tok,
	    index:idx,
            label:label,
            type:type,
            chartable:true
        });
	fields.push(field);
	if(field.isFieldLatitude()) latField = field;
	else if(field.isFieldLongitude()) lonField = field;
    });
    let records =[];
    lines.forEach((line,idx)=>{
	if(idx==0) return;
	line = line.trim();
	if(line.length==0) return;
	let data =[];
	let lat = NaN;
	let lon = NaN;
	let date = null;
	line.split(",").forEach((tok,col)=>{
	    tok  = tok.replace(/_nl_/g,"\n").replace(/_qt_/g,"\"").replace(/_comma_/g,",");
	    let field = fields[col];
	    if(latField && latField.getIndex()==col) {
		lat = tok = parseFloat(tok);
	    } else  if(lonField && lonField.getIndex()==col) {
		lon = tok = parseFloat(tok);
	    } else  if(dateField && dataField.getIndex()==col) {
		date = tok = new Data(tok);
	    } else {
		if(field.isFieldNumeric()) {
		    tok = parseFloat(tok);
		}
	    }
	    data.push(tok);
	});
	//PointRecord(fields,lat, lon, elevation, time, data)
        records.push(new  PointRecord(fields,lat, lon, NaN, date, data));
    });
    return  new PointData(src, fields, records,"#" + src);
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


var FILTER_ALL = "-all-";

//class: BaseFilter
function BaseFilter(display,properties) {
    this.display = display;
    if (properties == null) properties = {};
    RamaddaUtil.defineMembers(this, {
        properties: properties,
	isEnabled: function() {
	    return true;
	},
	prepareToFilter: function() {
	},
        isRecordOk: function(display, record, values) {
            return true;
        },
	getWidget: function() {return ""},
	initWidget: function(inputFunc) {}
    });
}



//class: BoundsFilter
function BoundsFilter(display, properties) {
    RamaddaUtil.inherit(this, new BaseFilter(display, properties));
    $.extend(this, {
	enabled:true,
	getWidget: function() {
	    let id = this.display.getDomId("boundsfilter");
	    return HtmlUtils.span([ATTR_STYLE,HU.css("margin-left","4px","margin-right","4px"), ID,id,CLASS,"ramadda-clickable", TITLE,"Filter records on map view. Shift-click to clear"], HtmlUtils.getIconImage("fas fa-globe-americas"));
	},
	initWidget: function(inputFunc) {
	    this.inputFunc = inputFunc;
	    let id = this.display.getDomId("boundsfilter");
	    let _this = this;
	    this.display.jq("boundsfilter").click(function(event){
		if (event.shiftKey) {
		    if(!_this.bounds) return;
		    _this.bounds = null;
		} else {
		    _this.bounds = _this.display.getBounds();
		}
		inputFunc($(this),null,_this.bounds);
	    });
	},
	isRecordOk: function(record) {
	    if(!this.bounds) {
		return true;
	    }
	    if(record.hasLocation()) {
		let b = this.bounds;
		let lat = record.getLatitude();
		let lon = record.getLongitude();
		if(lat>b.top || lat<b.bottom || lon <b.left || lon>b.right)
		    return false;
	    }
            return true;
	},
    });
}


//class: RecordFilter
function RecordFilter(display,filterFieldId, properties) {
    const ID_TEXT = "_text_";
    this.id = filterFieldId;
    this.isText = (this.id == ID_TEXT);
    let fields;
    if(this.isText) {
	let f = display.getProperty("textFilterFields");
	if(f) {
	    fields = display.getFieldsByIds(null,f);
	} else {
	    fields = display.getFieldsByType(null, "string");
	}
    } else {
	let filterField = display.getFieldById(null, filterFieldId);
	if(filterField)
	    fields = [filterField];
	else {
	    console.warn("Could not find filter field:" + filterFieldId);
	    this.disabled = true;
	    fields = [];
	}
    }
    $.extend(this, new BaseFilter(display, properties));
    this.getId = function() {
	return this.id;
    }
    let getAttr = (suffix,dflt)=>{
	let key = this.getId()+"." + suffix;
	let v = display.getProperty(key);
	if(!Utils.isDefined(v)) v = display.getProperty(suffix,dflt);
	return v;
    };
    let label = "";
    if(this.isText)  {
	label = getAttr("filterLabel","Search");
    } else  {
	label = getAttr("filterLabel",fields.length>0?fields[0].getLabel():"");
    }
    $.extend(this, {
	fields: fields,
	values:[],
	hideFilterWidget: display.getProperty("hideFilterWidget",false, true),
	displayType:getAttr("filterDisplay","menu"),
	label:   label,
	depends: getAttr("filterDepends",null),
	dateIds: [],
	prefix:display.getProperty(this.getId() +".filterPrefix",""),
	suffix:display.getProperty(this.getId() +".filterSuffix",""),
	startsWith:display.getProperty(this.getId() +".filterStartsWith",false),
	ops:Utils.split(display.getProperty(this.getId() +".filterOps"),";",true,true),
	labelField:display.getFieldById(null,display.getProperty(this.getId() +".labelField"))
    });



    if(this.ops) {
	let tmp = [];
	this.ops.forEach(tok=>{
	    let tuple  = tok.split(",");
	    tmp.push({
		op: tuple[0],
		value: tuple[1],
		label: tuple[2]||this.id+tuple[0] +tuple[1]
	    });
	});
	this.ops = tmp;
    }

    $.extend(this, {
	toString:function() {
	    return "filter:" + this.getId();
	},
	getField: function() {
	    return this.fields[0];
	},
	getFieldId: function() {
	    if(this.fields.length==0) return '';
	    return this.fields[0].getId();
	},	
	getLabel: function() {
	    return this.label;
	},

	getValue: function(record) {
	    if(this.fields.length==1) {
		return record.getValue(this.fields[0].getIndex());
	    } else {
		let v = this.fields.reduce((acc,field)=>{
		    return acc+=" " + record.getValue(field.getIndex());
		},"");
		return v;
	    }
	},
	isFieldNumeric:function() {
	    if(this.isText) return false;
	    if(this.disabled) return false;
	    return this.getField().isNumeric();
	},
	isFieldBoolean:function() {
	    if(this.isText) return false;
	    if(this.disabled) return false;
	    return this.getField().isFieldBoolean();
	},	
	isFieldEnumeration: function() {
	    if(this.isText) return false;
	    if(this.disabled) return false;
	    return this.getField().isFieldEnumeration();
	},
	isFieldText: function() {
	    if(this.isText) return true;
	    if(this.disabled) return false;
	    return this.getField().isFieldAbsoluteString();
	},
	isFieldDate: function() {
	    if(this.disabled) return false;
	    return this.getFieldType()=="date";
	},	
	isFieldMultiEnumeration: function() {
	    if(this.disabled) return false;
	    return this.getField().isFieldMultiEnumeration();
	},
	fieldType:null,
	getFieldType: function() {
	    if(this.disabled) return '';
	    if(this.getField() && !this.fieldType) {
		this.fieldType =  this.display.getProperty(this.getField().getId()+".type",this.getField().getType());
	    }
	    return this.fieldType;
	},
	getFilterId: function(id) {
	    return  this.display.getDomId("filterby_" + (id||this.getId()));
	},
	isEnabled: function() {
	    if(this.disabled) return false;
	    return this.isText || this.getField()!=null;
	},
	recordOk: function(display, record, values) {
            return true;
        },
	propertyCache:{},
	getProperty: function(key, dflt,dontCheckCache) {
	    if(!dontCheckCache) {
		let value = this.propertyCache[key];
		if(value) return value.value;
	    }
	    let v = this.display.getProperty(key, dflt);
	    if(!dontCheckCache) {
		this.propertyCache[key] = {value:v};
	    }
	    return v;
	},
	getPropertyFromUrl: function(key, dflt) {
	    key = this.getId()+'.'+ key;
	    return this.display.getPropertyFromUrl(key, dflt,true);
	},	
	prepareToFilter: function() {
	    this.mySearch = null;
	    if(this.filterIDependOn) {
		this.checkDependency();
	    }

	    if(!this.isEnabled()) {
		console.log('not enabled');
		return;
	    }
	    let value=null;
	    let _values =[];
	    let values=null;
	    let matchers =[];
	    if(this.ops) {
		let v = $("#" + this.getFilterId(this.getId())).val();
		if(v==FILTER_ALL) {
		    this.mySearch = null;
		    return;
		}
		this.mySearch =  {
		    index: parseFloat(v)
		};
		return;
	    } else  if(this.isFieldNumeric()) {
		let minField = $("#" + this.display.getDomId("filterby_" + this.getId()+"_min"));
		let maxField = $("#" + this.display.getDomId("filterby_" + this.getId()+"_max"));
		if(!minField.val() || !maxField.val()) return;
		let minValue = parseFloat(minField.val().trim());
		let maxValue = parseFloat(maxField.val().trim());
		let dfltMinValue = parseFloat(minField.attr("data-min"));
		let dfltMaxValue = parseFloat(maxField.attr("data-max"));
		if(minValue!= dfltMinValue || maxValue!= dfltMaxValue) {
		    value = [minValue,maxValue];
		}
 	    } else if(this.isFieldDate()){
		let date1 = $("#" + this.display.getDomId("filterby_" + this.getId()+"_date_from")).val();
		let date2 = $("#" + this.display.getDomId("filterby_" + this.getId()+"_date_to")).val();
		if(date1!=null && date1.trim()!="") 
		    date1 =  Utils.parseDate(date1);
		else
		    date1=null;
		if(date2!=null && date2.trim()!="") 
		    date2 =  Utils.parseDate(date2);
		else
		    date2=null;
		if(date1!=null || date2!=null)
		    value = [date1,date2]; 
	    }  else {
		values = this.getFieldValues();
		if(!values) {
		    return;
		}
		if(!Array.isArray(values)) values = [values];
		if(values.length==0) {
		    return;
		}
		values = values.map(v=>{
		    return v.replace(/_comma_/g,",");
		});
		values.forEach(v=>{
		    _values.push((""+v).toLowerCase());
		    try {
			matchers.push(new TextMatcher(v));
		    } catch(skipIt){
		    }
		});
	    }
	    let anyValues = value!=null;
	    if(!anyValues && values) {
		values.forEach(v=>{if(v.length>0 && v!= FILTER_ALL)anyValues = true});
	    }
	    //console.log("\t",this+" any values:" + anyValues);
	    if(anyValues) {
		this.mySearch =  {
		    value:value,
		    values:values,
		    matchers:matchers,
		    _values:_values,
		    anyValues:anyValues,
		};
	    } else {
		this.mySearch = null;
	    }
//	    console.log(this +"prepare:" + JSON.stringify(this.mySearch));
	},
	getFilterValues:function() {
	    if(!this.mySearch) this.prepareToFilter();
	    return this.mySearch;
	},
	isRecordOk:function(record,debug) {
	    let ok = true;
	    if(!this.isEnabled() || !this.mySearch) {
		if(debug) {
		    if(!this.isEnabled())
			console.log("\t"+ this+"  not enabled");
		    if(!this.mySearch)
			console.log("\t" + this+"  no mySearch");
		}
		return ok;
	    }
	    let rowValue = this.getValue(record);
	    if(this.ops) {
		let op = this.ops[this.mySearch.index];
		if(op.op=="<") ok =  rowValue<op.value;
		else if(op.op=="<=") ok = rowValue<=op.value;
		else if(op.op==">") ok= rowValue>op.value;
		else if(op.op==">=") ok= rowValue>=op.value;
		else if(op.op=="==") ok= rowValue==op.value;				
	    } else   if(this.isFieldBoolean()) {
		rowValue=String(rowValue);
		ok = this.mySearch.values.includes(rowValue);
	    } else   if(this.isFieldEnumeration()) {
		rowValue=String(rowValue);
		if(this.isFieldMultiEnumeration()) {
 		    ok = false;
		    let values = rowValue.split(",");
		    values.forEach(value=>{
			value=value.trim();
			if(this.mySearch.values.includes(value)) ok = true;
		    });
		} else {
		    ok = this.mySearch.values.includes(rowValue);
		}
	    } else if(this.isFieldNumeric()) {
		if(isNaN(this.mySearch.value[0]) && isNaN(this.mySearch.value[1])) return ok;
		if(isNaN(rowValue) || rowValue=="")  ok =false;
		else if(!isNaN(this.mySearch.value[0]) && rowValue<this.mySearch.value[0]) ok = false;
		else if(!isNaN(this.mySearch.value[1]) && rowValue>this.mySearch.value[1]) ok = false;
	    } else if(this.isFieldDate()){
		if(this.mySearch.value &&  Array.isArray(this.mySearch.value)) {
		    if(rowValue == null) {
			ok = false;
		    }  else  {
			let date1 = this.mySearch.value[0];
			let date2 = this.mySearch.value[1];
			if(!rowValue.getTime) {
			    ok = false;
			}  else {
			    let dttm = rowValue.getTime();
			    if(isNaN(dttm)) ok = false;
			    else if(date1 && dttm<date1.getTime())
				ok = false;
			    else if(date2 && dttm>date2.getTime())
				ok = false;
			}
		    }
		}
	    } else {
		let startsWith = this.startsWith;
		ok = false;
		rowValue  = String(rowValue).toLowerCase();
		for(let j=0;j<this.mySearch._values.length;j++) {
		    let fv = this.mySearch._values[j];
		    if(startsWith) {
			if(rowValue.toString().startsWith(fv)) {
			    ok = true;
			    break;
			}
		    } else  if(rowValue.toString().indexOf(fv)>=0) {
			ok = true;
			break;
		    }
		}


		if(!ok && !startsWith) {
		    for(ri=0;ri<this.mySearch.matchers.length;ri++) {
			let matcher = this.mySearch.matchers[ri];
			if(matcher.matches(rowValue.toString())) {
			    ok = true;
			    break;
			}
		    }
		}
	    }
	    return ok;
	},

	doTags:function() {
	    if(!this.getProperty(this.getId()+".showFilterTags",true)) {
		return false;
	    }
	    let tags =  this.display.getShowFilterTags();
	    return tags;
	},
	doTagsColor:function() {
	    if(!this.getProperty(this.getId()+".colorFilterTags",true)) return false;
	    let tags =  this.getProperty(this.getId()+".colorFilterTags", true) || this.getProperty("colorFilterTags");
	    return tags;
	},

	getFieldValues: function() {
	    if(this.isFieldEnumeration()) {
		if(this.doTags()) {
//		    console.log("\tselected tags: " + this.selectedTags);
		    return this.selectedTags ||[];
		}
	    }
	    let element =$("#" + this.display.getDomId("filterby_" + this.getId()));
	    let value=null;
	    if(element.attr("isCheckbox")) {
		if(element.is(':checked')) {
		    value = element.attr("onValue");
		} else {
		    value = element.attr("offValue");
		}
	    } else if(element.attr("isButton")) {
		value = element.attr("data-value");
	    } else {
		value = element.val();
	    }
	    if(!value) {
		if(this.defaultValue) value = this.defaultValue;
		else value = FILTER_ALL;
	    }
	    if(!Array.isArray(value)) {
		if(!this.isFieldEnumeration()) {
		    value = value.split(",");
		} else {
		    value = [value];
		}
	    }
	    let tmp = [];
	    value.forEach(v=>tmp.push(v.trim()));
	    value = tmp;
	    return value;
	},
	toggleTag:function(value,on,cbx, propagateEvent) {
	    let _this = this;
	    let type  = this.getFilterId();
	    let tagId = Utils.makeId(type +"_" +  value);

	    if(on) {
		if(this.selectedTags.includes(value)) return;
		this.selectedTags = Utils.addUnique(this.selectedTags,value);
		let tagGroup = this.display.jq(ID_TAGBAR).find(".tag-group" +HU.attrSelect("tag-type",this.getFilterId()));
		if(tagGroup.length==0) {
		    let bar;
		    if(this.display.getProperty("tagDiv"))
			bar= $("#"+this.display.getProperty("tagDiv"));
		    else
			bar= this.display.jq(ID_TAGBAR);
		    tagGroup = $(HU.div([ATTR_STYLE,HU.css("display","inline-block"), ATTR_CLASS,"tag-group","tag-type",this.getFilterId()])).appendTo(bar);
		}
		
		let tag = $(HU.div(["metadata-type",type,"metadata-value",value,ATTR_TITLE,value,
				    ATTR_STYLE, HU.css("background", Utils.getEnumColor(this.getFieldId())),CLASS,"display-search-tag", ID,tagId],value+SPACE +HU.getIconImage("fas fa-times"))).appendTo(tagGroup);
		tag.click(function(){
		    _this.selectedTags = Utils.removeElement(_this.selectedTags,value);
		    if(cbx)
			cbx.prop('checked',false);
		    $(this).remove();
		    _this.inputFunc(_this.fakeInput,null,_this.selectedTags);
		});
	    } else {
		this.selectedTags = Utils.removeElement(this.selectedTags,value);
		$("#" + tagId).remove();
	    }
	    if(propagateEvent && this.inputFunc) {
		this.inputFunc(this.fakeInput,null,this.selectedTags);
	    }
	},
	    
	initWidget: function(inputFunc) {
	    let _this= this;
	    if(!this.isEnabled()) return;
	    this.inputFunc = inputFunc;
	    this.fakeInput  = {
		attr:function(key) {
		    return this[key];
		},
		val: function() {return null},
		id: this.getId(),
		fieldId:this.getFieldId()
	    };

	    if(!this.hideFilterWidget && this.getProperty(this.getId()+".filterLive",this.getProperty('filterLive',false))) {
		let widgetId = this.getFilterId(this.getId());
		let widget = $("#" + widgetId);
		if(widget.length) {
		    widget.keyup(function() {
			inputFunc($(this),null,$(this).val());
		    });
		}
	    }

	    let multi = this.getProperty(this.getId() +".filterMultiple",this.getProperty('filterMultiple',false));
	    let showPopupSelect = multi ||this.getProperty(this.getId() +".filterShowPopup",this.getProperty('filterShowPopup'))
	    if(this.isFieldEnumeration() && showPopupSelect) {
		let widgetId = this.getFilterId(this.getId());
		if(!Utils.isDefined(multi)) multi=false;
		HU.makeSelectTagPopup(jqid(widgetId),{
		    wrap:"<span class='ramadda-hoverable;' style='display:inline-block;margin-right:4px;margin-bottom:0px;'>${widget}</span>",
		    single:!multi,
		    makeButtons:multi,
		    makeButton:false,
		    hide:false,after:true,buttonLabel:HU.getIconImage('fas fa-list-check')});
	    }

	    if(!this.hideFilterWidget && this.getProperty(this.getId()+".filterSuggest",false)) {
		let widgetId = this.getFilterId(this.getId());
		let widget = $("#" + widgetId);
		if(widget.length) {
		    widget.keyup(function(e) {
			if(_this.suggestDialog)
			    _this.suggestDialog.remove();
			let input = $(this);
			let v = input.val().toLowerCase();
			let html = '';
			let seen = {};
			_this.records.forEach(r=>{
			    let rv=r.getValueFromField(_this.getId());
			    if(!rv) return;
			    rv =String(rv);
			    if(seen[rv]) return;
			    seen[rv] = true;
			    let _rv = rv.toLowerCase();
			    if(_rv.indexOf(v)>0) {
				html+=HU.div([ATTR_CLASS,'ramadda-clickable',
					      ATTR_STYLE,HU.css('white-space','nowrap','max-width','400px','overflow-x','hidden')],
					      rv);
			    }
			});
			if(html!='') {
			    html = HU.div([ATTR_STYLE,HU.css('max-height','300px','overflow-y','auto','padding','5px')], html);
			    _this.suggestDialog =
				HU.makeDialog({content:html,my:'left top',at:'left bottom',anchor:input});
			    _this.suggestDialog.find('.ramadda-clickable').click(function() {
				_this.suggestDialog.remove();
				_this.suggestDialog=null;
				input.val($(this).html());
				input.focus();
			    });
			}			    

		    });
		}
	    }	    

	    this.initDateWidget(inputFunc);
	    let processDateSelect = (v)=>{
		let now=new Date();
		let from = now;
		let to;
		let widgetId = _this.widgetId;
		if(v=='') {
		    jqid(widgetId+'_date_from').val('');
		    jqid(widgetId+'_date_to').val('');		    
		    inputFunc(jqid(widgetId+'_date_from'),null,{from:'',to:'',select:''});
		    return;
		}
		if(v=='thisyear') {
		    let year  = now.getFullYear();
		    from = new Date(year, 0, 1);
		    to = new Date(year, 11, 31);			
		} else    if(v.startsWith('year_')) {
		    let year = parseInt(v.substring('year_'.length));
		    from = new Date(year, 0, 1);
		    to = new Date(year, 11, 31);			
		} else    if(v=='ytd') {
		    let year  = now.getFullYear();
		    from = new Date(year, 0, 1);
		    to = now;
		} else {
		    let date =Utils.createDateInner(v,now);
		    if(date.getTime()<now.getTime()) {
			from = date; to = now;
		    } else {
			from = now; to = date;
		    }
		}
		from = Utils.formatDateYYYYMMDD(from);
		to = Utils.formatDateYYYYMMDD(to);		    
		jqid(widgetId+'_date_from').val(from);
		jqid(widgetId+'_date_to').val(to);		    
		inputFunc(jqid(widgetId+'_date_from'),null,{from:from,to:to,select:v});
	    };
	    
	    if(this.dateRadiosId) {
		jqid(this.dateRadiosId).find('input:radio').change(function() {
		    processDateSelect($(this).attr('value'));
		});
	    }

	    if(this.dateSelectId) {
		jqid(this.dateSelectId).change(function() {
		    processDateSelect($(this).val());
		});
	    }
	    //	HtmlUtils.initSelect($("#" + this.widgetId));
	    if(this.tagCbxs) {
		let _this = this;
		let cbxChange = function() {
        	    let cbx = $(this);
	            let on = cbx.is(':checked');
		    let value  = $(this).attr("metadata-value");
		    _this.toggleTag(value,on,cbx,true);
		}
		let clickId = this.getFilterId()+"_popup";
		$("#" + clickId).click(()=>{
		    let dialog = this.display.createTagDialog(this.tagCbxs, $("#" + clickId), cbxChange, this.getFilterId(),this.getLabel());
		    dialog.find(".metadata-cbx").each(function() {
			let value = $(this).attr('metadata-value');
			$(this).prop('checked',_this.selectedTags.includes(value));
		    });
		});
	    }

	},
	initDateWidget: function(inputFunc) {
	    if(!this.hideFilterWidget) {
		for(let i=0;i<this.dateIds.length;i++) {
		    let id = this.dateIds[i];
		    HtmlUtils.datePickerInit(id);
		    $("#" + id).change(function(){
			inputFunc($(this));
		    });
		}
	    }
	},
	checkDependency: function() {
	    if(!this.filterIDependOn || !this.records) {
		return;
	    }


	    /*
	    if(!this.dependMySearch || !this.filterIDependOn.mySearch || !this.dependMySearch.values || !this.filterIDependOn.mySearch.values) {
		console.log("checkDependency: not ready:" +  " my search:" + this.dependMySearch);
		return;
	    }

	    let v1 = this.dependMySearch.values;
	    let v2 = this.filterIDependOn.mySearch.values;
	    if(v1.length == v2.length) {
		let equals = true;
		for(let i=0;i<v1.length && equals;i++)
		    equals = v1[i] == v2[i];
		if(equals) return;
	    }
*/
            let enums = this.getEnums(this.records);
	    let widgetId = this.getFilterId(this.getId());
	    let tmp = [];
	    enums.forEach(e=>tmp.push(e.value));
	    this.display.ignoreFilterChange = true;
	    let widget = $("#" + widgetId);
	    let val = widget.val();
	    if(!val) val  = 	widget.attr("data-value");
	    widget.html(HU.makeOptions(tmp,val));
	    this.display.ignoreFilterChange = false;
	},
	handleEventPropertyChanged:function(prop) {
	    if(this.isFieldEnumeration() && this.doTags()) {
		if(this.selectedTags) {
		    let type  = this.getFilterId();
		    this.selectedTags.forEach(value=>{
			let tagId = Utils.makeId(type +"_" +  value);	
			$("#" + tagId).remove();
		    });
		}
		this.selectedTags = [];
		let values = prop.values?prop.values:null;
		if(!values) {
		    if(prop.value) {
			if(Array.isArray(prop.value)) values= prop.value;
			else values[prop.value];
		    } else {
			values=[];
		    }
		}

		prop.value.forEach(value=>{
		    if(value) {
			this.toggleTag(value,true);
		    }
		});
		return;
	    }


	    let id = this.widgetId;
	    if(this.isFieldDate() && prop?.value?.select) {
		jqid(id+'_date_from').val(prop.value.from);
		jqid(id+'_date_to').val(prop.value.to);
		jqid(id+'_date_select').val(prop.value.select);				
		return
	    }
	    if(prop.id && prop.id.endsWith("date_from")) {
		id+="_date_from";
	    } else 	if(prop.id && prop.id.endsWith("date_to")) {
		id+="_date_to";
	    }


	    let widget = $("#"+id);
	    if(widget.attr("isCheckbox")) {
		let on = widget.attr("onValue");
		widget.prop('checked',prop.value.includes(on));
	    } else {
		widget.val(prop.value);
	    }
	    widget.attr("data-value",prop.value);
	    if(widget.attr("isButton")) {
		widget.find(".display-filter-button").removeClass("display-filter-button-selected");
		widget.find("[value='" + prop.value +"']").addClass("display-filter-button-selected");
	    }
	},
	getIncludeAll:function() {
	    return this.getProperty(this.getId() +".includeAll",
			     this.getProperty(this.getId() +".filterIncludeAll",
					      this.getProperty("filterIncludeAll", 
							       this.getProperty("filter.includeAll", true))));
	},
	getWidget: function(fieldMap, bottom,records, vertical) {
	    let labelVertical =   this.getProperty("filterLabelVertical",this.getProperty(this.getId()+".filterLabelVertical",vertical));
	    this.records = records;
	    let debug = false;
	    if(debug) console.log(this.id +".getWidget");
	    if(!this.isEnabled()) {
		if(debug) console.log("\tnot enabled");
		return "";
	    }
	    let widgetStyle = "";
	    if(this.hideFilterWidget)
		widgetStyle = "display:none;";
	    fieldMap[this.getId()] = {
		field: this.fields[0],
		values:[],
	    };
	    let showLabel = true;
            let widget;
	    let widgetId = this.widgetId = this.getFilterId(this.getId());
	    let widgetLabel =   this.getProperty(this.getId()+".filterLabel",this.getLabel());
	    let includeAll = this.getIncludeAll();

            if(this.ops) {
		let labels =[];
		this.ops.forEach((op,idx)=>{
		    labels.push([String(idx),op.label]);
		});

		let selected = this.getPropertyFromUrl('fv',FILTER_ALL);
		let showLabel = this.getProperty(this.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true));
		let allName = this.getProperty(this.getId() +".allName",!showLabel?this.getLabel():"All");
		let enums = Utils.mergeLists([[FILTER_ALL,allName]],labels);
		let attrs= [STYLE,widgetStyle, ID,widgetId,"fieldId",this.getId()];
		widget = HU.select("",attrs,enums,selected);
	    } else   if(this.isFieldBoolean()) {
		let attrs= [STYLE,widgetStyle, ID,widgetId,"fieldId",this.getId()];
		let filterValues = this.getProperty(this.getId()+".filterValues");
                let enums = [];
		let allName = this.getProperty(this.getId() +".allName","-");
		enums.push(['',allName]);
		if(filterValues) {
		    filterValues.split(",").forEach(tok=>{
			let toks = tok.split(":");
			enums.push(toks);
		    });
		} else {
		    enums.push('true','false');
		}

//		let values = filterValues?filterValues.split(","):["-","true","false"];
		widget = HU.select("",attrs,enums,this.dflt);
	    } else   if(this.isFieldEnumeration()) {
		if(debug) console.log("\tis enumeration");
		let filterValue = this.getProperty(this.getId()+".filterValue");
		let dfltValue = this.defaultValue = filterValue?filterValue:
		    this.getPropertyFromUrl('fv',FILTER_ALL);
                let enums = this.getEnums(records);
		let attrs= [ATTR_STYLE,widgetStyle, ATTR_ID,widgetId,"fieldId",this.getId()];
		if(this.getProperty(this.getId() +".filterMultiple",this.getProperty('filterMultiple'))) {
		    attrs.push("multiple");
		    attrs.push("");
		    attrs.push("size");
		    attrs.push(this.getProperty(this.getId() +".filterMultipleSize",
						this.getProperty('filterMultipleSize','3')));
		    dfltValue = dfltValue.split(",");
		}


		if(this.displayType!="menu") {
		    if(debug) console.log("\tnot menu");


		    if(!includeAll && dfltValue == FILTER_ALL) dfltValue = enums[0].value;
		    let buttons = "";
		    let colorMap = Utils.parseMap(this.getProperty(this.getId() +".filterColorByMap"));
		    let useImage = this.displayType == "image";
		    let useButton = this.displayType == "button";
		    let imageAttrs = [];
		    let imageMap = Utils.getNameValue(this.getProperty(this.getId() +".filterImages"));
		    if(useImage) {
			let w = this.getProperty(this.getId() +".filterImageWidth");
			let h = this.getProperty(this.getId() +".filterImageHeight");
			if(h) {
			    imageAttrs.push("height");
			    imageAttrs.push(h);
			}
			if(w) {
			    imageAttrs.push("width");
			    imageAttrs.push(w);
			}
			if(!h && !w) {
			    imageAttrs.push("width");
			    imageAttrs.push("50");
			}
			
			imageAttrs.push(ATTR_STYLE);
			imageAttrs.push(this.getProperty(this.getId() +".filterImageStyle","border-radius:50%;"));
		    }
		    for(let j=0;j<enums.length;j++) {
			let extra = "";
			let v = enums[j].value;
			let color = colorMap?colorMap[v]:null;
			let label;
			if(Array.isArray(v)) {
			    label = v[1];
			    v = v[0];
			} else {
			    label = v;
			}

			let style = this.getProperty(this.getId() +".filterItemStyle","");
			if(color) {
			    style += " background-color:" + color +"; ";
			} else {
			    style += " border:1px solid #ccc; "
			}
			
			let clazz = " ramadda-hoverable ramadda-clickable display-filter-item display-filter-item-" + this.displayType +" ";
			if(useButton) clazz+=" ramadda-button ";
			if(v == dfltValue) {
			    clazz+=  " display-filter-item-" + this.displayType +"-selected ";
			}
			if(v == FILTER_ALL) {
			    extra = " display-filter-item-all ";
			}
			if(useImage) {
			    let image=null;
			    if(imageMap) image = imageMap[v];
			    if(!image || image=="") image = enums[j].image;
			    if(image) {
				buttons+=HtmlUtils.div(["fieldId",this.getId(),ATTR_CLASS,clazz,ATTR_STYLE,style, "data-value",v,ATTR_TITLE,label],
						       HtmlUtils.image(image,imageAttrs));
			    } else {
				buttons+=HtmlUtils.div(["fieldId",this.getId(),ATTR_CLASS,clazz,ATTR_STYLE,style,"data-value",v,ATTR_TITLE,label],label);
			    }
			} else {
			    buttons+=HtmlUtils.div(["fieldId",this.getId(),ATTR_CLASS,clazz, ATTR_STYLE,style,"data-value",v],label);
			}
			buttons+="\n";
		    }


		    if(useImage && this.getProperty(this.getId() +".filterShowButtonsLabel")) {
			buttons+=HtmlUtils.div([ATTR_CLASS,"display-filter-item-label",ATTR_ID,this.display.getDomId("filterby_" + this.getId() +"_label")],"&nbsp;");
		    }
		    bottom[0]+= this.prefix + 
			HtmlUtils.div(["data-value",dfltValue,ATTR_CLASS,"display-filter-items",ATTR_ID,widgetId,"isButton","true", "fieldId",
				       this.getId()], buttons);
		    if(debug) console.log("\treturn 1");
		    return "";
		} else if(this.getProperty(this.getId() +".filterCheckbox")) {
		    if(debug) console.log("\tis checkbox");
		    attrs.push("isCheckbox");
		    attrs.push(true);
		    let tmp = [];
		    enums.map(e=>tmp.push(e.value));
		    let checked = tmp.includes(dfltValue);
		    if(tmp.length>0) {
			attrs.push("onValue");
			attrs.push(tmp[0]);
		    }
		    if(tmp.length>1) {
			attrs.push("offValue");
			attrs.push(tmp[1]);
		    }
		    widget = HtmlUtils.checkbox("",attrs,checked);
		    //			    console.log(widget);
		} else if(this.doTags()) {
		    let doColor = this.doTagsColor();
		    showLabel  =false;
		    let cbxs = [];
		    this.tagToCbx = {};
		    this.selectedTags = [];
		    enums.map((e,idx)=>{
			let count  = e.count;
			let value = e.value;
			let label = value;
			if(Array.isArray(value)) {
			    value = e.value[0];
			    label = e.value[1];
			    if(value === "")
				label = "-blank-";
			}
			let showCount  = true;
			if(count) label = label +(showCount?" (" + count+")":"");
			let cbxId = this.getFilterId() +"_cbx_" + idx;
			this.tagToCbx[value] = cbxId;
			let cbx = HU.checkbox("",[CLASS,"metadata-cbx",ID,cbxId,"metadata-type",this.getFilterId(),"metadata-value",value],false) +" " + HU.tag( "label",  [CLASS,"ramadda-noselect ramadda-clickable","for",cbxId],label);
			cbx = HU.span([CLASS,'display-search-tag','tag',label,STYLE, HU.css("background", Utils.getEnumColor(this.getFieldId()))], cbx);
			cbxs.push(cbx);
		    }); 
		    this.tagCbxs  = cbxs;
		    let clickId = this.getFilterId()+"_popup";
		    let label = " " +this.getLabel()+" ("+ cbxs.length+")";
		    label = label.replace(/ /g,"&nbsp;");
		    let style = HU.css("white-space","nowrap", "line-height","1.5em",  "margin-top","6px","padding-right","5px");
		    if(doColor)
			style+=HU.css("border","1px solid #ccc","background", Utils.getEnumColor(this.getFieldId()));
		    else
			style+=HU.css();
		    widget= HU.div([STYLE, style, TITLE,"Click to select tag", ID,clickId,CLASS,"ramadda-clickable entry-toggleblock-label"], HU.makeToggleImage("fa-solid fa-plus","font-size:8pt;") +label);   
		} else {
		    if(debug) console.log("\tis select");
		    let tmp = [];
		    let showCount = this.getProperty(this.getId()+".filterShowCount",this.getProperty("filterShowCount",true));
		    enums.map(e=>{
			let count  = e.count;
			let v = e.value;
			let label = v;
			if(Array.isArray(v)) {
			    v = e.value[0];
			    label = e.value[1];
			    if(v === "")
				label = "-blank-";
			}
			if(count) label = label +(showCount?" (" + count+")":"");
			tmp.push([v,label]);
		    }); 
                    widget = HtmlUtils.select("",attrs,tmp,dfltValue);
		}
	    } else if(this.isFieldNumeric()) {
		if(debug) console.log("\tis numeric");
		let min=0;
		let max=0;
		let cnt=0;
		records.map(record=>{
		    let value = this.getValue(record);
		    if(isNaN(value))return;
		    if(cnt==0) {min=value;max=value;}
		    else {
			min = Math.min(min, value);
			max = Math.max(max, value);
		    }
		    cnt++;
		});
		let tmpMin = this.getPropertyFromUrl('fvmin',this.getProperty("filterValueMin"));
		let tmpMax = this.getPropertyFromUrl('fvmax',this.getProperty("filterValueMax"));
		let minStyle = "";
		let maxStyle = "";
		let dfltValueMin = min;
		let dfltValueMax = max;
		if(Utils.isDefined(tmpMin)) {
		    minStyle = "background:" + TEXT_HIGHLIGHT_COLOR+";";
		    dfltValueMin = parseFloat(tmpMin);
		}
		if(Utils.isDefined(tmpMax)) {
		    maxStyle = "background:" + TEXT_HIGHLIGHT_COLOR+";";
		    dfltValueMax = parseFloat(tmpMax);
		}

		let size = this.getProperty(this.getId()+'.filterWidgetSize',
					    this.getProperty('filterWidgetSize', '60px'));
		minStyle+=HU.css('width',size);
		maxStyle+=HU.css('width',size);
                widget = HtmlUtils.input('',dfltValueMin,[STYLE,minStyle,'data-type',this.getFieldType(),'data-min',min,ATTR_CLASS,'display-filter-range display-filter-input', ATTR_ID,widgetId+'_min','xsize',3,'fieldId',this.getId()]);
		widget += '-';
                widget += HtmlUtils.input('',dfltValueMax,[STYLE,maxStyle,'data-type',this.getFieldType(),'data-max',max,ATTR_CLASS,'display-filter-range display-filter-input', ATTR_ID,widgetId+'_max','xsize',3,'fieldId',this.getId()]);
	    } else if(this.getFieldType() == 'date') {
                widget =HtmlUtils.datePicker('','',[ATTR_CLASS,'display-filter-input',ATTR_STYLE,widgetStyle, ATTR_ID,widgetId+'_date_from','fieldId',this.getId()]) +'-' +
		    HtmlUtils.datePicker('','',[ATTR_CLASS,'display-filter-input',ATTR_STYLE,widgetStyle, ATTR_ID,widgetId+'_date_to','fieldId',this.getId()]);
		this.dateIds.push(widgetId+'_date_from');
		this.dateIds.push(widgetId+'_date_to');

		let selects = this.getProperty(this.getId()+'.filterDateSelects');

		if(selects) {
		    if(!this.getProperty(this.getId()+'.filterDateShowRange',true)) {
			widget  = HU.span([ATTR_STYLE,'display:none;'], widget);
		    }
		    this.dateSelectId = widgetId+'_date_select';
		    selects = selects.split(",").map(o=>{
			let toks = Utils.split(o,':',true,true);
			if(toks.length==2) return {value:toks[0],label:toks[1]};
			return {value:o,label:o};
		    });
		    let select;
		    if(this.getProperty(this.getId()+'.filterDateShowRadio',false)) {
			this.dateRadiosId = widgetId+'_date_radios';
			let name = HU.getUniqueId('radios_');
			selects = Utils.mergeLists([{value:'',label:'All dates'}],selects);
			select = HU.div([ATTR_ID,this.dateRadiosId,
					 ATTR_STYLE,HU.css('text-align','left')], HU.radioGroup(name, selects));
		    } else {
			selects = Utils.mergeLists([{value:'',label:'Select date'}],selects);
			select= HU.select('',[ATTR_ID,widgetId+'_date_select','ignore',true],selects);
		    }
		    if(labelVertical)
			widget += select;
		    else
			widget=HU.span([],widget)+HU.span([ATTR_STYLE,'margin-left:5px'],select);
		}

            } else {
		let dfltValue = this.getPropertyFromUrl('fv',"");
		let width = this.getProperty(this.getId() +".filterWidth","150px");		
		let attrs =[ATTR_STYLE,widgetStyle+"width:" + HU.getDimension(width), ATTR_ID,widgetId,"fieldId",this.getId(),ATTR_CLASS,"display-filter-input"];
		let placeholder = this.getProperty(this.getId() +".filterPlaceholder");
		attrs.push("width");
		attrs.push(width);
		if(placeholder) {
		    attrs.push("placeholder");
		    attrs.push(placeholder);
		} else {
		    showLabel = false;
		    attrs.push("placeholder");
		    attrs.push(widgetLabel);
		}

		attrs.push("istext",this.isText);
                widget =HU.input("",dfltValue,attrs);
		let values=fieldMap[this.getId()].values;
		let seen = {};
		records.map(record=>{
		    let value = this.getValue(record);
		    if(!seen[value]) {
			seen[value] = true;
			values.push(value);
		    }	
		});
            }
	    if(!this.hideFilterWidget) {
		let tt = widgetLabel;
		if(Utils.stringDefined(this.getField().getDescription())) {
		    tt = tt+HU.getTitleBr() +
			this.getField().getDescription();
		}
		if(widgetLabel.length>50) widgetLabel = widgetLabel.substring(0,49)+"...";
		if(!this.getProperty(this.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true))) {
		    widgetLabel = "";
		}
		else {
		    if(!Utils.stringDefined(widgetLabel)) widgetLabel = "";
		    else widgetLabel = widgetLabel+": ";
		}
		widgetLabel = this.display.makeFilterLabel(widgetLabel,tt,labelVertical);
		if(labelVertical) widgetLabel = widgetLabel+"<br>";
		if(vertical) {
		    widget = HtmlUtils.div([],(showLabel?widgetLabel:"") + widget+this.suffix);
		} else {
		    widget = HtmlUtils.div([ATTR_STYLE,"display:inline-block;"],(showLabel?widgetLabel:"") + widget+this.suffix);
		}
	    }
	    if(!vertical)
		widget= widget +(this.hideFilterWidget?"":"&nbsp;&nbsp;");
	    if(this.prefix) widget = this.prefix+widget;

	    let show = this.getProperty(this.getId() +".filterShow",this.getProperty("filterShow",true));
	    if(!show) widget=HU.div([ATTR_STYLE,'display:none;'], widget);

	    return widget;
	},
	getWidgetId:function() {
	    return this.widgetId;
	},
	getEnums: function(records) {
	    let counts = {};
	    let isMulti  = this.isFieldMultiEnumeration();
	    records.forEach((record,idx)=>{
		let value = this.getValue(record);
		if(value ===null) return;
		value = String(value);
		let values = isMulti?value.split(","):[value];
		values.forEach(v=>{
		    v =v.trim ();
		    if(!counts[v]) counts[v]=1;
		    else   counts[v]++;
		});
	    });

	    let enums = null;
	    let filterValues = this.getProperty(this.getId()+".filterValues");
	    let showLabel = this.getProperty(this.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true));

	    if (filterValues) {
		let toks;
		if ((typeof filterValues) == "string") {
		    filterValues = Utils.getMacro(filterValues);
		    toks = filterValues.split(",");
		} else {
		    toks = filterValues;
		}
		enums=[];
		toks.map(tok=>{
		    let tmp = tok.split(":");
		    if(tmp.length>1) {
			tok = [tmp[0],tmp[1]];
		    } else if(tok == FILTER_ALL) {
			let allName = this.getProperty(this.getId() +".allName",!showLabel?this.getLabel():"All");
			tok = [tmp[0],allName];
		    } else {
			tok = [tok,tok];
		    }
		    let count = counts[tok[0]];
		    enums.push({value:tok,count:count});
		})
	    }
	    if(enums == null) {
		let depends = this.getProperty(this.getId() +".depends");
		this.filterIDependOn = !depends?null:this.display.getRecordFilter(depends);
		let allName = this.getProperty(this.getId() +".allName",!showLabel?this.getLabel():"All");
		allName+=' (' + records.length+')'
		enums = [];
		let includeAll = this.getIncludeAll();
//		if(includeAll && !this.getProperty(this.getId() +".filterLabel",null,true)) {
		if(includeAll) {
		    enums.push({value:[FILTER_ALL,allName]});
		}
		let seen = {};
		let dflt = this.getField().getEnumeratedValues();
		if(dflt) {
		    for(let v in dflt) {
			seen[v] = true;
			let count = counts[v];
			enums.push({value:[v,dflt[v]],count:count});
		    }
		}
		let enumValues = [];
		let imageField=this.display.getFieldByType(null, "image");
		let valuesAreNumbers = true;

		if(this.filterIDependOn) {
		    this.filterIDependOn.prepareToFilter();
//		    console.log('getEnums: dependencys search info:',this.filterIDependOn.mySearch)
		}

		records.forEach((record,idx)=>{
		    if(this.filterIDependOn) {
			if(!this.filterIDependOn.isRecordOk(record)) return;
		    }
		    let value =this.getValue(record);
		    let values;
		    if(isMulti) {
			values = value.split(",").map(v=>{return v.trim();});
		    } else {
			values = [value];
		    }

		    values.forEach(value=>{
			if(seen[value]) return;
			seen[value]  = true;
			let obj = {};
			if(imageField)
			    obj.image = this.display.getDataValues(record)[imageField.getIndex()];
			if((+value+"") != value) valuesAreNumbers = false;
			let label = value;
			if(label.length>30) {
			    label=  label.substring(0,29)+"...";
			}
			if(this.labelField) {
			    label += " - " + this.labelField.getValue(record);
			    console.log("l:" + label);
			}


			if(typeof value == "string")
			    value = value.replace(/\'/g,"&apos;");
			let tuple = [value, label];
			obj.value = tuple;
			obj.count =  counts[value];

			enumValues.push(obj);
		    });
		});


		let sortCount =this.getProperty(this.getId() +".filterSortCount",this.getProperty('filterSortCount'));
		if(sortCount ||
		   this.getProperty(this.getId() +".filterSort",this.getProperty('filterSort',true))) {
		    let sort = this.getProperty(this.getId() +".filterSort",this.getProperty('filterSort',false));
		    if(!sort) 
			sortCount  = this.getProperty(this.getId() +".filterSortCount",this.getProperty('filterSortCount',true));
		    enumValues.forEach(e=>{
			if(!Utils.isDefined(e.count)) e.count=0;
		    });

		    enumValues.sort((a,b)  =>{
			if(sortCount) {
			    if(b.count!=a.count) {
				return b.count-a.count;
			    }				
			}
			a= a.value;
			b = b.value;
			if(valuesAreNumbers) {
			    return +a - +b;
			}
			return (""+a[1]).localeCompare(""+b[1]);
		    });
		}
		for(let j=0;j<enumValues.length;j++) {
		    let v = enumValues[j];
		    enums.push(v);
		}
	    }
	    return enums;
	}
	
    });
}

RecordFilter.prototype = {
    toString:function() {
	return 'RecordFilter:' + this.id;
    }
}


//class: MonthFilter
function MonthFilter(param) {
    RamaddaUtil.inherit(this, new BaseFilter());
    RamaddaUtil.defineMembers(this, {
        months: param.split(","),

        recordOk: function(display, record, values) {
            for (i in this.months) {
                let month = this.months[i];
                let date = record.getDate();
                if (date == null) return false;
                if (date.getMonth == null) {
                    //console.log("bad date:" + date);
                    return false;
                }
                if (date.getMonth() == month) return true;
            }
            return false;
        }
    });
}


function TextMatcher (pattern,myId) {
    this.myId = myId;
    this.regexps=[];
    if(pattern) {
        pattern = pattern.trim();
    }
    if(pattern && pattern.length>0) {
        pattern = pattern.replace(/\./g,"\\.");
        if(pattern.startsWith('"') && pattern.endsWith('"')) {
            pattern  = pattern.replace(/^"/,"");
            pattern  = pattern.replace(/"$/,"");
            this.regexps.push(new RegExp("(" + pattern + ")","ig"));
        } else {
            pattern.split(" ").map(p=>{
                p = p.trim();
		try {
		    //check if the string has a regep fragment
		    if(p.includes('(') || p.includes(')')) {
		    } else {
			this.regexps.push(new RegExp("(" + p + ")","ig"));
		    }
		} catch(err) {
		    console.log('Error creating pattern matcher:' + err,p);
		}
            });
        }
    }   
    $.extend(this, {
        pattern: pattern,
        hasPattern: function() {
            return this.regexps.length>0;
        },
        highlight: function(text,id) {
	    if(id && this.myId && id!=this.myId) return text;
            for(var i=0;i<this.regexps.length;i++) {
                text  =  text.replace(this.regexps[i], "<span style=background:yellow;>$1</span>");
            }
            return text;
        },
        matches: function(text) {
            if(this.regexps.length==0) return true;
            text  = text.toLowerCase();
            for(var i=0;i<this.regexps.length;i++) {
                if(!text.match(this.regexps[i])) return false;
            }
            return true;
        }
    });

}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/



const DISPLAY_LINECHART = "linechart";
const DISPLAY_AREACHART = "areachart";
const DISPLAY_BARCHART = "barchart";
const DISPLAY_BARTABLE = "bartable";
const DISPLAY_BARSTACK = "barstack";
const DISPLAY_PIECHART = "piechart";
const DISPLAY_TIMERANGECHART = "timerangechart";
const DISPLAY_SANKEY = "sankey";
const DISPLAY_CALENDAR = "calendar";
const DISPLAY_SCATTERPLOT = "scatterplot";
const DISPLAY_HISTOGRAM = "histogram";
const DISPLAY_BUBBLE = "bubble";
const DISPLAY_GAUGE = "gauge";
const DISPLAY_TABLE = "table";
const DISPLAY_WORDTREE = "wordtree";
const DISPLAY_TREEMAP = "treemap";
const DISPLAY_ORGCHART = "orgchart";
const ID_CHART = "chart";
const ID_CHARTS = "charts";
const ID_CHARTS_INNER = "chartsinner";


var ramaddaChartInfo = {
    debug:false,
    version:"51",
    loading:false,
    chartsHaveLoaded:false,
    pending:[],
    packages:{}
};
function haveGoogleChartsLoaded(callback) {
    //    console.log("haveGoogleChartsLoaded");
    if(ramaddaChartInfo.chartsHaveLoaded) {
	if(callback) callback();
	return true;
    }
    if(callback) {
	ramaddaChartInfo.pending.push(callback);
    }
    if(!window["google"]) {
	if(ramaddaChartInfo.debug)
	    console.log("\tno google");
	if(ramaddaChartInfo.loading) {
	    return false;
	}
	ramaddaChartInfo.loading = true;
	Utils.loadScript('https://www.gstatic.com/charts/loader.js',()=>{
	    if(ramaddaChartInfo.debug)
		console.log("loader.js loaded calling google.charts.load version:" + ramaddaChartInfo.version);
	    google.charts.load(ramaddaChartInfo.version, {
		packages: ['corechart']
	    });
	    //	    console.log("calling setOnLoadCallback");
	    google.charts.setOnLoadCallback(() =>{
		if(ramaddaChartInfo.debug)
		    console.log("core chart loaded");
		ramaddaChartInfo.chartsHaveLoaded = true;
		ramaddaChartInfo.pending.forEach(callback=>{
		    if(ramaddaChartInfo.debug)
			console.log("\tcalling callback");
		    callback();
		});
		ramaddaChartInfo.pendingDisplays = [];
	    });
	});
    }
}


function ramaddaLoadGoogleChart(what, callback) {
    let package = ramaddaChartInfo.packages[what];
    if(!package)
	package = ramaddaChartInfo.packages[what] ={
	    loading:false,
	    loaded:false,
	    pending:[]
	};
    if(!package.loaded) {
	if(callback)
	    package.pending.push(callback);
	if (!package.loading) {
	    package.loading = true;
	    if(ramaddaChartInfo.debug)
		console.log("calling google.charts.load:" + what);
	    google.charts.load(ramaddaChartInfo.version, {
		packages: [what],
		callback:()=>{
		    if(ramaddaChartInfo.debug)
			console.log("google.charts.load callback:" + what +" pending:" + package.pending.length);
		    package.loaded = true;
		    package.pending.forEach(callback=>callback());
		}
	    });
	}
	return false;
    }
    return true;
}



addGlobalDisplayType({
    type: DISPLAY_TABLE,
    label: "Table",
    category: CATEGORY_TABLE,
    desc:"Basic tabular display",
    preview: "table.png"}, true);
addGlobalDisplayType({
    type: DISPLAY_LINECHART,
    label: "Line Chart",
    category: CATEGORY_CHARTS,
    preview:"linechart.png",
    desc:"Show time series or other data",
    helpurl:true
});
addGlobalDisplayType({
    type: DISPLAY_BARCHART,
    label: "Bar Chart",
    category: CATEGORY_CHARTS,
    preview:'barchart.png'
});
addGlobalDisplayType({
    type: DISPLAY_BARSTACK,
    label: "Stacked Bar Chart",
    category: CATEGORY_CHARTS,
    preview:'barstack.png',
    helpurl:true    
});
addGlobalDisplayType({
    type: DISPLAY_AREACHART,
    label: "Area Chart",
    category: CATEGORY_CHARTS,
    preview:'areachart.png',
});

addGlobalDisplayType({
    type: DISPLAY_BARTABLE,
    label: "Bar Table",
    category: CATEGORY_CHARTS,
    preview:'bartable.png'
});
addGlobalDisplayType({
    type: DISPLAY_SCATTERPLOT,
    label: "Scatter Plot",
    category: CATEGORY_CHARTS,
    preview: 'scatterplot.png'
});
addGlobalDisplayType({
    type: DISPLAY_HISTOGRAM,
    label: "Histogram",
    category: CATEGORY_CHARTS,
    preview: 'histogram.png'
});
addGlobalDisplayType({
    type: DISPLAY_BUBBLE,
    label: "Bubble Chart",
    category: CATEGORY_CHARTS,
    preview: 'bubblechart.png'
});
addGlobalDisplayType({
    type: DISPLAY_PIECHART,
    label: "Pie Chart",
    category: CATEGORY_CHARTS,
    preview: 'piechart.png'                    
});

addGlobalDisplayType({
    type: DISPLAY_GAUGE,
    label: "Gauge",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    preview: "gauge.png"
});
addGlobalDisplayType({
    type: DISPLAY_TIMERANGECHART,
    label: "Time Range",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    preview: 'timerange.png',
    desc:'Show data with start/end times'    
});
addGlobalDisplayType({
    type: DISPLAY_SANKEY,
    label: "Sankey Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    preview: "sankey.png"                                    
});

addGlobalDisplayType({
    type: DISPLAY_CALENDAR,
    label: "Calendar Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    preview: "calendar.png"
});
addGlobalDisplayType({
    type: DISPLAY_WORDTREE,
    label: "Word Tree",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    preview: "wordtree.png",
    desc:"Specify a number of fields. Each field value is a level in the tree"    
});
addGlobalDisplayType({
    type: DISPLAY_TREEMAP,
    label: "Tree Map",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    preview: "treemap.png"    
});

addGlobalDisplayType({
    type: DISPLAY_ORGCHART,
    label: "Org Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    preview: "orgchart.png"                                
});




let PROP_CHART_MIN = "chartMin";
let PROP_CHART_MAX = "chartMax";
let DFLT_WIDTH = "600px";
let DFLT_HEIGHT = "200px";

/*
  Create a chart
  id - the id of this chart. Has to correspond to a div tag id 
  pointData - A PointData object (see below)
*/
function RamaddaGoogleChart(displayManager, id, chartType, properties) {
    const ID_TRENDS_CBX = "trends_cbx";
    const ID_PERCENT_CBX = "percent_cbx";
    const ID_COLORS = "colors";
    const ID_HIGHLIGHTFIELDSHOLDER = "highlightfieldsholder";
    const ID_HIGHLIGHTFIELDS = "highlightfields";	    
    let _this = this;
    if(!Utils.isDefined(properties['sortOnDate']))
	properties['sortOnDate'] = true;
    //Init the defaults first
    $.extend(this, {
	debugChartOptions:false,
	useTestData:false,	
        indexField: -1,
        curveType: 'none',
        fontSize: 0,
        showPercent: false,
        percentFields: null,
    });
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, chartType, properties);
    let myProps = [
	{label:'Chart Style'},
	{p:'chartWidth',ex:''},
	{p:'chartHeight',ex:''},
	{p:'chartLeft',d:0},
	{p:'chartRight',d:0},
	{p:'chartTop',d:10,ex:'0'},
	{p:'chartBottom',ex:'0',d:0},

	{p:'textFontSize',ex:12},
	{p:'textBold',ex:true},
	{p:'textItalic',ex:true},
	{p:'textColor',ex:'green'},
	{p:'textFontName',ex:'Times'},
	
	{p:'hAxisTitle'},
	{p:'vAxisTitle'},	
	{p:'hAxisHideTicks'},
	{p:'vAxisHideTicks'},	
	{p:'lineDashStyle',d:null,ex:'2,2,20,2,20'},
	{p:'highlight.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},
	{p:'nohighlight.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},	
	{p:'some_field.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},

	{p:'labelInLegend',ex:'label'},
	{p:'highlight.labelInLegend',d:null,ex:'label',canCache:true},
	{p:'nohighlight.labelInLegend',d:null,ex:'label',canCache:true},	
	{p:'some_field.labelInLegend',d:null,ex:'label',canCache:true},
	{p:'tooltipStyle',ex:'min-width:600px;'},
	{p:'tooltipX',tt:'Fix the tooltip position',ex:'0'},
	{p:'tooltipY',tt:'Fix the tooltip position',ex:'0'},		

	{p:'highlightFields',d:null,ex:'fields'},
	{p:'highlightShowFields',d:null,ex:'true'},
	{p:'highlightShowFieldsSize',d:"4",ex:'4'},
	{p:"acceptHighlightFieldsEvent",d:true,ex:'true'},
	{p:'highlightDim',d:'true',ex:'true',tt:'Dim the non highlight lines'},


	{p:'seriesType',d:null,ex:'line|area|bars',canCache:true},
	{p:'highlight.seriesType',d:null,ex:'line|area|bars',canCache:true},
	{p:'nohighlight.seriesType',d:null,ex:'line|area|bars',canCache:true},	
	{p:'some_field.seriesType',d:null,ex:'line|area|bars'},	

	{p:'pointSize',d:0,ex:'0'},
	{p:'highlight.pointSize',d:0,ex:'4'},
	{p:'nohighlight.pointSize',d:0,ex:'4'},	
	{p:'some_field.pointSize',d:'4',ex:'4'},

	{p:'lineWidth',d:null,ex:null},
	{p:'highlight.lineWidth',d:null,ex:'2'},
	{p:'nohighlight.lineWidth',d:null,ex:'2'},	
	{p:'some_field.lineWidth',d:'2',ex:'2'},

	{p:'highlight.color',d:null,ex:null},
	{p:'nohighlight.color',d:null,ex:null},
	{p:'some_field.color',d:null,ex:null},


	{p:'pointShape',d:null,ex:'circle|triangle|square|diamond|star'},
	{p:'highlight.pointShape',d:null,ex:'circle|triangle|square|diamond|star'},
	{p:'nohighlight.pointShape',d:null,ex:'circle|triangle|square|diamond|star'},	
	{p:'some_field.pointShape',d:null,ex:'circle|triangle|square|diamond|star'},

	{p:'dragToZoom',d:true},
	{p:'dragToPan',d:false},	

	{p:'showUnit',ex:false},
	{p:'dynamicTooltip',ex:'true',d:true,tt:'Dynamically create the tooltips'},

	{p:'skipMissing',d:false,ex:'true',tt:'skip rows  that have any missing values'},
	{p:'replaceNanWithZero'},
	{p:'maxColumns',d:-1},
	{p:'interpolateNulls',d:true,ex:'true'},
	{p:'animateChart',ex:true},
	{p:'animationDuration',d:500},
	{p:'animationEasing',d:'linear'},
	{label:'Trendlines'},
	{p:'showTrendLines',d:null,ex:"true"},
	{p:"trendlineType",ex:"exponential"},
	{p:"trendlineVisibleInLegend",ex:"true"},
	{p:"trendlineColor",d:"red"},
	{p:"trendlineLineWidth",ex:"2"},
	{p:"trendlineOpacity",ex:"0.3"},		    		    		    

	{label:'Annotations'},
	{p:'annotations',
	 ex:'date,label,desc;date,label,desc;',tt:'e.g. 2008-09-29,A,Start of housing crash;2008-11-04,B,Obama elected;'},
	{p:'showAnnotationsLegend',ex:true},
 	{p:'annotationFields',ex:'',tt:'Set of fields to add an annotation to the line chart'},
 	{p:'annotationStride',ex:10,tt:'Only show every N annotations'},
 	{p:'annotationLabelField',ex:'field',tt:'Field to use for annotation label'},		
 	{p:'annotationTemplate',ex:'"${field}',tt:'Template to use'},		
 	{p:'annotationLabelTemplate',ex:'"${field}',tt:'Template to use for label'},		
	{p:'annotationStyle',d:'point',ex:'line|point'},
	{p:'annotationSize',ex:'18'},
	{p:'annotationColor',d:'black',ex:'red'},
	{p:'annotationAuraColor',ex:'gray'},
	{p:'annotationBold',ex:true},
	{p:'annotationItalic',ex:true},
	{p:'annotationStemColor',d:'red'}
	


    ];
    this.debugTimes = false;


    this.isGoogleChart = true;
    defineDisplay(this, SUPER, myProps, {

	showFieldsInDialog: function() {
	    return true;
	},
	checkFinished: function() {
	    return true;
	},
	useDisplayMessage:function() {
	    return true;
	},
	//Override so we don't include the expandable class
	getContentsClass: function() {
	    return "display-contents-inner display-" + this.type;
	},

        useChartableFields: function() {
            return true;
        },
        defaultSelectedToAll: function() {
            return false;
        },
	getRequiredPackages: function() {
	    return [];
	},
	chartCallbackPending: false,
        updateUI: function(args) {
	    let callback = this.chartCallbackPending?null:()=>{
		//		console.log(this.type +".updateUI: charts loaded");
		this.updateUI();
	    };
	    this.chartCallbackPending=true;
	    if(!haveGoogleChartsLoaded(callback)) {
		return;
	    }

	    let required = this.getRequiredPackages();
	    if(required.length>0) {
		if(!this.packageLoading) this.packageLoading = {};
		let gotPackages  = required.length;
		//		console.log(this.type+" loading packages:" + required);
		required.forEach(pkg=> {
		    let callback = this.packageLoading[pkg]?null:()=>{
			//			console.log(this.type+" package loaded callback");
			this.updateUI();
		    };
		    if(ramaddaLoadGoogleChart(pkg,callback)) {
			gotPackages--;
		    }
		});
		if(gotPackages>0) return;
	    }
	    args = args || {};
            SUPER.updateUI.call(this, args);
	    //	    console.log(this.type +".updateUI: ready");

	    this.updateUIInner(args);
	},
	updateUIInner: function(args) {
	    let debug = false;
	    if(debug)
		console.log(this.type+".updateUI")
            if (!this.getDisplayReady()) {
		if(debug)
		    console.log("\tdisplay not ready");
                return;
            }
	    if(debug)
		console.log("\tcalling displayData");
	    if(args.dataFilterChanged) {
		//this.setDisplayMessage(this.getLoadingMessage());
		setTimeout(()=>{
		    this.displayData(args.reload, debug);
		},1);
		return;
	    }
            this.displayData(args.reload, debug);
        },
        getWikiAttributes: function(attrs) {
            this.defineWikiAttributes(["vAxisMinValue", "vAxisMaxValue",'vAxisExplicit']);
            SUPER.getWikiAttributes.call(this, attrs);
            if (this.colorList.join(",") != "blue,red,green") {
                attrs.push("colors");
                attrs.push(this.getColorList().join(", "));
            }
        },

        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function(e) {
                if (e && e.which != 13 && e.which!=0) {
                    return;
                }
                _this.vAxisMinValue = Utils.toFloat(_this.jq("vaxismin").val());
		//		console.log("vaxis:" + _this.vAxisMinValue + " " + this.getVAxisMinValue());
                _this.vAxisMaxValue = Utils.toFloat(_this.jq("vaxismax").val());
                _this.minDate = _this.jq("mindate").val();
                _this.maxDate = _this.jq("maxdate").val();
                _this.displayData();

            };
	    ["vaxismin","vaxismax","mindate","maxdate"].map(f=>{
		this.jq(f).blur(updateFunc);
		this.jq(f).keypress(updateFunc);
	    });



            this.jq(ID_COLORS).keypress(function(e) {
                if (e.which != 13) {
                    return;
                }
                let v = _this.jq(ID_COLORS).val();
                _this.colorList = v.split(",");
                _this.displayData();
                let pointData = _this.dataCollection.getList();
                _this.getDisplayManager().handleEventPointDataLoaded(_this, _this.lastPointData);
            });

            this.jq(ID_TRENDS_CBX).click(function() {
                _this.setProperty('showTrendLines', _this.jq(ID_TRENDS_CBX).is(':checked'));
                _this.displayData();

            });
            this.jq(ID_PERCENT_CBX).click(function() {
                _this.showPercent = _this.jq(ID_PERCENT_CBX).is(':checked');
                _this.displayData();

            });

        },
        setColor: function() {
            let v = prompt("Enter comma separated list of colors to use", this.colorList.join(","));
            if (v != null) {
                this.colorList = v.split(",");
                this.displayData();
                let pointData = this.dataCollection.getList();
                this.getDisplayManager().handleEventPointDataLoaded(this, this.lastPointData);
            }
        },
        getVAxisMinValue: function() {
            return parseFloat(this.getProperty("vAxisMinValue", NaN));
        },
        getVAxisMaxValue: function() {
            return parseFloat(this.getProperty("vAxisMaxValue", NaN));
        },
	getHAxisMinValue: function() {
            return parseFloat(this.getProperty("hAxisMinValue", NaN));
        },
        getHAxisMaxValue: function() {
            return parseFloat(this.getProperty("hAxisMaxValue", NaN));
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            //                menuItems.push(HU.onClick(get+".setColor();", "Set color"));

            let min = "0";
            if (!isNaN(this.getVAxisMinValue())) {
                min = "" + this.getVAxisMinValue();
            }
            let max = "";
            if (!isNaN(this.getVAxisMaxValue())) {
                max = "" + this.getVAxisMaxValue();
            }

            let tmp = HU.formTable();
            tmp += HU.formEntry("Axis Range:", HU.input("", min, ["size", "7", ATTR_ID, this.domId("vaxismin")]) + " - " +
				HU.input("", max, ["size", "7", ATTR_ID, this.domId("vaxismax")]));
            tmp += HU.formEntry("Date Range:", HU.input("", this.minDate, ["size", "10", ATTR_ID, this.domId("mindate")]) + " - " +
				HU.input("", this.maxDate, ["size", "10", ATTR_ID, this.domId("maxdate")]));


            tmp += HU.formEntry("Colors:",
				HU.input("", this.getColorList().join(","), ["size", "35", ATTR_ID, this.domId(ID_COLORS)]));
            tmp += "</table>";
            menuItems.push(tmp);

        },
        getChartType: function() {
            return this.getType();
        },
        askMinZAxis: function() {
            this.setMinZAxis(prompt("Minimum axis value", "0"));
        },
        setMinZAxis: function(v) {
            if (v != null) {
                this.vAxisMinValue = parseFloat(v);
                this.displayData();
            }
        },
        askMaxZAxis: function() {
            this.setMaxZAxis(prompt("Maximum axis value", "100"));
        },
        setMaxZAxis: function(v) {
            if (v != null) {
                this.vAxisMaxValue = parseFloat(v);
                this.displayData();
            }
        },
        askMinDate: function() {
            let ex = this.minDate;
            if (ex == null || ex == "") {
                ex = "1800-01-01";
            }
            let v = prompt("Minimum date", ex);
            if (v == null) return;
            this.setMinDate(v);
        },
        setMinDate: function(v) {
            this.minDate = v;
            this.displayData();
        },
        askMaxDate: function() {
            let ex = this.maxDate;
            if (ex == null || ex == "") {
                ex = "2100-01-01";
            }
            let v = prompt("Maximum date", ex);
            if (v == null) return;
            this.setMaxDate(v);
        },
        setMaxDate: function(v) {
            this.maxDate = v;
            this.displayData();
        },
        trendLineEnabled: function() {
            return false;
        },
        getDialogContents: function(tabTitles, tabContents) {
            let height = "600";
            let html = HU.div([ATTR_ID, this.domId(ID_FIELDS), STYLE, HU.css('overflow-y','auto','max-height', height + "px")], "  ");
            if (this.trendLineEnabled()) {
                html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Other");

                html += HU.checkbox(this.domId(ID_TRENDS_CBX),
				    [],
				    this.getShowTrendLines(),"Show trend line");
                html += " ";
                html += HU.checkbox(this.domId(ID_PERCENT_CBX),
				    [],
				    this.showPercent,"Show percent of displayed total");
                html += "<br>";
            }

            tabTitles.push("Fields");
            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },
        okToHandleEventRecordSelection: function() {
            return true;
        },
        handleEventRecordHighlight: function(source, args) {
	    this.handleEventRecordSelection(source, args);
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
            //TODO: don't do this in index space, do it in time or space space
            if (source == this) {
                return;
            }
            if (!this.okToHandleEventRecordSelection()) {
                return;
	    }
	    let index = this.findMatchingIndex(args.record).index
	    if(index<0 || !Utils.isDefined(index)) {
		return;
	    }
	    this.setChartSelection(index);
        },
        getFieldsToSelect: function(pointData) {
	    if(this.convertedFields) return this.convertedFields;
	    return pointData.getRecordFields();
        },
        canDoGroupBy: function() {
            return false;
        },
        clearCache: function() {
        },
        googleChartCallbackPending: false,
        includeIndexInData: function() {
            return false;
        },
        getGroupBy: function() {
            return this.getProperty("groupByField");
        },
        getIncludeIndexIfDate: function() {
            return false;
        },
	makeIndexValue: function(indexField, value, offset) {
	    if(indexField.isString()) {
		return  {v:offset,f:value};
	    } 
	    if(value && value.getTime) {
		return  {v:value,f:this.formatDate(value)}
	    }
	    return value;
	},
	getFieldsToDisplay: function(fields) {
	    return fields;
	},

        displayData: function(reload, debug) {
	    this.displayDataInner(reload,debug);
	},


        displayDataInner: function(reload, debug) {
	    if(this.dataLoadFailed) {
		return;
	    } 


	    if(debug)
		console.log(this.type +" displayData " + this.getId() +" " + this.type);

	    let isExpanded = this.jq(ID_CHART).attr("isexpanded");
	    let originalHeight = this.jq(ID_CHART).attr("original-height");
	    if(isExpanded==="true") {
		this.setProperty("expandedHeight",this.jq(ID_CHART).css("height"));
		this.setProperty("isExpanded",true);
		this.setProperty("originalHeight",originalHeight);
	    } else {
		this.setProperty("expandedHeight",null);
		this.setProperty("isExpanded",false);
		this.setProperty("originalHeight",null);
	    }
            if (!this.getDisplayReady()) {
		if(debug)
		    console.log("\tdisplay not ready");
                return;
            }
            if (this.inError) {
		if(debug)
		    console.log("\tin error");
                return;
            }
            if (!haveGoogleChartsLoaded()) {
		if(debug)
		    console.log("\tgoogle charts have not loaded callback pending:" +this.googleChartCallbackPending);
                if (!this.googleChartCallbackPending) {
                    this.googleChartCallbackPending = true;
		    this.setDisplayMessage(this.getLoadingMessage());
                    setTimeout(()=> {
                        this.googleChartCallbackPending = false;
                        this.displayData();
                    }, 100);
                }
                return;
            }
            if (this.inError) {
                return;
            }
            if (!this.hasData()) {
		this.clearChart();
		this.setDisplayMessage(this.getLoadingMessage());
                return;
            }

	    if(!this.getAcceptEventDataSelection()) {
		this.setDisplayMessage("Creating display...");
	    }

            //            let selectedFields = this.getSelectedFields(this.getFieldsToSelect(pointData));
	    let records =this.filterData();
            let selectedFields = this.getSelectedFields();
	    
	    if(debug)
		console.log("\tpointData #records:" +records.length);

	    if(debug)
		console.log("\tselectedFields:" + selectedFields);

            if (selectedFields.length == 0 && this.lastSelectedFields != null) {
                selectedFields = this.lastSelectedFields;
		if(debug)
		    console.log("\tusing last selectedFields:" + selectedFields);
            }



            if (selectedFields == null || selectedFields.length == 0) {
                if (this.getChartType() == DISPLAY_TABLE || this.getChartType() == DISPLAY_TREEMAP) {
		    selectedFields = this.getFields().filter(field=>{
			return !field.isFieldGeo();
		    })
		    if(debug)
			console.log("\tfields from data collection:" + selectedFields);
                } else {
                    selectedFields = this.getSelectedFields();
		    if(debug)
			console.log("\tgetSelectedFields again:" + selectedFields);
		    

		    if(selectedFields.length==0) {
			this.getFields().every(f=>{
			    if(f.isNumeric() && !f.isFieldGeo()) {
				selectedFields = [f];
				return false;
			    }
			    return true;
			});

		    }
                }
            }




            if (selectedFields.length == 0) {
		if(!this.getAcceptEventDataSelection()) {
		    //                    this.setContents("No fields selected");
		    this.setDisplayMessage("No fields selected");
		}
                return;
            }


            //Check for the skip
            let tmpFields = [];
            for (let i = 0; i < selectedFields.length; i++) {
                if (!this.shouldSkipField(selectedFields[i])) {
                    tmpFields.push(selectedFields[i]);
                }
            }
            selectedFields = tmpFields;
	    if(debug)
		console.log("\tsetting lastSelectedFields:" + selectedFields);
            this.lastSelectedFields = selectedFields;
	    //Do this here because the title, if displayed, may hold a {field} macro
	    //that doesn't get set before we've loaded the data
	    if(this.lastSelectedFields && this.lastSelectedFields.length>0) {
		this.jq(ID_TITLE_FIELD).html(this.lastSelectedFields[0].getLabel(this));
	    }

	    let maxColumns = this.getMaxColumns(-1);
	    if(maxColumns>0) {
		let tmp = [];
		selectedFields.every((f,idx)=>{
		    if(idx>=maxColumns) return false;
		    tmp.push(f)
		    return true;
		});
		selectedFields=tmp;
	    }


            let props = {
                includeIndex: this.includeIndexInData()
            };
            props.groupByIndex = -1;

            let groupBy = this.getGroupBy();
            if (groupBy) {
		this.getFields().every(field=>{
                    if (field.getId() == groupBy) {
                        props.groupByIndex = field.getIndex();
                        props.groupByField = field;
			return false;
                    }
		    return true;
                });
            }

            let fieldsToSelect = selectedFields;
            if (this.raw) {
                fieldsToSelect = this.dataCollection.getList()[0].getRecordFields();
                props.raw = true;
            }

            props.includeIndexIfDate = this.getIncludeIndexIfDate();

            let dataHasIndex = props.includeIndex;

	    let t1= new Date();
	    fieldsToSelect = this.getFieldsToDisplay(fieldsToSelect);
            let dataList = this.getStandardData(fieldsToSelect, props);
	    let t2= new Date();
	    if(this.debugTimes)
		Utils.displayTimes("chart.getStandardData",[t1,t2],true);

	    if(debug)
		console.log(this.type +" fields:" + fieldsToSelect.length +" dataList:" + dataList.length);
            if (dataList.length == 0 && !this.userHasSelectedAField) {
                let pointData = this.dataCollection.getList()[0];
                let chartableFields = this.getFieldsToSelect(pointData);
                for (let i = 0; i < chartableFields.length; i++) {
                    let field = chartableFields[i];
                    dataList = this.getStandardData([field], props);
                    if (dataList.length > 0) {
                        this.setSelectedFields([field]);
                        break;
                    }
                }
            }

            if (dataList.length == 0) {
		this.setContents(this.getMessage(this.getNoDataMessage()));
		//                this.setDisplayMessage(this.getNoDataMessage());
                return;
            }

            if (this.showPercent) {
                let newList = [];
                let isNumber = [];
                let isOk = [];
                let headerRow = null;
                let fields = null;
                if (this.percentFields != null) {
                    fields = this.percentFields.split(",");
                }
                for (let i = 0; i < dataList.length; i++) {
                    let row = this.getDataValues(dataList[i]);
                    if (i == 0) {
                        headerRow = row;
                        continue;
                    }
                    if (i == 1) {
                        let seenIndex = false;
                        for (let j = 0; j < row.length; j++) {
                            let valueIsNumber = (typeof row[j] == "number");
                            let valueIsDate = (typeof row[j] == "object");
                            if (valueIsNumber) {
                                if (dataHasIndex && !seenIndex) {
				    valueIsNumber = false;
                                    seenIndex = true;
                                }
                            }
                            if (valueIsDate) {
                                seenIndex = true;
                            }
                            if (valueIsNumber && fields != null) {
                                valueIsNumber = fields.indexOf(fieldsToSelect[j].getId()) >= 0 ||
                                    fields.indexOf("#" + (j + 1)) >= 0;
                            }
                            isNumber.push(valueIsNumber);
                        }
                        let newHeader = [];
                        for (let j = 0; j < headerRow.length; j++) {
                            let v = headerRow[j];
                            if (!isNumber[j]) {
                                newHeader.push(v);
                            } else {
                                newHeader.push("% " + v);
                            }
                        }
                        newList.push(newHeader);
                    }

                    let total = 0;
                    let cnt = 0;
                    for (let j = 0; j < row.length; j++) {
                        if (isNumber[j]) {
                            total += parseFloat(row[j]);
                            cnt++;
                        }
                    }
                    let newRow = [];
                    for (let j = 0; j < row.length; j++) {
                        if (isNumber[j]) {
                            if (total != 0) {
                                let v = parseFloat(((row[j] / total) * 100).toFixed(1));
                                newRow.push(v);
                            } else {
                                newRow.push(NaN);
                            }
                        } else {
                            newRow.push(row[j]);
                        }
                    }
                    newList.push(newRow);
                }
                dataList = newList;
            }
            try {
		this.clearDisplayMessage();
		let tt1 =new Date();
                this.makeGoogleChart(dataList, props, selectedFields);
		let tt2 =new Date();
		if(this.debugTimes)
		    Utils.displayTimes("chart.makeGoogleChart",[tt1,tt2],true);
            } catch (e) {
		this.handleError("Error making chart:" + e,e);
		this.setIsFinished();
                return;
            }

	    this.setIsFinished();
            let container = this.jq(ID_CHART);
	    if(this.jq(ID_CHART).is(':visible')) {
		this.lastWidth = container.width();
	    } else {
		this.lastWidth = -1;
	    }

	    if(reload) {
		let pointData = this.getData();
		if(pointData) {
		    let dataList = pointData.getRecords();
		    if(dataList.length>0) {
			let record = dataList[0];
			this.propagateEventRecordSelection({record: record});
		    }
		}
	    }
        },
        printDataList: function(dataList) {
            console.log("data list:" + dataList.length);
            for (let i = 0; i < dataList.length; i++) {
                let row = dataList[i];
                let s = "";
                for (let j = 0; j < row.length; j++) {
                    if (j > 0) s += ", ";
                    s += row[j];
                }
                console.log("row: " + i + "  " + s);
            }
        },
	mapCharts: function(func) {
            if (this.charts != null) {
		this.charts.map(chart=>{
		    func(chart);
		});
	    }
	},
        clearChart: function() {
	    if(this.chart) {
		this.chart.clearChart();
		this.chart = null;
	    }
	    this.mapCharts(chart=>{
		if(chart.clearChart) {
		    chart.clearChart();
		}
	    });
	    this.charts = [];
        },
        setChartSelection: function(index) {
	    if(!Array.isArray(index)) {
		index=[index];
	    }
	    let selection=index.map(i=>{
		return {
                    row: i,
		    column:null
		}
	    });
	    this.mapCharts(chart=>{
                if (chart.setSelection) {
		    chart.setSelection(selection);
		}});
	    
        },
        tableHeaderMouseover: function(i, tooltip) {},
	doAddTooltip: function() {
	    return true;
	},
	getAddStyle: function() {
	    return true;
	},
	getFormatNumbers: function() {
	    return false;
	},
        getDataTableValueGetter: function() {
	    return (v)=>{return v;}
	},
	getHighlightFields:function() {
	    let p = this.getPropertyFromUrl("highlightFields");
	    return  Utils.split(this.getPropertyFromUrl("highlightFields"),",",true,true)||[];
	},
        handleEventPropertyChanged: function(source, prop) {
	    if(prop.property == "dateRange") {
		let index1=this.findClosestDate(prop.minDate).index;
		let index2=this.findClosestDate(prop.maxDate).index;		
		if(index1>=0) {
		    if(this.getAcceptDateRange()) {
			this.setChartSelection([index1,index2]);
		    }
		}
	    } else    if(prop.property == "highlightFields") {
		if(this.getProperty("acceptHighlightFieldsEvent",true)) {
		    this.setProperty("highlightFields",prop.value);
		    this.forceUpdateUI();
		    let v = Utils.split(prop.value,",",true,true);
		    this.jq(ID_HIGHLIGHTFIELDS).val(v);
		}
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this, source,prop);
	},
	makeSeriesInfo: function(dataTable) {
	    let seriesNames =[];
	    //Assume first one is the index
	    for(let i=1;i<dataTable.getNumberOfColumns();i++) {
		//Styles, etc
		if(dataTable.getColumnRole(i)!="") continue;
		seriesNames.push(dataTable.getColumnLabel(i));
	    }
	    let colors = this.getColorList();
	    let highlightMap  ={};
	    let highlightFields = this.getHighlightFields();
	    let highlightDim = this.getProperty("highlightDim",false);
	    highlightFields.forEach(f=>{highlightMap[f] = true});
	    let seriesInfo = {};
            let useMultipleAxes = this.getProperty("useMultipleAxes", true);
	    let extraMap = {};
	    this.getExtraLines().forEach(info=>{
		let id = Utils.makeId(info.label);
		extraMap[id] = info;
	    });
	    seriesNames.forEach((name,idx)=>{
		name = name.replace(/\(.*\)/g,"");
		//check for the formatted label
		if(name.indexOf('<')>=0) return;
		let id = Utils.makeId(name);
		let highlight = highlightMap[id];
		let s = {
		};
		["labelInLegend", "seriesType","lineDashStyle","pointSize", "lineWidth","color","pointShape"].forEach(a=>{
		    let dflt = this.getProperty((highlight?"highlight.":"nohighlight.") + a,this.getProperty(a));
		    if(a=='pointSize') dflt = this.getPointSize();
		    let value = this.getProperty(id+"." + a,null);

		    if(!Utils.isDefined(value)) {
			value = this.getProperty(id.replace(/_/g,'')+"." + a,null);
		    }

		    if(!Utils.isDefined(value))
			value = dflt;


		    if(extraMap[id] && extraMap[id][a]) {
			value =extraMap[id][a];
		    }
		    

		    if(Utils.isDefined(value) && a=="lineDashStyle") {
			let tmp = [];
			let delim = ",";
			if(value.indexOf(";")>=0) delim=";";
			Utils.split(value,delim,true,true).forEach(tok=>{
			    tmp.push(parseFloat(tok));
			});
			value=tmp;
		    }
		    if(a=="seriesType") a = "type";
		    s[a] = value;
		});
		if(!s.color) s.color = colors[idx%colors.length];
		if(highlightFields.length>0) {
		    if(!highlight && highlightDim) {
			s.color = Utils.pSBC(0.75,s.color);
		    }
		}
		if (useMultipleAxes) {
		    if(idx%2==0) {
			s.targetAxisIndex=0;
		    }  else  {
			s.targetAxisIndex=1;
		    }
		}
		seriesInfo[idx] = s;
	    });



	    if(this.getProperty("highlightShowFields",false)) {
		if(this.jq(ID_HIGHLIGHTFIELDSHOLDER).length==0) {
		    this.jq(ID_HEADER2).append(HU.span([ID,this.domId(ID_HIGHLIGHTFIELDSHOLDER)]));
		}
		
		if(this.jq(ID_HIGHLIGHTFIELDS).length==0) {
		    let seriesValues = [];
		    seriesNames.forEach(n=>{
			seriesValues.push([Utils.makeId(n),n]);
		    });
		    seriesValues.sort((a,b)=>{
			return a[1].localeCompare(b[1]);
			
		    });
		    let highlightWidget = SPACE + HU.vbox(["Highlight",
							   HU.select("",[ID,this.domId(ID_HIGHLIGHTFIELDS),"multiple","true","size",this.getProperty("highlightShowFieldsSize","3")],seriesValues,highlightFields)]);
		    let select =  HU.span([CLASS,"display-filter",STYLE,""],highlightWidget);
		    this.jq(ID_HIGHLIGHTFIELDSHOLDER).html(select);
		    this.jq(ID_HIGHLIGHTFIELDS).change(()=>{
			let v = Utils.makeArray(this.jq(ID_HIGHLIGHTFIELDS).val());
			v = Utils.join(v,",");
			this.setProperty("highlightFields",v);
			this.addToDocumentUrl("highlightFields",v);
			this.forceUpdateUI();
			let props = {
			    property: "highlightFields",
			    value:v
			};
			this.propagateEvent(DisplayEvent.propertyChanged, props);
		    });
		}
	    }
	    //	    console.log(JSON.stringify(seriesInfo,null,2));
	    return seriesInfo;
	},
	
	makeTrendlinesInfo: function(dataTable) {
	    let seriesNames =[];
	    //Assume first one is the index
	    for(let i=1;i<dataTable.getNumberOfColumns();i++) {
		//Styles, etc
		if(dataTable.getColumnRole(i)!="") continue;
		seriesNames.push(dataTable.getColumnLabel(i));
	    }
	    let trendlinesInfo = {};
	    seriesNames.forEach((name,idx)=> {
		let id = Utils.makeId(name);
		if(this.getProperty("showTrendline." + id, this.getShowTrendLines())) {
		    let s = {
		    };
		    trendlinesInfo[idx] = s;
		    s.type = this.getProperty("trendlineType." + id,this.getProperty("trendlineType"));
		    s.visibleInLegend = this.getProperty("trendlineVisibleInLegend." + id,this.getProperty("trendlineVisibleInLegend"));
		    s.color = this.getProperty("trendlineColor." + id,
					       this.getProperty("trendlineColor","red"));
		    s.lineWidth = this.getProperty("trendlineLineWidth." + id,this.getProperty("trendlineLineWidth",2));
		    s.opacity = this.getProperty("trendlineOpacity." + id,this.getProperty("trendlineOpacity"));
		}
	    });
	    return trendlinesInfo;
	},
	getExtraLines:function() {
	    if(this.extraLines) return this.extraLines;
	    this.extraLines = [];
	    let idx=0;
	    while(this.getProperty('fixedLine'+idx)) {
		let info = {
		    color: 'blue',
		    lineWidth: 2,
		    label: '',
		    value: 0,
		};
		Utils.split(this.getProperty('fixedLine'+idx),",",true,true).forEach(tok=>{
		    let tuple = Utils.split(tok,':');
		    if(tuple.length!=2) return;
		    let key = tuple[0];
		    let value = tuple[1];
		    if(key=='value') {
			info.value=+value;
		    } else {
			info[key] = value;
		    }
		});
		if(!isNaN(info.value)) {
		    this.extraLines.push(info);
		}
		idx++;
	    }
	    return this.extraLines;
	},
        makeDataTable: function(dataList, props, selectedFields, chartOptions) {
	    let extraLines = this.getExtraLines();
	    let indexIsString = this.getProperty("indexIsString", this.getProperty("forceStrings",false));
	    let useStringInLegend = this.getProperty("useStringInLegend");

	    this.getPropertyCount=0;
	    this.getPropertyCounts={};
	    let dateType = this.getProperty("dateType","date");
	    let debug =    false || displayDebug.makeDataTable;
//	    debug=true
	    let debugRows = 1;
	    debugRows = 2;
	    if(debug) this.logMsg(this.type+" makeDataTable #records:" + dataList.length);
	    //    if(debug) console.log(selectedFields.map(f=>{return f.getId()+'-'+f.getLabel()}));
	    let replaceNanWithZero = this.getReplaceNanWithZero();

	    let maxWidth = this.getProperty("maxFieldLength",this.getProperty("maxFieldWidth",-1));
	    let tt = this.getProperty('tooltip');
	    let addTooltip = (Utils.stringDefined(tt));
	    if(!this.getProperty("addTooltip",true) || !this.doAddTooltip()) {
		addTooltip=false;
	    }
	    if(this.getDoDyamicTooltip()) {
		addTooltip = false;
	    }
    	    let addStyle= this.getAddStyle();
	    let annotationTemplate = this.getAnnotationTemplate();
	    let formatNumbers = this.getFormatNumbers();
            if (dataList.length == 1) {
		return google.visualization.arrayToDataTable(this.makeDataArray(dataList));
            }

	    let groupField = this.getFieldById(null,  this.getProperty("groupBy"));
	    if(groupField) {
		dataList = this.filterData();
		let groupedData =[];
		let groupValues = [];
		let seen = {};
		let cnt =0;
		let dateToValue =  {};
		let dates = [];
		if(debug)console.log("\trecord[0]:" + dataList[0]);

		dataList.map((record,idx)=>{
		    if(cnt++==0) return;
		    let values = this.getDataValues(record);
		    let value = values[groupField.getIndex()];
		    if(!seen[value]) {
			seen[value]  = true;
			seen[Utils.makeId(value)]  = true;			
			groupValues.push(value);
		    }
		    let newValues =dateToValue[record.getDate()];
		    if(!newValues) {
			dates.push(record.getDate());
			newValues = {};
			dateToValue[record.getDate()] = newValues;
		    }
		    newValues[value] = values[selectedFields[0].getIndex()];
		});

		let data = [];
		let tmp = [];
		let highlightFields = this.getHighlightFields();
		let tmpMap ={};
		highlightFields.forEach(f=>{
		    if(seen[f]) {
			tmp.push(Utils.makeLabel(f));
		    }
		});

		groupValues = Utils.mergeLists(tmp,groupValues);
		groupValues = groupValues.filter(v=>{
		    if(tmpMap[v]) return false;
		    tmpMap[v] = true;
		    return true;
		});
		dates.map(date=>{
		    let tuple=[this.getDateValue(date)];
		    data.push(tuple);
		    let valueMap = dateToValue[date];
		    groupValues.map(group=>{
			let value = valueMap[group];
			tuple.push(value);
		    });
		});

		let header = Utils.mergeLists(["Date"],groupValues);
		if(debug)console.log("\theader:" + header);
		let dataTable = new google.visualization.DataTable();
		if(data.length>0) {
		    //TODO: figure out type of columns with null values
		    let tuple = data[0];
		    tuple.forEach((t,idx)=>{
			let name = header[idx];
			let type = t==null?"number":(typeof t);
			if(type =="number") {
			    if(debug)console.log("\tadd column:" + name+ " type: number");
			    dataTable.addColumn("number", name);
			} else if(type =="string") {
			    if(debug)console.log("\tadd column:" + name+ " type: string");
			    dataTable.addColumn("string", name);
			} else if(t.getTime || (t.v && t.v.getTime)) {
			    if(debug)console.log("\tadd column:" + name+ " type: date");
			    dataTable.addColumn("date", name);
			} else {
			    console.log("\tUnknown type:" + t);
			    console.log(JSON.stringify(t,null,2));
			}
		    });
		}
		dataTable.addRows(data);
		if(chartOptions) {
		    chartOptions.series = this.makeSeriesInfo(dataTable);
		    chartOptions.trendlines = this.makeTrendlinesInfo(dataTable);
		}
		return dataTable;
	    }

            let justData = [];
            let tooltipFields = this.getFieldsByIds(null,this.getProperty("tooltipFields", ""));
            let dataTable = new google.visualization.DataTable();
            let header = this.getDataValues(dataList[0]);
            let sample = this.getDataValues(dataList[1]);
	    let fixedValueS = this.getProperty("fixedValue");
	    let fixedValueN  = fixedValueS?parseFloat(fixedValueS):NaN;
	    let fIdx = 0;
	    let maxHeaderLength = this.getProperty("maxHeaderLength",-1);
	    let maxHeaderWidth = this.getProperty("maxHeaderWidth",-1);
	    let headerStyle= this.getProperty("chartHeaderStyle");
            for (let colIdx = 0; colIdx < header.length; colIdx++) {
		let field=null;
		if(colIdx>0 || !props.includeIndex) {
		    field = selectedFields[fIdx++];
		} else {
		    //todo?
		}
                let value = sample[colIdx];
		let headerLabel = header[colIdx];
		if(maxHeaderLength>0 && headerLabel.length>maxHeaderLength) {
		    let orig = headerLabel;
		    headerLabel = headerLabel.substring(0,maxHeaderLength-1)+"...";
		    headerLabel = HU.span([TITLE,orig], headerLabel);
		}
		if(maxHeaderWidth>0 || headerStyle) {
		    let orig = headerLabel;
		    let style = "";
		    if(maxHeaderWidth>0)
			headerLabel = headerLabel.replace(/ /g,"&nbsp;");
		    if(maxHeaderWidth>0)
			style+="max-width:" + maxHeaderWidth +"px;overflow-x:auto;";
		    if(headerStyle)
			style+=headerStyle;
		    headerLabel = HU.div([TITLE,orig,STYLE,style], headerLabel);
		} 
                if (colIdx == 0 && props.includeIndex) {
                    //This might be a number or a date
                    if ((typeof value) == "object") {
                        //assume its a date
 			if(typeof value.v == "number") {
			    if(indexIsString)  {
				if(debug)console.log("\tadd column:" + headerLabel+ " type: string");
				if(useStringInLegend)
				    dataTable.addColumn('string', headerLabel);
				else
				    dataTable.addColumn('number', headerLabel);

			    }   else {
				if(debug)console.log("\tadd column:" + headerLabel+ " type: number");
				dataTable.addColumn('number', headerLabel);
			    }
			} else {
			    if(debug)console.log("\tadd column:" + headerLabel+ " type: " + dateType);
			    dataTable.addColumn(dateType, headerLabel);
			}
                    } else {
			if(debug)console.log("\tadd column:" + headerLabel+ " type: " + (typeof value) +" sample:" + value);
                        dataTable.addColumn((typeof value), headerLabel);
                    }
                } else {
		    if(colIdx>0 && fixedValueS) {
			if(debug)console.log("\tadd column: fixedValue type: number");
			dataTable.addColumn('number', this.getProperty("fixedValueLabel","Count"));
		    } else {
			if(field.isString() || field.isBoolean()) {
			    if(debug)console.log("\tadd column: " + headerLabel +" type: string");
			    dataTable.addColumn('string', headerLabel);
			} else if(field.isFieldDate()) {
			    if(debug)console.log("\tadd column: " + headerLabel +" type: " + dateType);
			    dataTable.addColumn(dateType, headerLabel);
			} else {
			    if(debug)console.log("\tadd column: " + headerLabel +" type: number");
			    dataTable.addColumn('number', headerLabel);
			}
		    }
		    this.extraLines.forEach(info=>{
			dataTable.addColumn('number', info.label);
		    });
		    if(annotationTemplate) {
			if(debug)console.log("\tadd column: annotation");
			dataTable.addColumn({
			    type: 'string',
			    role: 'annotation',
			    id: 'annotation',
			    'p': {
				'html': true
			    }
			});
		    }

		    if(addStyle) {
			if(debug)
			    console.log("\tadd style column");
			dataTable.addColumn({ type: 'string', role: ATTR_STYLE });
		    }
		    if(colIdx>0 && fixedValueS) {
			break;
		    }
                }


		if(addTooltip) {
		    if(debug)
			console.log("\tadd tooltip column");
		    dataTable.addColumn({
			type: 'string',
			role: 'tooltip',
			'p': {
			    'html': true
			}
		    });
		}
	    }

	    if(debug) {
		console.log("columns:");
		for(let i=0;i<dataTable.getNumberOfColumns();i++)
		    console.log("\tcol[" + i +"]=" + dataTable.getColumnLabel(i) +" role:" +
				dataTable.getColumnRole(i)+
				" type:" + dataTable.getColumnType(i));
	    }

	    let annotationStride = this.getAnnotationStride(0);
	    let annotationLabelTemplate = this.getAnnotationLabelTemplate();
	    let annotationCnt = 0;	    
	    if(Utils.stringDefined(this.getProperty("annotations")) ||
	       Utils.stringDefined(this.getProperty("annotationFields"))) {
		let clonedList = Utils.cloneList(dataList);
		clonedList.shift();
		this.annotations  = new Annotations(this,clonedList);

		if(this.annotations.hasFields()) {
                    dataTable.addColumn({
			type: 'string',
			role: 'annotation',
			id: 'annotation',
			'p': {
                            'html': true
			}
                    });
		    dataTable.addColumn({
			type: 'string',
			role: 'annotationText',
			'p': {
                            'html': true
			}
                    });
		}
	    }

	    if(this.annotations?.isEnabled()) {
		if(this.annotations.getShowLegend()) {
		    //Pad the left to align with  the chart axis
		    this.jq(ID_LEGEND).html("<table width=100%><tr valign=top><td width=10%></td><td width=90%>" +
					    HU.div([ATTR_CLASS, "display-chart-legend"],this.annotations.getLegend())
					    +"</td></tr></table>");
		}
//xxxx

		dataTable.addColumn({
                    type: 'string',
                    role: 'annotation',
		    id: 'annotation',
                    'p': {
                        'html': true
                    }
                });
		dataTable.addColumn({
                    type: 'string',
                    role: 'annotationText',
                    'p': {
                        'html': true
                    }
                });
	    }


	    let times = [new Date()];
	    let records = [];
            for (let i = 1; i < dataList.length; i++) {
		records.push(dataList[i].record);
	    }
	    let colors =  this.getColorTable(true);
            let colorBy = this.getColorByInfo(records);
	    let valueGetter = this.getDataTableValueGetter(records);
	    let didColorBy = false;
	    let tuples = [];
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
		let record =dataList[rowIdx];
                let row = this.getDataValues(record);
		//		let index = row[0];
		//		if(index.v) index  = index.v;
		let theRecord = record.record;
		let color = "";
                if (colorBy.index >= 0) {
                    let value = theRecord.getData()[colorBy.index];
		    hasColorByValue  = true;
		    colorByValue = value;
                    didColorBy = true;
		    color =  colorBy.getColorFromRecord(theRecord);
                }

                row = row.slice(0);
                let newRow = [];
		if(debug && rowIdx<debugRows)
		    console.log("row[" + rowIdx+"]:");

		let fIdx=0;
		let rowOk = true;
		let skipMissing = this.getSkipMissing();
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
		    let field = selectedFields[fIdx++];
                    let value = row[colIdx];
		    //		    if(rowIdx==1)			console.log("\tcol:" + colIdx +" value:", value,' type:'+(typeof value));
		    if(indexIsString) {
			if(Utils.isDefined(value.f)) {
			    let s = (value.f).toString().replace(/\n/g, " ");
			    if(s.trim().length==0) s='<blank>';
			    if(maxWidth>0 && s.length>maxWidth)
				s = s.substring(0,maxWidth) +"...";
			    value.f = s;
			}
		    }
		    if(colIdx>0 && fixedValueS) {
			newRow.push(valueGetter(fixedValueN, colIdx, field, theRecord));
			if(debug && rowIdx<debugRows)
			    console.log("\t fixed:" + fixedValueN);
		    } else {
			let type = (typeof value);
			if(type == "number") {
			    if(skipMissing && isNaN(value)) {
				rowOk = false;
				break;
			    }
			    if(formatNumbers) {
				value = {v:value,f:String(this.formatNumber(value))};
				if(replaceNanWithZero && isNaN(value.v)) value.v=0
			    }
			}  else if(type=="boolean") {
			    value = String(value);
			}
			if(debug && rowIdx<debugRows) {
			    let v = value.f?("f:" + value.f +" v:" +value.v):value;
			    //			    console.log("\t value[" + colIdx +"]=",v," " + (typeof value));
			}
			if(maxWidth>0 && type == "string" && value.length > maxWidth)
			    value = value.substring(0,maxWidth) +"...";
			let o = valueGetter(value, colIdx, field, theRecord);
			if(colIdx==0 && useStringInLegend) {
			    if(Utils.isDefined(o.f)) o=o.f;
			}
			newRow.push(o);
		    }
                    if (colIdx == 0 && props.includeIndex) {
			/*note to self - an inline comment breaks the minifier 
			  if the index so don't add a tooltip */
                    } else {
			extraLines.forEach(info=>{
			    newRow.push(info.value);
			});

			if(annotationTemplate) {
			    let v = annotationTemplate.replace("${value}",value.f||value);
			    if(debug && rowIdx<debugRows)
				console.log("\t annotation" + v);
			    newRow.push(v);
			}
			if(addStyle) {
			    newRow.push(color);
			    if(debug && rowIdx<debugRows)
				console.log("\t color:" + color);
			}
                    }
		    if(colIdx>0 && fixedValueS) {
			break;
		    }
		    if(addTooltip) {
			let tooltip = "";
			if(tt) {
			    tooltip  = this.getRecordHtml(theRecord,null,tt);
			} else {
			    let label = "";
			    if (theRecord) {
				for (let j = 0; j < tooltipFields.length; j++) {
				    label += "<b>" + tooltipFields[j].getLabel(this) + "</b>: " +
					theRecord.getValue(tooltipFields[j].getIndex()) + "<br>";
				}
			    }
			    tooltip += label;
			    for (let j = 0; j < row.length; j++) {
				if (j > 0)
				    tooltip += "<br>";
				label = header[j].replace(/ /g, "&nbsp;");
				value = row[j];
				if (!Utils.isDefined(value)) value = "NA";
				if (value && value.f) {
				    value = value.f;
				}
				
				if (Utils.isNumber(value)) {
				    value = this.formatNumber(value);
				}
				value = "" + value;
				value = value.replace(/ /g, SPACE);
				tooltip += HU.b(label) + ":" + SPACE + value;
			    }
			}
			tooltip = HU.div([ATTR_STYLE,HU.css('padding','8px')],tooltip);
			newRow.push(tooltip);
			if(debug && rowIdx<debugRows)
			    console.log("\t added tooltip");
		    }



		}

		if(!rowOk) continue;



		if(this.annotations?.hasFields()) {
                    if (theRecord) {
			let desc = "";
			this.annotations.getFields().forEach(f=>{
			    let d = HU.b(f.getLabel())+': '+f.getValue(theRecord);
			    if(d!="")
				desc+= (d+"<br>");
			});
			desc = desc.trim();
			desc = desc.replace(/ /g,"&nbsp;");
			annotationCnt++;
			let label = null; 
			if(annotationLabelTemplate) {
			    label = this.applyRecordTemplate(theRecord, null, null,annotationLabelTemplate);
			} else {
			    if(desc.trim().length>0) {
				label =""+(this.annotations.labelField?theRecord.getValue(this.annotations.labelField.getIndex()):("#"+annotationCnt))
				if(label.trim().length==0) label = "#"+annotationCnt;
			    }
			}
			//			debug =true;
			if(debug && rowIdx<debugRows) {
			    console.log("\t label:" + label);
			    console.log("\t desc:" + desc);
			}


			if(annotationStride<=0 || (annotationCnt%annotationStride)==0) {
			    newRow.push(label);
			    newRow.push(desc);
			} else {
			    newRow.push(null);
			    newRow.push(null);

			}
		    } else {
			if(i<2)
			    console.log("No records for annotation");
		    }
		}
		if(this.annotations &&  this.annotations.isEnabled()) {
		    let annotations = this.annotations.getAnnotationsFor(rowIdx);
		    if(annotations) {
			if(debug && rowIdx<debugRows) {
			    console.log("\t annotation:" + annotations);
			}
			let label = "";
			let desc = "";
			annotations.forEach(a=>{
			    if(label!="") label+="/";
			    label+=a.label;
			    if(desc!="") desc+="<br>";
			    else {
				if(a.record && a.record.getDate()) {
				    desc+=HU.b(this.formatDate(a.record.getDate()))+"<br>";
				}
			    }
			    desc+=a.description;			    
			});
			newRow.push(label);
			newRow.push(desc);
		    } else {
			if(debug && rowIdx<debugRows) {
			    console.log("\t annotation:" + "null");
			    console.log("\t desc:" + "null");
			}
			newRow.push(null);
			newRow.push(null);
		    }
		    debug =false;
		}
		//		if(justData.length<4)   console.log(newRow);
                justData.push(newRow);
	    }

	    if(debug)
		console.log("#rows:" + justData.length);

	    times.push(new Date());
            dataTable.addRows(justData);
            if (didColorBy) {
		colorBy.displayColorTable();
            }
	    if(chartOptions) {
		//Only make the series if it isn't stacked
		if(!chartOptions.isStacked) {
		    chartOptions.series = this.makeSeriesInfo(dataTable);
		}
		chartOptions.trendlines = this.makeTrendlinesInfo(dataTable);
	    }

	    if(this.debugTimes)
		Utils.displayTimes("makeDataTable",times,true);
            return dataTable;
        },
        makeChartOptions: function(dataList, props, selectedFields) {
            let chartOptions = {
		annotations: {
		    style: this.getAnnotationStyle(),
		    textStyle: {
			fontSize: this.getAnnotationSize(16),
			color: this.getAnnotationColor(),
			auraColor: this.getAnnotationAuraColor(),
			bold: this.getAnnotationBold(),
			italic: this.getAnnotationItalic(),
		    },
		    stem: {
			color: this.getAnnotationStemColor(),
			length: 100
		    }
		},
		interpolateNulls: this.getInterpolateNulls(),
                tooltip: {
                    isHtml: true,
		    //		    ignoreBounds: true, 
		    //changed this to focus from both as when both then the tooltip
		    //that is shown on a click stays around when the mouse over tooltip
		    //is shown
		    trigger: 'focus' 
                },
            };


            $.extend(chartOptions, {
		width:"100%",
                lineWidth: this.getProperty("lineWidth",1),
                colors: this.getColorList(),
                curveType: this.curveType,
		pointShape:this.getProperty("pointShape"),
		pointSize: this.getProperty("pointSize"),
                vAxis: {}
            });


            chartOptions.backgroundColor = {};
            chartOptions.chartArea = {};
            chartOptions.chartArea.backgroundColor = {};
	    

            chartOptions.legend = {
                textStyle: {}
            };
            chartOptions.hAxis = {
                gridlines: {},
                minorGridlines: {},		
                textStyle: {},
            };
	    chartOptions.xannotations = {
		textStyle: {
		    fontSize: this.getProperty('annotationsFontSize',12),
		    color: this.getProperty('annotationsTextColor')
		},
		stem: {
		    color:this.getProperty('annotationsStemColor'),
		    length:this.getProperty('annotationsStemLength'),
		},
		style: this.getProperty('annotationsStyle')
	    };


	    if(this.getDragToZoom()) {
		chartOptions.explorer =  { 
		    actions: ['dragToZoom', 'rightClickToReset'],
		    axis: 'horizontal',
		    keepInBounds: true,
		    maxZoomIn: 4.0
		};
	    } else if(this.getDragToPan()) {
		chartOptions.explorer= {
		    axis: 'horizontal',
		    keepInBounds: true,
		    maxZoomIn: 4.0
		}
	    }

            chartOptions.vAxis = {
                gridlines: {},
                minorGridlines: {},		
                textStyle: {},
            };
	    if(this.getProperty("vAxisReverse"))
		chartOptions.vAxis.direction=-1;


	    chartOptions.hAxis.minValue = this.getProperty("hAxisMinValue");
	    chartOptions.hAxis.maxValue = this.getProperty("hAxisMaxValue");
	    chartOptions.vAxis.minValue = this.getProperty("vAxisMinValue");
	    chartOptions.vAxis.maxValue = this.getProperty("vAxisMaxValue");

	    if(this.getProperty('vAxisExplicit')) {
		chartOptions.vAxis.viewWindowMode='explicit';
		chartOptions.vAxis.viewWindow  ={
		    max:chartOptions.vAxis.maxValue,
                    min:chartOptions.vAxis.minValue
		}
	    }




	    chartOptions.vAxis.logScale = this.getProperty("vAxisLogScale",this.getProperty("logScale"));
	    chartOptions.hAxis.logScale = this.getProperty("hAxisLogScale");

            chartOptions.hAxis.titleTextStyle = {};
            chartOptions.vAxis.titleTextStyle = {};
	    if(this.getProperty("hAxisDateFormat")) {
		chartOptions.hAxis.format = this.getProperty("hAxisDateFormat");
	    }


	    //	    this.getPropertyShow = true;
	    let lineColor = this.getProperty("lineColor");
	    let backgroundColor = this.getProperty("chartBackground");
            this.setPropertyOn(chartOptions.backgroundColor, "chart.fill", "fill", backgroundColor);
            this.setPropertyOn(chartOptions.backgroundColor, "chart.stroke", "stroke", this.getProperty("chartArea.fill", ""));
            this.setPropertyOn(chartOptions.backgroundColor, "chart.strokeWidth", "strokeWidth", null);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.fill", "fill", backgroundColor);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.stroke", "stroke", null);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.strokeWidth", "strokeWidth", null);

	    let minorGridLinesColor = this.getProperty("minorGridLines.color",this.getProperty("gridlines.color")||lineColor||"transparent");
            this.setPropertyOn(chartOptions.hAxis.gridlines, "hAxis.gridlines.color", "color", this.getProperty("gridlines.color")|| lineColor);
	    this.setPropertyOn(chartOptions.hAxis.minorGridlines, "hAxis.minorGridlines.color", "color", minorGridLinesColor);

	    this.setPropertyOn(chartOptions.hAxis, "hAxis.baselineColor", "baselineColor", this.getProperty("baselineColor")|| lineColor);	    
            this.setPropertyOn(chartOptions.vAxis.gridlines, "vAxis.gridlines.color", "color", this.getProperty("gridlines.color")|| lineColor);
	    this.setPropertyOn(chartOptions.vAxis.minorGridlines, "vAxis.minorGridlines.color", "color",  minorGridLinesColor);
	    this.setPropertyOn(chartOptions.vAxis, "vAxis.baselineColor", "baselineColor", this.getProperty("baselineColor")|| lineColor);

            let textColor = this.getTextColor();
	    let textBold = this.getTextBold();
	    let textItalic = this.getTextItalic();
            let textFontName = this.getTextFontName();
            let fontSize = this.getTextFontSize();	    
            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.color", "color", this.getProperty("axis.text.color", textColor));
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.color", "color", this.getProperty("axis.text.color", textColor));
            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.bold", "bold", textBold);
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.bold", "bold", textBold);
            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.italic", "italic", textItalic);
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.italic", "italic", textItalic);
            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.fontName", "fontName", textFontName);
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.fontName", "fontName", textFontName);
            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.fontSize", "fontSize",fontSize);
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.fontSize", "fontSize", fontSize);

	    chartOptions.vAxis.title  =
		Utils.decodeText(this.getProperty("vAxis.text", this.getProperty("vAxisText",this.getVAxisTitle())));

	    chartOptions.hAxis.title  =
		Utils.decodeText(this.getProperty("hAxis.text", this.getProperty("hAxisText",this.getHAxisTitle())));
	    chartOptions.hAxis.slantedText = this.getProperty("hAxis.slantedText",this.getProperty("slantedText",false));
            this.setPropertyOn(chartOptions.hAxis.titleTextStyle, "hAxis.text.color", "color", textColor);
            this.setPropertyOn(chartOptions.vAxis.titleTextStyle, "vAxis.text.color", "color", textColor);
            this.setPropertyOn(chartOptions.legend.textStyle, "legend.text.color", "color", textColor);

	    chartOptions.hAxis.viewWindow = {};
	    if(Utils.isDefined(this.getProperty('hAxisViewMin'))) {
		chartOptions.hAxis.viewWindow.min = +this.getProperty('hAxisViewMin');
	    }
	    if(Utils.isDefined(this.getProperty('hAxisViewMax'))) {
		chartOptions.hAxis.viewWindow.max = +this.getProperty('hAxisViewMax');
	    }	    





	    let prop;
	    prop = this.getProperty("hAxis.ticks");
	    if(prop || prop=="")  {
		let fmt = this.getProperty("hAxis.tickTemplate","${value}");
		let ticks = Utils.split(this.getProperty("hAxis.ticks"),",",true,true);
		ticks=ticks.map(t=> {
		    let toks = t.split(':');
		    let label;
		    if(toks.length>1) {
			t = toks[0];
			label=toks[1];
		    } else {
			label = fmt.replace("${value}",t);
		    }
		    return {
			v:t,
			f:label
		    }
		});
		chartOptions.hAxis.ticks  = ticks;
	    }
	    prop = this.getProperty("vAxis.ticks");
	    if(prop || prop=="")  {
		let fmt = this.getProperty("vAxis.tickTemplate","${value}");
		let ticks = Utils.split(this.getProperty("vAxis.ticks"),",",true,true);
		ticks=ticks.map(t=> {
		    return {
			v:t,
			f:fmt.replace("${value}",t)
		    }
		});
		chartOptions.vAxis.ticks  = ticks;
	    }

	    if(this.getHAxisHideTicks()) 
		chartOptions.hAxis.ticks  = [];
	    if(this.getVAxisHideTicks()) 
		chartOptions.vAxis.ticks  = [];	    

            if (fontSize > 0) {
                chartOptions.fontSize = fontSize;
            }

	    let defaultRanges=[];
	    let numeric = [];
            dataList.forEach((v,idx)=>{
		if(idx==0) return;
		let tuple = this.getDataValues(v);
		if(idx==1) {
		    tuple.forEach((tv,idx)=>{
			numeric.push((typeof tv)=="number");
		    });
		    numeric.forEach(v=>defaultRanges.push([Number.MAX_VALUE,Number.MIN_VALUE]));
		}
		
		
		let cnt = 0;
		tuple.forEach((tv,idx)=>{
		    if(numeric[idx]) {
			defaultRanges[cnt][0] = Math.min(defaultRanges[cnt][0],tv);
			defaultRanges[cnt][1] = Math.max(defaultRanges[cnt][1],tv);
			cnt++;
		    }
		});
	    });

            let range = [NaN, NaN];
	    //	    console.log("range:" +this.getVAxisMinValue());
            if (!isNaN(this.getVAxisMinValue())) {
                range[0] = this.getVAxisMinValue();
            } else if (defaultRanges.length>0) {
		if(this.getProperty("vAxisUseDefault")) {
                    range[0] = defaultRanges[0][0];
		}
            }

	    if (!isNaN(this.getVAxisMaxValue())) {
                range[1] = this.getVAxisMaxValue();
            } else if (defaultRanges.length>0) {
		//                range[1] = defaultRanges[0][1];
            }



            if (!isNaN(range[0])) {
                chartOptions.vAxis.minValue = range[0];
            }
            if (!isNaN(range[1])) {
                chartOptions.vAxis.maxValue = range[1];
		//		chartOptions.vAxis.maxValue = null;
            }

	    //	    console.log(chartOptions.vAxis.maxValue);

            this.chartDimensions = {
                width: "90%",
                left: "10%",
                right: 10,
            }

            useMultipleAxes = this.getProperty("useMultipleAxes", true);

            if ((selectedFields.length > 1 && useMultipleAxes) || this.getProperty("padRight", false) === true) {
                this.chartDimensions.width = "80%";
            }


            if (this.getShowTrendLines()) {
                chartOptions.trendlines = {
                    0: {
                        type: 'linear',
                        color: 'green',
                    }
                };
            }
	    
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(expandedHeight) {
		chartOptions.height = expandedHeight;
	    }
	    if(this.getPropertyShow) {
		this.getPropertyShow = false;
		Utils.makeDownloadFile("props.txt",this.getPropertyOutput);
	    }
            this.setContents(HU.div([ID,this.domId(ID_CHARTS)]));
	    


            return chartOptions;
        },
        getChartHeight: function() {
            return this.getProperty('chartHeight', this.getProperty("height"));
        },
        getChartWidth: function() {
            return this.getProperty('chartWidth', this.getProperty('width'));
        },
        getChartDiv: function(chartId) {
            let divAttrs = [ATTR_ID, chartId];
            let style = "";
            let width = this.getChartWidth();
            if (false && width) {
		if(width.endsWith("%")) {
                    style += HU.css("width", width);
		} else {
                    if (width > 0)
			style += HU.css("width", width + "px");
                    else if (width < 0)
			style += HU.css("width" , (-width) + "%");
                    else
			style += HU.css("width", width);
		}
            } else {
		//                style += HU.css("width","100%");
            }
	    let expandedHeight  = this.getProperty("expandedHeight");
            let height =  this.getChartHeight();
	    if(expandedHeight) {
                style += HU.css("height", expandedHeight);
	    } else {
		if (height) {
                    if (height > 0)
			style += HU.css("height", height + "px");
                    else if (height < 0)
			style += HU.css("height", (-height) + "%");
                    else
			style += HU.css("height", height);
		} else {
                    style += HU.css("height", "100%");
		}
	    }
	    //	    style += HU.css("text-align","center");
            divAttrs.push(STYLE);
            divAttrs.push(style);
	    divAttrs.push(CLASS);
	    divAttrs.push("ramadda-expandable-target");
	    let isExpanded = this.getProperty("isExpanded");
	    let originalHeight = this.getProperty("originalHeight");
	    if(isExpanded) {
		divAttrs.push("isexpanded","true")
		divAttrs.push("original-height",originalHeight)
	    }
	    if(this.getProperty("expandableHeight")) {
		divAttrs.push("expandable-height");
		divAttrs.push(this.getProperty("expandableHeight"));
	    }
            return HU.div(divAttrs, "");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            throw new Error("doMakeGoogleChart undefined");
        },
	makeGoogleChart: function(dataList, props, selectedFields) {
	    //	    try {
	    this.doMakeGoogleChartInner(dataList,props,selectedFields);
	    //	    } catch(err) {
	    //		this.handleError("Error creating chart: " + err, err);
	    //	    }
	},
	setAxisRanges: function(chartOptions, selectedFields, records) {
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[0]);
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }

	    let vaxes = {};
	    let getProp = (f,prop,dflt)=>{
		let v= Utils.getProperty(this.getProperty(f.getId()+'.' + prop,this.getProperty(prop,dflt)));
		return v;
	    }
	    selectedFields.forEach((f,idx)=>{
		let min = this.getProperty(f.getId()+'.vAxisMinValue');
		let max = this.getProperty(f.getId()+'.vAxisMaxValue');		
		let viewWindow = {};
		if(Utils.isDefined(min)) viewWindow.min= parseFloat(min);
		if(Utils.isDefined(max)) viewWindow.max= parseFloat(max);		
		vaxes[idx] = { viewWindow: viewWindow}
		vaxes[idx].title=getProp(f,'vAxisTitle')
		let ts = vaxes[idx].textStyle={};
		ts.color= getProp(f,'vAxis.text.color');
		ts.fontSize=getProp(f,'vAxis.text.fontSize');
		ts.fontName = getProp(f,'vAxis.text.fontName');
		ts.bold=getProp(f,'vAxis.text.bold');
		ts.italic=getProp(f,'vAxis.text.italic');		
	    })

	    chartOptions.vAxes = vaxes;

	    if(this.getProperty("vAxisFixedRange") || this.getProperty("vAxisSelectedFields") || this.getProperty("vAxisAllFields")) {
		let min = Number.MAX_VALUE;
		let max = Number.MIN_VALUE;		
		let fields = this.getProperty("vAxisAllFields")?this.getFields():selectedFields;
		fields.forEach(f=>{
		    if(f.isFieldNumeric()) {
			let y = this.getColumnValues(records, f);
			if(!isNaN(y.min))
			    min  = Math.min(min, y.min);
			if(!isNaN(y.max))
			    max  = Math.max(max, y.max);
		    }
		});
		if(min!=Number.MAX_VALUE) {
		    chartOptions.vAxis.minValue = min;
		    chartOptions.vAxis.maxValue = max;
		}
	    }

	},
	doMultiChartsByField:function() {
	    return this.getProperty('doMultiChartsByField');
	},
	makeMultiChart:function (label, dataList, fields,props) {
	    let multiStyle="width:200px;" + this.getProperty("multiStyle","");
	    let multiLabelTemplate=this.getProperty("multiLabelTemplate","${value}");
	    let labelPosition = this.getProperty("multiChartsLabelPosition","bottom");
	    let tmpChartOptions = this.chartOptions;
	    this.chartOptions = $.extend({},this.chartOptions);
	    label = multiLabelTemplate.replace("${value}",label);
	    let header = HU.div([CLASS,"display-multi-header"], label);
	    let top =labelPosition=="top"?header:"";
	    let bottom = labelPosition=="bottom"?header:"";
	    let innerId = this.domId(ID_CHART)+"_" + this.chartCount;
	    let div = HU.div([CLASS,"display-multi-div", STYLE,HU.css('display','inline-block')+ multiStyle], top + this.getChartDiv(innerId) + bottom);
	    this.jq(ID_CHARTS_INNER).append(div);
	    let chart = this.makeGoogleChartInner(dataList, innerId, props, fields);
	    if(chart) {
		this.charts.push(chart);
		chart.chartOptions = this.chartOptions;
	    }
	    this.chartOptions =tmpChartOptions;
	    return chart;
	},


	doMakeGoogleChartInner: function(dataList, props, selectedFields) {
            if (typeof google == 'undefined') {
                this.setDisplayMessage("No google");
                return;
            }
            this.chartOptions = this.makeChartOptions(dataList, props, selectedFields);
	    this.chartOptions.bar = {groupWidth:"95%"}
            if (!Utils.isDefined(this.chartOptions.height)) {
                this.chartOptions.height = "100%";
            }
	    this.charts = [];
	    this.chartCount  = -1;

	    //	    if(this.getChartHorizontal()) {
	    //		this.chartOptions.bars='horizontal'
	    //	    }
            let records = this.getPointData().getRecords();
	    this.setAxisRanges(this.chartOptions, selectedFields, records);
	    //	    console.log(JSON.stringify(this.chartOptions, null,2));
	    //Clear out any existing charts
	    this.clearChart();
	    if(this.getProperty("doMultiCharts",this.getProperty("multipleCharts",false))) {
		this.jq(ID_CHARTS).html(HU.div([ID,this.domId(ID_CHARTS_INNER),STYLE,HU.css('text-align','center')]));
		if(this.doMultiChartsByField()) {
		    this.multiChartData=[];
		    selectedFields.forEach((field,idx)=>{
			this.chartCount  =idx;
			let dataList = this.getStandardData([field], props);
			let chart = this.makeMultiChart(field.getLabel(), dataList, [field], props);
			this.multiChartData.push({props:props,
						  fields:[field],
						  dataList:dataList,
						  field:field,
						  chartOptions:chart.chartOptions,
						  chart:chart});
		    });
		    return;
		}

		let multiField=this.getFieldById(null,this.getProperty("multiField"));
		let map = {};
		let groups = [];
		let tmp = [];
		dataList.forEach((v,idx)=>{if(idx>0) tmp.push(v)});
		if(!multiField) {
		    tmp.sort(function(a,b) {
			let v1 = a.record?a.record.getDate():a.date;
			let v2 = b.record?b.record.getDate():b.date;
			return v1.getTime()-v2.getTime();
		    });
		}
		dataList = Utils.mergeLists([dataList[0]], tmp);
		dataList.forEach((v,idx)=>{
		    if(idx==0) return;
                    let record = v.record;
		    let groupValue = record?multiField?record.getValue(multiField.getIndex()):record.getDate():v.date;
		    let list=null;
		    list = map[groupValue];
		    if(!list) {
			list = [];
			map[groupValue] = list;
			groups.push(groupValue);
		    }
		    list.push(v);
		})
		if(multiField) groups.sort();
		groups.forEach((groupValue,idx)=>{
		    this.chartCount  =idx;
		    let tmpDataList = [];
		    let list = map[groupValue];
		    tmpDataList.push(dataList[0]);
		    tmpDataList = Utils.mergeLists(tmpDataList,list);
		    let label = groupValue;
		    if(groupValue.getTime) label = this.formatDate(groupValue);
		    this.makeMultiChart(label, tmpDataList,  selectedFields,props);

		});
	    } else {
		this.jq(ID_CHARTS).append(this.getChartDiv(this.domId(ID_CHART)));
		let chart = this.makeGoogleChartInner(dataList, this.domId(ID_CHART), props, selectedFields);
		if(chart) this.charts.push(chart);
	    }
	},

	drawChart:function(chart,dataTable,chartOptions) {
	    chart.draw(dataTable, 	    chartOptions);
	},

	makeGoogleChartInner: function(dataList, chartId, props, selectedFields) {
	    let chartDiv = document.getElementById(chartId);
	    if(!chartDiv) {
		this.logMsg("makeGoogleChart: no chart div found:" + chartId);
		return;
	    }
	    let dataTable = this.makeDataTable(dataList, props, selectedFields, this.chartOptions);
            let chart = this.doMakeGoogleChart(dataList, props, chartDiv, selectedFields, this.chartOptions);
            if (chart == null) return null;
            if (!dataTable) {
                this.setDisplayMessage(this.getNoDataMessage());
                return null;
            }
	    if(this.getProperty("vAxisSharedRange")) {
		let indexIsString = this.getProperty("indexIsString", this.getProperty("forceStrings",false));
		let min = NaN;
		let max = NaN;		
		for(let i=0;i<dataTable.getNumberOfColumns();i++) {
		    //if(i==0 && indexIsString) continue;
		    //should we always skip the first column since it is the index
		    if(i==0) continue;
		    if(dataTable.getColumnType(i)!='number') continue;
		    let minmax = dataTable.getColumnRange(i);
		    minmax={min:NaN,max:NaN};
		    let values = dataTable.getDistinctValues(i);
		    values.forEach(v=>{
			if(isNaN(v))return;
			min = Utils.min(min,v);
			max = Utils.max(max,v);			
		    });
		}
		this.getExtraLines().forEach(info=>{
		    min = Utils.min(min,info.value);
		    max = Utils.max(max,info.value);			
		});

		if(!isNaN(min) && !isNaN(max)) {
		    let diff = max-min;
		    //pad out 10%
		    min-=diff*0.1;
		    max+=diff*.1;
		    if(Utils.isDefined(this.getProperty('vAxisMinValue')))min=+this.getProperty('vAxisMinValue');
		    if(Utils.isDefined(this.getProperty('vAxisMaxValue')))max=+this.getProperty('vAxisMaxValue');
		    
                    this.chartOptions.vAxis.minValue = min;
                    this.chartOptions.vAxis.maxValue = max;
		}
            }


	    if(this.getDoDyamicTooltip()) {
		this.chartOptions.tooltip={ trigger: 'none' };
	    }




	    if(this.getAnimateChart(this.getProperty("animation",false,true))) {
		this.chartOptions.animation = {
		    startup: true,
		    duration:parseFloat(this.getAnimationDuration()),
		    easing:this.getAnimationEasing()
		};
		HU.callWhenScrolled(this.domId(ID_CHART),()=>{
		    if(!this.animationCalled) {
			this.animationCalled = true;
			this.mapCharts(chart=>{
			    this.drawChart(chart,dataTable, this.chartOptions);
			});
		    }
		});
	    } else {
		try {
		    if(this.debugChartOptions)
			console.log(JSON.stringify(this.chartOptions, null,2));
		    this.chart = chart;
		    this.dataTable = dataTable;
		    let testData = google.visualization.arrayToDataTable([
			['Genre', 'Fantasy & Sci Fi', 'Western'],
			['2010', 10, 24],
			['2020', 16, 22],
			['2030', 28, 19]
		    ]);

		    let t1 = new Date();
		    this.drawChart(chart, this.useTestData?testData:dataTable, this.chartOptions);
		} catch(err) {
		    this.handleError("Error creating chart:" + err,err);
		    return null;
		}
	    }

	    this.addEvents(chart,dataTable);
	    return chart;
	},
	addDynamicTooltip: function(chart,data,event) {
	    let row = event.row;
	    let record = this.indexToRecord[row];
	    if(!record) return;
	    if(!this.tooltipEvent) return;
	    let tooltip = this.tooltipDiv;
	    if(!this.tooltipDiv) {
		tooltip = this.tooltipDiv =  document.createElement('div');
		tooltip.style.position = 'absolute';
		document.body.appendChild(tooltip);
	    }
	    let tt = this.getProperty("tooltip");
	    let style = HU.css('font-size','80%') +this.getTooltipStyle('');
	    let content =   HU.div([ATTR_CLASS,'ui-tooltip',ATTR_STYLE,style],
				   this.getRecordHtml(record, null, tt));

	    tooltip.innerHTML = content;
	    let chartContainer = chart.getContainer();
	    let chartRect = chartContainer.getBoundingClientRect();
	    let pageX = this.tooltipEvent.pageX;
            let pageY = this.tooltipEvent.pageY;
	    pageX = +this.getTooltipX(pageX);
	    pageY = +this.getTooltipY(pageY);	    
	    let right = chartRect.left+chartRect.width;
	    if(pageX+400>right) pageX=right-400;
	    tooltip.style.left = pageX+'px';
	    tooltip.style.top =(pageY+20)+'px';
	    tooltip.style.display = 'block';
	    
	},

	getDoDyamicTooltip: function() {
	    return this.getDynamicTooltip();
	},
	addEvents: function(chart,data) {
            let _this = this;
	    if(this.getDoDyamicTooltip()) {
		let chartContainer = chart.getContainer();
		if(chartContainer) {
		    chartContainer.addEventListener('mousemove', (event) =>{
			this.tooltipEvent = event;
		    })
		}
		google.visualization.events.addListener(chart, 'onmouseover', (event) =>{
		    this.addDynamicTooltip(chart,data,event);
		});

		google.visualization.events.addListener(chart, 'onmouseout', (event)=> {
		    if(this.tooltipDiv) {
			this.tooltipDiv.style.display = 'none';
		    }
		});
	    }


	    if(this.getProperty("propagateHighlightEvent")) {
		google.visualization.events.addListener(chart, 'onmouseover', function(event) {
                    pointData = _this.dataCollection.getList()[0];
                    let fields = pointData.getRecordFields();
                    let records = pointData.getRecords();
	            let record = records[event.row];
		    if(!record) return;
		    _this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, _this, {highlight:true,record: record});
		});
	    }
            google.visualization.events.addListener(chart, 'select', function(event) {
                _this.mapCharts(chart=>{
		    //		    chart.setSelection([]);
		    if (chart.getSelection) {
			let selected = chart.getSelection();
			if (selected && selected.length > 0) {
                            let index = selected[0].row;
			    let record = _this.indexToRecord[index];
			    if(record) {
				let records = _this.getBinnedRecords(record);
				if(records) {
				    if(records.length==1)  {
					_this.propagateEventRecordSelection({record: records[0]});
				    } else {
					_this.propagateEventRecordSelection({record: records[0],
									     records:records});
				    }
				} else {
				    _this.propagateEventRecordSelection({record: record});
				}
			    }
			}
		    }});
            });
	}


    });
}



function RamaddaAxisChart(displayManager, id, chartType, properties) {
    let SUPER = new RamaddaGoogleChart(displayManager, id, chartType, properties);
    let myProps = [
	{label:'Chart Properties'},
	{p:'indexField',ex:'field',tt:'alternate field to use as index'},
 	{p:'indexIsString',ex:'true',tt:'if index is a string set to true'},
 	{p:'useStringInLegend',ex:'true',tt:'if index is a string then add the string value to the data'},	
	{p:'vAxisMinValue',ex:''},
	{p:'vAxisMaxValue',ex:''},
	{p:'vAxisExplicit',ex:true,tt:'use the min/max values explicitly'},	
	{p:'&lt;field&gt;.vAxisMinValue',ex:'',tt:'Min value for the field'},
	{p:'&lt;field&gt;.vAxisMaxValue',ex:'',tt:'Max value for the field'},	
	{p:'vAxisSharedRange',ex:'true',tt:'use the same max value across all time series'},
	{p:'vAxisReverse',ex:'true',tt:'Reverse the v axis'},
	{p:"hAxisFixedRange"},
	{p:"vAxisSelectedFields",ex:'true',tt:'Use selected fields to find min/max for the range'},
	{p:"vAxisAllFields",ex:'true',tt:'Use all field values to find min/max for the range'},
	{p:'vAxisLogScale',ex:'true'},
	{p:'hAxisLogScale',ex:'true'},
	{p:'tooltipFields',ex:''},
 	{p:'dateType',ex:'datetime'},
 	{p:'addTooltip',ex:'false',tt:'Set this to false for multi-series charts if you only want the hovered series to show in the tt'},
	{inlineLabel:'Multiples Charts'},
	{p:'doMultiCharts',ex:'true'},
	{p:'multiField',ex:'field'},
	{p:'multiStyle',ex:''},
	{p:'multiLabelTemplate',ex:'${value}'},
	{p:'multiChartsLabelPosition',ex:'bottom|top|none'},
	{inlineLabel:'Chart Layout'},
	{p:'lineColor',ex:''},
	{p:'chartBackground',ex:''},
	{p:'chart.fill',ex:''},
	{p:'chartArea.fill',ex:''},
	{p:'chart.stroke',ex:''},
	{p:'chart.strokeWidth',ex:''},
	{p:'chartArea.fill',ex:''},
	{p:'chartArea.stroke',ex:''},
	{p:'chartArea.strokeWidth',ex:''},
	{p:'gridlines.color',ex:'transparent'},
	{p:'minorGridLines.color',ex:'transparent'},
	{p:'gridlines.color',ex:''},
	{p:'hAxis.gridlines.color',ex:''},
	{p:'hAxis.minorGridlines.color',ex:'transparent'},
	{p:'baselineColor',ex:''},
	{p:'hAxis.baselineColor',ex:''},
	{p:'gridlines.color',ex:''},
	{p:'vAxis.gridlines.color',ex:''},
	{p:'vAxis.minorGridlines.color',ex:'transparent'},
	{p:'baselineColor',ex:''},
	{p:'vAxis.baselineColor',ex:''},
	{p:'textColor',ex:'#000'},
	{p:'textBold',ex:'true'},

	{p:'axis.text.color',ex:'#000'},
	{p:'hAxis.text.color',ex:'#000'},
	{p:'vAxis.text.color',ex:'#000'},
	{p:'&lt;field&gt;.vAxis.text.color',ex:'#000'},

	{p:'hAxis.text.fontSize',ex:'16'},
	{p:'vAxis.text.fontSize',ex:'16'},
	{p:'&lt;field&gt;.vAxis.text.fontSize',ex:'16'},

	{p:'hAxis.text.fontName',ex:'Times'},
	{p:'vAxis.text.fontName',ex:'Times'},
	{p:'&lt;field&gt;.vAxis.text.fontName',ex:'Times'},		


	{p:'hAxis.text.bold',ex:'true'},
	{p:'vAxis.text.bold',ex:'true'},
	{p:'&lt;field&gt;.vAxis.text.bold',ex:'true'},	

	{p:'hAxis.text.italic',ex:'true'},
	{p:'vAxis.text.italic',ex:'true'},
	{p:'&lt;field&gt;.vAxis.text.italic',ex:'true'},	


	{p:'vAxisText',ex:''},
	{p:'vAxis.text',ex:''},

	{p:'slantedText',ex:'true'},
	{p:'hAxis.slantedText',ex:''},
	{p:'hAxis.text.color',ex:'#000'},
	{p:'vAxis.text.color',ex:'#000'},

	{p:'&lt;field&gt;.vAxis.text.color',ex:'#000'},



	{p:'legend.position',ex:'top|bottom|none'},
	{p:'legend.text.color',ex:'#000'},
	{p:'hAxis.ticks',tt:'Comma separated list of tick marks',ex:''},
	{p:'hAxis.tickTemplate',ex:'${value}'},
	{p:'vAxis.ticks',tt:'Comma separated list of tick marks',ex:''},
	{p:'vAxis.tickTemplate',ex:'${value}'},	

	{p:'useMultipleAxes',ex:'true'},
    ];

    defineDisplay(this, SUPER, myProps, {

	setChartArea: function(chartOptions) {
            if (!chartOptions.chartArea) {
                chartOptions.chartArea = {};
            }
	    $.extend(chartOptions.chartArea, {
                left: this.getChartLeft(this.chartDimensions.left),
                right: this.getChartRight(this.chartDimensions.right),
                top: this.getChartTop(),
		bottom: this.getChartBottom(50),
                height: this.getChartHeight('70%'),
                width: this.getChartWidth(this.chartDimensions.width),
            });
	    ["left","top","right","bottom"].forEach(a=>{
		let v =chartOptions.chartArea[a];
		if(v) v = String(v).replace("px","");
		chartOptions.chartArea[a] = v;
	    });						    
	},

        makeChartOptions: function(dataList, props, selectedFields) {
            chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);

	    let dataFields = dataList[0].fields;


	    let expandedHeight  = this.getProperty("expandedHeight");
            chartOptions.height = expandedHeight || this.getProperty("chartHeight", this.getProperty("height", "150"));

            if (!chartOptions.legend)
                chartOptions.legend = {};


	    this.setPropertyOn(chartOptions.legend, "legend.position", "position", this.getProperty("legendPosition", 'bottom'));
	    this.setChartArea(chartOptions);
	    
            let useMultipleAxes = this.getProperty("useMultipleAxes", true);
            if (useMultipleAxes) {
		//TODO: 
                chartOptions.series = [
		    {
			targetAxisIndex: 0
                    }, {
			targetAxisIndex: 1
                    }];
            }

	    if(chartOptions.legend.position=="left") {
                chartOptions.series = [
		    {
			targetAxisIndex: 1
		    }]
	    }



	    if (!chartOptions.hAxis) {
		chartOptions.hAxis = {};
	    }
	    if (!chartOptions.vAxis) {
		chartOptions.vAxis = {};
	    }
	    chartOptions.hAxis.textPosition = this.getProperty("hAxisTextPosition","top");
	    chartOptions.vAxis.textPosition = this.getProperty("vAxisTextPosition");


            if (this.getProperty("hAxisTitle")) {
                chartOptions.hAxis.title = this.getProperty("hAxisTitle");
            }
            if (this.getProperty("vAxisTitle")) {
                chartOptions.vAxis.title = this.getProperty("vAxisTitle");
		if(chartOptions.vAxis.title && dataFields) {

		    let label = dataFields.reduce((acc,v)=>{
			return acc+" " + v.getLabel(this);
		    },"");
		    chartOptions.vAxis.title = chartOptions.vAxis.title.replace("${fields}",label);
		}

            }
	    //	    console.log(JSON.stringify(chartOptions,null,2));

            if (Utils.isDefined(this.chartHeight)) {
                chartOptions.height = this.chartHeight;
            }

            return chartOptions;

        }
    });

}



function RamaddaSeriesChart(displayManager, id, chartType, properties) {
    const SUPER = new RamaddaAxisChart(displayManager, id, chartType, properties);
    defineDisplay(this, SUPER, [], {
        includeIndexInData: function() {
            return this.getProperty("includeIndex", true);
        },
        trendLineEnabled: function() {
            return true;
        },
    });
}


function BlankchartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, "blankchart", properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            return null;
        },
    });
}


function LinechartDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaSeriesChart(displayManager, id, DISPLAY_LINECHART, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            return new google.visualization.LineChart(chartDiv);
        },
    });
}




function AreachartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, DISPLAY_AREACHART, properties);
    let myProps = [
	{label:'Area Chart Properties'},
	{p:'isStacked',ex:'true'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            if (this.isStacked)
                chartOptions.isStacked = true;
            return new google.visualization.AreaChart(chartDiv);
        }
    });
}


function RamaddaBaseBarchart(displayManager, id, type, properties) {
    const SUPER  = new RamaddaSeriesChart(displayManager, id, type, properties);
    let myProps = [
    ];
    defineDisplay(this, SUPER, myProps, {
        canDoGroupBy: function() {
            return true;
        },
        makeChartOptions: function(dataList, props, selectedFields) {
            chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            let chartType = this.getChartType();
            if (chartType == DISPLAY_BARSTACK) {
		chartOptions.series = null;
                chartOptions.isStacked = true;
            }
            if (this.getProperty("barWidth")) {
		let w = this.getProperty("barWidth");
		if(w=="flex") {
		    if(dataList.length<100) {
			w = "10";
		    } else {
			w = null;
		    }
		}
		if(w) {
                    chartOptions.bar = {
			groupWidth: w
                    }
		}
	    }
	    chartOptions.orientation = this.getProperty("orientation","horizontal");
	    return chartOptions;
	},

        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            return new google.visualization.BarChart(chartDiv);
	    //            return new google.charts.Bar(chartDiv);	    
        }
    });
}


function BarchartDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaBaseBarchart(displayManager, id, DISPLAY_BARCHART, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {});
}

function BarstackDisplay(displayManager, id, properties) {
    properties = $.extend({
        "isStacked": true
    }, properties);
    const SUPER =  new RamaddaBaseBarchart(displayManager, id, DISPLAY_BARSTACK, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {});
}


function HistogramDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_HISTOGRAM, properties);
    let myProps = [
	{label:'Histogram Properties'},
	{p:'legendPosition',ex:'none|top|right|left|bottom'},
	{p:'textPosition',ex:'out|in|none'},
	{p:'isStacked',ex:'false|true|percent|relative'},
	{p:'logScale',ex:'true|false'},
	{p:'scaleType',ex:'log|mirrorLog'},
	{p:'minValue',ex:''},
	{p:'maxValue',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        okToHandleEventRecordSelection: function() {
            return false;
        },
	getDoDyamicTooltip: function() {
	    return false;
	},
        makeDataTable: function(dataList, props, selectedFields) {
            return google.visualization.arrayToDataTable(this.makeDataArray(dataList));
        },
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            //            chartOptions = {};
            if (this.legendPosition) {
                if (!chartOptions.legend)
                    chartOptions.legend = {};
                chartOptions.legend.position = this.legendPosition;
            }
            let isStacked = this.getProperty("isStacked", null);
            if (isStacked)
                chartOptions.isStacked = isStacked == "true" ? true : isStacked == "false" ? false : isStacked;
            chartOptions.vAxis = {};
            chartOptions.vAxis.viewWindow = {};
            if (Utils.isDefined(this.logScale)) {
                chartOptions.vAxis.logScale = ("" + this.logScale) == true;
            }
            if (this.textPosition) {
                chartOptions.vAxis.textPosition = this.textPosition;
            }


            if (Utils.isDefined(this.minValue)) {
                chartOptions.vAxis.viewWindow.min = parseFloat(this.minValue);
            }
            if (Utils.isDefined(this.maxValue)) {
                chartOptions.vAxis.viewWindow.max = parseFloat(this.maxValue);
            }
            if (!isNaN(this.getVAxisMaxValue())) {
                chartOptions.vAxis.maxValue = this.getVAxisMaxValue();
            }
            if (!isNaN(this.getVAxisMinValue())) {
                chartOptions.vAxis.minValue = parseFloat(this.getVAxisMinValue());
            }
            if (!isNaN(this.getHAxisMaxValue())) {
                chartOptions.hAxis.maxValue = this.getHAxisMaxValue();
            }
            if (!isNaN(this.getHAxisMinValue())) {
                chartOptions.hAxis.minValue = parseFloat(this.getHAxisMinValue());
            }	    
            return new google.visualization.Histogram(chartDiv);
        },

    });
}


function RamaddaTextChart(displayManager, id, chartType, properties) {
    const SUPER = new RamaddaGoogleChart(displayManager, id, chartType, properties);
    defineDisplay(this, SUPER, [], {
        getFieldsToSelect: function(pointData) {
	    if(this.convertedFields) return this.convertedFields;
            return pointData.getNonGeoFields();
        },
    });
}




function PiechartDisplay(displayManager, id, properties) {
    let ID_PIE_LEGEND = "pielegend";
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_PIECHART, properties);
    let myProps = [
	{label:'Pie Chart Properties'},
	{p:'groupBy',ex:''},
	{p:'groupByCount',ex:'true'},
	{p:'groupByCountLabel',ex:''},
	{p:'showTopLegend'},
	{p:'binCount',ex:'true'},
	{p:'pieHole',ex:'0.5'},
	{p:'is3D',ex:'true'},
	{p:'bins',ex:''},
	{p:'binMin',ex:''},
	{p:'binMax',ex:'max'},
	{p:'sumFields',ex:'true'},
	{p:'sliceVisibilityThreshold',ex:'0.01'},
	{p:'pieSliceTextColor',ex:'black'},
	{p:'pieSliceBorderColor',d:'white',ex:'black'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {

	uniqueValues:[],
	uniqueValuesMap:{},
	getDoDyamicTooltip: function() {
	    return false;
	},
        canDoGroupBy: function() {
            return true;
        },
	makeGoogleChart: function(dataList, props, selectedFields) {
	    this.uniqueValues = [];
	    this.uniqueValuesMap = {};
	    SUPER.makeGoogleChart.call(this, dataList, props, selectedFields);
	    if(!this.getShowTopLegend()) return;
	    let legend = "";
	    let colors = this.getColorList();
	    let colorCnt = 0;
	    this.uniqueValues.map((v,idx)=>{
		if(colorCnt>=colors.length) colorCnt = 0;
		let color  = colors[colorCnt];
		legend += HU.div([STYLE,HU.css('display','inline-block','width','8px','height','8px','background', color)]) +SPACE + v +SPACE2;
		colorCnt++;
	    });
	    if(this.jq(ID_PIE_LEGEND).length==0) {
		this.jq(ID_HEADER2).append(HU.div([ID,this.domId(ID_PIE_LEGEND)]));
	    }
	    this.jq(ID_PIE_LEGEND).html(legend);

	},
        setChartSelection: function(index) {
	    //noop
	},
	//Override these methods since the pie chart can't use the explorer
	getDragToZoom:function(){return false;},
	getDragToPan:function(){return false;},	
        getGroupBy: function() {
            if (!this.groupBy && this.groupBy != "") {
                let stringField = this.getFieldByType(this.getFields(), "string");
                if (stringField) {
                    this.groupBy = stringField.getId();
                }
            }
            return this.groupBy;
        },
        getChartDiv: function(chartId) {
            let divAttrs = [ATTR_ID, chartId];
            divAttrs.push(STYLE);
            let style = "";
	    let width = this.getProperty("chartWidth") || this.getChartWidth();
	    let height = this.getProperty("chartHeight") || this.getChartHeight();
            if (width) {
                if (width > 0)
                    style += "width:" + width + "px;";
                else if (width < 0)
                    style += "width:" + (-width) + "%;";
                else
                    style += "width:" + width + ";";
            } else {
                style += "width:" + "100%;";
            }
            if (height) {
                if (height > 0)
                    style += "height:" + height + "px;";
                else if (height < 0)
                    style += "height:" + (-height) + "%;";
                else
                    style += "height:" + height + ";";
            } else {
                style += "height:" + "100%;";
            }
	    //	    style += "border:1px solid green;"
            divAttrs.push(style);
            return HU.div(divAttrs, "");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            chartOptions.tooltip = {
                textStyle: {
                    color: '#000000',
		    fontSize:12,
                },
                showColorCode: true,
		//		isHtml: true,
		//		ignoreBounds: true,
            };
	    this.chartOptions.legend = {'position':this.getProperty("legendPosition", 'right'),'alignment':'center'};
            if (this.getBins()) {
                chartOptions.title = "Bins: " + this.getDataValues(dataList[0])[1];
	    } else if(this.getSumFields()) {
                chartOptions.title = this.getProperty("chartTitle","Categories/Values");
            } else {
                chartOptions.title = this.getDataValues(dataList[0])[0] + " - " + this.getDataValues(dataList[0])[1];
            }

            if (this.getIs3D()) {
                chartOptions.is3D = true;
            }
            if (this.getPieHole()) {
                chartOptions.pieHole = this.pieHole;
            }
            if (this.getSliceVisibilityThreshold()) {
                chartOptions.sliceVisibilityThreshold = this.sliceVisibilityThreshold;
            }

	    chartOptions.pieSliceBorderColor = this.getPieSliceBorderColor();
	    chartOptions.pieSliceTextStyle  = {
		color: this.getPieSliceTextColor()
            };

	    chartOptions.chartArea = {};
	    $.extend(chartOptions.chartArea, {
                left: this.getChartLeft(),
                right: this.getChartRight(),
                top: this.getChartTop(),
		bottom: this.getChartBottom(),
                width: '100%',
                height: '100%'
            });

            return new google.visualization.PieChart(chartDiv);
        },
	getColorList:function() {
	    if (this.getProperty("colors") && this.getProperty("colors")!="default") {
		return SUPER.getColorList.call(this);
	    }
	    if (this.getProperty("colorTable")) {
		let ct =this.getColorTable();
		return ct.colors;
	    }	    
	    return Utils.mergeLists(Utils.getColorTable("schemeset1",true),
				    Utils.getColorTable("schemecategory",true));
	},

        makeDataTable: function(dataList, props, selectedFields) {
            let dataTable = new google.visualization.DataTable();
            let list = [];
            let header = this.getDataValues(dataList[0]);
            dataTable.addColumn("string", header[0]);
            dataTable.addColumn("number", header[1]);


            if (this.getBins()) {
                let bins = parseInt(this.getProperty("bins", null));
                let min = Number.MAX_VALUE;
                let max = Number.MIN_VALUE;
                let haveMin = false;
                let haveMax = false;
                if (this.getBinMin()) {
                    min = parseFloat(this.getBinMin());
                    haveMin = true;
                }
                if (this.getBinMax()) {
                    max = parseFloat(this.getBinMax());
                    haveMax = true;
                }

                let goodValues = [];
                for (let i = 1; i < dataList.length; i++) {
                    let tuple = this.getDataValues(dataList[i]);
                    let value = tuple[1];
                    if (!Utils.isRealNumber(value)) {
                        continue;
                    }
                    if (!haveMin)
                        min = Math.min(value, min);
                    if (!haveMax)
                        max = Math.max(value, max);
                    goodValues.push(value);
                }

                let binList = [];
                let step = (max - min) / bins;
                for (let binIdx = 0; binIdx < bins; binIdx++) {
                    binList.push({
                        min: min + binIdx * step,
                        max: min + (binIdx + 1) * step,
                        values: []
                    });
                }

                for (let rowIdx = 0; rowIdx < goodValues.length; rowIdx++) {
                    let value = goodValues[rowIdx];
                    let ok = false;

                    for (let binIdx = 0; binIdx < binList.length; binIdx++) {
                        if (value < binList[binIdx].min || (value >= binList[binIdx].min && value <= binList[binIdx].max)) {
                            binList[binIdx].values.push(value);
                            ok = true;
                            break;
                        }
                    }
                    if (!ok) {
                        binList[binList.length - 1].values.push(value);
                    }
                }
                for (let binIdx = 0; binIdx < bins; binIdx++) {
                    let bin = binList[binIdx];
                    list.push(["Bin:" + this.formatNumber(bin.min) + "-" + this.formatNumber(bin.max),
                               bin.values.length
			      ]);
                }
            } else if(this.getSumFields()) {
		dataTable = new google.visualization.DataTable();
		dataTable.addColumn("string", "Category");
		dataTable.addColumn("number", "Value");
		let records=  this.filterData();
		let sumFields =  this.getFieldsByIds(null, this.getSumFields());
		let sums = [];
		sumFields.map(f=>{sums.push(0)});
		if(this.chartCount>=0) {
		    records = [records[this.chartCount]];
		}
                records.map(record=>{
		    sumFields.map((f,idx)=>{
			let v = record.getValue(f.getIndex());
			if(!isNaN(v))  sums[idx]+=v;
		    });
		});
		sumFields.map((f,idx)=>{
                    list.push([f.getLabel(this),sums[idx]>0?sums[idx]:0]);
		});

            } else {
                for (let i = 1; i < dataList.length; i++) {
                    let tuple = this.getDataValues(dataList[i]);
                    let s = "" + (tuple.length == 1 ? "#" + i : tuple[0]);
                    let v = tuple.length == 1 ? tuple[0] : tuple[1];
                    list.push([s, v]);
                }
            }
	    list.map(tuple=>{
		let s = tuple[0];
		if(!this.uniqueValuesMap[s]) {
		    this.uniqueValuesMap[s] = true;
		    this.uniqueValues.push(s);
		}
	    });
            dataTable.addRows(list);
            return dataTable;
        }
    });


}


//TODO: this is broken because we don't load the sankey package because it loads an old version of d3


function SankeyDisplay(displayManager, id, properties) {
    this.tries = 0;
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_SANKEY, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
	getRequiredPackages: function() {
	    return ['sankey'];
	},
	getDoDyamicTooltip: function() {
	    return false;
	},

        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            chartOptions.height = parseInt(this.getProperty("chartHeight", this.getProperty("height", "400")));
            chartOptions.sankey = {
                node: {
                    colors: this.colors,
                    width: 5,
                },
                link: {
                    colorMode: 'source',
                    colors: this.colors,
                    color: {
                        //                                stroke:'black',
                        //strokeWidth:1,
                    }
                }
            }
	    return new google.visualization.Sankey(chartDiv);
        },
        defaultSelectedToAll: function() {
            return true;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            if (!this.getProperty("doCategories", false)) {
                let values = this.makeDataArray(dataList);
                return google.visualization.arrayToDataTable(values);
            }
            let strings = [];
            for (let i = 0; i < selectedFields.length; i++) {
                let field = selectedFields[i];
                if (field.isFieldString()) {
                    strings.push(field);
                }
            }
            let values = [];
            values.push(["characteristic 1", "characteristic 2", "value"]);
            for (let i = 1; i < strings.length; i++) {
                let field1 = strings[i - 1];
                let field2 = strings[i];
                let cnts = {};
                for (let r = 1; r < dataList.length; r++) {
                    let row = this.getDataValues(dataList[r]);
                    let value1 = row[i - 1];
                    let value2 = row[i];
                    let key = value1 + "-" + value2;
                    if (!cnts[key]) {
                        cnts[key] = {
                            v1: value1,
                            v2: value2,
                            cnt: 0
                        }
                    }
                    cnts[key].cnt++;
                }
                for (a in cnts) {
                    values.push([cnts[a].v1, cnts[a].v2, cnts[a].cnt]);
                }
            }
            return google.visualization.arrayToDataTable(values);
        }
    });
}

function WordtreeDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_WORDTREE, properties);
    let myProps = [
	{label:"Word Tree"},
	{p:"treeRoot",d:"root", tt:"Word to use for root"},
	{p:"wordColors",ex:"red,green,blue",tt:"Colors to use for tree levels"},
	{p:"fixedSize",d:"false",tt:""},
	{p:"buckets",ex:"100,110,115,120,130",tt:"For numeric fields the buckets to put the records in"},	
	{p:"&lt;field&gt;.buckets",ex:"100,110,115,120,130",tt:"Specify buckets for a particular field"},
	{p:"bucketLabels",ex:"young,middle,old,really_old",tt:"For numeric fields the labels used for the buckets"},	
	{p:"&lt;field&gt;.bucketLabels",ex:"young,middle,old,really_old",tt:"Specify bucket labels for a particular field"},			
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        handleEventRecordSelection: function(source, args) {},
	getRequiredPackages: function() {
	    return ['wordtree'];
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            if (this.getProperty("chartHeight"))
                chartOptions.height = parseInt(this.getProperty("chartHeight"));
            if (this.getWordColors()) {
                let tmp = this.getWordColors().split(",");
                let colors = [];
                for (let i = 0; i < 3 && i < tmp.length; i++) {
                    colors.push(tmp[i]);
                }
                if (colors.length == 3)
                    chartOptions.colors = colors;
            }

            if (this.getProperty("chartWidth")) {
                chartOptions.width = parseInt(this.getProperty("chartWidth"));
            }

            chartOptions.wordtree = {
                format: 'implicit',
                wordSeparator: "_SEP_",
                word: this.getTreeRoot(),
                //                    type: this.getProperty("treeType","double")

            }
            if (this.getProperty("maxFontSize")) {
                chartOptions.maxFontSize = parseInt(this.getProperty("maxFontSize"));
            }

            return new google.visualization.WordTree(chartDiv); 
        },


        makeDataTable: function(dataList, props, selectedFields) {
            //null ->get all data
            let root = this.getTreeRoot();
            let records = this.filterData(null, selectedFields, {skipFirst:true});
            let fields = this.getSelectedFields(this.getData().getRecordFields());
            let valueField = this.getFieldById(null, this.getProperty("colorBy"));
            let values = [];
            let typeTuple = ["phrases"];
            values.push(typeTuple);
            let fixedSize = this.getFixedSize();
            if (valueField)
                fixedSize = 1;
            if (fixedSize) typeTuple.push("size");
            if (valueField)
                typeTuple.push("value");
            let fieldInfo = {};

            let header = "";
            for (let i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (header != "")
                    header += " -&gt;";
                header += field.getLabel(this);
                if (!field.isFieldNumeric()) continue;
                let column = this.getColumnValues(records, field);
                let buckets = [];
                let argBuckets = this.getProperty("buckets." + field.getId(), this.getProperty("buckets", null));
                let min, max;
                if (argBuckets) {
                    let argBucketLabels = this.getProperty("bucketLabels." + field.getId(), this.getProperty("bucketLabels", null));
                    let bucketLabels;
                    if (argBucketLabels)
                        bucketLabels = argBucketLabels.split(",");
                    let bucketList = argBuckets.split(",");
                    let prevValue = 0;
                    for (let bucketIdx = 0; bucketIdx < bucketList.length; bucketIdx++) {
                        let v = parseFloat(bucketList[bucketIdx]);
                        if (bucketIdx == 0) {
                            min = v;
                            max = v;
                        }
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                        if (bucketIdx > 0) {
                            let label;
                            if (bucketLabels && i <= bucketLabels.length)
                                label = bucketLabels[bucketIdx - 1];
                            else
                                label =this.formatNumber(prevValue) + "-" + this.formatNumber(v);
                            buckets.push({
                                min: prevValue,
                                max: v,
                                label: label
                            });
                        }
                        prevValue = v;
                    }
                } else {
                    let numBuckets = parseInt(this.getProperty("numBuckets." + field.getId(), this.getProperty("numBuckets", 10)));
                    min = column.min;
                    max = column.max;
                    let step = (column.max - column.min) / numBuckets;
                    for (let bucketIdx = 0; bucketIdx < numBuckets; bucketIdx++) {
                        let r1 = column.min + (bucketIdx * step);
                        let r2 = column.min + ((bucketIdx + 1) * step);
			let label = this.formatNumber(r1) + "-" + this.formatNumber(r2);
                        buckets.push({
                            min: r1,
                            max: r2,
                            label: label
                        });
                    }
                }
                fieldInfo[field.getId()] = {
                    min: min,
                    max: max,
                    buckets: buckets
                };
            }

            let sep = "_SEP_";
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                let string = root;
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    string += sep;
                    let value = row[field.getIndex()];
                    if (field.isFieldNumeric()) {
                        let info = fieldInfo[field.getId()];
                        for (let bucketIdx = 0; bucketIdx < info.buckets.length; bucketIdx++) {
                            let bucket = info.buckets[bucketIdx];
                            if (value >= bucket.min && value <= bucket.max) {
                                value = bucket.label;
                                break;
                            }
                        }
                    }
                    string += value;
                }
                let data = [string.trim()];
                if (fixedSize) data.push(parseInt(fixedSize));
                if (valueField)
                    data.push(row[valueField.getIndex()]);
                values.push(data);
            }
            if (this.getProperty("header")) {
                header = this.getProperty("header", "");
            } else {
                header = "<b>Fields: </b>" + header;
                if (this.getProperty("headerPrefix"))
                    header = this.getProperty("headerPrefix") + " " + header;
            }
            this.writeHtml(ID_DISPLAY_TOP, header);
            return google.visualization.arrayToDataTable(values);
        },
    });
}



function TableDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TABLE, properties);
    let myProps = [
	{label:'Table'},
	{p:'imageField',ex:''},
	{p:'tableWidth',ex:'100%'},
	{p:'frozenColumns',ex:'1'},
	{p:'colorCells',ex:'field1,field2'},
	{p:'foregroundColor'},
	{p:'showRowNumber',ex:true},
	{p:'field.colorTable',ex:''},
	{p:'field.colorByMap',ex:'value1:color1,value2:color2'},
	{p:'maxHeaderLength',ex:'60'},
	{p:'maxHeaderWidth',ex:'60'},
	{p:'headerStyle'}];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	getRequiredPackages: function() {
	    return ['table'];
	},
        canDoGroupBy: function() {
            return true;
        },
        defaultSelectedToAll: function() {
            return true;
        },
        getDataTableValueGetter: function(records) {
	    let unhighlightColor = this.getProperty("unhighlightColor","#fff");
	    let highlightColor = this.getProperty("highlightColor","#FFFFCC");
	    let colorCells = this.getProperty("colorCells");
	    let colorByMap = {};
	    let linkField = this.getFieldById(null,this.getProperty("linkField"));
	    let iconField = this.getFieldById(null,this.getProperty("iconField"));
	    let foreground = this.getProperty("foregroundColor");
	    let cbs = [];
	    if(colorCells) {
		colorCells.split(",").forEach(c=>{
		    let f = this.getFieldById(null,c);
		    if(f) {
			colorByMap[c] = new ColorByInfo(this, null, records, null,c+".colorByMap",null, c, f);
			cbs.push(colorByMap[c]);
		    }
		});
	    }

	    //Show the bars
	    let dom = this.jq(ID_COLORTABLE);
	    cbs.forEach((cb,idx)=>{
		let id = this.domId(ID_COLORTABLE+idx);
		dom.append(HU.div([ID,id]));
		cb.displayColorTable(null,true,ID_COLORTABLE+idx);
	    });


	    return  (v,idx, field, record)=>{
		if(v===null) {
		    return {
			v:0,
			f:""
		    }
		}
		let f = v;
		if(v && v.f) {
		    f = v.f;
		    v = v.v;
		}
		if(v && v.getTime) {
		    f = this.formatDate(v);
		}
		if(iconField && record && idx==0) {
		    let icon = record.getValue(iconField.getIndex());
		    f = HU.image(icon) +"&nbsp;" +f;
		}
		if(linkField && record&& idx==0) {
		    let url = record.getValue(linkField.getIndex());
		    if(f) f = f.trim();
		    if (Utils.isDefined(f) && f!="") {
			f = HU.href(url,f);
		    }
		}

		if(!this.getFilterHighlight() || !record) {
		    f = HU.div([STYLE,HU.css('padding','4px')],f)
		} else {
		    let c = record.isHighlight(this) ? highlightColor: unhighlightColor;
		    f = HU.div([STYLE,HU.css('padding','4px','background', c)],f)
		}


		if(field) {
		    let colorBy = colorByMap[field.getId()];
		    if(colorBy && record) {
			let color =  colorBy.getColorFromRecord(record);
			let fg = foreground || Utils.getForegroundColor(color);
			f = HU.div([STYLE,HU.css('height','100%','background', color,'color',fg+" !important")],f)
		    }
		    if(field.getType()=="url") {
			if(!v.startsWith('http')) v = 'https://' + v;
			return {
			    v:v,
			    f:HU.href(v,v,['target','_link'])
			};
		    }
		    if(field.getType()=="image") {
			return {
			    v:v,
			    f:HU.href(v,HU.image(v,[WIDTH,this.getProperty("imageWidth",100)]))
			};
		    }		    
		}

		return {
		    v:v,
		    f:f
		};
	    }
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(!expandedHeight) {
		chartOptions.height = null;
		if (this.chartHeight) {
                    chartOptions.height = this.chartHeight;
		}
		if (chartOptions.height == null) {
                    let height = this.getProperty("height", null);
                    if (height) {
			chartOptions.height = height;
                    }
		}
		if (chartOptions.height == null) {
                    chartOptions.height = "300px";
		}
	    }


	    if(this.debugChartOptions)
		console.log(JSON.stringify(chartOptions,null,2));
            chartOptions.allowHtml = true;
	    if(this.getProperty("tableWidth"))
		chartOptions.width=this.getProperty("tableWidth");
            chartOptions.frozenColumns =this.getProperty("frozenColumns",0);
	    chartOptions.showRowNumber=this.getProperty("showRowNumber",false);

            if (dataList.length && this.getDataValues(dataList[0]).length > 4) {
                chartOptions.cssClassNames = {
                    headerCell: 'display-table-header-max'
                };
            } else {
                chartOptions.cssClassNames = {
                    headerCell: 'display-table-header'
                };
            }
	    if(!chartOptions.cssClassNames)
		chartOptions.cssClassNames = {};

	    if(this.getProperty("fixCellHeight",true)) {
		chartOptions.cssClassNames.headerCell= 'display-table-cell';
		chartOptions.cssClassNames.tableCell= 'display-table-cell';
	    }
            return new google.visualization.Table(chartDiv); 
        },
	doAddTooltip: function() {
	    return false;
	},
	getAddStyle: function() {
	    return false;
	},
	getFormatNumbers: function() {
	    return true;
	},
        setChartSelection: function(index) {
	    SUPER.setChartSelection.call(this,index);
	    var container = this.jq(ID_CHART).find('.google-visualization-table-table:eq(0)').parent();
	    var row = this.jq(ID_CHART).find('.google-visualization-table-tr-sel');
	    //	    var header = this.jq(ID_CHART).find('.google-visualization-table-table:eq(1)').parent();

	    //The header selector doesn't work so for now just offset by 60
	    //$(container).prop('scrollTop', $(row).prop('offsetTop') - $(header).height());
	    $(container).prop('scrollTop', $(row).prop('offsetTop')-60);
	},
        xxxxmakeDataTable: function(dataList, props, selectedFields) {
            let rows = this.makeDataArray(dataList);
            let data = [];
            for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                let row = rows[rowIdx];
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
		    let t = (typeof row[colIdx]);
                    if (t == "string") {
                        row[colIdx] = row[colIdx].replace(/\n/g, "<br>");
			if(row[colIdx].startsWith("http:") || row[colIdx].startsWith("https:")) {
			    row[colIdx] = "<a href='" +row[colIdx] +"'>" + row[colIdx]+"</a>";
			}
		    } else if(t == "number") {
			//This doesn't stick
			if(isNaN(row[colIdx])) 
			    row[colIdx] = "--";
		    }
                }
                data.push(row);
            }
            return google.visualization.arrayToDataTable(data);
        }
    });

}



function BubbleDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_BUBBLE, properties);
    let myProps = [
	{label:'Bubble Chart Attibutes'},
	{p:'xField'},
	{p:'yField'},	
	{p:'labelField'},
	{p:'colorBy'},
	{p:'sizeField'},	
	{p:'legendPosition',ex:'none|top|right|left|bottom'},
	{p:'hAxisFormat',ex:'none|decimal|scientific|percent|short|long'},
	{p:'vAxisFormat',ex:'none|decimal|scientific|percent|short|long'},
	{p:'hAxisTitle',ex:''},
	{p:'vAxisTitle',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getChartDiv: function(chartId) {
            let divAttrs = [ATTR_ID, chartId];
            divAttrs.push(STYLE);
            let style = "";
	    let width = this.getProperty("chartWidth") || this.getChartWidth();
	    let height = this.getProperty("chartHeight") || this.getChartHeight();
            if (width) {
                if (width > 0)
                    style += "width:" + width + "px;";
                else if (width < 0)
                    style += "width:" + (-width) + "%;";
                else
                    style += "width:" + width + ";";
            } else {
                style += "width:" + "100%;";
            }
            if (height) {
                if (height > 0)
                    style += "height:" + height + "px;";
                else if (height < 0)
                    style += "height:" + (-height) + "%;";
                else
                    style += "height:" + height + ";";
            } else {
                style += "height:" + "100%;";
            }
	    //	    style += "border:1px solid green;"
	    style += "padding:5px;"
            divAttrs.push(style);
            return HU.div(divAttrs, "");
        },

	getFieldsToDisplay: function(fields) {
	    if(fields.length>=4) return fields;
	    let labelField=this.getFieldById(null, this.getProperty("labelField"));
	    let colorField=this.getFieldById(null, this.getColorBy(this.getProperty("colorField")));
	    let sizeField=this.getFieldById(null, this.getProperty("sizeField"));
	    let xField=this.getFieldById(null, this.getProperty("xField"));
	    let yField=this.getFieldById(null, this.getProperty("yField"));	    	    	    	    
	    if(!labelField) throw new Error("Need to specify labelField");
	    if(!xField) throw new Error("Need to specify xField");
	    if(!yField) throw new Error("Need to specify yField");	    
	    let f = [labelField, xField, yField];
	    if(colorField) f.push(colorField);
	    if(sizeField) f.push(sizeField);
	    return f;
	},

        makeDataTable: function(dataList, props, selectedFields, chartOptions) {
	    let debug =displayDebug.makeDataTable;
	    if(debug) {
		this.logMsg(this.type+" makeDataTable #records:" + dataList.length);
                let fields = this.getSelectedFields();
		console.log("\tfields:" + fields);
	    }
	    let tmp =[];
	    let a = this.makeDataArray(dataList);
	    while(a[0].length<5)
		a[0].push("");
	    tmp.push(a[0]);
	    //Remove nans
	    this.didUnhighlight = false;
	    let minColorValue = Number.MAX_SAFE_INTEGER;
	    for(let i=1;i<a.length;i++) {
		let tuple = a[i];
		while(tuple.length<5) {
		    tuple.push(1);
		}
		minColorValue = Math.min(minColorValue, tuple[3]);
	    }


	    for(let i=1;i<a.length;i++) {
		let tuple = a[i];
		while(tuple.length<5)
		    tuple.push(1);
		if(debug && i<5)
		    console.log("\tdata:" + tuple);
		let ok = true;
		for(j=1;j<tuple.length && ok;j++) {
		    if(isNaN(tuple[j])) ok = false;
		}
		//If highlighting and have color then set to NaN
		if(this.getFilterHighlight()) {
		    let unhighlightColor = this.getProperty("unhighlightColor","#eee");
		    if(dataList[i].record && !dataList[i].record.isHighlight(this)) {
			this.didUnhighlight = true;
			tuple[3] =minColorValue-0.111;
		    }
		}
		if(ok) 
		    tmp.push(tuple);
	    }
            return google.visualization.arrayToDataTable(tmp);
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            let ct = this.getColorTable(true);
            if (ct) {
                chartOptions.colors = ct;
            } else if (!this.colors) {
                chartOptions.colors = this.getColorList();
            }
            if (chartOptions.colors) {
                chartOptions.colors = Utils.getColorTable("rainbow", true);
            }
	    $.extend(chartOptions.chartArea, {
                left: this.getChartLeft(this.chartDimensions.left),
                right: this.getChartRight(this.chartDimensions.right),
                top: this.getChartTop(10),
		bottom: this.getChartBottom(40),
                height: this.getChartHeight(200)
            });
            chartOptions.height = "100px";
            chartOptions.sizeAxis = {
	    }

            chartOptions.colorAxis = {
                legend: {
                    position: this.getProperty("legendPosition", "in")
                }
            }
	    let colorTable = this.getColorTable(true);
	    if(colorTable) {
		chartOptions.colorAxis.colors = colorTable;
		if(this.didUnhighlight) {
		    chartOptions.colorAxis.colors = [...chartOptions.colorAxis.colors];
		    chartOptions.colorAxis.colors.unshift(this.getProperty("unhighlightColor","#eee"));
		}
	    }

            chartOptions.bubble = {
                textStyle: {
                    auraColor: "none"
                },
                stroke: "#666"
            };


            header = this.getDataValues(dataList[0]);
	    chartOptions.hAxis = chartOptions.hAxis||{};
            chartOptions.vAxis = chartOptions.vAxis||{};

	    chartOptions.hAxis.minValue = this.getProperty("hAxisMinValue");
	    chartOptions.hAxis.maxValue = this.getProperty("hAxisMaxValue");
	    chartOptions.vAxis.minValue = this.getProperty("vAxisMinValue");
	    chartOptions.vAxis.maxValue = this.getProperty("vAxisMaxValue");


            let records = this.getPointData().getRecords();
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[1]);
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }
	    if(this.getProperty("vAxisFixedRange")) {
		let y = this.getColumnValues(records, selectedFields[2]);
		chartOptions.vAxis.minValue = y.min;
		chartOptions.vAxis.maxValue = y.max;
	    }



	    chartOptions.vAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");
	    chartOptions.hAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");

            chartOptions.hAxis.format = this.getProperty("hAxisFormat", null);
            chartOptions.vAxis.format = this.getProperty("vAxisFormat", null);

            chartOptions.hAxis.title = this.getProperty("hAxisTitle", header.length > 1 ? header[1] : null);
            chartOptions.vAxis.title = this.getProperty("vAxisTitle", header.length > 2 ? header[2] : null);

	    //	    console.log(JSON.stringify(chartOptions,null,2));

            return new google.visualization.BubbleChart(chartDiv); 
        }

    });
}


function BartableDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, DISPLAY_BARTABLE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
	getRequiredPackages: function() {
	    return ['bar'];
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            let height = "";
            if (Utils.isDefined(this.getChartHeight())) {
                height = this.getChartHeight();
            } else {
                if (dataList.length > 1) {
                    let numBars = dataList.length;
                    if (this.getProperty('isStacked')) {
                        height = numBars * 22;
                    } else {
                        height = numBars * 22 + numBars * 14 * (this.getDataValues(dataList[0]).length - 2);
                    }
                }
            }
            $.extend(chartOptions, {
                title: '',
                bars: 'horizontal',
                colors: this.getColorList(),
                width: (Utils.isDefined(this.getChartWidth()) ? this.getChartWidth() : "100%"),
                chartArea: {
                    left: this.getChartLeft('30%'),
                    top: 0,
                    width: '70%',
                    height: '80%'
                },
                height: height,
                bars: 'horizontal',
                tooltip: {
                    showColorCode: true,
		    isHtml:true
                },
                legend: {
                    position: 'none'
                },
            });

            if (Utils.isDefined(this.getProperty('isStacked'))) {
                chartOptions.isStacked = this.getProperty('isStacked');
            }

            if (this.getProperty('hAxisTitle'))
                chartOptions.hAxis = {
                    title: this.getProperty('hAxisTitle')
                };
            if (this.getProperty('vAxisTitle'))
                chartOptions.vAxis = {
                    title: this.getProperty('vAxisTitle')
                };
            return new google.visualization.BarChart(chartDiv);
	    //            return new google.charts.Bar(chartDiv); 
        },
        getDefaultSelectedFields: function(fields, dfltList) {
            let f = [];
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (!field.isNumeric()) {
                    f.push(field);
                    break;
                }
            }
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.isNumeric()) {
                    f.push(field);
                    break;
                }
            }
            return f;
        }
    });


}


function TreemapDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TREEMAP, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        handleEventRecordSelection: function(source, args) {},
	getRequiredPackages: function() {
	    return ['treemap'];
	},
        getFieldsToSelect: function(pointData) {
	    if(this.convertedFields) return this.convertedFields;
            return pointData.getRecordFields();
        },
        tooltips: {},
        makeChartOptions: function(dataList, props, selectedFields) {
            let _this = this;
            let tooltip = function(row, size, value) {
                if (_this.tooltips[row]) {
                    return _this.tooltips[row];
                }
                return "<div class='display-treemap-tooltip-outer'><div class='display-treemap-tooltip''><i>left-click: go down<br>right-click: go up</i></div></div>";
            };
            let chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            $.extend(chartOptions, {
                highlightOnMouseOver: true,
                generateTooltip: tooltip,
                maxDepth: parseInt(this.getProperty("maxDepth", 2)),
                maxPostDepth: parseInt(this.getProperty("maxPostDepth", 3)),
            });

            return chartOptions;
        },
        defaultSelectedToAll: function() {
            return true;
        },

        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            let dataTable = this.makeDataTable(dataList, props, selectedFields, chartOptions);
            if (!dataTable) return null;
            return new google.visualization.TreeMap(chartDiv);
        },

        addTuple: function(data, colorField, seen, value, parent, n1, n2) {
            let ovalue = value;
            let cnt = 0;
            if (Utils.isDefined(seen[value]) && parent) {
                value = parent + ":" + value;
            }
            while (true) {
                if (!Utils.isDefined(seen[value])) {
                    seen[value] = true;
                    break;
                }
                value = ovalue + " " + (++cnt);
            }
            let tuple = [value, parent, n1];
            if (colorField) tuple.push(n2);
            data.push(tuple);
            return value;
        },

        valueClicked: function(field, value) {
            field = this.getFieldById(this.getFields(), field);
            this.propagateEvent("fieldValueSelected", {
                field: field,
                value: value
            });
        },
        makeDataTable: function(dataList, props, selectedFields) {
            let records = this.filterData(null,null,{skipFirst:true});
            if (!records) {
                return null;
            }
            let allFields = this.getFields();
            let fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            let strings = this.getFieldsByType(fields, "string");
            if (strings.length < 2) {
                this.displayError("No string fields specified");
                return null;
            }
            let addPrefix = this.getProperty("addPrefix", true);
            let sizeField = this.getFieldById(allFields, this.getProperty("sizeBy"));
            let colorField = this.getFieldById(allFields, this.getProperty("colorBy"));
            let values = this.getFieldsByType(fields, "numeric");
            if (!sizeField && values.length > 0)
                sizeField = values[0];
            if (!colorField && values.length > 1)
                colorField = values[1];

            let tooltipFields = [];
            let toks = this.getProperty("tooltipFields", "").split(",");
            for (let i = 0; i < toks.length; i++) {
                let tooltipField = this.getFieldById(null, toks[i]);
                if (tooltipField)
                    tooltipFields.push(tooltipField);
            }
            if (tooltipFields.length == 0) tooltipFields = allFields;

            this.tooltips = {};

            let columns = [];
            for (let fieldIndex = 0; fieldIndex < strings.length; fieldIndex++) {
                let field = strings[fieldIndex];
                columns.push(this.getColumnValues(records, field).values);
            }

            let data = [];
            let leafs = [];
            let tmptt = [];
            let seen = {};
            this.addTuple(data, colorField, {}, "Node", "Parent", "Value", "Color");
            let root = strings[0].getLabel(this);
            this.addTuple(data, colorField, seen, root, null, 0, 0);
            let keys = {};
            let call = this.getGet();
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                //               if(rowIdx>20) break;
                let row = this.getDataValues(records[rowIdx]);
                let key = "";
                let parentKey = "";
                for (let fieldIndex = 0; fieldIndex < strings.length - 1; fieldIndex++) {
                    let values = columns[fieldIndex];
                    if (key != "")
                        key += ":";
                    key += values[rowIdx];
                    if (!Utils.isDefined(keys[key])) {
                        let parent = Utils.isDefined(keys[parentKey]) ? keys[parentKey] : root;
                        let value = values[rowIdx];
                        if (addPrefix && fieldIndex > 0)
                            value = parent + ":" + value;
                        keys[key] = this.addTuple(data, colorField, seen, value, parent, 0, 0);
                    }
                    parentKey = key;
                }
                let parent = Utils.isDefined(keys[parentKey]) ? keys[parentKey] : root;
                let value = row[strings[strings.length - 1].getIndex()];
                let size = sizeField ? row[sizeField.getIndex()] : 1;
                let color = colorField ? row[colorField.getIndex()] : 0;
                value = this.addTuple(leafs, colorField, seen, value, parent, size, color);
                let tt = "<div class='display-treemap-tooltip-outer'><div class='display-treemap-tooltip''>";
                for (let f = 0; f < tooltipFields.length; f++) {
                    let v = row[tooltipFields[f].getIndex()];
                    let field = tooltipFields[f];
                    v = HU.onClick(call + ".valueClicked('" + field.getId() + "','" + v + "')", v, []);
                    tt += HU.b(field.getLabel(this)) + ": " + v + "<br>";
                }
                tt += "</div></div>";
                tmptt.push(tt);
            }
            for (let i = 0; i < leafs.length; i++) {
                data.push(leafs[i]);
                this.tooltips[data.length - 2] = tmptt[i];
            }
            return google.visualization.arrayToDataTable(data);
        },
    });
}



function TimerangechartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TIMERANGECHART, properties);
    let myProps = [
	{label:'Time Range'},
	{p:'startDateField',ex:''},
	{p:'endDateField',ex:''},
	{p:'labelFields',ex:''},
	{p:'showLabel',ex:'false'},		
	{p:"fontSize",d:10},
	{p:"font",d:'Helvetica'},
	{p:'alternatingRowStyle',d:'true',ex:'false'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	getRequiredPackages: function() {
	    return ['timeline'];
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    if(this.dataColors && this.dataColors.length)
		chartOptions.colors = this.dataColors;

	    chartOptions.alternatingRowStyle = this.getAlternatingRowStyle();
	    chartOptions.timeline =  {
		rowLabelStyle: {fontName: this.getFont(), fontSize: this.getFontSize()},
                barLabelStyle: {fontName: this.getFont(), fontSize:  this.getFontSize() }
	    };

	    chartOptions.tooltip = null;
            return new google.visualization.Timeline(chartDiv);
        },
        makeDataTable: function(dataList, props, selectedFields) {
	    let tt = this.getProperty("tooltip");
	    let addTooltip = (tt || this.getProperty("addTooltip",false)) && this.doAddTooltip();
	    let records = this.filterData(null,null,{skipFirst:true});
            let strings = [];
            let stringField = this.getFieldByType(selectedFields, "string");
            if (!stringField)
                stringField = this.getFieldByType(null, "string");
            let showLabel = this.getProperty("showLabel", true);
            let labelFields = [];
            let labelFieldsTemplate = this.getProperty("labelFieldsTemplate");
            let toks = this.getProperty("labelFields", "").split(",");
            for (let i = 0; i < toks.length; i++) {
                let field = this.getFieldById(null, toks[i]);
                if (field)
                    labelFields.push(field);
            }

	    let startDateField = this.getFieldById(null,this.getPropertyStartDateField());
	    let endDateField = this.getFieldById(null,this.getPropertyEndDateField());
            let dateFields = [];
	    if(startDateField==null || endDateField==null) {
                dateFields = this.getFieldsByType(null, "date");
	    } else {
		dateFields = [startDateField, endDateField];
	    }
            let values = [];
            let dataTable = new google.visualization.DataTable();
            if (dateFields.length < 2) {
                throw new Error("Need to have at least 2 date fields");
            }

            if (stringField) {
                dataTable.addColumn({
                    type: 'string',
                    id: stringField.getLabel(this)
                });
            } else {
                dataTable.addColumn({
                    type: 'string',
                    id: "Index"
                });
            }

	    labelFields = [];

            if (labelFields.length > 0) {
                dataTable.addColumn({
                    type: 'string',
                    id: 'Label'
                });
            } else if(addTooltip) {
                dataTable.addColumn({
                    type: 'string',
                    id: 'dummy'
                });
	    }
	    if(addTooltip)  {
		dataTable.addColumn({
                    type: 'string',
                    role: 'tooltip',
                    'p': {
			'html': true
                    }});
	    }

            dataTable.addColumn({
                type: 'date',
                id: dateFields[0].getLabel(this)
            });
            dataTable.addColumn({
                type: 'date',
                id: dateFields[1].getLabel(this)
            });


            let colorBy = this.getColorByInfo(records);
	    if(colorBy.isEnabled()) {
		this.dataColors = [];
	    }

            for (let r = 0; r < records.length; r++) {
		let record = records[r];
                let row = this.getDataValues(records[r]);
                let tuple = [];
		if(this.dataColors) {
		    let c = colorBy.getColorFromRecord(record, "blue");
		    this.dataColors.push(c);
		}
                values.push(tuple);
                if (stringField && showLabel)
                    tuple.push(row[stringField.getIndex()]);
                else
                    tuple.push("#" + (r + 1));
                if (labelFields.length > 0) {
                    let label = "";
                    if (labelFieldsTemplate)
                        label = labelFieldsTemplate;
                    for (let l = 0; l < labelFields.length; l++) {
                        let f = labelFields[l];
                        let value = row[f.getIndex()];
                        if (labelFieldsTemplate) {
                            label = label.replace("{" + f.getId() + "}", value);
                        } else {
                            label += value + " ";
                        }

                    }
                    tuple.push(label);
                } else 	if(addTooltip)  {
		    tuple.push(null);
		}
		if(addTooltip)  {
		    let text =   this.getRecordHtml(record, null, tt);
		    tuple.push(text);
		}
                tuple.push(row[dateFields[0].getIndex()]);
                tuple.push(row[dateFields[1].getIndex()]);
            }
            dataTable.addRows(values);
	    if(colorBy.isEnabled()) {
		colorBy.displayColorTable(null,true);
	    }
            return dataTable;
        }
    });
}



function CalendarDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_CALENDAR, properties);
    let myProps = [
	{label:'Calendar'},
	{p:'cellSize',d:15,ex:"15"},
	{p:'missingValue',ex:""},	
	{p:'strokeColor',d: '#76a7fa', ex:'#76a7fa'},
	{p:'strokeWidth',ex:'1'},
	{p:'strokeOpacity',d:0.5,ex:'0.5'},	    		
	{p:'noDataBackground',ex:'green'},
	{p:'noDataColor',ex:'red'},
	{p:'colorAxis',ex:'red,blue'},	

    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	getDoDyamicTooltip: function() {
	    return false;
	},
	getRequiredPackages: function() {
	    return ['calendar'];
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    let opts = {
		calendar: {
                    cellSize: parseInt(this.getPropertyCellSize()),
		    cellColor: {
			stroke: this.getPropertyStrokeColor(),
			strokeOpacity: this.getPropertyStrokeOpacity(),
			strokeWidth: this.getPropertyStrokeWidth(1),
		    },
		},
		height: this.getProperty("height", 800),
		noDataPattern: {
		    backgroundColor: this.getPropertyNoDataBackground(),
		    color: this.getPropertyNoDataColor()
		},
	    };
	    let colors = this.getPropertyColorAxis();
	    if(colors) {
		opts.colorAxis =  {
		    colors:colors.split(",")
		}
	    }
	    $.extend(chartOptions, opts);
            //If a calendar is show in tabs then it never returns from the draw
            if (this.jq(ID_CHART).width() == 0) {
                return;
            }

            let cal =  new google.visualization.Calendar(chartDiv);
	    return cal;

        },
        defaultSelectedToAll: function() {
            return true;
        },
        getContentsStyle: function() {
            let height = this.getProperty("height", 800);
            if (height > 0) {
                return " height:" + height + "px; " + " max-height:" + height + "px; overflow-y: auto;";
            }
            return "";
        },
        canDoMultiFields: function() {
            return false;
        },
        getIncludeIndexIfDate: function() {
            return true;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            let dataTable = new google.visualization.DataTable();
            let header = this.getDataValues(dataList[0]);
            if (header.length < 2) return null;
            dataTable.addColumn({
                type: 'date',
                id: 'Date'
            });
            dataTable.addColumn({
                type: 'number',
                id: header[1]
            });
            dataTable.addColumn({
                type: 'string',
                role: 'tooltip',
                'p': {
                    'html': true
                }
            });
            let haveMissing = false;
            let missing = this.getPropertyMissingValue();
            if (missing) {
                haveMissing = true;
                missing = parseFloat(missing);
            }
            let list = [];
            let cnt = 0;
            let options = {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            };
	    this.dateToRecords = {};
            for (let i = 1; i < dataList.length; i++) {
		let records = this.getBinnedRecords(dataList[i].record);
		let obj = dataList[i];
		if(!records && obj.record) records  = [obj.record];
                let value = this.getDataValues(obj)[1];
                if (value == NaN) continue;
                if (haveMissing && value == missing) {
                    continue;
                }
                cnt++;

		let dttm = this.getDataValues(dataList[i])[0];
		this.dateToRecords[dttm.v.getTime()] = records;
                let tooltip = "<center><b>" + dttm.f + "</b></center>" +
                    "<b>" + header[1].replace(/ /g, "&nbsp;") + "</b>:&nbsp;" + this.formatNumber(value);
                tooltip = HU.div([STYLE, HU.css('padding','5px')], tooltip);
                list.push([this.getDataValues(dataList[i])[0], value, tooltip]);
            }
            dataTable.addRows(list);
            return dataTable;
	}

    });


}









function GaugeDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_GAUGE, properties);
    properties.multiChartsLabelPosition = 'none';
    let myProps = [
	{label:'Gauge'},
	{p:'minorTicks',d:0},
	{p:'majorTicks',ex:'10,20,30,40'},
	{p:'fontSize',ex:'14pt'},
	{p:'greenFrom',ex:0},
	{p:'greenTo',ex:10},
	{p:'yellowFrom',ex:0},
	{p:'yellowTo',ex:10},		
	{p:'redFrom',ex:0},
	{p:'redColor',ex:'#ff0000'},
	{p:'yellowColor',ex:'#ff0000'},
	{p:'greenColor',ex:'#ff0000'},	
	{p:'redTo',ex:10},
	{p:'gaugeMin',tt:'min gauge value'},
	{p:'gaugeMax',tt:'max gauge value'},
	{p:'field_based_values',tt:'all of the above can have fieldid.propert, e.g., temp.redFrom=...'},		
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	getRequiredPackages: function() {
	    return ['gauge'];
	},
        getChartHeight: function() {
            return this.getProperty("chartHeight", this.getChartWidth());
        },
        getChartWidth: function() {
            return this.getProperty("chartWidth", "150");
        },

	//check the font size
	drawChart(chart,dataTable,chartOptions) {
	    SUPER.drawChart.call(this,chart,dataTable,chartOptions);
	    let items = $(chart.container).find('svg g text');
	    if(this.getFontSize()) {
		items.css('font-size',this.getFontSize());
	    }
	},
	doMultiChartsByField:function() {
	    //If we are doing multi charts then do them by field (columns)
	    return true;
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            this.dataList = dataList;
            let field = selectedFields[0];
	    let c = (props)=>{
		props.forEach(prop=>{
		    let v = this.getFieldProperty(field,prop);
		    if(Utils.isDefined(v))
			chartOptions[prop] = v;
		});
	    };
	    c(['redFrom','redTo','yellowFrom','yellowTo','greenFrom','greenTo','greenColor','redColor','yellowColor','min','max']);
	    $.extend(chartOptions,{
		minorTicks: this.getFieldProperty(field,'minorTicks',0)
	    });
	    if(Utils.stringDefined(this.getFieldProperty(field,'majorTicks'))) {
		chartOptions.majorTicks =  Utils.split(this.getFieldProperty(field,'majorTicks'));
	    }

            let min = Number.MAX_VALUE;
            let max = Number.MIN_VALUE;
            let setMinMax = true;
            for (let row = 1; row < dataList.length; row++) {
                let tuple = this.getDataValues(dataList[row]);
                //                        if(tuple.length>2) setMinMax = false;
                for (let col = 0; col < tuple.length; col++) {
                    if (!Utils.isNumber(tuple[col])) {
                        continue;
                    }
                    let value = tuple[col];
                    min = Utils.min(min, value);
                    max = Utils.max(max, value);
                }
            }
            min = Utils.formatNumber(min, true);
            max = Utils.formatNumber(max, true);
	    let gaugeMin  = this.getFieldProperty(field,'gaugeMin');
	    let gaugeMax  = this.getFieldProperty(field,'gaugeMax');
            if (Utils.isDefined(gaugeMin)) {
                setMinMax = true;
                min = parseFloat(gaugeMin);
            }
            if (Utils.isDefined(gaugeMax)) {
                setMinMax = true;
                max = parseFloat(gaugeMax);
            }
            if (setMinMax) {
                chartOptions.min = min;
                chartOptions.max = max;
            }
            return new google.visualization.Gauge(chartDiv);
        },

        makeDataTable: function(dataList, props, selectedFields) {
	    if(dataList==null) return;
            dataList = this.makeDataArray(dataList);
            if (!Utils.isDefined(this.index)) this.index = dataList.length - 1;
            let index = this.index + 1;
            let list = [];
            list.push(["Label", "Value"]);
            let header = this.getDataValues(dataList[0]);
            if (index >= dataList.length) index = dataList.length - 1;
            let row = this.getDataValues(dataList[index]);
            for (let i = 0; i < row.length; i++) {
                if (!Utils.isNumber(row[i])) continue;
                let h = header[i];
                if (h.length > 20) {
                    let index = h.indexOf("(");
                    if (index > 0) {
                        h = h.substring(0, index);
                    }
                }
                if (h.length > 20) {
                    h = h.substring(0, 19) + "...";
                }
                if (this.getProperty("gaugeLabel"))
                    h = this.getProperty("gaugeLabel");
                else if (this["gaugeLabel" + (i + 1)]) h = this["gaugeLabel" + (i + 1)];
                let value = row[i];
                list.push([h, Utils.formatNumber(value, true)]);
            }

            return google.visualization.arrayToDataTable(list);
        },
        setChartSelection: function(index) {
            this.index = index;
	    if(this.multiChartData) {
		this.multiChartData.forEach(info=>{
		    //{dataList:dataList,field:field,chartOptions:chart.chartOptions,chart:chart});
		    let dataTable = this.makeDataTable(info.dataList,info.props, info.fields);
                    this.drawChart(info.chart,dataTable, info.chartOptions);
		});
		return
	    }
            let dataTable = this.makeDataTable(this.dataList);
            this.mapCharts((chart,idx)=>{
                this.drawChart(chart,dataTable, this.chartOptions);
	    });
        },
    });
}




function ScatterplotDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaGoogleChart(displayManager, id, DISPLAY_SCATTERPLOT, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        trendLineEnabled: function() {
            return true;
        },
	setAxisRanges: function(chartOptions, selectedFields, records) {
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[0]);
		if(chartOptions.hAxis) chartOptions.hAxis = {};
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }

	    if(this.getProperty("vAxisFixedRange")) {
		if(chartOptions.vAxis) chartOptions.vAxis = {};
		let x = this.getColumnValues(records, selectedFields[1]);
		chartOptions.vAxis.minValue = x.min;
		chartOptions.vAxis.maxValue = x.max;
	    }
	},
        makeChartOptions: function(dataList, props, selectedFields) {
            let chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            chartOptions.curveType = null;
            chartOptions.lineWidth = 0;
            $.extend(chartOptions, {
                title: '',
                tooltip: {
                    isHtml: true
                },
                legend: 'none',
            });

            if (!chartOptions.chartArea) chartOptions.chartArea = {};
            $.extend(chartOptions.chartArea, {
                left: "10%",
                top: 10,
                height: "80%",
                width: "90%"
            });
            if (this.getShowTitle()) {
                chartOptions.title = this.getTitle(true);
            }

	    if (!chartOptions.hAxis) chartOptions.hAxis = {};
	    if (!chartOptions.vAxis) chartOptions.vAxis = {};
	    if(this.getProperty("hAxisLogScale", false)) 
		chartOptions.hAxis.logScale = true;
	    if(this.getProperty("vAxisLogScale", false)) 
		chartOptions.vAxis.logScale = true;


	    chartOptions.vAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");
	    chartOptions.hAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");

	    /*
	      chartOptions.trendlines =  {
	      0: {
	      type: 'linear',
	      color: 'green',
	      lineWidth: 3,
	      opacity: 0.3,
	      showR2: true,
	      visibleInLegend: true
	      }
	      };		

	    */


            if (dataList.length > 0 && this.getDataValues(dataList[0]).length > 1) {
                if (!chartOptions.vAxis) chartOptions.vAxis = {};
                if (!chartOptions.hAxis) chartOptions.hAxis = {};
		if (this.getProperty("hAxisTitle")) {
                    chartOptions.hAxis.title = this.getProperty("hAxisTitle");
		}
		if (this.getProperty("vAxisTitle")) {
                    chartOptions.vAxis.title = this.getProperty("vAxisTitle");
		}

		if(!chartOptions.hAxis.title) {
                    $.extend(chartOptions.hAxis, {
			title: this.getDataValues(dataList[0])[0]
                    });
		}

		if(!chartOptions.vAxis.title) {
                    $.extend(chartOptions.vAxis, {
			title: this.getDataValues(dataList[0])[1]
                    });
		}
                //We only have the one vAxis range for now
                if (!isNaN(this.getVAxisMinValue())) {
		    //                    chartOptions.hAxis.minValue = this.getVAxisMinValue();
                    chartOptions.vAxis.minValue = this.getVAxisMinValue();
                }
                if (!isNaN(this.getVAxisMaxValue())) {
		    //                    chartOptions.hAxis.maxValue = this.getVAxisMaxValue();
                    chartOptions.vAxis.maxValue = this.getVAxisMaxValue();
                }
            }
	    //	    console.log(JSON.stringify(chartOptions,null,2));

            return chartOptions;
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    if(!chartDiv) return
            let height = this.getProperty("height",400);
            if (Utils.isDefined(this.getProperty("chartHeight"))) {
                height = this.getProperty("chartHeight");
            }
            let width = "100%";
	    if (Utils.isDefined(this.getProperty("chartWidth"))) {
                width = this.getProperty("chartWidth");
            }
	    if((typeof height)=="number") height = height+"px";
	    if((typeof width)=="number") width = width+"px";

            $("#" + chartDiv.id).css("width", width);
            $("#" + chartDiv.id).css("height", height);
            return new google.visualization.ScatterChart(chartDiv);
        },

        getDefaultSelectedFields: function(fields, dfltList) {
            let f = [];
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.isNumeric()) {
                    f.push(field);
                    if (f.length >= 2)
                        break;
                }
            }
            return f;
        }
    });


}



function OrgchartDisplay(displayManager, id, properties) {
    const ID_ORGCHART = "orgchart";
    const SUPER = new RamaddaGoogleChart(displayManager, id, DISPLAY_ORGCHART, properties);
    let myProps = [
	{label:'Orgchart'},
	{p:'labelField',ex:''},
	{p:'parentField',ex:''},
	{p:'idField',ex:''},
	{p:'treeRoot',ex:'some label'},
	{p:'treeTemplate',ex:''},
	{p:'treeNodeSize',ex:'small|medium|large'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER,myProps, {
        handleEventRecordSelection: function(source, args) {},
        needsData: function() {
            return true;
        },
	getRequiredPackages: function() {
	    return ['orgchart'];
	},

	updateUIInner: function() {
            this.displayHtml(HU.div([ID,this.domId(ID_ORGCHART)],""));
	    if(this.jq(ID_ORGCHART).length==0) {
		setTimeout(()=>this.updateUI(),1000);
		return;
	    }
	    let roots=null;
	    try {
		roots = this.makeTree();
	    } catch(error) {
		this.handleError("An error has occurred:" + error, error);
		return;
	    }
	    if(roots==null) return;

	    let data = new google.visualization.DataTable();
            data.addColumn('string', 'Name');
            data.addColumn('string', 'Parent');
            data.addColumn('string', 'ToolTip');
	    let rows = [];
	    let cnt=0;
	    let func = function(node) {
		cnt++;
		let value = node.label;
		if(node.display) {
		    value = {'v':node.label,f:node.display};
		}
		let row = [value, node.parent?node.parent.label:"",node.tooltip||""];
		rows.push(row);
		if(node.children.length>0) {
		    node.children.map(func);
		}
		if(node.record) {
		    //		    _this.countToRecord[cnt] = node.record;
		}
	    }
	    roots.map(func);
            data.addRows(rows);
            let chart = new google.visualization.OrgChart(document.getElementById(this.domId(ID_ORGCHART)));
            // Draw the chart, setting the allowHtml option to true for the tooltips.
            this.drawChart(chart, data, {'allowHtml':true,'allowCollapse':true,
					 'size':this.getProperty("treeNodeSize","medium")});
	}
    });
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


const DISPLAY_SLIDES = "slides";
const DISPLAY_IMAGES = "images";
const DISPLAY_IMAGEZOOM = "imagezoom";
const DISPLAY_CARDS = "cards";


addGlobalDisplayType({
    type: DISPLAY_IMAGES,
    label: "Images",
    requiresData: true,
    forUser: true,
    category:CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Image Gallery","images.png"),                    
});

addGlobalDisplayType({
    type: DISPLAY_IMAGEZOOM,
    label: "Image Zoom",
    requiresData: true,
    forUser: true,
    category:CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Image Zoom","imagezoom.png","Show a set of images and allow for zooming in"),                        
});

addGlobalDisplayType({
    type: DISPLAY_SLIDES,
    label: "Slides",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Show records in a slide like format","slides.png")
});


addGlobalDisplayType({
    type: DISPLAY_CARDS,
    label: "Cards",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Group records hierachically showing images","cards.png"),                
});


function RamaddaCardsDisplay(displayManager, id, properties) {
    const ID_RESULTS = "results";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CARDS, properties);
    Utils.importJS(RamaddaUtil.getCdnUrl("/lib/color-thief.umd.js"),
		   () => {},
		   (jqxhr, settings, exception) => {
		       console.log("err");
		   });
  
    let myProps = [
	{label:'Cards Attributes'},
	{p:'groupByFields',ex:''},
	{p:'initGroupFields',ex:''},
	{p:'tooltipFields',ex:''},
	{p:'captionFields'},
	{p:'captionTemplate',ex:'${name}'},
	{p:'sortFields',ex:''},
	{p:'labelField',ex:''},
	{p:'imageWidth',ex:'100'},
	{p:'imageMargin',ex:'5'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        updateUI: function() {
            this.colorAnalysisEnabled = this.getProperty("doColorAnalysis");
            var pointData = this.getData();
            if (pointData == null) return;
            var allFields = pointData.getRecordFields();
	    var fields = this.getSelectedFields(allFields);
            if (fields == null || fields.length == 0) {
                fields = allFields;
	    }
            var records = this.filterData();
            if(!records) return;
	    let theFields = fields;
	    this.initGrouping  = this.getFieldsByIds(fields, this.getProperty("initGroupFields","",true));
            this.groupByFields = this.getFieldsByIds(fields, this.getProperty("groupByFields","",true));
            this.groupByMenus= +this.getProperty("groupByMenus",this.groupByFields.length);
            this.imageField = this.getFieldByType(fields, "image");
            this.urlField = this.getFieldByType(fields, "url");
            this.tooltipFields = this.getFieldsByIds(fields, this.getProperty("tooltipFields","",true));
            this.labelFields = this.getFieldsByIds(fields, this.getProperty("labelFields", null, true));
	    if(this.labelFields.length==0) {
		var tmp = this.getFieldById(fields,this.getProperty("labelField", null, true));
		if(tmp) {
		    this.labelFields.push(tmp);
		}
	    }
            this.onlyShowImages =this.getProperty("onlyShowImages", false);
            this.altLabelField = this.getFieldById(fields, this.getProperty("altLabelField", null, true));
            this.captionFields = this.getFieldsByIds(fields, this.getProperty("captionFields", "", true));
            this.captionTemplate = this.getProperty("captionTemplate",null, true);
            if(this.captionFields.length==0) this.captionFields = this.tooltipFields;
            this.colorByField = this.getFieldById(fields, this.getProperty("colorBy", null, true));
            this.colorList = this.getColorTable(true);
            this.foregroundList = this.getColorTable(true,"foreground");
            if(!this.getProperty("showImages",true)) this.imageField = null;

            if(!this.imageField)  {
                if(this.captionFields.length==0) {
                    this.displayError("No image or caption fields specified");
                    return;
                }
            }
            var contents = "";

	    if(!this.groupByHtml) {
		this.groupByHtml = "";
		if(this.colorAnalysisEnabled)
		    this.groupByHtml +=  HU.span([CLASS,"ramadda-button",ID,this.domId("docolors")], "Do colors")+" " +
		    HU.span([CLASS,"ramadda-button",ID,this.domId("docolorsreset")], "Reset");
		if(this.groupByFields.length>0) {
		    var options = [["","--"]];
		    this.groupByFields.map(field=>{
			options.push([field.getId(),field.getLabel()]);
		    });

		    this.groupByHtml +=  HU.span([CLASS,"display-fitlerby-label"], " Group by: ");
		    for(var i=0;i<this.groupByMenus;i++) {
			var selected = "";
			if(i<this.initGrouping.length) {
			    selected = this.initGrouping[i].getId();
			}
			this.groupByHtml+= HU.select("",[ID,this.domId(ID_GROUPBY_FIELDS+i)],options,selected)+"&nbsp;";
		    }
		    this.groupByHtml+="&nbsp;";
		    this.jq(ID_HEADER1).html(HU.div([CLASS,"display-filterby"],this.groupByHtml));
		    this.jq("docolors").button().click(()=>{
			this.analyzeColors();
		    });
		    this.jq("docolorsreset").button().click(()=>{
			this.updateUI();
		    });


		}
	    }



            contents += HU.div([ID,this.domId(ID_RESULTS)]);
            this.setContents(contents);
            let _this = this;
            this.jq(ID_HEADER1).find("input, input:radio,select").change(function(){
                _this.updateUI();
            });

            this.displaySearchResults(records,theFields);
        },
	analyzeColors: function() {
	    if(!window["ColorThief"]) {
		setTimeout(()=>this.analyzeColors(),1000);
		return;
	    }
	    const colorThief = new ColorThief();
	    var cnt = 0;
	    while(true) {
		var img = document.querySelector('#' + this.domId("gallery")+"img" + cnt);
		var div = $('#' + this.domId("gallery")+"div" + cnt);
		cnt++;
		if(!img) {
		    return;
		    
		}
		img.crossOrigin = 'Anonymous';
		// Make sure image is finished loading
		//		    if (img.complete) {
		var c = colorThief.getColor(img);
		var p = colorThief.getPalette(img);
		var width = img.width/p.length;
		var html = "";
		for(var i=0;i<p.length;i++) {
		    var c = p[i];
		    html+=HU.div([STYLE,HU.css('display','inline-block','width', width + "px','height', img.height +'px','background','rgb(" + c[0]+"," + c[1] +"," + c[2]+")")],"");
		}
		div.css("width",img.width);
		div.css("height",img.height);
		div.html(html);
		//			div.css("background","rgb(" + c[0]+"," + c[1] +"," + c[2]);
		img.style.display = "none";
	    }
	},
	displaySearchResults: function(records, fields) {
	    records= this.sortRecords(records);
            var fontSize = this.getProperty("fontSize",null);
            var cardStyle = this.getProperty("cardStyle",null);

            var width = this.getProperty("imageWidth","50");
            var margin = this.getProperty("imageMargin","0");
            var groupFields = [];
            var seen=[];
            for(var i=0;i<this.groupByMenus;i++) {
                var id =  this.jq(ID_GROUPBY_FIELDS+i).val();
                if(!seen[id]) {
                    seen[id] = true;
                    var field= this.getFieldById(fields, id);
                    if(field) {
                        groupFields.push(field);
                        if(field.isNumeric() && !field.range) {
                            var min = Number.MAX_VALUE;
                            var max = Number.MIN_VALUE;
                            records.map(record=>{
                                var v =field.getValue(record);
                                if(isNaN(v)) return;
                                if(v<min) min  = v;
                                if(v > max) max =v;
                            });
                            field.range = [min,max];
                            var binsProp = this.getProperty(field.getId() +".bins");
                            field.bins = [];
                            if(binsProp) {
                                var l  = binsProp.split(",");
                                for(var i=0;i<l.length-1;i++) {
                                    field.bins.push([+l[i],+l[i+1]]);
                                }
                            } else {
                                var numBins = +this.getProperty(field.getId() +".binCount",10); 
                                field.binSize = (max-min)/numBins;
                                for(var bin=0;bin<numBins;bin++) {
				    field.bins.push([min+field.binSize*bin,min+field.binSize*(bin+1)]);
				}
                            }
                        }
                    }
                }
            }

            function groupNode(id,field) {
                $.extend(this,{
                    id: id,
		    field:field,
		    members:[],
                    isGroup:true,
                    getCount: function() {
                        if(this.members.length==0) return 0;
                        if(this.members[0].isGroup) {
                            var cnt = 0;
                            this.members.map(node=>cnt+= node.getCount());
                            return cnt;
                        }
                        return this.members.length;
                    },
                    findGroup: function(v) {
                        for(var i=0;i<this.members.length;i++) {
                            if(this.members[i].isGroup && this.members[i].id == v) return this.members[i];
                        }
                        return null;
                    },
                });
            }
            var topGroup = new groupNode("");
            var colorMap ={};
            var colorCnt = 0;
	    var imgCnt = 0;
            for (var rowIdx = 0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
                var row = this.getDataValues(records[rowIdx]);
                var contents = "";
                var tooltip = "";
                this.tooltipFields.map(field=>{
                    if(tooltip!="") tooltip+="&#10;";
                    tooltip+=field.getValue(record);
                });
		tooltip =tooltip.replace(/\"/g,"&quot;");
                var label = "";
                var caption="";
                if(this.captionFields.length>0) {
                    if(this.captionTemplate) caption  = this.captionTemplate;
                    this.captionFields.map(field=>{
			var value = (""+field.getValue(record)).replace(/\"/g,"&quot;");
                        if(this.captionTemplate)
                            caption = caption.replace("\${" + field.getId()+"}",value);
                        else
                            caption+=value+"<br>";
                    });
                    if(this.urlField) {
                        var url = this.urlField.getValue(record);
                        if(url && url!="") {
                            caption = "<a style='color:inherit;'  href='" +url+"' target=_other>" +caption+"</a>";
                        }
                    }
                }
		this.labelFields.map(f=>{
		    label += row[f.getIndex()]+" ";
		});
		label = label.trim();
                var html ="";
                var img = null;
                if(this.imageField) {
                    img = row[this.imageField.getIndex()];
		    
                    if(this.onlyShowImages && !Utils.stringDefined(img)) continue;
                } 
                
                var  imgAttrs= [CLASS,"display-cards-popup","data-fancybox",this.domId("gallery"),"data-caption",caption];
		if(img) img = img.trim();
                if(Utils.stringDefined(img)) {
		    if(this.colorAnalysisEnabled)
			img = ramaddaBaseUrl+"/proxy?url=" + img;
                    img =  HU.href(img, HU.div([ID,this.domId("gallery")+"div" + imgCnt], HU.image(img,["width",width,ID,this.domId("gallery")+"img" + imgCnt])),imgAttrs)+label;
		    imgCnt++;
                    html = HU.div([CLASS,"display-cards-item", TITLE, tooltip, STYLE,HU.css('margin', margin+'px')], img);
                } else {
                    var style = "";
                    if(fontSize) {
                        style+= " font-size:" + fontSize +"; ";
                    }
                    if(this.colorByField && this.colorList) {
                        var value = this.colorByField.getValue(record);
                        if(!Utils.isDefined(colorMap[value])) {
                            colorMap[value] = colorCnt++;
                        }
                        var index = colorMap[value];
                        if(index>=this.colorList.length) {
                            index = this.colorList.length%index;
                        }
                        style+="background:" + this.colorList[index]+";";
                        if(this.foregroundList) {
                            if(index<this.foregroundList.length) {
                                style+="color:" + this.foregroundList[index]+" !important;";
                            } else {
                                style+="color:" + this.foregroundList[this.foregroundList-1]+" !important;";
                            }
                        }
                    }
                    if(cardStyle)
                        style +=cardStyle;
                    var attrs = [TITLE,tooltip,CLASS,"ramadda-gridbox display-cards-card",STYLE,style];
                    if(this.altLabelField) {
                        html = HU.div(attrs,this.altLabelField.getValue(record));
                    } else {
                        html = HU.div(attrs,caption);
                    }
                    html =  HU.href("", html,imgAttrs);
                }
                var group = topGroup;
                for(var groupIdx=0;groupIdx<groupFields.length;groupIdx++) {
                    var groupField  = groupFields[groupIdx];
                    var value = row[groupField.getIndex()];
                    if(groupField.isNumeric()) {
                        for(var binIdx=0;binIdx<groupField.bins.length;binIdx++) {
                            var bin= groupField.bins[binIdx];
                            if(value<=bin[1] || binIdx == groupField.bins.length-1) {
                                value = Utils.formatNumber(bin[0]) +" - " + Utils.formatNumber(bin[1]);
                                break;
                            }
                        }
                    }
                    var child = group.findGroup(value);
                    if(!child) {
                        group.members.push(child = new groupNode(value,groupField));
                    }
                    group = child;
                }
                group.members.push(html);
            }
	    let total = topGroup.getCount();
            let topHtml = HU.div([CLASS,"display-cards-header"],"Total" +" (" + total+")");
            topHtml+=this.makeGroupHtml(topGroup, topGroup);
            this.writeHtml(ID_RESULTS, topHtml);
	    HU.createFancyBox( this.jq(ID_RESULTS).find("a.display-cards-popup"), {
                caption : function( instance, item ) {
                    return  $(this).data('caption') || '';
                }});
        },
        makeGroupHtml: function(group, topGroup) {
            if(group.members.length==0) return "";
            var html="";
            if(group.members[0].isGroup) {
                group.members.sort((a,b)=>{
                    if(a.id<b.id) return -1;
                    if(a.id>b.id) return 1;
                    return 0;
                });
                var width = group.members.length==0?"100%":100/group.members.length;
                html +=HU.open(TABLE,[WIDTH,'100%','border',0]) +HU.open(TR,['valign','top']);
                for(var i=0;i<group.members.length;i++) {
                    var child = group.members[i];
		    var prefix="";
		    if(child.field)
			prefix = child.field.getLabel()+": ";
                    html+=HU.open(TD,[WIDTH, width+"%"]);
		    let perc = Math.round(100*child.getCount()/topGroup.getCount());
		    html+=HU.div([CLASS,"display-cards-header"],prefix+child.id +" (#" + child.getCount()+" - " + perc +"%)");
		    html+= this.makeGroupHtml(child, topGroup);
                    html+=HU.close(TD);
                }
                html +=HU.close(TR, TABLE);
            } else {
                html+=Utils.join(group.members,"");
            }
            return html;
        }
    });
}




function RamaddaImagesDisplay(displayManager, id, properties) {
    const ID_GALLERY = "gallery";
    const ID_IMAGES = "images";
    //never want to do this
    properties.tooltipClick=null;
    if(!Utils.isDefined(properties["showRecordPager"])) {
	properties["showRecordPager"] = true;
    }
    if(!Utils.isDefined(properties["noun"])) {
	properties["noun"] = "images";
    }    
    if(Utils.isDefined(properties["numberOfImages"])) {
	properties["recordPagerNumber"] = properties["numberOfImages"];
    }


    let myProps = [
	{label:'Image Gallery Properties'},
	{p:'imageField',ex:''},
	{p:'urlPrefix'},
	{p:'template',ex:''},
	{p:'labelFields',ex:''},
	{p:'topLabelTemplate',ex:''},	
	{p:'bottomLabelTemplate',ex:''},	
	{p:'tooltipFields',ex:''},
	{p:'includeBlanks',ex:'true'},
	{p:'blockWidth',ex:'150'},
	{p:'imageWidth',ex:'150'},
	{p:'imageHeight',ex:'150'},	
	{p:'imageMargin',ex:'10px'},
	{p:'decorate',ex:'false'},
	{p:'doPopup',ex:'false'},
	{p:'imageStyle',ex:''},			
	{p:'minHeightGallery',ex:150},
	{p:'maxHeightGallery',ex:150},	
	{p:'columns',ex:'5'},
	{p:'includeNonImages',d:true},
	{p:'showPlaceholderImage',d:true},
    ];

    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_IMAGES, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	dataFilterChanged: function() {
	    this.updateUI();
	},
        handleEventRecordSelection: function(source, args) {
	    let blocks = this.find(".display-images-block");
	    let select = HU.attrSelect(RECORD_ID, args.record.getId());
	    let block = this.find(select);
	    blocks.css('border',null);
	    block.css('border',"1px solid " +this.getHighlightColor());
	    HU.scrollVisible(this.jq(ID_IMAGES),block);
	},
        updateUI: function() {
	    let includeBlanks  = this.getPropertyIncludeBlanks(false);
	    let imageField = null;
	    let showBottomLabel = this.getProperty("showBottomLabel",true);
            let records = this.filterData(null,null,{recordOk:record=>{
		if(imageField == null) imageField = this.getFieldById(null, this.getProperty("imageField"));
		if(!imageField) {
		    imageField = this.getFieldByType(null,"image");
		}
		if(!imageField) {
		    return false;
		}

		return true;
		/*** TODO?
		let image = record.getValue(imageField.getIndex());
		if(!Utils.stringDefined(image) && !includeBlanks) {
		    return false;
		}
		return true;
		*/
	    }});
            if(!records) return;

	    if(!imageField) {
		this.setDisplayMessage("No image field in data");
		return false;
	    }

	    let urlPrefix = this.getUrlPrefix();
	    let urlField = this.getFieldById(null, this.getProperty("urlField"));
	    let tooltipClick = this.getProperty("tooltipClick");
            let pointData = this.getData();
            let fields = pointData.getRecordFields();

            let labelFields = this.getFieldsByIds(null, this.getProperty("labelFields", null, true));
            let template = this.getTemplate();
            let topLabelTemplate = this.getTopLabelTemplate();
            let bottomLabelTemplate = this.getPropertyBottomLabelTemplate();	    
            let tooltipFields = this.getFieldsByIds(null, this.getProperty("tooltipFields", null, true));



	    let decorate = this.getPropertyDecorate(true);
	    let columns = +this.getPropertyColumns(0);
	    let colorBy = this.getColorByInfo(records);
	    let width = this.getPropertyImageWidth();
	    let blockWidth = this.getBlockWidth("200px");	    
	    let height = this.getPropertyImageHeight();	    
	    if(!width && !height) width="100%";
	    let imageStyle = this.getPropertyImageStyle("");
	    let contents = "";
	    let uid = HtmlUtils.getUniqueId();
	    let base = "gallery"+uid;
	    let displayedRecords = [];
	    let doPopup = this.getPropertyDoPopup(true);
	    let recordIndex = 0;
	    let columnCnt = -1;
	    let columnMap = {};
	    let class1= "display-images-image-outer display-images-block ";
	    let class2 = "display-images-image-inner";
	    let class3 = "display-images-image-wrapper";
	    this.idToRecord = {};
	    let baseStyle = "";
	    if(records.length<10) {
		if(records.length<2) {
		    width='500px';
		    blockWidth='510px';
		} else {
		    width='300px';
		    blockWidth='310px';
		}
	    }


	    if(!decorate) {
		class2 = "";
		class1 = "display-images-block";
		baseStyle = HU.css("margin",this.getPropertyImageMargin("10px"));
	    }
	    if(columns) {
		if(width && width.endsWith("%"))
		    baseStyle+=HU.css(WIDTH,width);
	    }
	    baseStyle+=this.getProperty("blockStyle","");
	    let cnt = 1;

	    let includeNonImages = this.getIncludeNonImages();
	    let blankImage =this.getShowPlaceholderImage(true)?HU.image(ramaddaBaseUrl+'/images/placeholder.png',[ATTR_WIDTH,'100%']):
		HU.space(1);
	    
	    records.forEach((record,rowIdx)=>{

                let row = this.getDataValues(record);
		let image = record.getValue(imageField.getIndex());
		if(urlPrefix) image = urlPrefix+image;
		displayedRecords.push(record);
		this.idToRecord[record.getId()] = record;
		let topLabel = null;
		if(topLabelTemplate) {
		    topLabel = this.getRecordHtml(record,fields,topLabelTemplate);
		}
		let label = "";
		let galleryLabel = "";
		if(Utils.stringDefined(bottomLabelTemplate)) {
		    label = this.getRecordHtml(record,fields,bottomLabelTemplate);
		} 
		labelFields.forEach(l=>{
		    let value  = record.getValue(l.getIndex());
		    if(value.getTime) {
			value = this.formatDate(value);
		    } 
		    galleryLabel += " " + value; 
		});
		if(galleryLabel=="") galleryLabel=label;
		else if(label=="") label = galleryLabel;		
		let tt = "";
		tooltipFields.forEach(l=>{tt += "\n" + l.getLabel()+": " + row[l.getIndex()]});
		tt = tt.trim();
		let style = baseStyle;
		let imgAttrs = [ATTR_STYLE,imageStyle,"alt",galleryLabel,ATTR_ID,base+"image" + rowIdx,"loading","lazy"];
		if(width) imgAttrs.push(WIDTH,width);
		else if(height) imgAttrs.push(HEIGHT,height);		
		if(!Utils.stringDefined(image) &&!includeNonImages) return;

		let img = (!Utils.stringDefined(image))?blankImage:HU.div([ATTR_CLASS,class3],HU.image(image,imgAttrs));
		let topLbl = (topLabel!=null?HU.div([CLASS,"ramadda-clickable display-images-toplabel"], topLabel):"");
		let lbl = HU.div([CLASS,"ramadda-clickable display-images-label"], label.trim());
		if(urlField) {
		    if(topLbl!="")
			topLbl = HU.href(urlField.getValue(record), topLbl,["target","_target"]);
		    lbl = HU.href(urlField.getValue(record), lbl,["target","_target"]);
		    galleryLabel = HU.href(urlField.getValue(record), galleryLabel,["target","_target"]);
		    galleryLabel = galleryLabel.replace(/"/g,"'");
		}
		if(!showBottomLabel)
		    lbl="";
		if(colorBy.isEnabled()) {
		    let c = colorBy.getColorFromRecord(record);
		    style+=HU.css(BACKGROUND,c);
		}

		let recordContents;
		let block;
		if(template) {
		    let row = this.getDataValues(record);
		    block = recordContents= this.applyRecordTemplate(record, row,fields,template);
		    style+=HU.css("text-align","left");
		} else {
		    style+=HU.css("vertical-align","top","width",blockWidth);
		    if(doPopup) {
			img = HU.href(image,img,[CLASS,"popup_image","data-fancybox",base,"data-caption",galleryLabel]);
		    } else if(urlField&& !tooltipClick) {
			img = HU.href(urlField.getValue(record),img,["target","_target"]);
		    }
		    recordContents = HU.div([CLASS,class2], topLbl + img + lbl);
		}


		block = 
		    HU.div([STYLE, style, RECORD_ID,record.getId(),RECORD_INDEX,recordIndex++,ID,base+"div"+  rowIdx, CLASS, class1,TITLE,tt],
			   recordContents);
		if(columns) {
		    if(++columnCnt>=columns) {
			columnCnt=0;
		    }
		    if(!columnMap[columnCnt]) columnMap[columnCnt] = "";
		    columnMap[columnCnt] += block;
		} else {
		    contents += block;
		}
	    });
	    if(columns) {
		contents = "<table border=0 width=100%><tr valign=top>";
		for(let col=0;true;col++) {
		    if(!columnMap[col]) break;
		    contents+=HU.td(['align','center'],columnMap[col]);
		}
		contents+="</tr></table>";
	    } else {
	    }

	    if(this.getPropertyMinHeightGallery() || this.getPropertyMaxHeightGallery()) {
		let css = "";
		if(this.getPropertyMinHeightGallery()) css+=HU.css("min-height",HU.getDimension(this.getPropertyMinHeightGallery()));
		if(this.getPropertyMinHeightGallery())	css+= HU.css("max-height",HU.getDimension(this.getPropertyMaxHeightGallery()));
		contents = HU.div([ID,this.domId(ID_IMAGES),STYLE,css+HU.css("overflow-y","auto")], contents);
	    }

	    contents  = HU.div([CLASS,"ramadda-grid"],contents);
            this.setContents(contents);
	    let blocks = this.find(".display-images-block");
	    let _this = this;
	    blocks.mouseenter(function() {
		$(this).attr("oldborder",$(this).css("border"));
		$(this).css("border","1px solid " + _this.getHighlightColor());
	    });
	    blocks.mouseleave(function() {
		$(this).css("border",$(this).attr("oldborder"));
	    });			      


	    this.makeTooltips(blocks,displayedRecords);
	    if(!doPopup) {
		let _this = this;
		if(!tooltipClick) {
		    blocks.click(function() {
			let record = _this.idToRecord[$(this).attr(RECORD_ID)];
			if(record) {
			    _this.propagateEventRecordSelection({record: record});
			}
		    });
		}
	    } else {
		HU.createFancyBox( this.jq(ID_RESULTS).find("a.popup_image"), {
                    caption : function( instance, item ) {
			return  $(this).data('data-caption') || '';
                    }});
		
	    }

	    if(this.getProperty("propagateEventRecordList",false)) {
		this.getDisplayManager().notifyEvent(DisplayEvent.recordList, this, {
		    recordList: displayedRecords,
		});
	    }
	}
    })
}



function RamaddaImagezoomDisplay(displayManager, id, properties) {
    const ID_THUMBS = "thumbs";
    const ID_THUMB = "thumb";    
    const ID_IMAGE = "image";
    const ID_IMAGEINNER = "imageinner";    
    const ID_POPUP = "imagepopup";
    const ID_POPUPIMAGE = "imagepopupimage";
    const ID_RECT = "imagerect";            
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_IMAGEZOOM, properties);
    let myProps = [
	{label:"Image Zoom Attributes"},
	{p:'labelFields',d:'name'},
	{p:'thumbField'},
	{p:'thumbWidth',ex:'100'},
	{p:'imageWidth',ex:'150'},
	{p:'urlField'},
	{p:'popupWidth'},
	{p:'popupHeight'},	
	{p:"popupImageWidth",d:2000}
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	dataFilterChanged: function() {
	    this.updateUI();
	},
        updateUI: function() {
            let pointData = this.getData();
            if (pointData == null) return;
            let records = this.filterData();
            if(!records) return;
            let fields = pointData.getRecordFields();
            this.urlField = this.getFieldById(fields, this.getUrlField("url"));
	    if(!this.urlField) this.urlField = this.getFieldById(fields, 'entry_url');
	    this.imageField = this.getFieldById(fields,"image");
	    if(!this.imageField)
		this.imageField = this.getFieldByType(fields,"image");
	    if(!this.imageField) {
		this.setDisplayMessage("No image field in data");
		return;
	    }
	    this.labelFields = this.getFieldsByIds(fields, this.getPropertyLabelFields());
            let thumbField = this.getFieldById(fields, this.getProperty("thumbField", "thumb")) || this.imageField;
	    let thumbWidth = parseFloat(this.getProperty("thumbWidth",100));
	    let height=this.getHeightForStyle();
	    let imageWidth = this.getProperty("imageWidth",500);
	    this.popupWidth =  +this.getProperty("popupWidth",imageWidth);
	    this.popupHeight = +this.getProperty("popupHeight",300);

	    let rect = HU.div([STYLE,HU.css("border","1px solid " +this.getHighlightColor(),"width","20px","height","20px","left","10px","top","10px","display","none","position","absolute","z-index",1000,"pointer-events","none"),ID, this.domId(ID_RECT)]);
	    let imageDiv = HU.div([ATTR_STYLE,"position:relative"],
				  rect+
				  HU.div([ID,this.domId(ID_IMAGE),STYLE,HU.css("position","relative") ]) +
				  HU.div([ID,this.domId(ID_POPUP),CLASS,"display-imagezoom-popup",STYLE,HU.css("z-index","100","display","none",WIDTH,this.popupWidth+"px",HEIGHT,this.popupHeight+"px","overflow-y","hidden","overflow-x","hidden", "position","absolute","top","0px","left", imageWidth+"px")],""));

	    let contents = HU.table(["border",0,WIDTH,"100%"],
				    HU.tr(["valign","top"],
					  HU.td([WIDTH,"2%"],
						HU.div([ID,this.domId(ID_THUMBS), STYLE,HU.css("max-height",height,"overflow-y","auto","display","inline-block")],"")) +
					  HU.td([WIDTH,"90%"],
						imageDiv)));
	    let thumbsHtml = "";
	    let first = null;
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
		let image = row[this.imageField.getIndex()];
		if(image=="") {
		    continue;
		}
		if(!first) first=records[rowIdx];
		let thumb = row[thumbField.getIndex()];		
		thumbsHtml += HU.image(thumb,[RECORD_INDEX,rowIdx,ID,this.domId(ID_THUMB)+rowIdx,WIDTH, thumbWidth,CLASS,"display-imagezoom-thumb"])+"<br>\n";
	    }
            this.setContents(contents);
	    this.jq(ID_THUMBS).html(thumbsHtml);
	    let _this = this;
	    let thumbs = this.jq(ID_THUMBS).find(".display-imagezoom-thumb");
	    let thumbSelect = (thumb=>{
		thumbs.css("border","1px solid transparent");
		thumb.css("border","1px solid " + this.getHighlightColor());
		let index = parseFloat(thumb.attr(RECORD_INDEX));
		HU.addToDocumentUrl("imagezoom_thumb",index);
		let record = records[index]
		_this.handleImage(record);
		_this.propagateEventRecordSelection({record: record});
	    });

	    thumbs.mouseover(function() {	
		thumbSelect($(this));
	    });
	    this.jq(ID_THUMBS).css("border","1px solid transparent");
	    let selectedIndex =  HU.getUrlArgument("imagezoom_thumb");
	    let x = HU.getUrlArgument("imagezoom_x");
	    let y = HU.getUrlArgument("imagezoom_y");	    
	    let selectedThumb = this.jq(ID_THUMB+(selectedIndex||"0"));
	    if(selectedThumb.length)
		thumbSelect(selectedThumb);
	    if(selectedIndex) this.showPopup();
	    if(Utils.isDefined(x)) {
		setTimeout(()=>{
		    this.handleMouseMove({x:parseFloat(x),y:parseFloat(y)});
		},250);
	    }

	    this.jq(ID_IMAGE).click((e)=>{
		let width = +this.getPopupImageWidth();
                if (event.shiftKey) {
		    this.setProperty("popupImageWidth",Math.max(width*0.9,500));
		} else {
		    this.setProperty("popupImageWidth",width*1.2);
		}
		this.showPopup();
		this.handleMouseMove();
	    });
	},
	showPopup: function() {
	    if(!this.currentRecord) return;
	    let row = this.getDataValues(this.currentRecord);
	    let image = row[this.imageField.getIndex()];
	    this.jq(ID_POPUP).css("display","block");
	    let imageAttrs = [ID,this.domId(ID_POPUPIMAGE),STYLE,HU.css("xposition","absolute")];
	    if(this.getPopupImageWidth()) {
		imageAttrs.push(WIDTH);
		imageAttrs.push(this.getPopupImageWidth());
	    } 
	    this.jq(ID_POPUP).html(HU.image(image,imageAttrs));
	},
	handleImage: function(record, offset) {
	    let _this = this;
	    this.currentRecord = record;
            let row = this.getDataValues(record);
	    let image = row[this.imageField.getIndex()];
	    let width = this.getProperty("imageWidth",500);
    	    let label = "";
	    if(this.labelFields.length>0) {
		this.labelFields.map(l=>{label += " " + row[l.getIndex()]});
		if(this.urlField) {
                    var url = this.urlField.getValue(record);
                    if(url && url!="") {
                        label = "<a style='color:inherit;'  href='" +url+"' target=_other>" +label+ "</a>";

                    }
		}
	    }
	    let html =  HU.image(image,["x","+:zoom in/-:zoom out",STYLE,HU.css("z-index",1000),WIDTH, width,ID,this.domId(ID_IMAGEINNER)]);
	    if(label!="")
		html+=HU.div([STYLE,"color:#000"],label);
	    this.jq(ID_IMAGE).html(html);

	    this.jq(ID_POPUP).html("");
	    this.jq(ID_POPUP).css("display","none");
	    this.jq(ID_IMAGEINNER).mouseenter(()=>{
		this.showPopup();
	    });
	    this.jq(ID_IMAGEINNER).mouseout(()=>{
		this.jq(ID_POPUP).html("");
		this.jq(ID_POPUP).css("display","none");
		this.jq(ID_RECT).css("display","none");		
	    });

	    this.jq(ID_IMAGEINNER).mousemove((e)=>{
		this.handleMouseMove({
		    event:e});
	    });
	    if(offset)
		this.jq(ID_POPUPIMAGE).offset(offset);
	},
	handleMouseMove(params) {
	    if(!params) params = {event:this.currentMouseEvent};
	    this.currentMouseEvent=params.event;
	    let image = this.jq(ID_IMAGEINNER);
	    let w = image.width();
	    let h = image.height();
	    let popupImage = this.jq(ID_POPUPIMAGE);
	    let iw = popupImage.width();
	    let ih = popupImage.height();		
	    if(h==0 || ih==0) return false;
	    let popupWidth = popupImage.parent().width();
	    let popupHeight = popupImage.parent().height(); 	    	    
	    let scaleX = w/iw;
	    let scaleY = h/ih;
	    let scaledWidth = scaleX*popupWidth;
	    let scaledHeight = scaleY*popupHeight;
	    let sw2 = scaledWidth/2;
	    let sh2 = scaledHeight/2;	    
	    let parentOffset = image.parent().offset();
	    if(!Utils.isDefined(params.x)) 
		params.x = params.event.pageX - parentOffset.left;
	    if(!Utils.isDefined(params.y)) 
		params.y = params.event.pageY - parentOffset.top;
	    if(params.x<sw2) params.x=sw2;
	    if(params.y<sh2) params.y=sh2;
	    if(params.x>w-sw2) params.x=w-sw2;
	    if(params.y>h-sh2) params.y=h-sh2;	    	    
	    

	    //This causes problems
//	    HU.addToDocumentUrl("imagezoom_x",params.x);
//	    HU.addToDocumentUrl("imagezoom_y",params.y);	    

	    let offX = scaleX*iw/2;
	    let offY = scaleY*ih/2;		
	    let percentW = (params.x-sw2)/w;
	    let percentH = (params.y-sh2)/h;

	    if(popupImage.parent().length==0) return;
	    let pp = popupImage.parent().offset();
	    let offset = {
		left:pp.left-percentW*iw,
		top:pp.top-percentH*ih};
	    this.jq(ID_POPUPIMAGE).offset(offset);		    
	    let rect = this.jq(ID_RECT);
	    rect.css({"display":"block",top:params.y-sh2+"px",left:params.x-sw2+"px",width:scaledWidth+"px",height:scaledHeight+"px"});
	    return true;
	},

    })
}






function RamaddaSlidesDisplay(displayManager, id, properties) {
    const ID_SLIDE = "slide";
    const ID_STRIP = "strip";
    //If we are showing the strip then make sure there is a width set
    if(properties.imageField && properties.showStrip && !Utils.isDefined(properties.width)) {
	//properties.width="100%";
    }
    
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_SLIDES, properties);
    let myProps = [
	{label:'Slides Attributes'},
	{p:'template',ex:''},
	{p:'mediaField',ex:'',tt:'Field that contains a URL to an image, youtube, etc'},
	{p:'showStrip',ex:'true',tt:'Show the navigation strip'},
	{p:'slideWidth',ex:'100px'},
	{p:'thumbnailField',ex:''},
	{p:'thumbnailWidth',ex:'100px'},	
	{p:'urlField',ex:''},
	{p:'labelField',ex:''},
	{p:'labelTemplate',ex:'${name} ...'},
	{p:'topLabelTemplate',ex:'${name} ...'},		
	{p:'tooltipFields',ex:''},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	slideIndex:0,
	handleEventRecordSelection: function(source, args) {
	    if(!this.records) return;
	    let index = this.findRecordIndex(this.records,args.record);
	    if(index>=0) {
		this.slideIndex=index;
		this.displaySlide();
	    }
	},
        getContentsStyle: function() {
            var style = "";
            var height = this.getHeightForStyle();
            if (height) {
		style += " height:" + height + ";";
            }
            var width = this.getWidthForStyle();
            if (width) {
                style += " width:" + width + ";";
            }
            return style;
        },

	updateUI: function() {
	    var pointData = this.getData();
	    if (pointData == null) return;
	    this.records = this.filterData();
	    if(!this.records) return;
            this.fields = this.getData().getRecordFields();
	    this.records= this.sortRecords(this.records);
	    this.theTemplate = this.getProperty('template','');
//	    this.fields.forEach(f=>{console.log(f.getId());});
	    this.urlField = this.getFieldById(null, this.getProperty("urlField"));
	    this.labelField = this.getFieldById(null, this.getLabelField());
	    this.topLabelTemplate =  this.getTopLabelTemplate();
	    this.labelTemplate =  this.getLabelTemplate();
	    this.tooltipFields = this.getFieldsByIds(null, this.getProperty("tooltipFields"));	    	    
	    this.mediaField = this.getFieldById(null, this.getProperty("mediaField",this.getProperty("imageField")));
	    this.thumbnailField = this.getFieldById(null, this.getProperty("thumbnailField")) || this.mediaField;
            let height = this.getHeightForStyle('400');
	    let left = HU.div([ID, this.domId(ID_PREV), STYLE,HU.css('padding-right','10px','font-size','200%'),CLASS,'ramadda-clickable display-slides-arrow-left fas fa-angle-left']);
	    let right = HU.div([ID, this.domId(ID_NEXT), STYLE,HU.css('padding-left','10px','font-size','200%'), CLASS,'ramadda-clickable  display-slides-arrow-right fas fa-angle-right']);
	    let slide = HU.div([ATTR_CLASS,'display-slides-slide',
				ATTR_STYLE,HU.css('overflow-y','auto','max-height', height), ID, this.domId(ID_SLIDE), CLASS,'display-slides-slide']);

	    let top = "";
	    this.showStrip = this.thumbnailField && this.getProperty("showStrip");
	    if(this.showStrip) {
		let stripStyle = HU.css('overflow-x','auto','max-width','100%') +this.getProperty('stripStyle','');
		top = HU.div([ID,this.domId(ID_STRIP),CLASS,'display-slides-strip','tabindex','0',ATTR_STYLE,stripStyle]);
	    }
	    let contents = top+HU.div([ATTR_STYLE,HU.css('position','relative')],
				      slide + left + right);

	    this.setContents(contents);

	    if(this.showStrip) {
		let width = HU.getDimension(this.getThumbnailWidth("100px"));
		let strip="";
		this.records.forEach((record,idx)=>{
		    let url = this.thumbnailField.getValue(record);
		    //The null in the thumbnail file gets turned into a NaN
		    if((""+url)=="NaN") url = null;
		    if(!Utils.stringDefined(url)) {
			if(this.mediaField) 
			    url = this.mediaField.getValue(record);
		    }
		    if(!Utils.stringDefined(url)) {return;}
		    let clazz = 'display-slides-strip-image';
		    if(idx==0) clazz+=' display-slides-strip-image-selected';
		    let tt = HU.makeMultiline(this.tooltipFields.map(f=>{
			return  f.getValue(record);
		    }));


		    if(Utils.isImage(url)) {
			strip += HU.div([],HU.image(url,['loading','lazy',ATTR_TITLE,tt,'width',width,ATTR_CLASS,clazz,RECORD_INDEX,idx]));
		    } else {
			let label = "";
			if(this.labelField) {
			    label = this.labelField.getValue(record);
			} else {
			    label = "Record:" + idx;
			    let tail = Utils.getFileTail(url);
			    if(tail) label+="<br>" + tail;
			}
			if(tt=="") tt = label;
			if(url.match(/youtube.com\/watch/)) {
			    label = HU.image(ramaddaBaseUrl +"/media/youtube.png") +" " + label;
			}
			tt = tt.replace(/<br>/g,HtmlUtils.BR_ENTITY);
			strip += HU.div([ATTR_TITLE,tt,ATTR_STYLE,HU.css('display','inline-block','min-width',width,'width',width,'overflow-x','hidden'),ATTR_CLASS,clazz,RECORD_INDEX,idx],label);
		    }
		});
		let stripDom = this.jq(ID_STRIP);
		stripDom.html(strip);
		let _this = this;
		this.stripImages = stripDom.find('.display-slides-strip-image');
		stripDom.mouseenter(function(event) {
		    stripDom.focus();
		});
		stripDom.keydown(function(event) {
		    if(event.which==39) {
			_this.slideIndex++;
			_this.displaySlide(true);
		    } else if(event.which==37) {
			_this.slideIndex--;
			_this.displaySlide(true);
		    }
		});
		this.stripImages.click(function() {
		    _this.stripImages.removeClass('display-slides-strip-image-selected');
		    $(this).addClass('display-slides-strip-image-selected');
		    _this.slideIndex = $(this).attr(RECORD_INDEX);
		    _this.displaySlide(true,true);
		});
	    }


	    this.jq(ID_PREV).click(() =>{
		this.slideIndex--;
		this.displaySlide(true);
	    });
	    this.jq(ID_NEXT).click(() =>{
		this.slideIndex++;
		this.displaySlide(true);
	    });
	    setTimeout(()=>{
		this.displaySlide();},200);

	},
	displaySlide: function(propagateEvent,fromStrip) {
	    let _this = this;
	    let slideWidth = this.getSlideWidth('100%');
	    if(this.slideIndex<0) this.slideIndex=0;
	    if(this.slideIndex>=this.records.length) this.slideIndex=this.records.length-1;
	    if(this.slideIndex==0)
		this.jq(ID_PREV).hide();
	    else
		this.jq(ID_PREV).show();
	    if(this.slideIndex==this.records.length-1)
		this.jq(ID_NEXT).hide();
	    else
		this.jq(ID_NEXT).show();
	    if(!fromStrip && this.showStrip) {
		this.stripImages.removeClass('display-slides-strip-image-selected');
		this.stripImages.find(HtmlUtils.attrSelect(RECORD_INDEX,this.slideIndex)).addClass('display-slides-strip-image-selected');
		this.stripImages.each(function() {
		    if(+$(this).attr(RECORD_INDEX) == _this.slideIndex) {
			$(this).addClass('display-slides-strip-image-selected');
			$(this).scrollintoview({
			    direction:'x'
			});
		    }
		});
	    }

	    let record = this.records[this.slideIndex];
	    let row = this.getDataValues(record);
	    let html = "";
	    let mainLink="";
	    let mainUrl;
	    if(this.urlField) {
		mainUrl = this.urlField.getValue(record);
	    }

	    if(Utils.stringDefined(this.theTemplate)) {
		html = this.applyRecordTemplate(record, row,this.fields,this.theTemplate);
	    } else if(this.mediaField) {
		let url = this.mediaField.getValue(record);
		if(Utils.isImage(url)) {
		    html = HU.image(url,[STYLE,HU.css('width',slideWidth)]);
		} else if(url.match('.mp3')) {
		    html =HU.center( Utils.embedAudio(url));
		} else if(url.match('soundcloud')) {
		    html = HU.center("<iframe scrolling='no' src='https://w.soundcloud.com/player/?visual=true&url=" +
				     url +"&maxwidth=450' width='450' height='390' frameborder='no'></iframe>");
		} else {
		    if(url.match(/youtube.com\/watch/)||url.match(/youtu.be/)) {
			
			html = HU.center(Utils.embedYoutube(url));
		    } else {
			html = HU.center(HU.tag("iframe",['src',url,'width','640','height','351','frameborder','0',
							  'webkitallowfullscreen',true,'mozallowfullscreen','true','allowfullscreen','true']));
		    }
		}
		if(html&&mainUrl && !this.topLabelTemplate)
		    html = html+"<br>"+HU.href(mainUrl, "Link",['target','_link']);
		if(this.tooltipFields) {
		    let tt = HU.makeMultiline(this.tooltipFields.map(f=>{
			return  f.getValue(record);
		    }));
		    html = HU.div([TITLE,tt], html);
		}
		if(this.labelField) {
		    html = html+HU.div([ATTR_CLASS,'display-slides-label'], this.labelField.getValue(record));
		}
		if(this.topLabelTemplate) {
		    let label = this.applyRecordTemplate(record,this.getDataValues(record),null, this.topLabelTemplate);
		    if(mainUrl) label = HU.href(mainUrl,label);
		    html=HU.div([ATTR_CLASS,'display-slides-label'], label)+html;
		}
		if(this.labelTemplate) {
		    let label = this.applyRecordTemplate(record,this.getDataValues(record),null, this.labelTemplate);
		    html=html+HU.div([ATTR_CLASS,'display-slides-label'], label);
		}
			

		
	    }
	    html = html.replace(/\${recordIndex}/g,(this.slideIndex+1));
	    this.jq(ID_SLIDE).html(html);
	    let args = {highlight:true,record: record};
	    if(propagateEvent)
		this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, this, args);
	},
        handleEventRecordHighlight: function(source, args) {
	}
    })}



/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/



const DISPLAY_ANIMATION = "animation";
const DISPLAY_LABEL = "label";
const DISPLAY_DOWNLOAD = "download";
const DISPLAY_LEGEND = "legend";
const DISPLAY_RELOADER = "reloader";
const DISPLAY_MESSAGE = "message";
const DISPLAY_FIELDSLIST = "fieldslist";
const DISPLAY_TICKS = "ticks";
const DISPLAY_MENU = "menu";

addGlobalDisplayType({
    type: DISPLAY_DOWNLOAD,
    label: "Download",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Show a download link",null,"Allows user to select fields and<br>download CSV and JSON")                                        
});



addGlobalDisplayType({
    type: DISPLAY_RELOADER,
    label: "Reloader",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Reload the displays",null,"Automatically reloads the displays on a set frequency")                                            
});
addGlobalDisplayType({
    type: DISPLAY_ANIMATION,
    label: "Animation",
    requiresData: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Steps through time to drive other displays","animation.png","")                                                        
});
addGlobalDisplayType({
    type: DISPLAY_MESSAGE,
    label: "Message",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a formatted message",null,"")                                                    
});
addGlobalDisplayType({
    type: DISPLAY_MENU,
    label: "Menu",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows records in a menu to be selected")
});

addGlobalDisplayType({
    type: DISPLAY_FIELDSLIST,
    label: "Fields List",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
//    tooltip: makeDisplayTooltip("No data, just a formatted message",null,"")                                                    
});

addGlobalDisplayType({
    type: DISPLAY_LABEL,
    label: "Label",
    requiresData: false,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a text label",null,"Useful to add text to the display layout")                                                
});
addGlobalDisplayType({
    type: DISPLAY_LEGEND,
    label: "Legend",
    requiresData: false,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a configurable legend","legend.png")
});
addGlobalDisplayType({
    type: DISPLAY_TICKS,
    label: "Ticks",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows records as ticks in a timeline","ticks.png")
});



function RamaddaAnimationDisplay(displayManager, id, properties) {
    var ID_START = "start";
    var ID_STOP = "stop";
    var ID_TIME = "time";
    var ID_STEP="step";
    let SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_ANIMATION, properties);
    let myProps =[
	{label:"Animation Control"},
	{p:"sleepTime",ex:'100',tt:'sleep in milliseconds'},
	{p:'startIndex',d:0}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        running: false,
        timestamp: 0,
        iconStart: "fa-play",
        iconStop: "fa-stop",
        iconBack: "fa-step-backward",
        iconForward: "fa-step-forward",
        iconSlower: "fa-minus",
	iconFaster: "fa-plus",
	iconBegin: "fa-fast-backward",
	iconEnd: "fa-fast-forward",
        needsData: function() {
            return true;
        },
        deltaIndex: function(i) {
            this.stop();
            this.setIndex(this.index + i);
        },
        setIndex: function(i) {
            if (i < 0) i = 0;
            this.index = i;
            this.applyStep(true, !Utils.isDefined(i));
        },
        toggle: function() {
            if (this.running) {
                this.stop();
            } else {
                this.start();
            }
        },
        tick: function() {
            if (!this.running) return;
            this.index++;
            this.applyStep();
            var theAnimation = this;
            setTimeout(function() {
                theAnimation.tick();
            }, this.sleepTime);
        },
        applyStep: function(propagate, goToEnd) {
            if (!Utils.isDefined(propagate)) propagate = true;
	    let records = this.currentRecords;
            if (records == null) {
                $("#" + this.getDomId(ID_TIME)).html("No data");
                return;
            }
            if (goToEnd) this.index = records.length - 1;
            if (this.index >= records.length) {
                this.index = 0;
            }
            var record = records[this.index];
            var label = "";
            if (record.getDate() != null) {
                var dttm = this.formatDate(record.getDate(), {
                    suffix: this.getTimeZone()
                });
                label += HU.b("Date:") + " " + dttm;
            } else {
                label += HU.b("Index:") + " " + this.index;
            }
            $("#" + this.getDomId(ID_TIME)).html(label);
            if (propagate) {
		this.propagateEventRecordSelection({record: record});
            }
        },
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let records = this.currentRecords;
	    if(!records) {
		if(args.record) records = [args.record];
	    }
	    records.every((r,idx)=>{
		if(r.getId() == args.record.getId() || r.getTime() == args.record.getTime()) {
		    this.index = idx;
		    this.applyStep(false);
		    return false;
		}
		return true;
	    });

        },
        faster: function() {
            this.sleepTime = this.sleepTime / 2;
            if (this.sleepTime == 0) this.sleepTime = 10;
        },
        slower: function() {
            this.sleepTime = this.sleepTime * 1.5;
        },
        start: function() {
            if (this.running) return;
            this.running = true;
            this.timestamp++;
            $("#" + this.getDomId(ID_START)).html(HU.getIconImage(this.iconStop));
            this.tick();
        },
        stop: function() {
            if (!this.running) return;
            this.running = false;
            this.timestamp++;
            $("#" + this.getDomId(ID_START)).html(HU.getIconImage(this.iconStart));
        },
        updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    this.currentRecords = records;
	    //            this.createUI();
            this.stop();

            var get = this.getGet();
            var html = "";
	    let c = "display-animation-button";
	    

	    let btn = (data,title,icon,id)=>{
		let attrs = [ATTR_STYLE,'margin-right:6px;',ATTR_CLASS,'ramadda-clickable',ATTR_TITLE,title,'command',data];
		if(id) attrs.push(ATTR_ID,this.domId(id));
		html +=HU.span(attrs,HU.getIconImage(icon))
	    }

	    btn("start","Go to start",this.iconBegin);
	    btn("-1","Step back; shift-click step back 10",this.iconBack);	    
	    btn("play","Start/Stop",this.iconStart,ID_START);	    
	    btn("1","Step Forward; shift-click step forward 10",this.iconForward);
	    btn("end","Go to end",this.iconEnd);	    	    
	    html+=SPACE2;
	    btn("-","Slower",this.iconSlower);
	    btn("+","Faster",this.iconFaster);	    	    	    
    
            html += HU.div([ATTR_STYLE, "display:inline-block; min-height:24px; margin-left:10px;", ATTR_ID, this.getDomId(ID_TIME)], "&nbsp;");
            this.setDisplayTitle("Animation");
            this.setContents(html);

	    let _this = this;
	    this.getContents().find("[command]").click(function(event) {
		let cmd = $(this).attr("command");
		let shift = event.shiftKey;
		switch(cmd) {
		case 'start': _this.setIndex(0);break;
		case 'end': _this.setIndex();break;		    
		case '-1': _this.deltaIndex(shift?-10:-1);break;
		case '1': _this.deltaIndex(shift?10:1);break;		    
		case 'play':_this.toggle();break;
		case '+':_this.faster();break;
		case '-':_this.slower();break;
		}
	

	    });
	    if(!Utils.isDefined(this.index)) {
		this.setIndex(Math.min(records.length-1,this.getStartIndex(0)));
	    }

        },
    });

    this.sleepTime = +this.getSleepTime(this.getProperty('animationSpeed',500));
}



function RamaddaMessageDisplay(displayManager, id, properties) {
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_MESSAGE, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return false;
        },
	updateUI: function() {
	    if(this.getProperty("decorate",true)) {
		this.setContents(this.getMessage(this.getProperty("message",this.getNoDataMessage())));
	    } else {
		this.setContents(this.getProperty("message",this.getNoDataMessage()));
	    }
	}});
}

function RamaddaFieldslistDisplay(displayManager, id, properties) {
    const ID_POPUP = 'popup';
    const ID_POPUP_BUTTON = 'popupbutton';    
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_FIELDSLIST, properties);
    let myProps =[
	{label:"Fields List"},
	{p:'displayFields',tt:'Fields to display'},
	{p:'numericOnly',ex:true},
	{p:'reverseFields',ex:true},
	{p:'decorate',ex:true},
	{p:'asList',d:true},
	{p:'sortFields',d:true,ex:true},
	{p:'includeLatLon',d:false,ex:true},				
	{p:'selectable',ex:true},
	{p:'showFieldDetails',ex:true},
	{p:'showPopup',d:false,ex:true,tt:'Popup the selector'},	
	{p:'selectOne',ex:true},
	{p:'some_field.color',ex:'red',tt:'add a color block'},
	{p: 'selectLabel',tt:'Label to use for the button'},
	{p: 'filterSelect',ex:true,tt:'Use this display to select filter fields'},
	{p: 'filterSelectLabel',tt:'Label to use for the button'}	
    ];
    
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	needsData: function() {
            return true;
        },
	fieldsToMap:{},
	getFieldsKey:function() {
	    let fields = this.getFields();
	    let key ='';
	    fields.forEach(f=>{
		key+='_'+f.getId();
	    });
	    return key;
	},
        setEntry: function(entry) {
	    //When we change the data then cache the existing fieldMap
	    if(this.selectedMap) {
		let key = this.getFieldsKey();
		this.fieldsToMap[key] = this.selectedMap;
	    }
	    this.selectedMap=null;
	    this.fields =null;
	    SUPER.setEntry.call(this, entry);
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(records == null) return;
	    let html = "";
            let selectedFields;
	    if(this.getFilterSelect()) {
		selectedFields = this.getFieldsByIds(null,this.getProperty('filterFields', ''));
	    } else  {
		selectedFields = this.getSelectedFields();
	    }
	    //Check if we've displayed a pointdata with the same set of fields
	    let key = this.getFieldsKey();
	    this.selectedMap = this.selectedMap || this.fieldsToMap[key];
	    if(this.selectedMap ==null)  {
		this.selectedMap={};
		if(selectedFields && selectedFields.length!=0) {
		    selectedFields.forEach(f=>{
			this.selectedMap[f.getId()] = true;
		    });
		} else {
		    selectedFields = null;
		}
	    } else {
		selectedFields = null;
	    }
            let fields = this.fields;
	    if(!fields) {
		if(this.getDisplayFields())
		    fields =this.getFieldsByIds(null, this.getDisplayFields(), true);
		else
		    fields = this.getData().getRecordFields();
		if(this.getNumericOnly()) {
		    fields  = fields.filter(f=>{
			return f.isFieldNumeric();
		    });
		}
	    	if(this.getReverseFields()) {
		    let tmp = [];
		    fields.forEach(f=>{
			tmp.unshift(f);
		    });
		    fields=tmp;
		}
		if(!this.getIncludeLatLon()) {
		    fields = fields.filter(f=>{
			return !f.isFieldGeo();
		    });
		}
		if(this.getSortFields(true)) {
		    fields = fields.sort((f1,f2)=>{
			return f1.getDescription().localeCompare(f2.getDescription());
		    });
		}
	    }
	    this.fields	     = fields;
	    this.fieldsMap={};
	    this.fields.forEach(f=>{
		this.fieldsMap[f.getId()] = f;
	    });

//	    html += HU.center('#' + records.length +' records');
	    let fs = [];
	    let clazz = ' ramadda-clickable display-fields-field ';
	    let asList = this.getAsList();
	    if(this.getDecorate(true)) clazz+= ' display-fields-field-decorated ';
	    if(asList)
		clazz+=' display-fields-list-field';
	    let selectable = this.getSelectable(true);
	    let details = this.getShowFieldDetails(false);	    
	    fields.forEach((f,idx)=>{
		
		let block  =f.getLabel();
		let color = this.getProperty(f.getId()+'.color');
		if(color)
		    block+=HU.div([ATTR_CLASS,'display-fields-field-color',ATTR_STYLE,HU.css('background',color)]);
		block = HU.div([ATTR_STYLE,HU.css('position','relative')],block);

		if(details) {
		    block+= '<br>' +
			f.getId() + f.getUnitSuffix()+'<br>' +
			f.getType();
		}
		let c = clazz;
		let selected = this.selectedMap[f.getId()];
		if(selectable) c += ' display-fields-field-selectable ';
		if(selectable && selected) c += ' display-fields-field-selected ';
		let title = '';
		if(selectable)
		    title = 'Click to toggle. Shift-click toggle all';
		block =HU.div([TITLE,title,'field-selected',selected, 'field-id', f.getId(),ATTR_CLASS,c], block);
		fs.push(block);
	    });
	    let fhtml = Utils.wrap(fs,'','');
	    html += fhtml;

	    let label = this.getSelectLabel(this.getFilterSelect()?this.getFilterSelectLabel('Select Filter Fields'):'Select fields');
	    if(this.getShowPopup()) {
		html = HU.div([ID,this.domId(ID_POPUP_BUTTON)], label) +
		    HU.div([ID,this.domId(ID_POPUP),STYLE,'display:none;max-height:300px;overflow-y:auto;width:600px;'], html);
	    }
	    this.setContents(html);
	    if(this.getShowPopup()) {
		this.jq(ID_POPUP_BUTTON).button().click(()=>{
		    this.fieldsDialog = HU.makeDialog({contentId:this.domId(ID_POPUP),title:label,inPlace:true,anchor:this.domId(ID_POPUP_BUTTON),draggable:true,header:true,sticky:true});
		});
	    }
	    if(selectable) {
		let _this = this;
		let fieldBoxes = this.find('.display-fields-field');
		fieldBoxes.draggable({
		    stop: function() {
		    },
		    containment:this.domId(ID_DISPLAY_CONTENTS),
		    revert: true
		});
		fieldBoxes.droppable( {
		    hoverClass: 'display-fields-droppable',
		    accept:'.display-fields-field',
		    drop: function(event,ui) {
			let draggedId = ui.draggable.attr('field-id');
			let targetId = $(this).attr('field-id');			
			let draggedField = _this.fields.find(f=>{
			    if(f.getId()==draggedId) return f;
			    return null;
			});
			let targetField = _this.fields.find(f=>{
			    if(f.getId()==targetId) return f;
			    return null;
			});			
			if(!draggedField) {
			    console.log('could not find dragged field:' + draggedId);
			    return
			}
			if(!targetField) {
			    console.log('could not find target field:' + targetId);
			    return
			}
			
			Utils.moveBefore(_this.fields,targetField,draggedField);
			_this.printFields();
			_this.updateUI();
			_this.handleFieldSelect();
		    }
		});


		fieldBoxes.click(function(event) {
		    if(event.metaKey) {
			_this.printFields();
			return
		    }
		    let shift = event.shiftKey ;
		    let doAll = shift;
		    let allSelected;
		    let selected  = $(this).attr('field-selected')=='true';
		    if(_this.getSelectOne()) {
			if(selected) return;
			selected=true;
			allSelected=false;
			doAll = true;
		    } else {
			selected = !selected;
			allSelected=selected;
		    }
		    if(doAll) {
			fieldBoxes.attr('field-selected',allSelected);
			if(allSelected) {
			    fieldBoxes.addClass('display-fields-field-selected');
			} else {
			    fieldBoxes.removeClass('display-fields-field-selected');
			}

		    }

		    $(this).attr('field-selected',selected);
		    if(selected) {
			$(this).addClass('display-fields-field-selected');
		    } else {
			$(this).removeClass('display-fields-field-selected');
		    }

		    _this.handleFieldSelect();
		});
	    }
	},
	printFields:function() {
	    if(!this.canEdit()) return;
	    let out=this.fields.reduce((v,f,idx)=>{return v+(idx==0?'':',')+f.getId()},'fields=\"');
	    out+='\"\n\n';
	    out+=this.getActiveFields().reduce((v,f,idx)=>{return v+(idx==0?'':',')+f.getId()},'displayFields=\"');
	    out+='\"\n';
	    Utils.copyToClipboard(out);
	    console.log(out);

	},
	getActiveFields:function() {
	    let _this=this;
	    let fieldBoxes = (this.fieldsDialog&&this.fieldsDialog.length)?
		this.fieldsDialog.find(".display-fields-field"):
		this.find(".display-fields-field");
	    let isSelected = {};
	    let selectedFields = [];
	    fieldBoxes.each(function(){
		let selected  = $(this).attr("field-selected")=="true";
		if(selected) {
		    let id = $(this).attr("field-id");
		    let field = _this.fieldsMap[id];
		    if(field) isSelected[field.getId()]=true;
		}
	    });
	    this.fields.forEach(f=>{
		if(isSelected[f.getId()]) selectedFields.push(f);
	    });

	    _this.selectedMap = {};
	    selectedFields.forEach(f=>{
		_this.selectedMap[f.getId()] = true;
	    });
	    return selectedFields;
	},
	handleFieldSelect:function() {
	    let _this = this;
	    let selectedFields  = this.getActiveFields();
	    setTimeout(()=>{
		if(_this.getFilterSelect()) {
		    _this.propagateEvent(DisplayEvent.filterFieldsSelected, selectedFields);
		} else {
		    _this.propagateEvent(DisplayEvent.fieldsSelected, selectedFields);
		}
	    },20);
	}	
});
}


function RamaddaLabelDisplay(displayManager, id, properties) {
    var ID_TEXT = "text";
    var ID_EDIT = "edit";

    if (properties && !Utils.isDefined(properties.showTitle)) {
        properties.showTitle = false;
    }
    this.text = "";
    this.editMode = properties.editMode;
    if (properties.text) this.text = properties.text;
    else if (properties.label) this.text = properties.label;
    else if (properties.html) this.text = properties.html;
    if (properties[ATTR_CLASS]) this[ATTR_CLASS] = properties[ATTR_CLASS];
    else this[ATTR_CLASS] = "display-text";

    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_LABEL, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        initDisplay: function() {
            var theDisplay = this;
            this.createUI();
            var textClass = this[ATTR_CLASS];
            if (this.editMode) {
                textClass += " display-text-edit ";
            }
            var style = "color:" + this.getTextColor("contentsColor") + ";";
            var html = HU.div([ATTR_CLASS, textClass, ATTR_ID, this.getDomId(ID_TEXT), ATTR_STYLE, style], this.text);
            if (this.editMode) {
                html += HU.textarea(ID_EDIT, this.text, ["rows", 5, "cols", 120, ATTR_SIZE, "120", ATTR_CLASS, "display-text-input", ATTR_ID, this.getDomId(ID_EDIT)]);
            }
            this.setContents(html);
            if (this.editMode) {
                var editObj = this.jq(ID_EDIT);
                editObj.blur(function() {
                    theDisplay.text = editObj.val();
                    editObj.hide();
                    theDisplay.initDisplay();
                });
                this.jq(ID_TEXT).click(function() {
                    var src = theDisplay.jq(ID_TEXT);
                    var edit = theDisplay.jq(ID_EDIT);
                    edit.show();
                    edit.css('z-index', '9999');
                    edit.position({
                        of: src,
                        my: "left top",
                        at: "left top",
                        collision: "none none"
                    });
                    theDisplay.jq(ID_TEXT).html("");
                });
            }


        },
        getWikiAttributes: function(attrs) {
            SUPER.getWikiAttributes(attrs);
            attrs.push("text");
            attrs.push(this.text);
        },
    });
}



function RamaddaLegendDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width='100%';
    let SUPER =  new RamaddaDisplay(displayManager, id, DISPLAY_LEGEND, properties);
    RamaddaUtil.inherit(this,SUPER);
    let myProps = [
	{label:'Legend'},
	{p:'labels',ex:''},
	{p:'colors',ex:''},
	{p:'circles',ex:'true'},	
	{p:'inBox',ex:'true'},
	{p:'labelColor',ex:'#fff'},
	{p:'labelColors',ex:'color1,color2,...'},
	{p:'labelField',ex:''},	
	{p:'orientation',ex:'vertical'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	getColorList:function() {
	    if (this.getProperty("colorTable")) {
		let ct =this.getColorTable();
		return ct.colors;
	    }	    
	    return SUPER.getColorList.call(this);
	},

	needsData: function() {
            return this.getProperty("labelField")!=null;
	},
	updateUI: function() {
	    let labels = this.getProperty("labels","").split(",");
            let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    if(labelField) {
		let records = this.filterData();
		if (!records) {
                    this.setDisplayMessage(this.getLoadingMessage());
                    return;
		}
		labels = [];
		records.forEach(record=>{
		    labels.push(labelField.getValue(record));
		});
	    }

            let colorBy;
	    if(this.getProperty("colorTable"))  {
		colorBy = new ColorByInfo(this, [], []);
		labels=[];
	    }

	    let colors = this.getColorList();
	    let html = "";
	    let colorWidth = this.getProperty("colorWidth","20px");
	    let labelColor = this.getProperty("labelColor","#000");
	    let labelColors = this.getProperty("labelColors")?this.getProperty("labelColors").split(","):null;
	    let inBox = this.getProperty("inBox",false);
	    let orientation = this.getProperty("orientation","horizontal");
	    let delim = orientation=="horizontal"?" ":"<br>";
	    let circles = this.getCircles();
	    for(let i=0;i<labels.length;i++) {
		let label = labels[i];
		let color = colors[i]||"#fff";
		if(i>0) html+=delim;
		if(!inBox) {
		    html+=HU.div([ATTR_CLASS,"display-legend-item"], HU.div([ATTR_CLASS,"display-legend-color " + (circles?"display-colortable-dot":""),ATTR_STYLE,"background:" + color+";width:" + colorWidth+";"+(circles?"height:" + colorWidth+";":	  "height:15px;")]) +
				 HU.div([ATTR_CLASS,"display-legend-label"],label));
		} else {
		    let lc = labelColors?labelColors[i]:labelColor || labelColor;
		    html+=HU.div([ATTR_CLASS,"display-legend-color",ATTR_STYLE,"margin-left:8px;background:" + color+";"],
				 HU.div([ATTR_CLASS,"display-legend-label",ATTR_STYLE,"margin-left:8px;margin-right:8x;color:" + lc+";"],label));
		}
	    }
	    if(orientation!="vertical") {
		html = HU.center(html); 
	    }
	    this.setContents(html);
	    if(colorBy) {
		this.displayColorTable(colorBy,ID_COLORTABLE,this.getProperty("colorByMin",10),
				       this.getProperty("colorByMax",100));
	    }
	},
    });
}



function RamaddaDownloadDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_DOWNLOAD, properties);
    const ID_DOWNLOAD_CSV = "downloadcsv";
    const ID_DOWNLOAD_JSON = "downloadjson";
    const ID_DOWNLOAD_COPY = "downloadcopy";
    const ID_DOWNLOAD_FROMSERVER = "fromserver";    
    const ID_FROMDATE = "fromdate";
    const ID_TODATE = "todate";                
    const ID_CANCEL = "cancel";
    const ID_COUNT = "count";        
    let myProps =[
	{label:'Download'},
	{p:'downloadLabel',ex:'Download'},
	{p:'useIcon',d:'false',ex:'false'},
	{p:'iconSize',ex:'',d:'16pt'},	
	{p:'fileName',d:'download',ex:'download'},
	{p:'askFields',d:'false',ex:'true'},
	{p:'showRecordCount',ex:true,tt:'Show # records'},
	{p:'showCsvButton',ex:false,tt:'Show/hide the CSV button'},
	{p:'showJsonButton',ex:false,tt:'Show/hide the JSON button'},
	{p:'showCopyButton',ex:false,tt:'Show/hide the Copy button'},
	{p:'showDateSelect',d:false,ex:true,tt:'Show date select'},			
//	{p:'doSave',d:false,tt:'Show the save file button'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	fieldOn:{},
	needsData: function() {
            return true;
	},
	updateUI: function() {
	    let records = this.filterData();
	    let label = this.getDownloadLabel(this.getProperty("csvLabel","Download Data"));
	    label = label.replace("${title}",this.getProperty(ATTR_TITLE,""));
	    let useIcon = this.getUseIcon(true);
	    let iconSize = this.getIconSize();
	    label = HU.div([ATTR_STYLE,'display:inline-block;',ID,this.getDomId("csv")], useIcon?HU.getIconImage("fa-download",[ATTR_STYLE,'line-height:0px;display:block;'],[STYLE,"cursor:pointer;font-size:" + iconSize+";",TITLE,label]):label);
	    if(this.getShowRecordCount()) {
		label=label+HU.space(2)+HU.span([ATTR_ID,this.domId(ID_COUNT)],records?('# '+records.length+' records'):'');
	    }
	    this.setContents(HU.div([],label));
	    if(useIcon) {
		this.jq("csv").click(() => {
		    this.doDownload();
		});
	    } else {
		this.jq("csv").button().click(() => {
		    this.doDownload();
		});
	    }
	},

	getSubsetFunction: function() {
	    let fromDate = Utils.stringDefined(this.selectFromDate)?new Date(this.selectFromDate):null;
	    let toDate = Utils.stringDefined(this.selectToDate)?new Date(this.selectToDate):null;	    
	    //Offset the to date by 24 hours to get the end of the day
	    if(toDate)
		toDate = new Date(toDate.getTime()+1000*60*60*24);
	    if(fromDate|| toDate) {
		return record=>{
		    if(!record.hasDate()) return false;
		    let date = record.getDate();
		    if(fromDate && date.getTime()<fromDate.getTime()) {
			return false;
		    }
		    if(toDate && date.getTime()>toDate.getTime()) return false;		    
		    return true;
		};
	    }
	    return null;
	},

	getCsv: function(fields, records,copy) {
            fields = fields || this.getData().getRecordFields();
	    
	    let cnt = parseInt(this.jq('number_records').val().trim());
	    let csv = DataUtils.getCsv(fields, records,this.getSubsetFunction(),cnt);
	    if(copy) {
		Utils.copyToClipboard(csv);
		alert("Copied to clipboard");
	    } else {
		Utils.makeDownloadFile(this.getPropertyFileName()+".csv", csv);
	    }
	},
	getJson: function(fields, records) {
            fields = fields || this.getData().getRecordFields();
	    let cnt = parseInt(this.jq('number_records').val().trim());
	    DataUtils.getJson(fields, records,this.getPropertyFileName()+".json",this.getSubsetFunction(),cnt);
	},

	applyFieldSelection: function() {
	    this.getData().getRecordFields().forEach(f=>{
		let cbx = this.jq("cbx_" + f.getId());
		let on = cbx.is(':checked');
		this.fieldOn[f.getId()] = on;
	    });
	},
	getDownloadDialog: function(records) {
            let selectedFields = this.getSelectedFields();
	    if(selectedFields) {
		this.fieldOn = {};
		this.getData().getRecordFields().forEach(f=>{
		    this.fieldOn[f.getId()] = false;
		});
		selectedFields.forEach(f=>{
		    this.fieldOn[f.getId()] = true;
		});
	    }
	    
	    let space = SPACE;
	    let buttons = "";
	    if(this.getShowCsvButton(true)) {
		buttons+=HU.div([ID,this.getDomId(ID_DOWNLOAD_CSV)],"CSV") +space;
	    }
	    if(this.getShowJsonButton(true))
		buttons+=HU.div([ID,this.getDomId(ID_DOWNLOAD_JSON)],"JSON") +space;
	    if(this.getShowCopyButton(true))
		buttons+=  HU.div([ID,this.getDomId(ID_DOWNLOAD_COPY)],"Copy") +space;
	    buttons+=  HU.div([ID,this.getDomId(ID_CANCEL)],"Cancel");
	    let html = HU.center("#" +HU.input('',records.length,[ATTR_ID,this.getDomId('number_records'),ATTR_TITLE,'Select # records to download','size','4']) +" records");
	    html+=HU.center(HU.span([ATTR_STYLE,'font-size:80%;'], 'Note: this downloads the data currently<br>being shown in the browser'));
	    html+=HU.center(buttons);
	    if(this.getShowDateSelect()) {
		html+=HU.formTable();
		html+=HU.formEntry('From date:',
				   HU.tag("input",[ATTR_ID,this.domId(ID_FROMDATE),'placeholder','yyyy-MM-dd','size','10','value',this.selectFromDate??'']));
		html+=HU.formEntry('To date:',
				   HU.tag("input",[ATTR_ID,this.domId(ID_TODATE),'placeholder','yyyy-MM-dd','size','10','value',this.selectToDate??'']));
		html+=HU.formTableClose();
	    }
    
	    html += "<b>Include:</b>";
	    let cbx = "";
	    cbx += HU.checkbox(this.getDomId("cbx_toggle_all"),[],true,"Toggle all") +"<br>";
	    this.getData().getRecordFields().forEach((f,idx)=>{
		let on = this.fieldOn[f.getId()];
		if(!Utils.isDefined(on)) {
		    on = true;
		}
		cbx += HU.checkbox(this.getDomId("cbx_" + f.getId()),[CLASS,"display-downloader-field-cbx"],on,f.getLabel()) +"<br>";
	    });
	    html += HU.div([STYLE,HU.css("max-height","200px","overflow-y","auto","margin-left","10px")], cbx);
	    html = HU.div([STYLE,HU.css("margin","5px")],html);
	    return html;
	},
	doDownload: function() {
	    let records = this.filterData();
	    let func = (json,copy)=>{
		if(this.getShowDateSelect()) {
		    this.selectFromDate=this.jq(ID_FROMDATE).val();
		    this.selectToDate=this.jq(ID_TODATE).val();		    
		}

		this.jq(ID_DIALOG).hide();
		let allFields = this.getData().getRecordFields();
		let fields = [];
		this.applyFieldSelection();
		allFields.forEach(f=>{
		    if(this.fieldOn[f.getId()]) {
			fields.push(f);
		    }
		});

		/*
		let pointData = this.dataCollection.getList()[0];
		let url = new URL('https://localhost/' + pointData.getUrl());
		if(allFields.length!=fields.length) {
		    fields.forEach(f=>{
			url = HU.url(url.toString(),['field_use',f.getId()]);
		    });
		}
		if(!json)
		    url = HU.url(url.toString(),['product','points.csv']);
		console.log(url);
		window.open(url,'_download');
		return
		*/

		if(json) 
		    this.getJson(fields, records);
		else	
		    this.getCsv(fields, records,copy);
		if(this.dialog) this.dialog.remove();
		this.dialog =null;	    };
	    if(this.getPropertyAskFields(true)) {
		let html = this.getDownloadDialog(records);
		let dialog;
		let init = ()=>{
		    let _this = this;
		    this.jq("cbx_toggle_all").click(function() {
			let on = $(this).is(':checked');
			dialog.find(".display-downloader-field-cbx").each(function() {
			    $(this).prop("checked",on);
			});
		    });
		    this.jq(ID_CANCEL).button().click(() =>{
			this.applyFieldSelection();
			this.jq(ID_DIALOG).hide();
			if(this.dialog) this.dialog.remove();
			this.dialog =null;
		    });
		    this.jq(ID_DOWNLOAD_CSV).button().click(() =>{
			func(false);
		    });
		    this.jq(ID_DOWNLOAD_JSON).button().click(() =>{
			func(true);
		    });
		    this.jq(ID_DOWNLOAD_COPY).button().click(() =>{
			func(false,true);
		    });				    
		};
		dialog = this.showDialog(html,this.getDomId(ID_DISPLAY_CONTENTS),init,this.getTitle());


		if(this.getShowDateSelect()) {
		    this.jq(ID_FROMDATE).datepicker({ dateFormat: 'yy-mm-dd',changeMonth: true, changeYear: true,constrainInput:false, yearRange: '1900:2100'  });
		    this.jq(ID_TODATE).datepicker({ dateFormat: 'yy-mm-dd',changeMonth: true, changeYear: true,constrainInput:false, yearRange: '1900:2100'  });		    
		}		


	    } else  {
		this.getCsv(null, records);
	    }
	},
    });
}



function RamaddaReloaderDisplay(displayManager, id, properties) {
    const ID_CHECKBOX= "cbx";
    const ID_COUNTDOWN= "countdown";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RELOADER, properties);
    let myProps = [
	{label:'Reloader'},
	{p:'interval',ex:'30',d:30,label:"Interval"},
	{p:'showCheckbox',ex:'false',d:true,label:"Show Checkbox"},
	{p:'showCountdown',ex:'false',d:true,label:"Show Countdown"},	
	{p:'doPage',ex:'true',tt:'Reload the entire page'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	reloadData: function() {
	    let pointData = this.dataCollection.getList()[0];
	    if(pointData)
		pointData.loadData(this,true);
	    else
		console.log('No data to reload');
	},
	updateUI: function() {
	    let html = "";
	    //If we are already displaying then don't update the UI
	    if(this.jq(ID_COUNTDOWN).length>0) return;
	    if(this.getPropertyShowCheckbox()) {
		html += HU.checkbox(this.getDomId(ID_CHECKBOX),[],true);
	    }		
	    if(this.getPropertyShowCountdown()) {
		html+=" " + HU.span([CLASS,"display-reloader-label", ID,this.getDomId(ID_COUNTDOWN)],this.getCountdownLabel(this.getPropertyInterval()));
	    } else {
		if(this.getPropertyShowCheckbox()) {
		    html+=" " + HU.span([ID,this.getDomId(ID_COUNTDOWN)],"Reload");
		}
	    }
	    this.setContents(html);
            this.clearDisplayMessage();
	    this.jq(ID_CHECKBOX).change(()=>{
		let cbx = this.jq(ID_CHECKBOX);
		if(cbx.is(':checked')) {
		    this.setTimer(this.lastTime);
		}
	    });
	    this.jq(ID_COUNTDOWN).addClass("ramadda-clickable").css("cursor","pointer").attr(ATTR_TITLE,"Reload").click(()=>{
		this.checkReload(-1);
	    });
	    this.setTimer(this.getPropertyInterval());
	},
	setDisplayMessage:function(msg) {
	    //noop
	},
	okToRun: function() {
	    let cbx = this.jq(ID_CHECKBOX);
	    if(cbx.length==0) return true;
	    return cbx.is(':checked');
	},
	getCountdownLabel: function(time) {
	    let pad = "";
	    if(time<10) pad = "&nbsp;";
	    if(time>60) {
		let minutes = Math.round((time-time%60)/60);
		let seconds = time%60;
		if(minutes<10) minutes  = "0" + String(minutes);
		if(seconds<10) seconds = "0"+String(seconds);
		return "Reload in " + minutes +":" + seconds+pad;
	    }
	    return "Reload in " + time +" seconds"+pad;
	},
	updateCountdown(time) {
	    if(this.getPropertyShowCountdown()) {
		this.jq(ID_COUNTDOWN).html(this.getCountdownLabel(time));
	    } else {
		this.jq(ID_COUNTDOWN).html("Reload");
	    }
	},
	setTimer(time) {
	    if(!this.okToRun()) return;
	    this.lastTime = time;
	    this.updateCountdown(time);
	    if(this.lastTimeout) clearTimeout(this.lastTimeout);
	    this.lastTimeout = setTimeout(()=>{
		this.checkReload(time);
	    },1000);
	},
	doReload: function(time) {
	    if(this.getDoPage()) {
		location.reload(true);
	    } else {
		this.reloadData();
	    }
	},
	checkReload: function(time) {
	    time--;
	    if(time<=0) {
		this.jq(ID_COUNTDOWN).html("Reloading..." +HU.span([STYLE,"color:transparent;"],""));
		this.doReload();
		time = this.getPropertyInterval();
		//Start up again in a bit so the reloading... label is shown
		if(this.lastTimeout) clearTimeout(this.lastTimeout);
		this.lastTimeout = setTimeout(()=>{
		    this.setTimer(time);
		},1000);
	    } else {
		this.setTimer(time);
	    }
	}
    });
}

function RamaddaTicksDisplay(displayManager, id, properties) {
    if(!properties.animationHeight) properties.animationHeight = "30px";
    properties.doAnimation =  false;
    properties.animationShowButtons = false;
    properties.animationMakeSlider = false;
    const ID_ANIMATION = "animation";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TICKS, properties);
    let myProps = [
	{label:'Time Ticks'},
	{p:'animationHeight',ex:'30px'},
	{p:'showYears',ex:'true'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {    
        needsData: function() {
            return true;
        },
	dataFilterChanged: function() {
	    SUPER.dataFilterChanged.call(this);
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let dateInfo = this.getDateInfo(records);
	    let years = {
	    }
	    if(!this.getPropertyShowYears(false)) {
		years["all"] = {
		    records:records,
		    yearCnt:"all"
		}
	    } else {
		let yearCnt=0;
		records.forEach(record=>{
		    if(!record.getDate()) return;
		    let year = record.getDate().getUTCFullYear();
		    if(years[year] == null) {
			years[year] = {
			    records:[],
			}
		    }
		    years[year].records.push(record);
		});
	    }
	    let html = "";
	    Object.keys(years).sort().forEach(year=>{
		html+=HU.div([CLASS,'display-ticks-ticks', ID,this.getDomId(ID_ANIMATION+year)]);
	    })
	    this.setContents(html);
	    Object.keys(years).sort().forEach((year,idx)=>{		 
		let info=years[year];
		let dateInfo = this.getDateInfo(info.records);
		let animation = new DisplayAnimation(this,true,{baseDomId:ID_ANIMATION+year,targetDiv:this.jq(ID_ANIMATION+year)});
		animation.makeControls();
		if(year!="all") {
		    dateInfo.dateMin = new Date(Date.UTC(year,0,1));
		    dateInfo.dateMax = new Date(Date.UTC(year,11,31));
		}
		animation.init(dateInfo.dateMin, dateInfo.dateMax,info.records);
	    });
	}
    });
}



function RamaddaMenuDisplay(displayManager, id, properties) {
    const ID_MENU = "menu";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MENU, properties);
    let myProps = [
	{label:'Record Menu'},
	{p:'labelTemplate',d:'${name}'},
	{p:'menuLabel',ex:''},
	{p:'showArrows',d:false,ex:true},
	{p:'showButtons',d:false,ex:true},
	{p:'maxPerRow',tt:'When showing buttons how many buttons per row',ex:6},	
	{p:'buttonStyle',d:''},
	{p:'buttonStyleOn',d:''},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {    
        needsData: function() {
            return true;
        },
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    if(!this.recordToIdx) return;
	    let idx = this.recordToIdx[args.record.getId()];
	    if(Utils.isDefined(idx)) {
		this.jq(ID_MENU).val(idx);
	    }
	},
        pointDataLoaded: function(pointData, url, reload) {
//	    this.logMsg("pointDataLoaded");
	    SUPER.pointDataLoaded.call(this, pointData,url,reload);
	    if(this.haveLoadedData && this.records) {
		setTimeout(()=>{
		    let record = this.records[+this.jq(ID_MENU).val()];
		    if(record) {
			this.propagateEventRecordSelection({record: record});
		    }},100);
	    }
	    this.haveLoadedData= true;
	},

	updateUI: function() {
	    let _this = this;
//	    this.logMsg("updateUI");
	    this.records = this.filterData();
	    if(!this.records) return;
	    let options = [];
	    let labelTemplate = this.getLabelTemplate();
	    this.recordToIdx = {};
	    let showButtons = this.getShowButtons();
	    if(showButtons) {
		let buttonStyle = this.getButtonStyle();
		let buttonStyleOn = this.getButtonStyleOn();		
		let tabs = [];
		this.idToRecord = {};
		let count = 0;
		let maxPerRow  = this.getProperty('maxPerRow',-1);
		let html = '';
		if(maxPerRow>=0) {
		    html=HU.open('div',[ATTR_STYLE,'text-align:center;']);
		}
		this.records.forEach((record,idx)=>{
		    if(maxPerRow>=0) {
			count++;
			if(count>maxPerRow) {
			    count=1;
			    //Add a spacer
			    tabs.push('<div style=\'margin-top:4px;\'></div>');
			}
		    }
		    let label = this.getRecordHtml(record, null, labelTemplate);
		    let style = buttonStyle;
		    if(idx==0) style+=buttonStyleOn;
		    tabs.push(HU.span([ATTR_CLASS,'display-menu-button-item ramadda-hoverable ramadda-clickable ' + (idx==0?'display-menu-button-item-on':''),ATTR_STYLE,style,RECORD_ID,record.getId()], label));
		    this.idToRecord[record.getId()] = record;
		});
		html+=Utils.join(tabs,"");
		if(maxPerRow>=0) {
		    html+=HU.close('div');
		}
		this.setContents(html);
		let items = this.getContents().find('.display-menu-button-item');
		items.click(function() {
		    if($(this).hasClass('display-menu-button-item-on')) return;
		    let record = _this.idToRecord[$(this).attr(RECORD_ID)];
		    items.removeClass('display-menu-button-item-on');
		    items.attr(ATTR_STYLE,buttonStyle);		    
		    items.removeClass('display-menu-button-item-on');
		    $(this).addClass('display-menu-button-button-on');
		    $(this).attr(ATTR_STYLE,buttonStyle+buttonStyleOn);
		    _this.propagateEventRecordSelection({record: record});
		});
		return
	    }

	    this.records.forEach((record,idx)=>{
		let label = this.getRecordHtml(record, null, labelTemplate);
		options.push([idx,label]);
		this.recordToIdx[record.getId()] = idx;
	    });

	    let menu =  HU.select("",[ATTR_ID, this.getDomId(ID_MENU)],options);
	    if(this.getShowArrows(false)) {
		let noun = this.getProperty("noun", "Data");
		let prev = HU.span([CLASS,"display-changeentries-button ramadda-clickable", TITLE,"Previous " +noun, ID, this.getDomId(ID_PREV), TITLE,"Previous"], HU.getIconImage("fa-chevron-left"));
 		let next = HU.span([CLASS, "display-changeentries-button ramadda-clickable", TITLE,"Next " + noun, ID, this.getDomId(ID_NEXT), TITLE,"Next"], HU.getIconImage("fa-chevron-right")); 
		menu = menu.replace(/\n/g,"");
		menu = prev + "&nbsp;" + menu +  "&nbsp;" +next;
	    }
	    let label = this.getMenuLabel();
	    if(label) menu = label+"&nbsp;" + menu;
	    this.setContents(menu);
	    if(this.getShowArrows(false)) {
		this.jq(ID_PREV).click(e=>{
		    let index = +this.jq(ID_MENU).val()-1;
		    if(index<0) {
			index = this.records.length-1;
		    }
		    this.jq(ID_MENU).val(index).trigger("change");
		});
		this.jq(ID_NEXT).click(e=>{
		    let index = +this.jq(ID_MENU).val()+1;
		    if(index>=this.records.length) {
			index = 0;
		    }
		    this.jq(ID_MENU).val(index).trigger("change");
		});
	    }
	    this.jq(ID_MENU).change(()=> {
		let record = this.records[+this.jq(ID_MENU).val()];
		this.propagateEventRecordSelection({record: record});
	    });

	}
    });
}


/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/

const DISPLAY_NOTEBOOK = "notebook";
addGlobalDisplayType({
    type: DISPLAY_NOTEBOOK,
    label: "Notebook",
    requiresData: false,
    category: CATEGORY_CONTROLS
});

var pluginDefintions = {
    'jsx': {
        "languageId": "jsx",
        "displayName": "React JSX",
        "url": "https://raw.githubusercontent.com/hamilton/iodide-jsx/master/docs/evaluate-jsx.js",
        "module": "jsx",
        "evaluator": "evaluateJSX",
        "pluginType": "language"
    },
    "lisp": {
        "languageId": "lisp",
        "displayName": "Microtalk Lisp",
        "url": "https://ds604.neocities.org/js/microtalk.js",
        "module": "MICROTALK",
        "evaluator": "evaluate",
        "pluginType": "language",
        "outputHandler": "processLispOutput",
    },
    "sql": {
        "languageId": "sql",
        "displayName": "SqlLite",
        "url": ramaddaBaseHtdocs+"/lib/notebook/sqllite.js",
        "module": "SqlLite",
        "evaluator": "evaluate",
        "pluginType": "language"
    },
    "plantuml": {
        "languageId": "plantuml",
        "displayName": "PlantUml",
        "codeMirrorMode": "",
        "keybinding": "x",
        "url": "https://raw.githubusercontent.com/six42/iodide-plantuml-plugin/master/src/iodide-plantuml-plugin.js",
        "depends": [{
            "type": "js",
            "url": "https://raw.githubusercontent.com/johan/js-deflate/master/rawdeflate.js"
        }],
        "module": "plantuml",
        "evaluator": "plantuml_img",
        "pluginType": "language"
    },
    "ml": {
        "languageId": "ml",
        "displayName": "ocaml",
        "codeMirrorMode": "mllike",
        "keybinding": "o",
        "url": "https://louisabraham.github.io/domical/eval.js",
        "module": "evaluator",
        "evaluator": "execute",
        "pluginType": "language",
        "depends": [{
            "type": "css",
            "url": "https://louisabraham.github.io/domical/style.css"
        }]
    }
};




function RamaddaNotebookDisplay(displayManager, id, properties) {
    var ID_NOTEBOOK = "notebook";
    var ID_IMPORTS = "imports";
    var ID_CELLS = "cells";
    var ID_CELLS_BOTTOM = "cellsbottom";
    var ID_INPUTS = "inputs";
    var ID_OUTPUTS = "outputs";
    var ID_CONSOLE = "console";
    var ID_CONSOLE_TOOLBAR = "consoletoolbar";
    var ID_CONSOLE_CONTAINER = "consolecontainer";
    var ID_CONSOLE_OUTPUT = "consoleout";
    var ID_CELL = "cell";
    var ID_MENU = "menu";
    this.properties = properties || {};
    let SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_NOTEBOOK, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        runOnLoad: this.getProperty("runOnLoad", true),
        displayMode: this.getProperty("displayMode", false),
        showConsole: this.getProperty("showConsole", true),
        consoleHidden: this.getProperty("consoleHidden", false),
        layout: this.getProperty("layout", "horizontal"),
        columns: this.getProperty("columns", 1),
    });

    RamaddaUtil.defineMembers(this, {
        cells: [],
        cellCount: 0,
        fetchedNotebook: false,
        currentEntries: {},
        globals: {},
        baseEntries: {},
        outputRenderers: [],
        initDisplay: async function() {
            this.createUI();
            var imports = HtmlUtils.div([ATTR_ID, this.getDomId(ID_IMPORTS)]);
            var contents = imports + HtmlUtils.div([ATTR_CLASS, "display-notebook-cells", ATTR_ID, this.getDomId(ID_CELLS)], "&nbsp;&nbsp;Loading...") +
                HtmlUtils.div([ATTR_ID, this.getDomId(ID_CELLS_BOTTOM)]);
            var popup = HtmlUtils.div([ATTR_CLASS, "ramadda-popup", ATTR_ID, this.getDomId(ID_MENU)]);
            contents = HtmlUtils.div([ATTR_ID, this.getDomId(ID_NOTEBOOK)], popup + contents);
            this.setContents(contents);
            this.makeCellLayout();
            this.jq(ID_NOTEBOOK).hover(() => {}, () => {
                this.jq(ID_MENU).hide()
            });
            if (!this.fetchedNotebook) {
                this.initOutputRenderers();
                if (!this.fetchingNotebook) {
                    this.fetchingNotebook = true;
                    await Utils.importJS(ramaddaBaseHtdocs + "/lib/ace/src-min/ace.js");
                    await Utils.importJS(ramaddaBaseUrl + "/lib/showdown.min.js");
                    var imports = "<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Main-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Math-Italic.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Size2-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Size4-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'/>\n<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Lato:300,400,700,700i'>\n<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css' crossorigin='anonymous'>\n<script defer src='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js' crossorigin='anonymous'></script>";
                    $(imports).appendTo("head");
                    setTimeout(() => this.fetchNotebook(1), 10);
                }
            } else {
                this.layoutCells();
            }
        },
        fetchNotebook: async function(cnt) {
            if (!window["ace"]) {
                if (cnt > 50) {
                    alert("Could not load ace.js");
                    return;
                }
                setTimeout(() => this.fetchNotebook(cnt + 1), cnt * 10);
                return;
            }
            var dttm = new Date().getTime();
            ace.config.set('basePath', ramaddaBaseUrl + "/htdocs_v" + dttm + "/lib/ace/src-min");
            let _this = this;
            this.fetchedNotebook = true;
            await this.getEntry(this.getProperty("entryId", ""), entry => {
                this.baseEntry = entry;
            });
            await this.baseEntry.getRoot(entry => {
                this.rootEntry = entry;
            });
            var id = this.getProperty("entryId", "");
            var url = ramaddaBaseUrl + "/getnotebook?entryid=" + id;
            url += "&notebookId=" + this.getProperty("notebookId", "default_notebook");
            var jqxhr = $.getJSON(url, function(data) {
                _this.loadJson(data);
            }).fail(function() {
                var props = {
                    showInput: true,
                }
                this.addCell("init cell", props, false).run();
                this.cells[0].focus();
            });

        },
        formatObject: function(value) {
            return Utils.formatJson(value);
        },
        initOutputRenderers: function() {
            let notebook = this;
            this.outputRenderers = [];
            /*
            this.addOutputRenderer({
                    shouldRender: (value) => {return typeof value === "object";},
                        render: (value) => {if(Array.isArray(value)) return HtmlUtils.div([ATTR_STYLE," white-space: pre;"], JSON.stringify(value)); return HtmlUtils.div([ATTR_STYLE," white-space: pre;"],JSON.stringify(value,null,2))},
                        });
            */
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return Array.isArray(value);
                },
                render: (value) => {
                    return Utils.formatJson(value);
                },
            });
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return Array.isArray(value) && value.length > 0 && Array.isArray(value[0]);
                },
                render: (value) => {
                    var table = "<table>";
                    for (var rowIdx = 0; rowIdx < value.length; rowIdx++) {
                        var row = value[rowIdx];
                        table += "<tr>";
                        for (var colIdx = 0; colIdx < row.length; colIdx++) {
                            table += "<td>&nbsp;" + row[colIdx] + "</td>";
                        }
                        table += "</tr>";
                    }
                    table += "</table>";
                    return table;

                }
            });


            this.addOutputRenderer({
                shouldRender: (value) => {
                    return typeof value === "object" && value.getTime;
                },
                render: (value) => {
                    return notebook.formatDate(value)
                },
            });

            this.addOutputRenderer({
                shouldRender: (value) => {
                    var t = typeof value;
                    return t === "string" || t === "number" || t === "boolean";
                },
                render: (value) => {
                    if (typeof value === "string") {
                        if (value.split("\n").length > 1) {
                            return HtmlUtils.div([ATTR_STYLE, " white-space: pre;"], value);
                        }
                    }
                    return value
                },
            });
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return typeof value === "object" && "lat" in value && "lon" in value;
                },
                render: (value) => {
                    var url = 'http://staticmap.openstreetmap.de/staticmap.php?center=' + value.lat + ',' + value.lon + '&zoom=17&size=400x150&maptype=mapnik';
                    return "<img src='" + url + "'/>"
                },
            });

        },
        addOutputRenderer: function(renderer) {
            if (this.outputRenderers.indexOf(renderer) < 0) {
                this.outputRenderers.push(renderer);
            }
        },
        formatOutput: function(value) {
            if (!value) return null;
            for (var i = this.outputRenderers.length - 1; i >= 0; i--) {
                var renderer = this.outputRenderers[i];
                if (renderer.shouldRender && renderer.shouldRender(value)) {
                    return renderer.render(value);
                }
            }
            var v = null;
            if (value.iodideRender) {
                v = value.iodideRender();
            } else if (value.notebookRender) {
                v = value.notebookRender();
            }
            if (v) {
                //TODO handle elements
                if (typeof v == "string") {
                    return v;
                }
            }
            return null;
        },
        getBaseEntry: function() {
            return this.baseEntry;
        },
        getRootEntry: function() {
            return this.rootEntry;
        },
        getPopup: function() {
            return this.jq(ID_MENU);
        },
        loadJson: async function(data) {
            if (data.error) {
                this.setContents(_this.getMessage("Failed to load notebook: " + data.error));
                return;
            }
            if (!Utils.isDefined(this.properties.runOnLoad) && Utils.isDefined(data.runOnLoad)) {
                this.runOnLoad = data.runOnLoad;
            }
            if (!Utils.isDefined(this.properties.displayMode) && Utils.isDefined(data.displayMode)) {
                this.displayMode = data.displayMode;
            }
            if (!Utils.isDefined(this.properties.showConsole) && Utils.isDefined(data.showConsole)) {
                this.showConsole = data.showConsole;
            }
            if (Utils.isDefined(data.consoleHidden)) {
                this.consoleHidden = data.consoleHidden;
            }
            if (!Utils.isDefined(this.properties.columns) && Utils.isDefined(data.columns)) {
                this.columns = data.columns;
            }
            if (!Utils.isDefined(this.properties.layout) && Utils.isDefined(data.layout)) {
                this.layout = data.layout;
            }

            if (Utils.isDefined(data.currentEntries)) {
                for (a in data.currentEntries) {
                    var obj = {};
                    if (this.currentEntries[a]) continue;
                    obj.name = a;
                    obj.entryId = data.currentEntries[a].entryId;
                    try {
                        await this.getEntry(obj.entryId, e => obj.entry = e);
                        this.currentEntries[a] = obj;
                    } catch (e) {}
                }
            }
            if (Utils.isDefined(data.cells)) {
                this.cells = [];
                data.cells.forEach(cell => this.addCell(cell.outputHtml, cell, true));
                this.layoutCells();
            }
            if (this.cells.length == 0) {
                var props = {
                    showInput: true,
                }
                this.addCell("%%wiki\n", props, false);
                this.layoutCells();
                this.cells[0].focus();
            }
            if (this.runOnLoad) {
                this.runAll();
            }
        },
        addEntry: async function(name, entryId) {
            var entry;
            await this.getEntry(entryId, e => entry = e);
            this.currentEntries[name] = {
                entryId: entryId,
                entry: entry
            };
        },
        getCurrentEntries: function() {
            return this.currentEntries;
        },
        clearEntries: function() {
            this.currentEntries = {};
            for (a in this.baseEntries)
                this.currentEntries[a] = this.baseEntries[a];
        },
        saveNotebook: function(output) {
            var json = this.getJson(output);
            json = JSON.stringify(json, null, 2);
            var args = {
                entryid: this.getProperty("entryId", ""),
                notebookId: this.getProperty("notebookId", "default_notebook"),
                notebook: json
            };
            var url = ramaddaBaseUrl + "/savenotebook";
            $.post(url, args, (result) => {
                if (result.error) {
                    alert("Error saving notebook: " + result.error);
                    return;
                }
                if (result.result != "ok") {
                    alert("Error saving notebook: " + result.result);
                    return;
                }
                if (!this.getShowConsole()) {
                    alert("Notebook saved");
                } else {
                    this.log("Notebook saved", "info", "nb");
                }
            });
        },
        showInput: function() {
            if (this.displayMode && !this.getProperty("user")) {
                return false;
            }
            if (this.getProperty("showInput", true) == false) {
                return false;
	    }
            return true;
        },
        getJson: function(output) {
            var obj = {
                cells: [],
                currentEntries: {},
                runOnLoad: this.runOnLoad,
                displayMode: this.displayMode,
                showConsole: this.showConsole,
                consoleHidden: this.consoleHidden,
                layout: this.layout,
                columns: this.columns,
            };
            for (var name in this.currentEntries) {
                var e = this.currentEntries[name];
                obj.currentEntries[name] = {
                    entryId: e.entryId
                };
            }
            this.cells.forEach(cell => obj.cells.push(cell.getJson(output)));
            return obj;
        },
        initConsole: function() {
            if (!this.showInput()) {
                return;
            }
            let _this = this;
            this.console = this.jq(ID_CONSOLE_OUTPUT);
            if (this.consoleHidden)
                this.console.hide();
            this.jq(ID_CONSOLE).find(".ramadda-image-link").click(function(e) {
                var what = $(this).attr("what");
                if (what == "clear") {
                    _this.console.html("");
                }
                e.stopPropagation();
            });

            this.consoleToolbar = this.jq(ID_CONSOLE_TOOLBAR);
            this.consoleToolbar.click(() => {
                if (this.console.is(":visible")) {
                    this.console.hide(400);
                    this.consoleHidden = true;
                } else {
                    this.consoleHidden = false;
                    this.console.show(400);
                }
            });
        },
        getShowConsole: function() {
            return this.showInput() && this.showConsole;
        },
        makeConsole: function() {
            this.console = null;
            if (!this.getShowConsole()) {
                return "";
            }
            var contents = this.jq(ID_CONSOLE_OUTPUT).html();
            var consoleToolbar = HtmlUtils.div([ATTR_ID, this.getDomId(ID_CONSOLE_TOOLBAR), ATTR_CLASS, "display-notebook-console-toolbar", ATTR_TITLE, "click to hide/show console"],
                HtmlUtils.leftRight("",
                    HtmlUtils.span([ATTR_CLASS, "ramadda-image-link", ATTR_TITLE, "Clear", "what", "clear"],
                        HtmlUtils.image(Utils.getIcon("clear.png")))));
            return HtmlUtils.div([ATTR_ID, this.getDomId(ID_CONSOLE), ATTR_CLASS, "display-notebook-console"],
                consoleToolbar +
                HtmlUtils.div([ATTR_CLASS, "display-notebook-console-output", ATTR_ID, this.getDomId(ID_CONSOLE_OUTPUT)], contents || ""));
        },

        makeCellLayout: function() {
            var html = "";
            var consoleContainer = HtmlUtils.div([ATTR_ID, this.getDomId(ID_CONSOLE_CONTAINER)]);
            this.jq(ID_CELLS_BOTTOM).html("");
            if (this.showInput() && this.layout == "horizontal") {
                var left = HtmlUtils.div([ATTR_ID, this.getDomId(ID_INPUTS), ATTR_STYLE, "width:100%;"]);
                var right = HtmlUtils.div([ATTR_ID, this.getDomId(ID_OUTPUTS), ATTR_STYLE, "width:100%;"]);
                var center = HtmlUtils.div([], "");
                left += consoleContainer;
                html = "<table style='table-layout:fixed;' border=0 width=100%><tr valign=top><td width=50%>" + left + "</td><td style='border-left:1px #ccc solid;' width=1>" + center + "</td><td width=49%>" + right + "</td></tr></table>";
            } else {
                this.jq(ID_CELLS_BOTTOM).html(consoleContainer);
            }
            this.jq(ID_CELLS).html(html);
        },
        plugins: {},
        addPlugin: async function(plugin, chunk) {
            var error;
            if (plugin.depends) {
                for (var i = 0; i < plugin.depends.length; i++) {
                    var obj = plugin.depends[i];
                    var type = obj.type;
                    var url = obj.url;
                    if (type == "js") {
                        await Utils.importJS(url,
                            () => {},
                            (jqxhr, settings, exception) => {
                                error = "Error fetching plugin url:" + url;
                            });
                    } else if (type == "css") {
                        await Utils.importCSS(url,
                            () => {},
                            (jqxhr, settings, exception) => {
                                error = "Error fetching plugin url:" + url;
                            });
                    }
                    if (error) {
                        this.log(error, "error", "nb", chunk ? chunk.div : null);
                        return;
                    }
                }
            }

            var url = Utils.replaceRoot(plugin.url);
            await Utils.importJS(url,
                () => {},
                (jqxhr, settings, exception) => {
                    error = "Error fetching plugin url:" + url;
                });
            if (!error) {
                var module = plugin.module;
                var tries = 200;
                //Wait 20 seconds max
                while (window[module] == null && tries-- > 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                if (!window[module]) {
                    error = "Could not load plugin module: " + module;
                } else {
                    if (window[module].isPluginReady) {
                        var tries = 200;
                        while (!window[module].isPluginReady() && tries-- > 0) {
                            //                            console.log("not ready yet:" + tries);
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        //                        console.log("final ready:" + window[module].isPluginReady() );
                        if (!window[module].isPluginReady())
                            error = "Could not load plugin module: " + module;
                    }
                }
            }
            if (error) {
                this.log(error, "error", "nb", chunk ? chunk.div : null);
                return;
            }
            this.plugins[plugin.languageId] = plugin;
        },
        hasPlugin: async function(id, callback) {
            if (!this.plugins[id]) {
                if (window.pluginDefintions[id]) {
                    await this.addPlugin(window.pluginDefintions[id], null);
                }
            }
            Utils.call(callback, this.plugins[id] != null);
        },
        processChunkWithPlugin: async function(id, chunk, callback) {
            var module = this.plugins[id].module;
            var func = this.plugins[id].evaluator;
            var result = window[module][func](chunk.getContent(), chunk);
            return Utils.call(callback, result);

        },
        processPluginOutput: function(id, chunk, result) {
            if (!result) return;
            var module = this.plugins[id].module;
            var func = window[this.plugins[id].outputHandler];
            if (func) {
                chunk.div.append(func(result));
            } else {
                if (typeof result == "object") {
                    //TODO: for now don't format this as some results are recursive
                    //                   console.log(result);
                    //                   chunk.div.set(this.formatObject(result));
                } else {
                    chunk.div.set(result);
                }
            }
        },
        log: function(msg, type, from, div) {
            var icon = "";
            var clazz = "display-notebook-console-item";
            if (typeof msg == "object") {
                msg = Utils.formatJson(msg);
            }
            if (type == "error") {
                clazz += " display-notebook-console-item-error";
                icon = HtmlUtils.image(Utils.getIcon("cross-octagon.png"));
                if (div) {
                    div.append(HtmlUtils.div([ATTR_CLASS, "display-notebook-chunk-error"], msg));
                }
            } else if (type == "output") {
                clazz += " display-notebook-console-item-output";
                icon = HtmlUtils.image(Utils.getIcon("arrow-000-small.png"));
            } else if (type == "info") {
                clazz += " display-notebook-console-item-info";
                icon = HtmlUtils.image(Utils.getIcon("information.png"));
            }
            if (!this.console) return;
            if (!from) from = "";
            else from = HtmlUtils.div([ATTR_CLASS, "display-notebook-console-from"], from);
            var block = HtmlUtils.div([ATTR_STYLE, "margin-left:5px;"], msg);
            var html = "<table width=100%><tr valign=top><td width=10>" + icon + "</td><td>" +
                block +
                "</td><td width=10>" +
                from +
                "</td></tr></table>";
            var item = HtmlUtils.div([ATTR_CLASS, clazz], html);
            this.console.append(item);
            //200 is defined in display.css
            var height = this.console.prop('scrollHeight');
            if (height > 200)
                this.console.scrollTop(height - 200);
        },
        clearConsole: function() {
            this.console.html("");
        },
        layoutCells: function() {
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.prepareToLayout();
            }
            this.makeCellLayout();
            if (this.showInput() && this.layout == "horizontal") {
                var left = "";
                var right = "";
                var id;
                for (var i = 0; i < this.cells.length; i++) {
                    var cell = this.cells[i];
                    id = cell.id;
                    cell.index = i + 1;
                    left += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], "");
                    left += "\n";
                    right += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], "");
                }
                this.jq(ID_INPUTS).html(left);
                this.jq(ID_OUTPUTS).html(right);
            } else {
                var html = "<div class=row style='padding:0px;margin:0px;'>";
                var clazz = HtmlUtils.getBootstrapClass(this.columns);
                var colCnt = 0;
                for (var i = 0; i < this.cells.length; i++) {
                    var cell = this.cells[i];
                    cell.index = i + 1;
                    html += HtmlUtils.openTag("div", [ATTR_CLASS, clazz]);
                    html += HtmlUtils.openTag("div", [ATTR_STYLE, "max-width:100%;overflow-x:auto;padding:0px;margin:px;"]);
                    html += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], "");
                    html += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], "");
                    html += HtmlUtils.closeTag("div");
                    html += HtmlUtils.closeTag("div");
                    html += "\n";
                    colCnt++;
                    if (colCnt >= this.columns) {
                        colCnt = 0;
                        html += HtmlUtils.closeTag("div");
                        html += "<div class=row style='padding:0px;margin:0px;'>";
                    }
                };
                html += HtmlUtils.closeTag("div");
                this.jq(ID_CELLS).append(html);
            }
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.createCell();
            };
            this.jq(ID_CONSOLE_CONTAINER).html(this.makeConsole());
            this.initConsole();
        },
        addCell: function(content, props, layoutLater) {
            cell = this.createCell(content, props);
            this.cells.push(cell);
            if (!layoutLater) {
                if (this.showInput() && this.layout == "horizontal") {
                    this.jq(ID_INPUTS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], ""));
                    this.jq(ID_OUTPUTS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], ""));
                } else {
                    this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], ""));
                    this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], ""));
                }
                cell.createCell();
            }
            return cell;
        },
        createCell: function(content, props) {
            if (!props) props = {
                showInput: true
            };
            var cellId = this.getId() + "_" + this.cellCount;
            //Override any saved id
            props.id = cellId;
            this.cellCount++;
            this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cellId], ""));
            var cell = new RamaddaNotebookCell(this, cellId, content, props);
            return cell;
        },
        clearOutput: function() {
            this.cells.forEach(cell => cell.clearOutput());
        },
        getIndex: function(cell) {
            var idx = 0;
            for (var i = 0; i < this.cells.length; i++) {
                if (cell.id == this.cells[i].id) {
                    idx = i;
                    break;
                }
            }
            return idx;
        },
        moveCellUp: function(cell) {
            var cells = [];
            var newCell = null;
            var idx = this.getIndex(cell);
            if (idx == 0) return;
            this.cells.splice(idx, 1);
            this.cells.splice(idx - 1, 0, cell);
            this.layoutCells();
            cell.focus();
        },
        moveCellDown: function(cell) {
            var cells = [];
            var newCell = null;
            var idx = this.getIndex(cell);
            if (idx == this.cells.length - 1) return;
            this.cells.splice(idx, 1);
            this.cells.splice(idx + 1, 0, cell);
            this.layoutCells();
            cell.focus();
        },

        newCellAbove: function(cell) {
            var cells = [];
            var newCell = null;
            for (var i = 0; i < this.cells.length; i++) {
                if (cell.id == this.cells[i].id) {
                    newCell = this.createCell("%%wiki\n", {
                        showInput: true,
                        showHeader: false
                    });
                    cells.push(newCell);
                }
                cells.push(this.cells[i]);
            }
            this.cells = cells;
            this.layoutCells();
            newCell.focus();
        },

        newCellBelow: function(cell) {
            var cells = [];
            var newCell = null;
            for (var i = 0; i < this.cells.length; i++) {
                cells.push(this.cells[i]);
                if (cell.id == this.cells[i].id) {
                    newCell = this.createCell("%%wiki\n", {
                        showInput: true,
                        showHeader: false
                    });
                    cells.push(newCell);
                }
            }
            this.cells = cells;
            this.layoutCells();
            newCell.focus();
        },
        deleteCell: function(cell) {
            cell.jq(ID_CELL).remove();
            var cells = [];
            this.cells.forEach(c => {
                if (cell.id != c.id) {
                    cells.push(c);
                }
            });
            this.cells = cells;
            if (this.cells.length == 0) {
                this.addCell("", null);
            }
        },
        cellValues: {},
        setCellValue: function(name, value) {
            this.cellValues[name] = value;
        },
        getCellValues: function() {
            return this.cellValues;
        },
        convertInput: function(input) {
            for (name in this.cellValues) {
                var re = new RegExp("\\$\\{" + name + "\\}", "g");
                input = input.replace(re, this.cellValues[name]);
            }
            return input;
        },
        inGlobalChanged: false,
        globalChanged: async function(name, value) {
                var globalChangeCalled = this.inGlobalChanged;
                var top = !this.inGlobalChanged;
                if(this.inRunAll) {
                    top =  false;
                }
                this.inGlobalChanged=true;
                if(top) {
                    this.cells.forEach(cell=>cell.prepareToRun());
                }
                for(var i=0;i<this.cells.length;i++) {
                    await this.cells[i].globalChanged(name,value);
                }
                if(!globalChangeCalled) {
                    this.inGlobalChanged = false;
                }
        },
        addGlobal: async function(name, value, dontPropagate) {
            //TODO: more var name cleanup
            name = name.trim().replace(/[ -]/g, "_");
            var oldValue = this.getGlobalValue(name);
            if (Utils.isDefined(window[name])) window[name] = value;
            this.globals[name] = value;
            if(!dontPropagate) {
                var newValue = this.getGlobalValue(name);
                if(newValue!=oldValue) {
                    //TODO:
                    //                    await this.globalChanged(name, newValue);
                }
            }
        },
        getGlobalValue: function(name) {
                if(!this.globals[name]) return null;
                if(typeof this.globals[name] =="function") return this.globals[name]();
                return this.globals[name];
        },
        inRunAll: false,
        runAll: async function() {
            this.inRunAll = true;
            var ok = true;
            this.cellValues = {};
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.prepareToRun();
            }
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                if (!cell.runFirst) continue;
                await this.runCell(cell).then(result => ok = result);
            }
            if (!ok) return;
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                if (cell.runFirst) continue;
                await this.runCell(cell, true).then(result => ok = result);
            }
            this.inRunAll = false;
        },
        runCell: async function(cell, doingAll) {
            if (cell.hasRun) return true;
            await cell.run(result => ok = result, {
                doingAll: doingAll
            });
            if (!ok) return false;
            var raw = cell.getRawOutput();
            if (raw) {
                raw = raw.trim();
                if (Utils.stringDefined(cell.cellName)) {
                    this.cellValues[cell.cellName] = raw;
                }
            }
            return true;
        },
        toggleAll: function(on) {
            this.cells.forEach(cell => {
                cell.showInput = on;
                cell.applyStyle();
            });
        },

    });
}




var iodide = {
    addOutputRenderer: function(renderer) {
        notebook.addOutputRenderer(renderer);
    },
    addOutputHandler: function(renderer) {
        notebook.addOutputHandler(renderer);
    },
    output: {
        text: function(t) {
            notebook.write(t);
        },
        element: function(tag) {
            var id = HtmlUtils.getUniqueId();
            notebook.write(HtmlUtils.tag(tag, [ATTR_ID, id]));
            return document.getElementById(id);
        }
    },
};

var notebook;


function NotebookState(cell, div) {
    this.id = HtmlUtils.getUniqueId();
    this.cell = cell;
    this.notebook = cell.notebook;
    $.extend(this, {
        entries: {},
        div: div,
        stopFlag: false,
        result: null,
        log: function(msg, type, from) {
            this.getNotebook().log(msg, type, from, this.div);
        },
        clearConsole: function() {
            this.getNotebook().clearConsole();
        },
        getStop: function() {
            return this.stopFlag;
        },
        getCell: function() {
            return this.cell;
        },
        addGlobal: async function(name,value) {
                await this.getNotebook().addGlobal(name,value);
        },

        globalChanged: async function(name,value) {
                await this.getNotebook().globalChanged(name,value);
        },
        setValue: function(name, value) {
            this.notebook.setCellValue(name, value);
        },
        makeData: async function(entry) {
            if (!entry)
                await this.getCurrentEntry(e => entry = e);
            if ((typeof entry) == "string") {
                await this.notebook.getEntry(entry, e => entry = e);
            }
            var jsonUrl = this.notebook.getPointUrl(entry);
            if (jsonUrl == null) {
                this.writeError("Not a point type:" + entry.getName());
                return null;
            }
            var pointDataProps = {
                entry: entry,
                entryId: entry.getId()
            };
            return new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
        },
        log: function(msg, type) {
            this.getNotebook().log(msg, type, "js");
        },
        getNotebook: function() {
            return this.notebook;
        },

        save: function(output) {
            this.notebook.saveNotebook(output);
            return "notebook saved";
        },

        clearEntries: function() {
            this.clearEntries();
        },

        ls: async function(entry) {
            var div = new Div();
            if (!entry)
                await this.getCurrentEntry(e => entry = e);
            this.call.getEntryHeading(entry, div);
            this.write(div.toString());
        },

        lsEntries: function() {
            var h = "";
            var entries = this.currentEntries;
            for (var name in entries) {
                var e = entries[name];
                h += name + "=" + e.entry.getName() + "<br>";
            }
            this.write(h);
        },

        stop: function() {
            this.stopFlag = true;
        },
        setGlobal: async function(name, value) {
                await this.cell.notebook.addGlobal(name, value);
        },
        setEntry: function(name, entryId) {
            this.cell.notebook.addEntry(name, entryId);
        },
        getEntry: async function(entryId, callback) {
            await this.cell.notebook.getEntry(e => entry = e);
            return Utils.call(callback, entry);
        },
        wiki: async function(s, entry, callback) {
            if (!callback) {
                var wdiv = new Div();
                this.div.append(wdiv.toString());
                callback = h => wdiv.append(h);
            }
            if (entry == null)
                await this.cell.getCurrentEntry(e => entry = e);
            if ((typeof entry) != "string") entry = entry.getId();
            await GuiUtils.loadHtml(ramaddaBaseUrl + "/wikify?doImports=false&entryid=" + entry + "&wikitext=" + encodeURIComponent(s),
                callback);
        },
        //These are for the iodiode mimic
        addOutputRenderer: function(renderer) {
            this.getNotebook().addOutputRenderer(renderer);
        },
        addOutputHandler: function(renderer) {
            this.getNotebook().addOutputRenderer(renderer);
        },
        output: {
            text: function(t) {
                notebook.write(t);
            },
            element: function(tag) {
                var id = HtmlUtils.getUniqueId();
                notebook.write(HtmlUtils.tag(tag, [ATTR_ID, id]));
                return document.getElementById(id);
            }
        },
        clearOutput: function() {
            this.cell.clearOutput();
        },
        clearAllOutput: function() {
            this.getNotebook().clearOutput();
        },
        write: function(value, clear) {
            if (!value) return;
            var s = this.getNotebook().formatOutput(value);
            if (s == null && (typeof value) == "object") {
                s = this.notebook.formatObject(value);
            }
            if (clear)
                this.div.set(s);
            else
                this.div.append(s);
        },
        linechart: async function(entry, props) {
            if (!entry)
                await this.cell.getCurrentEntry(e => entry = e);
            this.cell.createDisplay(this, entry, DISPLAY_LINECHART, props);
        },
    });
}


var notebookStates = {};

function RamaddaNotebookCell(notebook, id, content, props) {
    this.notebook = notebook;

    var ID_CELL = "cell";
    var ID_HEADER = "header";
    var ID_CELLNAME = "cellname";
    var ID_INPUT = "input";
    var ID_INPUT_TOOLBAR = "inputtoolbar";
    var ID_OUTPUT = "output";
    var ID_MESSAGE = "message";
    var ID_BUTTON_MENU = "menubutton";
    var ID_BUTTON_RUN = "runbutton";
    var ID_BUTTON_TOGGLE = "togglebutton";
    var ID_MENU = "menu";
    var ID_CELLNAME_INPUT = "cellnameinput";
    var ID_SHOWHEADER_INPUT = "showheader";
    var ID_SHOWEDIT = "showedit";
    var ID_RUN_ON_LOAD = "runonload";
    var ID_DISPLAY_MODE = "displaymode";
    var ID_LAYOUT_TYPE = "layouttype";
    var ID_SHOWCONSOLE = "showconsole";
    var ID_LAYOUT_COLUMNS = "layoutcolumns";
    var ID_RUNFIRST = "runfirst";
    var ID_SHOW_OUTPUT = "showoutput";
    var ID_RUN_ICON = "runningicon";

    let SUPER = new DisplayThing(id, {});
    RamaddaUtil.inherit(this, SUPER);

    RamaddaUtil.defineMembers(this, {
        id: id,
        inputRows: 1,
        index: 0,
        content: content,
        outputHtml: "",
        showInput: false,
        showHeader: false,
        cellName: "",
        runFirst: false,
        showOutput: true,
    });

    if (props) {
        $.extend(this, props);
    }
    RamaddaUtil.defineMembers(this, {
        getJson: function(output) {
            var obj = {
                id: this.id,
                inputRows: this.inputRows,
                content: this.getInputText(),
                showInput: this.showInput,
                showHeader: this.showHeader,
                runFirst: this.runFirst,
                showOutput: this.showOutput,
                cellName: this.cellName,
            };
            if (this.currentEntry)
                obj.currentEntryId = this.currentEntry.getId();
            if (output)
                obj.outputHtml = this.outputHtml;
            return obj;
        },
        createCell: function() {
            if (this.content == null) {
                this.content = "%% wiki";
            }
            this.editId = addHandler(this);
            addHandler(this, this.editId + "_entryid");
            addHandler(this, this.editId + "_wikilink");
            var _this = this;
            var buttons =
                this.makeButton(ID_BUTTON_MENU, icon_menu, "Show menu", "showmenu") +
                this.makeButton(ID_BUTTON_RUN, Utils.getIcon("run.png"), "Run this cell", "run") +
                this.makeButton(ID_BUTTON_RUN, Utils.getIcon("runall.png"), "Run all", "runall");

            var runIcon = HtmlUtils.image(icon_blank, ["align", "right", ATTR_ID, this.getDomId(ID_RUN_ICON), ATTR_STYLE, "padding-bottom:2px;padding-top:2px;padding-right:5px;"]);
            buttons = buttons + "&nbsp;" + HtmlUtils.span([ATTR_ID, this.getDomId(ID_CELLNAME)], this.cellName);
            buttons += runIcon;
            var header = HtmlUtils.div([ATTR_CLASS, "display-notebook-header", ATTR_ID, this.getDomId(ID_HEADER), "tabindex", "0", ATTR_TITLE, "Click to toggle input\nShift-click to clear output"], "&nbsp;" + buttons);

            //Strip out the meta chunks
            var content = "";
            var lines = this.content.split("\n");
            var inMeta = false;
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var _line = line.trim();
                if (_line.startsWith("%%")) {
                    if (_line.match(/^%% *meta/)) {
                        inMeta = true;
                    } else {
                        inMeta = false;
                    }
                }
                if (!inMeta) {
                    content += line + "\n";
                }
            }


            content = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            var input = HtmlUtils.div([ATTR_CLASS, "display-notebook-input ace_editor", ATTR_ID, this.getDomId(ID_INPUT), ATTR_TITLE, "shift-return: run chunk\nctrl-return: run to end"], content);
            var inputToolbar = HtmlUtils.div([ATTR_ID, this.getDomId(ID_INPUT_TOOLBAR)], "");

            input = HtmlUtils.div([ATTR_CLASS, "display-notebook-input-container"], inputToolbar + input);
            var output = HtmlUtils.div([ATTR_CLASS, "display-notebook-output", ATTR_ID, this.getDomId(ID_OUTPUT)], this.outputHtml);
            output = HtmlUtils.div([ATTR_CLASS, "display-notebook-output-container"], output);
            var menu = HtmlUtils.div([ATTR_ID, this.getDomId(ID_MENU), ATTR_CLASS, "ramadda-popup"], "");
            var html = header + input;
            html = HtmlUtils.div([ATTR_ID, this.getDomId(ID_CELL)], html);
            $("#" + this.id + "_cellinput").html(html);
            $("#" + this.id + "_celloutput").html(output);
            var url = ramaddaBaseUrl + "/wikitoolbar?doImports=false&entryid=" + this.entryId + "&handler=" + this.editId;
            url += "&extrahelp=" + ramaddaBaseUrl + "/userguide/notebook.html|Notebook Help";
            GuiUtils.loadHtml(url, h => {
                this.inputToolbar = h;
                this.jq(ID_INPUT_TOOLBAR).html(h);
                $("#" + this.editId + "_prefix").html(HtmlUtils.span([ATTR_ID, this.getDomId("toolbar_notebook"),
                    ATTR_STYLE, "border-right:1px #ccc solid;",
                    ATTR_CLASS, "ramadda-menubar-button"
                ], "Notebook"));
                this.jq("toolbar_notebook").click(() => this.showNotebookMenu());

            });
            this.header = this.jq(ID_HEADER);
            this.header.click((e) => {
                if (e.shiftKey)
                    this.processCommand("clear");
                else {
                    this.hidePopup();
                    this.processCommand("toggle");
                }

            });

            let wikiEditor = new WikiEditor("", "", this.getDomId(ID_INPUT), false, {
                maxLines: 30,
                minLines: 5
            });
	    this.editor = wikiEditor.getEditor();
            this.editor.getSession().on('change', () => {
                this.inputChanged();
            });
            this.menuButton = this.jq(ID_BUTTON_MENU);
            this.toggleButton = this.jq(ID_BUTTON_TOGGLE);
            this.cell = this.jq(ID_CELL);
            this.input = this.jq(ID_INPUT);
            this.output = this.jq(ID_OUTPUT);
            this.inputContainer = this.cell.find(".display-notebook-input-container");
            this.inputMenu = this.cell.find(".display-notebook-input-container");
            this.applyStyle();
            this.header.find(".display-notebook-menu-button").click(function(e) {
                _this.processCommand($(this).attr("what"));
                e.stopPropagation();
            });

            this.calculateInputHeight();
            this.input.focus(() => this.hidePopup());
            this.input.click(() => this.hidePopup());
            this.output.click(() => this.hidePopup());
            this.input.on('input selectionchange propertychange', () => this.calculateInputHeight());
            var moveFunc = (e) => {
                var key = e.key;
                if (key == 'v' && e.ctrlKey) {
                    this.notebook.moveCellDown(_this);
                    return;
                }
                if (key == 6 && e.ctrlKey) {
                    this.notebook.moveCellUp(_this);
                    return;
                }

            };
            this.input.keydown(moveFunc);
            this.header.keydown(moveFunc);
            this.input.keydown(function(e) {
                var key = e.key;
                if (key == 's' && e.ctrlKey) {
                    _this.notebook.saveNotebook(false);
                    return;
                }
                if (key == 'Enter') {
                    //                    console.log(key +"  shift:"  + e.shiftKey +" ctrl:" + e.ctrlKey);
                    if (e.shiftKey || e.ctrlKey) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (e.shiftKey && e.ctrlKey) {
                            //run all
                            _this.run(null);
                        } else {
                            //run current, run to end
                            _this.run(null, {
                                justCurrent: true,
                                toEnd: e.ctrlKey
                            });
                            if (!e.ctrlKey) {
                                _this.stepToNextChunk();
                            }
                        }
                    }
                }

            });
        },
        selectClick(type, id, entryId, value) {
            if (type == "entryid") {
                this.insertText(entryId);
            } else {
                this.insertText("[[" + entryId + "|" + value + "]]");
            }
            this.input.focus();
        },
        insertTags: function(tagOpen, tagClose, sampleText) {
            var id = this.getDomId(ID_INPUT);
            var textComp = GuiUtils.getDomObject(id);
            insertTagsInner(id, textComp.obj, tagOpen, tagClose, sampleText);
            this.calculateInputHeight();
        },
        insertText: function(value) {
            var id = this.getDomId(ID_INPUT);
            var textComp = GuiUtils.getDomObject(id);
            WikiUtil.insertAtCursor(id, textComp.obj, value);
            this.calculateInputHeight();
        },
        showNotebookMenu: function() {
            var link = this.jq("toolbar_notebook");
            this.makeMenu(link, "left bottom");
        },
        makeButton: function(id, icon, title, command) {
            if (!command) command = "noop";
            return HtmlUtils.div(["what", command, ATTR_TITLE, title, ATTR_CLASS, "display-notebook-menu-button", ATTR_ID, this.getDomId(id)], HtmlUtils.image(icon, []));
        },
        makeMenu: function(src, at) {
            if (!src) {
                src = this.input;
            }
            if (!src.is(":visible")) {
                src = this.header;
            }
            if (!src.is(":visible")) {
                src = this.output;
            }
            if (!at) at = "left top";
            let _this = this;
            let space = "&nbsp;&nbsp;";
            let menu = "";
	    let open = HU.open('div',[ATTR_CLASS,'display-notebook-menu-block']);
	    let close = '</div>';
            menu += HtmlUtils.input(ID_CELLNAME_INPUT, _this.cellName, ["placeholder", "Cell name", ATTR_STYLE, "width:100%;", ATTR_ID, _this.getDomId(ID_CELLNAME_INPUT)]);

            menu += open;
            menu += "<table  width=100%> ";
            menu += "<tr><td align=right><b>New cell:</b>&nbsp;</td><td>";
            menu += HtmlUtils.div([ATTR_CLASS, "ramadda-link", "what", "newabove"], "Above") + space;
            menu += HtmlUtils.div([ATTR_CLASS, "ramadda-link", "what", "newbelow"], "Below");
            menu += "</td></tr>"
            menu += "<tr><td align=right><b>Move:</b>&nbsp;</td><td>";
            menu += HtmlUtils.div([ATTR_TITLE, "ctrl-^", ATTR_CLASS, "ramadda-link", "what", "moveup"], "Up") + space;
            menu += HtmlUtils.div([ATTR_TITLE, "ctrl-v", ATTR_CLASS, "ramadda-link", "what", "movedown"], "Down");
            menu += "</td></tr>"
            menu += "</table>";

	    menu+=close;
	    menu+=open;
            menu += HtmlUtils.div([ATTR_TITLE, "ctrl-return", ATTR_CLASS, "ramadda-link", "what", "hideall"], "Hide all inputs");
            menu += "<br>"
            menu += HtmlUtils.div([ATTR_CLASS, "ramadda-link", "what", "clearall"], "Clear all outputs");
            menu += "<br>";
            var cols = this.notebook.columns;
            var colId = _this.getDomId(ID_LAYOUT_COLUMNS);
            menu += "<b>Layout:</b> ";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_LAYOUT_TYPE), [], _this.notebook.layout == "horizontal","Horizontal") + "<br>";
            //            menu += "Columns: ";
            //            menu += HtmlUtils.input(colId, this.notebook.columns, ["size", "3", ATTR_ID, _this.getDomId(ID_LAYOUT_COLUMNS)]);
	    menu+=close;
	    menu+=open;
            menu += HtmlUtils.checkbox(_this.getDomId(ID_SHOW_OUTPUT), [], _this.showOutput,"Output enabled") + "<br>";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_SHOWCONSOLE), [], _this.notebook.showConsole,"Show console") + "<br>";

            menu += HtmlUtils.checkbox(_this.getDomId(ID_RUNFIRST), [], _this.runFirst, "Run first") + "<br>";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_RUN_ON_LOAD), [], _this.notebook.runOnLoad,"Run on load") + "<br>";
            menu += HtmlUtils.div([ATTR_TITLE, "Don't show the left side and input for anonymous users"], HtmlUtils.checkbox(_this.getDomId(ID_DISPLAY_MODE), [], _this.notebook.displayMode) + " Display mode" + "<br>");

	    menu+=close;
	    menu+=open;
            menu += HtmlUtils.div([ATTR_CLASS, "ramadda-link", "what", "savewithout"], "Save notebook") + "<br>";
	    menu+=close;
	    menu+=open;
            menu += HtmlUtils.div([ATTR_CLASS, "ramadda-link", "what", "delete"], "Delete cell") + "<br>";
            menu += HtmlUtils.div([ATTR_CLASS, "ramadda-link", "what", "help"], "Help") + "<br>";
            menu = HtmlUtils.div([ATTR_CLASS, "display-notebook-menu"], menu);
	    menu+=close;
            var popup = this.getPopup();
            this.dialogShown = true;
            popup.html(HtmlUtils.div([ATTR_CLASS, "ramadda-popup-inner"], menu));
            popup.show();
            popup.position({
                of: src,
                my: "left top",
                at: at,
                collision: "fit fit"
            });
            _this.jq(ID_SHOWHEADER_INPUT).focus();

            _this.jq(ID_SHOWCONSOLE).change(function(e) {
                _this.notebook.showConsole = _this.jq(ID_SHOWCONSOLE).is(':checked');
                _this.hidePopup();
                _this.notebook.layoutCells();
            });


            _this.jq(ID_SHOWHEADER_INPUT).change(function(e) {
                _this.showHeader = _this.jq(ID_SHOWHEADER_INPUT).is(':checked');
                _this.applyStyle();
            });


            _this.jq(ID_RUNFIRST).change(function(e) {
                _this.runFirst = _this.jq(ID_RUNFIRST).is(':checked');
            });

            _this.jq(ID_SHOW_OUTPUT).change(function(e) {
                _this.showOutput = _this.jq(ID_SHOW_OUTPUT).is(':checked');
                _this.applyStyle();
            });
            _this.jq(ID_RUN_ON_LOAD).change(function(e) {
                _this.notebook.runOnLoad = _this.jq(ID_RUN_ON_LOAD).is(':checked');
            });
            _this.jq(ID_DISPLAY_MODE).change(function(e) {
                _this.notebook.displayMode = _this.jq(ID_DISPLAY_MODE).is(':checked');
            });
            _this.jq(ID_SHOWEDIT).change(function(e) {
                _this.showInput = _this.jq(ID_SHOWEDIT).is(':checked');
                _this.applyStyle();
            });

            _this.jq(ID_LAYOUT_TYPE).change(function(e) {
                if (_this.jq(ID_LAYOUT_TYPE).is(':checked')) {
                    _this.notebook.layout = "horizontal";
                } else {
                    _this.notebook.layout = "vertical";
                }
                _this.hidePopup();
                _this.notebook.layoutCells();
            });
            _this.jq(ID_LAYOUT_COLUMNS).keypress(function(e) {
                var keyCode = e.keyCode || e.which;
                if (keyCode != 13) {
                    return;
                }
                var cols = parseInt(_this.jq(ID_LAYOUT_COLUMNS).val());
                if (isNaN(cols)) {
                    _this.jq(ID_LAYOUT_COLUMNS).val("bad:" + _this.jq(ID_LAYOUT_COLUMNS).val());
                    return;
                }
                _this.hidePopup();
            });
            _this.jq(ID_CELLNAME_INPUT).keypress(function(e) {
                var keyCode = e.keyCode || e.which;
                if (keyCode == 13) {
                    _this.hidePopup();
                    return;
                }
            });
            popup.find(".ramadda-link").click(function() {
                var what = $(this).attr("what");
                _this.processCommand(what);
            });
        },
        hidePopup: function() {
            var popup = this.getPopup();
            if (popup && this.dialogShown) {
                var cols = parseInt(this.jq(ID_LAYOUT_COLUMNS).val());
                this.cellName = this.jq(ID_CELLNAME_INPUT).val();
                this.jq(ID_CELLNAME).html(this.cellName);
                popup.hide();
                this.applyStyle();

                if (!isNaN(cols) && this.notebook.columns != cols) {
                    this.notebook.columns = cols;
                    this.notebook.layoutCells();
                }
            }
            this.dialogShown = false;
        },
        processCommand: function(command) {
            if (command == "showmenu") {
                this.makeMenu();
                return;
            } else if (command == "toggle") {
                this.showInput = !this.showInput;
                this.applyStyle(true);
            } else if (command == "showthis") {
                this.showInput = true;
                this.applyStyle();
            } else if (command == "hidethis") {
                this.showInput = false;
                this.applyStyle();
            } else if (command == "showall") {
                this.notebook.toggleAll(true);
            } else if (command == "hideall") {
                this.notebook.toggleAll(false);
            } else if (command == "run") {
                this.notebook.runCell(this);
            } else if (command == "runall") {
                this.notebook.runAll();
            } else if (command == "clear") {
                this.clearOutput();
            } else if (command == "clearall") {
                this.notebook.clearOutput();
            } else if (command == "moveup") {
                this.notebook.moveCellUp(this);
            } else if (command == "movedown") {
                this.notebook.moveCellDown(this);
            } else if (command == "newabove") {
                this.notebook.newCellAbove(this);
            } else if (command == "newbelow") {
                this.notebook.newCellBelow(this);
            } else if (command == "savewith") {
                this.notebook.saveNotebook(true);
            } else if (command == "savewithout") {
                this.notebook.saveNotebook(false);
            } else if (command == "help") {
                var win = window.open(ramaddaBaseUrl + "/userguide/notebook.html", '_blank');
                win.focus();
            } else if (command == "delete") {
                this.askDelete();
                return;
            } else {
                console.log("unknown command:" + command);
            }
            this.hidePopup();
        },
        shouldShowInput: function() {
            return this.showInput && this.notebook.showInput();
        },
        applyStyle: function(fromUser) {
            if (this.shouldShowInput()) {
                this.jq(ID_INPUT_TOOLBAR).css("display", "block");
                this.inputContainer.show(400, () => this.editor.resize());
                this.showHeader = true;
            } else {
                this.jq(ID_INPUT_TOOLBAR).css("display", "none");
                this.inputContainer.hide(fromUser ? 200 : 0);
                this.showHeader = false;
            }
            this.showHeader = this.notebook.showInput();
            if (this.showHeader) {
                this.header.css("display", "block");
            } else {
                this.header.css("display", "none");
            }
            if (this.showOutput) {
                this.output.css("display", "block");
            } else {
                this.output.css("display", "none");
            }
        },
        getPopup: function() {
            return this.notebook.getPopup();
        },
        askDelete: function() {
            let _this = this;
            var menu = "";
            menu += "Are you sure you want to delete this cell?<br>";
            menu += HtmlUtils.span([ATTR_CLASS, "ramadda-link", "what", "yes"], "Yes");
            menu += HtmlUtils.span([ATTR_STYLE, "margin-left:50px;", ATTR_CLASS, "ramadda-link", "what", "cancel"], "No");
            var popup = this.getPopup();

            popup.html(HtmlUtils.div([ATTR_CLASS, "ramadda-popup-inner"], menu));
            popup.show();
            var src = this.input;
            if (!src.is(":visible")) {
                src = this.output;
            }
            if (!src.is(":visible")) {
                src = this.header;
            }
            popup.position({
                of: src,
                my: "left top",
                at: "left top",
                collision: "fit fit"
            });
            popup.find(".ramadda-link").click(function() {
                var what = $(this).attr("what");
                _this.hidePopup();
                if (what == "yes") {
                    _this.notebook.deleteCell(_this);
                }
            });
        },
        inputChanged: function() {
            var value = this.getInputText();
            var lines = value.split("\n");
            var cursor = this.editor.getCursorPosition();
            for (var i = cursor.row; i >= 0; i--) {
                var line = lines[i].trim();
                if (line.startsWith("%%")) {
                    var type = line.substring(2).trim();
                    if (type.startsWith("md") || type.startsWith("html") || type.startsWith("css") || type.startsWith("raw")) {
                        var doRows = {};
                        doRows[i] = true;
                        this.runInner(value, doRows);
                    }
                    break;
                }
            }
        },
        stepToNextChunk: function() {
            var value = this.getInputText();
            var lines = value.split("\n");
            var cursor = this.editor.getCursorPosition();
            for (var i = cursor.row + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith("%%")) {
                    var ll = lines[i].length;
                    this.editor.selection.moveTo(i, ll);
                    this.editor.scrollToLine(i, true, true, function() {});
                    break;
                }
            }

        },
        run: async function(callback, args) {
            if (!args) args = {};
            var justCurrent = args.justCurrent;
            var toEnd = args.toEnd;
            var doingAll = args.doingAll;
            if (this.running) return Utils.call(callback, true);
            this.running = true;
            var doRows = null;
            try {
                var ok = true;
                var value = this.getInputText();
                if (justCurrent) {
                    doRows = {};
                    var cursor = this.editor.getCursorPosition();
                    var row = cursor.row;
                    var lines = value.split("\n");
                    var percentCnt = 0;
                    if (toEnd) {
                        justCurrent = false;
                        while (row >= 0) {
                            if (lines[row].trim().startsWith("%%")) {
                                break;
                            }
                            row--;
                        }
                        if (row < 0) row = 0;
                        while (row < lines.length) {
                            doRows[row] = true;
                            row++;
                        }
                    } else {
                        //go to the next chunk
                        row++;
                        while (row < lines.length) {
                            if (lines[row].trim().startsWith("%%")) {
                                row--;
                                break;
                            }
                            row++;
                        }
                        if (row >= lines.length) row = lines.length - 1;
                        while (row >= 0) {
                            var line = lines[row].trim();
                            doRows[row] = true;
                            if (line.startsWith("%%")) break;
                            row--;
                        }
                    }
                }

                this.jq(ID_RUN_ICON).attr("src", icon_progress);
                await this.runInner(value, doRows, doingAll).then(r => ok = r);
                this.jq(ID_RUN_ICON).attr("src", icon_blank);
                if (!ok) {
                    this.running = false;
                    return Utils.call(callback, false);
                }
                this.outputUpdated();
            } catch (e) {
                this.jq(ID_RUN_ICON).attr("src", icon_blank);
                this.running = false;
                this.writeOutput("An error occurred:" + e.toString() + " " + (typeof e));
                console.log("error:" + e.toString());
                if (e.stack)
                    console.log(e.stack);
                return Utils.call(callback, false);
            }
            this.running = false;
            return Utils.call(callback, true);
        },
        prepareToLayout: function() {
            this.content = this.getInputText();
        },
        getInputText: function() {
            if (!this.editor) return this.content;
            return this.editor.getValue();
        },
        globalChanged: async function(name, value) {
            for(var i=0;i<this.chunks.length;i++) {
                var chunk = this.chunks[i];
                if(chunk.hasRun) continue;
                if(chunk.depends.includes(name)) {
                   var ok = true;
                   await this.runChunk(chunk,r=>ok=r);
                   if(!ok) break;
                }
            }
        },
        prepareToRun: function() {
            this.hasRun = false;
            if(this.chunks) {
                this.chunks.forEach(chunk=>chunk.hasRun = false);
            }
        },
        runInner: async function(value, doRows, doingAll) {
            value = value.trim();
            value = value.replace(/{cellname}/g, this.cellName);
            value = this.notebook.convertInput(value);
            if (!this.chunks) this.chunks = [];
            var chunks = this.chunks;
            var type = "wiki";
            var rest = "";
            var commands = value.split("\n");
            var prevChunk = null;
            var chunkCnt = 0;
            var _cell = this;
            var getChunk = (cell,type, content,  doChunk, rest) => {
                var props = Utils.parseAttributes(rest);
                props.type = type;
                props.doChunk = doChunk;
                props.content   = content;
                var chunk = (chunkCnt < chunks.length ? chunks[chunkCnt] : null);
                chunkCnt++;
                if (chunk) {
                    if (chunk.div.jq().length == 0) {
                        chunk = null;
                    } else {}
                } else {}
                if (!chunk) {
                    chunk = new NotebookChunk(cell, props);
                    chunks.push(chunk);
                    if(!chunk.skipOutput) {
                        if (prevChunk) prevChunk.div.jq().after(chunk.div.toString());
                        else cell.output.html(chunk.div.toString());
                    }
                } else {
                    chunk.initChunk(props);
                }
                prevChunk = chunk;
                chunk.div.jq().show();
                return chunk;
            };
            var content = "";
            var doChunk = true;
            for (var rowIdx = 0; rowIdx < commands.length; rowIdx++) {
                var command = commands[rowIdx];
                var _command = command.trim();
                if (_command.startsWith("//")) continue;
                if (_command.startsWith("%%")) {
                    var newRest = _command.substring(2).trim();
                    var newType;
                    var index = newRest.indexOf(" ");
                    if (index < 0) {
                        newType = newRest;
                        newRest = "";
                    } else {
                        newType = newRest.substring(0, index).trim();
                        newRest = newRest.substring(index);
                    }
                    if (content != "") {
                        getChunk(this, type, content, doChunk, rest);
                    }
                    doChunk = doRows ? doRows[rowIdx] : true;
                
                    content = "";
                    if (content != "") content += "\n";
                    if (newType != "")
                        type = newType;
                    rest = newRest;
                    continue;
                }
                content = content + command + "\n";
            }

            if (content != "") {
                getChunk(this,type, content, doChunk, rest);
            }

            this.chunkMap = {};
            for (var i = 0; i < this.chunks.length; i++) {
                var chunk = this.chunks[i];
                if (chunk.name) {
                    this.chunkMap[chunk.name] = chunk;
                }
            }
            for (var i = chunkCnt; i < this.chunks.length; i++) {
                this.chunks[i].div.jq().hide();
            }
            this.rawOutput = "";
            var ok = true;
            await this.runChunks(this.chunks, doingAll, true, r => ok = r);
            if (!ok) return false;
            await this.runChunks(this.chunks, doingAll, false, r => ok = r);
            if (!ok) return false;
            Utils.initContent("#" + this.getDomId(ID_OUTPUT));
            return true;
        },
        runChunks: async function(chunks, doingAll, justFirst, callback) {
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                var ok = true;
                if (justFirst === true && !chunk.props["runfirst"]) {
                    continue;
                }
                if (justFirst === false && chunk.props["runfirst"] === true) {
                    continue;
                }
                if (doingAll && chunk.props["skiprunall"] === true) {
                    continue;
                }
                if (!chunk.doChunk) {
                    continue;
                }
                await this.runChunk(chunk, (r => ok = r));
                if (!ok) return Utils.call(callback, false);
            }
            return Utils.call(callback, true);
        },
        runChunk: async function(chunk,   callback) {
            if (chunk.hasRun) {
                //                console.log("runChunk: chunk has run");
                return Utils.call(callback, true);
            }
            chunk.ok = true;
            chunk.div.set("");
            chunk.hasRun = true;
            for (var i = 0; i < chunk.depends.length; i++) {
                var name = chunk.depends[i];
                if (this.chunkMap[name] && !this.chunkMap[name].hasRun) {
                    var ok = true;
                    var otherChunk = this.chunkMap[name];
                    await this.runChunk(otherChunk, false, null, (r => ok = r));
                    if (!ok || !otherChunk.ok) {
                        return Utils.call(callback, false);
                    }
                }
            }
            await this.processChunk(chunk);
            if (!chunk.ok) {
                Utils.call(callback, false);
                return;
            }
            if (chunk.name && (typeof chunk.name == "string")) {
                var name = chunk.name.trim();
                if (chunk.output) {
                    if (name != "") {
                        await this.notebook.addGlobal(name, chunk.output);
                    }
                } else {
                    await this.notebook.addGlobal(name, null);
                }
            }
            return Utils.call(callback, true);
        },

        writeOutput: function(h) {
            if (!this.output) {
                err = new Error();
                console.log("no output:" + err.stack);
                return;
            }
            this.output.html(h);
            this.outputUpdated();
        },
        outputUpdated: function() {
            this.outputHtml = this.jq(ID_OUTPUT).html();
        },
        getRawOutput: function() {
            return this.rawOutput;
        },
        focus: function() {
            this.input.focus();
        },
        clearOutput: function() {
            if (this.chunks)
                this.chunks.forEach(chunk => chunk.div.set(""));
            this.outputHtml = "";
        },
        processHtml: async function(chunk) {
            var content = chunk.getContent();
            if (content.match("%\n*$")) {
                content = content.trim();
                content = content.substring(0, content.length - 1);
            }
            this.rawOutput += content + "\n";
            chunk.output = content;
            chunk.div.set(content);
        },
        processCss: async function(chunk) {
            var css = HtmlUtils.tag(ATTR_STYLE, ["type", "text/css"], chunk.getContent());
            this.rawOutput += css + "\n";
            chunk.output = css;
            chunk.div.set(css);
        },
        handleError: function(chunk, error, from) {
            chunk.ok = false;
            console.log("An error occurred:" + error);
            this.notebook.log(error, "error", from, chunk.div);
        },
        getFetchUrl: async function(url, type, callback) {
            //Check for entry id
            url = Utils.replaceRoot(url);

            if (url.match(/^[a-z0-9]+-[a-z0-9].*/)) {
                return Utils.call(callback, ramaddaBaseUrl + "/entry/get?entryid=" + url);
            } else {
                if (!url.startsWith("http")) {
                    if ((url.startsWith("/") && !url.startsWith(ramaddaBaseUrl)) || url.startsWith("..") || !url.startsWith("/")) {
                        var entry;
                        await this.getEntryFromPath(url, e => entry = e);
                        if (!entry) {
                            return Utils.call(callback, null);
                        }
                        return Utils.call(callback, ramaddaBaseUrl + "/entry/get?entryid=" + entry.getId());
                    }
                }
                return Utils.call(callback, url);
            }
        },
        processFetch: async function(chunk) {
            var lines = chunk.getContent().split("\n");
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line == "") continue;
                var origLine = line;
                var error = null;
                var msgExtra = "";
                var idx = line.indexOf(":");
                if (idx < 0) {
                    this.handleError(chunk, "Bad fetch line:" + line, "io");
                    return;
                }
                var tag = line.substring(0, idx);
                line = line.substring(idx + 1).trim();
                var idx = line.indexOf(" //");
                if (idx >= 0) {
                    line = line.substring(0, idx).trim();
                }


                var url = null;
                var variable = null;
                if (["text", "json", "blob"].includes(tag)) {
                    var args = line.match(/^([a-zA-Z0-9_]+) *= *(.*)$/);
                    if (args) {
                        variable = args[1];
                        line = args[2].trim();
                        msgExtra = " (var " + variable + ")";
                    }
                }

                await this.getFetchUrl(line, tag, u => url = u);
                if (!url) {
                    this.handleError(chunk, "Unable to get entry url:" + line, "io");
                    return;
                }

                if (tag == "js") {
                    //Don't import jquery
                    if (url.match("jquery-.*\\.js")) return;
                    await Utils.importJS(url,
                        () => {},
                        (jqxhr, settings, exception) => {
                            error = "Error fetching " + origLine + " " + (exception ? exception.toString() : "");
                        },
                        //Check the cache
                        false
                    );
                } else if (tag == "css") {
                    await Utils.importCSS(url,
                        null,
                        (jqxhr, settings, exception) => error = "Error fetching " + origLine + " " + exception, true);
                } else if (tag == "html") {
                    await Utils.doFetch(url, h => chunk.div.append(h), (jqxhr, settings, exception) => error = "Error fetching " + origLine + " " + exception);
                } else if (tag == "text" || tag == "json" || tag == "blob") {
                    var isJson = tag == "json";
                    var isBlob = tag == "blob";
                    var results = null;
                    await Utils.doFetch(url, h => results = h, (jqxhr, settings, err) => error = "Error fetching " + origLine + " error:" + (err ? err.toString() : ""), tag == "blob" ? "blob" : "text");
                    if (results) {
                        if (isJson) {
                            if (typeof results == "string")
                                results = JSON.parse(results);
                        } else if (isBlob) {
                            results = new Blob([results], {});
                        }
                        if (variable) {
                            await this.notebook.addGlobal(variable, results);
                        } else {
                            if (isJson) {
                                chunk.div.append(Utils.formatJson(results));
                            } else {
                                chunk.div.append(HtmlUtils.pre([ATTR_STYLE, "max-width:100%;overflow-x:auto;"], results));
                            }
                        }
                    }
                } else {
                    error = "Unknown fetch:" + origLine;
                }
                if (error) {
                    this.handleError(chunk, error, "io");
                    return;
                } else {
                    this.notebook.log("Loaded: " + url + msgExtra, "output", "io");
                }
            }
        },
        processMd: async function(chunk) {
            //            await Utils.importJS(ramaddaBaseUrl + "/lib/katex/lib/katex/katex.min.css");
            //            await Utils.importJS(ramaddaBaseUrl + "/lib/katex/lib/katex/katex.min.js");

            var content = chunk.getContent();
            this.rawOutput += content + "\n";
            if (content.match("%\n*$")) {
                content = content.trim();
                content = content.substring(0, content.length - 1);
            }
            var o = "";
            var tex = null;
            var lines = content.split("\n");
            var texs = [];
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var _line = line.trim();
                if (_line.startsWith("$$")) {
                    if (tex != null) {
                        try {
                            var html = katex.renderToString(tex, {
                                throwOnError: true
                            });
                            o += "tex:" + texs.length + ":\n";
                            texs.push(html);
                        } catch (e) {
                            o += "Error parsing tex:" + e + "<pre>" + tex + "</pre>";
                        }
                        tex = null;
                    } else {
                        tex = "";
                    }
                } else if (tex != null) {
                    tex += line + "\n";
                } else {
                    o += line + "\n";
                }
            }

            var converter = new showdown.Converter();
            var html = converter.makeHtml(o);
            for (var i = 0; i < texs.length; i++) {
                html = html.replace("tex:" + i + ":", texs[i]);
            }
            var md = HtmlUtils.div([ATTR_CLASS, "display-notebook-md"], html);
            chunk.output = html;
            chunk.div.set(md);
        },
        processPy: async function(chunk) {
            if (!this.notebook.loadedPyodide) {
                chunk.div.set("Loading Python...");
                await Utils.importJS(ramaddaBaseHtdocs + "/lib/pyodide/pyodide.js");
                await languagePluginLoader.then(() => {
                    pyodide.runPython('import sys\nsys.version;');
                    //                        pyodide.runPython('print ("hello python")');
                }, (e) => console.log("error:" + e));
                await pyodide.loadPackage(['numpy', 'cycler', 'pytz', 'matplotlib'])
                chunk.div.set("");
                this.notebook.loadedPyodide = true;
            }

            pyodide.runPython(chunk.getContent());
        },
        processPlugin: async function(chunk) {
            var plugin = JSON.parse(chunk.getContent());
            await this.notebook.addPlugin(plugin, chunk);
        },
        processWiki: async function(chunk) {
            this.rawOutput += chunk.getContent() + "\n";
            var id = this.notebook.getProperty("entryId", "");
            await this.getCurrentEntry(e => entry = e);
            if (entry) id = entry.getId();
            let _this = this;
            let divId = HtmlUtils.getUniqueId();
            var wikiCallback = function(html) {
                var h = HtmlUtils.div([ATTR_ID, divId, ATTR_STYLE], html);
                chunk.div.set(h);
                chunk.output = h;
            }
            var wiki = "{{group showMenu=false}}\n" + chunk.getContent();
            await GuiUtils.loadHtml(ramaddaBaseUrl + "/wikify?doImports=false&entryid=" + id + "&wikitext=" + encodeURIComponent(chunk.getContent()),
                wikiCallback);
        },
        processSh: async function(chunk) {
            var r = "";
            var lines = chunk.getContent().split("\n");
            var commands = [];
            for (var i = 0; i < lines.length; i++) {
                var fullLine = lines[i].trim();
                if (fullLine == "") continue;
                var cmds = fullLine.split(";");
                for (var cmdIdx = 0; cmdIdx < cmds.length; cmdIdx++) {
                    var line = cmds[cmdIdx].trim();
                    if (line == "" || line.startsWith("#") || line.startsWith("//")) continue;
                    var toks = line.split(" ");

                    var command = toks[0].trim();
                    var proc = null;
                    var extra = null;
                    if (this["processCommand_" + command]) {
                        proc = this["processCommand_" + command];
                    } else {
                        proc = this.processCommand_help;
                        extra = "Unknown command: <i>" + command + "</i>";
                    }
                    var div = new Div("");
                    commands.push({
                        proc: proc,
                        line: line,
                        toks: toks,
                        extra: extra,
                        div: div
                    });
                    r += div.set("");
                }
            }
            let _this = this;
            chunk.div.set(r);
            var i = 0;
            for (i = 0; i < commands.length; i++) {
                var cmd = commands[i];
                if (cmd.extra) {
                    cmd.div.append(extra);
                }
                await cmd.proc.call(_this, cmd.line, cmd.toks, cmd.div, cmd.extra);
            }
        },
        processJs: async function(chunk,state) {
            var lines;
            var topLines = 0;
            await this.getCurrentEntry(e => {
                    current = e
                });
            if(!notebookStates[state.id]) {
                throw new Error("Null NB:" + state.id);
            }
            try {
                var notebookEntries = this.notebook.getCurrentEntries();
                for (name in notebookEntries) {
                    state.entries[name] = notebookEntries[name].entry;
                }
                var jsSet = "";
                state.entries["current"] = current;
                state.entries["parent"] = this.parentEntry;
                state.entries["base"] = this.notebook.getBaseEntry();
                state.entries["root"] = this.notebook.getRootEntry();

                var stateJS = "notebookStates['" + state.id + "']";
                topLines++;
                jsSet += "var notebook= " + stateJS + ";\n";
                topLines++;
                for (name in state.entries) {
                    var e = state.entries[name];
                    topLines++;
                    jsSet += "var " + name + "= notebook.entries['" + name + "'];\n"
                }
                for (name in this.notebook.cellValues) {
                    var clean = name.replace(/ /g, "_").replace(/[^a-zA-Z0-9_]+/g, "_");
                    topLines++;
                    jsSet += "var " + clean + "= notebook.getNotebook().cellValues['" + name + "'];\n";
                }
                for (name in this.notebook.globals) {
                    name = name.trim();
                    if (name == "") continue;
                    //                    if (!Utils.isDefined(window[name])) {
                        topLines++;
                        jsSet += "var " + name + "= notebook.getNotebook().getGlobalValue('" + name + "');\n";
                        //                    }
                }
                var js = chunk.getContent().trim();
                lines = js.split("\n");
                js = jsSet + "\n" + js;
                var result = eval.call(null, js);
                if (state.getStop()) {
                    chunk.ok = false;
                }
                var html = "";
                if (result != null) {
                    chunk.output = result;
                    var rendered = this.notebook.formatOutput(result);
                    if (rendered != null) {
                        html = rendered;
                        this.rawOutput += html + "\n";
                    } else {
                        var type = typeof result;
                        if (type != "object" && type != "function") {
                            html = result;
                            this.rawOutput += html + "\n";
                        }
                    }
                }
                chunk.div.append(html);
            } catch (e) {
                chunk.ok = false;
                var line = lines[e.lineNumber - topLines - 1];
                console.log("Error:" + e.stack);
                this.notebook.log("Error: " + e.message + "<br>&gt;" + (line ? line : ""), "error", "js", chunk.div);
            }
        },
        processChunk: async function(chunk) {
            var state = new NotebookState(this, chunk.div);
            window.notebook = state;
            notebookStates[state.id] = state;
            if (chunk.type == "html") {
                await this.processHtml(chunk, state);
            } else if (chunk.type == "plugin") {
                await this.processPlugin(chunk,state);
            } else if (chunk.type == "wiki") {
                await this.processWiki(chunk,state);
            } else if (chunk.type == "css") {
                await this.processCss(chunk,state);
            } else if (chunk.type == "fetch") {
                await this.processFetch(chunk,state);
            } else if (chunk.type == "raw") {
                var content = chunk.getContent();
                chunk.output = content;
                this.rawOutput += content;
            } else if (chunk.type == "js") {
                await this.processJs(chunk,state);
            } else if (chunk.type == "sh") {
                await this.processSh(chunk,state);
            } else if (chunk.type == "meta") {
                //noop
            } else if (chunk.type == "md") {
                await this.processMd(chunk,state);
            } else if (chunk.type == "py") {
                await this.processPy(chunk,state);
            } else {
                var hasPlugin;
                await this.notebook.hasPlugin(chunk.type, p => hasPlugin = p);
                if (hasPlugin) {
                    chunk.div.set("");
                    var result;
                    await this.notebook.processChunkWithPlugin(chunk.type, chunk, r => result = r);
                    //TODO: what to do with the result
                    if (result) {
                        this.notebook.processPluginOutput(chunk.type, chunk, result);
                    }
                    return;
                }
                this.notebook.log("Unknown type:" + chunk.type, "error", null, chunk.div);
                chunk.ok = false;
            }
            delete  notebookStates[state.id];
            if (state.getStop()) {
                chunk.ok = false;
            }

        },



        calculateInputHeight: function() {
            this.content = this.getInputText();
            if (!this.content) return;
            var lines = this.content.split("\n");
            if (lines.length != this.inputRows) {
                this.inputRows = lines.length;
                this.input.attr("rows", Math.max(1, this.inputRows));
            }
        },

        writeStatusMessage: function(v) {
            var msg = this.jq(ID_MESSAGE);
            if (!v) {
                msg.hide();
                msg.html("");
            } else {
                msg.show();
                msg.position({
                    of: this.getOutput(),
                    my: "left top",
                    at: "left+4 top+4",
                    collision: "none none"
                });
                msg.html(v);
            }
        },
        handleControlKey: function(event) {
            var k = event.which;
        },
        getOutput: function() {
            return this.jq(ID_OUTPUT);
        },
        getInput: function() {
            return this.jq(ID_INPUT);
        },
        writeResult: function(html) {
            this.writeStatusMessage(null);
            html = HtmlUtils.div([ATTR_CLASS, "display-notebook-result"], html);
            var output = this.jq(ID_OUTPUT);
            output.append(html);
            output.animate({
                scrollTop: output.prop("scrollHeight")
            }, 1000);
            this.currentOutput = output.html();
            this.currentInput = this.getInputText();
        },
        writeError: function(msg) {
            this.writeStatusMessage(msg);
            //                this.writeResult(msg);
        },
        header: function(msg) {
            return HtmlUtils.div([ATTR_CLASS, "display-notebook-header"], msg);
        },
        processCommand_help: function(line, toks, div, callback, prefix) {
            if (div == null) div = new Div();
            var help = "";
            if (prefix != null) help += prefix;
            help += "<pre>pwd, ls, cd</pre>";
            return div.append(help);
        },
        entries: {},

        selectEntry: function(entryId) {
            var cnt = 1;
            var entries = this.notebook.getCurrentEntries();
            while (entries["entry" + cnt]) {
                cnt++;
            }
            var id = prompt("Set an ID", "entry" + cnt);
            if (id == null || id.trim() == "") return;
            this.notebook.addEntry(id, entryId);
        },
        setId: function(entryId) {
            var cursor = this.editor.getCursorPosition();
            this.editor.insert(entryId);
            //            this.editor.selection.moveTo(cursor.row, cursor.column);
            //            this.editor.focus();
        },
        cdEntry: function(entryId) {
            var div = new Div("");
            this.currentEntry = this.entries[entryId];
            notebookState.entries["current"] = this.currentEntry;
            this.output.html(div.toString());
            this.processCommand_pwd("pwd", [], div);
            this.outputUpdated();
        },
        addToToolbar: function(id, entry, toolbarItems) {
            var call = "getHandler('" + id + "').setId('" + entry.getId() + "')";
            var icon = HtmlUtils.image(ramaddaBaseUrl + "/icons/setid.png", ["border", 0, ATTR_TITLE, "Set ID in Input"]);
            toolbarItems.unshift(HtmlUtils.tag(TAG_A, ["onclick", call], icon));
            var call = "getHandler('" + id + "').selectEntry('" + entry.getId() + "')";
            var icon = HtmlUtils.image(ramaddaBaseUrl + "/icons/circle-check.png", ["border", 0, ATTR_TITLE, "Select Entry"]);
            toolbarItems.unshift(HtmlUtils.tag(TAG_A, ["onclick", call], icon));
        },
        getEntryPrefix: function(id, entry) {
            this.entries[entry.getId()] = entry;
            var call = "getHandler('" + id + "').cdEntry('" + entry.getId() + "')";
            return HtmlUtils.div([ATTR_STYLE, "padding-right:4px;", ATTR_TITLE, "cd to entry", "onclick", call, ATTR_CLASS, "ramadda-link"], HtmlUtils.image(ramaddaBaseUrl + "/icons/go.png"));
        },
        displayEntries: function(entries, div) {
            if (div == null) div = new Div();
            this.currentEntries = entries;
            if (entries == null || entries.length == 0) {
                return div.msg("No children");
            }
            var handlerId = addHandler(this);
            var html = this.notebook.getEntriesTree(entries, {
                handlerId: handlerId,
                showIndex: false,
                suffix: Utils.getUniqueId("_shell_")
            });
            div.set(HtmlUtils.div([ATTR_STYLE, "max-height:200px;overflow-y:auto;"], html));
            this.outputUpdated();
        },
        getEntryFromArgs: function(args, dflt) {
            var currentEntries = this.currentEntries;
            if (currentEntries == null) {
                return dflt;
            }
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (arg.match("^\d+$")) {
                    var index = parseInt(arg);
                    break;
                }
                if (arg == "-entry") {
                    i++;
                    var index = parseInt(args[i]) - 1;
                    if (index < 0 || index >= currentEntries) {
                        this.writeError("Bad entry index:" + index + " should be between 1 and " + currentEntries.length);
                        return;
                    }
                    return currentEntries[index];
                }
            }
            return dflt;
        },
        setCurrentEntry: async function(entry) {
            this.currentEntry = entry;
            this.parentEntry = null;
            if (this.currentEntry)
                await this.currentEntry.getParentEntry(entry => {
                    this.parentEntry = entry;
                });
        },
        getCurrentEntry: async function(callback) {
            if (this.currentEntry == null) {
                await this.setCurrentEntry(this.notebook.getBaseEntry());
            }
            if (this.currentEntry == null) {
                if (Utils.isDefined(dflt)) return dflt;
                this.rootEntry = new Entry({
                    id: ramaddaBaseEntry,
                    name: "Root",
                    type: "group"
                });
                this.currentEntry = this.rootEntry;
            }
            return Utils.call(callback, this.currentEntry);
        },
        createDisplay: async function(state, entry, displayType, displayProps) {
            if (!entry) await this.getCurrentEntry(e => entry = e);
            if ((typeof entry) == "string") {
                await this.notebook.getEntry(entry, e => entry = e);
            }

            if (!state.displayManager) {
                var divId = HtmlUtils.getUniqueId();
                state.div.append(HtmlUtils.div([ATTR_ID, divId], ""));
                state.displayManager = new DisplayManager(divId, {
                    "showMap": false,
                    "showMenu": false,
                    "showTitle": false,
                    "layoutType": "table",
                    "layoutColumns": 1,
                    "defaultMapLayer": "osm",
                    "entryId": ""
                });
            }

            var divId = HtmlUtils.getUniqueId();
            state.div.append(HtmlUtils.div([ATTR_ID, divId], "DIV"));
            var props = {
                layoutHere: true,
                divid: divId,
                showMenu: true,
                sourceEntry: entry,
                entryId: entry.getId(),
                showTitle: true,
                showDetails: true,
                title: entry.getName(),
            };

            if (displayProps) {
                $.extend(props, displayProps);
            }
            if (!props.data && displayType != DISPLAY_ENTRYLIST) {
                var jsonUrl = this.notebook.getPointUrl(entry);
                if (jsonUrl == null) {
                    this.writeError("Not a point type:" + entry.getName());
                    return;
                }
                if (jsonUrl == null) {
                    jsonUrl = this.getPointUrl(entry);
                }
                var pointDataProps = {
                    entry: entry,
                    entryId: entry.getId()
                };
                props.data = new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
            }
            state.displayManager.createDisplay(displayType, props);
        },
        createPointDisplay: async function(toks, displayType) {
            await this.getCurrentEntry(e => current = e);
            var entry = this.getEntryFromArgs(toks, currentEntry);
            var jsonUrl = this.notebook.getPointUrl(entry);
            if (jsonUrl == null) {
                this.writeError("Not a point type:" + entry.getName());
                return;
            }
            this.notebook.createDisplay(entry.getId(), displayType, jsonUrl);
        },
        processCommand_table: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_TABLE);
        },
        processCommand_linechart: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_LINECHART);
        },

        processCommand_barchart: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_BARCHART);
        },
        processCommand_bartable: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_BARTABLE);
        },
        processCommand_hello: function(line, toks) {
            this.writeResult("Hello, how are you?");
        },
        processCommand_scatterplot: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_SCATTERPLOT)
        },
        processCommand_blog: function(line, toks) {
            this.getLayoutManager().publish('blogentry');
        },
        getEntryHeading: function(entry, div) {
            var entries = [entry];
            var handlerId = addHandler(this);
            var html = this.notebook.getEntriesTree(entries, {
                handlerId: handlerId,
                showIndex: false,
                suffix: Utils.getUniqueId("_shell_")
            });
            div.set(HtmlUtils.div([ATTR_STYLE, "max-height:200px;overflow-y:auto;"], html));
            return div;
            //            var icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
            //            return "&gt; "+ icon +" " +entry.getName();
        },
        processCommand_pwd: async function(line, toks, div) {
            if (div == null) div = new Div();
            await this.getCurrentEntry(e => entry = e);
            return this.getEntryHeading(entry, div);
        },
        processCommand_set: async function(line, toks, div) {
            if (div == null) div = new Div();
            if (toks.length < 2) {
                div.append("Error: usage: set &lt;name&gt; &lt;value&gt;");
                return;
            }
            var name = toks[1];
            if (toks.length == 2) {
                var v = this.notebook.getGlobalValue(name);
                if (v) {
                    div.append(v);
                } else {
                    div.append("Unknown: " + name);
                }
            } else {
                var v = Utils.join(toks, " ", 2);
                v = v.replace(/\"/g, "");
                await this.notebook.addGlobal(name, v);
            }
        },
        processCommand_clearEntries: function(line, toks, div) {
            this.notebook.clearEntries();
            div.set("Entries cleared");
        },
        processCommand_printEntries: async function(line, toks, div) {
            var h = "";
            await this.getCurrentEntry(e => current = e);
            h += "current" + "=" + current.getName() + "<br>";
            var entries = this.notebook.getCurrentEntries();
            for (var name in entries) {
                var e = entries[name];
                h += name + "=" + e.entry.getName() + "<br>";
            }
            if (h == "") h = "No entries";
            div.set(h);
        },
        processCommand_echo: async function(line, toks, div) {
            line = line.replace(/^echo */, "");
            div.set(line);
        },
        processCommand_print: async function(line, toks, div) {
            line = line.replace(/^print */, "");
            div.set(line);
        },

        processCommand_info: async function(line, toks, div) {
            await this.getCurrentEntry(e => entry = e);
            div.append("current:" + entry.getName() + " id:" + entry.getId() + "<br>");
        },

        processCommand_cd: async function(line, toks, div) {
            if (div == null) div = new Div();
            if (toks.length <= 1) {
                await this.setCurrentEntry(this.notebook.getBaseEntry());
                return;
                //                return this.getEntryHeading(this.currentEntry, div);
            }
            var arg = Utils.join(toks, " ", 1).trim();
            var entry;
            await this.getEntryFromPath(arg, e => entry = e);
            if (!entry) {
                div.msg("Could not get entry:" + arg);
                return;
            }
            await this.setCurrentEntry(entry);
        },
        getEntryFromPath: async function(arg, callback) {
            var entry;
            await this.getCurrentEntry(e => entry = e);
            if (arg.startsWith("/")) {
                await entry.getRoot(e => {
                    entry = e
                });
            }
            var dirs = arg.split("/");
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                if (dir == "") continue;
                if (dir == "..") {
                    await entry.getParentEntry(e => {
                        entry = e
                    });
                    if (!entry) {
                        break;
                    }
                } else {
                    await entry.getChildrenEntries(c => children = c);
                    var child = null;
                    var startsWith = false;
                    var endsWith = false;
                    if (dir.endsWith("*")) {
                        dir = dir.substring(0, dir.length - 1);
                        startsWith = true;
                    }
                    if (dir.startsWith("*")) {
                        dir = dir.substring(1);
                        endsWith = true;
                    }
                    for (var childIdx = 0; childIdx < children.length; childIdx++) {
			let theChild = children[childIdx];
                        var name = theChild.getName();
                        if (startsWith && endsWith) {
                            if (name.includes(dir)) {
                                child = theChild;
                                break;
                            }
                        } else if (startsWith) {
                            if (name.startsWith(dir)) {
                                child = theChild;
                                break;
                            }
                        } else if (endsWith) {
                            if (name.endsWith(dir)) {
                                child = theChild;
                                break;
                            }
                        }
                        if (theChild.getName() == dir || theChild.getFilename()==dir) {
                            child = theChild;
                            break;
                        }
                    }
                    if (!child) {
                        break;
                    }
                    entry = child;
                }
            }
            return Utils.call(callback, entry);
        },


        processCommand_ls: async function(line, toks, div) {
            if (div == null) div = new Div();
            div.set("Listing entries...");
            await this.getCurrentEntry(e => entry = e);
            await entry.getChildrenEntries(children => {
                this.displayEntries(children, div)
            }, "");
        },
        entryListChanged: function(entryList) {
            var entries = entryList.getEntries();
            if (entries.length == 0) {
                this.writeStatusMessage("Sorry, nothing found");
            } else {
                this.displayEntries(entries);
            }
        },
        processCommand_search: async function(line, toks, div) {
            var text = "";
            for (var i = 1; i < toks.length; i++) text += toks[i] + " ";
            text = text.trim();
            var settings = new EntrySearchSettings({
                text: text,
            });
            var jsonUrl = this.notebook.getRamadda().getSearchUrl(settings, OUTPUT_JSON);
            let _this = this;
            var myCallback = {
                entryListChanged: function(list) {
                    var entries = list.getEntries();
                    div.set("");
                    if (entries.length == 0) {
                        div.append("Nothing found");
                    } else {
                        _this.displayEntries(entries, div)
                    }
                }
            };
            var entryList = new EntryList(this.notebook.getRamadda(), jsonUrl, myCallback, false);
            div.set("Searching...");
            await entryList.doSearch();
        },
        processCommand_clear: function(line, toks, div) {
            this.clearOutput();
        },
        processCommand_save: function(line, toks, div) {
            this.notebook.saveNotebook();
        },

    });

}


function processLispOutput(r) {
    if (r && r.val) return r.val;
    return Utils.formatJson(r);
}




function NotebookChunk(cell, props) {
    for(name in props)
        props[name.toLowerCase()] = props[name];
    this.div =  new Div(null, "display-notebook-chunk");
    this.cell = cell;
    $.extend(this, {
            getContent: function() {
                var content = this.content;
                for (name in this.cell.notebook.globals) {
                    var value = this.cell.notebook.getGlobalValue(name);
                    if (typeof value == "object") {
                        value = Utils.formatJson(value);
                    }
                    content = content.replace("${" + name.trim() + "}", value);
                }
                return content;
            },
           initChunk: function(props) {
                this.skipOutput = false;
                if (props["skipoutput"] === true) {
                    this.skipOutput = true;
                    this.div.set("");
                    this.div = new Div();
                }
                var depends = [];
                if (props["depends"] && typeof props["depends"] == "string") depends = props["depends"].split(",");
                var content = props.content||"";
                var regexp = RegExp(/\${([^ }]+)}/g);
                while((result = regexp.exec(content)) !== null) {
                    var param = result[1];
                    if(!depends.includes(param)) depends.push(param);
                }
                $.extend(this, {
                        name: props["name"],
                            depends: depends,
                            output: null,
                            runFirst: props["runFirst"],
                            hasRun: false,
                            content: content,
                            type: props.type,
                            props: props,
                            doChunk: !!props.doChunk,
                            ok: true
                            });
            }
        });
    this.initChunk(props);
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/



//Note: I put all of the chart definitions together at the top so one can see everything that is available here
const DISPLAY_D3_GLIDER_CROSS_SECTION = "GliderCrossSection";
//const DISPLAY_D3_PROFILE = "profile";
const DISPLAY_D3_LINECHART = "D3LineChart";
const DISPLAY_D3_PLOT = "d3plot";
const DISPLAY_SKEWT = "skewt";
const DISPLAY_VENN = "venn";
const DISPLAY_CHERNOFF = "chernoff";
const DISPLAY_D3BUBBLE = "d3bubble";
const DISPLAY_MINIDOTS = "minidots";

//Note: Added requiresData and category
addGlobalDisplayType({
    type: DISPLAY_D3_PLOT,
    forUser: true,
    label: "D3 Plot",
    requiresData: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("D3 Plot",null,'In development. Uses D3.Plot')        
});


addGlobalDisplayType({
    type: DISPLAY_D3_LINECHART,
    forUser: false,
    label: "D3 LineChart",
    requiresData: true,
    category: "Charts"
});
/*
  addGlobalDisplayType({
  type: DISPLAY_D3_PROFILE,
  forUser: false,
  label: "Profile",
  requiresData: true,
  category: "Charts"
  });
*/
addGlobalDisplayType({
    type: DISPLAY_D3_GLIDER_CROSS_SECTION,
    forUser: false,
    label: "Glider cross section",
    requiresData: true,
    category: CATEGORY_MISC
});


addGlobalDisplayType({
    type: DISPLAY_VENN,
    forUser: true,
    label: "Venn Diagram",
    requiresData: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("A Venn diagram","venn.png")    
});

addGlobalDisplayType({
    type: DISPLAY_MINIDOTS,
    forUser: false,
    label: "Mini Dots",
    requiresData: true,
    category: CATEGORY_MISC
});

addGlobalDisplayType({
    type: DISPLAY_CHERNOFF,
    forUser: false,
    label: "Chernoff Faces",
    requiresData: true,
    category: CATEGORY_MISC
});

addGlobalDisplayType({
    type: DISPLAY_D3BUBBLE,
    forUser: true,
    label: "Bubble Chart",
    requiresData: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Animated bubbles showing images","d3bubble.png"),            
});


addGlobalDisplayType({
    type: DISPLAY_SKEWT,
    forUser: false,
    label: "SkewT",
    requiresData: true,
    category: CATEGORY_MISC
});

//Note: define meaningful things as variables not as string literals
const FIELD_TIME = "time";
const FIELD_DEPTH = "depth";
const FIELD_VALUE = "value";
const FIELD_SELECTEDFIELD = "selectedfield";

const TYPE_LATITUDE = "latitude";
const TYPE_LONGITUDE = "longitude";
const TYPE_TIME = "time";
const TYPE_VALUE = "value";
const TYPE_ELEVATION = "elevation";


const FUNC_MOVINGAVERAGE = "movingAverage";

const D3Util = {
    initPlot:function(display,opts) {
	opts = opts??{};
	['caption',
	 ['plotWidth','width'],
	 ['plotHeight','height'],
	 'marginTop','marginRight','marginBottom','marginLeft','grid'].forEach(prop=>{
	     if(!Array.isArray(prop)) prop = [prop,prop];
	     if(!Utils.isDefined(opts[prop[1]])) {
		 opts[prop[1]] = display.getProperty(prop[0]);
	     }
	 });

	/*
	  opts.x = {x:{
	  round: true, nice: d3.utcYear,type:'band',ticks:10,
	  axis: display.getProperty('xAxisPosition','bottom')
	  }};
	*/
	/*
	  opts.x = {grid: display.getProperty('xAxisGrid',false),
	  ticks:10};
	*/


	return opts;
    },
    initMarks:function(display, marks) {
	if(display.getProperty('showFrame')) {
	    marks.push(Plot.frame());
	}
	//	marks.push(Plot.text(["Hello, world!"], {frameAnchor: "left"}));
	Utils.split(display.getProperty("rules",""),",").forEach(rule=>{
            marks.push(Plot.ruleY([parseFloat(rule)]));
	});

	marks.push(Plot.axisX({ticks: d3.utcYear.every(50), tickFormat: "%Y"}));
	//	marks.push(Plot.axisX({anchor: "top",tickSpacing:200,xticks:10}));
	//	marks.push(Plot.gridX({ticks:5, stroke: "#efefef", strokeOpacity: 0.5}));
    },

    createMarks:function(display, fields, records,args) {
	let marks = [];
	args = args??{};
	this.initMarks(display, marks);
	fields.forEach((field,idx)=>{
	    let opts = {};
	    $.extend(opts,args);
            marks.push(D3Util.createMark(display, field,records,idx,opts));
	}); 
	return marks;
    },
    getProperty(display, prefix,prop,dflt) {
	return  display.getProperty(prefix+'.'+prop,display.getProperty(prop))??dflt;
    },
    createMark:function(display, field,records,index,args) {
	args = args??args;
	if(!args.array) {
	    args.array=this.getD3Data(display,field,records,{includeDate:args.includeDate});
	}
	let opts = {x: "Date", y: field.getId()};
	let colors = args.colors?? display.getColorList();
	let fill = args.fill??this.getProperty(display,field.getId(),'fillColor');

	opts.strokeWidth =parseFloat(args.strokeWidth??this.getProperty(display,field.getId(),'strokeWidth',1));
	opts.stroke =  args.stroke??this.getProperty(display,field.getId(), 'strokeColor','#000');
	
	let mark;
	let markType  = display.getProperty(field.getId()+'.markType',display.getProperty('markType','line'));
	if(markType=='bar') {
	    opts.fill = fill;
	    mark= Plot.barY(args.array, opts);
	} else if(markType=='dot') {
	    opts.fill = fill;
	    opts.r = parseFloat(this.getProperty(display,field.getId(),'radius',4));
	    mark= Plot.dot(args.array, opts);	    
	} else if(markType=='line') {
	    mark= Plot.lineY(args.array, opts);
	} else {
	    console.error('Unknown mark type:' + markType);
	    mark= Plot.lineY(args.array, opts);
	}
	return mark;
    },	
    getD3Data:function(display,fields,records,args) {
	if(!Array.isArray(fields)) fields=[fields];
	args = args??{};
	let opts = {
	    includeDate:false
	}
	$.extend(opts,args);
	let d3Array = [];
	records.forEach((record,idx)=>{
	    let obj = {};
	    if(opts.includeDate)
		//		obj.Date = Utils.formatDateYYYYMMDD(record.getDate());
		obj.Date = record.getDate();
	    fields.forEach(field=>{
		obj[field.getId()] = field.getValue(record);  
	    });
	    d3Array.push(obj);
	});    
	return d3Array;
    },
    getAxis: function(axisType, range) {
        var axis;
        if (axisType == FIELD_TIME) {
            axis = d3.time.scale().range(range);
        } else {
            axis = d3.scale.linear().range(range);
        }
        return axis;
    },
    getDataValue: function(axis, record, index) {
        var data;
        if (axis.fieldIdx >= 0) {
            data = record.getData()[axis.fieldIdx];
        } else {
            switch (axis.type) {
            case TYPE_TIME:
                data = new Date(record.getDate());
                break;
            case TYPE_ELEVATION:
                //console.log(record.getElevation());
                data = record.getElevation();
                break;
            case TYPE_LATITUDE:
                data = record.getLatitude();
            case TYPE_LONGITUDE:
                data = record.getLongitude();
            default:
                data = record.getData()[index];
            }
        }


        if (axis.reverse == true) {
            return -1 * data;
        } else {
            return data;
        }
    },
    // This will be the default but we can add more colorscales
    getColorFromColorBar: function(value, range) {
        var colors = ["#00008B", "#0000CD", "#0000FF", "#00FFFF", "#7CFC00", "#FFFF00", "#FFA500", "#FF4500", "#FF0000", "#8B0000"];
        var colorScale = d3.scale.linear()
            .domain([0, colors.length - 1])
            .range(range);

        var colorScaler = d3.scale.linear()
            .range(colors)
            .domain(d3.range(0, colors.length).map(colorScale));

        color = colorScaler(value);
        return color;
    },
    // This is for the path lines the previous function for generic ones. 
    addColorBar: function(svg, colors, colorSpacing, displayWidth) {
        //Note: this originally had this.displayWidth which was undefined
        var colorBar = svg.append("g")
            .attr({
                ATTR_ID: "colorBarG",
                "transform": "translate(" + (displayWidth - 40) + ",0)"
            });

        colorBar.append("g")
            .append("defs")
            .append("linearGradient")
            .attr({
                id: "colorBarGradient",
                x1: "0%",
                y1: "100%",
                x2: "0%",
                y2: "0%"
            })
            .selectAll("stop")
            .data(colors)
            .enter()
            .append("stop")
            .attr({
                "offset": function(d, i) {
                    return colorSpacing * (i) + "%"
                },
                "stop-color": function(d, i) {
                    return colors[i]
                },
                "stop-opacity": 1
            });

        return colorBar;
    }
}


function RamaddaD3plotDisplay(displayManager, id, properties) {
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_D3_PLOT, properties);
    let myProps = [
        {label:'D3 Plot Attributes'},
        {p:'skewtWidth',ex:'500'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        updateUI: async function() {
	    if(!window.Plot) {
		if(this.awaiting) return;
		this.awaiting = true;
		await Utils.importJS('https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.9/dist/plot.umd.min.js')
		this.awaiting = false;
	    }
	    if(this.awaiting) {
		return;
	    }
            let records =  this.filterData();
	    if(!records) {
		return;
	    }
            let fields = this.getSelectedFields([]);
	    let data=D3Util.getD3Data(this,fields,records,{includeDate:true});
	    let marks = D3Util.createMarks(this,fields,records,{includeDate:true});    
	    let opts=D3Util.initPlot(this,{marks:marks});
/*
  color bar example
  https://observablehq.com/@observablehq/plot-warming-stripes
	    let opts2 = {
		x: {round: true},
		color: {scheme: "BuRd"},
		marks: [
		    Plot.lineY(data, {
			x: "Date",
			y: "gcag",
//			interval: "year", // yearly data
//			inset: 0 // no gaps
		    })
		]
		}
		*/
	    let plot = Plot.plot(opts);
	    this.getContents().html(plot);
	}
    });
}


function RamaddaSkewtDisplay(displayManager, id, properties) {
    const ID_SKEWT = "skewt";
    const ID_DATE_LABEL = "skewtdate";
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_SKEWT, properties);
    let myProps = [
        {label:'Skewt Attributes'},
        {p:'skewtWidth',ex:'500'},
        {p:'skewtHeight',ex:'550'},
        {p:'hodographWidth',ex:'150'},
        {p:'showHodograph',ex:'false'},
        {p:'windStride',ex:'1'},
        {p:'showText',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        initDisplay:  function() {
            SUPER.initDisplay.call(this);
        },
        handleEventPointDataLoaded: function(source, pointData) {
            //TODO: this results in a double  call to updateUI when first created
            this.updateUI();
        },
        handleEventRecordSelection: function(source, args) {
	    this.skewt.highlightRecord(args.record);
	},
        updateUI: async function() {
            if(!this.loadedResources) {
		if(this.loadingSkewt) return;
		this.loadingSkewt=true;
                await Utils.importCSS(RamaddaUtil.getCdnUrl("/lib/skewt/sounding.css"));
                await Utils.importJS(RamaddaUtil.getCdnUrl("/lib/skewt/d3skewt.js"));
                this.loadedResources = true;
            }

            if(!window["D3Skewt"]) {
                setTimeout(()=>this.updateUI(),100);
                return;
            }
            SUPER.updateUI.call(this);

	    if(!d3.scaleLinear) {
                this.setDisplayMessage("Oops, the wrong version of D3 had been loaded");
		return;
	    }

	    //          console.log("skewt.updateui-1");
            let records =  this.filterData();
            if (!records || records.length==0) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    //          console.log("skewt.updateui-2");
            let skewtId = this.getDomId(ID_SKEWT);
	    let html = '';
            html += HU.div([ATTR_TITLE,'Download skew-t data',ATTR_ID,this.domId('download'),ATTR_CLASS,'ramadda-clickable',ATTR_STYLE,'text-align:right;margin-right:20px;'],HU.getIconImage('fas fa-download'));
	    html += HU.div([ATTR_ID, skewtId], "");
            this.setContents(html);
	    this.jq('download').click(()=>{
		if(!this.dataObject) {
		    alert('No data available');
		    return;
		}		    
		let keys = Object.keys(this.dataObject);
		keys = Utils.removeItem(keys,'records');
		let data = '';
		keys.forEach((key,idx)=>{
		    if(idx>0) data+=',';
		    data+=key
		})
		data+='\n';
		let cnt = this.dataObject[keys[0]].length;
		for(let i=0;i<cnt;i++) {
		    keys.forEach((key,idx)=>{
			if(idx>0) data+=',';
			let v = parseFloat(this.dataObject[key][i]);
			v = Utils.trimDecimals(v,4);
			data+=v;
		    });
		    data+='\n';
		}
		Utils.makeDownloadFile(this.getProperty(ATTR_TITLE,'skewt').replace(/ /g,'_')+'.csv',data);

	    });
            let date = records[0].getDate();
            if(this.jq(ID_DATE_LABEL).length==0) {
                this.jq(ID_TOP_LEFT).append(HtmlUtils.div([ID,this.getDomId(ID_DATE_LABEL)]));
            }
            if(date!=null) {
                this.jq(ID_DATE_LABEL).html("Date: " + this.formatDate(date));
            } else {
                this.jq(ID_DATE_LABEL).html("");
            }
            let options = {};
            if (this.propertyDefined("showHodograph"))
                options.showHodograph = this.getProperty("showHodograph", true);
            if (this.propertyDefined("showText"))
                options.showText = this.getProperty("showText", true);

            if (this.propertyDefined("skewtWidth"))
                options.skewtWidth = parseInt(this.getProperty("skewtWidth"));
            if (this.propertyDefined("skewtHeight"))
                options.skewtHeight = parseInt(this.getProperty("skewtHeight"));
            if (this.propertyDefined("hodographWidth")){
                options.hodographWidth = parseInt(this.getProperty("hodographWidth"));
            }
            if (this.propertyDefined("windStride")){
                options.windStride = parseInt(this.getProperty("windStride"));
            }
            options.showText = this.getProperty("showText",true);
            //            options.hodographWidth = 200;
            let fields = this.getData().getRecordFields();
            let names = [
                {id:'pressure',aliases:['vertCoord','pressure_mb']},
                {id:'height',aliases:['Geopotential_height_isobaric']},
                {id:'temperature',aliases:['Temperature_isobaric','temperature_c']},
                {id:'dewpoint',aliases:[]},
                {id:'rh',aliases:['Relative_humidity_isobaric','relative_humidity']},
                {id:'wind_direction',aliases:['wind_direction_true_deg']},
                {id:'wind_speed',aliases:['wind_speed_m_s']},
                {id:'uwind',aliases:['u-component_of_wind_isobaric','u']},
                {id:'vwind',aliases:['v-component_of_wind_isobaric','v']},
            ];
            //TODO: check for units
            let data ={};
            let dataFields ={};
            for(let i=0;i<names.length;i++) {
                let obj = names[i];
                let id = obj.id;
                let field = this.getFieldById(fields,id,false,true);
                if(field == null) {
                    for(let j=0;j<obj.aliases.length;j++) {
                        field = this.getFieldById(fields,obj.aliases[j],false,true);
                        if(field) break;
                    }
                }
                if(field) {
                    data[id] = this.getColumnValues(records, field).values;
                    dataFields[id]=field;
                }
            }

	    let getFieldIds = () =>{
		return fields.reduce((acc,field)=>{
		    return acc+field.getId()+"<br>";
		},"<br>Fields:<br>");
	    }
	    

            if(!data.pressure) {
                this.displayError("No pressure defined in data." + getFieldIds());
                return;
            }

            if(!data.temperature) {
                this.displayError("No temperature defined in data." + getFieldIds());
                return;
            }

	    data.records = records;
            if(!data.height) {
                let pressures = [
                    1013.25, 954.61, 898.76, 845.59, 795.01, 746.91, 701.21,
                    657.80, 616.6, 577.52, 540.48, 505.39, 472.17, 440.75,
                    411.05, 382.99, 356.51, 331.54, 303.00, 285.85, 264.99,
                    226.99, 193.99, 165.79, 141.70, 121.11, 103.52, 88.497,
                    75.652, 64.674, 55.293, 25.492, 11.970, 5.746, 2.871,
                    1.491, 0.798, 0.220, 0.052, 0.010,];
                let alts = [
                    0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000,
                    5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000,
                    11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000,
                    20000, 25000, 30000, 35000, 40000, 45000, 50000, 60000, 70000,
                    80000,
                ];
                
                data.height = [];
                for(let i=0;i<data.pressure.length;i++) {
                    let pressure = data.pressure[i];
                    let alt = alts[alts.length-1];
                    for(let j=0;j<pressures.length;j++) {
                        if(pressure>=pressures[j]) {
                            if(j==0) alt = 0;
                            else {
                                let p1 = pressures[j-1];
                                let p2 = pressures[j];
                                let a1 = alts[j-1];
                                let a2 = alts[j];
                                let percent = 1-(pressure-p2)/(p1-p2);
                                alt = (a2-a1)*percent+a1;
                            }
                            break;
                        }
                    }
                    data.height.push(alt);
                }
            }


            if(!data.dewpoint) {
                if(!data.rh) {
                    this.displayError("No dewpoint or rh." + getFieldIds());
                    return;
                }
                data.dewpoint = [];
                for(let i=0;i<data.rh.length;i++) {
                    let rh=data.rh[i];
                    let t=data.temperature[i];
                    let dp = t-(100-rh)/5;
                    data.dewpoint.push(dp);
                }
            }

            if(!data.wind_speed) {
		if(!data.uwind || !data.vwind) {
                    this.displayError("No wind speed defined in data."  + getFieldIds());
                    return;
                }
                data.wind_speed = [];
                data.wind_direction = [];
                for(let i=0;i<data.uwind.length;i++) {
                    let u = data.uwind[i];
                    let v = data.vwind[i];
                    let ws = Math.sqrt(u*u+v*v);
                    let wdir = 180+(180/Math.PI)*Math.atan2(v,u);
                    data.wind_speed.push(ws);
                    data.wind_direction.push(wdir);
                }
            }

            let alldata = data;
            data = {};
            //if any missing then don't include
            for(a  in alldata) data[a] = [];
            alldata[names[0].id].map((v,idx)=>{
                let ok = true;
                for(id in alldata) {
                    if(isNaN(alldata[id][idx])) {
                        ok = false;
                        break;
                    }
                }
                if(ok || id=='records') {
                    for(id in alldata) {
                        data[id].push(alldata[id][idx]);
                    }
                }
            });

            if(data.height.length>1) {
                if(data.height[0]>data.height[1]) {
                    for(name in data)
                        data[name] = Utils.reverseArray(data[name]);
                }
            }
            if(data.temperature.length==0) {
                this.displayError(this.getNoDataMessage());
                return;
            }
	    this.dataObject = data;

            options.myid = this.getId();
	    options.mouseDownListener = (record)=>{
		if(record) {
		    this.propagateEventRecordSelection({highlight:true,record: record});
		}
	    }
            try {
                this.skewt = new D3Skewt(skewtId, options,data);
            } catch(e) {
                this.displayError("An error occurred: " +e);
                console.log("error:" + e.stack);
                return;
            }
            await this.getDisplayEntry((e)=>{
		if(!e) return;
                let q= e.getAttribute("variables");
                if(!q) return;
                q = q.value;
                q = q.replace(/\r\n/g,"\n");
                q = q.replace(/^ *\n/,"");
                q = q.replace(/^ *([^:]+):([^\n].*)$/gm,"<div title='$1' class=display-skewt-index-label>$1</div>: <div title='$2'  class=display-skewt-index>$2</div>");
                q = q.replace(/[[\r\n]/g,"\n");
                q = HtmlUtils.div([ATTR_CLASS, "display-skewt-text"],q);
                $("#" + this.skewt.textBoxId).html(q);
            });
        }
    });
}


function RamaddaD3Display(displayManager, id, properties) {
    const ID_SVG = "svg";
    const SUPER = new RamaddaDisplay(displayManager, id, "d3", properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        initDisplay: function() {
            this.createUI();
            this.setDisplayTitle(properties.graph.title);

            //Note: use innerHeight/innerWidth wiki attributes
            let width = this.getProperty("innerWidth", 600);
            let height = this.getProperty("innerHeight", 300);
            let margin = {
                top: 20,
                right: 50,
                bottom: 30,
                left: 50
            };
            let divStyle =
                "height:" + height + "px;" +
                "width:" + width + "px;";
            let html = HtmlUtils.div([ATTR_ID, this.getDomId(ID_SVG), ATTR_STYLE, divStyle], "");
            this.setContents(html);

            // To create dynamic size of the div
            this.displayHeight = parseInt((d3.select("#" + this.getDomId(ID_SVG)).style("height")).split("px")[0]) - margin.top - margin.bottom; //this.getProperty("height",300);//d3.select("#"+this.getDomId(ID_SVG)).style("height");//
            this.displayWidth = parseInt((d3.select("#" + this.getDomId(ID_SVG)).style("width")).split("px")[0]) - margin.left - margin.right; //this.getProperty("width",600);//d3.select("#"+this.getDomId(ID_SVG)).style("width");//

            //                console.log("WxH:" + this.displayHeight +" " + this.displayWidth);

            // To solve the problem with the classess within the class
            let myThis = this;
            let zoom = d3.behavior.zoom()
                .on("zoom", function() {
                    myThis.zoomBehaviour()
                });
            this.zoom = zoom;
            this.svg = d3.select("#" + this.getDomId(ID_SVG)).append("svg")
                .attr("width", this.displayWidth + margin.left + margin.right)
                .attr("height", this.displayHeight + margin.top + margin.bottom)
                .attr(ATTR_CLASS, "D3graph")
                .call(zoom)
                .on("click", function(event) {
                    myThis.click(event)
                })
                .on("dblclick", function(event) {
                    myThis.dbclick(event)
                })
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Define the Axis
            // 100 pixels for the legend... lets see if we keep it
            this.x = D3Util.getAxis(properties.graph.axis.x.type, [0, this.displayWidth - 100]);
            this.y = D3Util.getAxis(properties.graph.axis.y.type, [this.displayHeight, 0]);

            this.xAxis = d3.svg.axis()
                .scale(this.x)
                .orient("bottom");

            this.yAxis = d3.svg.axis()
                .scale(this.y)
                .orient("left");

            // Add Axis to the plot
            this.svg.append("g")
                .attr(ATTR_CLASS, "x axis")
                .attr("transform", "translate(0," + this.displayHeight + ")")
                .call(this.xAxis);

            this.svg.append("g")
                .attr(ATTR_CLASS, "y axis")
                .call(this.yAxis);


            // Color Bar
            let colors = ["#00008B", "#0000CD", "#0000FF", "#00FFFF", "#7CFC00", "#FFFF00", "#FFA500", "#FF4500", "#FF0000", "#8B0000"];

            let colorSpacing = 100 / (colors.length - 1);

            let colorBar = D3Util.addColorBar(this.svg, colors, colorSpacing, this.displayWidth);
            this.color = d3.scale.category10();
            this.updateUI();
        },
        needsData: function() {
            return true;
        },
        initDialog: function() {
            this.addFieldsCheckboxes();
        },
        getDialogContents: function() {
            let height = this.getProperty(PROP_HEIGHT, "400");
            let html = HtmlUtils.div([ATTR_ID, this.getDomId(ID_FIELDS), ATTR_CLASS, "display-fields", ]);
            html += SUPER.getDialogContents.apply(this);
            return html;
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        // onlyZoom is not updating the axis
        updateUI: function() {
            //Note: Not sure why onlyZoom was a function param. The pointData gets passes in 
            //when the json is loaded
            //            updateUI: function(onlyZoom) {
            let onlyZoom = false;

            //Note: if we write to the SVG dom element then we lose the svg object that got created in initDisplay
            //Not sure how to show a message to the user
            if (!this.hasData()) {
                return;
            }
            test = this;
            let selectedFields = this.getSelectedFields();
            if (selectedFields.length == 0) {
                //this.writeHtml(ID_SVG, "No fields selected");
                return;
            }
            this.addFieldsCheckboxes();
            pointData = this.getData();
            if (pointData == null) {
                //this.writeHtml(ID_SVG, "No data");
                console.log("no data");
                return;
            }

            let fields = pointData.getNumericFields();
            let records = pointData.getRecords();
            let ranges = RecordUtil.getRanges(fields, records);
            let elevationRange = RecordUtil.getElevationRange(fields, records);
            let offset = (elevationRange[1] - elevationRange[0]) * 0.05;
            // To be used inside a function we can use this.x inside them so we extract as variables. 
            let x = this.x;
            let y = this.y;
            let color = this.color;
            let axis = properties.graph.axis;

            if (onlyZoom) {
                this.zoom.x(this.x);
                this.zoom.y(this.y);
            } else {
                // Update axis for the zoom and other changes
                this.x.domain(d3.extent(records, function(d) {
                    return D3Util.getDataValue(axis.x, d, selectedFields[0].getIndex());
                }));
                // the y domain depends on the first selected element I have to think about it.
                this.y.domain(d3.extent(records, function(d) {
                    return D3Util.getDataValue(axis.y, d, selectedFields[0].getIndex());
                }));

                this.zoom.x(this.x);
                this.zoom.y(this.y);
            }

            this.svg.selectAll(".y.axis").call(this.yAxis);
            this.svg.selectAll(".x.axis").call(this.xAxis);

            // Remove previous lines
            this.svg.selectAll(".line").remove();
            this.svg.selectAll(".legendElement").remove();

            let myThis = this;
            for (let fieldIdx = 0; fieldIdx < selectedFields.length; fieldIdx++) {
                let dataIndex = selectedFields[fieldIdx].getIndex();
                let range = ranges[dataIndex];
                // Plot line for the values
                let line = d3.svg.line()
                    .x(function(d) {
                        return x(D3Util.getDataValue(axis.x, d, selectedFields[fieldIdx].getIndex()));
                    })
                    .y(function(d) {
                        return y(D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex()));
                    });

                displayLine = this.svg.append("path")
                    .datum(records)
                    .attr(ATTR_CLASS, "line")
                    .attr("d", line)
                    .on("mousemove", function(event) {
                        myThis.mouseover(event)
                    })
                    .attr("fill", "none")
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("stroke-width", "0.5px");

                if (properties.graph.axis.z == FIELD_SELECTEDFIELD) {
                    displayLine.attr("stroke", "url(#colorBarGradient)");
                }

                if (properties.graph.derived != null) {
                    let funcs = properties.graph.derived.split(",");
                    for (funcIdx = 0; funcIdx < funcs.length; funcIdx++) {
                        let func = funcs[funcIdx];
                        if (func == FUNC_MOVINGAVERAGE) {
                            // Plot moving average Line
                            let movingAverageLine = d3.svg.line()
                                .x(function(d) {
                                    return x(D3Util.getDataValue(axis.x, d, selectedFields[fieldIdx].getIndex()));
                                })
                                .y(function(d, i) {
                                    if (i == 0) {
                                        return _movingSum = D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex());
                                    } else {
                                        _movingSum += D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex());
                                    }
                                    return y(_movingSum / i);
                                })
                                .interpolate("basis");
                            this.svg.append("path")
                                .attr(ATTR_CLASS, "line")
                                .attr("d", movingAverageLine(records))
                                .attr("fill", "none")
                                .attr("stroke", function(d) {
                                    return color(fieldIdx);
                                })
                                .attr("stroke-width", "1.5px")
                                .attr("viewBox", "50 50 100 100 ")
                                .style("stroke-dasharray", ("3, 3"));
                        } else {
                            console.log("Error: Unknown derived function:" + func);
                        }

                    }
                }

                // Legend element Maybe create a function or see how we implement the legend
                this.svg.append("svg:rect")
                    .attr(ATTR_CLASS, "legendElement")
                    .attr("x", this.displayWidth - 100)
                    .attr("y", (50 + 50 * fieldIdx))
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("height", 2)
                    .attr("width", 40);

                this.svg.append("svg:text")
                    .attr(ATTR_CLASS, "legendElement")
                    .attr("x", this.displayWidth - 100 + 40 + 10) // position+color rect+padding
                    .attr("y", (55 + 55 * fieldIdx))
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr(ATTR_STYLE, "font-size:50%")
                    .text(selectedFields[fieldIdx].getLabel());
            }
        },

        zoomBehaviour: function() {
            // Call redraw with only zoom don't update extent of the data.
            this.updateUI(true);
        },
        //this gets called when an event source has selected a record
        handleEventRecordSelection: function(source, args) {},
        mouseover: function(event) {
            // TO DO
            console.log("mouseover");
        },
        click: function(event) {
            // TO DO
            console.log("click:" + event);
        },
        dbclick: function(event) {
            // Unzoom
            this.zoom();
            this.updateUI();
        },
        getSVG: function() {
            return this.svg;
        }
    });
}


function RamaddaD3LineChartDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Line chart",
        //Note: changed this to "derived" from "extraLine".
        //This is a comma separated list of functions (for now just one)
        derived: FUNC_MOVINGAVERAGE,
        axis: {
            y: {
                type: TYPE_VALUE,
                fieldname: FIELD_SELECTEDFIELD
            },
            x: {
                type: TYPE_TIME,
                fieldname: FIELD_TIME,
            }
        }
    };

    properties = $.extend(dfltProperties, properties);
    return new RamaddaD3Display(displayManager, id, properties);
}


/*
  function RamaddaProfileDisplay(displayManager, id, properties) {
  var dfltProperties = {};
  //Note: use json structures to define the props
  dfltProperties.graph = {
  title: "Profile chart",
  derived: null,
  axis: {
  y: {
  type: TYPE_ELEVATION,
  fieldname: FIELD_DEPTH,
  fieldIdx: 3,
  reverse: true
  },
  x: {
  type: TYPE_VALUE,
  fieldname: FIELD_VALUE,
  },
  }
  };
  //Note: now set the properties
  properties = $.extend(dfltProperties, properties);
  return new RamaddaD3Display(displayManager, id, properties);
  }
*/



function RamaddaGliderCrossSectionDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Glider cross section",
        derived: null,
        axis: {
            y: {
                type: TYPE_ELEVATION,
                fieldname: FIELD_DEPTH,
                reverse: true
            },
            x: {
                type: TYPE_TIME,
                fieldname: FIELD_TIME,
            },
            z: FIELD_SELECTEDFIELD,
        }
    };
    properties = $.extend(dfltProperties, properties);

    return new RamaddaD3Display(displayManager, id, properties);
}






var loadedVenn = false;
function RamaddaVennDisplay(displayManager, id, properties) {
    const ID_VENN = "venn";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_VENN, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
	    if(!loadedVenn) {
		loadedVenn = true;
		var includes = "<script src='" + RamaddaUtil.getCdnUrl("/lib/venn.js")+"'></script>";
		this.writeHtml(ID_DISPLAY_TOP, includes);
	    }
	    let _this = this;
	    var func = function() {
		if(!window["venn"]) {
		    setTimeout(func, 1000);
		} else {
                    _this.updateUIInner();
		}
            };
	    func();
        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return;
            }
            /*
              var sets = [{sets : [0], label : 'SE', size : 28,}, 
              {sets : [1], label : 'Treat', size: 35},
              {sets : [2], label : 'Anti-CCP', size : 108}, 
              {sets : [3], label : 'DAS28', size:106},
              {sets : [0,1], size:1},
              {sets : [0,2], size:1},
              {sets : [0,3], size:14},
            */
            var setInfos = {};
            var setCnt = 0;
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var row = this.getDataValues(records[rowIdx]);
                var keys = [];
                var key = "";
                for (var fieldIdx = 0; fieldIdx < strings.length; fieldIdx++) {
                    var field = strings[fieldIdx];
                    var value = row[field.getIndex()];
                    var setKey = field.getId() + "--" + value;
                    keys.push(setKey);
                    key += "--" + setKey;
                    if (!Utils.isDefined(setInfos[setKey])) {
                        setInfos[setKey] = {
                            count: 0,
                            setIds: [setCnt],
                            label: value,
                        };
                        setCnt++;
                    }
                    setInfos[setKey].count++;
                }
                var ids = [];
                if (!Utils.isDefined(setInfos[key])) {
                    for (var i = 0; i < keys.length; i++) {
                        ids.push(setInfos[keys[i]].setIds[0]);
                    }
                    setInfos[key] = {
                        count: 0,
                        setIds: ids,
                        label: null,
                    };
                }
                setInfos[key].count++;
            }

            var sets = [];
            for (var a in setInfos) {
                var setInfo = setInfos[a];
                var obj = {
                    sets: setInfo.setIds,
                    size: setInfo.count
                };
                if (setInfo.label)
                    obj.label = setInfo.label;
                sets.push(obj);
            }
            this.setContents(HtmlUtils.div([ATTR_ID, this.getDomId(ID_VENN), ATTR_STYLE, "height:300px;"], ""));
            var chart = venn.VennDiagram()
                .width(600)
                .height(400);
            var id = "#" + this.getDomId(ID_VENN);
            var strokeColors = this.getColorTable(true, "strokeColors", "nice");
            var fillColors = this.getColorTable(true, "fillColors", "nice");
            var textColors = this.getColorTable(true, "textColors");
            if (!textColors)
                textColors = strokeColors;
            d3.select(id).datum(sets).call(chart);
            d3.selectAll(id + " .venn-circle path")
                .style("fill-opacity", parseFloat(this.getProperty("fillOpacity", 0.5)))
                .style("stroke-width", parseInt(this.getProperty("strokeWidth", 1)))
                .style("stroke-opacity", parseFloat(this.getProperty("strokeOpacity", 0.5)))
                .style("stroke", function(d, i) {
                    return i < strokeColors.length ? strokeColors[i] : strokeColors[i % strokeColors.length];
                })
                .style("fill", function(d, i) {
                    return i < fillColors.length ? fillColors[i] : fillColors[i % fillColors.length];
                })
            d3.selectAll(id + " .venn-circle text")
                .style("fill", function(d, i) {
                    return i < textColors.length ? textColors[i] : textColors[i % textColors.length]; 
		})
                .style("font-size", this.getProperty("fontSize", "16px"))
                .style("font-weight", this.getProperty("fontWeight", "100"));

        }
    });
}


function RamaddaMinidotsDisplay(displayManager, id, properties) {
    const ID_MINIDOTS = "minidots";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MINIDOTS, properties);
    let myProps = [
	{label:'Minidots Properties'},
	{p:'dateField',ex:''},
	{p:'valueField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUI();
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let dotsWidth = +this.getProperty("dotsWidth",500);
	    let dotsHeight = +this.getProperty("dotsHeight",200);	    
	    let valueField = this.getFieldById(null,this.getPropertyValueField());
	    let dateField = this.getFieldById(null,this.getPropertyDateField());
	    let groupByField = this.getFieldById(null,this.getProperty("groupBy"));
	    let divisor = +this.getProperty("divisor",1);
	    if(!valueField) {
                this.displayError("No value field specified");
		return;
	    }
	    if(!dateField) dateField = this.getFieldByType(null,"date");
	    let dateToCount = {};
	    let minDate=null, maxDate = null;
	    let groups = {};

	    records.forEach(record=>{
		let date = dateField?record.getValue(dateField.getIndex()):record.getDate();
		minDate = minDate!=null?Math.min(minDate,date.getTime()):date;
		maxDate = maxDate!=null?Math.max(maxDate,date.getTime()):date;
	    });
	    records.forEach(record=>{
		let groupByValue = groupByField?record.getValue(groupByField.getIndex()):"all";
		let date = dateField?record.getValue(dateField.getIndex()):record.getDate();
		minDate = minDate!=null?Math.min(minDate,date.getTime()):date;
		maxDate = maxDate!=null?Math.max(maxDate,date.getTime()):date;
		let data = groups[groupByValue];
		if(!data) {
		    groups[groupByValue] = data = {
			records:[],
			total:0,
			list:[],
			seen:{}
		    }
		}
		data.records.push(record);
		let value = record.getValue(valueField.getIndex());
		data.total+=value;
		value = value/divisor;
		if(data.list.length>5000) return;
		for(let i=0;i<value;i++) {
		    data.list.push({x:date.getTime(),
				    y:Math.random(),
				    record:record});
		}
	    });
	    let range = {
		minx:minDate,
		maxx:maxDate,
		miny:0,
		maxy:1
	    }
	    let groupList = Object.keys(groups).sort();
	    if(!groupByField) {
		let data = groups["all"];
		this.setContents(HtmlUtils.div([CLASS,"display-minidots-dots", ID, this.getDomId(ID_MINIDOTS), STYLE, HU.css(HEIGHT,HU.getDimension(dotsHeight),WIDTH,HU.getDimension(dotsWidth))], ""));
		drawDots(this,"#"+ this.getDomId(ID_MINIDOTS),dotsWidth,dotsHeight,data.list,range,null/*colorBy*/);
	    } else {
		let container = this.jq(ID_MINIDOTS);
		let table = "<table border=1>";
		groupList.forEach((key,idx)=>{
		    let data = groups[key];
		    table+="<tr>";
		    table += HU.td([],key +" (" + data.total+")");
		    let id = this.getDomId(ID_MINIDOTS+"_"+idx);
		    table += HU.td([],HtmlUtils.div([CLASS,"display-minidots-dots", ID, id, STYLE, HU.css(HEIGHT,HU.getDimension(dotsHeight),WIDTH,HU.getDimension(dotsWidth))], ""));
		    table+="</tr>\n";
		});
		this.setContents(table);
		groupList.forEach((key,idx)=>{
		    let data = groups[key];
		    let id = this.getDomId(ID_MINIDOTS+"_"+idx);
		    drawDots(this,"#"+ id,dotsWidth,dotsHeight,data.list,range,null/*colorBy*/);
		});
	    }

        }
    });
}



function RamaddaChernoffDisplay(displayManager, id, properties) {
    const ID_VENN = "venn";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_VENN, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        timeout: 100,
        written: false,
        updateUI: function() {
            if (!this.written) {
                this.written = true;
                var includes = "<script src='" + RamaddaUtil.getCdnUrl("/lib/chernoff.js")+"'></script>";
                this.writeHtml(ID_DISPLAY_TOP, includes);
            }
            this.updateUIInner();
        },
        updateUIInner: function() {
            let _this = this;
            if (!Utils.isDefined(d3.chernoff)) {
                this.timeout = this.timeout * 2;
                var func = function() {
                    _this.updateUIInner();
                };
                setTimeout(func, this.timeout);
                return;
            }
            let records = this.filterData();
            if (!records) {
                return;
            }
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length == 0)
                fields = allFields;
            var string = this.getFieldByType(fields, "string");
            var legend = "";
            var colorField = this.getFieldById(allFields, this.getProperty("colorBy"));
            var colorscale;
            if (colorField) {
                var colors = this.getColorTable(true, null, "blue_white_red");
                var colorValues = this.getColumnValues(records, colorField);
                colorscale = [];
                var min = parseFloat(this.getProperty("colorByMin", colorValues.min));
                var max = parseFloat(this.getProperty("colorByMax", colorValues.max));
                var range = max - min;
                //                console.log("range:" +  max +" " +min +" #colors:" + colors.length);
                for (var i = 0; i < colorValues.values.length; i++) {
                    var value = colorValues.values[i];
                    var percent = (value - min) / range;
                    var idx = Math.round(percent * (colors.length - 1));
                    //                    console.log(idx+" " +colors[idx] +" " + value + " " + percent);
                    colorscale.push(colors[idx]);
                }
                this.displayColorTable(colors, ID_DISPLAY_BOTTOM, min, max);
                legend += "<b>Colored by</b>: " + colorField.getLabel() + "&nbsp;&nbsp;";
            }
            var attrs = [{
                label: "Face width",
                name: "face",
                key: "f",
                min: 0,
                max: 1
            }, {
                label: "Hair",
                name: "hair",
                key: "h",
                min: -1,
                max: 1
            }, {
                label: "Mouth",
                name: "mouth",
                key: "m",
                min: -1,
                max: 1
            }, {
                label: "Nose height",
                name: "noseHeight",
                key: "nh",
                min: 0,
                max: 1
            }, {
                label: "Nose width",
                name: "noseWidth",
                key: "nw",
                min: 0,
                max: 1
            }, {
                label: "Eyes height",
                name: "eyesHeight",
                key: "eh",
                min: 0,
                max: 1
            }, {
                label: "Eyes width",
                name: "eyesWidth",
                key: "ew",
                min: 0,
                max: 1
            }, {
                label: "Brow",
                name: "brow",
                key: "b",
                min: -1,
                max: 1
            }];
            var html = "";
            var showHelp = this.getProperty("showHelp", false);
            if (showHelp) {
                html += "Settings:<br><table class=ramadda-table><thead><tr><th>Attribute&nbsp;</th><th>&nbsp;Default range&nbsp;</th><th>&nbsp;Set field&nbsp;</th><th>&nbsp;Set min&nbsp;</th><th>&nbsp;Set max&nbsp;</th></tr></thead><tbody>";
            }

            for (a in attrs) {
                var attr = attrs[a];
                if (showHelp) {
                    html += "<tr><td>" + attr.label + "</td><td align=center>" + attr.min + " - " + attr.max + "</td><td>" + attr.name + "Field=&lt;field_id&gt;" + "</td><td>" + attr.name + "Min=&lt;min_value&gt;" + "</td><td>" + attr.name + "Max=&lt;max_value&gt;" + "</td></tr>";
                }
                attr.field = this.getFieldById(allFields, this.getProperty(attr.name + "Field"));
                if (attr.field) {
                    legend += "<b>" + attr.label + "</b>: " + attr.field.getLabel() + "&nbsp;&nbsp;";
                    if (Utils.isDefined(this.getProperty(attr.name + "Min"))) {
                        attr.min = parseFloat(this.getProperty(attr.name + "Min"));
                    }
                    if (Utils.isDefined(this.getProperty(attr.name + "Max"))) {
                        attr.max = parseFloat(this.getProperty(attr.name + "Max"));
                    }
                    attr.column = this.getColumnValues(records, attr.field);
                }
            }
            if (showHelp) {
                html += "</tbody></table>";
            }

            var sortField = this.getFieldById(allFields, this.getProperty("sortBy"));

            var rows = [];
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var blob = {
                    values: this.getDataValues(records[rowIdx])
                };
                if (colorscale) blob.color = colorscale[rowIdx]
                rows.push(blob);
            }

            if (sortField) {
                rows.sort(function(a, b) {
                    var v1 = a.values[sortField.getIndex()];
                    var v2 = b.values[sortField.getIndex()];
                    if (v1 < v2) return 1;
                    if (v1 > v2) return -1;
                    return 0;
                });
            }

            var data = [];
            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var blob = rows[rowIdx];
                var row = blob.values;
                var color = blob.color;
                var faceData = {
                    f: 0.5, //0-1
                    h: 0, //-1-1
                    m: 0, //-1-1
                    nh: 0.5, //0-1
                    nw: 0.5, //0-1
                    eh: 0.5, //0-1
                    ew: 0.5, //0-1
                    b: 0 //-1-1
                };
                data.push({
                    faceData: faceData,
                    color: color
                });
                var tt = "";
                for (a in attrs) {
                    var attr = attrs[a];
                    var field = attr.field;
                    if (!field) {
                        faceData[attr.key] = attr.min + (attr.max - attr.min) / 2;
                    } else {
                        var value = row[field.getIndex()];
                        var min = attr.column.min;
                        var max = attr.column.max;
                        tt += field.getLabel() + ": " + value + " range: " + min + " - " + max + " (" + attr.label + ")\n";
                        if (max != min) {
                            var percent = (value - min) / (max - min);
                            var adjValue = attr.min + (attr.max - attr.min) * percent;
                            //                            console.log(" %:" + percent + " v:" + value +" min:" + min +" max:" + max +" adj:" + adjValue);
                            faceData[attr.key] = adjValue;
                        }
                    }
                }
                var label = (string ? row[string.getIndex()] : "Row: " + rowIdx);
                var labelValue = (string ? row[string.getIndex()] : "");
                label = HtmlUtils.div([ATTR_CLASS, "display-chernoff-label"], label);
                var div = HtmlUtils.div([ATTR_ID, this.getDomId("chernoff") + "_" + rowIdx, ATTR_CLASS, "display-chernoff-face"], "");
                html += HtmlUtils.div([ATTR_TITLE, tt, ATTR_CLASS, "display-chernoff-wrapper ramadda-div-link", "value", labelValue], div + label);
            }
            legend = HtmlUtils.div([ATTR_CLASS, "display-chernoff-legend"], legend);
            var height = this.getProperty("height", "400px");
            if (!height.endsWith("px")) height += "px";
            this.setContents(legend + HtmlUtils.div([ATTR_STYLE, "height:" + height + ";", ATTR_CLASS, "display-chernoff-container", ATTR_ID, this.getDomId("chernoff")], html));
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var div = "#" + this.getDomId("chernoff") + "_" + rowIdx;
                this.makeFace(div, data[rowIdx].faceData, data[rowIdx].color);
            }

            if (string) {
                this.find(".ramadda-div-link").click(function() {
                    var value = $(this).attr("value");
                    _this.propagateEvent("fieldValueSelected", {
                        field: string,
                        value: value
                    });
                });
            }
        },
        makeFace: function(div, faceData, color) {
            function chernoffFace() {
                var width = 400,
                    height = 200;
                var chernoff = d3.chernoff()
                    .face(function(d) {
                        return d.f;
                    })
                    .hair(function(d) {
                        return d.h;
                    })
                    .mouth(function(d) {
                        return d.m;
                    })
                    .nosew(function(d) {
                        return d.nw;
                    })
                    .noseh(function(d) {
                        return d.nh;
                    })
                    .eyew(function(d) {
                        return d.ew;
                    })
                    .eyeh(function(d) {
                        return d.eh;
                    })
                    .brow(function(d) {
                        return d.b;
                    });

                function data() {
                    return [faceData];
                }

                function drawFace(selection) {
                    var svg = selection.append("svg")
                        .attr("width", width)
                        .attr("height", height);
                    var face = svg.selectAll("g.chernoff")
                        .data(data())
                        .enter().append("g")
                        .attr(ATTR_CLASS, "chernoff")
                        .call(chernoff);
                    if (color)
                        face.attr(ATTR_STYLE, "fill:" + color);
                }

                function draw(selection) {
                    selection.call(drawFace);
                }
                return draw;
            }
            d3.select(div)
                .call(chernoffFace());
        }





    });
}



function RamaddaD3bubbleDisplay(displayManager, id, properties) {
    const ID_BUBBLES = "bubbles";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_D3BUBBLE, properties);
    if(!window["BubbleChart"]) {
	Utils.importJS(RamaddaUtil.getCdnUrl("/lib/d3/d3-legend.min.js"));
	Utils.importJS(RamaddaUtil.getCdnUrl("/lib/d3/bubblechart.js"));
    }
    let myProps = [
	{label:'Bubble Chart'},
	{p:'labelField',ex:''},
	{p:'colorBy',ex:''},
	{p:'valueField',ex:''},
	{p:'descriptionField',ex:''},
	{p:'imageField',ex:''},
	{p:'sizeLabel1',ex:''},
	{p:'sizeLabel2',ex:''},
	{p:'showSizeLegend',ex:'false'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	callbackWaiting:false,
        displayData: function() {
	    this.updateUI();
	},
        updateUI: function() {
            if(!window["BubbleChart"]) {
		if(!this.callbackWaiting) {
		    this.callbackWaiting = true;
                    setTimeout(()=>{
			this.callbackWaiting = false;
			this.updateUI()
		    },100);
		}
                return;
            }
	    //If the width is 0 then there is an error in the d3
	    if(this.getContents().width() ==0)  {
		this.setContents("...");
		return;
	    }
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
            let colorByField = this.getFieldById(null, this.getProperty("colorBy","category"));
	    let valueField = this.getFieldById(null, this.getProperty("valueField"));
	    if(colorByField)
		this.setProperty("sortFields",colorByField.getId());
	    let html = HtmlUtil.tag("svg", [ATTR_ID, this.getDomId(ID_BUBBLES),
					    "width","100%","height","700", "font-family","sans-serif","font-size","10", "text-anchor","middle"])
	    this.setContents(html);
	    let values;
	    let min = 0;
	    let max = 0;
	    if(valueField) {
		values =  this.getColumnValues(records, valueField).values;
		values.map((v,idx)=>{
		    min  = idx==0?v:Math.min(v,min);
		    max  = idx==0?v:Math.max(v,max);
		});
	    }

	    let labelField = this.getFieldById(null, this.getProperty("labelField","name"));
	    let descField = this.getFieldById(null, this.getProperty("descriptionField"));	    
	    let imageField = this.getFieldById(null, this.getProperty("imageField"));	    
	    let template = this.getProperty("template","${default}");
	    if(!labelField) {
                this.setContents(this.getMessage("No label field found"));
		return
	    }

	    let data =[];
	    records.map(r=>{
		let desc =  descField?r.getValue(descField.getIndex()):this.getRecordHtml(r,null, template);
		let label = r.getValue(labelField.getIndex());
		let obj = {
		    name: label,
		    icon:label,
		    desc:desc,
		    cat:"",
		    value:10,
		}
		if(colorByField)
		    obj.cat = r.getValue(colorByField.getIndex());
		if(valueField)
		    obj.value = r.getValue(valueField.getIndex());
		if(imageField)
		    obj.icon = r.getValue(imageField.getIndex());
		data.push(obj);
	    });
	    if(data.length==0) {
		this.setContents(this.getMessage(this.getNoDataMessage()));
		return;
	    }
	    let colors =  this.getColorTable(true);
	    new BubbleChart("#"+this.domId(ID_BUBBLES),data,{
		label1:this.getProperty("sizeLabel1"),
		label2: this.getProperty("sizeLabel2"), 
		colors:colors,
		showSizeLegend: this.getProperty("showSizeLegend",valueField!=null)
	    });
	}
    })
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


const DISPLAY_WORDCLOUD = "wordcloud";
const DISPLAY_TEXTSTATS = "textstats";
const DISPLAY_FREQUENCY = "frequency";
const DISPLAY_TEXTANALYSIS = "textanalysis";
const DISPLAY_TEXTRAW = "textraw";
const DISPLAY_TEXT = "text";

const DISPLAY_BLOCKS = "blocks";
const DISPLAY_TEMPLATE = "template";
const DISPLAY_TOPFIELDS = "topfields";
const DISPLAY_GLOSSARY = "glossary";

addGlobalDisplayType({
    type: DISPLAY_TEXT,
    label: "Text Readout",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Simple text display","text.png")
});

addGlobalDisplayType({
    type: DISPLAY_TEMPLATE,
    label: "Template",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Flexible text template to show records","template.png")    
});


addGlobalDisplayType({
    type: DISPLAY_TOPFIELDS,
    label: "Top Fields",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("List Fields","topfields.png","For every row it sorts the field values and lists the field names"),    
});

addGlobalDisplayType({
    type: DISPLAY_WORDCLOUD,
    forUser: true,
    label: "Word Cloud",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Cloud of words","wordcloud.png")
});

addGlobalDisplayType({
    type: DISPLAY_TEXTSTATS,
    forUser: true,
    label: "Text Stats",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Summary statistics for text","textstats.png","Incudes line/word count, word length and frequency")    
});

addGlobalDisplayType({
    type: DISPLAY_FREQUENCY,
    forUser: true,
    label: "Frequency",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Text field based frequencies","frequency.png")
});
addGlobalDisplayType({
    type: DISPLAY_TEXTRAW,
    forUser: true,
    label: "Text Raw",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Shows raw text","textraw.png","Provides a search field")                                        
});
addGlobalDisplayType({
    type: DISPLAY_TEXTANALYSIS,
    forUser: true,
    label: "Text Analysis",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Analyzes text","textanalysis.png")
});
addGlobalDisplayType({
    type: DISPLAY_BLOCKS,
    forUser: true,
    label: "Blocks",
    requiresData: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Blocks","blocks.png","Shows a certain number of small blocks or icons color coded from the data"),        
});

addGlobalDisplayType({
    type: DISPLAY_GLOSSARY,
    forUser: true,
    label: "Glossary",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Searchable glossary","glossary.png")    
});


function RamaddaBaseTextDisplay(displayManager, id, type, properties) {
    const ID_TEXTBLOCK = "textblock";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    defineDisplay(this, SUPER, [], {
        processText: function(cnt,fields) {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            var fieldInfo = {};
            var allFields = this.getData().getRecordFields();
            fields = fields || this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
            var minLength = parseInt(this.getProperty("minLength", 0));
            var maxLength = parseInt(this.getProperty("maxLength", 100));
            var stopWords = this.getProperty("stopWords");
            if (stopWords) {
                if (stopWords == "default") {
                    stopWords = Utils.stopWords;
                } else {
                    stopWords = stopWords.split(",");
                }
            }
            var extraStopWords = this.getProperty("extraStopWords");
            if (extraStopWords) extraStopWords = extraStopWords.split(",");

            var stripTags = this.getProperty("stripTags", false);
            var tokenize = this.getProperty("tokenize", false);
            var lowerCase = this.getProperty("lowerCase", false);
            var removeArticles = this.getProperty("removeArticles", false);
            if (cnt) {
                cnt.count = 0;
                cnt.total = 0;
                cnt.lengths = {};
            }
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var row = this.getDataValues(records[rowIdx]);
                for (var fieldIdx = 0; fieldIdx < strings.length; fieldIdx++) {
                    var field = strings[fieldIdx];
                    if (!fieldInfo[field.getId()]) {
                        fieldInfo[field.getId()] = {
                            field: field,
                            words: [],
                            counts: {},
                            divId: this.domId(ID_TEXTBLOCK + (field.getIndex())),
                        }
                    }
                    var fi = fieldInfo[field.getId()];
                    var value = row[field.getIndex()];
                    if (stripTags) {
                        value = Utils.stripTags(value);
                    }
                    var values = [value];
                    if (tokenize) {
			values[0] = values[0].replace(/\"/g," ");
                        values = Utils.tokenizeWords(values[0], stopWords, extraStopWords, removeArticles);
                    }
                    for (var valueIdx = 0; valueIdx < values.length; valueIdx++) {
                        var value = values[valueIdx].trim();
			if(values.length>1 && value.length<=1) continue;
			if(value.startsWith("&")) continue;  
			var _value = value.toLowerCase();
                        if (cnt) {
                            cnt.count++;
                            cnt.total += value.length;
                            if (!Utils.isDefined(cnt.lengths[value.length]))
                                cnt.lengths[value.length] = 0;
                            cnt.lengths[value.length]++;
                        }


                        if (!tokenize) {
                            if (stopWords && stopWords.includes(_value)) continue;
                            if (extraStopWords && extraStopWords.includes(_value)) continue;
                        }
                        if (value.length > maxLength) continue;
                        if (value.length < minLength) continue;
                        if (lowerCase) value = value.toLowerCase();
                        if (!Utils.isDefined(fi.counts[value])) {
                            fi.counts[value] = 0;
                        }
                        fi.counts[value]++;
                    }
                }
            }



            return fieldInfo;
        }
    });
}


function RamaddaWordcloudDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_WORDCLOUD, properties);
    let myProps = [
	{label:"Wordcloud"},
	{p:'termField'},
	{p:'fields'},	
	{p:'tableFields'},
	{p:'countField'},
	{p:'tokenize',ex:true},
	{p:'handleClick',ex:true},
	{p:'showFieldLabel',ex:true},
	{p:'showRecords'},
	{p:'combined'},
	{p:'shape',ex:'rectangular'},
	{p:'stopWords',ex:'word1,word2'},
	{p:'showFieldLabel',ex:'false'}	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
	hasJq:false,
        updateUI: function() {
	    if(!this.loadedJq) {
		this.loadedJq = true;
		let includes = "<link rel='stylesheet' href='" + RamaddaUtil.getCdnUrl("/lib/jqcloud.min.css")+"'>";
		includes += "<script src='" + RamaddaUtil.getCdnUrl("/lib/jqcloud.min.js")+"'></script>";
		this.writeHtml(ID_DISPLAY_TOP, includes);
		let _this = this;
		let tmp = $("body");
		let func = function() {
		    if(!tmp.jQCloud) {
			setTimeout(func, 100);
		    } else {
			_this.hasJq = true;
			_this.updateUIInner();
		    }
		};
		setTimeout(func, 100);
	    } else if(this.hasJq) {
                this.updateUIInner();
	    }
        },
        updateUIInner: function() {
            let records = this.filterData();
	    if(records == null) return;
	    let countField = this.getFieldById(null, this.getProperty("countField"));
	    let termField = this.getFieldById(null, this.getProperty("termField"));
            let allFields = this.getData().getRecordFields();
            let fields = termField?[termField]:this.getSelectedFields(allFields);
            let fieldInfo = this.processText(null,fields);
            if (fieldInfo == null) return;
            if (fields.length == 0)
                fields = allFields;



            let options = {
                autoResize: true,
            };
            let colors = this.getColorTable(true);
            if (colors) {
                options.colors = colors,
                options.classPattern = null;
                options.fontSize = {
                    from: 0.1,
                    to: 0.02
                };
            }
            if (this.getProperty("shape"))
                options.shape = this.getProperty("shape");


	    if(countField && termField) {
		let minLength = parseInt(this.getProperty("minLength", 0));
		let maxLength = parseInt(this.getProperty("maxLength", 100));
		let stopWords = this.getProperty("stopWords");
		if (stopWords) {
                    if (stopWords == "default") {
			stopWords = Utils.stopWords;
                    } else {
			stopWords = stopWords.split(",");
                    }
		}
		let info = [];
		let wordToWeight = {};
		records.every(record=>{
		    let word =termField.getValue(record);
		    let _word = word.toLowerCase();
                    if (stopWords && stopWords.includes(_word)) return true;
		    if(!wordToWeight[word]) {
			wordToWeight[word]=0;
		    }
		    wordToWeight[word]+=countField.getValue(record);
		    return true;
		});
                let handlers = null;
		let _this = this;
                if (this.getProperty("handleClick", true)) {
                    handlers = {
                        click: function(w) {
			    console.dir(w);
                            let word = w.target.innerText;
                            _this.showRows(records, null, word, fields);
                        }
                    }
                };

		    
		for(word in wordToWeight) {
		    info.push({
			text: word,
			html:{style:"cursor:pointer;"},
			weight:wordToWeight[word] ,
			handlers:handlers,
		    });

		}
                this.setContents(HU.div([ATTR_ID, this.domId("words"), ATTR_STYLE, HU.css('height','300px')], ""));
                $("#" + this.domId("words")).jQCloud(info, options);
		return
	    }
            let strings = this.getFieldsByType(fields, "string");
            let _this = this;
            let divs = "";
            let words = [];
            let maxWords = parseInt(this.getProperty("maxWords", -1));
            let minCount = parseInt(this.getProperty("minCount", 0));
            let width = (100 * 1 / strings.length) + "%;";
            for (a in fieldInfo) {
                let fi = fieldInfo[a];
                let field = fi.field;
                let handlers = null;
                if (this.getProperty("handleClick", true)) {
                    handlers = {
                        click: function(w) {
                            let word = w.target.innerText;
                            _this.showRows(records, field, word, fields);
                        }
                    }
                };

                let counts = [];
                for (word in fi.counts) {
                    let count = fi.counts[word];
                    counts.push({
                        word: word,
                        count: count
                    });
                }
                counts.sort(function(a, b) {
                    if (a.count < b.count) return -1;
                    if (a.count > b.count) return 1;
                    return 0;
                });
                if (minCount > 0) {
                    let tmp = [];
                    for (let i = 0; i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }
                if (maxWords > 0) {
                    let tmp = [];
                    for (let i = 0; i <= maxWords && i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                for (let wordIdx = 0; wordIdx < counts.length; wordIdx++) {
                    let word = counts[wordIdx];
                    let obj1 = {
                        weight: word.count,
			html:{style:"cursor:pointer;"},
                        handlers: handlers,
                        text: word.word,
                    };
                    let obj2 = {
                        weight: word.count,
			html:{style:"cursor:pointer;"},
                        handlers: handlers,
                        text: field.getLabel() + ":" + word.word,
                    };
                    fi.words.push(obj1);
                    words.push(obj2);
                }
                let label = "";
                if (this.getProperty("showFieldLabel", true))
                    label = HU.b(fi.field.getLabel());

                divs += HU.div([ATTR_STYLE,HU.css('display','inline-block','width', width)], 
			       label + HU.div([ATTR_STYLE, HU.css('border','1px #ccc solid','height','300px'), ATTR_ID, fi.divId], ""));
            }

            this.setContents("");
            if (this.getProperty("combined", false)) {
                this.setContents(HU.div([ATTR_ID, this.domId("words"), ATTR_STYLE, HU.css('height','300px')], ""));
                $("#" + this.domId("words")).jQCloud(words, options);
            } else {
                this.setContents(divs);
                for (a in fieldInfo) {
                    let fi = fieldInfo[a];
                    $("#" + fi.divId).jQCloud(fi.words, options);
                }
            }
        },
        showRows: function(records, field, word, stringFields) {
	    if(!field)
		field = this.getFieldById(null, this.getProperty("termField"));
            let tokenize = this.getProperty("tokenize", false);
            if (stringFields && word.startsWith(field.getLabel() + ":")) {
                word = word.replace(field.getLabel() + ":", "");
            }
            let tableFields;
            if (this.getProperty("tableFields")) {
                tableFields = {};
                let list = this.getProperty("tableFields").split(",");
                for (a in list) {
                    tableFields[list[a]] = true;
                }
            }
            let fields = this.getData().getRecordFields();
            let html = "";
            let data = [];
            let header = [];
            data.push(header);
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let f = fields[fieldIdx];
                if (tableFields && !tableFields[f.getId()]) continue;
                header.push(fields[fieldIdx].getLabel());
            }
            let showRecords = this.getProperty("showRecords", false);
            if (showRecords) {
                html += "<br>";
            }
            let re = new RegExp("(\\b" + word + "\\b)", 'i');
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                let value =  row[field.getIndex()];
                if (tokenize) {
                    if (!value.match(re)) {
                        continue;
                    }
                } else {
                    if (word != value) {
                        continue;
                    }
                }
                let tuple = [];
                data.push(tuple);
                for (let col = 0; col < fields.length; col++) {
                    let f = fields[col];
                    if (tableFields && !tableFields[f.getId()]) continue;
                    let v = row[f.getIndex()];
		    if(v.getTime) {
			v = {v:v,f:this.formatDate(v)};
		    } else {
			if (tokenize) {
                            v = v.replace(re, "<span style=background:yellow;>$1</span>");
			}
		    }
                    if (showRecords) {
                        html += HU.b(f.getLabel()) + ": " + v + "</br>";
                    } else {
                        tuple.push(v);
                    }
                }
                if (showRecords) {
                    html += "<p>";
                }
            }

            if (showRecords) {
                this.writeHtml(ID_DISPLAY_BOTTOM, html);
            } else {
                let prefix = "";
                if (!tokenize) {
                    prefix = (field?field.getLabel():"Word") + "=" + word
                }
                this.writeHtml(ID_DISPLAY_BOTTOM, HU.center(prefix + HU.div([ATTR_ID, this.domId("table"), ATTR_STYLE, HU.css('height','300px')], "")));
		let step2=()=>{
                    let dataTable = google.visualization.arrayToDataTable(data);
                    this.chart = new google.visualization.Table(document.getElementById(this.domId("table")));
                    this.chart.draw(dataTable, {
			allowHtml: true
                    });
		}
		let step1=()=>{
		    if(!ramaddaLoadGoogleChart('table',step2)) {
			return
		    }
		}
		if(!haveGoogleChartsLoaded(step1)) {
		    return;
		}
		step2();
            }
        }
    });
}




function RamaddaTemplateDisplay(displayManager, id, properties) {
    if(!Utils.isDefined(properties.showTitle)) properties.showTitle=false;
    if(!Utils.isDefined(properties.showMenu)) properties.showMenu=false;
//    if(!Utils.isDefined(properties.displayStyle)) properties.displayStyle = "background:rgba(0,0,0,0);";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TEMPLATE, properties);
    let myProps = [
	{label:"Template"},
	{p: "template",ex:'${default}'},
	{p:"toggleTemplate",ex:"",tt:'Used as the toggle label for hiding/showing the main template'},
	{p:"headerTemplate",ex:"... ${totalCount} ... ${selectedCount} ${filter_field} ..."},
	{p:"footerTemplate",ex:"... ${totalCount} ... ${selectedCount} ${filter_.field} ... "},
	{p:"templateStyle",ex:'display:inline-block;',tt:'Style for the wrapper div'},	
	{p:"emptyMessage",tt:'Text to show when there are no records to show'},
	{p:"select",ex:"max|min|<|>|=|<=|>=|contains"},
	{p:"selectField"},
	{p:"selectValue"},
	{p:'onlyShowSelected',ex:'true'},
	{p:'useNearestDate',tt:'Sample on the selected record time',ex:'true'},	
	{p:'showFirst',ex:'true',tt:'Show first record'},
	{p:'showLast',ex:'true',tt:'Show last record'},		
	{p:'showRecords',tt:'comma separated list of record indices',ex:'0,3,4'},
	{p:'dontShowRecords',tt:'comma separated list of record indices to not show',ex:'0,3,4'},	
	{p:'selectHighlight',ex:'true'},	
	{p:'handleSelectOnClick',ex:'false',tt:"Don't select the record on a click"},
	{p:"groupByField"},
	{p:"groupDelimiter",ex:"<br>"},	
	{p:"groupTemplate",wikivalue:"<b>${group}</b><ul>${contents}</ul>"},
	{p:"sortGroups",wikivalue:"true"},
	{p:'${&lt;field&gt;_total}'},
	{p:'${&lt;field&gt;_max}'},
	{p:'${&lt;field&gt;_min}'},
	{p:'${&lt;field&gt;_average}'},
	{p:'highlightOnScroll',ex:'true'},
	{p:'scrollOnHighlight',ex:'true',d:'true',tt:'Scroll to the record when it is highlighted'},

        {p:'highlightFilterText',ex:'true',tt:'Highlight any filter text'},	
	{p:'colorBackground',d:false, canCache:true},
	{p:'addCopyToClipboard',ex:true,tt:'Add a link to copy the output to the clipboard'},
	{p:'copyToClipboardDownloadFile',ex:'somefile.txt',tt:'Instead of copying to the clipboard download the file'}	
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	dataFilterChanged: function() {
	    if(this.getOnlyShowSelected() && this.selectedRecord ) {
		this.selectedRecord = null;
		this.selectedRecords = null;		
		this.setContents("");
	    }
	    SUPER.dataFilterChanged.call(this);
	},
        displayData: function(reload, debug) {
	    this.updateUI();
	},
	updateUI: function() {
	    let records = this.myRecords = this.filterData();
	    if(!records) return;
	    let fields = this.getFields();
            fields = this.getSelectedFields();
	    if(!fields) return;
	    if(this.getOnlyShowSelected()) {
		if(!this.selectedRecord && !this.selectedRecords) {
		    if(this.getShowFirst(true)) {
			this.selectedRecord = records[0];
		    }
		}
		if(!this.selectedRecord && !this.selectedRecords) {
		    this.setContents(this.getEmptyMessage("<br>"));
		    return;
		}
		records = this.selectedRecords|| [this.selectedRecord];
		records= this.sortRecords(records);
	    } else {
		records= this.sortRecords(records);
		if(this.getShowFirst(false)) {
		    records = [records[0]];
		} else 	if(this.getShowLast(false)) {
		    records = [records[records.length-1]];
		}
	    }
	    let showRecords = this.getShowRecords();
	    if(showRecords) {
		let tmp = [];
		showRecords.split(",").forEach(idx=>{
		    tmp.push(records[+idx]);
		});
		records = tmp;
	    }
	    let dontShowRecords = this.getDontShowRecords();
	    if(dontShowRecords) {
		let notOK = {};
		dontShowRecords.split(",").forEach(idx=>{
		    notOK[+idx]=true;
		});
		let tmp = [];
		for(let i=0;i<records.length;i++) {
		    if(notOK[i]) continue;
		    tmp.push(records[i]);
		}
		records = tmp;
	    }	    
	    let uniqueFields  = this.getFieldsByIds(fields, this.getProperty("uniqueFields"));
	    let uniqueMap ={};
	    let template = this.getTemplate();
	    let toggleTemplate = this.getToggleTemplate();
	    let select = this.getProperty("select","all");
	    let selected = [];
	    let summary = {};
	    let goodRecords = [];
	    let matchers = this.getHighlightFilterText()?this.getFilterTextMatchers():null;
	    records.forEach(record=>{
		if(uniqueFields.length>0) {
		    var key= "";
		    uniqueFields.map(uf=>{
			key += "__" +uf.getValue(record);
		    });
		    if(Utils.isDefined(uniqueMap[key])) {
			return;
		    }
		    uniqueMap[key] = true;
		}
		goodRecords.push(record);
		for(var i=0;i<fields.length;i++) {
		    var f = fields[i];
		    var v =f.getValue(record);
		    if(!summary[f.getId()]) {
			summary[f.getId()] = {
			    total: 0,
			    min: v,
			    max:v,
			    count:0,
			    uniques:{},
			    uniqueCount:0
			}
		    }
		    var s = summary[f.getId()];
		    if(f.isString()) {
			if(!s.uniques[v]) {
			    s.uniqueCount++;
			    s.uniques[v] = true;
			}
			continue;
		    } 
		    if(f.isDate&& v && v.getTime) {
			if(v.getTime()<s.min.getTime()) s.min = v;
			if(v.getTime()>s.max.getTime()) s.max = v;
		    }  else if(!isNaN(v)) {
			s.total+=v;
			s.min = Math.min(s.min,v);
			s.max = Math.max(s.max,v);
			s.count++;
		    }
		}
	    });

	    records=goodRecords;

	    for(var i=0;i<fields.length;i++) {
		var f = fields[i];
		if(!f.isNumeric()) continue;
		var s = summary[f.getId()];
		if(s && s.count) {
		    s.average =  s.total/s.count;
		}
	    }
	    

	    if(select == "max" || select=="min" || select=="=" || select=="<" || select == ">" ||
	       select == "<=" || 	       select == "?>=" || select=="match") {
		var selectField = this.getProperty("selectField",null);
		if(selectField) selectField  =this.getFieldById(null, selectField);
		if(!selectField) {
		    this.setContents("No selectField specified");
		    return;
		}
		var selectValue = this.getProperty("selectValue","0");
		var selectValueNum = parseFloat(selectValue);
		var max =0; 
		var min = 0;
		var cnt = 0;
		var maxRecord;
		var minRecord;
		var equalsRecord;
		records.map(record=>{
		    var v =selectField.getValue(record);
		    if(select == "match") {
			if(v.match(selectValue)) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == "=") {
			if(v == selectValue) {
			    selected.push(record);
			}
			return;
		    }
		    if(isNaN(v)) return;
		    if(select == "<") {
			if(v < selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == ">") {
			if(v > selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == ">=") {
			if(v >= selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == "<=") {
			if(v <= selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(cnt++ == 0) {
			min  = v;
			max = v;
			minRecord = record;
			maxRecord = record;
			return;
		    }
		    if(v<min) {
			min  = v;
			minRecord = record;
		    }
		    if(v > max) {
			max =v;
			maxRecord = record;
		    }
		});
		if(select == "min") {
		    if(minRecord)
			selected.push(minRecord);
		} else 	if(select == "max") {
		    if(maxRecord)
			selected.push(maxRecord);
		}
	    } else {
		selected = records;
	    }
	    let contents = "";
	    if(selected.length==0) {
		contents = this.getEmptyMessage("Nothing found");
	    }

            let colorBy = this.getColorByInfo(selected);


	    let attrs = {};
	    attrs["selectedCount"] = selected.length;
	    attrs["totalCount"] = records.length;


	    for(var i=0;i<fields.length;i++) {
		let f = fields[i];
		let s = summary[f.getId()];
		if(!s) continue;
		if(f.isDate) {
		    attrs[f.getId()+"_min"] = s.min;
		    attrs[f.getId()+"_max"] = s.max;
		    continue;
		}
		if(s && f.isString()) {
		    attrs[f.getId() +"_uniques"] =  s.uniqueCount;
		    continue;
		}
		if(!f.isNumeric()) continue;
		if(s) {
		    attrs[f.getId() +"_total"] = s.total;
		    attrs[f.getId() +"_min"] = s.min;
		    attrs[f.getId() +"_max"] = s.max;
		    attrs[f.getId() +"_average"] = s.average;
		}
	    }

	    let headerTemplate = this.getProperty("headerTemplate","");
	    let footerTemplate = this.getProperty("footerTemplate","");

	    if(selected.length==1) {
		let row = this.getDataValues(selected[0]);
		headerTemplate = this.applyRecordTemplate(selected[0],row,fields,headerTemplate);
		footerTemplate = this.applyRecordTemplate(selected[0],row,fields,footerTemplate);
	    }

	    let replace = (pattern,value)=>{
		headerTemplate = headerTemplate.replace(pattern,value);
		footerTemplate = footerTemplate.replace(pattern,value);		    
	    };

	    fields.forEach(f=>{
		if(!f.isNumeric()) return;
		let total = 0;
		let cnt = 0;
		let min=0;
		let max=0;
		selected.forEach(record=>{
		    let v= f.getValue(record);
		    if(!isNaN(v)) {
			if(cnt==0) {
			    min=v;
			    max=v;
			}
			min = Math.min(v,min);
			max = Math.max(v,max);			
			total+=v;
			cnt++;
		    }

		});
		replace('${'+ f.getId()+'_average}}', cnt==0?'NA':Utils.formatNumberComma(total/cnt));
		replace('${'+ f.getId()+'_min}', Utils.formatNumberComma(min));
		replace('${'+ f.getId()+'_max}', Utils.formatNumberComma(max));		
		replace('${'+ f.getId()+'_total}', Utils.formatNumberComma(total));
	    });
	    if(this.filters) {
		for(let filterIdx=0;filterIdx<this.filters.length;filterIdx++) {
		    let filter = this.filters[filterIdx];
		    if(!filter.isEnabled()) {
			continue;
		    }
		    let f = filter.getField();
		    let fid = "filter_" + f.getId();
		    if(f.isNumeric()) {
			let min = $("#" + this.domId("filterby_" + f.getId()+"_min")).val()?.trim();
			let max = $("#" + this.domId("filterby_" + f.getId()+"_max")).val()?.trim();
			attrs[fid +"_min"] = min;
			attrs[fid +"_max"] = max;
		    } else {
			let widget =$("#" + this.domId("filterby_" + f.getId())); 
			if(!widget.val || widget.val()==null) continue;
			let value = widget.val();
			if(!value) continue;
			if(Array.isArray(value)) {
			    let tmp = "";
			    value.forEach(v=>{
				if(tmp!="") tmp+=", ";
				tmp+=v;
			    });
			    value = tmp;
			}
			value = value.trim();
			if(value==FILTER_ALL) {
			    let regexp = new RegExp("\\${filter_" + f.getId()+"[^}]*\\}",'g');
//			    attrs[fid] = "";
			    replace(regexp,"");
			} else {
			    /*
			    let regexp = new RegExp("\\${filter_" + f.getId()+" +prefix='([^']*)' +suffix='([^']*)' *\\}",'g');

			    replace(regexp,"$1" + value +"$2");
			    regexp = new RegExp("\\${filter_" + f.getId()+" +prefix='([^']*)' *\\}",'g');
			    replace(regexp,"$1" + value);
			    regexp = new RegExp("\\${filter_" + f.getId()+" +suffix='([^']*)' *\\}",'g');
			    replace(regexp,value +"$1");
			    regexp = new RegExp("\\${filter_" + f.getId()+" *\\}",'g');
			    replace(regexp,value);
			    */
			    attrs[fid] = value;
			}
		    }
		}
	    }

	    let th = Utils.tokenizeMacros(headerTemplate);
	    let tf = Utils.tokenizeMacros(footerTemplate);
	    headerTemplate = th.apply(attrs);
	    footerTemplate = tf.apply(attrs);	    

	    if(selected.length>0) {
		contents+= headerTemplate;
	    }

	    let handleSelectOnClick = this.getPropertyHandleSelectOnClick(true);


	    if(Utils.stringDefined(template)) {
		let groupByField  =this.getFieldById(null, this.getProperty("groupByField"));
		let groupDelimiter  = this.getProperty("groupDelimiter"," ");
		let groupTemplate  = this.getProperty("groupTemplate","<b>${group}</b><ul>${contents}</ul>");
		let groupList = [];
		let groups = {};
		var props = this.getTemplateProps(fields);
		var max = parseFloat(this.getProperty("maxNumber",-1));
		var cols = parseFloat(this.getProperty("templateColumns",-1));
		var colTag;
		if(cols>0) {
		    colTag = "col-md-" +Math.round(12/cols);
		    contents += '<div class="row-tight row">';
		}
		var colCnt = 0;
		var style = this.getTemplateStyle("");
		let noWrapper = this.getNoWrapper();
		for(var rowIdx=0;rowIdx<selected.length;rowIdx++) {
		    if(max!=-1 && rowIdx>=max) break;
		    if(cols>0) {
			if(colCnt>=cols) {
			    colCnt=0;
			    contents += '</div>\n';
			    contents += '<div class="row-tight row">\n';
			}
			contents+='<div  class="' + colTag+'">\n';
			colCnt++;
		    }
		    var record = selected[rowIdx];
		    var color = null;
                    if (colorBy.index >= 0) {
			var value =  record.getData()[colorBy.index];
			color =  colorBy.getColor(value, record);
		    }
		    let s = template;
		    let row = this.getDataValues(record);
		    if(s.trim()=="${default}") {
			s = this.getRecordHtml(record,fields,s);
		    } else  if(s.startsWith("${fields")) {
			s = this.getRecordHtml(record,fields,s);
		    } else {
			s= this.applyRecordTemplate(record, row,fields,s,props);
		    }
		    if(matchers) {
			let sv = String(s);
			fields.forEach(field=>{
			    matchers.forEach(h=>{
				sv  = h.highlight(sv,field.getId());
			    });
			});
			s = sv;
		    }



		    let macros = Utils.tokenizeMacros(s);
		    let rowAttrs = {};
		    rowAttrs["selectCount"] = selected.length;
		    rowAttrs["totalCount"] = records.length;
		    rowAttrs[RECORD_INDEX] = rowIdx+1;
		    let dataFilters = this.getTheDataFilters();
		    this.filters.forEach(f=>{
			if(!f.isEnabled() || !f.getField) return;
			rowAttrs["filter." + f.getField().getId()] =  f.getFieldValues();
		    });
		    let recordStyle = style;
		    if(color) {
			if(this.getColorBackground()) {
			    recordStyle = HU.css("background",color) + recordStyle;
			}
			rowAttrs["color"] = color;
		    }
		    if(!handleSelectOnClick)			recordStyle+=HU.css("cursor","default");
		    let tag = HU.openTag("div",[ATTR_CLASS,noWrapper?'':'display-template-record',ATTR_STYLE,recordStyle, ATTR_ID, this.getId() +"-" + record.getId(), TITLE,"",RECORD_ID,record.getId(),RECORD_INDEX, rowIdx]);
		    s = macros.apply(rowAttrs);
		    if(s.startsWith("<td")) {
			s = s.replace(/<td([^>]*)>/,"<td $1>"+tag);
			s = s.replace(/<\/td>$/,"</div></td>");
		    } else if(s.startsWith("<tr")) {
			s = s.replace(/<td([^>]*)>/g,"<td $1>"+tag);
			s = s.replace(/<\/td>/g,"</div></td>");
		    }  else {
			s = tag +s +HU.close(DIV);
		    }
		    if(toggleTemplate) {
			let t =this.applyRecordTemplate(record, row,fields,toggleTemplate,props); 
			s =  HU.toggleBlock(t, s,false);
		    }

		    if (groupByField) {
			let groupValue =groupByField.getValue(record);
			if(groupValue.getTime) groupValue = this.formatDate(groupValue);
			if(!groups[groupValue]) {
			    groupList.push(groupValue);
			    groups[groupValue] = "";
			} else {
			    groups[groupValue]+=groupDelimiter;
			}
			groups[groupValue]+=s;
		    } else {
			contents+=s;
		    }


		    if(cols>0) {
			contents+=HU.close(DIV);
		    }
		}
		if (groupByField) {
		    if(this.getPropertySortGroups(false))
			groupList = groupList.sort();
		    groupList.forEach(group=>{
			contents+=  groupTemplate.replace("${group}",group).replace("${contents}",groups[group]);
		    });
		}
		if(cols>0) {
		    contents += HU.close(DIV);
		}
	    }

	    if(selected.length>0) 
		contents+= footerTemplate;
	    this.setContents(contents,true);
	    HU.createFancyBox( this.jq(ID_DISPLAY_CONTENTS).find("a.popup_image"), {
                caption : function( instance, item ) {
		    let caption =   $(this).attr('data-caption');
		    if(!Utils.stringDefined(caption)) caption = $(this).attr(ATTR_TITLE) || '';
		    return caption;
                }});

	    this.addFieldClickHandler(null,null,false);
	    let recordElements = this.find(".display-template-record");
	    this.makeTooltips(recordElements, selected);
	    this.makePopups(recordElements, selected);
	    let _this = this;
	    if(this.getProperty('addCopyToClipboard')) {
		this.jq(ID_DISPLAY_CONTENTS).find('.display-template-record').css('cursor','pointer');
		Utils.initCopyable(this.jq(ID_DISPLAY_CONTENTS),{addLink:true,removeTags:true,removeNL:true,
								 downloadFileName:this.getProperty('copyToClipboardDownloadFile')});
	    }
	    if(handleSelectOnClick) {
		this.find(".display-template-record").click(function() {
		    var record = selected[$(this).attr(RECORD_INDEX)];
		    _this.handleEventRecordHighlight(this, {record:record,highlight:true,immediate:true,skipScroll:true});
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		});
	    }


	    if(this.getPropertyHighlightOnScroll(false)) {
		let items = this.find(".display-template-record");
		this.getContents().css('overflow-y','scroll');
		this.getContents().scroll(()=>{
		    let topElement = null;
		    items.each(function() {
			let pos  = $(this).position();
			if(pos.top<0) {
			    topElement = $(this);
			}
		    });
		    if(topElement) {
			var record = selected[topElement.attr(RECORD_INDEX)];
			if(record && this.currentTopRecord && record!=this.currentTopRecord) {
			    this.propagateEventRecordSelection({highlight:true,record: record});
			}
			this.currentTopRecord = record;
		    }
		});
	    }





	},
	highlightCount:0,
        handleEventRecordSelection: function(source, args) {
	    this.selectedRecords = args.records;
	    this.selectedRecord = args.record;
	    if(this.selectedRecord && this.getUseNearestDate() && this.myRecords) {
		this.selectedRecord = this.findClosestDate(this.selectedRecord.getDate()).record;
	    }

	    if(this.getOnlyShowSelected()) {
		this.updateUI();
	    } else {
		args.highlight = true;
		this.handleEventRecordHighlight(source, args);
	    }
	},
        handleEventRecordHighlight: function(source, args) {

	    if(this.getPropertySelectHighlight()) {
		this.selectedRecord=args.record;
		this.callUpdateUI();
		return
	    }

	    this.currentTopRecord = null;
	    let myCount = ++this.highlightCount;
	    var id = "#" + this.getId()+"-"+args.record.getId();
	    if(this.highlightedElement) {
		this.unhighlightElement(this.highlightedElement);
		this.highlightedElement = null;
	    }
//	    console.log(this.type+ " handleEventRecordHighlight " + args.highlight); 
	    if(args.highlight) {
		if(args.immediate) {
		    this.highlightElement(args);
		} else {
		    setTimeout(() =>{
			if(myCount == this.highlightCount) {
			    this.highlightElement(args);
			}
		    },100);
		}
	    } else {
		var id = "#" + this.getId()+"-"+args.record.getId();
		var element = $(id);
		this.unhighlightElement(element);
	    }
	},
	unhighlightElement: function(element) {
	    this.currentTopRecord = null;
	    element.removeClass("display-template-record-highlight");
	    var css = this.getProperty("highlightOffCss","").split(";");
	    if(css.length>0) {
		css.map(tok=>{
		    var c = tok.split(":");
		    var a = c[0];
		    var v = c.length>1?c[1]:null;
		    if(!v || v=="") {
			v = element.attr("prev-" + a);
		    }
		    if(v) {
			//			    console.log("un highlight css:" + element.css("background")+ " idx:" + element.attr(RECORD_INDEX));
			element.css(a,v);
		    }
		});
	    } 
	},
	highlightElement: function(args) {
	    let id = "#" + this.getId()+"-"+args.record.getId();
	    let element = $(id);
	    this.highlightedElement = element;
	    element.addClass("display-template-record-highlight");
	    let css = this.getProperty("highlightOnCss","").split(";");
	    if(css.length>0) {
		css.map(tok=>{
		    let c = tok.split(":");
		    let a = c[0];
		    let v = c.length>1?c[1]:null;
		    if(!v || v=="") {
			v = element.attr("prev-" + a);
		    }
		    if(v) {
			let oldV = element.css(a);
			if(oldV) {
			    element.attr("prev-" + a,oldV);
			}
			element.css(a,v);
		    }
		});
	    } 

	    try {
		if(this.getScrollOnHighlight() && !args.skipScroll) {
		    let eo = element.offset();
		    if(eo==null) return;
		    let container =  element.parent();
		    if(this.getProperty("orientation","vertical")== "vertical") {
			let c = container.offset().top;
			let s = container.scrollTop();
			container.scrollTop(eo.top- c + s)
		    } else {
			let c = container.offset().left;
			let s = container.scrollLeft();
			container.scrollLeft(eo.left- c + s)
		    }
		}

	    } catch(err) {
		console.log("Error:" + err);
	    }

	}
    })}





function RamaddaTopfieldsDisplay(displayManager, id, properties) {
    const ID_SLIDE = "slide";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TOPFIELDS, properties);
    let myProps = [
	{label:'Top Fields'},
	{p:'fieldCount',tt:''},
	{p:'labelField',tt:''},
	{p:'dateFormat',ex:'yyyy'},
	{p:'labelField'},
	{p:'scaleFont',ex:'false'}
    ]
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    var pointData = this.getData();
	    if (pointData == null) return;
	    let records = this.filterData();
	    if(!records) return;

            var fields = this.getData().getNonGeoFields();
	    var labelField = this.getFieldById(fields,this.getProperty("labelField"));
	    if(labelField==null) {
		labelField = this.getFieldById(fields, TITLE);
	    }
	    if(labelField==null) {
		labelField = this.getFieldById(fields, "name");
	    }
	    var fieldsToUse = this.getFieldsByIds(fields,this.getPropertyFields());
	    if(fieldsToUse.length==0) fieldsToUse = fields;
	    var html = "";
	    var fieldCount = +this.getProperty("fieldCount",10);
	    var dataList = [];
	    var min = Number.MAX_VALUE;
	    var max = Number.MIN_VALUE;
	    var dateFormat = this.getProperty("dateFormat");
	    for(var i=0;i<records.length;i++) {
		var record = records[i]; 
		var tuple = record.getData();
		var data =[];
		for(var j=0;j<fieldsToUse.length;j++) {
		    var field = fieldsToUse[j];
		    if(!field.isNumeric()) continue;
		    var value  =tuple[field.getIndex()];
		    if(!isNaN(value)) {
			min  = Math.min(min, value);
			max  = Math.max(max, value);
		    }
		    data.push({value: value, field: field});
		}
		data.sort((a,b)=>{
		    return b.value-a.value;
		});
		var header = labelField?tuple[labelField.getIndex()]:" Record:" + (i+1);
		if((labelField && labelField.isFieldDate()) || (typeof header =="date"))  {
		    header = Utils.formatDateWithFormat(header, dateFormat);
		}
		dataList.push({data:data,record:record,header:header});
	    }
	    var scaleFont = this.getProperty("scaleFont",true);
	    for(var i=0;i<dataList.length;i++) {
		var data = dataList[i].data;
		var record = dataList[i].record;
		var header = dataList[i].header;
		var tuple = record.getData();
		var div = "";
		var contents = "";
		for(var j=0;j<data.length && j<fieldCount;j++) {
		    var value = data[j].value;
		    var percent = max==min?1:(value-min)/(max-min);
		    var fontSize = 6+Math.round(percent*24)+"pt";
		    if(!scaleFont) fontSize = "100%";
		    var field = data[j].field;
		    contents += HU.div(["field-id",field.getId(), "data-value",field.getLabel(), TITLE,"Value: " + value, ATTR_CLASS,"display-topfields-row",ATTR_STYLE,"font-size:" + fontSize+";"], field.getLabel());
		}
		div += HU.div([ATTR_CLASS,"display-topfields-header",RECORD_INDEX,i],header);
		div += HU.div([ATTR_CLASS,"display-topfields-values"], contents);
		html+=HU.div([ATTR_CLASS,"display-topfields-record"], div);
	    }
	    this.setContents(html);
	    let _this = this;
	    this.find(".display-topfields-header").click(function(){
		var idx = $(this).attr(RECORD_INDEX);
		_this.find(".display-topfields-record").removeClass("display-topfields-selected");
		$(this).parent().addClass("display-topfields-selected");
		var record = records[idx];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    let rows =this.find(".display-topfields-row");
	    rows.hover(function() {
		rows.removeClass("display-topfields-highlight");
		var value = $(this).attr("data-value");
		_this.find(HU.attrSelect("data-value", value)).addClass("display-topfields-highlight");
		
	    });
	    rows.click(function() {
		var field = $(this).attr("field-id");
		_this.getDisplayManager().notifyEvent(DisplayEvent.fieldsSelected, _this, [field]);
		
	    });
	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    var index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    var container = this.getContents();
	    container.find(".display-topfields-record").removeClass("display-topfields-selected");
	    var element =   container.find(HU.attrSelect(RECORD_INDEX, index)).parent();
	    element.addClass("display-topfields-selected");
	    var c = container.offset().top;
	    var s = container.scrollTop();
	    var eo = element.offset();
	    var diff = eo.top- c + s;
	    container.scrollTop(diff)
	},



    })}










function RamaddaBlocksDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_BLOCKS, properties);
    const ID_BLOCKS_HEADER = "blocks_header";
    const ID_BLOCKS = "blocks";
    const ID_BLOCKS_FOOTER = "blocks_footer";
    let myProps = [
	{label:'Block'},
	{p:'animStep',d:0,ex:"1000",tt:'Animation delay (ms)'},
	{p:'doSum',d:true,ex:"false",tt:''},
	{p:'numBlocks',d:1000,ex:"1000",tt:'How many blocks to show'},
	{p:'header',d:true,ex:"Each block represents ${blockValue} ... There were a total of ${total} ...",tt:''},
	{p:'blockIcon',d:null,ex:"fa-male",tt:'Use an icon'},
	{p:'emptyBlockStyle',d:"background:transparent;border:1px solid #ccc;",tt:'Style for blocks not displayed yet'},	
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        updateUI: function() {
	    let f = this.getPropertyFields();
	    let records;
	    if(f) {
		records = this.filterData();
		if(!records) return;
	    }
	    this.counts = [];
	    this.counts2 = [];
	    if(f) {
		let fields = this.getFieldsByIds(null,f);
		if(!fields) return;
		this.footers = [];
		this.headers = [];
		let numBlocks  = this.getNumBlocks(1000);
		this.total = 0;
		fields.forEach(f=>{
		    this.footers.push("${count} " + f.getLabel());
		    let v = f.getValue(records[0]);
		    if(!isNaN(v)) this.total+=v;
		    this.counts.push(v);
		});

		if(this.total>0) {
		    this.blockValue = this.total/numBlocks;
		    this.counts.forEach(v=>{
			let percent = isNaN(v)?0:v/this.total;
			let scaledValue = percent*numBlocks;
			this.counts2.push(scaledValue);
		    });
		}
	    } else {
		//todo: set this
		this.blockValue = 0;
		let counts = this.getProperty("counts","100",true).split(";");
		for(let i=0;i<counts.length;i++) 
		    this.counts.push(parseFloat(counts[i]));
		let doSum = this.getPropertyDoSum();
		if(doSum) {
		    this.counts2 = this.counts;
		} else {
		    this.total = 0;
		    for(let i=0;i<this.counts.length;i++) {
			let tmp = this.counts[i];
			this.counts2.push(this.counts[i]-this.total);
			this.total+= tmp;
		    }
		}
		this.footers = this.getProperty("footers","",true).split(";");
		this.headers = this.getProperty("headers","",true).split(";");
	    }
	    while(this.footers.length< this.counts.length)
		this.footers.push("");
	    while(this.headers.length< this.counts.length)
		this.headers.push("");
	    this.setContents(
		HU.div([ATTR_CLASS,"display-blocks-header",ATTR_STYLE, this.getProperty("headerStyle","", true),ATTR_ID,this.domId(ID_BLOCKS_HEADER)]) +
		    HU.div([ATTR_CLASS,"display-blocks-blocks",ATTR_ID,this.domId(ID_BLOCKS)],"")+
		    HU.div([ATTR_CLASS,"display-blocks-footer", ATTR_STYLE, this.getProperty("footerStyle","", true), ATTR_ID,this.domId(ID_BLOCKS_FOOTER)]));
	    //Show the outline
	    this.showBlocks(true);
	    if(this.getProperty("displayOnScroll")) {
		HU.callWhenScrolled(this.domId(ID_DISPLAY_CONTENTS),()=>{
		    if(!this.displayedBlocks) {
			this.displayedBlocks = true;
			if(this.timeout)
			    clearTimeout(this.timeout);
			this.tmeout = setTimeout(()=>{this.showBlocks(false)},this.getPropertyAnimStep());
		    }
		},500);
	    }  else {
		this.showBlocks(false);
	    }
	},
	showBlocks: function(initial, step) {
	    if(!Utils.isDefined(step)) {
		if(initial)step = this.counts.length;
		else step = 0;
	    }
	    let contents = "";
	    contents += HU.openDiv([ATTR_CLASS,"display-blocks"]);
	    let tmp =this.getProperty("colors","#d73027,#fdae61,#74add1,#423E3B,red,green,blue",true); 
	    let ct = (typeof tmp) =="string"?tmp.split(","):tmp;
	    let footer ="";
	    while(ct.length<this.counts.length) {
		ct.push(ct[ct.length-1]);
	    }

	    let divider = parseFloat(this.getProperty("divider","1",true));
	    let dim=this.getProperty("blockDimensions","8",true);
	    let labelStyle = this.getProperty("labelStyle","", true);
	    let blockCnt = 0;
	    let iconProp = this.getProperty("blockIcon");
	    let clazz = iconProp?"display-block-icon":"display-block";
	    let emptyStyle = this.getEmptyBlockStyle();
	    for(let i=0;i<this.counts2.length;i++) {
		let num = this.counts[i];
		if(isNaN(num)) num = 0;
		let label = this.footers[i].replace("${count}",Utils.formatNumberComma(num));
		let style =  iconProp?"":"width:" + dim+"px;height:" + dim+"px;";
		let iconStyle = "";
		if(!initial) {
		    if(i<step) {
			if(!iconProp)
			    style += HU.css("background", ct[i]);
			else
			    iconStyle+=HU.css("color" ,ct[i]);
			let footerIcon =  iconProp?HU.getIconImage(iconProp, null, [ATTR_STYLE, iconStyle]):"";
			footer += HU.div([ATTR_CLASS,clazz,ATTR_STYLE,style],footerIcon) +" " + HU.span([ATTR_STYLE,labelStyle], label)+"&nbsp;&nbsp;";
		    } else {
			if(iconProp)
			    style += HU.css("background","transparent");
			else
			    style += HU.css("background","transparent","border","1px solid #ccc");			    			
			footer += "&nbsp;&nbsp;";
		    }
		} else {
		    style+=emptyStyle;
		}
		let icon = iconProp?HU.getIconImage(iconProp, null, [ATTR_STYLE, iconStyle]):"";
		let cnt = this.counts2[i]/divider;
		for(let j=0;j<10000 && j<cnt;j++) {
		    contents += HU.div([ATTR_CLASS,clazz,ATTR_STYLE,style,TITLE,label],icon);
		}
		blockCnt++;
	    }
	    contents += HU.closeDiv();
	    let header = this.getProperty("header","");
	    header = header.replace("${divider}",divider).replace("${total}",Utils.formatNumberComma(this.total)).replace("${blockValue}", Utils.formatNumberComma(Math.round(this.blockValue)));

	    this.jq(ID_BLOCKS_HEADER).html(header);
	    this.jq(ID_BLOCKS).html(contents);
	    this.jq(ID_BLOCKS_FOOTER).html(footer);
	    if(step < this.counts.length) {
		if(!this.getPropertyAnimStep()) {
		    this.showBlocks(false, step+1);
		} else {
		    if(this.timeout)
			clearTimeout(this.timeout);
		    this.timeout = setTimeout(()=>{this.showBlocks(false, step+1)},this.getPropertyAnimStep());
		}
	    }
	}
    });
}





function RamaddaTextstatsDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTSTATS, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        updateUI: function() {
            let cnt = {};
            let fieldInfo = this.processText(cnt);
            if (fieldInfo == null) return;
            let records = this.filterData();
            let allFields = this.getData().getRecordFields();
            let fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;

            let strings = this.getFieldsByType(fields, "string");
            let _this = this;
            let divs = "";
            let words = [];
            let html = "";
            let counts = [];
            let maxWords = parseInt(this.getProperty("maxWords", -1));
            let minCount = parseInt(this.getProperty("minCount", 0));
            let showBars = this.getProperty("showBars", true);
            let scale = this.getProperty("barsScale", 10);
            let barColor = this.getProperty("barColor", "blue");
            let barWidth = parseInt(this.getProperty("barWidth", "400"));
            for (a in fieldInfo) {
                let fi = fieldInfo[a];
                let field = fi.field;
                for (word in fi.counts) {
                    let count = fi.counts[word];
                    counts.push({
                        word: word,
                        count: count
                    });
                }
                counts.sort(function(a, b) {
                    if (a.count < b.count) return -1;
                    if (a.count > b.count) return 1;
                    return 0;
                });
                if (minCount > 0) {
                    let tmp = [];
                    for (let i = 0; i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                if (maxWords > 0) {
                    let tmp = [];
                    for (let i = 0; i <= maxWords && i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                let min = 0;
                let max = 0;
                if (counts.length > 0) {
                    max = counts[0].count;
                    min = counts[counts.length - 1].count;
                }

                let tmp = [];
                for (a in cnt.lengths) {
                    tmp.push({
                        length: parseInt(a),
                        count: cnt.lengths[a]
                    });
                }
                tmp.sort(function(a, b) {
                    if (a.length < b.length) return -1;
                    if (a.length > b.length) return 1;
                    return 0;
                });
                min = 0;
                max = 0;
                for (let i = 0; i < tmp.length; i++) {
                    max = (i == 0 ? tmp[i].count : Math.max(max, tmp[i].count));
                    min = (i == 0 ? tmp[i].count : Math.min(min, tmp[i].count));
                }
                if (this.getProperty("showFieldLabel", true))
                    html += HU.b(fi.field.getLabel()) + "<br>";
                let td1Width = "20%";
                let td2Width = "10%";
                if (this.getProperty("showSummary", true)) {
                    html += HU.openTag("table", [ATTR_CLASS, "nowrap ramadda-table", ATTR_ID, this.domId("table_summary")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Summary") + HU.th([], "&nbsp;"));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    html += HU.tr([], HU.td(["align", "right"], "Total lines:") + HU.td([], records.length));
                    html += HU.tr([], HU.td(["align", "right"], "Total words:") + HU.td([], cnt.count));
                    html += HU.tr([], HU.td(["align", "right"], "Average word length:") + HU.td([], Math.round(cnt.total / cnt.count)));
                    html += HU.closeTag("tbody");

                    html += HU.closeTag("table");
                    html += "<br>"
                }
                if (this.getProperty("showCounts", true)) {
                    html += HU.openTag("table", [ATTR_CLASS, "row-border nowrap ramadda-table", ATTR_ID, this.domId("table_counts")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Word Length") + HU.th(["width", td2Width], "Count") + (showBars ? HU.th([], "") : ""));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    for (let i = 0; i < tmp.length; i++) {
                        let row = HU.td([], tmp[i].length) + HU.td([], tmp[i].count);
                        if (showBars) {
                            let wpercent = (tmp[i].count - min) / max;
                            let width = 2 + wpercent * barWidth;
                            let color = barColor;
                            let div = HU.div([ATTR_STYLE, "height:10px;width:" + width + "px;background:" + color], "");
                            row += HU.td([], div);
                        }
                        html += HU.tr([], row);
                    }
                    html += HU.closeTag("tbody");
                    html += HU.closeTag("table");
                    html += "<br>"
                }
                if (this.getProperty("showFrequency", true)) {
                    html += HU.openTag("table", [ATTR_CLASS, "row-border ramadda-table", ATTR_ID, this.domId("table_frequency")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Word") + HU.th(["width", td2Width], "Frequency") + (showBars ? HU.th([], "") : ""));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    let min = 0;
                    let max = 0;
                    if (counts.length > 0) {
                        min = counts[0].count;
                        max = counts[counts.length - 1].count;
                    }
                    let totalWords = 0;
                    for (let i = 0; i < counts.length; i++) {
                        totalWords += counts[i].count;
                    }
                    for (let i = counts.length - 1; i >= 0; i--) {
                        let percent = Math.round(10000 * (counts[i].count / totalWords)) / 100;
                        let row = HU.td([], counts[i].word + "&nbsp;:&nbsp;") +
                            HU.td([], counts[i].count + "&nbsp;&nbsp;(" + percent + "%)&nbsp;:&nbsp;");
                        if (showBars) {
                            let wpercent = (counts[i].count - min) / max;
                            let width = 2 + wpercent * barWidth;
                            let color = barColor;
                            let div = HU.div([ATTR_STYLE, "height:10px;width:" + width + "px;background:" + color], "");
                            row += HU.td([], div);
                        }
                        html += HU.tr([], row);
                    }
                    html += HU.closeTag("tbody");
                    html += HU.closeTag("table");
                }
            }
            this.setContents(html);
            let tableHeight = this.getProperty("tableHeight", "200");

            if (this.getProperty("showSummary", true))
                HU.formatTable("#" + this.domId("table_summary"), {
                    scrollY: this.getProperty("tableSummaryHeight", tableHeight)
                });
            if (this.getProperty("showCounts", true))
                HU.formatTable("#" + this.domId("table_counts"), {
                    scrollY: this.getProperty("tableCountsHeight", tableHeight)
                });
            if (this.getProperty("showFrequency", true)) {
                HU.formatTable("#" + this.domId("table_frequency"), {
		    scrollY: this.getProperty("tableFrequenecyHeight", tableHeight),
		    searching: this.getProperty("showSearch", true)
		}, table =>{
		    this.frequencyTable = table;
		    this.frequencyTable.on( 'search.dt', ()=>{
			if(this.settingSearch) return;
			this.propagateEvent(DisplayEvent.propertyChanged, {
			    property: "searchValue",
			    value: this.frequencyTable.search()
			});
		    });
		});
	    }
        },
        handleEventPropertyChanged: function(source, prop) {
            if (prop.property == "searchValue") {
		this.settingSearch=true;
		this.setProperty("searchValue", prop.value);
		this.frequencyTable.search(prop.value);
		this.frequencyTable.draw();
		this.settingSearch=false;
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this,source, prop);
	},

    });
}



function RamaddaFrequencyDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_FREQUENCY, properties);
    let myProps = [
	{label:'Frequency'},
	{p:'orientation',ex:'vertical'},
	{p:'tableHeight',ex:'300px'},
	{p:'showPercent',ex:'false'},
	{p:'showCount',ex:'false'},
	{p:'showBars',ex:'true'},
	{p:'showBars',ex:'false'},
	{p:'showHeader',ex:'false'},
	{p:'banner',ex:'true'},
	{p:'barWidth',ex:'200'},
	{p:'clickFunction',ex:'selectother'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        updateUI: function() {
            let records = this.filterData();
	    if(!records) return;
            let allFields = this.getData().getRecordFields();
            let fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
	    let summary={};
	    for (let col = 0; col < fields.length; col++) {
		let f = fields[col];
		if(!Utils.isDefined(summary[f.getId()])) {
		    summary[f.getId()] = {
			counts:{},
			values:[],
			min:null,
			max:null,
			total:0,
			numbers:[],
			field:f
		    }
		}
	    }

	    let showCount = this.getProperty("showCount",true);
	    let showPercent = this.getProperty("showPercent",true);
	    let showBars = this.getProperty("showBars",false);
	    let barWidth = +this.getProperty("barWidth",200);

            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                for (let col = 0; col < fields.length; col++) {
                    let f = fields[col];
		    let s = summary[f.getId()];
                    let value =  row[f.getIndex()];
		    if(!Utils.isDefined(s.min)) {
			s.min=value;
			s.max=value;
		    }
		    if(f.isNumeric()) {
			s.numbers.push(value);
			if(isNaN(s.max)) s.max = value;
			else if(!isNaN(value))s.max = Math.max(value,s.max);
			if(isNaN(s.min)) s.min = value;
			else if(!isNaN(value))s.min = Math.min(value,s.min);
		    } else {
			if(!Utils.isDefined(s.counts[value])) {
			    let tuple = {value:value,count:0}
			    s.counts[value] = tuple;
			    s.values.push(tuple);
			}
			s.total++;
			s.counts[value].count++;
		    }
                }
	    }
	    let html = "";
	    let bannerHtml = "";
	    for (let col = 0; col < fields.length; col++) {
		bannerHtml += "<div style='text-align:center;'>";
		let f = fields[col];
		let s = summary[f.getId()];
		//		if(col>0) html+="<br>";
		if(f.isNumeric()) {
		    let numBins = parseFloat(this.getProperty("numBins",10,true));
		    s.bins = [];
		    let range = s.max-s.min;
		    let binWidth = (s.max-s.min)/numBins;
		    let label = "Not defined";
		    s.bins.push(label);
		    let tuple = {value:label,count:0}
		    s.counts[label] = tuple;
		    s.values.push(tuple);
                    let binsProp = this.getProperty(f.getId() +".bins");
		    let hasBins = Utils.stringDefined(binsProp);
		    let binValues;
                    if(hasBins) {
                        let l  = binsProp.split(",");
			binValues = [];
			l.map(v=>binValues.push(+v));
                        for(let i=0;i<l.length-1;i++) {
			    let v1 = +l[i];
			    let v2 = +l[i+1];
			    let label = v1 +" - " + v2;
			    s.bins.push(label);
			    let tuple = {value:label,count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
                        }
		    } else {
			for(let i=0;i<numBins;i++) {
			    let label = (Utils.formatNumber(s.min+binWidth*i)) +" - " + Utils.formatNumber(s.min+binWidth*(i+1));
			    s.bins.push(label);
			    let tuple = {value:label,count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
			}
		    }
		    for(let i=0;i<s.numbers.length;i++) {
			let value = s.numbers[i];
			let bin=0;
			if(!isNaN(value)) {
			    if(binValues) {
				for(let j=0;j<binValues.length-1;j++) {
				    if(value>=binValues[j] && value< binValues[j+1]) {
					bin = j;
					break;
				    }
				}
			    } else {
				if(binWidth!=0) {
				    let perc = (value-s.min)/range;
				    bin = Math.round(perc/(1/numBins))+1;
				    if(bin>numBins) bin = numBins;
				}
			    }
			}
			let label = s.bins[bin]; 
			if(!Utils.isDefined(s.counts[label])) {
			    let tuple = {value:s.bins[bin],count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
			}
			s.total++;
			s.counts[label].count++;
		    }
		}

		let hor = this.getProperty("orientation","") != "vertical";
		if(this.getProperty("floatTable") !=null) {
		    hor = this.getProperty("floatTable")==true;
		}
		html += HU.openTag("div", [ATTR_CLASS,"display-frequency-table",ATTR_STYLE,hor?"":"display:block;"]);
		html += HU.openTag("table", ["cellpadding","3",ATTR_ID,this.domId("summary"+col),"table-height",this.getProperty("tableHeight","300",true), ATTR_CLASS, "stripe row-border nowrap ramadda-table"]);
		if(this.getProperty("showHeader",true)) {
		    html += HU.openTag("thead", []);
		    let label =  HU.span([TITLE,"Click to reset",ATTR_CLASS,"display-frequency-label","data-field",s.field.getId()],f.getLabel());

		    
		    label = HU.div([ATTR_STYLE,"max-width:500px;overflow-x:auto;"], label);
		    let count = showCount? HU.th(["align","right","width","20%"],HU.div([ATTR_STYLE,"text-align:right"],"Count")):"";
		    let percent  = showPercent?HU.th(["align","right","width","20%"],  HU.div([ATTR_STYLE,"text-align:right"],"Percent")):"";
		    let bars = showBars? HU.th(["align","right","width",barWidth],HU.div([ATTR_STYLE,"text-align:right"],"&nbsp;")):"";
		    html += HU.tr([], HU.th(["xxwidth","60%"],  label+ count+ percent+bars));
		    html += HU.closeTag("thead");
		}

		html += HU.openTag("tbody", []);
		let colors = this.getColorTable(true);
		let dfltColor = this.getProperty("barColor","blue");
		if(colors) {
		    for(let i=0;i<s.values.length;i++) {
			let value = s.values[i].value;
			if(i<colors.length)
			    s.values[i].color = colors[i];
			else
			    s.values[i].color = colors[colors.length-1];
		    }
		}

	    	if(!f.isNumeric()) {
		    s.values.sort((a,b)=>{
			if(a.count<b.count) return 1;
			if(a.count>b.count) return -1;
			return 0;
		    });
		}

		let maxPercent = 0;
		for(let i=0;i<s.values.length;i++) {
		    let count = s.values[i].count;
		    if(count==0) continue;
		    let perc = count/s.total;
		    maxPercent = Math.max(maxPercent, perc);
		}

//		let csv = '';
		for(let i=0;i<s.values.length;i++) {
		    let value = s.values[i].value;
		    let label = value;
		    if(label=="") label="&lt;blank&gt;";
		    let count = s.values[i].count;
		    if(count==0) continue;
		    let perc = count/s.total;
		    value = value.replace(/\'/g,"&apos;");
		    let countLabel = count
		    let color = s.values[i].color;
		    if(!color) color = dfltColor;

		    if(showPercent) countLabel+=" (" + Math.round(perc*100)+"%)";
//		    csv+=value+','+perc+'\n';

		    bannerHtml += HU.div([TITLE,"Click to select",ATTR_CLASS," display-frequency-item","data-field",s.field.getId(),"data-value",value], value +"<br>" + countLabel);
		    let tdv = HU.td([], value);
		    let tdc =  (showCount?HU.td(["align", "right"], count):"");
		    let tdp =  showPercent?HU.td(["align", "right"], s.total==0?"0":Math.round(perc*100)+"%"):"";
		    let bw = perc/maxPercent;
		    let tdb = showBars?HU.td(["valign","center","width",barWidth], HU.div([TITLE,Math.round(perc*100)+"%",ATTR_STYLE,"background:" + color+";height:10px;width:"+ (Math.round(bw*barWidth))+"px"],"")):"";
		    html += HU.tr([], 
					 tdv + tdc + tdp + tdb
					);
		}
//		Utils.makeDownloadFile('percents.csv',csv);

		html += HU.close(TBODY,TABLE,DIV);
		bannerHtml += HU.close(TD);
	    }

	    let doBanner = this.getProperty("banner",false);
	    if(doBanner) html = HU.div([ATTR_CLASS,"display-frequency-banner"], bannerHtml);
	    this.setContents(html);
	    let _this = this;
	    let cnt = 0;
	    let items = this.find(".display-frequency-item");
	    items.click(function(){
		let click = _this.getProperty("clickFunction")
		let value = $(this).attr("data-value");
		let fieldId = $(this).attr("data-field");
		let parent = $(this).parent();
		let isSelected = $(this).hasClass("display-frequency-item-selected");
		items.removeClass("display-frequency-item-selected");
		if(!isSelected) {
		    $(this).addClass("display-frequency-item-selected");
		} else {
		    value = FILTER_ALL;
		}
		if(!click || click =="select") {
		    _this.handleEventPropertyChanged(_this,{
			property: "pattern",
			fieldId: fieldId,
			value: value
		    });
		} else if(click == "selectother") {
		    _this.propagateEvent(DisplayEvent.fitlerChanged, {
			value: value,
			id:_this.getFilterId(fieldId),
			fieldId: fieldId,
		    });
		}
	    });
	    this.find(".display-frequency-label").click(function(){
		let field = $(this).attr("data-field");
		//		    _this.find("[data-field=" + field+"]").css("color","black");
		_this.handleEventFilterChanged(_this,{
		    id:ATTR_ID,
		    fieldId: field,
		    value: "-all-"
		});
	    });

	    if(this.getProperty("showHeader",true)) {
		for (let col = 0; col < fields.length; col++) {
		    HU.formatTable("#" +this.domId("summary"+col),{});
		}
	    }
	}
    });
}

function RamaddaTextanalysisDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTANALYSIS, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
            var includes = "<script src='" + RamaddaUtil.getCdnUrl("/lib/compromise.min.js")+"'></script>";
            this.writeHtml(ID_DISPLAY_TOP, includes);
            let _this = this;
            var func = function() {
		if(window.nlp) {
                    _this.updateUIInner();
		} else {
		    setTimeout(func, 100);
		}
            };
            setTimeout(func, 100);
        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            let _this = this;
            this.setDisplayMessage("Processing text...");
            var func = function() {
                _this.updateUIInnerInner();
            };
            setTimeout(func, 10);
        },
        updateUIInnerInner: function() {
            let records = this.filterData();
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
	    var strings = this.getFieldsByIds(fields,"fields");
            if (strings.length == 0) {
		strings = this.getFieldsByType(fields, "string");
	    }
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
	    if(!this.lastRecords || this.lastRecords.length!= records.length) {
		this.lastRecords = records;
		var corpus = "";
		for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                    var row = this.getDataValues(records[rowIdx]);
                    var line = "";
                    for (var col = 0; col < strings.length; col++) {
			var f = fields[col];
			line += " ";
			line += row[f.getIndex()];
                    }
                    corpus += line;
		    corpus += "\n";
		}
		//		console.log("corpus:" + corpus.length +"\n" + corpus.substring(0,1000));
		this.nlp = window.nlp(corpus);
		//		console.log("after");
	    }
	    var nlp = this.nlp;
            var cols = [];
            if (this.getProperty("showPeople", false)) {
                cols.push(this.printList("People", nlp.people().out('topk')));
            }
            if (this.getProperty("showPlaces", false)) {
                cols.push(this.printList("Places", nlp.places().out('topk')));
            }
            if (this.getProperty("showOrganizations", false)) {
                cols.push(this.printList("Organizations", nlp.organizations().out('topk')));
            }
            if (this.getProperty("showTopics", false)) {
                cols.push(this.printList("Topics", nlp.topics().out('topk')));
            }
            if (this.getProperty("showNouns", false)) {
                cols.push(this.printList("Nouns", nlp.nouns().out('topk')));
            }
            if (this.getProperty("showVerbs", false)) {
                cols.push(this.printList("Verbs", nlp.verbs().out('topk')));
            }
            if (this.getProperty("showAdverbs", false)) {
                cols.push(this.printList("Adverbs", nlp.adverbs().out('topk')));
            }
            if (this.getProperty("showAdjectives", false)) {
                cols.push(this.printList("Adjectives", nlp.adjectives().out('topk')));
            }
            if (this.getProperty("showClauses", false)) {
                cols.push(this.printList("Clauses", nlp.clauses().out('topk')));
            }
            if (this.getProperty("showContractions", false)) {
                cols.push(this.printList("Contractions", nlp.contractions().out('topk')));
            }
            if (this.getProperty("showPhoneNumbers", false)) {
                cols.push(this.printList("Phone Numbers", nlp.phoneNumbers().out('topk')));
            }
            if (this.getProperty("showValues", false)) {
                cols.push(this.printList("Values", nlp.values().out('topk')));
            }
            if (this.getProperty("showAcronyms", false)) {
                cols.push(this.printList("Acronyms", nlp.acronyms().out('topk')));
            }
            if (this.getProperty("showNGrams", false)) {
                cols.push(this.printList("NGrams", nlp.ngrams().out('topk')));
            }
            if (this.getProperty("showDates", false)) {
                cols.push(this.printList("Dates", nlp.dates().out('topk')));
            }
            if (this.getProperty("showQuotations", false)) {
                cols.push(this.printList("Quotations", nlp.quotations().out('topk')));
            }
            if (this.getProperty("showUrls", false)) {
                cols.push(this.printList("URLs", nlp.urls().out('topk')));
            }
            if (this.getProperty("showStatements", false)) {
                cols.push(this.printList("Statements", nlp.statements().out('topk')));
            }
            if (this.getProperty("showTerms", false)) {
                cols.push(this.printList("Terms", nlp.terms().out('topk')));
            }
            if (this.getProperty("showPossessives", false)) {
                cols.push(this.printList("Possessives", nlp.possessives().out('topk')));
            }
            if (cols.length == 0) {
                this.setDisplayMessage("No text types specified");
                return;
            }
            var height = this.getProperty("height", "400");
            var html = HU.openTag("div", [ATTR_ID, this.domId("tables")]);

            for (var i = 0; i < cols.length; i += 3) {
                var c1 = cols[i];
                var c2 = i + 1 < cols.length ? cols[i + 1] : null;
                var c3 = i + 2 < cols.length ? cols[i + 2] : null;
                var width = c2 ? (c3 ? "33%" : "50%") : "100%";
                var style = "padding:5px";
                var row = "";
                row += HU.td(["width", width], HU.div([ATTR_STYLE, style], c1));
                if (c2)
                    row += HU.td(["width", width], HU.div([ATTR_STYLE, style], c2));
                if (c3)
                    row += HU.td(["width", width], HU.div([ATTR_STYLE, style], c3));
                html += HU.tag("table", ["width", "100%"], HU.tr(row));
            }
            html += HU.closeTag("div");
            this.setContents(html);
            HU.formatTable("#" + this.domId("tables") + " .ramadda-table", {
                scrollY: this.getProperty("tableHeight", "200")
            });
        },
        printList: function(title, l) {
            var maxWords = parseInt(this.getProperty("maxWords", 10));
            var minCount = parseInt(this.getProperty("minCount", 0));
            var table = HU.openTag("table", ["width", "100%", ATTR_CLASS, "stripe hover ramadda-table"]) + HU.openTag("thead", []);
            table += HU.tr([], HU.th([], title) + HU.th([], "&nbsp;"));
            table += HU.close(THEAD);
            table += HU.open(TBODY);
            var cnt = 0;
            for (var i = 0; i < l.length; i++) {
                if (l[i].count < minCount) continue;
                var row = HU.td([], l[i].normal) +
                    HU.td([], l[i].count + " (" + l[i].percent + "%)");
                table += HU.tr([], row);
                if (cnt++ > maxWords) break;
            }
            table += HU.close(TBODY,TABLE);
            return table;
        }
    });
}


function RamaddaTextrawDisplay(displayManager, id, properties) {
    const ID_TEXT = "text";
    const ID_OVERLAY = "overlay";
    const ID_OVERLAY_TABLE = "overlaytable";
    const ID_LABEL = "label";
    const ID_SEARCH = "search";
    const ID_HIGHLIGHT = "highlight"; 
    const ID_SHRINK = "shrink";
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTRAW, properties);
    let myProps = [
	{label:'Raw Text'},
	{p:'doBubble',ex:'true'},
	{p:'addLineNumbers',ex:'false'},
	{p:'labelTemplate',ex:'${lineNumber}'},
	{p:'maxLines',ex:'1000'},
	{p:'pattern',ex:'initial search pattern'},
	{p:'fromField',ex:''},
	{p:'linesDescriptor',ex:''},
	{p:'asHtml',ex:'false'},
	{p:'breakLines',ex:'true'},
	{p:'includeEmptyLines',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	doShrink: properties["initialShrink"],
        checkLayout: function() {
            this.updateUI();
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            let pointData = this.getData();
            this.allRecords = pointData.getRecords();
            let pattern = this.getProperty("pattern");
            if (pattern && pattern.length == 0) pattern = null;
	    if(pattern) pattern = pattern.replace(/"/g,"&quot;");
	    let input = "";
	    if(!this.filters || this.filters.length==0) 
		input += " " + HU.input("pattern", (pattern ? pattern : "") ,
					[ATTR_PLACEHOLDER, "Search text",
					 ATTR_ID, this.domId(ID_SEARCH)]);
	    this.showShrink = this.getProperty("showShrink",false);
	    if(this.showShrink) {
		input += " " + HU.checkbox("shrink",[ATTR_ID,this.domId(ID_SHRINK)], this.getProperty("initialShrink", true)) +" Shrink ";
	    }

            this.writeHtml(ID_TOP_RIGHT, HU.span([ATTR_ID,this.domId(ID_LABEL)]," ") + input);
            let _this = this;
	    this.jq(ID_SHRINK).click(function() {
		_this.doShrink = _this.jq(ID_SHRINK).is(':checked');
		_this.setProperty("initialShrink",_this.doShrink);
		_this.updateUI();
	    });
            this.jq(ID_SEARCH).keypress(function(event) {
                if (event.which == 13) {
                    _this.setProperty("pattern", $(this).val());
		    _this.propagateEvent(DisplayEvent.propertyChanged, {
			property: "pattern",
			value: $(this).val()
		    });
                    _this.updateUI();
                }
            });
            var height = this.getProperty("height", "600");
	    var style = this.getProperty("displayInnerStyle","");
            var html = HU.div([ATTR_ID, this.domId(ID_TEXT), ATTR_STYLE, "padding:4px;border:1px #ccc solid; max-height:" + height + "px;overflow-y:auto;" + style]);
            this.setContents(html);
	    let t1 = new Date();
            this.showText();
	    let t2 = new Date();
//	    Utils.displayTimes("T",[t1,t2]);
        },
        handleEventPropertyChanged: function(source, prop) {
            if (prop.property == "pattern") {
		this.setProperty("pattern", prop.value);
		this.updateUI();
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this,source, prop);
	},

        showText: function() {
	    let _this  = this;
            let records = this.filterData();
            if (!records) {
                return null;
            }
	    this.records = records;
 	    this.recordToIndex = {};
	    this.indexToRecord = {};
            let pattern = this.getProperty("pattern");
            if (pattern && pattern.length == 0) pattern = null;
	    let asHtml = this.getProperty("asHtml", true);
            let addLineNumbers = this.getProperty("addLineNumbers", true);
	    let labelTemplate = this.getProperty("labelTemplate","");
	    let labelWidth = "10px";
	    if(labelTemplate == "") {
		labelWidth = "1px";
	    }
	    if(labelTemplate == "" && addLineNumbers) {
		labelTemplate = "${lineNumber}";
	    }

            if (labelTemplate) asHtml = true;
            var maxLines = parseInt(this.getProperty("maxLines", 100000));
            var lineLength = parseInt(this.getProperty("lineLength", 10000));
            var breakLines = this.getProperty("breakLines", true);


            var includeEmptyLines = this.getProperty("includeEmptyLines", false);
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
	    var highlights;
	    var highlightStyles;
	    if(this.getProperty("highlights")) {
		highlights=[];
		highlightStyles = this.getProperty("highlightStyles","background:rgb(250_comma_0_comma_0);").split(",");
		this.getProperty("highlights","").split(",").map(h=>{
		    if(h.indexOf("(")<0) h = "(" + h +")";
		    highlights.push(RegExp(h,'ig'));
		});
	    }

            var corpus = HU.openTag("div", [ATTR_STYLE,"position:relative;"]);
	    corpus+=HU.div([ATTR_ID,this.domId(ID_OVERLAY),ATTR_STYLE,"position:absolute;top:0;left:0;"],
				  HU.tag("table",[ATTR_ID,this.domId(ID_OVERLAY_TABLE)]));

	    var fromField = this.getFieldById(null,this.getProperty("fromField"));
	    var bubble=this.getProperty("doBubble",false);
            if (labelTemplate) {
                corpus += "<table width=100%>";
            }
            var lineCnt = 0;
            var displayedLineCnt = 0;
	    var patternMatch = new TextMatcher(pattern);
	    var regexpMaps = {};
	    var filterFieldMap = {};
	    if(this.filters) {
		this.filters.map(f=>{if(f.field && f.field.isString)filterFieldMap[f.field.getId()]=f;});
	    }
	    var templates = {};
	    fields.map(f=>{
		templates[f.getId()] = this.getProperty(f.getId() +".template");
	    });
            var colorBy = this.getColorByInfo(records);
	    var delimiter = this.getProperty("delimiter","");
	    var rowScale = this.showShrink?this.getProperty("rowScale",0.3):null;

	    if(this.showShrink) {
		corpus+=HU.tr([],HU.td([],HU.getIconImage("fa-caret-down")));
	    }
	    let templateFields = this.getFields();
	    let templateProps = this.getTemplateProps(templateFields);	    
	    let templateMacros = Utils.tokenizeMacros(labelTemplate?labelTemplate:"");
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
		var record = records[rowIdx];
		if(!Utils.isDefined(record.lineNumber)) {
		    record.lineNumber = (rowIdx+1);
		}
		this.indexToRecord[rowIdx] = record;
		this.recordToIndex[record.getId()] = rowIdx;
                var row = this.getDataValues(record);
                var line = "";
                for (var col = 0; col < fields.length; col++) {
                    var f = fields[col];
		    if(rowIdx==0) {
			if(filterFieldMap[f.getId()]) {
			    let filter = filterFieldMap[f.getId()];
			    var value = filter.getFieldValues();
			    if(value) {
				if(!Array.isArray(value)) {
				    value = [value];
				}
				try {
				    regexpMaps[f.getId()] =  [];
				    value.map(v=>{
					if(v == "" || v == FILTER_ALL) return;
					var re = new TextMatcher(v);
					regexpMaps[f.getId()].push(re);
				    })
				} catch(e) {console.log("Error making regexp:" + e);}
			    }
			}
		    }
		    var value = ""+row[f.getIndex()];
                    value = value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
		    if(regexpMaps[f.getId()]) {
			regexpMaps[f.getId()].map(re=>{
			    value  = re.highlight(value);
			});
		    }
		    
		    if(line!="") 
			line += delimiter+" ";
		    if(templates[f.getId()]) {
			value = templates[f.getId()].replace("${value}",value);
		    }
                    line += value;
                }
                line = line.trim();
                if (!includeEmptyLines && line.length == 0) continue;
                lineCnt++;
		var rowAttrs =["valign", "top"];
		var rowStyle="";
                if (colorBy.index >= 0) {
		    var value = record.getData()[colorBy.index];
		    var color =  colorBy.getColor(value, record);
		    if(color) {
			rowAttrs.push(ATTR_STYLE);
			rowStyle +="background:" + Utils.addAlphaToColor(color,"0.25")+";";
		    }
                }
		rowAttrs.push(ATTR_CLASS);
		rowAttrs.push("display-raw-row");
		let matches=patternMatch.matches(line);
		let hasMatch = matches && patternMatch.hasPattern();
		if(hasMatch) {
		    rowAttrs.push("matched");
		    rowAttrs.push(true);
		}
		if(rowScale) {
		    if(!hasMatch) {
			rowStyle += "-webkit-transform: scale(1," + rowScale +");";
			rowStyle += "line-height:"+ rowScale +";";
			rowAttrs.push(ATTR_STYLE);
			rowAttrs.push(rowStyle);
		    }
		} else  if(!matches) {
		    continue;
		}
                line = patternMatch.highlight(line);
                displayedLineCnt++;
                if (displayedLineCnt > maxLines) break;
		let lineAttrs = [TITLE," ",ATTR_CLASS, " display-raw-line ",RECORD_INDEX,rowIdx]
		if(bubble) line = HU.div([ATTR_CLASS,"ramadda-bubble"],line);
		if(fromField) line+=HU.div([ATTR_CLASS,"ramadda-bubble-from"],  ""+row[fromField.getIndex()]);

		if(highlights) {
		    for(var hi=0;hi<highlights.length;hi++) {
			var h = highlights[hi];
			var s = hi<highlightStyles.length?highlightStyles[hi]:highlightStyles[highlightStyles.length-1];
			s = s.replace(/_comma_/g,",");
			line= line.replace(h, "<span style='" + s +"'>$1</span>");
		    }
		}
		line = HU.div(lineAttrs,line);
                if (labelTemplate) {
		    let row = this.getDataValues(record);
		    let label = this.applyRecordTemplate(record, row, templateFields,labelTemplate, templateProps,templateMacros);
		    var num = record.lineNumber;
		    if(!Utils.isDefined(num)) {
			num - lineCnt;
		    }
		    label = label.replace("${lineNumber}", "#" +(num));
		    label = label.replace(/ /g,"&nbsp;");
		    var r =  "";
		    if(this.showShrink) {
			r+= HU.td([WIDTH, "5px",ATTR_STYLE,HU.css('background','#ccc')],  HU.getIconImage("fa-caret-right",null, [ATTR_STYLE,"line-height:0px;"]));
		    }
		    r+= HU.td([WIDTH, labelWidth], "<a name=line_" + lineCnt + "></a>" +
				     "<a href=#line_" + lineCnt + ">" + label + "</a>&nbsp;  ") +
			HU.td([], line);
		    corpus += HU.tr(rowAttrs, r);
                } else {
                    corpus += line;
                    if (asHtml) {
                        if (breakLines)
                            corpus += "<p>";
                        else
                            corpus += "<br>";
                    } else {
                        corpus += "\n";
                        if (breakLines)
                            corpus += "\n";
                    }
                }
            }
            if (addLineNumbers) {
                corpus += HU.close(TABLE);
            }
            corpus+= HU.close(DIV);

            if (!asHtml)
                corpus = HU.tag(PRE, [], corpus);
            this.writeHtml(ID_TEXT, corpus);
	    colorBy.displayColorTable();
	    var linesWord = " "+ this.getProperty("linesDescriptor","lines");
	    var label =displayedLineCnt +linesWord;
	    if(this.allRecords.length!=displayedLineCnt) {
		label = displayedLineCnt+"/" + this.allRecords.length+linesWord+" (" + Math.round(displayedLineCnt/this.allRecords.length*100)+"%)";
	    }
	    this.jq(ID_LABEL).html(label);
	    this.jq(ID_SEARCH).focus();
	    if(rowScale) {
		var rows =  this.jq(ID_TEXT).find(".display-raw-row");
		var open = function() {
		    $(this).css("transform","scaleY(1)");		    
		    $(this).css("line-height","1.5");
		    $(this).css("border-bottom","1px solid #ccc");
		    $(this).css("border-top","1px solid #ccc");
		};
		var close = function() {
		    var row = this;
		    if(!$(row).attr("matched")) {	
			$(row).css("transform","scaleY(" + rowScale +")");
			$(row).css("line-height",rowScale);
			$(row).css("border-bottom","0px solid #ccc");
			$(row).css("border-top","0px solid #ccc");
		    }
		}
		rows.each(close);
		rows.mouseenter(open);
		rows.mousemove(open);
		rows.mouseout(close);
	    }
	    let lines =this.jq(ID_TEXT).find(".display-raw-line");
	    lines.click(function() {
		var idx = $(this).attr(RECORD_INDEX);
		var record = _this.indexToRecord[idx];
		if(record) {
		    _this.showRecordPopup($(this),record);
		    _this.propagateEventRecordSelection({record: record});
		    _this.highlightLine(idx);
		}
	    });
	    this.makeTooltips(lines,records);
        },
	highlightLine: function(index) {
	    var container = this.jq(ID_TEXT);
	    container.find(".display-raw-line").removeClass("display-raw-line-selected");
	    var sel = HU.attrSelect(RECORD_INDEX,index);
	    var element =  container.find(sel);
	    element.addClass("display-raw-line-selected");

	},
        handleEventRecordSelection: function(source, args) {
	    var index = this.findMatchingIndex(args.record).index;
	    if(index<0 || !Utils.isDefined(index)) {
		return;
	    }
	    this.highlightLine(index);
	    var container = this.jq(ID_TEXT);
	    var sel = HU.attrSelect(RECORD_INDEX,index);
	    var element =  container.find(sel);
	    var c = container.offset().top;
	    var s = container.scrollTop();
	    var eo = element.offset();
	    var diff = eo.top- c + s;
	    container.scrollTop(diff)
	},
    });
}


function RamaddaTextDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_TEXT, properties);
    let myProps = [
	{label:'Text Display'},
	{p:'recordTemplate',ex:''},
	{p:'showDefault',d:true,ex:"false"},
	{p:'message',d:null,ex:""},
    ];
    if(!properties["recordTemplate"]) {
	properties["recordTemplate"] = "${default}";
    }

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	handleAnnotation: function() {
	    let annotation = null;
	    let template = this.getProperty("template","${date} - ${description}");
	    let  macros = Utils.tokenizeMacros(template);
	    let attrs = {};
	    let date = null;
	    if(this.selectedRecord) {
		date = this.selectedRecord.getDate()
		if(date)
		    annotation = this.annotations.getAnnotationFromDate(date);
	    }
	    if(!annotation) {
		date=this.getAnimation().getBeginTime()
		if(date)
		    annotation = this.annotations.getAnnotationFromDate(date);
	    }
	    if(date) {
		attrs.date = date;
	    }  else {
		attrs.date = "";
	    }
	    if(!annotation) {
//		this.setContents("");
		return;
	    }
	    attrs.description = annotation.description;
	    attrs.label = annotation.label;
	    if(this.annotations.getShowLegend()) {
		attrs.legend  = this.annotations.getLegend();
	    } else {
		attrs.legend  = "";
	    }
	    let html =  macros.apply(attrs);
	    if(this.getProperty("decorate",true)) {
		html = this.getMessage(html);
	    }
	    this.setContents(html);
	},
	updateUI: function() {
            SUPER.updateUI.call(this);
	    if(this.getProperty("annotations")) {
		let pointData = this.getPointData();
		if (pointData == null) return;
		if(!this.annotations) {
		    this.annotations  = new Annotations(this,this.filterData());
		} 
		if(this.annotations.isEnabled()) {
		    this.handleAnnotation();
		}
	    }
	    if(this.selectedRecord) {
		this.setContents(this.getRecordHtml(this.selectedRecord));
	    } else  if(this.getPropertyShowDefault()) {
		this.recordMap = {};
		let records = this.filterData();
		if(records && records.length>0) {
		    records.forEach((record,idx)=>{
			this.recordMap[record.getId()] = record;
		    });
		    this.selectedRecord =records[0];
		    this.setContents(this.getRecordHtml(records[0]));
		}
	    } else  if(this.getPropertyMessage()) {
		this.setDisplayMessage(this.getPropertyMessage());
	    }
        },
        pointDataLoaded: function(pointData, url, reload) {
	    this.selectedRecord= null;
	    SUPER.pointDataLoaded.call(this, pointData,url,reload);
	},
        handleEventRecordSelection: function(source, args) {
	    if(this.recordMap) {
		if(!this.recordMap[args.record.getId()]) {
		    return;
		}
	    }
	    this.selectedRecord= args.record;
	    this.updateUI();
        }
    });
}




function RamaddaGlossaryDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_GLOSSARY, properties);
    const ID_GLOSSARY_HEADER = "glossary_header";
    let myProps = [
	{label:'Glossary'},
	{p:'wordField',ex:""},
	{p:'definitionField',ex:""},	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let wordField = this.getFieldById(null,this.getProperty("wordField"));
	    let definitionField = this.getFieldById(null,this.getProperty("definitionField"));	    
	    if(!wordField) {
                this.displayError("No word field specified");
                return;
	    }
	    if(!definitionField) {
                this.displayError("No definition field specified");
                return;
	    }	    
	    let letters = {};
	    records.forEach(record=>{
		let word = String(wordField.getValue(record)).trim();
		let definition = definitionField.getValue(record);
		let letter = word.substring(0,1).toUpperCase();
		let list = letters[letter] || (letters[letter] = []);
		list.push({word:word,definition:definition, record:record});
	    });
	    let highlight  = this.getFilterTextMatchers();
	    let header =  HU.div([ATTR_CLASS,"display-glossary-letter"], "All");
	    let html = "";
	    Object.keys(letters).sort().forEach(letter=>{
		let _letter = letter.trim();
		_letter = _letter==""?"_":_letter;
		let clazz = " display-glossary-letter ";
		if(this.searchLetter == _letter) {
		    clazz+=" display-glossary-letter-highlight ";
		}
		header += HU.div([ATTR_CLASS,clazz,"letter",_letter], _letter);
		if(this.searchLetter && this.searchLetter!=_letter) return;
		let group =  HU.div([ATTR_CLASS,"display-glossary-group-header"],  _letter) +
		    HU.openTag(DIV,[ATTR_CLASS,"display-glossary-group-inner"]);
		letters[letter].sort((a,b)=>{
		    return a.word.localeCompare(b.word);
		}).forEach(info=>{
		    let def = String(info.definition);
		    highlight.forEach(h=>{
			def  = h.highlight(def);
		    });

		    let entry  = HU.div([ATTR_CLASS,"display-glossary-word"], info.word) + HU.div([ATTR_CLASS,"display-glossary-definition"], def); 
		    group+=HU.div([TITLE,"",ATTR_CLASS,"display-glossary-entry",RECORD_ID,info.record.getId()],entry);
		});
		group += HU.closeTag(DIV);
		html+=group;
	    });

	    let height = this.getProperty("glossaryHeight","600px");
	    header = HU.div([ATTR_ID,this.domId(ID_GLOSSARY_HEADER), ATTR_CLASS,"display-glossary-header"], header);
	    html = HU.div([ATTR_STYLE,HU.css("max-height",HU.getDimension(height),"overflow-y","auto")], html);
	    this.setContents(header  + html);
	    let _this = this;
	    this.jq(ID_GLOSSARY_HEADER).find(".display-glossary-letter").click(function() {
		_this.searchLetter =  $(this).attr("letter");
		_this.forceUpdateUI();
	    });
	    this.makeTooltips(this.find(".display-glossary-entry"),records);
	},
    });
}



/**
   Copyright 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


var DISPLAY_ENTRYLIST = "entrylist";
var DISPLAY_TESTLIST = "testlist";
var DISPLAY_ENTRYDISPLAY = "entrydisplay";
var DISPLAY_ENTRY_GALLERY = "entrygallery";
var DISPLAY_ENTRY_GRID = "entrygrid";
var DISPLAY_OPERANDS = "operands";
var DISPLAY_METADATA = "metadata";
var DISPLAY_ENTRYTIMELINE = "entrytimeline";
var DISPLAY_REPOSITORIES = "repositories";
var DISPLAY_ENTRYTITLE = "entrytitle";
var DISPLAY_ENTRYWIKI = "entrywiki";
var DISPLAY_SEARCH  = "search";
var DISPLAY_SIMPLESEARCH  = "simplesearch";
var ID_RESULTS = "results";
var ID_SEARCH_FORM = "searchform";
var ID_SEARCH_HEADER = "searchheader";
var ID_SEARCH_BAR = "searchbar";
var ID_SEARCH_TAG = "searchtag";
var ID_SEARCH_TAG_GROUP = "searchtaggroup";
var ID_ENTRIES = "entries";
var ID_DETAILS_INNER = "detailsinner";
var ID_DETAILS_ANCESTORS = "detailsancestors";
var ID_DETAILS_TAGS= "detailstags";
var ID_DETAILS_TYPE= "detailstype";
var ID_PROVIDERS = "providers";
var ID_SEARCH_ORDERBY = "orderby";
var ID_SEARCH_SETTINGS = "searchsettings";
var ID_SEARCH_AREA = "search_area";
var ID_SEARCH_MAX = "search_max";
var ID_SEARCH_DATE_RANGE = "search_date";
var ID_SEARCH_DATE_CREATE = "search_createdate";
var ID_SEARCH_TAGS = "search_tags";
var ID_SEARCH_ANCESTOR = "search_ancestor";
var ID_SEARCH_ANCESTORS = "search_ancestors";
var ID_TREE_LINK = "treelink";
var ATTR_ENTRYID = "entryid";


var ID_SEARCH = "search";
var ID_FORM = "form";

var ID_TEXT_FIELD = "textfield";
var ID_NAME_FIELD = "namefield";
var ID_DESCRIPTION_FIELD = "descriptionfield";
var ID_ANCESTOR = "ancestor";
var ID_ANCESTOR_NAME = "ancestorname";
var ID_TYPE_FIELD = "typefield";
var ID_TYPE_DIV = "typediv";
var ID_TYPEFIELDS = "typefields";
var ID_METADATA_FIELD = "metadatafield";
var ID_COLUMN = "column";
var ID_SEARCH_HIDEFORM = "searchhideform";
var ATTR_TEXT_INPUT='data-text-input';

addGlobalDisplayType({
    type: DISPLAY_SIMPLESEARCH,
    label: "Simple Search",
    requiresData: false,
    category: CATEGORY_ENTRIES
});


addGlobalDisplayType({
    type: DISPLAY_ENTRYLIST,
    label: "Entry List",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
/*
  addGlobalDisplayType({
  type: DISPLAY_SEARCH,
  label: "Entry Search",
  requiresData: false,
  category: CATEGORY_ENTRIES
  });
*/
/*
  addGlobalDisplayType({
  type: DISPLAY_TESTLIST,
  label: "Test  List",
  requiresData: false,
  category: CATEGORY_ENTRIES
  });
*/
addGlobalDisplayType({
    type: DISPLAY_ENTRYDISPLAY,
    label: "Entry Display",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRYTITLE,
    label: "Entry Title",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRYWIKI,
    label: "Entry Wiki",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRY_GALLERY,
    label: "Entry Gallery",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRY_GRID,
    label: "Entry Date Grid",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
//addGlobalDisplayType({type: DISPLAY_OPERANDS, label:"Operands",requiresData:false,category:CATEGORY_ENTRIES});
addGlobalDisplayType({
    type: DISPLAY_METADATA,
    label: "Metadata Table",
    requiresData: false,
    category: CATEGORY_ENTRIES
});



function RamaddaEntryDisplay(displayManager, id, type, properties) {
    const  SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    RamaddaUtil.inherit(this, SUPER);
    this.defineProperties([
	{label:'Entry Search'},
	{p:'providers',ex:'this,category:.*',tt:'List of search providers',canCache:true},
	{p:'providersMultiple',ex:'true',tt:'Support selecting multiple providers'},
	{p:'providersMultipleSize',d:'4'}
    ]);

    this.ramaddas = new Array();
    let repos = this.getProperty("repositories", this.getProperty("repos", null));
    if (repos != null) {
        let toks = repos.split(",");
        //OpenSearch;http://adasd..asdasdas.dasdas.,
        for (let i = 0; i < toks.length; i++) {
            let tok = toks[i];
            tok = tok.trim();
            this.ramaddas.push(getRamadda(tok));
        }
        if (this.ramaddas.length > 0) {
            let container = new RepositoryContainer("all", "All entries");
            addRepository(container);
            for (let i = 0; i < this.ramaddas.length; i++) {
                container.addRepository(this.ramaddas[i]);
            }
            this.ramaddas.push(container);
            this.setOriginalRamadda(this.ramaddas[0]);
            this.setRamadda(this.ramaddas[0]);
        }
    }


    this.searchSettings =  new EntrySearchSettings({
        parent: properties.searchEntryParent || properties.entryParent,
        text: properties.searchEntryText || properties.entryText,
        entryType: properties.searchEntryType,
        orderBy: properties.orderBy,
	ancestor: properties.searchAncestor || properties.ancestor ,
    });
    if(properties.provider) {
	this.searchSettings.setProvider(properties.provider);
    }

    RamaddaUtil.defineMembers(this, {
        entryList: properties.entryList,
        entryMap: {},
	writeEntries: function(msg, entries) {
	    this.jq(ID_ENTRIES).html(msg);
	},
	writeMessage:function( msg)  {
	    this.jq(ID_RESULTS).html(msg);
	},
	writeResults: function(msg) {
	    this.jq(ID_RESULTS).html(msg);
	},
        getSearchSettings: function() {
            if (this.getPropertyProviders() != null) {
                this.searchSettings.clearProviders();
                let provider = this.searchSettings.getProvider();
		let select = this.jq(ID_PROVIDERS);
                let fromSelect = select.val();
                if (fromSelect != null) {
                    provider = fromSelect;
                } else {
		    provider =    this.getPropertyProviders()[0];
		    if(provider)provider = provider.id;
                }
		let ramadda=this.getRamadda();
		let ok = true;
		if(ramadda && ramadda.getId() == provider) {
		    ok = false;
		}
		if(ok) {
                    this.searchSettings.setProvider(provider);
		} else {
                    this.searchSettings.clearProviders();
		}
            }
            return this.searchSettings;
        },
        getEntries: function() {
            if (this.entryList == null) return [];
            return this.entryList.getEntries();
        },
	getEntriesMetadata:function(entries) {
	    let mdtsFromEntries = [];
            let mdtmap = {};
            let tmp = {};
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let metadata = entry.getMetadata();
                for (let j = 0; j < metadata.length; j++) {
                    let m = metadata[j];
                    if (tmp[m.type] == null) {
                        tmp[m.type] = "";
                        mdtsFromEntries.push(m.type);
                    }
                    mdtmap[metadata[j].type] = metadata[j].label;
                }
            }

            let html = "";
            html += HU.openTag(TAG_TABLE, [ATTR_ID, this.getDomId(TAG_TABLE), ATTR_CLASS, "cell-border stripe ramadda-table", ATTR_WIDTH, "100%", "cellpadding", "5", "cellspacing", "0"]);
            html += "<thead>"
            let type = this.findEntryType(this.searchSettings.entryType);
            let typeName = "Entry";
            if (type != null) {
                typeName = type.getLabel();
            }
	    this.writeMessage(this.getResultsHeader(entries));
            let mdts = null;
            //Get the metadata types to show from either a property or
            //gather them from all of the entries
            // e.g., "project_pi,project_person,project_funding"
            let prop = this.getProperty("metadataTypes", null);
            if (prop != null) {
                mdts = prop.split(",");
            } else {
                mdts = mdtsFromEntries;
                mdts.sort();
            }

            let skip = {
                "content.pagestyle": true,
                "content.pagetemplate": true,
                "content.sort": true,
                "spatial.polygon": true,
            };
            let headerItems = [];
            headerItems.push(HU.th([], HU.b(typeName)));
            for (let i = 0; i < mdts.length; i++) {
                let type = mdts[i];
                if (skip[type]) {
                    continue;
                }
                let label = mdtmap[mdts[i]];
                if (label == null) label = mdts[i];
                headerItems.push(HU.th([], HU.b(label)));
            }
            let headerRow = HU.tr(["valign", "bottom"], HU.join(headerItems, ""));
            html += headerRow;
            html += "</thead><tbody>"
            let divider = "<div class=display-metadata-divider></div>";
            let missing = this.missingMessage;
            if (missing = null) missing = "&nbsp;";
            for (let entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                let entry = entries[entryIdx];
                let metadata = entry.getMetadata();
                let row = [];
                let buttonId = this.getDomId("entrylink" + entry.getIdForDom());
                let link = entry.getLink(entry.getIconImage() + " " + entry.getName());
                row.push(HU.td([], HU.div([ATTR_CLASS, "display-metadata-entrylink"], link)));
                for (let mdtIdx = 0; mdtIdx < mdts.length; mdtIdx++) {
                    let mdt = mdts[mdtIdx];
                    if (skip[mdt]) {
                        continue;
                    }
                    let cell = null;
                    for (let j = 0; j < metadata.length; j++) {
                        let m = metadata[j];
                        if (m.type == mdt) {
                            let item = null;
                            if (m.type == "content.thumbnail" || m.type == "content.logo") {
                                let url = this.getRamadda().getRoot() + "/metadata/view/" + m.value.attr1 + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + m.id;
                                item = HU.image(url, [ATTR_WIDTH, "100"]);
                            } else if (m.type == "content.url" || m.type == "dif.related_url") {
                                let label = m.value.attr2;
                                if (label == null || label == "") {
                                    label = m.value.attr1;
                                }
                                item = HU.href(m.value.attr1, label);
                            } else if (m.type == "content.attachment") {
                                let toks = m.value.attr1.split("_file_");
                                let filename = toks[1];
                                let url = this.getRamadda().getRoot() + "/metadata/view/" + m.value.attr1 + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + m.id;
                                item = HU.href(url, filename);
                            } else {
                                item = m.value.attr1;
                                if (Utils.isDefined(m.value.attr2)) {
				    if(String(m.value.attr2).trim().length > 0) {
					item += " - " + m.value.attr2;
				    }
                                }
                            }
                            if (item != null) {
                                if (cell == null) {
                                    cell = "";
                                } else {
                                    cell += divider;
                                }
                                cell += HU.div([ATTR_CLASS, "display-metadata-item"], item);
                            }

                        }
                    }
                    if (cell == null) {
                        cell = missing;
                    }
                    if (cell == null) {
                        cell = "";
                    }
                    let add = HU.tag(TAG_A, [ATTR_STYLE, "color:#000;", ATTR_HREF, this.getRamadda().getRoot() + "/metadata/addform?entryid=" + entry.getId() + "&metadata_type=" + mdt,
					     "target", "_blank", "alt", "Add metadata", ATTR_TITLE, "Add metadata"
					    ], "+");
                    add = HU.div([ATTR_CLASS, "display-metadata-table-add"], add);
                    let cellContents = add + divider;
                    if (cell.length > 0) {
                        cellContents += cell;
                    }
                    row.push(HU.td([], HU.div([ATTR_CLASS, "display-metadata-table-cell-contents"], cellContents)));
                }
                html += HU.tr(["valign", "top"], HU.join(row, ""));
                //Add in the header every 10 rows
                if (((entryIdx + 1) % 10) == 0) html += headerRow;
            }
            html += "</tbody>"
            html += HU.closeTag(TAG_TABLE);
	    return html;
	},

        getEntriesGallery: function(entries) {
            let nonImageHtml = "";
            let html = "";
            let imageCnt = 0;
            let imageEntries = [];
	    for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                //Don: Right now this just shows all of the images one after the other.
                //If there is just one image we should just display it
                //We should do a gallery here if more than 1

                if (entry.isImage()) {
                    imageEntries.push(entry);
                    let link = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], entry.getName());
                    imageCnt++;
		    let imageUrl =entry.getImageUrl();
                    html += HU.tag(TAG_IMG, ["src", imageUrl, ATTR_WIDTH, "500", ATTR_ID,
					     this.getDomId("entry_" + entry.getIdForDom()),
					     ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
					    ]) + "<br>" +
                        link + "<p>";
                } else {
                    let icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
                    let link = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], icon + " " + entry.getName());
                    nonImageHtml += link + "<br>";
                }
            }

            if (imageCnt > 1) {
                //Show a  gallery instead
		this.galleryId = HU.getUniqueId("gallery_");
                let newHtml = HU.open(TAG_DIV,[ATTR_ID, this.galleryId,ATTR_CLASS,"ramadda-grid"]);
		let itemWidth = this.getProperty("galleryItemWidth","200px");
                for (let i = 0; i < imageEntries.length; i++) {
                    let entry = imageEntries[i];
		    let attrs = ["width",itemWidth];
                    newHtml += HU.open(TAG_DIV,[ATTR_CLASS,"display-entrygallery-item",ATTR_STYLE,HU.css(attrs)]);
                    let link = HU.tag(TAG_A, ["target","_entries",ATTR_HREF, entry.getEntryUrl()], entry.getName());
		    link = link.replace(/"/g,"'");
		    let imageUrl =entry.getImageUrl();
                    let img = HU.image(imageUrl, ["loading","lazy", ATTR_WIDTH, "100%", ATTR_ID,
						  this.getDomId("entry_" + entry.getIdForDom()),
						  ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
						 ]);
                    img = HU.href(entry.getResourceUrl(), img, ["data-fancybox",this.galleryId, "data-caption",link, ATTR_CLASS, "popup_image"]);
                    newHtml += HU.div([ATTR_CLASS, "image-outer"], HU.div([ATTR_CLASS, "image-inner"], img) +
				      HU.div([ATTR_CLASS, "image-caption"], link));

                    newHtml += HU.close(TAG_DIV);
                }
                newHtml += HU.close(TAG_DIV);
                html = newHtml;
            }


            //append the links to the non image entries
            if (nonImageHtml != "") {
                if (imageCnt > 0) {
                    html += "<hr>";
                }
                html += HU.div([ATTR_STYLE,HU.css("margin","10px")],nonImageHtml);
            }
            return html;
        }
    });
    if (properties.searchEntryType != null) {
        this.searchSettings.addType(properties.searchEntryType);
    }
}






function RamaddaSearcherDisplay(displayManager, id,  type, properties) {
    let NONE = "-- None --";
    let myProps = [
	{label:'Search'},
        {p:'showForm',d: true},
        {p:'formOpen',d: true},	
        {p:'orderBy',ex: 'name_ascending|name_descending|fromdate_ascending|fromdate_descending|todate_|createdate_|size_'},
        {p:'orientation',ex:'horizontal|vertical',d:'horizontal'},
	{p:'formHeight',d:'1000px'},
        {p:'entriesHeight',ex:'70vh'},	
        {p:'showEntries',d: true},
        {p:'showFooter',d: true},	
        {p:'showType',d: true},

        {p:'entryTypes',ex:'comma separated list of types - use "any" for any type'},
        {p:'typesLabel',tt: 'Label to use for the type section'},		
	{p:'addAllTypes',ex:'true',tt:'Add the All types to the type list'},
	{p:'addAnyType',ex:'true',tt:'Add the Any of these types to the type list'},
	{p:'startWithAny',ex:'true',tt:'Start with the Any of these types'},	
        {p:'doSearch',d: true,tt:'Apply search at initial display'},
	{p:'searchHeaderLabel',d: 'Search'},
	{p:'searchOpen',d: true},
        {p:'showOrderBy',d:true,ex: 'true'},
        {p:'showSearchSettings',d: true},
        {p:'showToggle',d: false},
	{p:'showEntryBreadcrumbs',ex:'false'},
	{p:'showSnippetInList',ex:'true'},
        {p:'showProviders',d: false},
        {p:'showDate',d: true},
        {p:'showCreateDate',ex:'true',d: false},	
        {p:'showArea',d: true},
        {p:'showText',d: true},
        {p:'showName',d: false},
        {p:'showDescription',d: false},		
	{p:'ancestor',ex:'this',tt:'Constrain search to this tree'},		
        {p:'showAncestor',d: true},
        {p:'ancestors',tt: 'Comma separated list of entry ids or type:entry_type'},
        {p:'ancestorsLabel',tt: 'Label to use for the ancestors section'},		
        {p:'mainAncestor',tt: 'Entry ID to force the search under'},
	{p:'textRequired',d:false},
        {p:'searchText',d: '',tt:'Initial search text'},
	{p:'searchPrefix',ex:'name:, contents:, path:'},
        {p:'showMetadata',d: false},
	{p:'metadataTypes', ex:'enum_tag:Tag,content.keyword:Keyword,thredds.variable:Variable'},
	{p:'metadataDisplay',ex:'archive_note:attr1=Arrangement:template=<b>{attr1}_colon_</b> {attr2}',
	 tt:'Add metadata in the toggle. e.g.: type1:template={attr1},type2:attr1=Value:template={attr1}_colon_ {attr2}'},
        {p:'showTags',d: true},	
	{p:'mainMetadataDisplay'},
	{p:'nameStyle'},
	{p:'showIcon'},
	{p:'showToggle'},
	{p:'showThumbnail'},
	{p:'placeholderImage',ex:'/repository/image.png'},
	{p:'showEntryType'},
	{p:'tagPopupLimit',d: 10,tt:'When do we show the tag popup' },		
	{p:'showSearchLabels',d:true},
	{p:'comparators',d:'<=,>=,=,between',tt:'comparators for numeric search'},
	{p:'searchDirect',d:false,tt:'Directly search remote RAMADDA repositories'},
        {p:'fields',d: null},
        {p:'formWidth',d: '225px'},
        {p:'entriesWidth',d: 0},
	{p:'displayTypes',ex:'list,images,timeline,map,metadata'},
	{p:'defaultImage',ex:'blank.gif',canCache:true},
	{p:'showColumns',tt:'Comma separated list of columns to show'},
	{p:'showEntryImage',d:true,tt:'Show the entry thumbnail'},
        {p:'showDetailsForGroup',d: false},
	{p:'inputSize',d:'200px',tt:'Text input size'},
	{p:'textInputSize',d:'20px',ex:'100%'},	
	{p:'startDateLabel'},
	{p:'createDateLabel'},	
	{p:'areaLabel'},
	{p:'toggleClose',ex:true},
	{p:'textToggleClose',ex:true},
	{p:'dateToggleClose',ex:true},		
	{p:'areaToggleClose',ex:true},
	{p:'columnsToggleClose',ex:true},		
	{p:'orderByTypes',d:'relevant,name,createdate,date,size,entryorder'},
	{p:'showOutputs',ex:'false',d:true},
	{p:'outputs',ex:'csv,json,zip,export,extedit,copyurl'},
	{p:'doWorkbench',d:false,ex:'true', tt:'Show the new, charts, etc links'},
    ];

    const SUPER = new RamaddaEntryDisplay(displayManager, id, type, properties);

    this.currentTime = new Date();
    defineDisplay(this, SUPER, myProps, {
        metadataTypeList: [],
	haveSearched: false,
        haveTypes: false,
        metadata: {},
        metadataLoading: {},
	addToDocumentUrl:function(key,value) {
	    //Don't do this right away
	    let now = new Date();
	    if(now.getTime()-this.currentTime.getTime()>1000) {
		HU.addToDocumentUrl(key,value);
	    }
	},
	ctor: function() {
	    let metadataTypesAttr = this.getMetadataTypes();
	    if (Utils.stringDefined(metadataTypesAttr) && this.getShowSearchSettings()) {
		//look for type:value:label, or type:label,
		let toks = metadataTypesAttr.split(",");
		for (let i = 0; i < toks.length; i++) {
		    let type = toks[i];
		    let label = type;
		    let value = null;
		    let subToks = type.split(":");
		    if (subToks.length > 1) {
			type = subToks[0];
			if (subToks.length >= 3) {
			    value = subToks[1];
			    label = subToks[2];
			} else {
			    label = subToks[1];
			}
		    }
		    if(label=='null') {
		    } else {
			this.metadataTypeList.push(new MetadataType(type, label, value));
		    }
		}
	    }
	},
        getLoadingMessage: function(msg) {
	    if(!msg) return "";
	    return msg;
	},
        isLayoutHorizontal: function() {
	    return this.getOrientation()== "horizontal";
        },

	initHtml: function() {
	    this.jq(ID_ANCESTOR).click((event) =>{
		let aid = this.domId(ID_ANCESTOR);
		let root = this.getRamadda().getRoot();
		RamaddaUtils.selectInitialClick(event,aid,aid,true,null,null,'',root);
	    });


	    this.jq(ID_SEARCH_HIDEFORM).click(()=>{
		this.formShown  = !this.formShown;
		if(this.formShown)
		    this.jq(ID_SEARCH_FORM).show();
		else
		    this.jq(ID_SEARCH_FORM).hide();
	    });
            if (this.areaWidgets) {
		this.areaWidgets.forEach(areaWidget=>{
		    areaWidget.initHtml();
		});
	    }
	    if(this.getShowOrderBy()) {
		let settings = this.getSearchSettings();
		let byList = [];
		let getLabel=(type,suffix,dflt)=>{
		    let key ='orderByLabel_'+ type+(suffix?'_'+suffix:'');
		    let label =this.getProperty(key);
		    if(label) return label;
		    if(!dflt) dflt = Utils.makeLabel(type)+(suffix?(' - '+suffix):'');
		    return  dflt;
		}


		Utils.split(this.getOrderByTypes(),',',true,true).forEach(type=>{
		    if(type=='relevant')
			byList.push([getLabel(type,null),type]);
		    else if(type=='name')
			byList.push([getLabel(type,'ascending',"Name A-Z"), type+'_ascending'],
				    [getLabel(type,'descending',"Name Z-A"),type+'_descending']);
		    else if(type=='createdate')
			byList.push(["Record create date - newest first","createdate_descending"],
				    ["Record create date - oldest first","createdate_ascending"]);
		    else if(type=='date')
			byList.push([getLabel(type,'descending',"From date - youngest first"),"fromdate_descending"],			  			  
				    [getLabel(type,'ascending',"From date - oldest first"),"fromdate_ascending"]);
		    else if(type=='size')
			byList.push(["Size - largest first","size_descending"],
				    ["Size - smallest first","size_ascending"]);
		    else if(type=='entryorder')
			byList.push(["Entry order - increasing","entryorder_ascending"],
				    ["Entry order - decreasing","entryorder_descending"]);		    
		    else {
			byList.push(
			    [getLabel(type,'descending'),'field:'+type+'_descending'],
			    [getLabel(type, 'ascending'),'field:'+type+'_ascending']);			    
		    }
		});
		let options = "";
		byList.forEach(tuple=>{
		    let label = tuple[0];
		    let by = tuple[1];
		    let extra = settings.orderBy==by?" selected ":""
		    options += "<option title='" + label+"'  " + "" + extra + " value=\"" + by + "\">" + label + "</option>\n";
		    
		});
		let select = HU.tag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_SEARCH_ORDERBY), ATTR_CLASS, "display-search-orderby"], options);
		this.jq(ID_SEARCH_HEADER).append(select);
	    }
            this.addExtraForm();
	},
	toggleAll:function(visible) {
	    let _this = this;
	    this.jq(ID_SEARCH_FORM).find('.display-search-label-toggle').each(function() {
		_this.toggleWidget($(this),visible);
	    });
	},
	toggleWidget:function(toggle, visible) {
	    let widget = jqid(toggle.attr('data-widget-id'));
	    let icon;
	    if(!visible) {
		widget.hide();
		icon = 'fa-plus';
	    } else {
		widget.show();
		icon = 'fa-minus';
	    }
	    icon = HU.getIconImage(icon, [], [ATTR_STYLE,'color:#fff;'])
	    let imageId= toggle.attr('data-image-id');
	    //			imageId,jqid(imageId).length);
	    jqid(imageId).html(icon);
	},
	addToggle:function(label,widgetId,toggleClose) {
	    let toggleId = HU.getUniqueId('');
	    let imageId = toggleId+'_image';
	    label = HU.div([ATTR_CLASS,'display-search-label-toggle',
			    'data-widget-id',widgetId,
			    'data-image-id',imageId,
			    ATTR_TITLE, "click: toggle; shift-click: toggle all",ATTR_ID,toggleId],
			   HU.span([ATTR_ID,imageId],
				   HU.getIconImage(toggleClose?'fa-plus':'fa-minus', [], [ATTR_STYLE,'color:#fff;'])) +' ' + label);
	    setTimeout(()=>{
		jqid(toggleId).click((event)=>{
		    let toggle = jqid(toggleId);
		    let widget = jqid(widgetId);
		    let visible = widget.is(':visible');
		    if(event.shiftKey) {
			this.toggleAll(!visible);
			return;
		    }
		    this.toggleWidget(toggle,!visible);
		});
	    },100);
	    return label;
	},
	addWidget:function(label,widget,args) {
	    let opts = {
		addToggle:true,
		addSimpleToggle:false,
		toggleClose:this.getToggleClose()
	    }
	    if(args) $.extend(opts,args);
	    if(!Utils.stringDefined(widget)) return '';
            let horizontal = this.isLayoutHorizontal();
	    if(horizontal)  {
		if(!Utils.stringDefined(label)) {
		    widget = HU.div([ATTR_CLASS,'display-search-widget-nolabel'],widget);	
		    return widget;
		}		    
		widget = HU.div([ATTR_CLASS,'display-search-widget ' + (opts.searchWidgetClass??'')],widget);	
		let widgetId = HU.getUniqueId('');
		if(opts.addToggle) {
		    label = this.addToggle(label,widgetId,opts.toggleClose);
		} 

		//let  w;
		let w = Utils.stringDefined(label)?
		    HU.div([ATTR_CLASS,"display-search-label",ATTR_STYLE,HU.css('xmin-width',HU.getDimension(this.getFormWidth()))], label):'';

		if(opts.addSimpleToggle) {
		    w  = HU.toggleBlock(HU.b(label),widget);
		} else {
		    w=w+HU.span([ATTR_ID,widgetId,ATTR_STYLE,HU.css('width','95%','display',opts.toggleClose?'none':'inline-block')],widget);
		}
		return HU.div([ATTR_CLASS,"display-search-block"], w);
	    }
	    return HU.formEntry("",widget);
	},
        getDefaultHtml: function() {
            let html = "";
            let horizontal = this.isLayoutHorizontal();
            let footer = this.getFooter();
            if (!this.getShowFooter(true)) {
                footer = "";
            }
	    this.jq(ID_BOTTOM).html(footer);
	    footer = "";
            let entriesDivAttrs = [ATTR_ID, this.getDomId(ID_ENTRIES), ATTR_CLASS, this.getClass("content")];
            let innerHeight= this.getProperty("innerHeight", null);
            let entriesStyle = this.getProperty("entriesStyle", "");	    
	    let style = "";
            if (innerHeight == null) {
                innerHeight = this.getEntriesHeight();
            }
            if (innerHeight != null) {
                style = "margin: 0px; padding: 0px; max-height:" + HU.getDimension(innerHeight) + "; overflow-y: auto;";
                style = HU.css('max-height', HU.getDimension(innerHeight),'overflow-y','auto');
            }
	    style+= entriesStyle;
            entriesDivAttrs.push(ATTR_STYLE);
            entriesDivAttrs.push(style);	    
	    let searchBar = HU.div([ATTR_CLASS,horizontal?"display-search-bar":"display-search-bar-vertical",ATTR_ID, this.domId(ID_SEARCH_BAR)],"");
            let resultsDiv = "";
            if (this.getProperty("showHeader", true)) {
                resultsDiv = HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)], "&nbsp;");
            }
	    resultsDiv = HU.leftRightTable(resultsDiv,HU.div([ATTR_CLASS,"display-search-header", ATTR_ID,this.domId(ID_SEARCH_HEADER)]),null,null,{valign:"bottom"});
	    let toggle = "";
	    if(horizontal && this.getShowForm()) {
		toggle = HU.div([ATTR_TITLE, "Toggle form",
				 ATTR_ID,this.domId(ID_SEARCH_HIDEFORM), ATTR_CLASS,"ramadda-clickable",
				 ATTR_STYLE,HU.css("position","absolute","left","0px","top","0px")],
				HU.getIconImage("fas fa-bars"));
	    }
            let entriesDiv = HU.div([ATTR_STYLE,HU.css("position","relative")],
				    toggle +
				    searchBar +
				    resultsDiv +
				    HU.div(entriesDivAttrs, this.getLoadingMessage()));

            if (horizontal) {
		html += HU.open(TAG_TABLE,["width","100%","border",0]);
		html+="<tr valign=top>";
                let entriesAttrs = [ATTR_CLASS, "col-md-12"];
                if (this.getShowForm()) {
                    let attrs = [];
		    let form = HU.div([ATTR_CLASS,'display-entrylist-form',
				       ATTR_STYLE,HU.css("width",HU.getDimension(this.getFormWidth()),
							 "max-width",HU.getDimension(this.getFormWidth()),
							 "overflow-x","auto")],this.makeSearchForm());
		    html += HU.tag(TAG_TD, [ATTR_ID,this.getDomId(ID_SEARCH_FORM),"width","1%"], form);
		    this.formShown  = true;
                }
                if (this.getShowEntries()) {
                    let attrs = [];
                    if (this.getEntriesWidth() === "") {
                        attrs = [];
                    } else if (this.getEntriesWidth() != 0) {
                        attrs = [ATTR_WIDTH, this.getEntriesWidth()];
                    }
                    html += HU.tag(TAG_TD,[], entriesDiv);		    
                }
                html += HU.closeTag(TAG_TR);
                html += HU.closeTag(TAG_TABLE);

                html += HU.openTag(TAG_DIV, [ATTR_CLASS, "row"]);
                if (this.getShowForm()) {
                    html += HU.tag(TAG_DIV, [ATTR_CLASS, "col-md-6"], "");
                }
                if (this.getShowEntries()) {
                    if (this.getShowFooter(true)) {
                        html += HU.tag(TAG_DIV, [ATTR_CLASS, "col-md-6"], footer);
                    }
                }
                html += HU.closeTag(TAG_DIV);
            } else {
                if (this.getShowForm()) {
                    html += this.makeSearchForm();
                }
                if (this.getShowEntries()) {
                    html += entriesDiv;
                    html += footer;
                }
            }
            html += HU.div([ATTR_CLASS, "display-entry-popup", ATTR_ID, this.getDomId(ID_DETAILS)], "&nbsp;");
            return html;
        },
        initDisplay: function() {
            let theDisplay = this;

            this.jq(ID_SEARCH).click(function(event) {
		theDisplay.submitSearchForm();
                event.preventDefault();
            });

            this.jq(ID_TEXT_FIELD).autocomplete({
                source: function(request, callback) {
                    //                            theDisplay.doQuickEntrySearch(request, callback);
                }
            });

	    //Don't selectbox the orderby
	    //	HtmlUtils.initSelect(this.jq(ID_SEARCH_ORDERBY));
	    this.jq(ID_SEARCH_ORDERBY).change(()=>{	    
                this.submitSearchForm();
	    });
            HtmlUtils.initSelect(this.jq(ID_REPOSITORY));
            this.jq(ID_REPOSITORY).change(function() {
                let v = theDisplay.jq(ID_REPOSITORY).val();
                let ramadda = getRamadda(v);
                theDisplay.setRamadda(ramadda);
                theDisplay.addTypes(null);
                theDisplay.typeChanged();
            });

            this.jq(ID_FORM).submit(function(event) {
                theDisplay.submitSearchForm();
                event.preventDefault();
            });


            this.addTypes(this.entryTypes);
	    this.initMetadata();
            if (!this.haveSearched) {
                if (this.getDoSearch()) {
		    if(!this.typesPending) {
			this.submitSearchForm();
		    }
                }
            }
        },
        showEntryDetails: async function(event, entryId, src, leftAlign) {
            if (true) return;
            let entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            let popupId = "#" + this.getDomId(ID_DETAILS + entryId);
            if (this.currentPopupEntry == entry) {
                this.hideEntryDetails(entryId);
                return;
            }
            let myloc = 'right top';
            let atloc = 'right bottom';
            if (leftAlign) {
                myloc = 'left top';
                atloc = 'left bottom';
            }
            this.currentPopupEntry = entry;
            if (src == null) src = this.getDomId("entry_" + entry.getIdForDom());
            let closeImage = HU.getIconImage(icon_close, []);
            let close = HU.onClick(this.getGet() + ".hideEntryDetails('" + entryId + "');",closeImage);

            let contents = this.getEntryHtml(entry, {
                headerRight: close
            });
            $(popupId).html(contents);
            $(popupId).show();
            /*
              $(popupId).position({
              of: jQuery( "#" +src),
              my: myloc,
              at: atloc,
              collision: "none none"
              });
            */
        },

	getCloser: function() {
	    if(true) return "";
	    return  HU.jsLink("",HU.getIconImage(icon_close, [ATTR_ID,this.domId("close"),ATTR_STYLE,HU.css("cursor","pointer")]));
	},
	initCloser: function(what) {
	    this.jq("close").click(()=>{
		this.jq(what||ID_RESULTS).hide();
	    });
	},
        getResultsHeader: function(entries, includeCloser) {
            let settings = this.getSearchSettings();
	    //Always show the next/prev because the results might be < max even though there
	    //are more on the repository because some results might be hidden due to access control
	    //            if (entries.length < DEFAULT_MAX) return entries.length+" result" +(entries.length>1?"s":"");
            let left = "Showing " + (settings.skip + 1) + "-" + (settings.skip + Math.min(settings.getMax(), entries.length));
	    if(entries.length==0) left = SPACE3+SPACE3+SPACE3;
            let nextPrev = [];
            let lessMore = [];
            if (settings.skip > 0) {
                nextPrev.push(HU.onClick(this.getGet() + ".loadPrevUrl();", HU.getIconImage("fa-arrow-left", [ATTR_TITLE, "Previous"]), [ATTR_CLASS, "display-link"]));
            }
            let addMore = false;
            if (entries.length>0 &&(true || entries.length == settings.getMax())) {
                nextPrev.push(HU.onClick(this.getGet() + ".loadNextUrl();", HU.getIconImage("fa-arrow-right", [ATTR_TITLE, "Next"]), [ATTR_CLASS, "display-link"]));
                addMore = true;
            }

	    if(entries.length>0) {
		lessMore.push(HU.onClick(this.getGet() + ".loadLess();", HU.getIconImage("fa-minus", [ATTR_TITLE, "View less"]), [ATTR_CLASS, "display-link"]));
		if (addMore) {
                    lessMore.push(HU.onClick(this.getGet() + ".loadMore();", HU.getIconImage("fa-plus", [ATTR_TITLE, "View more"]), [ATTR_CLASS, "display-link"]));
		}
	    }
            let results = "";
            let spacer = "&nbsp;&nbsp;&nbsp;"
	    if(includeCloser)
		results = this.getCloser();
	    results += "&nbsp;" + left + spacer;
            results += 
                HU.join(nextPrev, "&nbsp;") + spacer +
                HU.join(lessMore, "&nbsp;");
            return results+"<br>";
        },
	makeSearchSettings: function() {
	    let settings = this.getSearchSettings();
            settings.text = this.getFieldValue(this.getDomId(ID_TEXT_FIELD), settings.text);
            settings.name = this.getFieldValue(this.getDomId(ID_NAME_FIELD), settings.name);
            settings.description = this.getFieldValue(this.getDomId(ID_DESCRIPTION_FIELD), settings.description);
	    
	    if(settings.text) {
		if(Utils.stringDefined(settings.text)) {
		    this.addToDocumentUrl(ID_TEXT_FIELD,settings.text);
		}
		if(settings.text.trim()!="") {
		    if(this.getSearchPrefix())
			settings.text = this.getSearchPrefix()+ settings.text;
		}
	    }  else {
		//		this.addToDocumentUrl(ID_TEXT_FIELD,"");
	    }

	    settings.ancestor = this.getAncestor();
	    let orderBy = this.jq(ID_SEARCH_ORDERBY).val();
	    if(orderBy) {
		let ascending = orderBy.indexOf("_ascending")>=0;
		if(orderBy=="relevant") ascending=false;
		orderBy = orderBy.replace("_ascending","").replace("_descending","");
		settings.orderBy =  orderBy;
		settings.ascending = ascending;
	    }


            if (this.haveTypes) {
                settings.entryType = this.getFieldValue(this.getDomId(ID_TYPE_FIELD),
							settings.entryType);
		if(settings.entryType && (this.typeList==null || this.typeList.length>1) ) {
		    this.addToDocumentUrl(ID_TYPE_FIELD,settings.entryType);
		} else {
		    this.addToDocumentUrl(ID_TYPE_FIELD,null);
		}
            } else if(this.typeList && this.typeList.length==1) {
		settings.entryType = this.typeList[0];
	    }
	    if(!Utils.stringDefined(settings.entryType) && this.getEntryTypes()) { 
		settings.entryType = this.getEntryTypes();
	    }

            settings.clearAndAddType(settings.entryType);
	    let ancestor = this.jq(ID_ANCESTOR+"_hidden").val();
	    if(Utils.stringDefined(ancestor)) {
		settings.ancestor = ancestor;
		this.addToDocumentUrl(ID_ANCESTOR,ancestor);
		let name = this.jq(ID_ANCESTOR).val();
		if(name)
		    this.addToDocumentUrl(ID_ANCESTOR_NAME,name);		    
	    } else {
		//delete it
		this.addToDocumentUrl(ID_ANCESTOR,null);
		this.addToDocumentUrl(ID_ANCESTOR_NAME,null);		
	    }
            if (this.areaWidgets) {
		this.areaWidgets.forEach(areaWidget=>{
                    areaWidget.setSearchSettings(settings);
		});
            }
            if (this.dateRangeWidget) {
                this.dateRangeWidget.setSearchSettings(settings);
            }
            if (this.createdateRangeWidget) {
                this.createdateRangeWidget.setSearchSettings(settings);
            }	    
	    
            settings.metadata = [];
	    if(!this.getShowTags()) {
		this.metadataTypeList.forEach(metadataType=>{
                    let value = metadataType.getValue();
                    if (value == null) {
			value = this.getFieldValues(this.getMetadataFieldId(metadataType), null);
                    }
                    if (value != null) {
			if(!Array.isArray(value)) {value=[value]}
			value.forEach(v=>{
			    settings.metadata.push({
				type: metadataType.getType(),
				value: v
			    });
			});
                    }
		});
	    } 
	    if(this.metadataList) {
		this.metadataList.forEach(metadata=>{
		    if (!metadata.getElements()) {
			return;
		    }
		    metadata.getElements().forEach(element=>{
			element.addSearchSettings(settings);
		    });
		});
	    }

	    return settings;
	},
        submitSearchForm: function() {
            if (this.fixedEntries) {
                return;
            }
            this.haveSearched = true;
	    let settings  =this.makeSearchSettings();
            if (this.getTextRequired() && (settings.text == null || settings.text.trim().length == 0)) {
                this.writeEntries("");
                return;
            }

            //Call this now because it sets settings
            let theRepository = this.getRamadda()

	    this.writeMessage(this.getWaitImage() + " " +"Searching...");
            if (theRepository.children) {
                this.entryList = new EntryListHolder(theRepository, this);
                this.multiSearch = {
                    count: 0,
                };

                for (let i = 0; i < theRepository.children.length; i++) {
                    let ramadda = theRepository.children[i];
                    let jsonUrl = this.makeSearchUrl(ramadda);
                    this.updateForSearching(jsonUrl);
                    this.entryList.addEntryList(new EntryList(ramadda, jsonUrl, null, false));
                    this.multiSearch.count++;
                }
                this.entryList.doSearch(this);
            } else {
                this.multiSearch = null;
                let jsonUrl = this.makeSearchUrl(this.getRamadda());
                this.handleLog(jsonUrl);
                this.entryList = new EntryList(this.getRamadda(), jsonUrl, this, true);
                this.updateForSearching(jsonUrl);
            }
        },
        entryListChanged:function(entryList) {
	},
        handleSearchError: function(url, msg) {
            this.writeEntries("");
            this.writeMessage("Error performing search:" + msg);
            console.log("Error performing search:" + msg);
            //alert("There was an error performing the search\n" + msg);
        },
        updateForSearching: function(jsonUrl) {
	    let showOutputs = this.getShowOutputs(true);
	    let settings = this.getSearchSettings();
	    let okOutputs = this.getProperty('outputs');
	    if(okOutputs) {
		okOutputs = Utils.split(okOutputs,',',true,true);
	    }
	    let check = output=>{
		if(!showOutputs) return false;
		let id = output.id??output;
		if(!okOutputs) return true;
		if(id==OUTPUT_CSV) id='csv';
		else if(id==OUTPUT_ZIP) id='zip';
		else if(id==OUTPUT_EXPORT) id='export';				
		return okOutputs.includes(id);
	    }
	    let outputs = this.getRamadda().getSearchLinks(settings,true,check);

	    let url= this.getRamadda().getSearchUrl(settings);
	    let copyId = HU.getUniqueId('copy');
	    let extra = [];
	    if(this.getProperty('searchOutputs')) {
		extra = Utils.mergeLists(extra,Utils.split(this.getProperty('searchOutputs'),',',true,true));
	    }
	    if(!Utils.isAnonymous()) {
		if(check('extedit'))
		    extra.push('repository.extedit;Extended Edit');
	    }


	    extra.forEach(tok=>{
		let tuple = Utils.split(tok,';');
		if(tuple.length<2)return;
		let id = tuple[0];
		let label = tuple[1];
                outputs.push(HU.span([ATTR_CLASS,'ramadda-search-link ramadda-clickable',
				      ATTR_TITLE,'Click to download; shift-click to copy URL',
				      'custom-output','true',
				      'data-name',label,
				      'data-format',id,
				      'data-url',
				      this.getRamadda().getSearchUrl(settings,id)],
				     label));
	    });



	    outputs = HU.join(outputs, HU.space(2));
	    if(check('copyurl'))
		outputs = outputs+ HU.space(2)+
		HU.span([ATTR_CLASS,'ramadda-search-link ramadda-clickable',
			 ATTR_ID,copyId,
			 'data-copy',url],
			HU.getIconImage("fas fa-clipboard"));
	    if(this.getShowOutputs()) {
		this.footerRight = outputs == null ? "" :  outputs;
	    } else {
		this.footerRight = '';
	    }
            this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
	    let _this = this;
	    this.jq(ID_FOOTER_RIGHT).find('.ramadda-search-link').button().click(function(event){
		let custom  =$(this).attr('custom-output');
		_this.handleSearchLink(event,$(this),custom);
	    });
            let msg = this.searchMessage;
            if (msg == null) {
                msg = this.getRamadda().getSearchMessage();
            }
            let provider = this.getSearchSettings().getProvider();
            if (provider != null) {
                msg = null;
                if (this.providerMap != null && this.providerMap[provider]) {
                    msg = this.providerMap[provider].name;
                }
                if (msg == null) {
                    msg = provider;
                }
                msg = "Searching " + msg;
            }
            this.hideEntryDetails();
        },
        prepareToLayout: function() {
            SUPER.prepareToLayout.apply(this);
            this.savedValues = {};
            let cols = this.getSearchableColumns();
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                let id = this.getDomId(ID_COLUMN + col.getName());
                let value = $("#" + id).val();
                if (value == null || value.length == 0) continue;
                this.savedValues[id] = value;
            }
        },
        makeSearchUrl: function(repository) {
	    let _this=this;
            let extra = "";
            let cols = this.getSearchableColumns();
	    let searchBar  = this.jq(ID_SEARCH_BAR);
	    let makeTag=(key,value,label) =>{
		return  $(HU.div([ATTR_TITLE,'Click to clear search',ATTR_CLASS,"display-search-tag",key,value],label)).appendTo(searchBar);
	    }

	    this.getContents().find('.display-search-textinput').each(function() {
		let arg = $(this).attr(ATTR_TEXT_INPUT);
		if(!arg) return;
		let val = $(this).val();
		let tag = searchBar.find(HU.attrSelect(ATTR_TEXT_INPUT,arg));
		if(!Utils.stringDefined(val)) {
		    if(tag.length!=0) tag.remove();
		    return
		    
		}
		let label = arg+'='+val;
		if(tag.length==0) {
		    tag =makeTag(ATTR_TEXT_INPUT,arg,label);
		    tag.click(()=>{
			$(this).val('');
			_this.submitSearchForm();
		    });
		} else {
		    tag.html(label);
		}
	    });
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                if (!col.getCanSearch()) continue;
		let id  = ID_COLUMN + col.getName();
		let arg = col.getSearchArg();
		let tag = searchBar.find(HU.attrSelect("column",col.getName()));
		if(col.isNumeric()) {
                    let expr = this.jq(id+"_expr").val();
                    let from = this.jq(id+"_from").val();
                    let to = this.jq(id+"_to").val();		    		    
		    if(Utils.stringDefined(from) || Utils.stringDefined(to)) {
			let label =  (Utils.stringDefined(from)?(from+" &lt; "):"") +  col.getLabel() + (Utils.stringDefined(to)?(" &lt; " +to):"");
			if(tag.length==0) {
			    tag = makeTag("column",col.getName(),label);
			    tag.click(()=>{
				this.jq(id+"_from").val("");
				this.jq(id+"_to").val("");		    		    
				this.submitSearchForm();
			    });
			} else {
			    tag.html(label);
			}
			//			extra += "&" + arg  +"_expr" +  "=" + encodeURIComponent(expr);
			if(Utils.stringDefined(from))
			    extra += "&" + arg  +"_from" +  "=" + encodeURIComponent(from);
			if(Utils.stringDefined(to))
			    extra += "&" + arg  +"_to" +  "=" + encodeURIComponent(to);						
			//			console.log("expr:" +expr +" from:" + from +" to:" + to);
		    } else {
			tag.remove();
		    }
		} else if(col.isLatLon()) {
		    //searchurl
		    if(col.areaWidget) {
			let v = col.areaWidget.getValues();
			['north','west','south','east'].forEach(d=>{
			    if(Utils.stringDefined(v[d])) {
				extra += '&' + arg+'_'+d + '=' + encodeURIComponent(v[d].trim());
			    }
			});
			if(col.areaWidget.getContains()) {
			    extra += '&' + arg+'_areamode'+  '=' + 'contains';

			}
		    }
		} else if(col.isEnumeration() && col.showCheckboxes()) {
                    let fullId = this.getDomId(ID_COLUMN + col.getName());
		    let cbxValues=[];
		    let cbxs = $('[checkbox-id='+ fullId+']');
		    cbxs.each(function() {
			if($(this).is(':checked')) {
			    let value = $(this).attr('data-value');
			    extra += '&' + arg + '=' + encodeURIComponent(value);
			    cbxValues.push(value);
			}
		    });
		    if(cbxValues.length>0) {
			label = col.getLabel() +"=" + Utils.join(cbxValues,' or ');
			if(tag.length==0) {
			    tag = makeTag("column",col.getName(),label);
			    tag.click(()=>{
				cbxs.prop('checked',false);
				this.submitSearchForm();
			    })
			} else {
			    tag.html(label);
			}
		    } else {
			tag.remove();
		    }
		} else {
                    let value = this.jq(id).val();
                    if (value == null || value==VALUE_NONE) {
			tag.remove();
			continue;
		    }

		    if(!Array.isArray(value)) {
			value = [value];
		    }
		    if(value.length==0) {
			tag.remove();
			continue;
		    }

		    if(col.getType()=="string" || col.isDate() || col.isLatLon()) {
			if(value=="") {
			    tag.remove();
			    continue;
			}
		    }


		    let label = col.getLabel() +"=";
		    if(Array.isArray(value)) {
			label+=Utils.join(value,"&nbsp;|&nbsp;");
		    } else {
			label +=  value;
		    }
		    
		    if(tag.length==0) {
			tag = makeTag("column",col.getName(),label);
			tag.click(()=>{
			    let obj=this.jq(id);
			    if(obj.data && obj.data('selectBox-selectBoxIt')) {
				obj.data('selectBox-selectBoxIt').selectOption(VALUE_NONE);
			    } else {
				obj.val(null);
			    }
			    this.submitSearchForm();
			});
		    } else {
			tag.html(label);
		    }
		    value.forEach(v=>{
			extra += "&" + arg + "=" + encodeURIComponent(v);
		    });
		}
            }
	    let settings = this.getSearchSettings();
	    settings.setMax(this.jq(ID_SEARCH_MAX).val()??settings.getMax());
            settings.setExtra(extra);
            let jsonUrl = repository.getSearchUrl(settings, OUTPUT_JSON);
	    if(this.getMainAncestor()) {
		let main  = this.getMainAncestor();
		if(main=='this') {
		    main = this.getProperty('entryId');
		}
		jsonUrl+='&mainancestor='+ main;
	    }
	    this.getContents().find('.ramadda-displayentry-ancestor').each(function() {
		if($(this).is(':checked')) {
		    let id = $(this).attr('data-entryid');
		    jsonUrl+='&ancestor='+ id;
		}
	    });
	    
            return jsonUrl;
        },
	addAreaWidget(areaWidget) {
	    if(!this.areaWidgets) this.areaWidgets=[];
	    this.areaWidgets.push(areaWidget);
	},
	getSearchValue:function(key,dflt) {
	    let v =  GuiUtils.getUrlArg(this.urlPrefix+key,null);
	    if(v==null) return dflt;
	    v = v.replace(/\+/g,' ');
	    return v;
	},

        loadAncestorsList: function(entries) {
	    let html = '';
	    entries.forEach(entry=>{
		html+=HU.div([ATTR_CLASS,'display-search-ancestors-select'],
			     HU.checkbox('',[ATTR_ID,'ancestor_'+ entry.getId(),ATTR_CLASS,'ramadda-displayentry-ancestor',
					     'data-entryid',entry.getId()],false,entry.getName()));
	    });
	    this.jq(ID_SEARCH_ANCESTORS).html(HU.div([ATTR_CLASS,'display-search-ancestors'],html));
	    this.jq(ID_SEARCH_ANCESTORS).find('.ramadda-displayentry-ancestor').change(()=>{
		this.submitSearchForm();
	    });
	},
        loadAncestors: function(ancestors) {
	    let url = ramaddaBaseUrl+ '/wiki/getentries?entries=' + ancestors;
            let entryList = new EntryList(this.getRamadda(), url, this, false);
	    let success=list=>{
		this.loadAncestorsList(list.getEntries());
	    }
	    let fail=err=>{
		console.log(err);
	    }
            entryList.doSearch(null,success,fail);
	},
        makeSearchForm: function() {
	    let toggleClose = this.getProperty('toggleClose',!this.getSearchOpen(true));
            let form = HU.openTag(TAG_FORM, [ATTR_ID, this.getDomId(ID_FORM), "action", "#"]);
            let buttonLabel = HU.getIconImage("fa-search", [ATTR_TITLE, "Search"]);
            let topItems = [];
	    buttonLabel = "Search";
            let searchButton = HU.div([ATTR_STYLE,'margin-bottom:4px;max-width:80%;',ATTR_ID, this.getDomId(ID_SEARCH), ATTR_CLASS, "ramadda-button display-search-button ramadda-clickable"], buttonLabel);
            let extra = "";
            let settings = this.getSearchSettings();

            let horizontal = this.isLayoutHorizontal();

            if (this.ramaddas.length > 0) {
                let repositoriesSelect = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_REPOSITORY), ATTR_CLASS, "display-repositories-select"]);
                let icon = RamaddaUtil.getCdnUrl("/icons/favicon.png");
                for (let i = 0; i < this.ramaddas.length; i++) {
                    let ramadda = this.ramaddas[i];
                    let attrs = [ATTR_TITLE, "", ATTR_VALUE, ramadda.getId(),
				 "data-iconurl", icon
				];
                    if (this.getRamadda().getId() == ramadda.getId()) {
                        attrs.push("selected");
                        attrs.push(null);
                    }
                    let label =
                        repositoriesSelect += HU.tag(TAG_OPTION, attrs,
						     ramadda.getName());
                }
                repositoriesSelect += HU.closeTag(TAG_SELECT);
                topItems.push(repositoriesSelect);
            }


            this.providerMap = {};
	    let providers = this.getPropertyProviders();
            if (providers != null) {
		if(providers.length==1) {
		    this.provider = providers[0];
		} else {
		    if(!this.getShowProviders()){
			this.provider = providers[0];
		    } else {
			let options = "";
			let selected = HU.getUrlArgument(ID_PROVIDERS);
			let currentCategory = null;
			let catToBuff = {};
			let cats = [];
			this.getPropertyProviders().forEach(provider=>{
			    this.providerMap[provider.id] = provider;
			    let id = provider.id;
			    if(!Utils.isDefined(selected)) {
				selected = id;
			    }
			    let label = provider.name;
			    if (label.length > 40) {
				label = label.substring(0, 39) + "...";
			    }
			    let extraAttrs = "";
			    if (id == selected) {
				extraAttrs += " selected ";
			    }
			    let category = provider.category||"";
			    let buff = catToBuff[category];
			    if (buff == null) {
				cats.push(category);
				catToBuff[category] = "";
				buff = "";
			    }
			    let img = provider.icon;
			    if(img) {
				img = img.replace(/\${urlroot}/g, ramaddaBaseUrl);
				img = img.replace(/\${root}/g, ramaddaBaseUrl);
				extraAttrs += " data-iconurl=\"" + img + "\" ";
			    }
			    buff += "<option  title='" + label+"' class=display-search-provider " + extraAttrs + " value=\"" + id + "\">" + label + "</option>\n";
			    catToBuff[category] = buff;
			});

			if(cats.length==1) {
			    options += catToBuff[cats[0]];
			} else {
			    for (let catIdx = 0; catIdx < cats.length; catIdx++) {
				let category = cats[catIdx];
				if (category != "")
				    options += "<optgroup label=\"" + category + "\">\n";
				options += catToBuff[category];
				if (category != "")
				    options += "</optgroup>";
			    }
			}
			let attrs = [ATTR_STYLE,HU.css(),
				     ATTR_ID, this.getDomId(ID_PROVIDERS),
				     ATTR_CLASS, "display-search-providers"];
			if(this.getProvidersMultiple()) {
			    let size =Math.min(8,providers.length+1);
			    attrs.push("size",this.getProvidersMultipleSize(size),  "multiple", "multiple");
			}
			let providersSelect = HU.tag(TAG_SELECT,attrs, options);
			providersSelect = this.addWidget('Providers',providersSelect,
							 {toggleClose:true,
							  addToggle:true,
							  searchWidgetClass:(this.getProvidersMultiple()?'display-search-widget-providers':'')});
			topItems.push(providersSelect);
		    }
		}
	    }


	    this.typeList = null;
            if (this.getEntryTypes()) {
		this.typeList = this.getEntryTypes().split(",");
	    }
	    this.urlPrefix = 'search.';
	    if(this.typeList && this.typeList.length>0) this.urlPrefix+=this.typeList[0]+'.';
            if (this.getShowType()) {
		if(this.typeList == null || this.typeList.length==0) {
                    topItems.push(HU.div([ATTR_STYLE,HU.css("margin-bottom","4px"),ATTR_ID, this.getDomId(ID_TYPE_DIV)], HU.span([ATTR_CLASS, "display-loading"], "Loading types...")));
		} else {
		    extra+= HU.div([ATTR_STYLE,HU.css("margin-bottom","4px"),ATTR_ID, this.getDomId(ID_TYPE_DIV)]);
		}
            }


	    let text  = this.getFormText();
	    if(!Utils.stringDefined(text)) 
		text = HU.getUrlArgument(ID_TEXT_FIELD);
	    let textInputClass = "display-simplesearch-input display-search-textinput"
	    let attrs  = [ATTR_PLACEHOLDER, this.getEgText("Search text"), ATTR_TITLE,"e.g. name:, contents:,path:", ATTR_CLASS, textInputClass,  ATTR_ID, this.domId(ID_TEXT_FIELD)];
	    let inputAttrs =  [ATTR_CLASS, textInputClass];
	    if(this.getProperty("inputSize")) {
		inputAttrs.push(ATTR_SIZE);
		inputAttrs.push(this.getProperty("inputSize", "30"));
	    } else {
		inputAttrs.push(ATTR_STYLE);
		inputAttrs.push(HU.css("width","100%","min-width","50px","max-width","300px"));
	    }

	    let contents = "";
	    let topContents = "";	    
	    form+=HU.center(searchButton);
	    if(topItems.length>0) {
		if (horizontal) {
		    form += topItems[0];
		    topContents +=  HU.join(topItems.slice(1), "");
		} else {
		    topItems = topItems.map(item=>{return HU.div([ATTR_STYLE,HU.css("margin-right","8px")], item);});
		    form+="<br>";
		    form+=   HU.hrow(...topItems);
		}
	    }
	    

	    if(!horizontal)  {
		extra += HU.formTable();
	    }

	    let ancestors  = this.getProperty("ancestors");
	    if(ancestors) {
		extra+=this.addWidget(this.getProperty('ancestorsLabel','Search Under'),
				      HU.div([ATTR_ID,this.domId(ID_SEARCH_ANCESTORS)]),{toggleClose:true});
		setTimeout(()=>{
		    this.loadAncestors(ancestors);
		},1);
	    }

	    if(this.getShowAncestor()) {
		let ancestor = HU.getUrlArgument(ID_ANCESTOR) ?? this.getProperty("ancestor");
		let name = HU.getUrlArgument(ID_ANCESTOR_NAME) ?? this.getProperty("ancestorName");		
		let aid = this.domId(ID_ANCESTOR);
		let clear = HU.href("javascript:void(0);",HU.getIconImage("fas fa-eraser"), ['onClick',"RamaddaUtils.clearSelect(" + HU.squote(aid) +");",
											     ATTR_TITLE,"Clear selection"]);
		let input = HU.input("",name||"",["READONLY",null,ATTR_PLACEHOLDER,'Select', ATTR_STYLE,HU.css('cursor','pointer','width','100%'),ATTR_ID,aid,ATTR_CLASS,"ramadda-entry-popup-select  disabledinput"]);

		extra += HU.hidden("",ancestor||"",[ATTR_ID,aid+"_hidden"]);
		extra+=this.addWidget('Search Under',HU.div([ATTR_ID,this.domId(ID_SEARCH_ANCESTOR)], HU.leftRightTable(clear,input,"5%", "95%")),{toggleClose:true});
	    }


	    let textFields = [];
            let textField = HU.input("", text, Utils.mergeLists([ATTR_TEXT_INPUT,'Text'],attrs,inputAttrs));
            if (this.getShowText()) {
		textFields.push(textField);
            }

            if (this.getShowName()) {
		textFields.push(HU.input("","",
					 Utils.mergeLists([ATTR_TEXT_INPUT,'Name',
							   ATTR_ID,this.domId(ID_NAME_FIELD),ATTR_PLACEHOLDER,'Name'],
							  inputAttrs)));				       
	    }
            if (this.getShowDescription()) {
		textFields.push(HU.input("","",
					 Utils.mergeLists([ATTR_TEXT_INPUT,'Description',ATTR_ID,this.domId(ID_DESCRIPTION_FIELD),ATTR_PLACEHOLDER,'Description'],
							  inputAttrs)));				       
	    }	    

	    if(textFields.length) {
		extra+=this.addWidget('Text',Utils.join(textFields,'<br>'),{
		    toggleClose:this.getProperty('textToggleClose',toggleClose)});
	    }


	    let dateWidget='';
            if (this.getShowDate()) {
                this.dateRangeWidget = new DateRangeWidget(this);
		let label=this.getLabel(this.getStartDateLabel());
		if(Utils.stringDefined(label))
                    extra += this.addWidget(label, HU.div([ATTR_ID,this.domId(ID_SEARCH_DATE_RANGE)], this.dateRangeWidget.getHtml()));
		else
		    dateWidget+=this.dateRangeWidget.getHtml();
	    }
            if (this.getShowCreateDate(true)) {
		let label=this.getLabel(this.getCreateDateLabel());
                this.createdateRangeWidget = new DateRangeWidget(this,"createdate");
		if(Utils.stringDefined(label))
                    extra += this.addWidget(label, HU.div([ATTR_ID,this.domId(ID_SEARCH_DATE_CREATE)], this.createdateRangeWidget.getHtml()));
		else 
		    dateWidget+=HU.div([ATTR_STYLE,'margin-top:4px;'],this.createdateRangeWidget.getHtml());
            }
	    if(Utils.stringDefined(dateWidget)) {
		extra+=this.addWidget('Date',dateWidget,{toggleClose:this.getProperty('dateToggleClose',toggleClose)});
	    }
            if (this.getShowArea()) {
		let label=this.getLabel(this.getAreaLabel('Location'));
		let areaWidget =new AreaWidget(this);
                this.addAreaWidget(areaWidget) 
                extra += this.addWidget(label, HU.div([ATTR_ID,this.domId(ID_SEARCH_AREA)], areaWidget.getHtml()),
					{toggleClose:this.getProperty('areaToggleClose',true)});
            }
            extra += HU.div([ATTR_ID, this.getDomId(ID_TYPEFIELDS)], "");
            if (Utils.stringDefined(this.getMetadataTypes())) {
		let metadataBlock = "";
                for (let i = 0; i < this.metadataTypeList.length; i++) {
                    let type = this.metadataTypeList[i];
                    let value = type.getValue();
                    let metadataSelect;
                    if (value != null) {
                        metadataSelect = value;
                    } else {
                        metadataSelect = HU.tag(TAG_SELECT, [ATTR_ID, this.getMetadataFieldId(type),
							     ATTR_CLASS, "display-metadatalist"],
						HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""],
						       NONE));
                    }

		    if(this.getShowTags()) {
			let block = HU.div([ATTR_CLASS,"display-search-metadata-block"], HU.div([ATTR_CLASS,"display-search-metadata-block-inner",
												 ATTR_ID,this.getMetadataFieldId(type)]));
			let countId = this.getMetadataFieldId(type)+"_count";
			let wrapperId = this.getMetadataFieldId(type)+"_wrapper";			
			let label = type.getLabel();
			metadataBlock += this.addWidget(label, block,{toggleClose:toggleClose});
		    } else {
			metadataBlock += this.addWidget(type.getLabel(), metadataSelect,{toggleClose:toggleClose});
		    }
                }
		extra += HU.div([ATTR_ID,this.domId(ID_SEARCH_TAGS)], metadataBlock);
            }


            extra +=HU.div([ATTR_STYLE,'margin-top:1em;border-top:var(--basic-border);',ATTR_CLASS,'display-search-widget'],
			   HU.b('# Records:') +' '+	HU.input("",  DEFAULT_MAX, [ATTR_CLASS,'display-simplesearch-input',
										    ATTR_ID,this.domId(ID_SEARCH_MAX),
										    'size','5']));
	    

	    extra+=HU.div([ATTR_STYLE,'height:100px;']);

	    if(!horizontal) 
		extra += HU.closeTag(TAG_TABLE);

	    contents +=topContents;
	    topContents='';
            if (this.getShowSearchSettings()) {
                let id = this.getDomId(ID_SEARCH_SETTINGS);
                if (this.getShowToggle()) {
                    contents+= HU.div([ATTR_CLASS, "display-search-extra", ATTR_ID, id],
				      HU.toggleBlock("Search Settings", HU.div([ATTR_CLASS, "display-search-extra-inner"], extra), this.getFormOpen(true)));
                } else {
                    contents += HU.div([ATTR_CLASS, "display-search-extra", ATTR_ID, id],
				       HU.div([ATTR_CLASS, "display-search-extra-inner"], extra));
                }
            }

            //Hide the real submit button
            contents += HU.open(TAG_INPUT,[ATTR_TYPE,"submit",ATTR_STYLE,"position:absolute;left:-9999px;width:1px;height:1px;"]);
	    if(this.getFormHeight()) {
		contents = HU.div([ATTR_STYLE,HU.css("overflow-y","auto","max-height",HU.getDimension(this.getFormHeight()))], contents);
	    }

	    if(Utils.stringDefined(topContents)) {
		form+=HU.div([ATTR_CLASS,"display-search-extra"],topContents);
	    }
	    form+=contents;
            form += HU.closeTag(TAG_FORM);
            return form;

        },
	getEgText:function(eg) {
            eg = this.getProperty(ATTR_PLACEHOLDER,eg||"Search");
            if (this.eg) {
                eg = " " + this.eg;
            }
	    return eg;
	},

	getFormText:function() {
	    let text = this.getSearchSettings().text;
            if (text == null) {
                let args = Utils.getUrlArgs(document.location.search);
                text = args.text;
            }
            if (text == null) {
                text = this.getSearchText();
            }
	    return text;
	},

        handleEventMapBoundsChanged: function(source, args) {
            if (this.areaWidgets) {
		this.areaWidgets.forEach(areaWidget=>{
                    areaWidget.handleEventMapBoundsChanged(source, args);
		});
            }
        },
        typeChanged: function() {
	    this.jq(ID_SEARCH_BAR).find('[column]').remove();
            let settings = this.getSearchSettings();
            settings.skip = 0;
            settings.setMax(DEFAULT_MAX);
	    let type = this.getFieldValue(this.getDomId(ID_TYPE_FIELD),
					  settings.entryType);
	    settings.entryType = type;
            settings.clearAndAddType(settings.entryType);
            this.addExtraForm();
            this.submitSearchForm();
        },
        initMetadata: function() {
            this.metadata = {};
	    this.metadataList=[];
            this.metadataLoading = {};	    
            for (let i = 0; i < this.metadataTypeList.length; i++) {
                let type = this.metadataTypeList[i];
                this.addMetadata(type, null);
            }
	},
        makeMetadata: function(metadataType,metadata) {
	    if(!metadata.getElements)  {
		metadata=new DisplayEntryMetadata(this,metadataType,metadata);
		this.metadata[metadataType.getType()] = metadata;
		this.metadataList.push(metadata);
	    }
	    return metadata;
	},
        addMetadata: function(metadataType, metadata) {
	    let _this = this;
            if (metadata == null) {
                metadata = this.metadata[metadataType.getType()];
            }
            if (metadata == null) {
                if (!this.metadataLoading[metadataType.getType()]) {
                    this.metadataLoading[metadataType.getType()] = true;
                    metadata = this.getRamadda().getMetadataCount(metadataType, function(metadataType, metadata) {
			if(!metadata  || metadata.undefined) return;
                        _this.addMetadata(metadataType, metadata);
                    });
                }
            }
            if (metadata == null) {
		return;
            }
	    this.metadata=metadata = this.makeMetadata(metadataType,metadata);
            if (!metadata.getElements()) {
                return;
	    }

	    if(!this.metadataBoxes) this.metadataBoxes={};
	    this.metadataBoxes[metadataType.getType()] = {};
	    let dest =     $("#" + this.getMetadataFieldId(metadataType));
	    dest.html('');
	    this.idToElement = {};
	    let cbxChange = function(){
		let not  = $(this).attr("metadata-not");
		let value  = $(this).attr("metadata-value");
		let type  = $(this).attr("metadata-type");
		let index  = $(this).attr("metadata-index");				
		let on = $(this).is(':checked');
		let cbx = $(this);
		let element  = _this.idToElement[$(this).attr(ATTR_ID)];
		if(on) {
		    if(element) element.setCbxOn((not?'!':'')+value);
		    let label = metadataType.getLabel();
		    _this.addMetadataTag(metadataType.getType(), label,value, cbx,not);
		} else {
		    if(element) element.setCbxOff((not?'!':'')+value);
		    let tagId = Utils.makeId(_this.domId(ID_SEARCH_TAG) +"_" + metadataType.getType() +"_" + value);
		    $("#" + tagId).remove();
		}		
		_this.submitSearchForm();
	    };

	    let hasMultipleElements = 	    metadata.getElements().length>1;

	    metadata.getElements().forEach((element)=>{
		if(element.getType()=='string') {
		    let inputChange = function(){
			_this.submitSearchForm();
		    };
		    let input = dest.append(element.makeInput());
		    input.change(inputChange);
		    return;
		}
		if(!element.getValues()) return;
		let popupLimit = this.getTagPopupLimit();
		let cbxs = element.makeCheckboxes(_this.idToElement,!hasMultipleElements);
		if(hasMultipleElements || !this.getShowTags()) {
		    if(element.select) {
			let menu = dest.append(element.select);
			element.menu = menu;
			menu.change(()=>{
			    _this.submitSearchForm();
			});
		    }
		} else {
		    if(cbxs.length>1  || cbxs.length>popupLimit) {
			if(element.select) {
			    let menu = $(element.select).appendTo(dest);
			    element.menu = menu;
			    HU.makeSelectTagPopup(menu,{
				hide:false,
				label:element.getName()});
			    menu.change(()=>{
				_this.submitSearchForm();
			    });
			} else {
			    dest.append(HU.div([],'Select')).button().click(function(){
				let cbxs2 = element.makeCheckboxes(_this.idToElement);
				_this.createTagDialog(cbxs2, $(this), cbxChange, metadataType.getType(),metadataType.getLabel());
			    });
			}
		    } else {
			dest.append(Utils.wrap(cbxs,"","<br>"));
		    }
		}});
	    dest.find(":checkbox").change(cbxChange);
        },

	metadataTagSelected:function(type, value) {
	    let tagGroupId = ID_SEARCH_TAG_GROUP+"_"+type;
	    let tagGroup = this.jq(tagGroupId);
	    let existing = tagGroup.find(HU.attrSelect("metadata-type",type)+HU.attrSelect("metadata-value",value));
	    return (existing.length>0);
	},
	addMetadataTag:function(type, label,value, cbx,not) {
	    let _this = this;
	    let cbxId = cbx?cbx.attr(ATTR_ID):'unknowncbx';
	    let tagGroupId = ID_SEARCH_TAG_GROUP+'_'+type;
	    let tagGroup = _this.jq(tagGroupId);
	    if(this.metadataTagSelected(type, value)) return false;
	    let tagId = Utils.makeId(_this.domId(ID_SEARCH_TAG) +'_' +type +'_' + value);
	    if(tagGroup.length==0) {
		tagGroup = $(HU.div([ATTR_CLASS,'display-search-tag-group',
				     ATTR_ID,_this.domId(tagGroupId)])).appendTo(_this.jq(ID_SEARCH_BAR));			     
	    }
	    let prefix = not?'Not ':'';

	    let tag = $(HU.div(['source-id',cbxId,'metadta-not',not,'metadata-type',type,'metadata-value',value,ATTR_TITLE,label+':' + prefix + value,
				ATTR_CLASS,'display-search-tag', ATTR_ID,tagId],prefix + value+SPACE +HU.getIconImage('fas fa-times'))).appendTo(tagGroup);
	    tag.click(function() {
		let element=_this.idToElement[$(this).attr('source-id')];
		let value = $(this).attr('metadata-value');
		if(element && value) {
		    element.setCbxOff(value);
		}
		$(this).remove();
		if(cbx)
		    cbx.prop('checked',false);
		_this.submitSearchForm();
	    });
	    return true;
	},
	addSearchToTags: function() {
	    return false;
	},
	typeSearchEnabled:function() {
	    return this.jq(ID_TYPE_FIELD).length>0;
	},
	typeTagClicked:function(type) {
	    HtmlUtils.initSelect(this.jq(ID_TYPE_FIELD),{selectOption: type.getId()});
	},	
	metadataTagClicked:function(metadata) {
	    if(!this.metadataBoxes) return;
	    if(!this.metadataBoxes[metadata.type] || !this.metadataBoxes[metadata.type][metadata.value.attr1]) {
		this.addMetadataTag(metadata.type, metadata.type,metadata.value.attr1, null);
		this.submitSearchForm();
		return;
	    }

	    let cbx = $('#' + this.metadataBoxes[metadata.type][metadata.value.attr1]);
	    if(cbx.is(':checked')) return;
	    cbx.click();
	},
        getMetadataFieldId: function(metadataType) {
            let id = metadataType.getType?metadataType.getType():metadataType;
            id = id.replace('.', '_'); 
            return this.getDomId(ID_METADATA_FIELD + id);
        },

        findEntryType: function(typeName) {
            if (this.entryTypes == null) return null;
            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                if (type.getId() == typeName) return type;
            }
            return null;
        },
        addTypes: function(newTypes) {
            if (newTypes == null) {
                newTypes = this.getRamadda().getEntryTypes((ramadda, types) =>{
                    this.addTypes(types);
                },this.getEntryTypes());
		if(newTypes==null) {
		    this.typesPending=true;
		}

            }
            if (newTypes == null) {
                return;
            }

            this.entryTypes = newTypes;

            if (this.getEntryTypes()) {
                let showType = {};
		let typeList = this.getEntryTypes().split(',');
                typeList.forEach(type=>{
                    showType[type] = true;
                });
                let tmp = [];
                for (let i = 0; i < this.entryTypes.length; i++) {
                    let type = this.entryTypes[i];
                    if (showType[type.getId()]) {
                        tmp.push(type);
                    } else if (type.getCategory() != null && showType[type.getCategory()]) {
                        tmp.push(type);
                    }
                }
                this.entryTypes = tmp;
	    }

            this.haveTypes = true;
            if (!this.getShowType()) {
		this.addExtraForm();
                return;
            }


	    let addTypeCategory=this.getProperty('addTypeCategory');
            let cats = [];
            let catMap = {};
            let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_TYPE_FIELD),
						 ATTR_CLASS, 'display-typelist',
						 'onchange', this.getGet() + '.typeChanged();'
						]);
	    if(this.getProperty('addAllTypes')) {
		select += HU.tag(TAG_OPTION, [ATTR_TITLE, '', ATTR_VALUE, VALUE_ANY_TYPE],'Any type');
	    }
	    if(this.getProperty('addAnyType',true)) {
		select += HU.tag(TAG_OPTION, [ATTR_TITLE, '', ATTR_VALUE, ''],
				 this.getEntryTypes()?'Any of these types':'Any type');
	    }
	    let hadSelected = false;
	    let anySelected = false;
	    let startWithAny=this.getProperty('startWithAny');
	    let fromUrl = HU.getUrlArgument(ID_TYPE_FIELD);
            this.entryTypes.every(type=>{
                anySelected = this.getSearchSettings().hasType(type.getId());
		if(fromUrl)
		    anySelected = type.getId()==fromUrl;
		return !anySelected;
	    });

            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                let icon = type.getIcon();
                let optionAttrs = [ATTR_TITLE, type.getLabel(), ATTR_VALUE, type.getId(), ATTR_CLASS, "display-typelist-type",
				   "data-iconurl", icon
				  ];
                let selected = this.getSearchSettings().hasType(type.getId());
		if(!selected) {
		    if(fromUrl)
			selected = type.getId()==fromUrl;
		}
		if(!selected && !anySelected && i==0 && !startWithAny)  selected=true;
                if (selected) {
		    hadSelected = true;
                    optionAttrs.push("selected");
                    optionAttrs.push(null);
                }
		let label = type.getLabel();
		if(type.getEntryCount()>0) 
		    label += " (" + type.getEntryCount() + ")"

                let option = HU.tag(TAG_OPTION, optionAttrs, label);
                let map = catMap[type.getCategory()];
                if (map == null) {
		    if(addTypeCategory) 
			catMap[type.getCategory()] = HU.tag(TAG_OPTION, [ATTR_CLASS, "display-typelist-category", ATTR_TITLE, "", ATTR_VALUE, ""], type.getCategory());
                    cats.push(type.getCategory());
                }
                catMap[type.getCategory()] += option;

            }
            for (let i in cats) {
                select += catMap[cats[i]];
            }

            select += HU.closeTag(TAG_SELECT);
	    if(this.entryTypes.length==0) {
	    } else  if(this.entryTypes.length==1) {
		if(this.entryTypes[0].getId()!='any')
		    this.writeHtml(ID_TYPE_DIV, HU.hidden(ID_TYPE_FIELD,this.entryTypes[0].getId()));
	    } else {
		this.writeHtml(ID_TYPE_DIV, this.addWidget(this.getProperty('typesLabel','Types'),select));
	    }
	    
            HtmlUtils.initSelect(this.jq(ID_TYPE_FIELD),
				 { autoWidth: false,  "max-height":"100px"});
            this.addExtraForm();
	    this.typesPending=false;
	    this.submitSearchForm();
        },
        getSelectedType: function() {
            if (this.entryTypes == null) {
		return null;
	    }
	    if(this.entryTypes.length==1) return this.entryTypes[0];
            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                if (type.getId) {
                    if (this.getSearchSettings().hasType(type.getId())) {
                        return type;
                    }
                }
            }
            let selectedType =  this.getFieldValue(this.getDomId(ID_TYPE_FIELD), null);
	    if(selectedType) {
		for (let i = 0; i < this.entryTypes.length; i++) {
                    let type = this.entryTypes[i];
                    if (type.getId) {
			if(selectedType == type.getId())
                            return type;
                    }
                }
            }
	    return null;

        },
        getSearchableColumns: function() {
            let searchable = [];
            let type = this.getSelectedType();
            if (type == null) {
                return searchable;
            }
            let cols = type.getColumns();
            if (cols == null) {
                return searchable;
            }
	    let onlyShow = null;
	    if(this.getShowColumns()) {
		onlyShow = {};
		Utils.split(this.getShowColumns(),',',true,true).forEach(c=>{
		    onlyShow[c] = true;
		});
	    }
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
		if(onlyShow &&!onlyShow[col.getName()]) continue;
                if (!col.getCanSearch()) continue;
                searchable.push(col);
            }
            return searchable;
        },
	makeLabel:function(label) {
	    label = this.getLabel(label);
	    if(!Utils.stringDefined(label)) return '';
	    return HU.div([ATTR_CLASS,'display-search-label'],label);
	},
	getLabel:function(label) {
	    //check if it is a column
	    if(!label) return '';
	    if(label.getSearchLabel) label = label.getSearchLabel();
	    if(!label) return '';
	    label = label.trim();
	    //	    if(!label.endsWith(':'))  label = label+':';
	    return label;
	},

        addExtraForm: function() {
	    let popupLimit = this.getTagPopupLimit();
	    let toggleClose = this.getColumnsToggleClose(this.getProperty('toggleClose',!this.getSearchOpen(true)));
            if (this.savedValues == null) this.savedValues = {};
            let extra = "";
            let cols = this.getSearchableColumns();
	    let comparators = this.getComparators().split(",");
	    let lastGroup = null;
	    let inGroup=false;
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                if (this.getProperty("fields") != null && this.getProperty("fields").indexOf(col.getName()) < 0) {
                    continue;
                }

		let group = col.getSearchGroup();

		if(Utils.stringDefined(group) && group!=lastGroup) {
		    if(inGroup) extra+='</div></div>';
		    inGroup=true;
		    lastGroup=group;
		    let widgetId = HU.getUniqueId('');
		    extra+=HU.open(TAG_DIV,[ATTR_CLASS,'display-search-group']);
		    let label = this.addToggle(group,widgetId,toggleClose);
		    extra+=HU.div([ATTR_CLASS,'display-search-group-label'],label);
		    extra+=HU.open(TAG_DIV,[ATTR_ID,widgetId,ATTR_STYLE,HU.css('display',toggleClose?'none':'block')]);
		}
                let field = "";
                let id = this.getDomId(ID_COLUMN + col.getName());
                let savedValue = this.savedValues[id];
                if (savedValue == null) {
                    savedValue = this.jq(ID_COLUMN + col.getName()).val();
                }
		//                if (savedValue == null) savedValue = "";
		let widget = "";
		let label="";
		let help = "";
		if(col.getSuffix()) {
		    help = HU.span([ATTR_STYLE,HU.css('cursor','help','margin-left','10px'), ATTR_TITLE,col.getSuffix()], HU.getIconImage("fas fa-info"));
		}		
		
                if (col.isEnumeration()) {
		    let showCheckboxes=col.showCheckboxes()
		    let prop = this.getProperty(col.getName()+'.showCheckboxes');
		    if(prop!=null) showCheckboxes= (String(prop)=='true');
		    let showLabels = this.getShowSearchLabels();
		    let values = col.getValues();
		    let searchValue = this.getSearchValue(col.getName());
		    if(showCheckboxes) {
			for (let vidx in values) {
                            let value = values[vidx].value||"";
			    if(value=="") {
				value = "--blank--";
			    }
                            let label = values[vidx].label.trim();
			    if(label=="&lt;blank&gt;") label="--blank--";
			    if(label=="")
				label= "--blank--"; 
			    let boxId = id+'_'+vidx;
                            field += HU.div([],HU.checkbox(boxId,[ATTR_CLASS,'display-entrylist-enum-checkbox',ATTR_ID,boxId,'checkbox-id',id,'data-value',value],
							   value==searchValue, label));
			}
		    } else {
			let clazz = 'display-metadatalist';
			let attrs = [ATTR_ID, id];
			let optionAttrs = [ATTR_CLASS,"display-metadatalist-item", ATTR_TITLE, "", ATTR_VALUE, VALUE_NONE];
			if(values.length>=popupLimit || col.getSearchMultiples()) {
			    attrs.push('multiple','true');
			    attrs.push('size','4');			    
			} else {
			    clazz= 'display-searchmenu ' + clazz;
			}
			attrs.push(ATTR_CLASS,clazz);
			attrs.push('data-label',col.getLabel());
			field = HU.openTag(TAG_SELECT, attrs);
			field+="\n";
			if(!col.getSearchMultiples()) {
			    field += HU.tag(TAG_OPTION, optionAttrs,
					    showLabels?"-- Select --":col.getSearchLabel());
			}
			field+="\n";
			for (let vidx in values) {
                            let value = values[vidx].value||"";
                            let extraAttr = "";
                            if (value === savedValue || value===searchValue) {
				extraAttr = " selected ";
				console.log(value,savedValue,searchValue);

                            }

			    if(value=="") {
				value = "--blank--";
			    }
                            let label = values[vidx].label.trim();
			    if(label=="&lt;blank&gt;") label="--blank--";
			    if(label=="")
				label= "--blank--"; 
                            field += HU.tag(TAG_OPTION, [ATTR_CLASS,"display-metadatalist-item", ATTR_TITLE, label, ATTR_VALUE, value, extraAttr, null],
					    label);
			    field+="\n";
			}
			field += HU.closeTag(TAG_SELECT);
		    }


		    if(showLabels) {
			label =  this.getLabel(col);
			widget = field+help;
		    } else {
			widget= HU.div([ATTR_CLASS,"display-search-block"], field+help);
		    }
		} else if (col.isNumeric()) {
		    let from = HU.input("", "", [ATTR_TITLE,"greater than",ATTR_CLASS, "input display-simplesearch-input", ATTR_STYLE,HU.css("width","2.5em"), ATTR_ID, id+"_from"]);
		    let to = HU.input("", "", [ATTR_TITLE,"less than",ATTR_CLASS, "input display-simplesearch-input", ATTR_STYLE,HU.css("width","2.5em"), ATTR_ID, id+"_to"]);		    
		    label = col.getSearchLabel();
                    widget = from +" - " + to +help;
                } else if(col.isLatLon()) {
		    let areaWidget= col.areaWidget = new AreaWidget(this,col.getName());
		    label = this.makeLabel(col.getSearchLabel());
                    widget= HU.div([ATTR_ID,this.domId(col.getName())], areaWidget.getHtml());
                } else if(col.getType()=='string') {
                    field = HU.input("", savedValue??this.getSearchValue(col.getName()), [ATTR_PLACEHOLDER,col.getSearchLabel(),ATTR_CLASS, "input display-simplesearch-input", ATTR_SIZE, this.getTextInputSize(), ATTR_ID, id]);
                    widget =  field + " " + help;
		}
		let close = !inGroup;
		let toggleCloseProperty = this.getProperty(col.getName()+'.toggleClose',this.getToggleClose());
		if(Utils.isDefined(toggleCloseProperty)) {
		    close = String(toggleCloseProperty)=='true';
		}
		if(!toggleClose) close = false;

		extra+=this.addWidget(label,widget,{
		    addToggle:!inGroup,
		    addSimpleToggle:inGroup,
		    toggleClose:close
		});
	    }

	    if(inGroup) extra+='</div></div>';
            this.writeHtml(ID_TYPEFIELDS, extra);
	    this.jq(ID_TYPEFIELDS).find('.display-metadatalist').each(function() {
		let opts = $(this).find(TAG_OPTION);
		if(opts.length<popupLimit) return;
		HU.makeSelectTagPopup($(this),{
		    hide:false,
		    label:$(this).attr('data-label')});
	    });

	    let _this = this;
	    this.jq(ID_TYPEFIELDS).find(".ramadda-expr").change(function() {
		let id = $(this).attr(ATTR_ID);
		let val = $(this).val();
		id  = id.replace("_expr","_to");
		if(val=="between")
		    $("#" + id).show();
		else
		    $("#" + id).hide();
	    });
	    let cbxs = this.jq(ID_TYPEFIELDS).find(".display-entrylist-enum-checkbox");
	    cbxs.change(()=>{
		this.submitSearchForm();
	    });

	    let menus = this.jq(ID_TYPEFIELDS).find(".display-searchmenu");
	    HtmlUtils.initSelect(menus);
	    let allMenus = this.jq(ID_TYPEFIELDS).find(".display-metadatalist");
	    allMenus.change(()=>{
		this.submitSearchForm();
	    });
	    cols.forEach(col=>{
		if(col.areaWidget) {
		    col.areaWidget.initHtml();
		}
	    });
        },
        getEntries: function() {
            if (this.entryList == null) return [];
            return this.entryList.getEntries();
        },
        loadNextUrl: function() {
            let skip = +this.getSearchSettings().skip + parseInt(this.getSearchSettings().getMax());
	    this.getSearchSettings().skip = skip;
            this.submitSearchForm();
        },
        loadMore: function() {
            this.getSearchSettings().setMax( parseInt(this.getSearchSettings().getMax())+ DEFAULT_MAX);
	    this.jq(ID_SEARCH_MAX).val(this.getSearchSettings().getMax());

            this.submitSearchForm();
        },
        loadLess: function() {
            let max = this.getSearchSettings().getMax();
            max = parseInt(0.75 * max);
            this.getSearchSettings().setMax( Math.max(1, max));
	    this.jq(ID_SEARCH_MAX).val(this.getSearchSettings().getMax());
            this.submitSearchForm();
        },
        loadPrevUrl: function() {
            this.getSearchSettings().skip = Math.max(0, this.getSearchSettings().skip - this.getSearchSettings().getMax());
            this.submitSearchForm();
        },
        entryListChanged: function(entryList) {
            this.entryList = entryList;
        }
    });
}


function RamaddaEntrylistDisplay(displayManager, id, properties, theType) {
    if (theType == null) {
        theType = DISPLAY_ENTRYLIST;
    }
    const SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_ENTRYLIST, properties);
    let myProps = [];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        haveDisplayed: false,
        selectedEntries: [],
        getSelectedEntries: function() {
            return this.selectedEntries;
        },
        initDisplay: function() {
            let _this = this;
            if (this.getIsLayoutFixed() && this.haveDisplayed) {
                return;
            }
            this.haveDisplayed = true;
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
            this.providerChanged(true);
            if (this.dateRangeWidget) {
                this.dateRangeWidget.initHtml();
            }
            if (this.createdateRangeWidget) {
                this.createdateRangeWidget.initHtml();
            }	    
            SUPER.initDisplay.apply(this);
            if (this.entryList != null && this.entryList.haveLoaded) {
                this.entryListChanged(this.entryList);
            }
	    if(!this.getProvidersMultiple()) {
		HU.initSelect(this.jq(ID_PROVIDERS), { multiple:true,autoWidth: false,  "max-height":"100px"});
	    }
            this.jq(ID_PROVIDERS).change(function() {
                _this.providerChanged();
            });
        },
        providerChanged: function(initialCall) {
	    if(this.jq(ID_PROVIDERS).length==0) return;
	    if(!initialCall && this.jq(ID_ANCESTOR).val) {
		this.jq(ID_ANCESTOR).val("");
		this.jq(ID_ANCESTOR+"_hidden").val("");		
	    }
	    this.getSearchSettings().skip=0;
            let id = this.jq(ID_PROVIDERS).val();
	    this.provider = this.providerMap[id];
	    if(Utils.stringDefined(id) && id!='this') {
		this.addToDocumentUrl(ID_PROVIDERS,id);
	    }
	    this.jq(ID_SEARCH_BAR).html("");
	    let blocks = [ID_SEARCH_AREA, ID_SEARCH_TAGS,ID_SEARCH_ANCESTOR,ID_SEARCH_DATE_CREATE,ID_SEARCH_DATE_RANGE];
            if (this.provider && this.provider.type!="ramadda") {
		this.setRamadda(this.originalRamadda);
		let caps = (this.provider.capabilities||"").split(",");
		caps.forEach(cap=>{
		    let index = blocks.indexOf("search_" + cap);
		    if(index>=0) {
			blocks.splice(index,1);
		    }
		});
		//area
		blocks.forEach(id=>{
		    this.jq(id).hide();
		});
		this.jq(ID_TYPE_DIV).hide();
            } else {
		blocks.forEach(id=>{
		    this.jq(id).show();
		});
		this.jq(ID_TYPE_DIV).show();
		if(this.getSearchDirect()) {
		    if(this.provider)
			this.setRamadda(getRamadda(this.provider.id+";"+ this.provider.name));
		    this.addTypes();
		    this.initMetadata();
		}
            }
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.apply(this, menuItems);
            if (this.getSelectedEntriesFromTree().length > 0) {
                let get = this.getGet();
                menuItems.push(HU.onClick(get + ".makeDisplayList();", "Make List"));
                menuItems.push(HU.onClick(get + ".makeDisplayGallery();", "Make Gallery"));
            }
        },
        makeDisplayList: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries,
                showForm: false,
                showMenu: true,
                fixedEntries: true
            };
            props.entryList = new EntryList(this.getRamadda(), "", this, false);
            props.entryList.setEntries(entries);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRYLIST, props);
        },
        makeDisplayGallery: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries
            };

	    let eg = this.getEgText();
	    let text  = this.getFormText();
            let textField = HU.input("", text, [ATTR_PLACEHOLDER, eg, ATTR_CLASS, "display-search-input", ATTR_SIZE, "30", ATTR_ID, this.getDomId(ID_TEXT_FIELD)]);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRY_GALLERY, props);
        },
        handleEventEntrySelection: function(source, args) {
            this.selectEntry(args.entry, args.selected);
        },
        selectEntry: function(entry, selected) {
            let changed = false;
            if (selected) {
                this.jq("entry_" + entry.getIdForDom()).addClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index < 0) {
                    this.selectedEntries.push(entry);
                    changed = true;
                }
            } else {
                this.jq("entry_" + entry.getIdForDom()).removeClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index >= 0) {
                    this.selectedEntries.splice(index, 1);
                    changed = true;
                }
            }
        },
        makeEntriesDisplay: function(entries) {
	    this.tabId = null;
	    this.mapId = null;
	    if(this.myDisplays) {
		this.myDisplays.forEach(info=>{
		    if(info.display)
			removeRamaddaDisplay(info.display.getId());
		});
	    }
	    this.myDisplays = [];


	    let titles = [];
	    let contents = [];

	    let addContents=c=>{
		contents.push(HU.div([ATTR_CLASS,'display-entrylist-results'],c));
	    }

	    let makeExpandable= (html) =>{
		html =HU.div([ATTR_STYLE,HU.css('max-height','1000px','background','#fff','overflow-y','auto')],html);
		return HU.div([ATTR_CLASS,'ramadda-expandable-wrapper',ATTR_STYLE,HU.css('position','relative')],html);
	    }

	    this.getDisplayTypes('list').split(',').forEach(type=>{
		if(type=='list') {
		    titles.push('List');
		    addContents(makeExpandable(this.getEntriesTree(entries)));
		} else if(type=='images') {
		    let defaultImage = this.getDefaultImage();
		    let imageEntries = entries.filter(entry=>{
			if(defaultImage) return true;
			return entry.isImage();
		    });
		    if(imageEntries.length>0) {
			titles.push('Images');
			let id = HU.getUniqueId(type +'_');
			this.myDisplays.push({id:id,type:type});
			let images =HU.div([ATTR_ID,id,ATTR_CLASS,'ramadda-expandable display-entrylist-images',ATTR_STYLE,HU.css('width','100%')]);
			addContents(makeExpandable(images));
		    }
		} else if(type=='timeline') {
		    titles.push('Timeline');
		    let id = HU.getUniqueId(type +'_');
		    this.myDisplays.push({id:id,type:type});
		    addContents(HU.div([ATTR_ID,id,ATTR_STYLE,HU.css('width','100%')]));
		} else if(type=='map') {
		    this.areaEntries = entries.filter(entry=>{
			return entry.hasBounds() || entry.hasLocation();
		    });
		    if(this.areaEntries.length>0) {
			titles.push('Map');
			let id = HU.getUniqueId(type +'_');
			this.myDisplays.push({id:id,type:type,entries:this.areaEntries});
			addContents(HU.div([ATTR_ID,id,ATTR_STYLE,HU.css('width','100%')]));
		    }

		} else if(type=='metadata') {		    
		    titles.push('Metadata');
		    let mtd = HU.div([ATTR_STYLE,HU.css('width','800px','max-width','800px','overflow-x','auto')],this.getEntriesMetadata(entries));
		    addContents(mtd);
		} else {
		    console.log('unknown display:' + type);
		}
	    });

	    if(titles.length==1) 
		return HU.div([ATTR_CLASS,'display-entrylist-content-border'],contents[0]);
	    let tabId = HU.getUniqueId('tabs_');
	    let tabs = HU.open(TAG_DIV,[ATTR_ID,tabId,ATTR_CLASS,'ui-tabs']) +'<ul>';
	    titles.forEach((title,idx)=>{
		tabs +='<li>' +HU.href('#' + tabId+'-' + idx,title) +'</li>\n'
	    })
	    tabs +='</ul>\n';
	    this.tabCount = contents.length;
	    contents.forEach((content,idx)=>{
		tabs +=HU.div([ATTR_ID,tabId+'-' + idx,ATTR_CLASS,'ui-tabs-hide'], content);
	    });
	    tabs +=HU.close(TAG_DIV);
	    this.tabId = tabId;
	    return tabs;
        },

	handleSearchLink:function(event,button,dontAsk) {
	    let copy = button.attr('data-copy');
	    if(copy) {
		Utils.copyToClipboard(copy);
		alert('The URL has been copied to the clipboard');
		return;
	    }		

	    let url = button.attr('data-url');
	    let format = button.attr('data-format')
	    let formatName = button.attr('data-name')	    
	    let size = "100";
	    let doit = (extra) =>{
		url = url.replace(/max=\d+/,'max='+size);
		if(extra) url+=extra;
		if(event.shiftKey) {
		    let protocol = window.location.protocol;
		    let hostname = window.location.hostname;
		    let port = window.location.port;
		    let prefix = `${protocol}//${hostname}${port ? `:${port}` : ''}`;
		    url = prefix+url;
		    Utils.copyToClipboard(url);
		    alert('The URL has been copied to the clipboard');
		} else {
		    Utils.triggerDownload(url);
		}
	    };

	    size= this.jq(ID_SEARCH_MAX).val();
	    if(!dontAsk) {
		if(format==OUTPUT_CHOOSE) {
		    let html = HU.formTable();
		    html += HU.formEntry('Number of Records:',
					 HU.input('',size,[ATTR_ID,this.domId('downloadrecords'),ATTR_SIZE,'5']));
		    let select= [['csv','CSV'],['json','JSON'], ['wget','wget File Download'],['csvapi','wget CSV API'],['ids','IDs'],
				 ['wrapper_r','R Wrapper'],
				 ['wrapper_python','Python Wrapper'],
				 ['wrapper_matlab','Matlab Wrapper']];
		    html+= HU.formEntry('What to download:',
					HU.select('',[ATTR_ID,this.domId('downloadwhat')],select));
		    let buttons = HU.buttons([
			HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK'),
			HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel')]);
		    html+=HU.formTableClose();
		    html+=buttons;
		    html = HU.div([ATTR_STYLE,'margin:5px;'], html);
		    let dialog = HU.makeDialog({content:html,
						title:'Download options',
						anchor:button,
						draggable:true,header:true});
		    dialog.find('.ramadda-button-ok').button().click(()=>{
			size = this.jq('downloadrecords').val();
			what = this.jq('downloadwhat').val();
			doit('&what='+ what);
			dialog.remove();
		    });
		    dialog.find('.ramadda-button-cancel').button().click(()=>{
			dialog.remove();			
		    });
		} else {
		    size = prompt('How many records do you want in the ' + formatName +' download?',size);
		    if(!size) return;
		    
		    doit();
		}
	    } else {
		doit();
	    }
	},
        entryListChanged: function(entryList) {
            if (this.multiSearch) {
                this.multiSearch.count--;
            }
            SUPER.entryListChanged.apply(this, [entryList]);
            let entries = this.entryList.getEntries();

            if (entries.length == 0) {
		//                this.getSearchSettings().skip = 0;
                this.getSearchSettings().setMax(DEFAULT_MAX);
                let msg = "Nothing found";
                if (this.multiSearch) {
                    if (this.multiSearch.count > 0) {
                        msg = "Nothing found so far. Still searching " + this.multiSearch.count + " repositories";
                    } else {}
                }
                this.writeHtml(ID_FOOTER_LEFT, "");
		this.jq(ID_ENTRIES).html(this.getMessage(msg));
		//                this.writeMessage(msg);		
                this.getDisplayManager().handleEventEntriesChanged(this, []);
		//		this.jq(ID_ENTRIES).html("");
		//                return;
            }
	    this.writeMessage(this.getResultsHeader(entries));
            if (entries.length == 0) {
		return
	    }

            let get = this.getGet();
            this.writeHtml(ID_FOOTER_LEFT, "");
            if (this.footerRight != null) {
		let _this =this;
                this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
		this.jq(ID_FOOTER_RIGHT).find('.ramadda-search-link').button().click(function(event) {
		    let custom  =$(this).attr('custom-output');
		    _this.handleSearchLink(event,$(this),custom);
		});
            }

            let entriesHtml = this.makeEntriesDisplay(entries);
	    let html = entriesHtml;
            this.writeEntries(html, entries);
	    this.jq(ID_ENTRIES).find('.ramadda-metadata-bigtext').each(function() {
		Utils.initBigText($(this));
	    });

            this.addEntrySelect();
            this.getDisplayManager().handleEventEntriesChanged(this, entries);
	    if(this.galleryId) {
		HU.createFancyBox($("#" + this.galleryId).find("a.popup_image"),{helpers:{title:{type:'over'}}});
	    }


	    let tabbed = (event,ui)=>{
		this.activeTabIndex = ui.newTab.index();
		HtmlUtil.tabLoaded();
	    };
	    if(this.tabId) {
		let index = this.activeTabIndex;
		if(index>=this.tabCount)  index = this.tabCount-1;
		$('#' + this.tabId).tabs({activate: tabbed,active: index});
	    }	
	    if(this.myDisplays && this.myDisplays.length) {
		let index=0;
		let fields = [new RecordField({type: "string", index: (index++), id: "name",label: "Name"}),
			      new RecordField({type: "string", index: (index++), id: "description",label: "Description"}),
			      new RecordField({type: "date", index: (index++), id: "date",label: "Date"}),			      
			      new RecordField({type: "url", index: (index++), id: "url",label: "URL"}),
			      new RecordField({type: "image", index: (index++), id: "image",label: "Image"}),
			      new RecordField({type: "url", index: (index++), id: "iconUrl",label: "Icon"}),
			      new RecordField({type: "string", index: (index++), id: "tags",label: "Tags"}),
			      new RecordField({type: "string", index: (index++), id: "display_html",label: "Display Html"}),
			      new RecordField({type: "string", index: (index++), id: ATTR_ID,label: "Entry ID"}),			      
			      new RecordField({index: (index++), id: "latitude",label: "Latitude"}),
			      new RecordField({index: (index++), id: "longitude",label: "Longitude"}),			      			      					     ]
		let entryType = null;
		if(this.entryTypes && this.entryTypes.length) {
		    entryType = this.entryTypes[0];
		    entryType.getColumns().forEach(column=>{
			fields.push(new RecordField({index: (index++), id: column.getName(),label: column.getLabel()}));
		    });
		}
		let records = [];
		let defaultImage = this.getDefaultImage();
		if(defaultImage) {
		    if(defaultImage.startsWith("http"))
			defaultImage = ramaddaBaseUrl+ defaultImage;
		}
		let makeData = entries=>{
		    let records = [];
		    entries.forEach(entry=>{
			let tags = this.makeEntryTags(entry,true,"");
			let displayHtml = entry.displayHtml??entry.getName()
			let data = [entry.getName(true),
				    entry.getSnippet()||"",
				    entry.getStartDate(),
				    entry.getEntryUrl(),
				    entry.getImageUrl()||defaultImage||"",
				    entry.getIconUrl(),
				    tags,
				    displayHtml,
				    entry.getId(),
				    entry.getLatitude(),
				    entry.getLongitude()];
			if(entryType) {
			    entryType.getColumns().forEach(column=>{
				let v = entry.getAttributeValue(column.getName());
				data.push(v);
			    });
			}
			records.push(new PointRecord(fields, entry.getLatitude(),entry.getLongitude(),NaN,entry.getStartDate() || entry.getCreateDate(),data,0));
		    });
		    return records;
		};
		let baseData= new  PointData("pointdata", fields, makeData(entries),null,null);
		let _this = this;
		this.myDisplays.forEach(info=> {
		    let data = info.entries?new  PointData("pointdata", fields, makeData(info.entries)):baseData;
		    let dialogListener = (display, dialog)=>{
			dialog.find(".display-search-tag").click(function() {
			    let type = $(this).attr("metadata-type");
			    let value = $(this).attr("metadata-value");			    
			    if(!_this.addMetadataTag(type,type, value)) return;
			    _this.submitSearchForm();
			});
		    };
		    let tooltip = this.getProperty("tooltip")??"${default}";
		    let myTextGetter = null;


		    if(info.type=='map' && entryType && entryType.mapwiki) {
			myTextGetter = (display, records)=>{
			    if(records.length>1) return null;
			    let uid = HU.getUniqueId();
			    let entryId = records[0].data[8];
			    this.wikify(entryType.mapwiki,entryId,null,null,uid);
			    return HU.div([ATTR_ID,uid],
					  HU.center(HU.image(ramaddaCdn + '/icons/mapprogress.gif',[ATTR_WIDTH,'80px'])));
			};
		    }
		    let props = {centerOnMarkersAfterUpdate:true,
				 dialogListener: dialogListener,
				 highlightColor:"#436EEE",
				 blockStyle:this.getProperty("blockStyle",""),
				 doPopup:this.getProperty("doPopup",true),
				 tooltip:tooltip,
				 tooltipClick:tooltip,
				 myTextGetter:myTextGetter,
				 descriptionField:"description",
				 imageWidth:"140px",
				 blockWidth:"150px",
				 numberOfImages:500,
				 includeNonImages:this.getProperty('includeNonImages',true),
				 showTableOfContents:true,

				 showTableOfContentsTooltip:false,
				 addMapLocationToUrl:false,
				 canMove:true,
				 iconField:"iconUrl",
				 iconSize:16,
				 displayEntries:false,
				 imageField:"image",
				 urlField:"url",
				 titleField:"name",
				 labelField:"name",
				 labelFields:"name",
				 showBottomLabel:false,
				 bottomLabelTemplate:"",
				 topLabelTemplate:"${name}",
				 textTemplate:"${description}",
				 displayId:info.id,
				 divid:info.id,
				 showMenu:false,
				 theData:data,
				 displayStyle:"",
				 mapHeight:'400',
				 loadingMessage:''};
		    info.display =  this.getDisplayManager().createDisplay(info.type,props);
		});
	    }





	    this.jq(ID_ENTRIES).find('.ramadda-expandable-wrapper').each(function() {
		HU.makeExpandable($(this), false,{right:'5px',top:'0px'});
	    });


	    if(this.mapId && this.areaEntries && this.areaEntries.length>0) {
		let map = new RepositoryMap(this.mapId);
		map.initMap(false);
		this.areaEntries.forEach(entry=>{
                    let link = HU.tag(TAG_A, ["target","_entries",ATTR_HREF, entry.getEntryUrl()], entry.getName());
		    let text = link;
		    if(entry.isImage()) {
			text = HU.image(entry.getResourceUrl(), [ATTR_WIDTH, "400", ATTR_ID,
								 this.getDomId("entry_" + entry.getIdForDom()),
								 ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
								]) +"<br>" + link;


			
		    }
		    //		    map.addMarker:  function(id, location, iconUrl, markerName, text, parentId, size, yoffset, canSelect, attrs) {
		    map.addMarker('',{x:entry.getLongitude(),y:entry.getLatitude()}, entry.getIconUrl(),"",text,null,16,0,true,{});
		    /*
		      {"pointRadius":16,
		      "strokeWidth":1,
		      "fillColor":"blue",
		      "strokeColor":"#000"},text);
		    */
		});
		map.centerOnMarkersInit(null);
	    }

        },
    });
}


function RamaddaSimplesearchDisplay(displayManager, id, properties) {
    let myProps = [
	{label:'Simple Search'},
	{p:'resultsPosition',ex:'absolute|relative'},
	{p:'maxHeight',ex:300},
	{p:'maxWidth',ex:200},
	{p:'maxWidth',ex:200},		
	{p:'autoSearch',ex:true},
	{p:'showHeader',ex:true},
	{p:'inputSize',d:'200px',ex:'100%'},
	{p:'placeholder'},
	{p:'searchEntryType',ex:'',tt:'Constrain search to entries of this type'},		
	{p:'doPageSearch',ex:'true',tt:'Just search in the page'},
	{p:'autoFocus',d:false,ex:'false',tt:'auto focus on the search input field'},	
	{p:'doTagSearch',ex:'true'},
	{p:'tagShowGroup',d:true},
	{p:'tagSearchLimit',tt:'Show the inline search box for tags when the #tags exceeds the limit',d:15},
	{p:'pageSearchSelector',d:'.search-component,.entry-list-row-data'},
	{p:'applyToEntries',ex:true,tt:'When doing the entry search use the IDs to hide/show components'},
	{p:'pageSearchParent',ex:'.class or #id',tt:'set this to limit the scope of the search'},
        {p:'showParent',ex:'true',tt:'Show parent entry in search results'},		
    ];

    if(!properties.width) properties.width=properties.inputSize??"230px";
    const SUPER   = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_SIMPLESEARCH, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	callNumber:1,
        haveDisplayed: false,
        selectedEntries: [],
        getSelectedEntries: function() {
            return this.selectedEntries;
        },
        getDoInlineSearch: function() {
	    return this.getDoPageSearch() || this.getDoTagSearch();
	},
        initDisplay: function() {
	    $(document).ready(()=> {
		this.initDisplayInner();
	    });
	},
        initDisplayInner: function() {
            let _this = this;
            if (this.getIsLayoutFixed() && this.haveDisplayed) {
                return;
            }
            this.haveDisplayed = true;
            this.createUI();


	    let contents = "";
	    if(this.getDoTagSearch()) {
		let sel = this.getPageSearchSelectors();
		contents += '<div class=metadata-tags>';
		let tags ={};
		let list = [];
		sel.find('.metadata-tag').each(function() {
		    $(this).addClass('ramadda-clickable').click(function(){
			_this.selectTag($(this).attr('metadata-tag'));
		    });
		    let tag = $(this).attr('metadata-tag');
		    if(!tags[tag]) {
			tags[tag] = {
			    group:$(this).attr('metadata-group'),
			    tag:tag,
			    count:0,
			    elements:[]
			}
			list.push(tags[tag]);
		    }
		    tags[tag].count++;
		    tags[tag].elements.push($(this));
		});
		list = list.sort((a,b)=>{
		    if(a.group && b.group) {
			let c = a.group.localeCompare(b.group);
			if(c!=0) return c;
		    }
		    return b.count-a.count;
		});
		let groupMap={};
		let groups=[];
		list.forEach(obj=>{
		    let currentGroup=obj.group??''
		    let group = groupMap[currentGroup];
		    if(!group) {
			group = groupMap[currentGroup] = {
			    contents:'',
			    cnt:0
			}
			groups.push(currentGroup);
		    }
		    
		    group.cnt++;
		    let tag = obj.tag;
		    let ele = obj.elements[0];
		    if(ele.attr('data-image-url')) {
			let title = ele.attr(ATTR_TITLE)+HU.getTitleBr()??'';
			title+='Click to filter';
			group.contents+=HU.image(ele.attr('data-image-url'),[ATTR_CLASS,'metadata-tag ramadda-clickable','metadata-tag',tag,ATTR_TITLE,title]);
		    } else {
			let label = '#'+obj.count+': ' + tag.replace(/^[^:]+:/,'');
			style = ele.attr(ATTR_STYLE);
			group.contents+=HU.div(['data-background',ele.attr('data-background'),
						'data-style',style??'',
						ATTR_STYLE,style??'',ATTR_CLASS,'metadata-tag ramadda-clickable','metadata-tag',tag],label);
		    }
		});
		groups.forEach(g=>{
		    let group = groupMap[g];
		    let block = '';
		    if(g!='') {
			if(this.getTagShowGroup()) {
			    block+=HU.b(g)+': ';
			}
			group.contentsid=HU.getUniqueId('taggroup');
			if(group.cnt>this.getTagSearchLimit()) {
			    group.uid=HU.getUniqueId('taggroup');
			    block+=HU.span([ATTR_ID,group.uid]);
			}			    
		    }			
		    block+=HU.span([ATTR_ID,group.contentsid],group.contents);
		    contents+=HU.div([ATTR_STYLE,'text-align:left;'],block);
		})
		contents+='<div>';
		if(this.getDoPageSearch()) {
		    contents = HU.center(this.getDefaultHtml() + contents);
		} 
		this.setContents(contents);
		groups.forEach(g=>{
		    let group = groupMap[g];
		    if(group.uid) {
			HU.initPageSearch('#' + group.contentsid +' .metadata-tag',null,'Find tags',false,{target:'#'+group.uid,inputSize:'10'});
		    }
		});
		this.find(".metadata-tag").click(function(){
		    if($(this).hasClass("metadata-tag-selected")) {
			$(this).removeClass("metadata-tag-selected");
			$(this).css('background',$(this).attr('data-background')??"");
			let style = $(this).attr('data-style');
			if(style) $(this).attr(ATTR_STYLE,style);
		    } else {
			$(this).addClass("metadata-tag-selected");
			$(this).css('background','');
		    }
		    _this.doInlineSearch();
		});

	    } else {
		this.setContents(this.getDefaultHtml());
	    }


	    if(this.getDoPageSearch() && this.getAutoFocus()) {
		//Put this in a timeout because if it is in a tabs then the whole page gets scrolled
                setTimeout(()=>{
		    this.jq(ID_TEXT_FIELD).focus();
                },500);
	    }

	    this.initHtml();
	    let input = this.jq(ID_TEXT_FIELD);
	    if(this.getAutoSearch(true)) {
		//KEY
		input.keyup(function(event) {
		    _this.getSearchSettings().skip =0;
                    _this.getSearchSettings().setMax(DEFAULT_MAX);
		    let val = $(this).val().trim();
		    if(val=="") {
			_this.clearSearch();
			return;
		    }
		    if(!_this.getDoPageSearch()) {
			if(val.length<4) return;
		    }
		    let myCallNumber = ++_this.callNumber;
		    //Wait a bit in case more keys are coming
		    setTimeout(()=>{
			if(myCallNumber == _this.callNumber) {
			    _this.doSearch(true,myCallNumber);
			} else {
			}
		    },400);
		});
	    }

            this.jq(ID_SEARCH).click(function(event) {
		_this.doSearch(false,++_this.callNumber);
                event.preventDefault();
            });
            this.jq(ID_FORM).submit(function(event) {
		_this.doSearch(false,++_this.callNumber);
                event.preventDefault();
            });


            this.jq(ID_TEXT_FIELD).autocomplete({
                source: function(request, callback) {
                }
            });
	},
        getDefaultHtml: function() {
	    let html = this.makeSearchForm();
	    let style="";
	    let abs = (this.getProperty("resultsPosition","absolute")=="absolute");
	    if(!abs) {
		if(this.getMaxHeight(400)) {
		    style+=HU.css("max-height",HU.getDimension(this.getMaxHeight(400)));
		} 
		if(this.getMaxWidth()) {
		    style+=HU.css("width",HU.getDimension(this.getMaxWidth(400)));
		    style+=HU.css("max-width",HU.getDimension(this.getMaxWidth(200)));
		}
		let entries = HU.div([ATTR_ID,this.domId(ID_ENTRIES),ATTR_CLASS,"display-simplesearch-entries",ATTR_STYLE,style]);
		if (this.getShowHeader(true)) {
		    html+=  HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)]);
		}
		html+=entries;
	    }
	    return html;
	},
        makeSearchForm: function() {
            let form = HU.openTag(TAG_FORM, [ATTR_ID, this.getDomId(ID_FORM), "action", "#"]);
	    
	    let eg = this.getEgText();
	    let text  = this.getFormText();
	    let hadInitText = false;
	    if(!Utils.stringDefined(text) && this.getDoPageSearch()) {
		text = HU.getUrlArgument(ARG_PAGESEARCH)??'';
		if(Utils.stringDefined(text)) {
		    hadInitText = true;
		}
	    }


	    let size = HU.getDimension(this.getPropertyInputSize());
            let textField = HU.input("", text, [ATTR_STYLE, HU.css("width", size), ATTR_PLACEHOLDER, eg, ATTR_CLASS, "display-search-input", ATTR_ID, this.getDomId(ID_TEXT_FIELD)]);

	    form += textField;
            form += "<input type=\"submit\" style=\"position:absolute;left:-9999px;width:1px;height:1px;\"/>";
            form += HU.closeTag(TAG_FORM);
	    form+=HU.div([ATTR_ID,this.domId(ID_FORM)]);
	    if(hadInitText) {
		setTimeout(()=>{
		    this.doInlineSearch();
		},1);
	    }
            return form;
	},
	handleNoEntries: function() {
	    this.writeEntries("",[]);
            this.writeMessage("Nothing found");
            this.getDisplayManager().handleEventEntriesChanged(this, []);
	},
	writeMessage: function(msg) {
	    this.makeDialog();
	    SUPER.writeMessage.call(this,msg);
	},

	makeDialog: function() {
	    if(this.dialog && (this.dialog.parent()==null ||this.dialog.parent().length==0)) this.dialog = null;
	    if(!this.dialog) {
                let header = HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)], "&nbsp;");
                let entries= HU.div([ATTR_CLASS,"display-entries-entries", ATTR_ID, this.getDomId(ID_ENTRIES)], "");		
		this.dialog = HU.makeDialog({content:header+entries,anchor:this.getContents(),
					     draggable:true,header:true});
	    } else {
		this.dialog.show();
	    }
	},	    
	writeEntries: function(msg, entries) {
	    let abs = this.getProperty("resultsPosition","absolute")=="absolute";
	    if(!abs) {
		this.jq(ID_ENTRIES).html(msg);
		return;
	    }
	    this.makeDialog();

	    if(Utils.stringDefined(msg)) {
		this.jq(ID_ENTRIES).html(msg);
		this.writeMessage(this.getResultsHeader(entries,true));
	    } else {
		this.jq(ID_ENTRIES).html("");
	    }
	},

	getPageSearchSelectors:function() {
	    let top = this.getPageSearchParent() || "body";
	    let parent = $(top);
	    //Try with "#" id
	    if(parent.length==0 && this.getPageSearchParent()) {
		let selector = this.getPageSearchParent();
		if(selector.startsWith('.')) {
		    parent = $(selector);
		} else  {
		    parent = $("#"+selector);
		}		    
	    }
	    let sel=parent.find(this.getPageSearchSelector());
	    if(sel.length==0) {
		console.log(this.type+" could not find page search components:" + this.getPageSearchSelector());
	    }
	    return sel;

	},
	selectTag:function(tag) {
	    let _this  = this;
	    let tags = this.find(".metadata-tag");
	    tags.each(function() {
		if(tag == $(this).attr('metadata-tag')) {
		    $(this).addClass("metadata-tag-selected");
		    _this.doInlineSearch();
		}
	    });
	},
	doInlineSearch:function() {
	    let regExp;
	    let value;
	    let selectedTags;
	    if(this.getDoPageSearch()) {
		value = (this.jq(ID_TEXT_FIELD).val()||"").trim();
		value  = value.toLowerCase();
		if(value!="") {
		    try {
			regExp  = new RegExp(value);
		    } catch(err) {
			console.log("bad regexp:" + err);
		    }
		} else {
		    value = null;
		}
	    }

	    if(this.getDoTagSearch()) {
		let tags = this.find(".metadata-tag-selected");
		if(tags.length>0) {
		    tags.each(function(){
			let tag = $(this).attr("metadata-tag");
			if(!selectedTags) selectedTags={};
			selectedTags[tag] = true;
		    });
		}
	    }

	    if(!value && !selectedTags) {
		this.clearPageSearch();
		if(this.getDoPageSearch()) {
		    HU.removeFromDocumentUrl(ARG_PAGESEARCH);
		}
		return
	    }
	    let sel = this.getPageSearchSelectors();
	    sel.each(function() {
		let tagOk = true;
		let textOk = true;		
		if(selectedTags) {
		    tagOk = false;
		    let t = $(this).find(".metadata-tag");
		    t.each(function(){
			let tag = $(this).attr("metadata-tag");
			if(selectedTags[tag]) tagOk=true;
		    });
		}
		if(value) {
		    let values = Utils.split(value,",",true,true);
		    textOk = false;
		    let html = Utils.stripTags($(this).html());
		    let corpus = $(this).attr('data-corpus')??' ';
		    html+=corpus+' ';
		    html+=$(this).attr('entryid')??' ';		    
		    html = html.toLowerCase();
		    textOk = true;
		    values.every(v=>{
			textOk = false;
			if(html.indexOf(v)>=0) {
			    textOk = true;
			} else if(regExp) {
			    if(html.match(regExp)) textOk = true;
			}
			return textOk;
		    });
		}
		if(!tagOk || !textOk) {
		    $(this).fadeOut();
		} else {
		    $(this).show();
		}
	    });

	    if(this.getDoPageSearch()) {
		HU.addToDocumentUrl(ARG_PAGESEARCH,value);
	    }
	    
	    
	},
	clearPageSearch:function() {
	    let sel = this.getPageSearchSelectors();
	    sel.show();
	},
	clearSearch:function() {
	    if(this.getApplyToEntries()) {
		let sel = this.getPageSearchSelectors();
		sel.each(function() {
		    $(this).show();
		});
	    }
	    this.writeMessage("");
	    this.writeEntries("");			
	    if(this.dialog) {
		this.dialog.remove();
		this.dialog = null;
	    }
	    if(this.getDoInlineSearch()) {
		this.doInlineSearch();
	    }
	},
	doSearch:function(auto, callNumber) {
	    if(this.getDoPageSearch()) {
		this.doInlineSearch();
		return;
	    }
	    this.submitSearchForm(auto,callNumber);
	},
        submitSearchForm: function(auto, callNumber) {
	    this.writeMessage(this.getWaitImage() + " " +"Searching...");
	    if(callNumber==null) callNumber = this.callNumber;
            this.haveSearched = true;
            let settings  =this.makeSearchSettings();
	    settings.entryType = this.getSearchEntryType();	    
            let jsonUrl = this.makeSearchUrl(this.getRamadda());
            this.entryList = new EntryList(this.getRamadda(), jsonUrl);
	    let success= ()=>{
		if(this.callNumber == callNumber) {
		    this.entryListChanged(this.entryList);
		} 
	    };
	    let fail= (error)=>{
		this.writeEntries("Error:" + error);
	    };	    
	    this.entryList.doSearch(null,success,fail);
	    if(!auto)
		this.updateForSearching(jsonUrl);
        },

        makeDisplayList: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries,
                showForm: false,
                showMenu: true,
                fixedEntries: true
            };
            props.entryList = new EntryList(this.getRamadda(), "", this, false);
            props.entryList.setEntries(entries);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRYLIST, props);
        },
        handleEventEntrySelection: function(source, args) {
            this.selectEntry(args.entry, args.selected);
        },
        selectEntry: function(entry, selected) {
            let changed = false;
            if (selected) {
                this.jq("entry_" + entry.getIdForDom()).addClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index < 0) {
                    this.selectedEntries.push(entry);
                    changed = true;
                }
            } else {
                this.jq("entry_" + entry.getIdForDom()).removeClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index >= 0) {
                    this.selectedEntries.splice(index, 1);
                    changed = true;
                }
            }
        },
        makeEntriesDisplay: function(entries) {
            return this.getEntriesTree(entries);
        },
        entryListChanged: function(entryList) {
            if (this.multiSearch) {
                this.multiSearch.count--;
            }
            let entries = this.entryList.getEntries();
	    if(this.getApplyToEntries()) {
		if(this.dialog) {
		    this.dialog.hide();
		}
		let sel = this.getPageSearchSelectors();
		//		this.writeMessage("Found: " + entries.length +" entries");

		if(entries.length==0) {
		    sel.each(function() {
			$(this).show();
		    });
		} else {
		    let map = {}
		    entries.forEach(e=>{
			map[e.getId()]=true;
		    });
		    sel.each(function() {
			let entryId = $(this).attr('entryid');
			if(!entryId) return;
			if(map[entryId]) {
			    $(this).show();
			} else {
			    $(this).fadeOut();
			}
		    });

		}
		//		return
	    }


            SUPER.entryListChanged.apply(this, [entryList]);


            if (entries.length == 0) {
                this.getSearchSettings().skip = 0;
                this.getSearchSettings().setMax(DEFAULT_MAX);
		this.handleNoEntries();
                return;
            }
            this.writeMessage(this.getResultsHeader(entries, true));
	    this.initCloser(ID_RESULTS);

            let get = this.getGet();
            this.writeHtml(ID_FOOTER_LEFT, "");
            if (this.footerRight != null) {
                this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
            }


	    let html = "";
	    let inner = "";
	    let map = {};
	    let showParent = this.getProperty("showParent");
	    entries.forEach((entry,idx) =>{
		map[entry.getId()] = entry;
		let thumb = entry.getThumbnail();
		let attrs = [ATTR_TITLE,entry.getName(),ATTR_CLASS,"display-simplesearch-entry","entryid",entry.getId()];
		if(thumb) attrs.push("thumbnail",thumb);
		let link = HU.href(this.getRamadda().getEntryUrl(entry),entry.getIconImage() +"  "+ entry.getName());
		if(showParent && entry.getParentName()) {
		    let url = ramaddaBaseUrl+ "/entry/show?entryid=" + entry.parent;
		    let plink = HU.href(url, HU.image(entry.parentIcon) +" " + entry.parentName);
		    link = HU.hbox([plink,HU.span([ATTR_STYLE,'margin-right:4px;margin-left:4px;'],"&raquo;"), link]);
		}
		inner+=HU.div(attrs, link);
	    });
	    //	    inner = HU.div([ATTR_CLASS,"display-simplesearch-entries"],inner);
            this.writeEntries(inner, entries);
	    let _this = this;
	    this.jq(ID_ENTRIES).find(".display-simplesearch-entry").tooltip({
		show: {
		    delay: 1000,
		    duration: 300
		},
		content: function() {
		    let entry = map[$(this).attr("entryid")];
		    if(!entry) return null;
		    let thumb = $(this).attr("thumbnail");
		    let parent;
		    let html =entry.getIconImage()+' '+ HU.b(entry.getName());
		    html+=HU.div([],'Type: ' + entry.getTypeName());
		    let snippet = entry.getSnippet();
		    if(snippet)
			html+=HU.div([ATTR_STYLE,HU.css('border-top','var(--basic-border)')],snippet);
		    if(thumb) {
			html+=
			    HU.div([ATTR_STYLE,HU.css('max-height','100px','overflow-y','hidden','border-top','var(--basic-border)')],
				   HU.image(thumb,['width','300px']));
		    }
		    return html;
		}});

            this.getDisplayManager().handleEventEntriesChanged(this, entries);
        },

    });
}





function RamaddaEntrygridDisplay(displayManager, id, properties) {
    const ID_CONTENTS = "contents";
    const ID_GRID = "grid";
    const ID_AXIS_LEFT = "axis_left";
    const ID_AXIS_BOTTOM = "axis_bottom";
    const ID_CANVAS = "canvas";
    const ID_LINKS = "links";
    const ID_RIGHT = "right";

    const ID_SETTINGS = "gridsettings";
    const ID_YAXIS_ASCENDING = "yAxisAscending";
    const ID_YAXIS_SCALE = "scaleHeight";
    const ID_XAXIS_ASCENDING = "xAxisAscending";
    const ID_XAXIS_TYPE = "xAxisType";
    const ID_YAXIS_TYPE = "yAxisType";
    const ID_XAXIS_SCALE = "scaleWidth";
    const ID_SHOW_ICON = "showIcon";
    const ID_SHOW_NAME = "showName";
    const ID_COLOR = "boxColor";

    let myProps = [];
    let SUPER = new RamaddaEntryDisplay(displayManager, id, DISPLAY_ENTRY_GRID, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        entries: properties.entries,
        initDisplay: function() {
            let _this = this;
            this.createUI();
            let html = HU.div([ATTR_ID, this.getDomId(ID_CONTENTS)], this.getLoadingMessage("Loading entries..."));
            this.setContents(html);
            if (!this.entryIds) {
                _this.jq(ID_CONTENTS).html(this.getLoadingMessage("No entries specified"));
                return;
            }
            let props = {
                entries: this.entryIds
            };
            let searchSettings = new EntrySearchSettings(props);
            let jsonUrl = this.getRamadda().getSearchUrl(searchSettings, OUTPUT_JSON, "BAR");
            let myCallback = {
                entryListChanged: function(list) {
                    _this.entries = list.getEntries();
                    if (_this.entries.length == 0) {
                        _this.jq(ID_CONTENTS).html(_this.getLoadingMessage("No entries selected"));
                        return;
                    }
                    _this.drag = null;
                    _this.jq(ID_CONTENTS).html(_this.makeFramework());

                    _this.canvas = $("#" + _this.getDomId(ID_CANVAS));
                    _this.gridPopup = $("#" + _this.getDomId(ID_GRID) + " .display-grid-popup");
                    let debugMouse = false;
                    let xAxis = _this.jq(ID_AXIS_BOTTOM);
                    let yAxis = _this.jq(ID_AXIS_LEFT);
                    let mousedown = function(evt) {
                        if (debugMouse)
                            console.log("mouse down");
                        _this.handledClick = false;
                        _this.drag = {
                            dragging: false,
                            x: GuiUtils.getEventX(evt),
                            y: GuiUtils.getEventY(evt),
                            X: {
                                minDate: _this.axis.X.minDate ? _this.axis.X.minDate : _this.minDate,
                                maxDate: _this.axis.X.maxDate ? _this.axis.X.maxDate : _this.maxDate,
                            },
                            Y: {
                                minDate: _this.axis.Y.minDate ? _this.axis.Y.minDate : _this.minDate,
                                maxDate: _this.axis.Y.maxDate ? _this.axis.Y.maxDate : _this.maxDate,
                            }
                        }
                    }
                    let mouseleave = function(evt) {
                        if (debugMouse)
                            console.log("mouse leave");
                        _this.drag = null;
                        _this.handledClick = false;
                    }
                    let mouseup = function(evt) {
                        if (debugMouse)
                            console.log("mouse up");
                        if (_this.drag) {
                            if (_this.drag.dragging) {
                                if (debugMouse)
                                    console.log("mouse up-was dragging");
                                _this.handledClick = true;
                            }
                            _this.drag = null;
                        }
                    }
                    let mousemove = function(evt, doX, doY) {
                        if (debugMouse)
                            console.log("mouse move");
                        let drag = _this.drag;
                        if (!drag) return;
                        drag.dragging = true;
                        let x = GuiUtils.getEventX(evt);
                        let deltaX = drag.x - x;
                        let y = GuiUtils.getEventY(evt);
                        let deltaY = drag.y - y;
                        let width = $(this).width();
                        let height = $(this).height();
                        let percentX = (x - drag.x) / width;
                        let percentY = (y - drag.y) / height;
                        let ascX = _this.getXAxisAscending();
                        let ascY = _this.getXAxisAscending();
                        let diffX = (drag.X.maxDate.getTime() - drag.X.minDate.getTime()) * percentX;
                        let diffY = (drag.Y.maxDate.getTime() - drag.Y.minDate.getTime()) * percentY;

                        if (doX) {
                            _this.axis.X.minDate = new Date(drag.X.minDate.getTime() + ((ascX ? -1 : 1) * diffX));
                            _this.axis.X.maxDate = new Date(drag.X.maxDate.getTime() + ((ascX ? -1 : 1) * diffX));
                        }
                        if (doY) {
                            _this.axis.Y.minDate = new Date(drag.Y.minDate.getTime() + ((ascY ? 1 : -1) * diffY));
                            _this.axis.Y.maxDate = new Date(drag.Y.maxDate.getTime() + ((ascY ? 1 : -1) * diffY));
                        }
                        _this.makeGrid(_this.entries);
                    }
                    let mouseclick = function(evt, doX, doY) {
                        if (_this.handledClick) {
                            if (debugMouse)
                                console.log("mouse click-other click");
                            _this.handledClick = false;
                            return;
                        }
                        if (_this.drag && _this.drag.dragging) {
                            if (debugMouse)
                                console.log("mouse click-was dragging");
                            _this.drag = null;
                            return;
                        }
                        if (debugMouse)
                            console.log("mouse click");
                        _this.drag = null;
                        let action;
                        if (evt.metaKey || evt.ctrlKey) {
                            action = "reset";
                        } else {
                            let zoomOut = evt.shiftKey;
                            if (zoomOut)
                                action = "zoomout";
                            else
                                action = "zoomin";
                        }
                        _this.doZoom(action, doX, doY);
                    };

                    let mousemoveCanvas = function(evt) {
                        mousemove(evt, true, true);
                    }
                    let mousemoveX = function(evt) {
                        mousemove(evt, true, false);
                    }
                    let mousemoveY = function(evt) {
                        mousemove(evt, false, true);
                    }

                    let mouseclickCanvas = function(evt) {
                        mouseclick(evt, true, true);
                    }
                    let mouseclickX = function(evt) {
                        mouseclick(evt, true, false);
                    }
                    let mouseclickY = function(evt) {
                        mouseclick(evt, false, true);
                    }


                    _this.canvas.mousedown(mousedown);
                    _this.canvas.mouseleave(mouseleave);
                    _this.canvas.mouseup(mouseup);
                    _this.canvas.mousemove(mousemoveCanvas);
                    _this.canvas.click(mouseclickCanvas);

                    xAxis.mousedown(mousedown);
                    xAxis.mouseleave(mouseleave);
                    xAxis.mouseup(mouseup);
                    xAxis.mousemove(mousemoveX);
                    xAxis.click(mouseclickX);

                    yAxis.mousedown(mousedown);
                    yAxis.mouseleave(mouseleave);
                    yAxis.mouseup(mouseup);
                    yAxis.mousemove(mousemoveY);
                    yAxis.click(mouseclickY);

                    let links =
                        HU.image(icon_zoom, [ATTR_CLASS, "display-grid-action", ATTR_TITLE, "reset zoom", "action", "reset"]) +
                        HU.image(icon_zoom_in, [ATTR_CLASS, "display-grid-action", ATTR_TITLE, "zoom in", "action", "zoomin"]) +
                        HU.image(icon_zoom_out, [ATTR_CLASS, "display-grid-action", ATTR_TITLE, "zoom out", "action", "zoomout"]);
                    _this.jq(ID_LINKS).html(links);
                    $("#" + _this.getDomId(ID_GRID) + " .display-grid-action").click(function() {
                        let action = $(this).attr("action");
                        _this.doZoom(action);
                    });


                    _this.jq(ID_AXIS_LEFT).html("");
                    _this.jq(ID_AXIS_BOTTOM).html("");
                    _this.makeGrid(_this.entries);
                }
            };
            let entryList = new EntryList(this.getRamadda(), jsonUrl, myCallback, true);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let cbx = this.jq(ID_SETTINGS + " :checkbox");
            cbx.click(function() {
                _this.setProperty($(this).attr("attr"), $(this).is(':checked'));
                _this.makeGrid(_this.entries);
            });
            let input = this.jq(ID_SETTINGS + " :input");
            input.blur(function() {
                _this.setProperty($(this).attr("attr"), $(this).val());
                _this.makeGrid(_this.entries);
            });
            input.keypress(function(event) {
                let keycode = (event.keyCode ? event.keyCode : event.which);
                if (keycode == 13) {
                    _this.setProperty($(this).attr("attr"), $(this).val());
                    _this.makeGrid(_this.entries);
                }
            });

        },
        getDialogContents: function(tabTitles, tabContents) {
            let height = "600";
            let html = "";
            html += HU.openTag(TAG_DIV, [ATTR_ID, this.getDomId(ID_SETTINGS)]);

            html += HU.formTable();
            html += HU.formEntry("",
				 HU.checkbox(this.getDomId(ID_SHOW_ICON),
					     ["attr", ID_SHOW_ICON],
					     this.getProperty(ID_SHOW_ICON, "true")) + " Show Icon" +
				 "&nbsp;&nbsp;" +
				 HU.checkbox(this.getDomId(ID_SHOW_NAME),
					     ["attr", ID_SHOW_NAME],
					     this.getProperty(ID_SHOW_NAME, "true")) + " Show Name");
            html += HU.formEntry("X-Axis:",
				 HU.checkbox(this.getDomId(ID_XAXIS_ASCENDING),
					     ["attr", ID_XAXIS_ASCENDING],
					     this.getXAxisAscending()) + " Ascending" +
				 "&nbsp;&nbsp;" +
				 HU.checkbox(this.getDomId(ID_XAXIS_SCALE),
					     ["attr", ID_XAXIS_SCALE],
					     this.getXAxisScale()) + " Scale Width");
            html += HU.formEntry("Y-Axis:",
				 HU.checkbox(this.getDomId(ID_YAXIS_ASCENDING),
					     ["attr", ID_YAXIS_ASCENDING],
					     this.getYAxisAscending()) + " Ascending" +
				 "&nbsp;&nbsp;" +
				 HU.checkbox(this.getDomId(ID_YAXIS_SCALE),
					     ["attr", ID_YAXIS_SCALE],
					     this.getYAxisScale()) + " Scale Height");

            html += HU.formEntry("Box Color:",
				 HU.input(this.getDomId(ID_COLOR),
					  this.getProperty(ID_COLOR, "lightblue"),
					  ["attr", ID_COLOR]));

            html += HU.formTableClose();
            html += HU.closeTag(TAG_DIV);
            tabTitles.push("Entry Grid");
            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },

        doZoom: function(action, doX, doY) {
            if (!Utils.isDefined(doX)) doX = true;
            if (!Utils.isDefined(doY)) doY = true;
            if (action == "reset") {
                this.axis.Y.minDate = null;
                this.axis.Y.maxDate = null;
                this.axis.X.minDate = null;
                this.axis.X.maxDate = null;
            } else {
                let zoomOut = (action == "zoomout");
                if (doX) {
                    let d1 = this.axis.X.minDate.getTime();
                    let d2 = this.axis.X.maxDate.getTime();
                    let dateRange = d2 - d1;
                    let diff = (zoomOut ? 1 : -1) * dateRange * 0.1;
                    this.axis.X.minDate = new Date(d1 - diff);
                    this.axis.X.maxDate = new Date(d2 + diff);
                }
                if (doY) {
                    let d1 = this.axis.Y.minDate.getTime();
                    let d2 = this.axis.Y.maxDate.getTime();
                    let dateRange = d2 - d1;
                    let diff = (zoomOut ? 1 : -1) * dateRange * 0.1;
                    this.axis.Y.minDate = new Date(d1 - diff);
                    this.axis.Y.maxDate = new Date(d2 + diff);
                }
            }
            this.makeGrid(this.entries);
        },
        initGrid: function(entries) {
            let _this = this;
            let items = this.canvas.find(".display-grid-entry");
            items.click(function(evt) {
                let index = parseInt($(this).attr("index"));
                entry = entries[index];
                let url = entry.getEntryUrl();
                if (_this.urlTemplate) {
                    url = _this.urlTemplate.replace("{url}", url).replace(/{entryid}/g, entry.getId()).replace(/{resource}/g, entry.getResourceUrl());
                }

                _this.handledClick = true;
                _this.drag = null;
                window.open(url, "_entry");
                //                        evt.stopPropagation();
            });
            items.mouseout(function() {
                let id = $(this).attr("entryid");
                if (id) {
                    let other = _this.canvas.find("[entryid='" + id + "']");
                    other.each(function() {
                        if ($(this).attr("itemtype") == "box") {
                            $(this).attr("prevcolor", $(this).css("background"));
                            $(this).css("background", $(this).attr("prevcolor"));
                        }
                    });
                }

                _this.gridPopup.hide();
            });
            items.mouseover(function(evt) {
                let id = $(this).attr("entryid");
                if (id) {
                    let other = _this.canvas.find("[entryid='" + id + "']");
                    other.each(function() {
                        if ($(this).attr("itemtype") == "box") {
                            $(this).attr("prevcolor", $(this).css("background"));
                            $(this).css("background", "rgba(0,0,255,0.5)");
                        }
                    });
                }
                let x = GuiUtils.getEventX(evt);
                let index = parseInt($(this).attr("index"));
                entry = entries[index];
                let thumb = entry.getThumbnail();
                let html = "";
                if (thumb) {
                    html = HU.image(thumb, ["width", "300;"]) + "<br>";
                } else if (entry.isImage()) {
                    html += HU.image(entry.getResourceUrl(), ["width", "300"]) + "<br>";
                }
                html += entry.getIconImage() + " " + entry.getName() + "<br>";
                let start = entry.getStartDate().getUTCFullYear() + "-" + Utils.padLeft(entry.getStartDate().getUTCMonth() + 1, 2, "0") + "-" + Utils.padLeft(entry.getStartDate().getUTCDate(), 2, "0");
                let end = entry.getEndDate().getUTCFullYear() + "-" + Utils.padLeft(entry.getEndDate().getUTCMonth() + 1, 2, "0") + "-" + Utils.padLeft(entry.getEndDate().getUTCDate(), 2, "0");
                html += "Date: " + start + " - " + end + " UTC";
                _this.gridPopup.html(html);
                _this.gridPopup.show();
                _this.gridPopup.position({
                    of: $(this),
                    at: "left bottom",
                    my: "left top",
                    collision: "none none"
                });
                _this.gridPopup.position({
                    of: $(this),
                    my: "left top",
                    at: "left bottom",
                    collision: "none none"
                });
            });
        },
        makeFramework: function(entries) {
            let html = "";
            let mouseInfo = "click:zoom in;shift-click:zoom out;command/ctrl click: reset";
            html += HU.openDiv([ATTR_CLASS, "display-grid", ATTR_ID, this.getDomId(ID_GRID)]);
            html += HU.div([ATTR_CLASS, "display-grid-popup ramadda-popup"], "");
            html += HU.openTag(TAG_TABLE, ["border", "0", ATTR_CLASS, "", "cellspacing", "0", "cellspacing", "0", "width", "100%", ATTR_STYLE, "height:100%;"]);
            html += HU.openTag(TAG_TR, ["valign", "bottom"]);
            html += HU.tag(TAG_TD);
            html += HU.tag(TAG_TD, [], HU.div([ATTR_ID, this.getDomId(ID_LINKS)], ""));
            html += HU.closeTag(TAG_TR);
            html += HU.openTag(TAG_TR, [ATTR_STYLE, "height:100%;"]);
            html += HU.openTag(TAG_TD, [ATTR_STYLE, "height:100%;"]);
            html += HU.openDiv([ATTR_CLASS, "display-grid-axis-left ramadda-noselect", ATTR_ID, this.getDomId(ID_AXIS_LEFT)]);
            html += HU.closeDiv();
            html += HU.closeDiv();
            html += HU.closeTag(TAG_TD);
            html += HU.openTag(TAG_TD, [ATTR_STYLE, "height:" + this.getProperty("height", "400") + "px"]);
            html += HU.openDiv([ATTR_CLASS, "display-grid-canvas ramadda-noselect", ATTR_ID, this.getDomId(ID_CANVAS)]);
            html += HU.closeDiv();
            html += HU.closeDiv();
            html += HU.closeTag(TAG_TD);
            html += HU.closeTag(TAG_TR);
            html += HU.openTag(TAG_TR, []);
            html += HU.tag(TAG_TD, ["width", "100"], "&nbsp;");
            html += HU.openTag(TAG_TD, []);
            html += HU.div([ATTR_CLASS, "display-grid-axis-bottom ramadda-noselect", ATTR_TITLE, mouseInfo, ATTR_ID, this.getDomId(ID_AXIS_BOTTOM)], "");
            html += HU.closeTag(TAG_TABLE);
            html += HU.closeTag(TAG_TD);
            return html;
        },


        getXAxisType: function() {
            return this.getProperty(ID_XAXIS_TYPE, "date");
        },
        getYAxisType: function() {
            return this.getProperty(ID_YAXIS_TYPE, "month");
        },
        getXAxisAscending: function() {
            return this.getProperty(ID_XAXIS_ASCENDING, true);
        },
        getYAxisAscending: function() {
            return this.getProperty(ID_YAXIS_ASCENDING, true);
        },
        getXAxisScale: function() {
            return this.getProperty(ID_XAXIS_SCALE, true);
        },
        getYAxisScale: function() {
            return this.getProperty(ID_YAXIS_SCALE, false);
        },


        makeGrid: function(entries) {
            let showIcon = this.getProperty(ID_SHOW_ICON, true);
            let showName = this.getProperty(ID_SHOW_NAME, true);

            if (!this.minDate) {
                let minDate = null;
                let maxDate = null;
                for (let i = 0; i < entries.length; i++) {
                    let entry = entries[i];
                    minDate = minDate == null ? entry.getStartDate() : (minDate.getTime() > entry.getStartDate().getTime() ? entry.getStartDate() : minDate);
                    maxDate = maxDate == null ? entry.getEndDate() : (maxDate.getTime() < entry.getEndDate().getTime() ? entry.getEndDate() : maxDate);
                }
                this.minDate = new Date(Date.UTC(minDate.getUTCFullYear(), 0, 1));
                this.maxDate = new Date(Date.UTC(maxDate.getUTCFullYear() + 1, 0, 1));
            }

            let axis = {
                width: this.canvas.width(),
                height: this.canvas.height(),
                Y: {
                    vertical: true,
                    axisType: this.getYAxisType(),
                    ascending: this.getYAxisAscending(),
                    scale: this.getYAxisScale(),
                    skip: 1,
                    maxTicks: Math.ceil(this.canvas.height() / 80),
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                    ticks: [],
                    lines: "",
                    html: "",
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                },
                X: {
                    vertical: false,
                    axisType: this.getXAxisType(),
                    ascending: this.getXAxisAscending(),
                    scale: this.getXAxisScale(),
                    skip: 1,
                    maxTicks: Math.ceil(this.canvas.width() / 80),
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                    ticks: [],
                    lines: "",
                    html: ""
                }
            }
            if (!this.axis) {
                this.axis = axis;
            } else {
                if (this.axis.X.minDate) {
                    axis.X.minDate = this.axis.X.minDate;
                    axis.X.maxDate = this.axis.X.maxDate;
                } else {
                    this.axis.X.minDate = axis.X.minDate;
                    this.axis.X.maxDate = axis.X.maxDate;
                }
                if (this.axis.Y.minDate) {
                    axis.Y.minDate = this.axis.Y.minDate;
                    axis.Y.maxDate = this.axis.Y.maxDate;
                } else {
                    this.axis.Y.minDate = axis.Y.minDate;
                    this.axis.Y.maxDate = axis.Y.maxDate;
                }
            }

            if (axis.Y.axisType == "size") {
                this.calculateSizeAxis(axis.Y);
            } else if (axis.Y.axisType == "date") {
                this.calculateDateAxis(axis.Y);
            } else {
                this.calculateMonthAxis(axis.Y);
            }
            for (let i = 0; i < axis.Y.ticks.length; i++) {
                let tick = axis.Y.ticks[i];
		//                let style = (axis.Y.ascending ? "bottom:" : "top:") + tick.percent + "%;";
                let style = "bottom:" + tick.percent + "%;";
                let lineClass = tick.major ? "display-grid-hline-major" : "display-grid-hline";
                axis.Y.lines += HU.div([ATTR_STYLE, style, ATTR_CLASS, lineClass], " ");
                axis.Y.html += HU.div([ATTR_STYLE, style, ATTR_CLASS, "display-grid-axis-left-tick"], tick.label + " " + HU.div([ATTR_CLASS, "display-grid-htick"], ""));
            }

            if (axis.X.axisType == "size") {
                this.calculateSizeAxis(axis.X);
            } else if (axis.X.axisType == "date") {
                this.calculateDateAxis(axis.X);
            } else {
                this.calculateMonthAxis(axis.X);
            }
            for (let i = 0; i < axis.X.ticks.length; i++) {
                let tick = axis.X.ticks[i];
                if (tick.percent > 0) {
                    let lineClass = tick.major ? "display-grid-vline-major" : "display-grid-vline";
                    axis.X.lines += HU.div([ATTR_STYLE, "left:" + tick.percent + "%;", ATTR_CLASS, lineClass], " ");
                }
                axis.X.html += HU.div([ATTR_STYLE, "left:" + tick.percent + "%;", ATTR_CLASS, "display-grid-axis-bottom-tick"], HU.div([ATTR_CLASS, "display-grid-vtick"], "") + " " + tick.label);
            }

            let items = "";
            let seen = {};
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let vInfo = this[axis.Y.calculatePercent].call(this, entry, axis.Y);
                let xInfo = this[axis.X.calculatePercent].call(this, entry, axis.X);
                if (vInfo.p1 < 0) {
                    vInfo.p2 = vInfo.p2 + vInfo.p1;
                    vInfo.p1 = 0;
                }
                if (vInfo.p1 + vInfo.p2 > 100) {
                    vInfo.p2 = 100 - vInfo.p1;
                }

                let style = "";
                let pos = "";

                if (axis.X.ascending) {
                    style += "left:" + xInfo.p1 + "%;";
                    pos += "left:" + xInfo.p1 + "%;";
                } else {
                    style += "right:" + xInfo.p1 + "%;";
                    pos += "left:" + (100 - xInfo.p2) + "%;";
                }

                if (axis.X.scale) {
                    if (xInfo.delta > 1) {
                        style += "width:" + xInfo.delta + "%;";
                    } else {
                        style += "width:" + this.getProperty("fixedWidth", "5") + "px;";
                    }
                }


                let namePos = pos;
                if (axis.Y.ascending) {
                    style += " bottom:" + vInfo.p2 + "%;";
                    pos += " bottom:" + vInfo.p2 + "%;";
                    namePos += " bottom:" + vInfo.p2 + "%;";
                } else {
                    style += " top:" + vInfo.p2 + "%;";
                    pos += " top:" + vInfo.p2 + "%;";
                    namePos += " top:" + vInfo.p2 + "%;";
                    namePos += "margin-top:-15px;"
                }
                if (axis.Y.scale) {
                    if (vInfo.p2 > 1) {
                        style += "height:" + vInfo.delta + "%;";
                    } else {
                        style += "height:" + this.getProperty("fixedHeight", "5") + "px;";
                    }
                }

                if (entry.getName().includes("rilsd")) {
                    console.log("pos:" + namePos);
                }
                if (showIcon) {
                    items += HU.div([ATTR_CLASS, "display-grid-entry-icon display-grid-entry", "entryid", entry.getId(), "index", i, ATTR_STYLE, pos], entry.getIconImage());
                }
                let key = Math.round(xInfo.p1) + "---" + Math.round(vInfo.p1);
                if (showName && !seen[key]) {
                    seen[key] = true;
                    let name = entry.getName().replace(/ /g, "&nbsp;");
                    items += HU.div([ATTR_CLASS, "display-grid-entry-text display-grid-entry", "entryid", entry.getId(), "index", i, ATTR_STYLE, namePos], name);
                }
                let boxStyle = style + "background:" + this.getProperty(ID_COLOR, "lightblue");
                items += HU.div([ATTR_CLASS, "display-grid-entry-box display-grid-entry", "itemtype", "box", "entryid", entry.getId(), ATTR_STYLE, boxStyle, "index", i], "");
            }
            this.jq(ID_AXIS_LEFT).html(axis.Y.html);
            this.jq(ID_CANVAS).html(axis.Y.lines + axis.X.lines + items);
            this.jq(ID_AXIS_BOTTOM).html(axis.X.html);
            this.initGrid(entries);
        },
        calculateSizeAxis: function(axisInfo) {
            let min = Number.MAX_VALUE;
            let max = Number.MIN_VALUE;
            for (let i = 0; i < this.entries.length; i++) {
                let entry = this.entries[i];
                min = Math.min(min, entry.getSize());
                max = Math.max(max, entry.getSize());
            }
        },
        checkOrder: function(axisInfo, percents) {
            /*
              if(!axisInfo.ascending) {
              percents.p1 = 100-percents.p1;
              percents.p2 = 100-percents.p2;
              let tmp  =percents.p1;
              percents.p1=percents.p2;
              percents.p2=tmp;
              }
            */
            return {
                p1: percents.p1,
                p2: percents.p2,
                delta: Math.abs(percents.p2 - percents.p1)
            };
        },
        calculateDatePercent: function(entry, axisInfo) {
            let p1 = 100 * (entry.getStartDate().getTime() - axisInfo.min) / axisInfo.range;
            let p2 = 100 * (entry.getEndDate().getTime() - axisInfo.min) / axisInfo.range;
            return this.checkOrder(axisInfo, {
                p1: p1,
                p2: p2,
                delta: Math.abs(p2 - p1)
            });
        },
        calculateMonthPercent: function(entry, axisInfo) {
            let d1 = entry.getStartDate();
            let d2 = entry.getEndDate();
            let t1 = new Date(Date.UTC(1, d1.getUTCMonth(), d1.getUTCDate()));
            let t2 = new Date(Date.UTC(1, d2.getUTCMonth(), d2.getUTCDate()));
            let p1 = 100 * ((t1.getTime() - axisInfo.min) / axisInfo.range);
            let p2 = 100 * ((t2.getTime() - axisInfo.min) / axisInfo.range);
            if (entry.getName().includes("rilsd")) {
                console.log("t1:" + t1);
                console.log("t2:" + t2);
                console.log("before:" + p1 + " " + p2);
            }
            return this.checkOrder(axisInfo, {
                p1: p1,
                p2: p2,
                delta: Math.abs(p2 - p1)
            });
        },
        calculateMonthAxis: function(axisInfo) {
            axisInfo.calculatePercent = "calculateMonthPercent";
            axisInfo.minDate = new Date(Date.UTC(0, 11, 15));
            axisInfo.maxDate = new Date(Date.UTC(1, 11, 31));
            axisInfo.min = axisInfo.minDate.getTime();
            axisInfo.max = axisInfo.maxDate.getTime();
            axisInfo.range = axisInfo.max - axisInfo.min;
            let months = Utils.getMonthShortNames();
            for (let month = 0; month < months.length; month++) {
                let t1 = new Date(Date.UTC(1, month));
                let percent = (axisInfo.maxDate.getTime() - t1.getTime()) / axisInfo.range;
                if (axisInfo.ascending)
                    percent = 1 - percent;
                axisInfo.ticks.push({
                    percent: 100 * percent,
                    label: months[month],
                    major: false
                });
            }
        },
        calculateDateAxis: function(axisInfo) {
            axisInfo.calculatePercent = "calculateDatePercent";
            let numYears = axisInfo.maxDate.getUTCFullYear() - axisInfo.minDate.getUTCFullYear();
            let years = numYears;
            axisInfo.type = "year";
            axisInfo.skip = Math.max(1, Math.floor(numYears / axisInfo.maxTicks));
            if ((numYears / axisInfo.skip) <= (axisInfo.maxTicks / 2)) {
                let numMonths = 0;
                let tmp = new Date(axisInfo.minDate.getTime());
                while (tmp.getTime() < axisInfo.maxDate.getTime()) {
                    Utils.incrementMonth(tmp);
                    numMonths++;
                }
                axisInfo.skip = Math.max(1, Math.floor(numMonths / axisInfo.maxTicks));
                axisInfo.type = "month";
                if ((numMonths / axisInfo.skip) <= (axisInfo.maxTicks / 2)) {
                    let tmp = new Date(axisInfo.minDate.getTime());
                    let numDays = 0;
                    while (tmp.getTime() < axisInfo.maxDate.getTime()) {
                        Utils.incrementDay(tmp);
                        numDays++;
                    }
                    axisInfo.skip = Math.max(1, Math.floor(numDays / axisInfo.maxTicks));
                    axisInfo.type = "day";
                }
            }


            axisInfo.min = axisInfo.minDate.getTime();
            axisInfo.max = axisInfo.maxDate.getTime();
            axisInfo.range = axisInfo.max - axisInfo.min;
            let months = Utils.getMonthShortNames();
            let lastYear = null;
            let lastMonth = null;
            let tickDate;
            if (axisInfo.type == "year") {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear()));
            } else if (axisInfo.type == "month") {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear(), axisInfo.minDate.getUTCMonth()));
            } else {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear(), axisInfo.minDate.getUTCMonth(), axisInfo.minDate.getUTCDate()));
            }
            //                if(axisInfo.vertical)
            //                    console.log(axisInfo.type+" skip:" + axisInfo.skip + "   min:" + Utils.formatDateYYYYMMDD(axisInfo.minDate)+"   max:" + Utils.formatDateYYYYMMDD(axisInfo.maxDate));
            while (tickDate.getTime() < axisInfo.maxDate.getTime()) {
                let percent = (tickDate.getTime() - axisInfo.minDate.getTime()) / axisInfo.range;
                if (!axisInfo.ascending)
                    percent = (1 - percent);
                percent = 100 * percent;
                //                    console.log("    perc:"+ percent +" " + Utils.formatDateYYYYMMDD(tickDate));
                if (percent >= 0 && percent < 100) {
                    let label = "";
                    let year = tickDate.getUTCFullYear();
                    let month = tickDate.getUTCMonth();
                    let major = false;
                    if (axisInfo.type == "year") {
                        label = year;
                    } else if (axisInfo.type == "month") {
                        label = months[tickDate.getUTCMonth()];
                        if (lastYear != year) {
                            label = label + "<br>" + year;
                            lastYear = year;
                            major = true;
                        }
                    } else {
                        label = tickDate.getUTCDate();
                        if (lastYear != year || lastMonth != month) {
                            label = label + "<br>" + months[month] + " " + year;
                            lastYear = year;
                            lastMonth = month;
                            major = true;
                        }
                    }
                    axisInfo.ticks.push({
                        percent: percent,
                        label: label,
                        major: major
                    });
                }
                if (axisInfo.type == "year") {
                    Utils.incrementYear(tickDate, axisInfo.skip);
                } else if (axisInfo.type == "month") {
                    Utils.incrementMonth(tickDate, axisInfo.skip);
                } else {
                    Utils.incrementDay(tickDate, axisInfo.skip);
                }
            }

        }
    });
}


function RamaddaMetadataDisplay(displayManager, id, properties) {
    if (properties.formOpen == null) {
        properties.formOpen = false;
    }
    let SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_METADATA, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        haveDisplayed: false,
        initDisplay: function() {
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
            SUPER.initDisplay.apply(this);
            if (this.haveDisplayed && this.entryList) {
                this.entryListChanged(this.entryList);
            }
            this.haveDisplayed = true;
        },
        entryListChanged: function(entryList) {
            this.entryList = entryList;
            let entries = this.entryList.getEntries();
            if (entries.length == 0) {
                this.writeMessage("Nothing found");
                return;
            }
	    let html = this.getEntriesMetadata(entries);
            this.writeEntries(html, entries);
            HU.formatTable("#" + this.getDomId(TAG_TABLE), {
                scrollY: 400
            });
        },
    });

}



function RamaddaEntrydisplayDisplay(displayManager, id, properties) {
    let SUPER;
    $.extend(this, {
        sourceEntry: properties.sourceEntry
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ENTRYDISPLAY, properties));
    if (properties.sourceEntry == null && properties.entryId != null) {
        let _this = this;
        let f = async function() {
            await _this.getEntry(properties.entryId, entry => {
                _this.sourceEntry = entry;
                _this.initDisplay()
            });

        }
        f();
    }


    addRamaddaDisplay(this);
    $.extend(this, {
        selectedEntry: null,
        initDisplay: function() {
            this.createUI();
            let title = this.title;
            if (this.sourceEntry != null) {
                this.addEntryHtml(this.sourceEntry);
                let url = this.sourceEntry.getEntryUrl();

                if (title == null) {
                    title = this.sourceEntry.getName();
                }
                title = HU.tag("a", ["href", url, ATTR_TITLE, this.sourceEntry.getName(), "alt", this.sourceEntry.getName()], title);
            } else {
                this.addEntryHtml(this.selectedEntry);
                if (title == null) {
                    title = "Entry Display";
                }
            }
            this.setDisplayTitle(title);
        },
        handleEventEntrySelection: function(source, args) {
            //Ignore select events
            if (this.sourceEntry != null) return;
            let selected = args.selected;
            let entry = args.entry;
            if (!selected) {
                if (this.selectedEntry != entry) {
                    //not mine
                    return;
                }
                this.selectedEntry = null;
                this.setContents("");
                return;
            }
            this.selectedEntry = entry;
            this.addEntryHtml(this.selectedEntry);
        },
        getEntries: function() {
            return [this.sourceEntry];
        },
        addEntryHtml: function(entry) {
            if (entry == null) {
                this.setContents("&nbsp;");
                return;
            }
            let html = this.getEntryHtml(entry, {
                showHeader: false
            });
            let height = this.getProperty("height", "400px");
            if (!height.endsWith("px")) height += "px";
            this.setContents(HU.div([ATTR_CLASS, "display-entry-description", ATTR_STYLE, "height:" + height + ";"],
				    html));
            this.entryHtmlHasBeenDisplayed(entry);
        },
    });
}



function RamaddaEntrytitleDisplay(displayManager, id, properties) {
    let SUPER;
    $.extend(this, {
        sourceEntry: properties.sourceEntry
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ENTRYDISPLAY, properties));
    if (properties.sourceEntry == null && properties.entryId != null) {
        let _this = this;
        let f = async function() {
            await _this.getEntry(properties.entryId, entry => {
                _this.sourceEntry = entry;
                _this.initDisplay()
            });
        }
        f();
    }

    let myProps = [
	{label:'Entry Title'},
	{p:'template',ex:'<b>${icon} ${name} Date: ${date} ${start_date} ${end_date} ${entry_attribute...}</b>'},
	{p:'showLink',ex:'false'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	initDisplay: function() {
            this.createUI();
	    let html = "";
	    if(this.sourceEntry) {
		let e = this.sourceEntry;
		html = this.getProperty("template","<b>${icon} ${name} Date: ${date}</b>");
		html = html.replace("${name}",e.getDisplayName());
		html = html.replace("${icon}",e.getIconImage());
		html = html.replace("${date}",this.formatDate(e.getStartDate()));
		html = html.replace("${start_date}",this.formatDate(e.getStartDate()));
		html = html.replace("${end_date}",this.formatDate(e.getEndDate()));
		e.getAttributeNames().map(n=>{
		    html = html.replace("${" + n+"}",e.getAttributeValue(n));
		});
		if(this.getProperty("showLink",true)) {
		    html = HU.href(e.getEntryUrl(),html);
		}
	    }
	    this.displayHtml(html);
        },
	setEntry: function(entry) {
	    this.sourceEntry = entry;
	    this.initDisplay();
	},
        handleEventEntrySelection: function(source, args) {
        },
    });
}


function RamaddaEntrywikiDisplay(displayManager, id, properties) {
    const ID_WIKI = "wiki";
    let SUPER;
    if(!properties.displayStyle)
	properties.displayStyle="width:100%;"
    $.extend(this, {
        sourceEntry: properties.sourceEntry
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ENTRYDISPLAY, properties));

    if (properties.sourceEntry == null && properties.entryId != null) {
        let _this = this;
        let f = async function() {
            await _this.getEntry(properties.entryId, entry => {
                _this.sourceEntry = entry;
                _this.initDisplay()
            });
        }
        f();
    }

    let myProps = [
	{label:'Entry Wiki'},
	{p:'wiki',d:'{{import macro=forchild}}',ex:'wiki text'},
	{p:'wikiStyle',d:'width:100%;max-width:95vw'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	initDisplay: function() {
            this.createUI();
	    let html = HU.div([ATTR_ID,this.domId(ID_WIKI),ATTR_STYLE,this.getWikiStyle()]);
	    this.displayHtml(html);
	    if(this.sourceEntry) {
		let e = this.sourceEntry;
		let wiki = this.getWiki();
		wiki = wiki.replace(/\\n/g,"\n");
		//Delete the old displays
		if(this.addedDisplays) {
		    this.addedDisplays.forEach(display=>{
			if(display.getId)
			    removeRamaddaDisplay(display.getId());
		    });
		}
		this.addedDisplays = [];
		this.wikify(wiki,e.getId(),html=>{
		    addDisplayListener = display=>{
			this.addedDisplays.push(display);
			//			console.log("add display:" + display.type);
		    };
		    this.jq(ID_WIKI).html(html);
		    addDisplayListener = null;
		});
	    }
        },
	setEntry: function(entry) {
	    this.sourceEntry = entry;
	    this.initDisplay();
	},
        handleEventEntrySelection: function(source, args) {
        },
    });
}





function RamaddaOperandsDisplay(displayManager, id, properties) {
    const ID_SELECT = TAG_SELECT;
    const ID_SELECT1 = "select1";
    const ID_SELECT2 = "select2";
    const ID_NEWDISPLAY = "newdisplay";

    $.extend(this, new RamaddaEntryDisplay(displayManager, id, DISPLAY_OPERANDS, properties));
    addRamaddaDisplay(this);
    $.extend(this, {
        baseUrl: null,
        initDisplay: function() {
            this.createUI();
            this.baseUrl = this.getRamadda().getSearchUrl(this.searchSettings, OUTPUT_JSON);
            if (this.entryList == null) {
                this.entryList = new EntryList(this.getRamadda(), jsonUrl, this);
            }
            let html = "";
            html += HU.div([ATTR_ID, this.domId(ID_ENTRIES), ATTR_CLASS, this.getClass("entries")], "");
            this.setContents(html);
        },
        entryListChanged: function(entryList) {
            let html = "<form>";
            html += "<p>";
            html += HU.openTag(TAG_TABLE, [ATTR_CLASS, "formtable", "cellspacing", "0", "cellspacing", "0"]);
            let entries = this.entryList.getEntries();
            let get = this.getGet();

            for (let j = 1; j <= 2; j++) {
                let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_SELECT + j)]);
                select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""],
				 "-- Select --");
                for (let i = 0; i < entries.length; i++) {
                    let entry = entries[i];
                    let label = entry.getIconImage() + " " + entry.getName();
                    select += HU.tag(TAG_OPTION, [ATTR_TITLE, entry.getName(), ATTR_VALUE, entry.getId()],
				     entry.getName());

                }
                select += HU.closeTag(TAG_SELECT);
                html += HU.formEntry("Data:", select);
            }

            let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_CHARTTYPE)]);
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "linechart"],
			     "Line chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "barchart"],
			     "Bar chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "barstack"],
			     "Stacked bars");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "bartable"],
			     "Bar table");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "piechart"],
			     "Pie chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "scatterplot"],
			     "Scatter Plot");
            select += HU.closeTag(TAG_SELECT);
            html += HU.formEntry("Chart Type:", select);

            html += HU.closeTag(TAG_TABLE);
            html += "<p>";
            html += HU.tag(TAG_DIV, [ATTR_CLASS, "display-button", ATTR_ID, this.getDomId(ID_NEWDISPLAY)], "New Chart");
            html += "<p>";
            html += "</form>";
            this.writeEntries(html);
            let theDisplay = this;
            this.jq(ID_NEWDISPLAY).button().click(function(event) {
                theDisplay.createDisplay();
            });
        },
        createDisplay: function() {
            let entry1 = this.getEntry(this.jq(ID_SELECT1).val());
            let entry2 = this.getEntry(this.jq(ID_SELECT2).val());
            if (entry1 == null) {
                alert("No data selected");
                return;
            }
            let pointDataList = [];

            pointDataList.push(new PointData(entry1.getName(), null, null, ramaddaBaseUrl + "/entry/show?&output=points.product&product=points.json&numpoints=1000&entryid=" + entry1.getId()));
            if (entry2 != null) { 
		pointDataList.push(new PointData(entry2.getName(), null, null, ramaddaBaseUrl + "/entry/show?&output=points.product&product=points.json&numpoints=1000&entryid=" + entry2.getId()));
            }

            //Make up some functions
            let operation = "average";
            let derivedData = new DerivedPointData(this.displayManager, "Derived Data", pointDataList, operation);
            let pointData = derivedData;
            let chartType = this.jq(ID_CHARTTYPE).val();
            displayManager.createDisplay(chartType, {
                "layoutFixed": false,
                "data": pointData
            });
        }

    });
}


function RamaddaRepositoriesDisplay(displayManager, id, properties) {
    RamaddaUtil.inherit(this, new RamaddaEntryDisplay(displayManager, id, DISPLAY_REPOSITORIES, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        initDisplay: function() {
            let theDisplay = this;
            this.createUI();
            let html = "";
            if (this.ramaddas.length == 0) {
                html += this.getMessage("No repositories specified");
            } else {
                html += this.getMessage("Loading repository listing");
            }
            this.numberWithTypes = 0;
            this.finishedInitDisplay = false;
            //Check for and remove the all repositories
            if (this.ramaddas.length > 1) {
                if (this.ramaddas[this.ramaddas.length - 1].getRoot() == "all") {
                    this.ramaddas.splice(this.ramaddas.length - 1, 1);
                }
            }
            for (let i = 0; i < this.ramaddas.length; i++) {
                if (i == 0) {}
                let ramadda = this.ramaddas[i];
                let types = ramadda.getEntryTypes(function(ramadda, types) {
                    theDisplay.gotTypes(ramadda, types);
                });
                if (types != null) {
                    this.numberWithTypes++;
                }
            }
            this.setDisplayTitle("Repositories");
            this.setContents(html);
            this.finishedInitDisplay = true;
            this.displayRepositories();
        },
        displayRepositories: function() {
            if (!this.finishedInitDisplay || this.numberWithTypes != this.ramaddas.length) {
                return;
            }
            let typeMap = {};
            let allTypes = [];
            let html = "";
            html += HU.openTag(TAG_TABLE, [ATTR_CLASS, "display-repositories-table", ATTR_WIDTH, "100%", ATTR_BORDER, "1", "cellspacing", "0", "cellpadding", "5"]);
            for (let i = 0; i < this.ramaddas.length; i++) {
                let ramadda = this.ramaddas[i];
                let types = ramadda.getEntryTypes();
                for (let typeIdx = 0; typeIdx < types.length; typeIdx++) {
                    let type = types[typeIdx];
                    if (typeMap[type.getId()] == null) {
                        typeMap[type.getId()] = type;
                        allTypes.push(type);
                    }
                }
            }

            html += HU.openTag(TAG_TR, ["valign", "bottom"]);
            html += HU.th([ATTR_CLASS, "display-repositories-table-header"], "Type");
            for (let i = 0; i < this.ramaddas.length; i++) {
                let ramadda = this.ramaddas[i];
                let link = HU.href(ramadda.getRoot(), ramadda.getName());
                html += HU.th([ATTR_CLASS, "display-repositories-table-header"], link);
            }
            html += "</tr>";

            let onlyCats = [];
            if (this.categories != null) {
                onlyCats = this.categories.split(",");
            }



            let catMap = {};
            let cats = [];
            for (let typeIdx = 0; typeIdx < allTypes.length; typeIdx++) {
                let type = allTypes[typeIdx];
                let row = "";
                row += "<tr>";
                row += HU.td([], HU.image(type.getIcon()) + " " + type.getLabel());
                for (let i = 0; i < this.ramaddas.length; i++) {
                    let ramadda = this.ramaddas[i];
                    let repoType = ramadda.getEntryType(type.getId());
                    let col = "";
                    if (repoType == null) {
                        row += HU.td([ATTR_CLASS, "display-repositories-table-type-hasnot"], "");
                    } else {
                        let label =
                            HU.tag(TAG_A, ["href", ramadda.getRoot() + "/search/type/" + repoType.getId(), "target", "_blank"],
                                   repoType.getEntryCount());
                        row += HU.td([ATTR_ALIGN, "right", ATTR_CLASS, "display-repositories-table-type-has"], label);
                    }

                }
                row += "</tr>";

                let catRows = catMap[type.getCategory()];
                if (catRows == null) {
                    catRows = [];
                    catMap[type.getCategory()] = catRows;
                    cats.push(type.getCategory());
                }
                catRows.push(row);
            }

            for (let i = 0; i < cats.length; i++) {
                let cat = cats[i];
                if (onlyCats.length > 0) {
                    let ok = false;
                    for (let patternIdx = 0; patternIdx < onlyCats.length; patternIdx++) {
                        if (cat == onlyCats[patternIdx]) {
                            ok = true;
                            break;
                        }
                        if (cat.match(onlyCats[patternIdx])) {
                            ok = true;
                            break;

                        }
                    }
                    if (!ok) continue;

                }
                let rows = catMap[cat];
                html += "<tr>";
                html += HU.th(["colspan", "" + (1 + this.ramaddas.length)], cat);
                html += "</tr>";
                for (let row = 0; row < rows.length; row++) {
                    html += rows[row];
                }

            }


            html += HU.closeTag(HU.TAG_TABLE);
            this.setContents(html);
        },
        gotTypes: function(ramadda, types) {
            this.numberWithTypes++;
            this.displayRepositories();
        }
    });
}


function DisplayEntryMetadata(display,metadataType,metadata) {
    this.display=display;
    this.metadata = metadata;
    this.metadataType = metadataType;
    metadataType.addNot = metadata.addNot;

    if(metadata.elements) 
	this.elements= metadata.elements.map(element=>{return new DisplayEntryMetadataElement(display,this,element);});
    $.extend(this,{
	getType:function() {
	    return this.metadataType.getType();
	},
	getLabel:function() {
	    return this.metadataType.getLabel();
	},
	getAddNot:function() {
	    return this.metadataType.getAddNot();
	},		
	getElements:function() {
	    return this.elements;
	}
    });
}

//metadataelement
function DisplayEntryMetadataElement(display,metadata,element) {
    this.display=display;
    this.metadata=metadata;
    this.element = element;
    $.extend(this,{
	getMetadataType:function() {
	    return this.metadata.getType();
	},

	getType:function() {
	    return this.element.type;
	},
	getName:function() {
	    return this.element.name;
	},	
	getIndex:function() {
	    return this.element.index;
	},
	getValues:function() {
	    return this.element.values;
	},
	getInputText:function() {
	    return jqid(this.inputId).val();
	},
	makeInput:function() {
	    this.inputId = this.display.getMetadataFieldId(this.metadata.getType())+'_element_' + this.getIndex()+'_input';
	    let input = HU.input('','',[ATTR_CLASS,
					'display-simplesearch-input',
					ATTR_ID,this.inputId,ATTR_STYLE,HU.css('width','100%'),ATTR_PLACEHOLDER,this.getName()]);
	    return input;
	},
	cbxState:{},
	setCbxOn:function(v) {
	    this.cbxState[v] = true;
	},
	setCbxOff:function(v) {
	    this.cbxState[v] = false;
	},	
	addSearchSettings:function(settings) {
	    let text;
	    Object.keys(this.cbxState).forEach(value=>{
		if(!this.cbxState[value]) return;
		settings.metadata.push({
		    type: this.getMetadataType(),
		    index:this.getIndex(),
		    value: value
		});
	    });
	    if(this.selectId && jqid(this.selectId).length) {
		text=jqid(this.selectId).val();
	    } else if(this.getType()=='string') {
		text = this.getInputText();
	    }
	    if(text) {
		let textArray = text;
		if(!Array.isArray(textArray)) textArray = [textArray];
		textArray.forEach(text=>{
		    if(!Utils.stringDefined(text)) return;
		    settings.metadata.push({
			type: this.getMetadataType(),
			index:this.getIndex(),
			value: text
		    });
		});
	    }

	},


	makeCheckboxes:function(idToElementMap,multiples) {
	    let cbxs=[];
	    this.selectId = this.display.getMetadataFieldId(this.metadata.getType())+"_select_" + this.getIndex();
            let select =multiples?'': HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""]);
	    let popupLimit = this.display.getTagPopupLimit();
	    let addNot = this.display.getProperty('metadata.' +this.metadata.getType()+'.addnot',this.metadata.getAddNot());
	    this.getValues().forEach((v,i)=>{
                let count = v.count;
                let value = v.value;
                let label = v.label;
		let type =this.metadata.getType();
                let optionAttrs = [ATTR_VALUE, value, ATTR_CLASS, "display-metadatalist-item"];
                let selected = this.cbxState[value];
                if (selected) {
		    optionAttrs.push("selected");
		    optionAttrs.push(null);
                }
                select += HU.tag(TAG_OPTION, optionAttrs, label + " (" + count + ")");
		let cbxId = this.display.getMetadataFieldId(this.metadata.getType())+"_checkbox_" + this.getIndex()+"_"+i;
		if(idToElementMap) idToElementMap[cbxId] = this;
		let cbx = HU.checkbox("",[ATTR_ID,cbxId,
					  "metadata-type",type,
					  "metadata-index",this.getIndex(),
					  "metadata-value",value],selected) +" " + HU.tag( "label",  [ATTR_CLASS,"ramadda-noselect ramadda-clickable","for",cbxId],label +" (" + count+")");
		if(this.getValues().length>popupLimit) {
		    cbx = HU.span([ATTR_CLASS,'display-search-tag','tag',label], cbx);
		}
		cbxs.push(cbx);
		if(addNot) {
		    let cbxId = this.display.getMetadataFieldId(this.metadata.getType())+"_notcheckbox_" + this.getIndex()+"_"+i;
		    if(idToElementMap) idToElementMap[cbxId] = this;
		    let cbx = HU.checkbox("",[ATTR_ID,cbxId,
					      "metadata-not",true,
					      "metadata-type",type,
					      "metadata-index",this.getIndex(),
					      "metadata-value",value],selected) +" " +
			HU.tag( "label",  [ATTR_CLASS,"ramadda-noselect ramadda-clickable","for",cbxId],"<b>Not</b> " + label +" (" + count+")");
		    if(this.getValues().length>popupLimit) {
			cbx = HU.span([ATTR_CLASS,'display-search-tag','tag',label], cbx);
		    }
		    cbxs.push(cbx);
		}


	    });
	    let selectAttrs = [ATTR_ID,this.selectId];
	    if(multiples) selectAttrs.push('multiple','true','size',4);
	    this.select = HU.tag(TAG_SELECT, selectAttrs,select);
	    return cbxs;

	}
    });
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


//uncomment this to add this type to the global list
//addGlobalDisplayType({type: "example", label:"Example"});


/*
  This gets created by the displayManager.createDisplay('example')
 */
function RamaddaExampleDisplay(displayManager, id, properties) {

    //Dom id for example
    //The displays use display.getDomId(ID_CLICK) to get a unique (based on the display id) id
    var ID_CLICK = "click";

    var ID_DATA = "data";

    //Create the base class
    RamaddaUtil.inherit(this, new RamaddaDisplay(displayManager, id, "example", properties));

    //Add this display to the list of global displays
    addRamaddaDisplay(this);

    //Define the methods
    RamaddaUtil.defineMembers(this, {
        //gets called by displaymanager after the displays are layed out
        initDisplay: function() {
            //Call base class to init menu, etc
            this.createUI();

            //I've been calling back to this display with the following
            //this returns "getRamaddaDisplay('" + this.getId() +"')";
            var get = this.getGet();
            var html = "<p>";
            html += HtmlUtils.onClick(get + ".click();", HtmlUtils.div([ATTR_ID, this.getDomId(ID_CLICK)], "Click me"));
            html += "<p>";
            html += HtmlUtils.div([ATTR_ID, this.getDomId(ID_DATA)], "");

            //Set the contents
            this.setContents(html);

            //Add the data
            this.updateUI();
        },
        //this tells the base display class to loadInitialData
        needsData: function() {
            return true;
        },
        //this gets called after the data has been loaded
        updateUI: function() {
            var pointData = this.getData();
            if (pointData == null) return;
            var recordFields = pointData.getRecordFields();
            var records = pointData.getRecords();
            var html = "";
            html += "#records:" + records.length;
            //equivalent to:
            //$("#" + this.getDomId(ID_DATA)).html(html);
            this.jq(ID_DATA).html(html);
        },
        //this gets called when an event source has selected a record
        handleEventRecordSelection: function(source, args) {
            //args: index, record, html
            //this.setContents(args.html);
        },
        click: function() {
            this.jq(ID_CLICK).html("Click again");
        }
    });
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


const DISPLAY_MAP = "map";

let displayMapMarkers = ["marker.png", "marker-blue.png", "marker-gold.png", "marker-green.png"];
let displayMapCurrentMarker = -1;
let displayMapUrlToVectorListeners = {};
let displayMapMarkerIcons = {};

var ID_REGION_SELECTOR = "regionselector";


var debugit = false;
var debugMapTime = false;

addGlobalDisplayType({
    type: DISPLAY_MAP,
    label: "Map",
    category:CATEGORY_MAPS,
    preview: "map1.png",
    desc:"Lots of ways to show georeferenced data - dots, heatmaps, plots, etc",        
});




function MapFeature(source, points) {
    RamaddaUtil.defineMembers(this, {
        source: source,
        points: points
    });
}

var ID_MAP = "map";
var ID_MAP_CONTAINER = "mapcontainer";
var xcnt = 1;
var ycnt = 1;

function RamaddaBaseMapDisplay(displayManager, id, type,  properties) {
    $.extend(this, {
        theMap: null
    });

    //Default to a tooltip
    //    if(!properties.tooltip) properties.tooltip='${default}';
    this.myycnt = ++ycnt;
    this.myName = "map " + (this.myycnt);
    const SUPER = new RamaddaDisplay(displayManager, id, type,   properties);
    RamaddaUtil.inherit(this,SUPER);
    this.defineSizeByProperties();
    let myProps = [
	{label:'Base Map Properties'},
	{p:'bounds',ex:'north,west,south,east',tt:'initial bounds'},
	{p:'maxBounds',ex:'n,w,s,e or conus',tt:'max bounds when applying filters'},
	{p:'gridBounds',ex:'north,west,south,east'},	
	{p:'mapCenter',ex:'lat,lon',tt:"initial position"},
	{p:'zoomLevel',ex:4,tt:"initial zoom"},
	{p:'centerOnConus',ex:true},
	{p:'centerOnNA',ex:true},
	{p:'initBoundsUseAllRecords',ex:true},
	{p:'initBoundsPadding',ex:'A percent, e.g.0.05'},
	{p:'zoomTimeout',ex:500,
	 tt:"initial zoom timeout delay. set this if the map is in tabs, etc, and not going to the initial zoom"},
	{p:'popupWidth',d:400},
	{p:'popupHeight',d:200},	
	{p:'linked',ex:true,tt:"Link location with other maps"},
	{p:'linkGroup',ex:'some_name',tt:"Map groups to link with"},
	{p:'initialLocation', ex:'lat,lon',tt:"initial location"},
	{p:'defaultMapLayer',ex:'osm|google.roads|esri.street|google.hybrid|google.roads|google.terrain|google.satellite|opentopo|esri.topo|usfs|usgs.topo|naip|usgs.imagery|esri.shaded|esri.lightgray|esri.darkgray|esri.terrain|shadedrelief|esri.aeronautical|historic|osm.toner|osm.toner.lite'},
	{p:'geojsonLayer',ex:'entry ID',tt:'Display the geojson layer file held by give entry'},
	{p:'geojsonLayerName',d:'Map'},
	{p:'justShowMapLayer',ex:true,tt:'If true then just show map layer, don\'t use it for data display'},
	{p:'extraLayer1',label:'XYZ Layer',
	 ex:'xyz:name:Some Name:url:https\\\\://server/tiles/${z}/${x}/${y}.png:baseLayer:false:visible:true'},
	{p:'extraLayer1',label:'WMS Layer',
	 ex:'wms:name:Some Name:url:https\://server/tiles/${z}/${x}/${y}.png:baseLayer:false:visible:true'},
	{p:'extraLayer1',label:'GeoJSON Layer',
	 ex:'geojson:name:Some Name:url:resources/usmap.json:fillColor:transparent'},
	{p:'extraLayer1',label:'KML Layer',
	 ex:'geojson:name:Some Name:url:resources/usmap.json:fillColor:transparent'},		

	{p:'linkFields',tt:'Comma separated list of fields in the data to match with the map field, e.g., geoid'},	
	{p:'linkFeature',ex:'geoid',tt:'The field in the map to match with the data field, e.g., geoid'},
	{p:'debugFeatureLinking',tt:'Debug feature linking',ex:true},
	{p:'pruneFeatures',ex:true,tt:'Hide any features in the map that don\'t have a corresponding record'},
	{p:'showHighlight',ex:'true',tt:'Show popup when point is moused over'},
	{p:'highlightTemplate',ex:'Some text ${field1}',tt:'Template for mousing over points'},

	{p:'highlightWidth',d:200,tt:'Width of highlight popup'},
	{p:'highlightHeight',ex:200,tt:'Height of highlight popup'},	

	{p:'polygonField',tt:'Field that contains a polygon'},		

	{p:'annotationLayerTop',ex:'true',tt:'If showing the extra annotation layer put it on top'},

	{p:'showBounds',ex:'true',d:false},
	{p:'boundsStrokeColor',d:'blue'},
	{p:'boundsFillColor',d:'transparent'},
	{p:'boundsFillOpacity',d:'0.0'},			

	{p:'showOpacitySlider',ex:'false'},
	{p:'showLocationSearch',ex:'true'},
	{p:'showLatLonPosition',ex:'false',d:true},
	{p:'singlePointZoom',ex:'12'},
	{p:'showOverviewMap',ex:true},
	{p:'overviewMapWidth',d:180},
	{p:'overviewMapHeight',d:90},
	{p:'overviewMapHeight',d:90},
	{p:'overviewMapResolution',d:1},					
	{p:'overviewMapMinRatio',d:24},
	{p:'overviewMapMaxRatio',d:64},
	
	{p:'overviewMapLayer',ex:'osm|google.roads|esri.street|google.hybrid|google.roads|google.terrain|google.satellite|opentopo|esri.topo|usfs|usgs.topo|naip|usgs.imagery|esri.shaded|esri.lightgray|esri.darkgray|esri.terrain|shadedrelief|esri.aeronautical|historic|osm.toner|osm.toner.lite'},
	{p:'showGraticules',ex:true},	
	{p:'showLayerSwitcher',d:true,ex:'false'},
	{p:'showScaleLine',ex:'true',d:false},
	{p:'showZoomPanControl',ex:'true',d:true},
	{p:'showZoomOnlyControl',ex:'false',d:false},
	{p:'enableDragPan',ex:'false',d:true},
	{p:'showLayers',d:true,ex:'false',tt:'Connect points with map vectors'},
	{p:'showBaseLayersSelect',ex:true,d:false},
	{p:'baseLayerSelectLabel',d:null},
	{p:'locations',ex:'countries.json,usstates.json,uscities.json,usairports.json'},
	{p:'highlightColor',d:'blue',ex:'#ccc',tt:''},
	{p:'highlightFillColor',ex:'#ccc',
	 tt:'Use "match" to match the features opacity'},		
	{p:'highlightFillOpacity',ex:'0.5',
	 tt:'Use "match" to match the features opacity'},		
	{p:'highlightStrokeWidth',ex:'2',
	 tt:'Use "match" to match the features opacity'},			 
	{p:"highlightStrokeColor",
	 tt:'Use "match" to match the features opacity'},

	{p:'selectFillColor',ex:'#ccc',
	 tt:'Use "match" to match the features opacity'},		
	{p:'selectFillOpacity',ex:'0.5',
	 tt:'Use "match" to match the features opacity'},		
	{p:'selectStrokeWidth',ex:'2',
	 tt:'Use "match" to match the features opacity'},			 
	{p:"selectStrokeColor",
	 tt:'Use "match" to match the features opacity'},
	{p:"selectStrokeOpacity",
	 tt:'Use "match" to match the features opacity'},			 		
	
        {p:"vectorLayerStrokeColor",d:'#000'},
	{p:"vectorLayerFillColor",d:'#ccc'},
	{p:"vectorLayerFillOpacity",d:0.25},
        {p:"vectorLayerStrokeWidth",d:0.3},
    ];

    this.debugZoom = properties['debugZoom'];
    
    displayDefineMembers(this, myProps, {
        mapBoundsSet: false,
	extraLayers:[],
        initDisplay: function() {
	    //	    if(displayDebug.initMap) console.log(this.getLogLabel()+".initDisplay");
            SUPER.initDisplay.call(this);
	    if(!HU.documentReady) {
		$( document ).ready(()=> {
		    if(this.map) {
			setTimeout(()=>{
			    this.callingUpdateSize = true;
			    this.map.getMap().updateSize();
			    this.callingUpdateSize = false;
			},50);
		    }
		});
	    }
            let _this = this;
            let html = "";
            let extraStyle="";
            let height = this.getProperty("height", this.getProperty("mapHeight", '70vh'));
            if (height < 0) {
		height = (-height)+"%";
	    }
	    height = HU.getDimension(height);
            extraStyle += HU.css(ATTR_HEIGHT, height);

	    let map =HU.div(["tabindex","1",ATTR_CLASS, "display-map-map ramadda-expandable-target", ATTR_STYLE,
			     extraStyle, ATTR_ID, this.domId(ID_MAP)]);

	    let mapContainer = HU.div([ATTR_CLASS,"ramadda-map-container",ATTR_ID,this.domId(ID_MAP_CONTAINER)],
				      map+
				      HU.div([ATTR_CLASS,"ramadda-map-slider",ATTR_STYLE,this.getProperty("popupSliderStyle", "max-height:400px;overflow-y:auto;xxxmax-width:300px;overflow-x:auto;"),ATTR_ID,this.domId(ID_MAP)+"_slider"]));

            this.setContents(mapContainer);
	    
            if (!this.map) {
                this.createMap();
            } else {
                this.map.setMapDiv(this.domId(ID_MAP));
            }
            if (!this.haveCalledUpdateUI) {
		//		if(displayDebug.initMap)  console.log(this.getLogLabel()+" have not calledUpdateUI. setting up callback");
                let callback = function() {
		    _this.updateUICallback = null;
                    _this.updateUI();
                }
                this.updateUICallback = setTimeout(callback, 1);
            }
        },
	initRegionsSelector:function(button) {
	    //Fetch the regions
	    if(!MapUtils.regions) {
		let jqxhr = $.getJSON(RamaddaUtil.getUrl("/regions.json"), data=> {
		    if (GuiUtils.isJsonError(data)) {
			console.log("Error fetching regions");
			MapUtils.regions=[];
			return;
		    }
		    MapUtils.regions=data;
		    this.initRegionsSelector(button);
		});
		return;
	    }		    
	    let _this = this;
	    if(_this.regionsDialog) _this.regionsDialog.remove();		
	    let id = _this.domId(ID_REGION_SELECTOR);
	    let html = _this.makeRegionsMenu();
	    html = HU.div([ATTR_CLASS, "ramadda-popup-inner",ATTR_ID,id,
			   ATTR_STYLE,HU.css('margin-top','0.5em','min-width','800px')],html);
	    _this.regionsDialog = HU.makeDialog({content:html,title:'Regions',
						 draggable:true,header:true,
						 my:'left top',at:'left bottom',anchor:button});
	    _this.regionsDialog.find(".ramadda-menu-item").click(function() {
		let region = MapUtils.regions[+$(this).attr("idx")];
		_this.map.setViewToBounds(new RamaddaBounds(region.north, region.west, region.south, region.east));
	    });
	    this.jq('regionsearch').focus();
	    let regionItems = 	  this.regionsDialog.find(".ramadda-region-item")
	    this.jq('regionsearch').keyup(function(event) {
		let text = $(this).val().trim().toLowerCase();
		regionItems.each(function() {
		    if(text=='') {
			$(this).show();
		    } else {
			let corpus = $(this).html();
			if(!corpus) return;
			corpus =  corpus.toLowerCase();
			if(corpus.indexOf(text)>=0) {
			    $(this).show();
			} else {
			    $(this).hide();
			}
		    }
		});

	    });

	},

	makeRegionsMenu:function() {
	    let groups = {};
	    MapUtils.regions.forEach((r,idx)=>{
		//skip world as its a dup
		if(r.name == "World") return
		let group = r.group;
		if(group.toLowerCase()=="model regions") group="Regions";
		let name = r.name.replace(/ /g,"&nbsp;");
		let item = HU.div([ATTR_CLASS,"ramadda-menu-item ramadda-region-item", "idx",idx],name);
		if(!groups[group]) groups[group] = "";
		groups[group] +=item;});
	    let html ='';
	    html+= HU.center(HU.input('','',['placeholder','Find Region',ATTR_ID,this.domId('regionsearch'),'width','10']));
	    html += "<table width=100%><tr valign=top>";
	    let keys = Object.keys(groups);
	    let width = (100/keys.length)+'%';
	    keys.forEach(group=>{
		html+= HU.td(['width',width], HU.div([ATTR_STYLE,HU.css("font-weight","bold","border-bottom","1px solid #ccc","margin-right","5px")], Utils.camelCase(group))+HU.div([ATTR_STYLE,HU.css("max-height","200px","overflow-y","auto", "margin-right","10px")], groups[group]));
	    });
	    html+=HU.close(TAG_TR,TAG_TABLE);
	    return html;
	},

	getTurfPoints:function(f) {
	    let p=[];
	    let coords = f.geometry.coordinates;
	    coords.forEach(pair=>{
		p.push(pair[1],pair[0]);
	    });
	    return p;
	},
	makeTurfBounds:function(bounds,padding) {
	    if(Utils.isDefined(padding)) {
		let w = bounds.east-bounds.west;
		let h = bounds.north - bounds.south;
		return [bounds.west-padding*w, bounds.south-padding*h, bounds.east+padding*w, bounds.north+padding*h];
	    }
	    return [bounds.west, bounds.south, bounds.east, bounds.north];
	},
	makeFeature:function(map,geometryType, style, points) {
	    if(points.length>2) {
		let latLons = [];
		for(let i=0;i<points.length;i+=2) {
		    latLons.push(MapUtils.createPoint(points[i+1],points[i]));
		}
		if(geometryType=="OpenLayers.Geometry.Polygon") {
		    map.transformPoints(latLons);
		    let linearRing = MapUtils.createLinearRing(latLons);
		    let geom = MapUtils.createPolygon(linearRing);
		    return MapUtils.createVector(geom,null,style);
		} else {
		    return  map.createPolygon("","",latLons,style,null,geometryType=="OpenLayers.Geometry.LineString");
		}
	    } 
	    let point =  MapUtils.createLonLat(points[1], points[0]);
	    return  map.createPoint("",point,style);
	},

	createGeoJsonLayer:function(name,geojson,layer,style) {
	    if(layer) {
		layer.removeFeatures(layer.features);
	    } else {
		layer = MapUtils.createLayerVector(name,
						   {projection: this.getMap().getMap().displayProjection},
						   style);
		this.getMap().addLayer(layer);
		layer.ramaddaLayerIndex = 100;
		if(Utils.isDefined(this.layerVisible) && !this.layerVisible)
		    layer.setVisibility(false);
	    }
            let format= new OpenLayers.Format.GeoJSON({});
	    let features = format.read(geojson);
	    let strategy = new OpenLayers.Strategy.Fixed();
	    strategy.layer= layer;
	    strategy.merge({features:features});
	    this.extraLayers.push(layer);
	    return layer;
	},

	getBaseLayersSelect:function() {
	    if(this.map.baseLayers) {
		let items = [];
		let on = false;
		for(a in this.map.baseLayers) {
		    let layer = this.map.baseLayers[a];
		    if(!layer.isBaseLayer) continue;
		    if(layer.getVisibility()) on = a;
		    items.push([a,layer.name]);
		}
		let prefix = this.getBaseLayerSelectLabel();
		if(prefix) prefix=HU.b(prefix)+':'+SPACE;
		return  HU.span([ATTR_TITLE,"Choose base layer", ATTR_CLASS,"display-filter"],

				(prefix??'') +
				HU.select("",[ATTR_ID,this.domId("baselayers")],items,on));
	    }
	    return '';
	},
	initBaseLayersSelect:function() {
	    let _this = this;
	    this.jq("baselayers").change(function() {
		let on = $(this).val();
		for(let id in _this.map.baseLayers) {
		    if(id==on) {
			_this.map.getMap().setBaseLayer(_this.map.baseLayers[id]);
			break;
		    }
		}
	    });
	},
	checkLevelRange:function(layers, redraw) {
	    if(!layers) layers=[this.getMap().getMarkersLayer()];
	    if(this.debugZoom) console.log("features:");
	    let level = this.getMap().getMap().getZoom();
	    layers.forEach(layer=>{
		if(!layer) return;
		layer.features.forEach(feature=>{
		    if(!feature.levelRange) {
			if(this.debugZoom) console.log("\tno level range");
			return;
		    }
		    if(!feature.style) feature.style = {};
		    let visible = level>=feature.levelRange.min &&
			level<=feature.levelRange.max;
		    let changed= false;
		    //		console.log("\tlevel:",level,feature.levelRange,visible); 
		    if(visible) {
			changed = feature.style.display != 'inline';
			feature.style.display = 'inline';
		    }  else {
			changed = feature.style.display != 'none';
			feature.style.display = 'none';
		    }			
		    if(redraw &&changed) {
			layer.drawFeature(feature);
		    }
		});
	    });
	},

	getMap:function() {
	    return this.map;
	},
	setErrorMessage: function(msg) {
	    if(this.errorMessageHandler) {
		this.errorMessageHandler(this,msg);
		return
	    }
	    if(this.map)
		this.map.setProgress(HU.div([ATTR_CLASS, "display-map-message"], msg));
	    else
		SUPER.setErrorMessage.call(this,msg);
	},
	setMessage: function(msg) {
	    if(this.map) {
		if(msg!="")
		    msg = HU.div([ATTR_CLASS, "display-map-message"], msg);
		this.map.setProgress(msg);
	    }
	},
	setMapLabel: function(msg) {
	    if(this.map)
		this.map.setLabel(HU.div([ATTR_CLASS, "display-map-message"], msg));
	},	
	startProgress: function(msg) {
	    this.setMessage(msg??this.getProperty("loadingMessage","Creating map..."));
	},
	clearProgress: function() {
	    if(this.errorMessage) {
		this.errorMessage = null;
		return;
	    }
	    if(this.map) {
		this.map.hideLoadingImage();
		this.map.setProgress("");
	    }
	},

        checkLayout: function() {
            if (!this.map) {
                return;
            }
            let d = this.jq(ID_MAP);
            if (d.width() > 0 && this.lastWidth != d.width() && this.map) {
                this.lastWidth = d.width();
                this.map.getMap().updateSize();
            }
	    /* not sure why we have this here but it ends up screwing up the map zooming way out
	       if(!this.setMapLocationAndZoom && this.mapParams) {
	       this.setMapLocationAndZoom = true;
	       if(this.mapParams.initialZoom>=0) {
	       this.map.zoomTo(this.mapParams.initialZoom);
	       }
	       if(this.mapParams.initialLocation) {
	       let loc = MapUtils.createLonLat(this.mapParams.initialLocation.lon, this.mapParams.initialLocation.lat);
	       this.map.setCenter(loc);
	       }

	       }**/
        },

        initMapParams: function(params) {
	    params.maxBounds = this.getMaxBounds();
	    if(this.getProperty('canMove',false)) {
		params.canMove=true;
	    }
	    if(!this.getProperty('addMapLocationToUrl',true)) {
		params.addToUrl=false;
	    }
	    if(this.getSinglePointZoom()) {
		params.singlePointZoom = this.getSinglePointZoom();
	    }
	    if(this.getShowOpacitySlider()) {
		params.showOpacitySlider=true;
	    }
	    ['highlightStrokeColor','highlightFillColor',"highlightStrokeWidth","highlightFillOpacity","changeSizeOnSelect"].forEach(p=>{
		let v = this.getProperty(p);
		if(Utils.isDefined(v)) {
		    params[p] = v;
		}
	    });
	},
	initMap:function(map) {
	},
        doDisplayMap: function() {
	    return true;
	},
        createMap: function() {
            this.map = this.getProperty("externalMap", null);
	    if(this.map) {
		return this.map;
	    }

            let _this = this;
            let params = {
                defaultMapLayer: this.getDefaultMapLayer(map_default_layer),
		showLayerSwitcher: this.getShowLayerSwitcher(),
		showScaleLine: this.getShowScaleLine(),
		showLatLonPosition: this.getShowLatLonPosition(),
		showZoomPanControl: this.getShowZoomPanControl(),
		showZoomOnlyControl: this.getShowZoomOnlyControl(),
		enableDragPan: this.getEnableDragPan(),
		highlightColor: this.getHighlightColor(),
		highlightFillColor: this.getHighlightFillColor("match"),
		highlightFillOpacity: this.getHighlightFillOpacity(),				
		highlightStrokeWidth: this.getHighlightStrokeWidth(1),

		selectFillColor: this.getSelectFillColor("match"),
		selectFillOpacity: this.getSelectFillOpacity(),				
		selectStrokeWidth: this.getSelectStrokeWidth(),
		selectStrokeColor: this.getSelectStrokeColor(),		
		selectStrokeOpacity: this.getSelectStrokeOpacity(),				

		showLatLonLines:this.getProperty("showLatLonLines"),
		popupWidth: this.getPopupWidth(),
		popupHeight: this.getPopupHeight(),

            };
	    this.mapParams = params;
            let displayDiv = this.getProperty("displayDiv", null);
            if (displayDiv) {
                params.displayDiv = displayDiv;
		params.displayDivSticky = this.getProperty("displayDivSticky", false);
            }
            if (!this.getShowLocationSearch(true)) {
                params.showLocationSearch = false;
            }


	    params.addMarkerOnClick = this.getProperty('addMarkerOnClick');
	    params.linked = this.getLinked(false);
	    params.linkGroup = this.getLinkGroup(null);

	    this.hadInitialPosition = false;
            if (this.getProperty("latitude")) {
		this.hadInitialPosition = true;
                params.initialLocation = {lon:+this.getProperty("longitude", -105),
					  lat:+this.getProperty("latitude", 40)};
	    }
	    if(this.getCenterOnConus()) {
		if(!this.getZoomLevel()) 
		    this.setProperty('zoomLevel',3);
		this.setProperty('mapCenter','39.8333,-98.5855');
	    }
	    if(this.getCenterOnNA()) {
		if(!this.getZoomLevel()) 
		    this.setProperty('zoomLevel',3);
		this.setProperty('mapCenter','46.17983,-92.43896');
	    }	    

	    this.hadUrlArgumentMapCenter = Utils.stringDefined(HU.getUrlArgument(ARG_MAPCENTER));
	    this.hadUrlArgumentZoom = Utils.stringDefined(HU.getUrlArgument(ARG_ZOOMLEVEL));
	    if(!this.hadUrlArgumentMapCenter && this.getMapCenter()) {
		this.hadInitialPosition = true;
		[lat,lon] =  this.getMapCenter().replace("%2C",",").split(",");
                params.initialLocation = {lon:lon,lat:lat};
	    }

	    if(!this.hadUrlArgumentZoom && this.getZoomLevel()) {
		this.hadInitialPosition = true;
                params.initialZoom = +this.getZoomLevel();
		params.initialZoomTimeout = this.getZoomTimeout();
		if(debugBounds) console.log("DisplayMap - set initialZoom", params.initialZoom);
	    }

            this.map = this.getProperty("theMap", null);
            if (this.map) {
                this.map.setMapDiv(this.domId(ID_MAP));
            } else {
		if(this.getInitialLocation()) {
		    let toks = this.getInitialLocation().split(",");
		    params.initialLocation = {
			lat:+toks[0],
			lon:+toks[1]
		    }
		}
		this.initMapParams(params);
                this.map = new RepositoryMap(this.domId(ID_MAP), params);
		this.map.popupListener = (id,text) =>{
		    let fields = jqid(id).find('[field-id]');
		    fields.addClass('ramadda-clickable');
		    fields.click(function() {
			let field = $(this).attr('field-id');
			let value = $(this).attr('field-value');			
			//A hack because for some reason clicking on an href isn't doing anything
			if(value && value.toLowerCase().startsWith('http')) {
			    window.open(value,'_link');
			    return;
			}
			let args = {
			    id:field,
			    fieldId: field,
			    value: value
			};
			_this.propagateEvent(DisplayEvent.filterChanged, args,true);
		    });
		};
		if(this.getShowOverviewMap()) {
		    let opts = {size:{}};
		    let layer = this.getOverviewMapLayer();
		    if(layer) {
			layer = this.getMap().getMapLayer(layer);
			if(layer) {
			    opts.layers=[layer.clone()]
			}
		    }
		    opts.size.w=this.getOverviewMapWidth();
		    opts.size.h=this.getOverviewMapHeight();		    
		    opts.resolutionFactor = this.getOverviewMapResolution();
		    opts.minRatio = this.getOverviewMapMinRatio();
		    opts.maxRatio = this.getOverviewMapMaxRatio();		    
		    this.map.setShowOverviewMap(true,opts);
		}
		if(this.getShowGraticules()) {
		    this.map.setGraticulesVisible(true);
		}		
		this.map.myid = this.getLogLabel();
		//Set this so there is no popup on the off feature
		this.map.addKeyUpListener(event=>{
		    this.handleKeyUp(event);
		});
		this.map.addKeyDownListener(event=>{
		    this.handleKeyDown(event);
		});		
		this.map.textGetter = (layer,feature) =>{
		    return null;
		};
                this.lastWidth = this.jq(ID_MAP).width();
            }
	    this.initMap(this.map);
            if (this.doDisplayMap()) {
                this.map.setDefaultCanSelect(false);
            }
            this.map.initMap(false);
	    let hasLoc = Utils.isDefined(this.getZoomLevel())   ||
		Utils.isDefined(this.getMapCenter()) ||
		this.hadInitialPosition;
	    
            if (this.getPropertyBounds() ||this.getPropertyGridBounds() ) {
		this.hadInitialPosition = true;
                let toks = this.getPropertyBounds(this.getGridBounds("")).split(",");
                if (toks.length == 4) {
                    if (this.getShowBounds()) {
                        let attrs = {};
                        if (this.getBoundsStrokeColor(this.getProperty("boundsColor"))) {
                            attrs.strokeColor = this.getBoundsStrokeColor(this.getProperty("boundsColor"));
                        }
                        attrs.fillColor = this.getBoundsFillColor();
                        attrs.fillOpacity = this.getBoundsFillOpacity();			
                        let feature = this.map.addRectangle("bounds", parseFloat(toks[0]), parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]), attrs, "");
			feature.noSelect = true;
                    }
		    if(!hasLoc && this.setInitMapBounds)
			this.setInitMapBounds(parseFloat(toks[0]), parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]));
                }
            }


	    
	    if(this.getProperty("annotationLayer")) {
		let opts = {theMap:this.map,
			    embedded:true,
			    displayOnly:true,
			   };
		if(this.getPropertyAnnotationLayerTop()) {
		    opts.layerIndex = 100;
		}

		this.editableMap = new  RamaddaEditablemapDisplay(this.getDisplayManager(),HU.getUniqueId(""),opts);
		this.editableMap.initDisplay(true);
		this.editableMap.loadMap(this.getProperty("annotationLayer"));
	    }
	    
	    let extras = [];
	    if(this.getProperty('extraLayers')) {
		extras =Utils.mergeLists(extras,    this.getProperty('extraLayers').split(","));
	    }
	    if(Utils.stringDefined(this.getProperty('extraLayer'))) {
		extras.push(this.getProperty('extraLayer'));    
	    }
	    for(let i=1;true;i++) {
		if(!Utils.stringDefined(this.getProperty('extraLayer'+i))) break;
		extras.push(this.getProperty('extraLayer'+i));    
	    }


	    if(extras.length) {
		setTimeout(()=>{
		    this.addExtraLayers(extras);
		},1000);
	    }

            if (this.getShowLayers()) {
		//do this later so the map displays its initial location OK
		setTimeout(()=>{
		    let match = true;
		    let getId=id=>{
			match = true;
			if(id.startsWith('true:')) {
			    id =id.substring('true:'.length);
			    match=true;
			} else if(id.startsWith('false:')) {
			    id =id.substring('false:'.length);
			    match = false;
			}
			return id;
		    }
                    if (this.getProperty("shapefileLayer")) {
			let ids = Utils.split(this.getProperty('shapefileLayer',''),',',true,true);
			let labels = Utils.split(this.getProperty('shapefileLayerName',''),',',true,true);
			ids.forEach((id,idx)=>{
			    id = getId(id);
			    let url = RamaddaUtil.getUrl('/entry/show?output=shapefile.kml&entryid=' + id);
			    let label = labels[idx]??'Map';
			    this.addBaseMapLayer(url, label,true,match);
			});
                    }
                    if (this.getProperty('kmlLayer')) {
			let ids = Utils.split(this.getProperty('kmlLayer',''),',',true,true);
			let labels = Utils.split(this.getProperty('kmlLayerName',''),',',true,true);
			ids.forEach((id,idx)=>{
			    id = getId(id);
			    let url = this.getRamadda().getEntryDownloadUrl(id);
			    let label = labels[idx]??'Map';
			    this.addBaseMapLayer(url, label, true,match);
			});
                    }
		    let idx=0;
		    let geojsonUrl;
		    while((geojsonUrl=this.getProperty('geojsonLayer' + idx))) {
			this.addBaseMapLayer(geojsonUrl, '', false,match);
			idx++;
		    }
                    if (this.getProperty('geojsonLayer')) {
			let ids = Utils.split(this.getProperty('geojsonLayer',''),',',true,true);
			let labels = Utils.split(this.getProperty('geojsonLayerName',''),',',true,true);
			ids.forEach((id,idx)=>{
			    id = getId(id);
			    let url = this.getRamadda().getEntryDownloadUrl(id);
			    let label = labels[idx]??'Map';
			    this.addBaseMapLayer(url, label, false,match);
			});
                    }
		    let mapLayers = this.getProperty('mapLayers');
		    //Check to make sure it is an array
		    if(mapLayers && mapLayers.forEach) {
			this.displayingMapLayer = false;

			let process=(layer)=>{
			    let url
			    if(layer.type=='shapefile')
				url = RamaddaUtil.getUrl('/entry/show?output=shapefile.kml&entryid=' + layer.id);
			    else 
				url =  this.getRamadda().getEntryDownloadUrl(layer.id);
			    if(layer.match)
				this.displayingMapLayer = true;
			    this.addBaseMapLayer(url, layer.name, layer.type=='kml'||layer.type=='shapefile',layer.match,layer.style);
			};
			mapLayers.forEach(layer=>{if(layer.match) process(layer);});
			mapLayers.forEach(layer=>{if(!layer.match) process(layer);});			
		    }

		},500);
            }
        },

	addExtraLayers:function(extras) {
	    //extraLayers="baselayer:nexrad,geojson:US States:resources/usmap.json:fillColor:transparent"
	    extras.forEach(tuple=>{
		if(tuple.trim().length==0) return;
		tuple = tuple.replace(/https:/g,'https_semicolon_');
		tuple = tuple.replace(/\\:/g,'_semicolon_');		
		let args= {};
		let list = tuple.split(":");
		let type = list[0];
		for(let i=1;i<list.length;i+=2) {
		    let v = list[i+1]
		    if(!v) {
			console.log("Poorly formed extraLayers:" +tuple);
			continue;
		    }
		    args[list[i].trim()] =  Utils.getProperty(v.replace(/_semicolon_/g,':').replace(/_comma_/g,','));
		}

		let getUrl = url =>{
		    if(!url) return null;
		    if(url.startsWith("resources")) {
			url = RamaddaUtil.getUrl("/" + url);
		    } else if(url.startsWith("/resources")) {
			url = RamaddaUtil.getUrl(url);			
		    } else    if(!url.startsWith("/") && !url.startsWith("http")) {
			url = RamaddaUtil.getUrl("/entry/get?entryid=" + url);
		    }
		    return url;
		};

		let name = args['name'] ?? type;
		let isBaseLayer = Utils.isDefined(args.baseLayer)?args.baseLayer:false;
		let visible = Utils.isDefined(args.visible)?args.visible:true;
		if(type=="baselayer") {
		    if(!args.layer && list.length==2) {
			args.layer = list[1];
		    }
		    if(!args.layer) {
			this.logMsg("Could not find base layer:",tuple);
			return;
		    }
		    let layer = this.map.getBaseLayer(args.layer);
		    if(!layer) {
			this.logMsg("Could not find base layer:",tuple);
		    } else {
			layer.setVisibility(true);
		    }
		} else 	if(type=="geojson" || type=="kml") {
		    let url = getUrl(args.url);
		    if(!args.fillColor) args.fillColor='transparent';
		    //(name, url, canSelect, selectCallback, unselectCallback, args, loadCallback, zoomToExtent)
		    if(type=="kml") {
			this.map.addKmlLayer(name, url, false, null, null, args, null);
		    } else {
			this.map.addGeoJsonLayer(name, url, false, null, null, args, null);
		    }
		} else if(type=="wms") {
		    let url = args.url;
		    if(!url) {
			console.log("no url in wms:",args);
			return;
		    }
		    let layer=args.layer;
		    if(!layer) {
			console.log("no layer in wms:",args);
			return;
		    }
		    let opacity = args.opacity??1;
		    layer =  this.map.addWMSLayer(name,url,layer, isBaseLayer,true,{visible:visible,opacity:opacity});
		    if(isBaseLayer && (visible || this.getDefaultMapLayer()==name)) {
			this.map.getMap().setBaseLayer(layer);
		    }
		} else if(type=="xyz") {
		    let url = args.url;
		    if(!url) {
			console.log("no url in xyz:",args);
			return;
		    }
		    let layer = this.map.createXYZLayer(name,url,args.attribution,!isBaseLayer,visible);
                    this.map.addLayer(layer);
		    if(isBaseLayer && (visible || this.getDefaultMapLayer()==name)) {
			this.map.getMap().setBaseLayer(layer);
		    }
		} else {
		    console.log("Unknown map type:" + type)
		}
	    });
	},


        handleKeyUp:function(event) {
	},
        handleKeyDown:function(event) {
	},	
        addBaseMapLayer: function(url, label,isKml,matchData,style) {
	    if(!style) style={};
            let _this = this;
            mapLoadInfo = displayMapUrlToVectorListeners[url];
            if (mapLoadInfo == null) {
                mapLoadInfo = {
                    otherMaps: [],
                    layer: null
                };
                let selectFunc = function(layer) {
                    _this.mapFeatureSelected(layer);
                }
		//Don't do this for now as its handled elsewhere?
		selectFunc = null;
                let hasBounds = this.getProperty("bounds") != null ||
		    Utils.isDefined(this.getProperty("zoomLevel"))   ||
		    Utils.isDefined(this.getProperty("mapCenter"));
		let attrs =   {
                    strokeColor: matchData?this.getVectorLayerStrokeColor():
			this.getProperty('extraVectorLayerStrokeColor','blue'),
		    fillColor:this.getVectorLayerFillColor(),
		    fillOpacity:matchData?this.getVectorLayerFillOpacity():0,
                    strokeWidth: matchData?this.getVectorLayerStrokeWidth():
			this.getProperty('extraVectorLayerStrokeWidth',1),			
		}

		$.extend(attrs,style);
		//For some reason the attrs don't get applied to kml layers so we pass the attrs to baseMapLoaded
		let callback = (map, layer) =>{_this.baseMapLoaded(layer, url,isKml?attrs:null,matchData);}
		let layer;
		if (isKml)
                    layer = this.map.addKMLLayer(label??'Map', url, matchData &&this.doDisplayMap(), selectFunc,
						 null, attrs, callback, !hasBounds && matchData);
                else 
                    layer = this.map.addGeoJsonLayer(label??'Map', url, matchData&&this.doDisplayMap(), selectFunc,
						     null,   attrs,  callback, !hasBounds && matchData);
            } else if (mapLoadInfo.layer) {
                this.cloneLayer(mapLoadInfo.layer);
            } else {
                this.map.showLoadingImage();
                mapLoadInfo.otherMaps.push(this);
            }
        },
        baseMapLoaded: function(layer, url,attrs,matchData) {
	    if(attrs &&layer.features) {
		layer.features.forEach(f=>{
		    if(f.style) {
			$.extend(f.style,attrs);
		    } else {
			f.style = $.extend({},attrs);
		    }
		});
                layer.redraw();
	    }
	    if(this.getJustShowMapLayer()) return;
	    if(!matchData)return;
            this.vectorLayer = layer;
            this.applyVectorMap();
            mapLoadInfo = displayMapUrlToVectorListeners[url];
            if (mapLoadInfo) {
                mapLoadInfo.layer = layer;
                for (let i = 0; i < mapLoadInfo.otherMaps.length; i++) {
                    mapLoadInfo.otherMaps[i].cloneLayer(layer);
                }
                mapLoadInfo.otherMaps = [];
            }
        },
        applyVectorMap: function(force, textGetter, args) {
	},
        getBounds: function() {
	    if(this.map)
		return this.map.getBounds();
	    return null;
	},
    });
}



function RamaddaMapDisplay(displayManager, id, properties) {
    const ID_MAP_SLIDER = "map_slider";    
    const ID_LATFIELD = "latfield";
    const ID_LONFIELD = "lonfield";
    const ID_SIZEBY_LEGEND = "sizebylegend";
    const ID_COLORTABLE_SIDE = "colortableside";
    const ID_SHAPES = "shapes";
    const ID_HEATMAP_ANIM_LIST = "heatmapanimlist";
    const ID_HEATMAP_ANIM_PLAY = "heatmapanimplay";
    const ID_HEATMAP_ANIM_STEP_FORWARD = "heatmapanimstepforward";
    const ID_HEATMAP_ANIM_STEP_BACK = "heatmapanimstepback";    
    const ID_HEATMAP_TOGGLE = "heatmaptoggle";    
    const ID_HTMLLAYER = "htmllayer";
    const ID_TRACK_VIEW = "trackview";

    $.extend(this, {
        showBoxes: true,
        showPercent: false,
        percentFields: null,
        kmlLayer: null,
        kmlLayerName: "",
        geojsonLayer: null,
        geojsonLayerName: "",
        theMap: null,
	layerVisible:true
    });

    


    const SUPER = new RamaddaBaseMapDisplay(displayManager, id, DISPLAY_MAP, properties);
    RamaddaUtil.inherit(this,SUPER);
    addRamaddaDisplay(this);
    this.defineSizeByProperties();
    let shapes = 'square|triangle|downtriangle|circle|plane|star|cross|diamond|x|thinx||lightning|church';
    let myProps = [
	{label:'Map Properties'},
	{p:'strokeWidth',d:1},
	{p:'strokeColor',d:'#000'},
	{p:'strokeOpacity',d:1},
	{p:'fillColor',d:'blue'},
	{p:'fillOpacity',d:0.5},
	{p:'radius',d:5,tt:'Size of the map points'},
	{p:'scaleRadius',ex:'true',tt:'Scale the radius based on # points shown'},
	{p:'scaleRadiusMin',d:1},
	{p:'scaleRadiusMax',d:10},	
	{p:'scaleRadiusMaxPoints',d:5000},
	{p:'radiusList',tt:'comma separated list of count:size',
	 ex:'100:15,200:12,300:10'},
	{p:'maxRadius',ex:'16',d:1000},
	{p:'shape',d:'circle',ex:shapes,tt:'Use shape'},
	{p:'shapeBy',tt:'field to shape by'},
	{p:'shapeByMap',ex:'value1:' + shapes+':label1,value2:...'},
	{p:'defaultShape',ex:shapes},
	{p:'markerIcon',ex:'/icons/...'},
	{p:'iconSize',ex:16},
	{p:'justOneMarker',ex:'true',tt:'This is for data that is all at one point and you want to support selecting points for other displays'},	
	{p:'showPoints',ex:'true',tt:'Also show the map points when showing heatmap or glyphs or vectors'},
	{p:'applyPointsToVectors',d:true,tt:'If false then just show any attached map vectors without coloring them from the points'},
	{p:'bounds',ex:'north,west,south,east',tt:'initial bounds'},
	{p:'gridBounds',ex:'north,west,south,east'},	
	{p:'mapCenter',ex:'lat,lon',tt:'initial position'},
	{p:'zoomLevel',ex:4,tt:'initial zoom'},
	{p:'zoomTimeout',ex:500,tt:'initial zoom timeout delay. set this if the map is in tabs, etc, and not going to the initial zoom'},


	{p:'fixedPosition',ex:true,tt:'Keep the initial position'},
	{p:'linked',ex:true,tt:'Link location with other maps'},
	{p:'linkGroup',ex:'some_name',tt:'Map groups to link with'},
	{p:'initialLocation', ex:'lat,lon',tt:'initial location'},
	{p:'defaultMapLayer',ex:'osm|google.roads|esri.street|google.hybrid|google.terrain|google.satellite|opentopo|esri.topo|usfs|usgs.topo|naip|usgs.imagery|esri.shaded|esri.lightgray|esri.darkgray|esri.terrain|shadedrelief|esri.aeronautical|historic|osm.toner|osm.toner.lite'},
	{p:'extraLayers',tt:'comma separated list of layers to display',
	 ex:'baselayer:goes-visible,baselayer:nexrad,geojson:US States:/resources/usmap.json:fillColor:transparent'},

	{p:'skipZero',ex:'true',tt:'Skip locations that are at 0,0'},

	{p:'doPopup', ex:'false',tt:'Do not show popups'},
	{p:'doPopupSlider', ex:'true',tt:'Do the inline popup that slides down'},
	{p:'popupSliderRight', ex:'true',tt:'Position the inline slider to the right'},	
	{p:'popupSliderStyle', ex:'max-width:300px;overflow-x:auto;',tt:''},	
	{p:'showRegionSelector',ex:true},
	{p:'regionSelectorLabel'},	
	{p:'centerOnFilterChange',d:true,ex:false,tt:'Center map when the data filters change'},
	{p:'centerOnHighlight',ex:true,tt:'Center map when a record is highlighted'},
	{p:'centerOnMarkersAfterUpdate',ex:true,tt:'Always center on the markers'},	
	{p:'zoomLevelOnHighlight',ex:16,tt:'Set the zoom level'},
	{p:'doInitCenter',tt:'Center the maps on initialization'},
	{p:'boundsAnimation',ex:true,tt:'Animate when map is centered'},
	{p:'iconField',ex:'""',tt:'Field id for the image icon url'},
	{p:'rotateField',ex:'""',tt:'Field id for degrees rotation'},
	{p:'rotateScale',d:'1.0',tt:'Scale value to multiply the rotate field value by to get degrees rotation'},		
	{p:'filterBadLocations',ex:'false',d:true,tt:'Do not show records with bad lat/lon'},
	{p:'hideNaN',tt:'If doing color by do not show the points with missing values'},


	{label:'Map GUI'},
	{p:'showTableOfContents',ex:'true',tt:'Show left table of contents'},
	{p:'tocTitle'},
	{p:'tocWidth'},
	{p:'tocZoom',ex:3,tt:'zoom level when clicking on a table of contents item'},
	{p:'tocFields',ex:'',tt:'fields to show in TOC'},
	{p:'tocTemplate',ex:'',tt:'template to show in TOC'},	

	{p:'showMarkersToggle',ex:'true',tt:'Show the toggle checkbox for the marker layer'},
	{p:'showMarkersToggleLabel',ex:'label',tt:'Label to use for checkbox'},
	{p:'showClipToBounds',ex:'true',tt:'Show the clip bounds checkbox'},
	{p:'clipToBounds',ex:'true',tt:'Clip to bounds'},	
	{p:'showMarkers',ex:'false',tt: 'Hide the markers'},
	{p:'acceptEntryMarkers',ex:'true',d:false,tt:'If other maps can add entry markers and boxes'},



	{label:'Map Highlight'},
	{p:'showRecordSelection',ex:'false',d:'true'},
	{p:'highlight',ex:'true',tt:'Show mouse over highlights'},
	{p:'displayDiv',tt:'Div id to show highlights in'},
	{p:'showRecordHighlight',d:true},
	{p:'recordHighlightFeature',ex:'true',tt:'If there is a vector map that is being shown then highlight the map feature instead of drawing a point'},
	{p:'recordHighlightIcon',ex:'/icons/plane.png'},
	{p:'recordHighlightIconSize',d:30},
	{p:'recordHighlightShape',ex:shapes},
	{p:'recordHighlightRadius',ex:'20',tt:'Radius to use to show other displays highlighted record'},
	{p:'recordHighlightStrokeWidth',ex:'2',tt:'Stroke to use to show other displays highlighted record'},
	{p:'recordHighlightStrokeColor',d:'red',tt:'Color to use to show other displays highlighted record'},
	{p:'recordHighlightFillColor',ex:'rgba(0,0,0,0)',tt:'Fill color to use to show other displays highlighted record'},
	{p:'recordHighlightFillOpacity',ex:'0.5',tt:'Fill opacity to use to show other displays highlighted record'},
	{p:'recordHighlightVerticalLine',tt:'Draw a vertical line at the location of the selected record'},
	{p:'highlightColor',ex:'#ccc',tt:''},
	{p:'highlightFillColor',ex:'#ccc',tt:''},	
	{p:'highlightStrokeWidth',ex:'2',tt:''},	
	{p:'unhighlightColor',ex:'#ccc',tt:'Fill color when records are unhighlighted with the filters'},
	{p:'unhighlightStrokeWidth',ex:'1',tt:'Stroke width for when records are unhighlighted with the filters'},
	{p:'unhighlightStrokeColor',ex:'#aaa',tt:'Stroke color for when records are unhighlighted with the filters'},
	{p:'unhighlightRadius',d:-1,ex:'1',tt:'Radius for when records are highlighted with the filters'},

	{label:'Map Collisions'},
	{p:'handleCollisions',ex:true,tt:'Handle point collisions'},
	{p:'showCollisionToggle',ex:true,tt:'Show the toggle checkbox'},
	{p:'collisionFixed',d:false,ex:true,
	 tt:'If true, don\'t show the grouped markers on a click'},
	{p:'collisionPointSize',d:16,tt:'Size of each point. Higher # is more spread out'},
	{p:'collisionDotColor',d:'#fff',tt:'Color of dot drawn at center'},
	{p:'collisionDotOpacity',d:'0.9',tt:'Opacity of dot drawn at center'},	
	{p:'collisionRingColor',d:'#000',tt:'Color of ring'},
	{p:'collisionRingWidth',d:0.25,tt:'Width of ring'},	
	{p:'collisionDotColorOn',d:'blue',tt:'color to use when the collision marker is selected'},
	{p:'collisionDotRadius',d:12,tt:'Radius of dot drawn at center'},
	{p:'collisionScaleDots',ex:true,d:false,tt:'Scale the group dots'},
	{p:'collisionLineColor',ex:'red',tt:'Color of line drawn at center'},
	{p:'collisionLabelTemplate',d:'${count}'},
	{p:'collisionLabelColor',d:'#000'},
	{p:'collisionLabelFontSize',d:'10'},	


	{p:'collisionIcon',ex:'/icons/...',tt:'Use an icon for collisions',canCache:true},
	{p:'collisionIconSize',d:16,ex:'16',canCache:true},
	{p:'collisionTooltip',ex:'${default}',tt:'Tooltip to use for collision dot',canCache:true},


	{label:'Map Lines'},
	{p:'showSegments',ex:'true',tt:'If data has 2 lat/lon locations draw a line'},
	{p:'segmentWidth',d:'1',tt:'Segment line width'},	
	{p:'useGreatCircle',d:false,ex:'true',tt:'use great circle routes for segments'},
	{p:'sizeSegments',d:false,ex:'true',tt:'Size the segments based on record value'},	
	{p:'isPath',ex:'true',tt:'Make a path from the points'},
	{p:'isPathThreshold',ex:'1000',tt:'Make path from the points if # records<threshold'},
	{p:'groupByField',tt:'Field id to group the paths'},	
	{p:'pathWidth',d:'1'},
	{p:'pathColor',ex:'red'},	
	{p:'pathWindowTime',tt:'Show leading dots',ex:'1 day'},
	{p:'pathWindowSize',tt:'Number of records to show as leading dots'},
	{p:'pathWindowStrokeColor'},

	{p:'isTrajectory',ex:'true',tt:'Make a path from the points'},	
	{p:'showPathEndPoint',ex:true},
	{p:'pathEndPointShape',ex:'arrow'},
	{p:'latField1',tt:'Field id for segments'},
	{p:'lonField1',tt:'Field id for segments'},
	{p:'latField2',tt:'Field id for segments'},
	{p:'lonField2',tt:'Field id for segments'},
	{p:'trackUrlField',ex:'field id',tt:'The data can contain a URL that points to data'},

	{label:'Map Labels'},
	{p:'labelTemplate',ex:'${field}',tt:'Display labels in the map'},
	{p:'declutterLabels',d:true},
	{p:'labelRecordTemplate',ex:'${field}',tt:'Apply the template to the records. Use ${recordtemplate} for the labelTemplate'},
	{p:'labelKeyField',ex:'field',tt:'Make a key, e.g., A, B, C, ... based on the value of the key field'},	
	{p:'labelLimit',ex:'1000',tt:'Max number of records to display labels'},
	{p:'labelFontColor',ex:'#000'},
	{p:'labelFontSize',ex:'12px'},
	{p:'labelFontFamily',ex:'\'Open Sans\', Helvetica Neue, Arial, Helvetica, sans-serif'},
	{p:'labelFontWeight',ex:'plain'},
	{p:'labelBackground',ex:'green'},
	{p:'labelStrokeColor',ex:'#000'},
	{p:'labelStrokeWidth',d:1},
	{p:'labelAlign',ex:'l|c|r t|m|b'},
	{p:'labelXOffset',ex:'0'},
	{p:'labelYOffset',ex:'0'},
	{p:'labelOutlineColor',ex:'#fff'},
	{p:'labelOutlineWidth',ex:'0'},
	{p:'labelDeclutterPadding',d:1},
	{p:'labelDeclutterGranularity',d:1},
	{p:'labelDeclutterPixelsPerLine'},
	{p:'labelDeclutterPixelsPerCharacter'},
	{label:'Map Glyphs'},
	{p:'doGridPoints',ex:'true',tt:'Display a image showing shapes or bars',canCache:true},
	{p:'gridWidth',ex:'800',tt:'Width of the canvas'},
	{label:'label glyph',p:'glyph1',ex:'type:label,pos:sw,dx:10,dy:-10,label:field_colon_ ${field}_nl_field2_colon_ ${field2}'},
	{label:'rect glyph', p:'glyph1',ex:'type:rect,pos:sw,dx:10,dy:0,colorBy:field,width:150,height:100'},
	{label:'circle glyph',p:'glyph1',ex:'type:circle,pos:n,dx:10,dy:-10,fill:true,colorBy:field,width:20,baseWidth:5,sizeBy:field'},
	{label:'3dbar glyph', p:'glyph1',ex:'type:3dbar,pos:sw,dx:0,dy:0,height:30,width:6,baseHeight:5,sizeBy:field'},
	{label:'gauge glyph',p:'glyph1',ex:'type:gauge,color:#000,pos:sw,width:50,height:50,dx:10,dy:-10,sizeBy:field,sizeByMin:0'},

	{label:'Hex map, Voronoi, etc'},
	{p:'mapType',ex:'hex or triangle or square or voronoi',tt:'Create a hex or triangle or square or voronoi map'},
	{p:'doHexmap',ex:'true',tt:'Create a hexmap'},
	{p:'doTrianglemap',ex:'true',tt:'Create a triangle map'},		
	{p:'doSquaremap',ex:'true',tt:'Create a square map'},		
	{p:'hexmapUseCount',ex:'true',tt:'Use the record count for the color'},
	{p:'hexmapUseEnum',ex:'true',tt:'Use the value which appears the most'},
	{p:'hexmapLabelTemplate',ex:'${count} ${colorbyvalue}',tt:'For the label'},
	{p:'hexmapShowTotal',ex:'true',tt:'Total the values'},	
	{p:'hexmapMinValue',ex:'1',tt:'If doing averages this is the lower cut off to add to a total'},
	{p:'hexmapMaxValue',ex:'100',tt:'If doing averages this is the upper cut off to add to a total'},
	{p:'hexmapUseFullBounds',d:true,tt:'When filtering is the original fill bounds used'},
	{p:'hexmapPadding',tt:'Percent to bad out the bounding box',d:0.05},
	{p:'hexmapCellSide',tt:'How many on units per side',d:25},
	{p:'hexmapUnits',tt:'Side units',ex:'miles|kilometers|degrees|radians',d:'miles'},
	{p:'hexmapStrokeColor',d:'blue'},
	{p:'hexmapStrokeWidth',d:1},
	{p:'hexmapStrokeOpacity',d:1.0},
	{p:'hexmapStrokeDashstyle',d:'solid'},
	{p:'hexmapFillColor',d:'transparent'},
	{p:'hexmapFillOpacity',d:1.0},	
	{p:'hexmapColorBy',tt:'Field id to color the hexmap by'},
	{p:'hexmapColorTable',tt:'Color table for hexmap'},	
	{p:'hexmapEmptyStrokeColor'},
	{p:'hexmapEmptyStrokeWidth'},
	{p:'hexmapEmptyFillColor'},
	{p:'doVoronoi',ex:'true',tt:'Create  voronoi polygons'},
	{p:'voronoiColorBy',tt:'Field id to color the hexmap by'},
	{p:'voronoiStrokeColor',d:'blue'},
	{p:'voronoiStrokeWidth',d:1},
	{p:'voronoiStrokeOpacity',d:1},	
	{p:'voronoiStrokeDashstyle',d:'solid'},
	{p:'voronoiFillColor',d:'transparent'},
	{p:'voronoiFillOpacity',d:1.0},	
	{p:'voronoiPadding',ex:0.1,tt:'% to pad the bounds, 0-1.0'},
	{label:'Heatmap'},
	{p:'doHeatmap',ex:'true',tt:'Grid the data into an image',canCache:true},
	{p:'hmShowPoints',ex:'true',tt:'Also show the map points'},
	{p:'hmShowReload',ex:'true',tt:''},
	{p:'hmShowGroups',ex:'true',tt:''},
	{p:'hmBounds',ex:'north,west,south,east',tt:''},
	{p:'htmlLayerField'},
	{p:'htmlLayerShape',ex:'barchart|piechart'},	
	{p:'htmlLayerWidth',ex:'30'},
	{p:'htmlLayerHeight',ex:'15'},
	{p:'htmlLayerStyle',ex:'css style'},
	{p:'htmlLayerScale',d:'2:0.75,3:1,4:2,5:3,6:4,7:6',tt:'zoomlevel:scale,...'},
	{p:'htmlLayerPopupLabelField'},
	{p:'htmlLayerMin',tt:'min value for sparkline'},
	{p:'htmlLayerMax',tt:'max value for sparkline'},	
	{p:'htmlLayerFlipYAxis',ex:true},
	{p:'htmlLayerDrawAxisLabels',ex:true},
	{p:'htmlLayerPopupDrawAxisLabels',ex:true},	
	{p:'htmlLayerScaleWithAll',ex:'false',tt:'Scale data values with all or with just the local data'},
	{p:'cellShape',ex:'rect|3dbar|circle|vector'},
	{p:'cellColor',ex:'color'},
	{p:'cellFilled',ex:true},
	{p:'cellSize',ex:'8'},
	{p:'cellSizeH',ex:'20',tt:'Base value to scale by to get height'},
	{p:'cellSizeHBase',ex:'0',tt:'Extra height value'},
	{p:'arrowLength',d:-1,canCache:true},
	{p:'lineWidth',d:1,canCache:true},	
	{p:'angleBy',ex:'field',tt:'field for angle of vectors'},
	{p:'hmOperator',ex:'count|average|min|max'},
	{p:'hmAnimationSleep',ex:'1000'},
	{p:'hmReloadOnZoom',ex:'true'},
	{p:'reloadOnZoom',ex:'true'},	
	{p:'hmGroupByDate',ex:'true|day|month|year|decade',tt:'Group heatmap images by date'}, 
	{p:'hmGroupBy',ex:'field id',tt:'Field to group heatmap images'}, 
	{p:'hmLabelPrefix'},
	{p:'hmShowToggle',ex:true,tt:'Show the toggle checkbox to turn off/on the heatmap'},
	{p:'hmToggleLabel'},
	{p:'boundsScale',ex:'0.1',tt:'Scale up the map bounds'},
	{p:'hmFilter',ex:'average5|average9|average25|gauss9|gauss25',tt:'Apply filter to image'},
	{p:'hmFilterPasses',ex:'1'},
	{p:'hmFilterThreshold',ex:'1'},
	{p:'hmCountThreshold',ex:'1'},
    ];
    
    myProps.push({label:'Canvas'});
    myProps.push(...RamaddaDisplayUtils.getCanvasProps());
    myProps.push(...RamaddaDisplayUtils.sparklineProps);


    displayDefineMembers(this, myProps, {
        mapBoundsSet: false,
        features: [],
        myMarkers: {},
        mapEntryInfos: {},
	tracks:{},
	checkFinished: function() {
	    return true;
	},
        initDisplay: function() {
            SUPER.initDisplay.call(this);
            let _this = this;
	    let legendSide = this.getProperty('sizeByLegendSide');
	    if(legendSide) {
		let legend = HU.div([ATTR_ID,this.domId(ID_SIZEBY_LEGEND)]);
		if(legendSide=='top') {
		    this.jq(ID_HEADER0).append(legend);
		} else if(legendSide=='left') {
		    this.jq(ID_LEFT).append(legend);
		} else if(legendSide=='right') {
		    this.jq(ID_RIGHT).append(legend);
		} else if(legendSide=='bottom') {
		    this.jq(ID_BOTTOM).append(legend);
		} else {
		    console.log('Unknown legend side:' + legendSide);
		}
	    }
	    this.startProgress();
        },

        checkLayout: function() {
            if (!this.map) {
                return;
            }
            let d = this.jq(ID_MAP);
            if (d.width() ==0) return;
	    //Wait a bit so the dom settles down
	    setTimeout(()=>{
		this.checkLayoutInner();
	    },1000);
	},

        checkLayoutInner: function() {
            let d = this.jq(ID_MAP);
            this.map.getMap().updateSize();
            if (d.width() > 0 && this.lastWidth != d.width()) {
                this.lastWidth = d.width();
            }

	    if(!this.setMapLocationAndZoom && this.mapParams) {
		this.setMapLocationAndZoom = true;
		if(this.mapParams.initialZoom>=0) {
		    this.map.zoomTo(this.mapParams.initialZoom);
		}
		if(this.mapParams.initialLocation) {
		    let loc = MapUtils.createLonLat(this.mapParams.initialLocation.lon, this.mapParams.initialLocation.lat);
		    this.map.setCenter(loc);
		}
	    }
	    //And for some reason we need a little more delay for the final redraw
	    setTimeout(()=>{
		this.map.redraw();
	    },500);
        },

	handlePopup: function(feature, popup) {
	    if(!this.trackUrlField) return;
	    let func = ()=>{
		if(feature.record) {
		    if(this.tracks[feature.record.getId()]) {
			this.removeTrack(feature.record);
		    } else {
			let url = feature.record.getValue(this.trackUrlField.getIndex());
			$.getJSON(url, data=>{this.loadTrack(feature.record, data)}).fail(err=>{console.log("url failed:" + url +"\n" + err)});
		    }
		}
	    };
	    this.jq(ID_TRACK_VIEW).click(func);
	    this.jq(ID_TRACK_VIEW+"_1").click(func);	    
	},
	macroHook: function(record, token,value) {
	    if(!this.trackUrlField) {
		return null;
	    }
	    if(token.tag!=this.trackUrlField.getId()) {
		return null;
	    }
	    if(String(value).trim().length==0) return "";
	    this.currentPopupRecord = record;
	    let haveTrack = this.tracks[record.getId()]!=null;
	    let label =haveTrack?"Remove track":(token.attrs["label"] ||  "View track");
	    return SPACE + HU.span([ATTR_CLASS,"ramadda-clickable",ATTR_ID,this.domId(ID_TRACK_VIEW)],label);
	}, 
	getRecordUrlHtml: function(attrs, field, record) {
	    this.currentPopupRecord = record;
	    if(!this.trackUrlField || this.trackUrlField.getId()!=field.getId()) {
		return SUPER.getRecordUrlHtml.call(this, attrs, field, record);
	    }
	    let value = record.getValue(field.getIndex());
	    let haveTrack = this.tracks[record.getId()]!=null;
	    let label = haveTrack?"Remove track":(attrs[field.getId()+".label"] || "View track");
	    return  HU.span([ATTR_CLASS,"ramadda-clickable",ATTR_ID,this.domId(ID_TRACK_VIEW+"_1")],label);
	},
	removeTrack:function(record) {
	    if(this.tracks[record.getId()]) {
		this.map.removePolygon(this.tracks[record.getId()]);
		this.tracks[record.getId()] = null;
	    }
	    this.jq(ID_TRACK_VIEW).html("View track");
	    this.jq(ID_TRACK_VIEW+"_1").html("View track");
	    let item = this.jq(ID_LEFT).find(HU.attrSelect(RECORD_ID,record.getId()));
	    item.removeClass("display-map-toc-item-on");
	},
	loadTrack: function(record, data) {
            let newData = makePointData(data, null,this,"");
	    let points = RecordUtil.getPoints(newData.getRecords(),{});
	    let feature = this.markers?this.markers[record.getId()]:null;
	    let item = this.jq(ID_LEFT).find(HU.attrSelect(RECORD_ID,record.getId()));
	    record.trackData = newData;
	    item.addClass("display-map-toc-item-on");
	    try {
		record.setLocation(points[0].y, points[0].x);
		let loc =  MapUtils.createLonLat(points[0].x, points[0].y);
		loc = this.map.transformLLPoint(loc);
		if(feature)
		    feature.move(loc);
	    } catch(err) {
		console.log(err);
	    }

	    let bounds = {};
	    let attrs = {
		strokeColor:this.getStrokeColor("blue"),
		strokeWidth:this.getStrokeWidth(1),
		fillColor:this.getProperty("fillColor") ||'transparent',
	    };
            let polygon = this.map.addPolygon("", "", points, attrs);
	    polygon.record = record;
	    this.tracks[record.getId()]=polygon;
	    if(polygon.geometry) {
		this.map.zoomToExtent(polygon.geometry.getBounds());
	    }
	    this.map.closePopup();
	    setTimeout(()=>{
		this.getDisplayManager().notifyEvent(DisplayEvent.dataSelection, this, {data:newData});
	    },100);
	},
	applyToFeatureLayers:function(func) {
	    if(this.myFeatureLayer) func(this.myFeatureLayer);
	    if(this.myFeatureLayerNoSelect) func(this.myFeatureLayerNoSelect);
	},
	addFeatures:function(features,noSelect) {
	    let madeNewOne = false;
	    let layer = noSelect?this.myFeatureLayerNoSelect:this.myFeatureLayer;
	    if(!layer) {
		if(debugit && ycnt!=this.myycnt) {
		    console.trace("addFeatures",this.myName);
		}
		if(noSelect) 
		    layer = this.myFeatureLayerNoSelect = this.map.createFeatureLayer("Map Features NS",false);		
		else
		    layer = this.myFeatureLayer = this.map.createFeatureLayer("Map Features",true);
		if(Utils.isDefined(this.layerVisible)) {
		    layer.setVisibility(this.layerVisible);
		}
		if(this.getProperty("showMarkersToggle") && !this.getProperty("markersVisibility", true)) {
		    this.applyToFeatureLayers(layer=>{layer.setVisibility(false);});
		}
		this.myFeatures= [];
	    }
	    layer.addFeatures(features);
	    features.forEach(feature=>{
		feature.layer = layer;
		this.myFeatures.push(feature);
	    });
	},

	removeFeature: function(feature) {
	    if(feature) {
		this.applyToFeatureLayers(layer=>{
		    layer.removeFeatures([feature]);
		});
	    }
	},

	removeExtraLayers: function() {
	    try {
		this.extraLayers.every(layer=>{
		    layer.destroy();
		    this.map.removeLayer(layer,true);
		    return true;
		});
	    } catch(exc) {
		console.log(exc);
	    }
	    this.extraLayers = [];
	    this.heatmapLayers = [];
	    this.voronoiLayer=null;
	    this.hexmapLayer=null;
	},

	getMyMapLayers:function() {
	    return [this.heatmapLayers,this.voronoiLayer,this.hexmapLayer];
	},

	toString: function() {
	    return "displaymap";
	},
	deleteDisplay: function() {
	    if(debugit)
		console.log("delete:" + this.myName);
	    this.getDisplayManager().removeDisplay(this);
	    this.removeFeatures();
	    this.displayDeleted = true;
            this.map.getMap().events.unregister("updatesize", this,this.updatesizeFunc);
            this.map.getMap().events.unregister("moveend", this,this.moveendFunc);
            this.map.getMap().events.unregister("zoomend", this,this.zoomendFunc);	    	    
            let pointData = this.getPointData();
	    if(pointData) {
		pointData.removeFromCache(this);
	    }
	},

	removeFeatures: function() {
	    this.removeFeatureLayer();
	    this.removeExtraLayers();
	},


	setVisible: function(visible) {
	    this.layerVisible = visible;
	    let show = true;
	    if(this.jq("showMarkersToggle").length>0) {
		show = this.jq("showMarkersToggle").is(":checked");
	    }
	    if(show) {
		if(this.myFeatureLayer) {
		    this.myFeatureLayer.setVisibility(visible);
		    //		    console.log("setvisible:" + visible+" "+ this.myFeatureLayer.getVisibility());
		}
		if(this.myFeatureLayerNoSelect) {
		    this.myFeatureLayerNoSelect.setVisibility(visible);
		}
	    }
	    //TODO: have my own labelLayer
	    if(this.map.labelLayer)
		this.map.labelLayer.setVisibility(visible);
	    this.extraLayers.forEach(layer=>{
		layer.setVisibility(visible);
	    });

	},

	removeFeatureLayer: function() {
	    if(debugMapTime) {
		console.log('start removeFeatureLayer');
		console.time('removeFeatureLayer');
	    }
	    if(this.myFeatureLayer) {
		this.myFeatureLayer.destroy();
		this.map.removeLayer(this.myFeatureLayer,true);
		this.myFeatureLayer = null;
	    }
	    if(this.myFeatureLayerNoSelect) {
		this.myFeatureLayerNoSelect.destroy();
		this.map.removeLayer(this.myFeatureLayerNoSelect,true);
		this.myFeatureLayerNoSelect = null;
	    }	    
	    if(this.labelFeatures) {
		this.map.labelLayer.removeFeatures(this.labelFeatures,{silent:true});
		this.labelFeatures = null;
		this.jq("legendid").html("");
	    }
	    if(debugMapTime)
		console.timeEnd('removeFeatureLayer');
	    this.myFeatures= null;
	},

        initMapParams: function(params) {
	    SUPER.initMapParams.call(this,params);
	    if(this.getDoPopupSlider() || this.getPopupSliderRight()) {
		params.doPopupSlider = true;
		if(this.getPopupSliderRight()) {
		    params.popupSliderRight = true;
		}
	    }
	},
	initMap: function(map) {
	    if(!this.getShowMarkers(this.getProperty("markersVisibility", true))) {
		map.getMarkersLayer().setVisibility(false);
	    }
	    let boundsAnimation = this.getProperty("boundsAnimation");
	    if(boundsAnimation) {
		this.didAnimationBounds = false;
                let animationBounds = boundsAnimation.split(",");
                if (animationBounds.length == 4) {
		    let pause = parseFloat(this.getProperty("animationPause","1000"));
		    HU.callWhenScrolled(this.domId(ID_MAP),()=>{
			if(this.didAnimationBounds) {
			    return;
			}
			this.didAnimationBounds = true;
			let a = animationBounds;
			let b = MapUtils.createBounds(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]),parseFloat(a[0]));
			this.map.animateViewToBounds(b);
		    },pause);
		}
            }
	},
        createMap: function() {
	    SUPER.createMap.call(this);
            let _this = this;
	    if(!this.getShowMarkers(this.getProperty("markersVisibility", true))) {
		this.map.getMarkersLayer().setVisibility(false);
	    }

            if (this.doDisplayMap()) {
                this.map.setDefaultCanSelect(false);
            }
            this.map.initMap(false);
            this.map.addRegionSelectorControl(function(bounds) {
		_this.propagateEvent(DisplayEvent.mapBoundsChanged, {"bounds": bounds,    "force": true});
            },true);
	    this.map.popupHandler = (feature,popup) =>{
		this.handlePopup(feature, popup);
	    };
	    this.map.addFeatureSelectHandler(feature=>{
		if(debugPopup) console.log("\tdisplaymap: featureSelectHandler");
		let didSomething= false;
		let record = feature.record;
		if(feature.collisionInfo)  {
		    if(debugPopup) console.log("has collisioninfo");
		    return feature.collisionInfo.dotSelected(feature);
		}
		if(record) {
		    this.propagateEventRecordSelection({record:record});
		    this.propagateFilterFields(record);
		    //		    didSomething= true;
		}

		if(record && !this.getMap().getDoPopup() && this.getShowRecordSelection()) {
		    if(debugPopup) console.log("highlighting point");
		    this.highlightPoint(record.getLatitude(),record.getLongitude(),true,false);
		    //		    didSomething= true;
		}

		if(record && this.getProperty("shareSelected")) {
		    let idField = this.getFieldById(null,ATTR_ID);
		    if(idField) {
			ramaddaDisplaySetSelectedEntry(record.getValue(idField.getIndex()),this.getDisplayManager().getDisplays(),this);
		    }
		    if(debugPopup) console.log("\tdisplaymap: share selected");
		    //		    didSomething= true;
		}
		if(didSomething)
		    this.lastFeatureSelectTime = new Date();
		return false;
	    });

            this.map.addFeatureHighlightHandler((feature, highlight)=>{
		let record = feature.record;
		if(record) {
		    if(this.lastHighlightedRecord) {
			let args = {highlight:false,record: this.lastHighlightedRecord};
			this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, this, args);
			if (this.getAnimationEnabled()) {
			    this.getAnimation().handleEventRecordHighlight(this, args);
			}
			this.lastHighlightedRecord = null;
		    }
		    if(highlight) {
			this.lastHighlightedRecord = record;
		    }
		    let args = {highlight:highlight,record: record};
		    this.getDisplayManager().notifyEvent(DisplayEvent.recordHighlight, this, args);
		    if (this.getAnimationEnabled()) {
			this.getAnimation().handleEventRecordHighlight(this, args);
		    }
		}

	    });

	    this.map.highlightBackgroundColor=this.getProperty("highlighBackgroundColor","#fffeec");
	    if(this.getProperty("addEntryMarkers")) {
		this.map.setDoPopup(true);
	    } else {
		this.map.setDoPopup(this.getProperty("doPopup",true));
	    }
	    this.createTime = new Date();

            this.map.addClickHandler(this.domId(ID_LONFIELD), this
				     .domId(ID_LATFIELD), null, this);

            this.map.getMap().events.register("updatesize", this, this.updatesizeFunc=()=>{
		if(!this.callingUpdateSize) {
		    _this.updateHtmlLayers();
		}
            });

	    //register the events in a bit
	    setTimeout(()=>{
		this.registerEvents();
	    },1000);



	    
	    let boundsAnimation = this.getProperty("boundsAnimation");
	    if(boundsAnimation) {
		this.didAnimationBounds = false;
                let animationBounds = boundsAnimation.split(",");
                if (animationBounds.length == 4) {
		    let pause = parseFloat(this.getProperty("animationPause","1000"));
		    HU.callWhenScrolled(this.domId(ID_MAP),()=>{
			if(_this.didAnimationBounds) {
			    return;
			}
			_this.didAnimationBounds = true;
			let a = animationBounds;
			let b = MapUtils.createBounds(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]),parseFloat(a[0]));
			_this.map.animateViewToBounds(b);
		    },pause);
		}
            }


            let currentFeatures = this.features;
            this.features = [];
            for (let i = 0; i < currentFeatures.length; i++) {
                this.addFeature(currentFeatures[i]);
            }
	    if(this.getProperty("displayEntries",true)) {
		let entries = this.getDisplayManager().collectEntries();
		for (let i = 0; i < entries.length; i++) {
                    let pair = entries[i];
                    this.handleEventEntriesChanged(pair.source, pair.entries);
		}
	    }


	    if(this.getProperty("addEntryMarkers")) {
		this.getDisplayEntry(entry=>{
		    if(!entry) {
			console.log("failed to get entry");
			return;
		    }
		    entry.getChildrenEntries(entries=>{
			entries.forEach(entry=>{
			    if(!entry.hasLocation()) return;
			    let lonlat = MapUtils.createLonLat(entry.getWest(), entry.getNorth());
			    let html = "<b>" + entry.getName()+"</b>";
			    if(entry.isImage()) {
				html+="<br>" + HU.image(entry.getImageUrl(),["width","200px"]);
			    }
			    this.map.addMarker(entry.getId(), lonlat, entry.getIconUrl(),  "", html, null, 16);
			});
		    });
		});

	    }

            if (this.layerEntries) {
                let selectCallback = function(feature,layer,event) {
                    _this.handleLayerSelect(layer);
                }
                let unselectCallback = function(feature,layer,event) {
                    _this.handleLayerUnselect(layer);
                }
                let toks = this.layerEntries.split(",");
                for (let i = 0; i < toks.length; i++) {
                    let tok = toks[i];
                    let url = RamaddaUtil.getUrl("/entry/show?output=shapefile.kml&entryid=" + tok);
                    this.map.addKMLLayer("layer", url, true, selectCallback, unselectCallback);
                    //TODO: Center on the kml
                }
            }

	    for(let markerIdx=1;true;markerIdx++) {
		let marker = this.getProperty("marker" + markerIdx);
		if(!marker) break;
		this.map.addMarkerEmbed(marker);
	    }
        },
	registerEvents:function() {
            this.getMap().getMap().events.register("zoomend", this, this.zoomendFunc = ()=>{
		if(this.callingUpdateUI) return;
		if(this.lastUpdateTime) {
		    let diff = (new Date().getTime())-this.lastUpdateTime.getTime()
		    if(diff<2000) {
			return
		    }
		}
		if(this.debugZoom) {
		    console.log("level:" + this.getMap().getMap().getZoom());
		}
		//		console.log(this.getLogLabel()+" zoomend:"+this.callingUpdateUI+" " + this.lastUpdateTime);
		if(this.pointLevelRange || this.glyphLevelRange) {
		    this.checkLevelRange([this.myFeatureLayer],true);
		}		

                this.mapBoundsChanged();
		this.checkHeatmapReload();
		this.updateHtmlLayers();
		if(!this.haveAddPoints) {
		    return;
		}

		if(this.getHandleCollisions()) {
		    if(this.lastZoom == this.map.getZoom()) {
			return;
		    }
		    //Wait a bit
		    if(this.lastCollisionTimeout) {
			clearTimeout(this.lastCollisionTimeout);
		    }

		    //		    console.log(this.getLogLabel()+" setting up collision timeout");
		    this.lastTimeout = setTimeout(()=>{
			this.haveCalledUpdateUI = false;
			//			console.log(this.getLogLabel()+" calling updateUI from handleCollisions");
			this.updateUI();
			this.lastCollisionTimeout = null;
		    },1000);
		}
		//		console.log(this.getLogLabel()+" finished zoomend");
            });
            this.map.getMap().events.register("moveend", this, this.moveendFunc = ()=> {
		if(this.map.doingPopup) return;
                this.mapBoundsChanged();
		this.checkHeatmapReload();
            });
	},
        getBounds: function() {
	    if(this.map)
		return this.map.getBounds();
	    return null;
	},
        mapFeatureSelected: function(layer) {
            if (!this.getPointData()) {
                return;
            }
            this.map.onFeatureSelect(layer);
            if (!Utils.isDefined(layer.feature.record)) {
                return;
            }
            this.propagateEventRecordSelection({
                record: layer.feature.record
            });
        },
	showVectorLayer:true,
	toggleVectorLayer: function() {
	    this.showVectorLayer = !this.showVectorLayer;
            if(this.vectorLayer != null) {
		this.vectorLayer.setVisibility(this.showVectorLayer);
	    }
	    this.haveCalledUpdateUI = false;
	    this.updateUI();
	},
        doDisplayMap: function() {
            if (!this.getShowLayers()) return false;
            if (!this.getProperty("displayAsMap", true)) return false;
            if(this.getProperty("kmlLayer") ||
	       this.getProperty("shapefileLayer") ||
	       this.getProperty("geojsonLayer") ||
	       this.displayingMapLayer) {
		if(this.getShowLayers()) {
		    return this.showVectorLayer;
		}
	    }
        },
        cloneLayer: function(layer) {
            let _this = this;
            this.map.hideLoadingImage();
            layer = layer.clone();
            let features = layer.features;
            let clonedFeatures = [];
            for (let j = 0; j < features.length; j++) {
                feature = features[j];
                feature = feature.clone();
                if (feature.style) {
                    oldStyle = feature.style;
                    feature.style = {};
                    for (let a in oldStyle) {
                        feature.style[a] = oldStyle[a];
                    }
                }
                feature.layer = layer;
                clonedFeatures.push(feature);
            }
            layer.removeAllFeatures();
            this.map.getMap().addLayer(layer);
            layer.addFeatures(clonedFeatures);
            this.vectorLayer = layer;
            this.applyVectorMap();
            this.map.addSelectCallback(layer, this.doDisplayMap(), function(feature,layer,event) {
                _this.mapFeatureSelected(layer);
            });
        },
        handleEventPointDataLoaded: function(source, pointData) {
        },
        handleEventFieldsSelected: function(source, fields) {
	    if(this.getProperty("selectedFieldIsColorBy") && fields.length>0) {
		this.colorByFieldChanged(fields[0]);
	    }
        },
        handleLayerSelect: function(layer) {
	    if(debugPopup) this.logMsg("handleLayerSelect");
            let args = this.layerSelectArgs;
            if (!this.layerSelectPath) {
                if (!args) {
                    this.map.onFeatureSelect(layer);
                    return;
                }
                //If args was defined then default to search
                this.layerSelectPath = "/search/do";
            }
            let url = RamaddaUtil.getUrl(this.layerSelectPath);
            if (args) {
                let toks = args.split(",");
                for (let i = 0; i < toks.length; i++) {
                    let tok = toks[i];
                    let toktoks = tok.split(":");
                    let urlArg = toktoks[0];
                    let layerField = toktoks[1];
                    let attrs = layer.feature.attributes;
                    let fieldValue = null;
                    for (let attr in attrs) {
                        let attrName = "" + attr;
                        if (attrName == layerField) {
                            let attrValue = null;
                            if (typeof attrs[attr] == 'object' || typeof attrs[attr] == 'Object') {
                                let o = attrs[attr];
                                attrValue = o["value"];
                            } else {
                                attrValue = attrs[attr];
                            }
                            url = HU.appendArg(url, urlArg, attrValue);
                            url = url.replace("${" + urlArg + "}", attrValue);
                        }
                    }
                }
            }
            url = HU.appendArg(url, "output", "json");
            let entryList = new EntryList(this.getRamadda(), url, null, false);
            entryList.doSearch(this);
            this.getEntryList().showMessage("Searching", HU.div([ATTR_STYLE, HU.css("margin","20px")], this.getWaitImage()));
        },
        getEntryList: function() {
            if (!this.entryListDisplay) {
                let props = {
                    showMenu: true,
                    showTitle: true,
                    showDetails: true,
                    layoutHere: false,
                    showForm: false,
                    doSearch: false,
                };
                let id = this.getUniqueId("display");
                this.entryListDisplay = new RamaddaEntrylistDisplay(this.getDisplayManager(), id, props);
                this.getDisplayManager().addDisplay(this.entryListDisplay);
            }
            return this.entryListDisplay;
        },
        entryListChanged: function(entryList) {
            let entries = entryList.getEntries();
            this.getEntryList().entryListChanged(entryList);
        },
        handleLayerUnselect: function(layer) {
            this.map.onFeatureUnselect(layer);
        },
        addMapLayer: function(source, props) {
            let _this = this;
            let entry = props.entry;
            if (!this.addedLayers) this.addedLayers = {};
            if (this.addedLayers[entry.getId()]) {
                let layer = this.addedLayers[entry.getId()];
                if (layer) {
                    this.map.removeKMLLayer(layer);
                    this.addedLayers[entry.getId()] = null;
                }
                return;
            }

            let type = entry.getType().getId();
            if (type == "geo_shapefile" || type == "geo_geojson") {
                let bounds = MapUtils.createBounds(entry.getWest(), entry.getSouth(), entry.getEast(), entry.getNorth());
                if (bounds.left < -180 || bounds.right > 180 || bounds.bottom < -90 || bounds.top > 90) {
                    bounds = null;
                }

                let selectCallback = function(feature,layer,event) {
		    if(debugPopup) this.logMsg("selectCallback");
                    _this.handleLayerSelect(layer);
                }
                let unselectCallback = function(feature,layer,event) {
                    _this.handleLayerUnselect(layer);
                }
                let layer;
                if (type == "geo_geojson") {
                    let url = entry.getRamadda().getEntryDownloadUrl(entry);
                    layer = this.map.addGeoJsonLayer(this.getProperty('geojsonLayerName','Map'), url, this.doDisplayMap(), selectCallback, unselectCallback, null, null, true);
                } else {
                    let url = RamaddaUtil.getUrl("/entry/show?output=shapefile.kml&entryid=" + entry.getId());
                    layer = this.map.addKMLLayer(entry.getName(), url, true, selectCallback, unselectCallback, null, null, true);
                }
                this.addedLayers[entry.getId()] = layer;
                return;
            }

            let baseUrl = entry.getAttributeValue("base_url");
            if (!Utils.stringDefined(baseUrl)) {
                console.log("No base url:" + entry.getId());
                return;
            }
            let layer = entry.getAttributeValue("layer_name");
            if (layer == null) {
                layer = entry.getName();
            }
            this.map.addWMSLayer(entry.getName(), baseUrl, layer, false);
        },
        mapBoundsChanged: function() {
            let bounds = this.map.getMap().calculateBounds().transform(this.map.sourceProjection,
								       this.map.displayProjection);
	    this.propagateEvent(DisplayEvent.mapBoundsChanged, {"bounds": bounds,    "force": false});
	    if(this.clipToView || this.getClipToBounds()) {
		if(this.lastUpdateTime) {
		    let now = new Date();
		    if(now.getTime()-this.lastUpdateTime.getTime()>1000) {
			this.haveCalledUpdateUI = false;
			this.clipBounds = true;
			this.updatingFromClip = true;
			this.updateUI();
		    }
		}
	    }

        },
        addFeature: function(feature) {
            this.features.push(feature);
            feature.line = this.map.addPolygon("lines_" +
					       feature.source.getId(), RecordUtil
					       .clonePoints(feature.points), null);
        },
        getContentsDiv: function() {
	    let style="";
	    if(!this.getProperty("showInnerContents",true)) {
		style+="display:none;";
	    }		

            let html =  HU.div([ATTR_STYLE,style,ATTR_CLASS, "display-inner-contents", ID,
				this.domId(ID_DISPLAY_CONTENTS)], "");
	    return html;
        },
	addHighlightMarker:function(marker) {
	    if(!this.highlightMarkers) this.highlightMarkers=[];
	    this.highlightMarkers.push(marker);
	},
	removeHighlight: function() {
	    if(this.highlightMarkers) {
		this.highlightMarkers.forEach(marker=>{
		    this.removeFeature(marker);
		});
		this.highlightMarkers = null;
	    }
	},
	highlightPoint: function(lat,lon,highlight,andCenter,dontRemove,record) {
	    if(!this.getMap()) return;
	    if(!dontRemove) {
		this.removeHighlight();
	    }
	    if(!this.getShowRecordHighlight()) return;
	    if(highlight) {
		let point = MapUtils.createLonLat(lon,lat);
                let attrs = {
                    pointRadius: parseFloat(this.getProperty("recordHighlightRadius", +this.getPropertyRadius(6)+8)),
                    stroke: true,
                    strokeColor: this.getRecordHighlightStrokeColor(),
                    strokeWidth: parseFloat(this.getProperty("recordHighlightStrokeWidth", 2)),
		    fillColor: this.getProperty("recordHighlightFillColor", "#ccc"),
		    fillOpacity: parseFloat(this.getProperty("recordHighlightFillOpacity", 0.5)),
                };
		if(this.getProperty("recordHighlightUseMarker",false)) {
		    let size = +this.getProperty("recordHighlightRadius", +this.getRadius(24));
		    this.addHighlightMarker(this.getMap().createMarker("pt-" + featureCnt, point, null, "pt-" + featureCnt,null,null,size));
		} else 	if(this.getProperty("recordHighlightVerticalLine",false)) {
		    let points = [];
                    points.push(MapUtils.createPoint(lon,0));
		    points.push(MapUtils.createPoint(lon,80));
                    this.addHighlightMarker(this.getMap().createPolygon(id, "highlight", points, attrs, null));
		} else {
		    attrs.graphicName = this.getRecordHighlightShape();
		    let markerIcon = this.getRecordHighlightIcon();
		    let marker;
		    if(markerIcon) {
			let size = this.getRecordHighlightIconSize();
			marker = this.map.createMarker("highlight", point, markerIcon, "highlight",null,null, size,null,null,attrs);
		    } else {
			marker = this.getMap().createPoint("highlight", point, attrs);
		    }
		    this.addHighlightMarker(marker);
		    
		}
		if(this.highlightMarkers) {
		    this.highlightMarkers.forEach(marker=>{
			if(record) {
			    marker.record=record;
			    marker.textGetter=this.getTextGetter();
			}
		    });
		    this.addFeatures(this.highlightMarkers);
		}
		if(andCenter && this.getCenterOnHighlight()) {
		    this.getMap().setCenter(point);
		    if(this.getZoomLevelOnHighlight()) {
			this.getMap().setZoom(this.getZoomLevelOnHighlight());
		    }
		}
	    }
	},


        handleEventEntryMouseover: function(source, args) {
            if (!this.map) {
                return;
            }
            id = args.entry.getId() + "_mouseover";
            attrs = {
                lineColor: "red",
                fillColor: "red",
                fillOpacity: 0.5,
                lineOpacity: 0.5,
                doCircle: true,
                lineWidth: 1,
                fill: true,
                circle: {
                    lineColor: "black"
                },
                polygon: {
                    lineWidth: 4,
                }
            }
            this.addOrRemoveEntryMarker(id, args.entry, true, attrs);
        },
        handleEventEntryMouseout: function(source, args) {
            if (!this.map) {
                return;
            }
            id = args.entry.getId() + "_mouseover";
            this.addOrRemoveEntryMarker(id, args.entry, false);
        },
        handleEventAreaClear: function() {
            if (!this.map) {
                return;
            }
            this.map.clearRegionSelector();
        },
	propagateFilterFields: function(record) {
	    let fields = this.getFieldsByIds(null, this.getProperty("filterFieldsToPropagate"));
	    fields.map(field=>{
		let args = {
		    fieldId:field.getId(),
		    value:record.getValue(field.getIndex())
		};
		this.propagateEvent(DisplayEvent.filterChanged, args);
	    });
	},	    
	doneLocation:false,
        handleClick: function(theMap, event, lon, lat) {
	    if(event.shiftKey && event.metaKey) {
		if(!this.doneLocation) {
		    if(Utils.isAnonymous()) {
			console.log("latitude,longitude");
		    } else {
			console.log("latitude,longitude,address,city,state,zip,country");
		    }
		    this.doneLocation = true;
		}
		let loc = lat+"," + lon;
		if(Utils.isAnonymous()) {
                    let point= this.map.addPoint("", MapUtils.createLonLat(lon, lat));
		    Utils.copyToClipboard(loc+"\n");
		    console.log(loc);
		} else  {
		    let url = RamaddaUtil.getUrl("/map/getaddress?latitude=" + lat +"&longitude=" + lon);
		    $.getJSON(url, data=>{
			if(data.length==0) {
			    console.log(loc+",,,,,");
			} else {
			    let comp = data[0];
			    let point= this.map.addPoint("", MapUtils.createLonLat(lon, lat),null,comp.address);
			    console.log(loc+"," + comp.address+"," + comp.city +"," + comp.state +"," + comp.zip +"," + comp.country); 
			}
		    }).fail(err=>{
			console.log(loc+",,,,,");
		    });
		}
		return;
	    }

	    let debug = false;
	    if(debug)   console.log("click");
	    if(this.lastFeatureSelectTime) {
		let diff = new Date().getTime()-this.lastFeatureSelectTime.getTime();
		this.lastFeatureSelectTime = null;
		if(diff<1000) {
		    if(debug)   console.log("\tclick: lastFeatureSelectTime:" + diff)
		    return;
		}
	    }

	    if(event.shiftKey) {
		if(Utils.isAnonymous()) return;
		let text = prompt("Marker text", "");
		if(!text) return;
		let url = RamaddaUtil.getUrl("/metadata/addform?entryid=" + this.getProperty("entryId")+"&metadata_type=map_marker&metadata_attr1=" +
					     encodeURIComponent(text) +"&metadata_attr2=" + lat +"," + lon); 
		window.location = url;
		if(debug) console.log("\tclick:shift");
		return
	    }

            if (!this.map) {
		if(debug)    console.log("\tclick:no map")
                return;
            }

            if (this.doDisplayMap()) {
		if(debug)    console.log("\tclick: no display map")
                return;
            }

            let justOneMarker = this.getJustOneMarker(false);
            if(justOneMarker) {
		if(debug)    console.log("\tclick: just one")
                let pointData = this.getPointData();
                if(pointData) {
                    if(pointData.handleEventMapClick(this, this, lon, lat)) {
			this.startProgress('Reloading data...');
			this.getMap().showLoadingImage();
		    }
		    this.getDisplayManager().notifyEvent("mapClick", this, {lat:lat,lon:lon});
                }
            }


	    if(!this.records) {
		if(debug)    console.log("\tclick: no records")
		return;
	    }
	    let indexObj = [];
            let closest = RecordUtil.findClosest(this.records, lon, lat, indexObj);
            if (!closest) {
		if(debug)    console.log("\tclick: no closest")
		return;
	    }
	    if(debug)    console.log("\tclick: handling")
	    this.propagateEventRecordSelection({record: closest});

	    //If we are highlighting a record then change the marker
	    if(this.highlightMarkers) {
		this.highlightPoint(closest.getLatitude(),closest.getLongitude(),true,false);
	    }
	    
	    this.propagateFilterFields(closest);
        },

        getPosition: function() {
            let lat = $("#" + this.domId(ID_LATFIELD)).val();
            let lon = $("#" + this.domId(ID_LONFIELD)).val();
            if (lat == null)
                return null;
            return [lat, lon];
        },

        haveInitBounds: false,
        setInitMapBounds: function(north, west, south, east) {
            if (!this.map) return;
            if (this.haveInitBounds) return;
	    this.lastUpdateTime = new Date();
            this.haveInitBounds = true;
	    if(this.getProperty("doInitCenter",true)) {
		this.map.centerOnMarkers(MapUtils.createBounds(west, south, east,
							       north),true);
	    }
        },

        sourceToEntries: {},
        handleEventEntriesChanged: function(source, entries) {
            if (!this.map) {
                return;
            }
            //debug
            if (source == this.lastSource) {
                this.map.clearSelectionMarker();
            }
            if ((typeof source.forMap) != "undefined" && !source.forMap) {
                return;
            }
            let oldEntries = this.sourceToEntries[source.getId()];
            if (oldEntries != null) {
                for (let i = 0; i < oldEntries.length; i++) {
                    let id = source.getId() + "_" + oldEntries[i].getId();
                    this.addOrRemoveEntryMarker(id, oldEntries[i], false);
                }
            }

            this.sourceToEntries[source.getId()] = entries;
            let markers = MapUtils.createLayerMarkers("Markers",{});
            let lines =  MapUtils.createLayerVector("Lines", {});
            let north = -90,
                west = 180,
                south = 90,
                east = -180;
            let didOne = false;
            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let id = source.getId() + "_" + entry.getId();
                let mapEntryInfo = this.addOrRemoveEntryMarker(id, entries[i], true);
                if (entry.hasBounds()) {
                    if (entry.getNorth() > 90 ||
                        entry.getSouth() < -90 ||
                        entry.getEast() > 180 ||
                        entry.getWest() < -180) {
                        console.log("bad bounds on entry:" + entry.getName() + " " +
				    entry.getNorth() + " " +
				    entry.getSouth() + " " +
				    entry.getEast() + " " +
				    entry.getWest());
                        continue;
                    }

                    north = Math.max(north, entry.getNorth());
                    south = Math.min(south, entry.getSouth());
                    east = Math.max(east, entry.getEast());
                    west = Math.min(west, entry.getWest());
                    didOne = true;
                }
            }
            let bounds = (didOne ? MapUtils.createBounds(west, south, east, north) : null);
            //debug                    this.map.centerOnMarkers(bounds, true);
        },
        handleEventEntrySelection: function(source, args) {
            if (!this.map) {
                return;
            }
            let _this = this;
            let entry = args.entry;
            if (entry == null) {
                this.map.clearSelectionMarker();
                return;
            }
            let selected = args.selected;

            if (!entry.hasLocation()) {
                return;
            }
        },
        addOrRemoveEntryMarker: function(id, entry, add, args) {
	    if(!this.getAcceptEntryMarkers()) {
		return
	    }
            if (!args) {
                args = {};
            }
            let dflt = {
                lineColor: entry.lineColor,
                fillColor: entry.lineColor,
                lineWidth: entry.lineWidth,
                doCircle: false,
                doRectangle: this.showBoxes,
                fill: false,
                fillOpacity: 0.75,
                pointRadius: 12,
                polygon: {},
                circle: {}
            }
            dfltPolygon = {}
            dfltCircle = {}
            $.extend(dflt, args);
            if (!dflt.lineColor) dflt.lineColor = "blue";

            $.extend(dfltPolygon, dflt);
            if (args.polygon)
                $.extend(dfltPolygon, args.polygon);
            $.extend(dfltCircle, dflt);
            if (args.circle)
                $.extend(dfltCircle, args.circle);

            let mapEntryInfo = this.mapEntryInfos[id];
            if (!add) {
                if (mapEntryInfo != null) {
                    mapEntryInfo.removeFromMap(this.map);
                    this.mapEntryInfos[id] = null;
                }
            } else {
                if (mapEntryInfo == null) {
                    mapEntryInfo = new MapEntryInfo(entry);
                    this.mapEntryInfos[id] = mapEntryInfo;
                    if (entry.hasBounds() && dflt.doRectangle) {
                        let attrs = {};
                        mapEntryInfo.rectangle = this.map.addRectangle(id,
								       entry.getNorth(), entry.getWest(), entry
								       .getSouth(), entry.getEast(), attrs);
                    }
                    let latitude = entry.getLatitude();
                    let longitude = entry.getLongitude();
                    if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) {
                        return;
                    }
                    let point = MapUtils.createLonLat(longitude, latitude);

                    if (dflt.doCircle) {
                        attrs = {
                            pointRadius: dfltCircle.pointRadius,
                            stroke: true,
                            strokeColor: dfltCircle.lineColor,
                            strokeWidth: dfltCircle.lineWidth,
                            fillColor: dfltCircle.fillColor,
                            fillOpacity: dfltCircle.fillOpacity,
                            fill: dfltCircle.fill,
                        };
                        mapEntryInfo.circle = this.map.addPoint(id, point, attrs);
                    } else {
                        mapEntryInfo.marker = this.map.addMarker(id, point, entry.getIconUrl(), "", this.getEntryHtml(entry));
                    }
                    if (entry.polygon) {
                        let points = []
                        for (let i = 0; i < entry.polygon.length; i += 2) {
                            points.push(MapUtils.createPoint(entry.polygon[i + 1], entry.polygon[i]));
                        }
                        let attrs = {
                            strokeColor: dfltPolygon.lineColor,
                            strokeWidth: Utils.isDefined(dfltPolygon.lineWidth) ? dfltPolygon.lineWidth : 2
                        };
                        mapEntryInfo.polygon = this.map.addPolygon(id, entry.getName(), points, attrs, mapEntryInfo.marker);
                    }
                    let _this = this;
                    if (mapEntryInfo.marker) {
                        mapEntryInfo.marker.entry = entry;
                        mapEntryInfo.marker.ramaddaClickHandler = function(marker) {
                            _this.handleMapClick(marker);
                        };
                        if (this.handledMarkers == null) {
                            this.map.centerToMarkers();
                            this.handledMarkers = true;
                        }
                    }
                }
                return mapEntryInfo;
            }
        },
        handleMapClick: function(marker) {
            if (this.selectedMarker != null) {
                this.getDisplayManager().handleEventEntrySelection(this, {
                    entry: this.selectedMarker.entry,
                    selected: false
                });
            }
            this.getDisplayManager().handleEventEntrySelection(this, {
                entry: marker.entry,
                selected: true
            });
            this.selectedMarker = marker;
        },
	fakeLocations: function(){
	    return  this.getTheLinkFields() && this.getLinkFeature();
	},
	getTheLinkFields:function() {
	    let tmpLinkField=this.getFieldById(null,this.getProperty("linkField"));
	    let linkFields=this.getFieldsByIds(null,this.getProperty("linkFields"));	    
	    if(linkFields.length==0 && tmpLinkField!=null) linkFields=[tmpLinkField];
	    if(linkFields.length==0) linkFields=null;
	    return linkFields
	},

        applyVectorMap: function(force, textGetter, args) {
	    let debug = false;
            if (!force && this.vectorMapApplied) {
                return;
            }
	    let points = this.myPoints || this.myFeatures;
            if (!this.doDisplayMap() || !this.vectorLayer || !points) {
                return;
            }

	    if(!this.getApplyPointsToVectors()) {
		return;
	    }
	    
	    if(!args) args = {};
	    if(debug) this.logMsg("applyVectorMap");
	    if(!textGetter) textGetter  = this.textGetter;

	    let linkFields=this.getTheLinkFields();
	    let linkFeature=this.getLinkFeature();
            let features = this.vectorLayer.features.slice();
            let allFeatures = features.slice();
	    this.recordToFeature = {};
	    let debugFeatureLinking = this.getDebugFeatureLinking();
	    debug = debugFeatureLinking;
	    //	    debug=true
	    points.forEach(point=>{
		let record = point.record;
		if(!record) return;
		let feature = record.getDisplayProperty(this.getId(),"feature");
		if(feature)  this.recordToFeature[record.getId()] = feature;
	    });

	    if(linkFeature && linkFields) {
		linkFeature = linkFeature.toLowerCase();
		let recordMap = {};
		points.forEach(p=>{
		    let record = p.record;
		    if(record) {
			let tuple = record.getData();
			let value='';
			linkFields.forEach(linkField=>{
			    value+= tuple[linkField.getIndex()];
			});
			value  = value.toString().trim();
			record.linkValue = value;
			if(recordMap[value]) {
			    let other = recordMap[value];
			    //Get the highest value
			    let v1 = record.getDisplayProperty(this.getId(),'colorByValue');
			    let v2 = other.getDisplayProperty(this.getId(),'colorByValue');			    
			    if(Utils.isDefined(v1) && Utils.isDefined(v2)) {
				if(v1>v2) {
				    recordMap[value] = record;
				}
			    }

			} else {
			    recordMap[value] = record;
			}
		    }
		});
		if(debug) {
		    let values = Object.keys(recordMap);
		    console.log('map data/feature linking: data fields:' + linkFields.map(f=>{return f.getId()}));
		    if(points.length>0) {
			console.dir('all fields:' +points[0].record.fields.map(f=>{
			    return f.getId()
			}));
		    }
		    window.displayMapSamples = values;
		    console.log('to view all record values do: console.log(displayMapSamples)\nvalues 0-10:'+ values.slice(0,10));
		    console.log('looking for map feature:' + linkFeature);
		    console.log('#map features:' + features.length+
				' #records:' + points.length +
				' #unique record values:'+ values.length);



		}

		let errorCnt = 0;
		let foundCnt = 0;		
		window.displayMapMissingFeatures=[];
		features.forEach((feature,idx)=>{
		    let attrs = feature.attributes;
		    let ok = false;
		    for (let attr in attrs) {
			let _attr = String(attr).toLowerCase();
			if(linkFeature!=_attr) continue;
			ok  = true;
			let value = this.map.getAttrValue(attrs, attr);
			if(!Utils.isDefined(value)) {
			    console.log("\tno map feature attribute value");
			    continue;
			}
			value = value.toString().trim();
			feature.linkValue = value;
			record = recordMap[value];
			if(record) {
			    let v =record.getDisplayProperty(this.getId(),'colorByValue');
			    foundCnt++;
			    if(debugFeatureLinking&& foundCnt<3)
				console.log("%cfound record:" + value+": " + record.getId(),'color: green;');
			    this.recordToFeature[record.getId()] = feature;
			} else {
			    if(debugFeatureLinking) {
				window.displayMapMissingFeatures.push(attrs);
				errorCnt++;
				if(errorCnt<3) 
				    console.log("%ccould not find record with map value:" + value +":",'color: red;');
				if(errorCnt<2) { 
				    console.log('feature:',attrs);
				}
			    }
			}
		    }
		    if(!ok && idx==0) console.log("No map feature found:" + linkFeature,'attrs:',attrs);
		});
		if(debugFeatureLinking) {
		    console.log('features matched: '+ foundCnt + ' not matched:' + errorCnt);
		    if(errorCnt>0)
			console.log('to view all missing map features do: console.log(displayMapMissingFeatures)');
		    
		}
	    }



	    let j=0;
	    features.forEach((feature,idx)=>{
		feature.wasPruned = feature.pruned;
		feature.pruned = false;
		feature.newStyle=null;
		if(feature.style) {
		    feature.style.display ="inline-block";
		}
		feature.featureIndex = j++;
		feature.featureMatched = false;
		feature.pointCount = 0;
		feature.circles = [];
		if(feature.style)feature.style.balloonStyle = null;
	    });

            this.vectorMapApplied = true;

	    let maxExtent = null;
	    let doCount = this.getProperty("colorByCount",false);
	    let matchedFeatures = [];
	    let seen = {};
	    let maxCnt = -1;
	    let minCnt = -1;


	    points.forEach((point,idx)=>{
                if (point.style && point.style.display == "none") {
		    return;
		}
		let record = point.record;
                let center = point.center;
		let tmp = {index:-1,maxExtent: maxExtent};
		let matchedFeature = this.recordToFeature[record.getId()];
		if(matchedFeature) {
		    if (matchedFeature.geometry) {
			if (maxExtent === null) {
			    maxExtent = MapUtils.createBounds();
			}
			maxExtent.extend(matchedFeature.geometry.getBounds());
		    } else {
			//console.log("no geometry:" + matchedFeature.CLASS_NAME);
		    }
		}  else {
		    if(center) {
			matchedFeature = this.findContainingFeature(features, center,tmp,false);
		    }
		}
		if(!matchedFeature) {
		    return;
		}
		matchedFeature.featureMatched = true;
		record.setDisplayProperty(this.getId(),"feature",matchedFeature);
		if(!point.colorByColor && point.hasColorByValue && isNaN(point.colorByValue)) {
		    return;
		}
		maxExtent = tmp.maxExtent;
		if(!seen[matchedFeature.featureIndex]) {
		    seen[matchedFeature.featureIndex] = true;
		    matchedFeatures.push(matchedFeature); 
		}
		matchedFeature.circles.push(point);
		matchedFeature.record = record;
		matchedFeature.textGetter=textGetter;
		if(doCount) {
		    matchedFeature.pointCount++;
		    maxCnt = maxCnt==-1?matchedFeature.pointCount:Math.max(maxCnt, matchedFeature.pointCount);
		    minCnt = minCnt==-1?matchedFeature.pointCount:Math.min(minCnt, matchedFeature.pointCount);
		} else {
		    if(tmp.index>=0)
			features.splice(tmp.index, 1);
		}
	    });


	    if(!doCount) {
		for(let i=0;i<matchedFeatures.length;i++) {
		    let matchedFeature = matchedFeatures[i];
		    style = matchedFeature.style;
		    if (!style) style = {
			"stylename": "from display",
		    };
		    delete style.display;
		    let newStyle = {};
		    $.extend(newStyle,style);
		    let theCircle;
		    let max=0;
		    matchedFeature.circles.forEach((c,idx)=>{
			if(idx==0 || c.colorByValue>max) {
			    max = c.colorByValue;
			    theCircle=c;
			}
		    });
		    if(!theCircle) theCircle=matchedFeature.circles[0]
		    $.extend(newStyle, theCircle.style);
		    matchedFeature.newStyle=newStyle;
		    matchedFeature.popupText = theCircle.text;
		    matchedFeature.dataIndex = i;
		}
	    }


	    let strokeWidth = this.getVectorLayerStrokeWidth();
	    let strokeColor = this.getVectorLayerStrokeColor();
	    let fillOpacity  =this.getVectorLayerFillOpacity();

	    let prune = this.getPruneFeatures();
	    if(doCount) {
		let colors = this.getColorTable(true);
		if (colors == null) {
		    colors = Utils.ColorTables.grayscale.colors;
		}
		let range = maxCnt-minCnt;
		let labelSuffix = this.getProperty("doCountLabel","points");
		for (let j = 0; j < features.length; j++) {
		    let feature = features[j];
		    let percent = range==0?0:(feature.pointCount - minCnt) /range;
                    let index = parseInt(percent * colors.length);
                    if (index >= colors.length) index = colors.length - 1;
                    else if (index < 0) index = 0;
		    let color= colors[index];
		    let style = feature.style;
		    if (!style) style = {
			"stylename": "from display",
		    };
		    let newStyle = {};
		    $.extend(newStyle,style);
		    $.extend(newStyle,{
			fillColor: color,
			"fillOpacity": fillOpacity,
			"strokeWidth": strokeWidth,
			"strokeColor": strokeColor,
		    });

		    if(feature.pointCount==0) {
			//TODO: what to do with no count features?
			if(prune === true) {
			    newStyle.display = "none";
			}
		    }
		    feature.newStyle = newStyle;
		    feature.dataIndex = j;
		    feature.popupText = HU.div([],feature.pointCount +SPACE + labelSuffix);
		}
		this.displayColorTable(colors, ID_COLORTABLE, minCnt,maxCnt,{});
	    } else {
		if(prune) {
		    for (let i = 0; i < features.length; i++) {
			let feature = features[i];
			if(feature.featureMatched) {
			    continue;
			}
			let style = feature.style;
			if (!style) style = {
			    "stylename": "from display"
			};
			let newStyle = {};
			$.extend(newStyle,style);
			newStyle.display= "none";
			feature.pruned = true;
			feature.newStyle = newStyle;
		    }
		}
	    }



	    let redrawCnt = 0;
	    allFeatures.forEach((feature,idx)=>{
		if(!feature.newStyle) feature.newStyle={};
		if(feature.wasPruned && !feature.pruned ||
		   !feature.style ||
		   (feature.newStyle.display && 
		    feature.newStyle.display=="none" &&
		    feature.newStyle.display!=feature.style.display) ||
		   feature.style.fillColor!=feature.newStyle.fillColor) {
		    feature.style = feature.newStyle;
		    feature.style.strokeWidth=strokeWidth;
		    feature.style.strokeColor=strokeColor;		    
		    feature.style.fillOpacity=fillOpacity;

		    if(!feature.style.fillColor) {
			feature.style.fillColor = "rgba(230,230,230,0.5)";
			feature.style.strokeColor = "rgba(200,200,200,0.5)";
		    }
		    redrawCnt++;
		    this.vectorLayer.drawFeature(feature);
		    
		}
		feature.newStyle = null;
	    });

	    
	    /** TODO?
		if (!args.dontSetBounds && maxExtent && !this.hadInitialPosition && this.getCenterOnFilterChange(true)) {
		this.map.zoomToExtent(maxExtent, true);
		}
		if(!this.getProperty("fixedPosition",false))  {
		this.hadInitialPosition    = false;
		}
	    */


	    if(!this.hadInitialPosition && !this.applyMapVectorZoom) {
		this.applyMapVectorZoom = true;
		if(!this.hadUrlArgumentMapCenter && !this.hadUrlArgumentZoom &&
		   this.getProperty("doInitCenter",true)) {
		    this.map.zoomToLayer(this.vectorLayer);
		}
	    }




        },
	findContainingFeature: function(features, center, info,debug) {
	    //	    debug=true;
	    let matchedFeature = null;
            for (let j = 0; j < features.length; j++) {
                let feature = features[j];
                let geometry = feature.geometry;
                if (!geometry) {
		    if(debug) console.log("\tno geometry")
                    continue;
                }
                bounds = geometry.getBounds();
                if (!bounds.contains(center.x, center.y)) {
		    //		    if(debug) console.log("\tnot in bounds:" + bounds)
                    continue;
                }
		if(debug) console.log("\tfindContainingFeature:" + center.x+" " + center.y);
                if (geometry.components) {
		    if(debug) console.log("\thas components:" +geometry.components.length);
                    geometry.components.every(comp=> {
                        bounds = comp.getBounds();
                        if (!bounds.contains(center.x, center.y)) {
			    if(debug) console.log("\t\tnot contain:" + bounds + " " + comp.CLASS_NAME);
			    return true;
                        }
			if(!comp.containsPoint) {
			    if(debug) console.log("\t\tunknown geometry:" + comp.CLASS_NAME);
			    return true;
			}
			if(debug) console.log("\t\tcontains:" + comp.containsPoint(center));
                        if (comp.containsPoint(center)) {
                            matchedFeature = feature;
			    if (feature.geometry) {
				if (info.maxExtent === null) {
				    info.maxExtent = MapUtils.createBounds();
				}
				info.maxExtent.extend(feature.geometry.getBounds());
			    }
                            info.index = j;
			    return false;
                        }
			return true;
                    });
		}
		if(matchedFeature) return matchedFeature;
                if (!geometry.containsPoint) {
                    if(debug && !geometry.components) 
			console.log("unknown geometry:" + geometry.CLASS_NAME);
                    continue;
                }
                if (geometry.containsPoint(center)) {
		    if (info.maxExtent === null) {
			info.maxExtent = MapUtils.createBounds();
		    }
		    info.maxExtent.extend(geometry.getBounds());
                    matchedFeature = feature;
                    info.index = j;
                    break;
                }
	    }
	    return matchedFeature;
	},
        needsData: function() {
            return true;
        },
	animationStart:function(animation) {
	    if(this.myFeatures) {
                for (let i = 0; i < this.myFeatures.length; i++) {
                    let point = this.myFeatures[i];
                    point.style.display = 'none';
                }
	    }
            if (this.map.circles)
                this.map.circles.redraw();

	},
        handleDateRangeChanged: function(source, prop) {
	    this.getAnimation().setDateRange(prop.minDate, prop.maxDate);
	    this.applyDateRange();
	},
       	animationApply: function(animation) {
	    SUPER.animationApply.call(this,animation,true);
	    this.applyDateRange();
	},
       	applyDateRange: function() {
	    let animation = this.getAnimation();
            let windowStart = animation.begin.getTime();
            let windowEnd = animation.end.getTime();
            let atLoc = {};
	    if(this.myFeatures) {
		for (let i = 0; i < this.myFeatures.length; i++) {
                    let point = this.myFeatures[i];
                    if (point.date < windowStart || point.date > windowEnd) {
			point.style.display = 'none';
			continue;
                    }
                    if (atLoc[point.location]) {
			let other = atLoc[point.location];
			if (other.date < point.date) {
                            atLoc[point.location] = point;
                            other.style.display = 'none';
                            point.style.display = 'inline';
			} else {
                            point.style.display = 'none';
			}
			continue;
                    }
                    atLoc[point.location] = point;
                    point.style.display = 'inline';
		}
	    }

	    this.applyToFeatureLayers(layer=>{layer.redraw();});
            this.applyVectorMap(true, this.textGetter);
	},
        showAllPoints: function() {
	    if(this.myFeatures) {
		for (let i = 0; i < this.myFeatures.length; i++) {
		    let line = this.myFeatures[i];
		    line.style.display = 'inline';
		}
		if (this.map.lines)
		    this.map.lines.redraw();
	    }
	    this.applyToFeatureLayers(layer=>{layer.redraw();});
            this.applyVectorMap(true);
        },

	colorByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("colorBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({fieldChanged:true});
	},
	sizeByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("sizeBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({fieldChanged:true});
	},
	dataFilterChanged: function(args) {
	    if(!args) args = {};
	    this.vectorMapApplied  = false;
	    this.updateUI({source:args.source, dataFilterChanged:true, dontSetBounds:true,  reload:true,callback: (records)=>{
		if(args.source=="animation") return;
		if(!this.getCenterOnFilterChange()) return;
		if(this.getShowPoints() && records && records.length) {
		    //If we have our own features then just zoom to that layer and return
		    if(this.myFeatureLayer?.features?.length) {
			this.map.zoomToLayer(this.myFeatureLayer);
			return
		    }
		    this.map.centerOnMarkers(null, false, true);
		    return;
		}
		if (this.vectorLayer && this.showVectorLayer) {
		    this.map.zoomToLayer(this.vectorLayer,1.2);
		} else if(this.lastImageLayer) {
		    this.map.zoomToLayer(this.lastImageLayer);
		} else {
		    //true -> Just markers
		    if(records && records.length)
			this.map.centerOnMarkers(null, false, true);
		}
	    }});
	},
	requiresGeoLocation: function() {
	    if(this.fakeLocations()) return false;
	    if(this.shapesField && this.shapesTypeField) return false;
	    if((this.getLinkFields()||this.getProperty("linkField")) && this.getLinkFeature()) return false;
	    return true;
	},
	addFilters: function(filters) {
	    SUPER.addFilters.call(this, filters);
	    if(this.getProperty("showBoundsFilter")) {
		filters.push(new BoundsFilter(this));
	    }
	},
	getHeader2:function() {
	    let html = SUPER.getHeader2.call(this);
	    if(this.getProperty("showClipToBounds")) {
		this.clipToView=false;
		html =  HU.div([ATTR_STYLE,HU.css("display","inline-block","cursor","pointer","padding","1px","border","1px solid rgba(0,0,0,0)"), ATTR_TITLE,"Clip to view", ID,this.domId("clip")],HU.getIconImage("fa-map"))+SPACE2+ html;
	    }


	    if(this.getProperty("showMarkersToggle")) {
		let dflt = this.getProperty("markersVisibility", true);
		html += HU.checkbox(this.domId("showMarkersToggle"),[ATTR_ID,this.domId("showMarkersToggle")],dflt,
				    this.getProperty("showMarkersToggleLabel","Show Markers")) +SPACE2;
	    }

	    if(this.getShowBaseLayersSelect()) {
		html+=this.getBaseLayersSelect();
	    }

	    if(this.getProperty("showVectorLayerToggle",false)) {
		html += HU.checkbox("",[ATTR_ID,this.domId("showVectorLayerToggle")],!this.showVectorLayer) +" " +
		    this.getProperty("showVectorLayerToggleLabel","Show Points") +SPACE4;
	    }
	    html += HU.div([ATTR_CLASS,CLASS_HEADER_SPAN,ATTR_ID,this.domId("locations")]);
	    return html;
	},
	locationMenuCnt:0,
	addLocationMenu:function(url,data) {
	    let html = "";
	    let idx = this.locationMenuCnt++;
	    let label = data.label || data.name;
	    if(!label) {
		label = Utils.makeLabel(url.replace(/^.*[\\\/]/, '').replace(/\.[^\.]+$/,"").replace("_"," "));
	    }
	    html += HU.div([ATTR_CLASS,"ramadda-menu-button ramadda-clickable ramadda-map-button bold",
			    ATTR_ID,this.domId("location_" + idx)],"View " + (label)) +SPACE;
	    this.map.appendToolbar(html);
	    //	    this.jq("locations").append(html);
	    let _this = this;
	    this.jq("location_" + idx).click(function() {
		let inner = "";
		let locations = [];
		if(data.features) {
		    data.features.forEach(feature=>{
			let name = feature.properties.NAME || feature.properties.name;
			locations.push({name:name,geometry:feature.geometry});
		    });
		} else {
		    locations = data.locations;
		}
		locations.sort((a,b)=>{
		    return a.name.localeCompare(b.name);
		});
		locations.forEach((loc,idx)=>{
		    if(Utils.isDefined(loc.latitude)) {
			inner+=HU.div([ATTR_CLASS,"ramadda-clickable ramadda-hoverable display-map-location",
				       "latitude",loc.latitude,
				       "longitude",loc.longitude], loc.name);
		    } else if(Utils.isDefined(loc.north)) {
			inner+=HU.div([ATTR_CLASS,"ramadda-clickable ramadda-hoverable display-map-location", "north",loc.north,"west",loc.west,"south",loc.south,"east",loc.east], loc.name);

		    } else if(Utils.isDefined(loc.geometry)) {
			inner+=HU.div([ATTR_CLASS,"ramadda-clickable ramadda-hoverable display-map-location", "index",idx], loc.name);
		    }
		});
		inner = HU.div([ATTR_ID,_this.domId("locationmenu"),ATTR_STYLE,HU.css("max-height","200px","overflow-y","auto","padding","5px")],inner);
		let dialog = HU.makeDialog({content:inner,my:"left top",at:"left bottom",anchor:$(this),draggable:false,header:false});
		_this.jq("locationmenu").find(".ramadda-clickable").click(function() {
		    if(_this.locationFeatures) {
			_this.locationFeatures.forEach(feature=>{
			    _this.map.getHighlightLinesLayer().removeFeatures([feature]);
			});
		    }
		    _this.locationFeatures = [];
		    if($(this).attr("longitude")) {
			let point = MapUtils.createLonLat(+$(this).attr("longitude"),+$(this).attr("latitude"));
			_this.map.zoomTo(9);
			_this.map.setCenter(point);
		    } else if($(this).attr("north")) {
			_this.map.setViewToBounds(new RamaddaBounds(+$(this).attr("north"),+$(this).attr("west"),+$(this).attr("south"),+$(this).attr("east")));
		    } else {
			let geometry = locations[$(this).attr("index")].geometry;
			let type = geometry.type;
			let shapes = geometry.coordinates;
			let style = {
			    strokeColor: "blue",
			    fillColor:'rgba(0,0,255,0.10)',
			    strokeWidth: 2};
			if(type=="MultiPolygon") {
			    for(let i=0;i<shapes.length;i++) {
				let c2 = shapes[i];
				for(let j=0;j<c2.length;j++) {
				    _this.locationFeatures.push(_this.createFeature(c2[j],null,null,style));
				}
			    }
			} else if(type=="Polygon") {
			    for(let i=0;i<shapes.length;i++) {
				_this.locationFeatures.push(_this.createFeature(shapes[i],null,null,style));
			    }
			} else {
			    console.log("Unknown geometry:" + type);
			}
			_this.map.centerOnFeatures(_this.locationFeatures);
		    }
		    dialog.remove();
		});
	    });
	},
	initHeader2:function() {
            SUPER.initHeader2.call(this);

	    let _this = this;
	    this.initBaseLayersSelect();


	    if(this.getProperty('showTogglePath',false)) {
		let cbx = HU.checkbox('',[ATTR_ID,this.domId('togglepath')],this.getIsPath(),
				      'Show track');
		this.jq(ID_HEADER2_PREPREFIX).append(HU.span([ATTR_STYLE,'padding-right:10px;'],cbx));
		this.jq('togglepath').click(function() {
		    let on = $(this).is(':checked');
		    _this.setProperty('isPath',on);
		    _this.setProperty('showPoints',!on);			
		    _this.haveCalledUpdateUI = false;
		    _this.updateUI({fieldChanged:true});
		});

	    }

	    this.getProperty("locations","").split(",").forEach(url=>{
		url  =url.trim();
		if(url.length==0) return;
		let show = url.startsWith("show:");
		if(show) url = url.substring("show:".length);
		if(!url.startsWith("/") && !url.startsWith("http")) {
		    url = RamaddaUtil.getCdnUrl("/resources/" +url);			
		}
		if(url.endsWith('geojson')) {
		    this.map.addGeoJsonLayer('location layer', url, false, null, null, {}, null);
		    return;
		}
		let success = (data) =>{
		    data=JSON.parse(data);
		    this.addLocationMenu(url, data);
		    if(show) {
			let attrs = {
			    pointRadius:this.getProperty('locationRadius',4),
			    fillColor:this.getProperty('locationFillColor','blue'),
			    strokeWidth:this.getProperty('locationStrokeWidth',0),
			    strokeColor:this.getProperty('locationStrokeColor','blue'),			    
			}

			data.locations.forEach(loc=>{
			    let point = MapUtils.createLonLat(loc.longitude, loc.latitude);
			    this.map.addPoint('', point,attrs,loc.name);
			});
		    }
		};
		let fail = err=>{console.log("Error loading location json:" + url+"\n" + err);}
		Utils.doFetch(url, success,fail,null);	    
	    });


	    this.jq("showMarkersToggle").change(function() {
		let visible = $(this).is(':checked');
		_this.applyToFeatureLayers(layer=>{layer.setVisibility(visible);})
	    });
	    this.jq("showVectorLayerToggle").change(function() {
		_this.toggleVectorLayer();
	    });
	    
	    this.jq("clip").click(function(e){
		_this.clipToView = !_this.clipToView;
		if(!_this.clipToView) {
		    $(this).css("border","1px solid rgba(0,0,0,0)");
		} else {
		    $(this).css("border","1px solid #aaa");
		}
		_this.haveCalledUpdateUI = false;
		_this.updateUI();
	    });
	},

	handleNoData: function(pointData,reload) {
	    this.jq(ID_PAGE_COUNT).html("");
            this.addPoints([],[],[]);
	    this.setMessage(this.getNoDataMessage());

	},
	createFeature:function(polygon,record, textGetter, style){
	    if(!style) {
		if(this.baseStyle) {
		    this.baseStyle = $.extend({}, MapUtils.getVectorStyle('default'));
		    $.extend(this.baseStyle,{
			strokeColor: this.getProperty("vectorLayerStrokeColor","#000"),
			fillColor:this.getProperty("vectorLayerFillColor","#ccc"),
			fillOpacity:this.getProperty("vectorLayerFillOpacity",0.10),
			strokeWidth: this.getProperty("vectorLayerStrokeWidth",1),
			cursor:'pointer'
		    });
		}
		style = this.baseStyle;
	    }


	    let sitePoints = [];
	    polygon.forEach(pair=>{
		let point = MapUtils.createPoint(pair[0],pair[1]);
		let projPoint = this.map.transformLLPoint(point);
		sitePoints.push(projPoint);
	    });
	    let linearRing = MapUtils.createLinearRing(sitePoints);
	    let geometry = MapUtils.createPolygon([linearRing]);
	    let polygonFeature = MapUtils.createVector(geometry, null, style);
	    this.map.getHighlightLinesLayer().addFeatures([polygonFeature]);
	    polygonFeature.record = record;
	    polygonFeature.textGetter = textGetter;
	    return polygonFeature;
	},
	loadShapes: function(records) {
	    if(this.coordinateFeatures) {
		this.map.getHighlightLinesLayer().removeFeatures(this.coordinateFeatures);
	    }
	    let textGetter = (f)=>{
		if(f.record) {
                    return  this.getRecordHtml(f.record, null, this.getTooltip('${default}'));
		}
		return "NONE";
	    };
	    this.coordinateFeatures = [];
	    records.forEach((r,idx)=>{
		let type = r.getValue(this.shapesTypeField.getIndex());		
		let shapesString= r.getValue(this.shapesField.getIndex());
		let shapes = JSON.parse(shapesString);
		if(type=="MultiPolygon") {
		    for(let i=0;i<shapes.length;i++) {
			let c2 = shapes[i];
			for(let j=0;j<c2.length;j++) {
			    this.coordinateFeatures.push(this.createFeature(c2[j],r,textGetter));
			}
		    }
		} else if(type=="Polygon") {
		    for(let i=0;i<shapes.length;i++) {
			this.coordinateFeatures.push(this.createFeature(shapes[i],r,textGetter));
		    }
		} else {
		    console.log("Unknown geometry:" + type);
		}
	    });

	},	    
	toggleTrack:function(record,item) {
	    let marker = this.markers?this.markers[record.getId()]:null;
	    if(this.tracks[record.getId()]) {
		if(item)item.removeClass("display-map-toc-item-on");
		this.map.removePolygon(this.tracks[record.getId()]);
		this.tracks[record.getId()] = null;
		if(item) {
		    item.attr(ATTR_TITLE,"Click to view; Double-click to view track");
		}
	    } else {
		if(item) {
		    item.addClass("display-map-toc-item-on");
		    item.attr(ATTR_TITLE,"Click to view; Double-click to remove track");
		}
		let url = record.getValue(this.trackUrlField.getIndex());
		if(url!="")
		    $.getJSON(url, data=>{this.loadTrack(record, data)}).fail(err=>{console.log("url failed:" + url +"\n" + err)});
	    }
	    this.map.setCenter(MapUtils.createLonLat(record.getLongitude(),record.getLatitude()));
	},
	makeToc:function(records) {
	    let urlField  =  this.getFieldById(null,this.getProperty("urlField"));
	    let fields = this.getFieldsByIds(null,this.getTocFields(this.getProperty("labelField","name")));
	    if(!fields || fields.length==0) fields = this.getFieldsByType(null,"string");
	    let template = this.getTocTemplate();
	    let html='';
	    let title = this.getTocTitle(this.getProperty('tableOfContentsTitle',''));
	    if(template) {
		let clazz = "ramadda-clickable  display-map-toc-item ramadda-noselect";
		records.forEach((record,idx)=>{
		    let label = this.applyRecordTemplate(record,this.getDataValues(record),null, template);
		    html+=HU.div([ATTR_CLASS,clazz,RECORD_INDEX,idx], label);
		});
	    } else   if(fields && fields.length>0) {
		let iconField = this.getFieldById(null, this.getProperty("iconField"));
		let doTable=this.getProperty('tocTable',true);
		if(doTable) {
		    html+='<table  width=100%><tr>'
		    if(urlField) html+='<td></td>';
		    fields.forEach(f=>{
			html+='<td style=\'font-weight:bold;\'>' + f.getLabel() +'</td>';
		    });
		    html+='</tr>';
		}
		let clazz = "ramadda-clickable  display-map-toc-item ramadda-noselect";
		records.forEach((record,idx)=>{
		    let title = "View record";
		    if(this.trackUrlField) title = "Click to view; Double-click to view track";
		    let values=[];
		    values.push(...fields.map(f=>{
			return f.getValue(record);
		    }));

		    let value;
		    if(doTable) {
			let width = Math.floor(100/values.length)+'%';
			value = Utils.wrap(values,HU.open('td',[ATTR_CLASS,clazz,RECORD_ID,record.getId(),RECORD_INDEX,idx,'x'+ATTR_WIDTH,width]),'</td>');
			if(urlField) {
			    let url = urlField.getValue(record);
			    if(Utils.stringDefined(url)) {
				value = HU.td([ATTR_STYLE,HU.css('width','10px')],
					      HU.href(url,HU.getIconImage('fas fa-link',null,[ATTR_STYLE,'font-size:8pt;']),['target','_link']))+value;
			    }
			}
			html+=HU.tag('tr',[], value);
		    } else {
			value = Utils.join(values,' ');
			if(!iconField) {
			    clazz+=" ramadda-nav-list-link ";
			} else {
			    value = HU.getIconImage(iconField.getValue(record,icon_blank16),["width",16]) + SPACE + value;
			}
			if(urlField) {

			    let url = urlField.getValue(record);
			    if(Utils.stringDefined(url)) {
				value=HU.href(url,HU.getIconImage('fas fa-link',null,[ATTR_STYLE,'font-size:8pt;']),['target','_link']) + HU.space(1) +value;
			    }
			}
			html+= HU.span([ATTR_TITLE, title, ATTR_CLASS,clazz,RECORD_ID,record.getId(),RECORD_INDEX,idx], value);
		    }
		});
		if(doTable) {
		    html+='</table>';
		}
	    }

	    if(html) {
		let height = this.getProperty('height', this.getProperty('mapHeight', 300));
		height='calc(' +HU.getDimension(height)+' - 1em)';
		let style = HU.css('height',height,'max-height',height,'overflow-y','auto');
		if(this.getTocWidth()) {
		    style+=HU.css("min-width",this.getTocWidth());
		}
		html = HU.div([ATTR_CLASS, "display-map-toc",ATTR_STYLE,style,ATTR_ID, this.domId("toc")],html);
		if(title) html = HU.center(HU.b(title)) + html;
		this.jq(ID_LEFT).html(html);
		let _this = this;
		let items = this.jq(ID_LEFT).find(".display-map-toc-item");
		if(this.getProperty('showTableOfContentsTooltip')) 
		    this.makeTooltips(items,records);
		items.click(function() {
		    let idx = $(this).attr(RECORD_INDEX);
		    let record = records[idx];
		    if(!record) return;
		    _this.highlightPoint(record.getLatitude(), record.getLongitude(),true, false,false,record);
		    _this.map.setCenter(MapUtils.createLonLat(record.getLongitude(),record.getLatitude()));
		    if(_this.getProperty("tocZoom")) {
		    	_this.map.setZoom(_this.getProperty("tocZoom"));
		    }

		    if(record.trackData) {
			setTimeout(()=>{
			    _this.getDisplayManager().notifyEvent("dataSelection", _this, {data:record.trackData});
			},100);
		    }
		});

		items.dblclick(function() {
		    _this.removeHighlight();
		    let idx = $(this).attr(RECORD_INDEX);
		    let record = records[idx];
		    if(!record) return;
		    if(_this.trackUrlField) {
			let url = record.getValue(_this.trackUrlField.getIndex());
			if(url && url.length>0) {
			    _this.toggleTrack(record,$(this));
			    return;
			}
		    } 
		    _this.map.setCenter(MapUtils.createLonLat(record.getLongitude(),record.getLatitude()));
		});
	    }
	},	    

        updateUI: function(args) {
	    if(!args) args={};
	    let debug = false;
	    this.lastUpdateTime = null;
            SUPER.updateUI.call(this,args);
	    //	    console.log("map.updateUI: " + !this.getDisplayReady() +" " + !this.hasData() +" " +!this.getProperty("showData", true));
            if (this.haveCalledUpdateUI || !this.getDisplayReady() ||!this.hasData() || !this.getProperty("showData", true)) {
		if(debug) console.log("map.updateUI have called:" + this.haveCalledUI +" ready:" + this.getDisplayReady() +" has data:" + this.hasData() +" showData:" +this.getProperty("showData", true));
                return;
            }


	    if(this.updateUICallback) {
		clearTimeout(this.updateUICallback);
		this.updateUICallback = null;
	    }
            let pointData = this.getPointData();
	    this.lastZoom = this.map?this.map.getZoom():null;

	    //Set the shapes Fields here before filter data so we can accept non georeferenced data
	    this.shapesField = this.getFieldById(null,this.getProperty("shapesField"));
	    this.shapesTypeField = this.getFieldById(null,this.getProperty("shapesTypeField"));
	    this.trackUrlField  =  this.getFieldById(null,this.getProperty("trackUrlField"));
            let records = this.records =  this.filterData();
	    if(this.shapesTypeField && this.shapesField) {
		this.setProperty("tooltipNotFields",this.shapesTypeField.getId()+"," + this.shapesField);
		this.loadShapes(records);
	    }

	    if(debug) console.log("displaymap.updateUI reload=" +args.reload);
            if (records == null) {
		if(debug) console.log("\tno data");
                return;
            }



	    if(this.getSkipZero()) {
		records = records.filter(record=>{
		    return !(record.getLatitude()==0 && record.getLongitude()==0);
		});
	    }


	    if(this.getShowTableOfContents(false)) {
		this.makeToc(records);
	    }

	    if(!this.updatingFromClip) {
		//stop the flash
		if(args.source!="animation") {
		    this.setMessage(args.dataFilterChanged|| args.fieldChanged|| args.reload?"Reloading map...":"Creating map...");
		}
	    }
	    this.updatingFromClip = false;

	    //	    setTimeout(()=>{
	    try {
		if(displayDebug.initMap) this.logMsg("calling updateUIInner",true);
		this.callingUpdateUI = true;
		this.updateUIInner(args, pointData, records,debug);
		this.callingUpdateUI = false;
		if(this.getCenterOnMarkersAfterUpdate()) {
		    this.map.centerOnMarkers();
		}
		if(displayDebug.initMap) this.logMsg("done calling updateUIInner",true);
		if(args.callback)args.callback(records);
		this.clearProgress();
		if(!this.layerVisible) {
		    setTimeout(()=>{this.setVisible(false);},50);
		}
	    } catch(exc) {
		this.callingUpdateUI = false;
		console.log(exc)
		console.log(exc.stack);
		this.setMessage("Error:" + exc);
	    }

	    this.notifyExternalDisplay();

	    this.setIsFinished();
	    //	    });

	},
	notifyExternalDisplay:function() {
	    let externalDisplay = this.getProperty("externalDisplay");
	    if(externalDisplay) {
		externalDisplay.externalDisplayReady(this);
	    }
	},
	filterDataPhase2:function(records) {
	    records = SUPER.filterDataPhase2.call(this,records);
	    if(this.clipBounds || this.clipToView) {
		let bounds = RecordUtil.getBounds(records);
		this.clipBounds = false;
		let clipRecords = false;
		if(!this.lastPointBounds || (this.lastPointBounds && this.lastPointBounds!=bounds)) {
		    clipRecords = true;
		}
		this.lastPointBounds = bounds;
		if(this.clipToView || clipRecords) {
		    let viewbounds = this.map.getMap().calculateBounds().transform(this.map.sourceProjection, this.map.displayProjection);
		    let tmpRecords =records.filter(r=>{
			return viewbounds.containsLonLat(MapUtils.createLonLat(r.getLongitude(),r.getLatitude()));
		    });
		    //		    console.log("clipped records:" + tmpRecords.length);
		    records = tmpRecords;
		}
	    }
	    return records;
	},


	updateUIInner: function(args, pointData, records, debug) {
	    let _this = this;
	    let t1= new Date();
	    debug = debug || displayDebug.displayMapUpdateUI;
	    if(debug) console.log("displaymap.updateUIInner:" + records.length);
	    this.haveCalledUpdateUI = true;
	    let header='';
	    if(this.getShowCollisionToggle()) {
		header+=HU.span([ATTR_TITLE,'Toggle showing collisions',
				 ATTR_CLASS,'display-header-item'],
				HU.checkbox('',[ATTR_ID,this.domId('collisiontoggle')],
					    !this.getHandleCollisions(),
					    'Show all points'));
	    }


	    if(this.getShowRegionSelector()) {
		let label = this.getRegionSelectorLabel() ?? HU.getIconImage("fa-globe-americas");
		
		header+= HU.span([ATTR_CLASS,"display-header-span ramadda-menu-button ramadda-clickable",  ATTR_TITLE,"Select region", ID,this.domId("selectregion")],label)+SPACE2;

	    }


	    if(Utils.stringDefined(header)) {
		this.writeHeader(ID_HEADER2_PREFIX,header);
	    }

	    this.jq('collisiontoggle').change(function(){
		let on = $(this).is(':checked');
		_this.setProperty('handleCollisions',!on);
		_this.haveCalledUpdateUI = false;
		_this.updateUI();
		
	    });
	    this.jq("selectregion").click(function() {
		_this.initRegionsSelector($(this));
	    });

	    if(!this.getProperty("makeDisplay",true)) {
		return;
	    }
	    if(!this.fullBounds) {
		this.fullBounds = {};
		RecordUtil.getPoints(this.getRecords(), this.fullBounds);
	    }
            let pointBounds = {};
	    let haveLinkedFeature  = this.getTheLinkFields() && this.getLinkFeature();
	    if(!haveLinkedFeature && this.getFilterBadLocations(true)) {
		records = records.filter(r=>{
		    return r.getLatitude()>=-90 && r.getLatitude()<=90 &&
			r.getLongitude()>=-180 &&
			r.getLongitude()<=180;
		});
	    }


            let points = RecordUtil.getPoints(records, pointBounds);
            let fields = pointData.getRecordFields();
            let showSegments = this.getShowSegments(false);
	    let okToSetMapBounds = !showSegments && !this.hadInitialPosition && !args.dontSetBounds && 
		(!args.dataFilterChanged || this.getCenterOnFilterChange());
	    let haveRecords = records.length>0;
	    if(this.getInitBoundsUseAllRecords()) {
		pointBounds = {};
		let allRecords = this.getData().getRecords();
		RecordUtil.getPoints(allRecords, pointBounds);
		haveRecords=allRecords.length>0;
	    }
	    if(haveRecords) {
		if (!isNaN(pointBounds.north)) {
		    let padding = this.getInitBoundsPadding();
		    if(padding) {
			let w = pointBounds.east-pointBounds.west;
			pointBounds.east-=w*padding;
			pointBounds.west-=w*padding;			
			let h = pointBounds.north-pointBounds.south;
			pointBounds.north+=h*padding;
			pointBounds.south-=h*padding;			
		    }
		    this.pointBounds = pointBounds;
		    this.initBounds = pointBounds;
		    if(okToSetMapBounds) {

			if(pointBounds.insideDateLine) {
			    this.setInitMapBounds(pointBounds.north, -178, pointBounds.south, -170);
			} else {
			    this.setInitMapBounds(pointBounds.north, pointBounds.west, pointBounds.south, pointBounds.east);
			}
		    }
		}
	    }
	    if (this.map == null) {
		return;
	    }
	    if(this.highlightMarkers) {
		this.highlightMarkers.forEach(marker=>{
		    this.map.removePoint(marker);
		    this.map.removeMarker(marker);
		});
		this.highlightMarkers = null;
	    }

	    this.map.clearSeenMarkers();
	    let t2= new Date();
	    //	    debug = true;
	    if(debug) console.log("displaymap calling addPoints");
	    //Add in to handle when there is no geolocation on the record
	    //	    if(points.length==0 &&  haveLinkedFeature) {
	    if(points.length==0) {
		this.records.forEach(record=>{
		    points.push({x:-105,y:40});
		});
	    }
            this.addPoints(records,fields,points,pointBounds,debug);
	    let t3= new Date();
            this.addLabels(records,fields);
            this.applyVectorMap(true, this.textGetter,args);
	    let t4= new Date();
	    if(debug) Utils.displayTimes("time pts=" + points.length,[t1,t2,t3,t4], true);
	    this.lastUpdateTime = new Date();
	},
	xcnt:0,
	heatmapCnt:0,
	animationApply: function(animation, skipUpdateUI) {
 	    if(!this.heatmapLayers || !this.getHeatmapVisible()) {
		SUPER.animationApply.call(this, animation, skipUpdateUI);
		return;
	    }
	    let onDate=null;
	    //	    console.log("displaymap.animationApply:" + animation.begin + " " +animation.end);
	    let onLayer = null;
	    let offLayers = [];
	    this.heatmapLayers.every(layer=>{
		if(!layer.date) return true;
		if(layer.date.getTime()>= animation.begin.getTime() && layer.date.getTime()<= animation.end.getTime()) {
		    onDate = layer.date;
		    onLayer = layer;
		    layer.setVisibility(true);
		} else {
		    if(layer.getVisibility()) 
			offLayers.push(layer);
		}
		return true;
	    })
	    offLayers.forEach(layer=>{
		layer.setVisibility(false);
	    });
 	    if(!onDate) {
		SUPER.animationApply.call(this, animation, skipUpdateUI);
	    }
	    if(onLayer!=null)
		this.setMapLabel(onLayer.heatmapLabel);
	},
        setDateRange: function(min, max) {
	    //Not sure why we do this
	    if(this.getDoGridPoints(false)|| this.getDoHeatmap(false)) {
		SUPER.setDateRange.call(this, min,max);
	    } else {
		SUPER.setDateRange.call(this, min,max);
	    }
	},
	showColorTable: function(colorBy) {
	    colorBy.displayColorTable(null,true);
	    this.callingUpdateSize = true;
	    //for now don't do this as it takes a long time
	    //	    this.map.getMap().updateSize();
	    this.callingUpdateSize = false;
	},

	applyHeatmapAnimation: function(index) {
 	    if(!this.heatmapLayers || !this.getHeatmapVisible())
		return

	    this.jq(ID_HEATMAP_ANIM_LIST)[0].selectedIndex = index;
	    let offLayers = [];
	    this.heatmapLayers.forEach((layer,idx)=>{
		if(index==idx)
		    layer.setVisibility(true);
		else
		    offLayers.push(layer);
	    });
	    offLayers.forEach(layer=>{
		layer.setVisibility(false);
	    });
	    this.setMapLabel(this.heatmapLayers[index].heatmapLabel);
	},
	stepHeatmapAnimation: function(delta){
	    console.log('step');
 	    if(!this.heatmapLayers || !this.getHeatmapVisible())
		return

	    console.log('step2');

	    let index = this.jq(ID_HEATMAP_ANIM_LIST)[0].selectedIndex;
	    index+=delta;
	    if(index<0) {
		index = 0;
	    }
	    if(index>=this.heatmapLayers.length) {
		index =0;
	    }
	    this.applyHeatmapAnimation(index);
	    if(this.heatmapPlayingAnimation) {
		setTimeout(()=>{
		    this.stepHeatmapAnimation(1);
		},this.getHmAnimationSleep(1000));
	    }
	},
	checkHeatmapReload:function() {
	    //	    return
	    if(!this.getHmReloadOnZoom(this.getReloadOnZoom(false))) return;
	    let now = new Date ();
	    //Don't do this the first couple of seconds after we've been created
	    if(now.getTime()-this.createTime.getTime()<3000) return;
	    let diff = 0;
	    if(this.checkHeatmapReloadTime) {
		diff = now.getTime()-this.checkHeatmapReloadTime.getTime();
	    }
	    this.checkHeatmapReloadTime = now;
	    if(diff<1000) {
		if(!this.checkHeatmapReloadPending) {
		    this.checkHeatmapReloadPending = true;
		    setTimeout(()=>{
			this.checkHeatmapReloadPending = false;
			this.checkHeatmapReload();
		    },1100)
		}
		return;
	    }
	    this.checkHeatmapReloadTime = null;
	    this.reloadHeatmap = true;
	    this.haveCalledUpdateUI = false;
	    this.updateUI();
	},
	createHeatmap(records, fields, bounds) {
	    let debug = displayDebug.displayMapCreateMap;
	    //	    debug = true;
	    if(debug) console.log("createHeatmap");
	    let colorBy = this.getColorByInfo(records, null,null,null,["hmColorBy","colorBy",""]);
	    let angleBy = this.getColorByInfo(records, "angleBy",null,null,["hmAngleBy","angleBy",""]);
	    let lengthBy = this.getColorByInfo(records, "lengthBy",null,null,["hmLengthBy","lengthBy",""]);
	    if(!angleBy.isEnabled()) angleBy = colorBy;
	    if(!lengthBy.isEnabled()) lengthBy=null;
	    records = records || this.filterData();
	    if(this.getHmBounds()) {
		let toks = this.getHmBounds().split(",");
		bounds = new RamaddaBounds(+toks[0],+toks[1], +toks[2],+toks[3]);
	    }
	    let mapBounds = this.map.getBounds();
	    bounds = bounds ||  RecordUtil.getBounds(records);
	    bounds = RecordUtil.convertBounds(mapBounds);
	    if(this.pointBounds) bounds = this.pointBounds;
	    if(debug) {
		console.dir(bounds.north,bounds.west,bounds.south,bounds.east);
	    }


	    this.removeExtraLayers();
	    this.heatmapLayers = [];
	    this.extraLayers = [];	    
	    if(records.length==0) {
		this.errorMessage = this.getNoDataMessage();
		this.setMessage(this.errorMessage);
		return
	    }
	    if(this.reloadHeatmap) {
		this.reloadHeatmap = false;
		bounds = new RamaddaBounds(this.map.getBounds());
		records = RecordUtil.subset(records, bounds);
		//		bounds =  RecordUtil.getBounds(records);
	    }
	    bounds = RecordUtil.expandBounds(bounds,this.getProperty("boundsScale",0.05));

	    let dfltArgs = this.getDefaultGridByArgs();
	    let ratio = (bounds.east-bounds.west)/(bounds.north-bounds.south);
	    let w = Math.round(this.getProperty("gridWidth",800));
	    let h = Math.round(w/ratio);
	    let groupByField = this.getFieldById(null,this.getHmGroupBy());
	    let groupByDate = this.getHmGroupByDate();
	    if(debug) console.log('calling groupBy group by date:' + groupByDate +' group by field:' + groupByField);
	    let t1 = new Date();
	    let groups = (groupByField || groupByDate)?RecordUtil.groupBy(records, this, groupByDate, groupByField):null;
	    let t2 = new Date();
	    //	    Utils.displayTimes("make groups",[t1,t2],true);
	    if(debug) console.log("\tdone calling groupBy");
	    if(groups == null || groups.max == 0) {
		doTimes = false;
		groups= {
		    max:records.length,
		    values:["none"],
		    map:{none:records}
		}
	    }
	    //	    if(debug)	console.dir('groups:',groups);

	    //	    if(debug) console.log("\tdone calling groupBy count="+ groups.values.length);
	    let recordCnt = groups.max;
 	    if(dfltArgs.cellSize==0) {
		let sqrt = Math.sqrt(recordCnt);
		let size = Math.round(w/sqrt);
		dfltArgs.cellSizeX = dfltArgs.cellSizeY = dfltArgs.cellSize = size;
	    } else if(String(dfltArgs.cellSize).endsWith("%")) {
		dfltArgs.cellSize =dfltArgs.cellSizeX =  dfltArgs.cellSizeY = Math.floor(parseFloat(dfltArgs.cellSize.substring(0,dfltArgs.cellSize.length-1))/100*w);
	    }
	    let args =$.extend({colorBy:colorBy,angleBy:angleBy,lengthBy:lengthBy,w:w,h:h,bounds:bounds,forMercator:true},
			       dfltArgs);
	    if(debug) {
		console.log("#records:" + records.length+" dim:" + w +" " +h + " #records:" + records.length +" cell:" + dfltArgs.cellSizeX + " #records:" + records.length +" bounds:" + bounds);
	    }
	    let labels = [];
	    let labelPrefix = this.getHmLabelPrefix("${field}-");
	    groups.values.forEach((value,idx)=>{
		let recordsAtTime = groups.map[value];
		if(debug && idx<5)
		    console.log("group:" + value +" #:" + groups.map[value].length);

		let img = Gfx.gridData(this.getId(),fields, recordsAtTime,args);
		let label = value=="none"?"Heatmap": labelPrefix +" " +groups.labels[idx];
		label = label.replace("${field}",colorBy.field?colorBy.field.getLabel():"");
		labels.push(label);
		let layer = this.map.addImageLayer("heatmap"+(this.heatmapCnt++), label, "", img, idx==0, bounds.north, bounds.west, bounds.south, bounds.east,w,h, { 
		    isBaseLayer: false,
		});
		//For now don't set the layer index since it places this layer too high
		//		this.map.getMap().setLayerIndex(layer, 1000);
		layer.heatmapLabel = label;
		if(groupByDate) {
		    if(value.getTime)
			layer.date = value;
		}
		if(!this.getHeatmapVisible()) layer.setVisibility(false);
		this.extraLayers.push(layer);
		this.heatmapLayers.push(layer);
	    });
	    if(this.getHmShowGroups(true) && this.heatmapLayers.length>1 && !this.getAnimationEnabled()) {
		this.heatmapPlayingAnimation = false;
		let controls =  [];
		controls.push(HU.div([ATTR_ID,this.domId(ID_HEATMAP_ANIM_STEP_BACK),ATTR_STYLE,HU.css("display","inline-block"),ATTR_TITLE,"Step back"],
 				     HU.getIconImage("fa-step-backward",[ATTR_CLASS,"display-anim-button"])));

		if(!groupByField) 
		    controls.push(HU.div([ATTR_ID,this.domId(ID_HEATMAP_ANIM_PLAY),ATTR_STYLE,HU.css("display","inline-block"),ATTR_TITLE,"Play/Stop Animation"],
					 HU.getIconImage("fa-play",[ATTR_CLASS,"display-anim-button"])));
		controls.push(HU.div([ATTR_ID,this.domId(ID_HEATMAP_ANIM_STEP_FORWARD),ATTR_STYLE,HU.css("display","inline-block"),ATTR_TITLE,"Step forward"],
 				     HU.getIconImage("fa-step-forward",[ATTR_CLASS,"display-anim-button"])));
		

		controls.push(HU.div([ATTR_STYLE,HU.css("display","inline-block","margin-left","5px","margin-right","5px")], HU.select("",[ATTR_ID,this.domId(ID_HEATMAP_ANIM_LIST)],labels)));
		this.writeHeader(ID_HEADER2_PREPREFIX, Utils.join(controls,"&nbsp;&nbsp;"));
		let _this = this;
		this.jq(ID_HEATMAP_ANIM_LIST).change(function() {
		    let index = $(this)[0].selectedIndex;
		    _this.applyHeatmapAnimation(index);
		});
		this.jq(ID_HEATMAP_ANIM_PLAY).click(function() {
		    _this.heatmapPlayingAnimation = !_this.heatmapPlayingAnimation;
		    let icon = _this.heatmapPlayingAnimation?"fa-stop":"fa-play";
		    $(this).html(HU.getIconImage(icon,[ATTR_CLASS, "display-anim-button"]));
		    if(_this.heatmapPlayingAnimation) {
			_this.stepHeatmapAnimation(1);
		    }
		});
		this.jq(ID_HEATMAP_ANIM_STEP_FORWARD).click(function() {
		    _this.heatmapPlayingAnimation = false;
		    let icon = _this.heatmapPlayingAnimation?"fa-stop":"fa-play";
		    _this.jq(ID_HEATMAP_ANIM_PLAY).html(HU.getIconImage(icon,[ATTR_CLASS,"display-anim-button"]));
		    _this.stepHeatmapAnimation(1);
		});
		this.jq(ID_HEATMAP_ANIM_STEP_BACK).click(function() {
		    _this.heatmapPlayingAnimation = false;
		    let icon = _this.heatmapPlayingAnimation?"fa-stop":"fa-play";
		    _this.jq(ID_HEATMAP_ANIM_PLAY).html(HU.getIconImage(icon,[ATTR_CLASS,"display-anim-button"]));
		    _this.stepHeatmapAnimation(-1);
		});		

	    }
	    if(groups.values[0]!="none") {
		this.setMapLabel(labels[0]);
	    }
	    this.showColorTable(colorBy);


	    if(this.getHmShowToggle(this.getProperty("hm.showToggle")) || this.getHmShowReload()) {
		let cbx = this.jq(ID_HEATMAP_TOGGLE);
		let reload =  HU.getIconImage("fa-sync",[ATTR_CLASS,"display-anim-button",ATTR_TITLE,"Reload heatmap", ID,this.domId("heatmapreload")])+SPACE2;
		this.heatmapVisible= cbx.length==0 ||cbx.is(':checked');

		let toggle = reload +
		    HU.checkbox("",[ATTR_ID,this.domId(ID_HEATMAP_TOGGLE)],this.heatmapVisible,
				this.getHmToggleLabel(this.getProperty('hm.toggleLabel','Heatmap')));
		this.writeHeader(ID_HEADER2_PREFIX,HU.span([ATTR_STYLE,HU.css('margin-right:8px;')],toggle));


		let _this = this;
		this.jq('heatmapreload').click(()=> {
		    this.reloadHeatmap = true;
		    this.removeExtraLayers();
		    this.haveCalledUpdateUI = false;
		    this.updateUI();
		});
		this.jq(ID_HEATMAP_TOGGLE).change(()=>{
		    if(_this.heatmapLayers)  {
			let visible = _this.getHeatmapVisible();
			_this.heatmapVisible  = visible;
			_this.heatmapLayers.forEach(layer=>layer.setVisibility(visible));
			_this.map.setPointsVisibility(!visible);
		    }
		});
	    }
	},

	getHeatmapVisible:function() {
	    let toggle = this.jq(ID_HEATMAP_TOGGLE);
	    return toggle.length==0 || toggle.is(':checked');
	},
	updateHtmlLayers: function() {
	    if(this.htmlLayerInfo) {
		this.createHtmlLayer(this.htmlLayerInfo.records, this.htmlLayerInfo.fields);
	    }
	},
	updateHtmlLayer:function() {
	    if(!this.htmlLayer) return;
	    if(!this.htmlLayerId) {
		this.htmlLayerId =this.getUniqueId(ID_HTMLLAYER);
		this.htmlPopupLayerId =this.getUniqueId('popup');
		this.jq(ID_MAP).append(HU.div([ATTR_ID,this.htmlPopupLayerId,ATTR_STYLE,HU.css('position','absolute','width','100%','left','0px','top','0px','bottom','0px','xbackground','red','z-index','0','pointer-events', 'none')]));
		let vp  = this.map.getMap().getViewport();
		vp = $(vp).children()[0];
		$(vp).css('display','relative');
		$(vp).append(HU.div([ATTR_STYLE,'z-index:10',ATTR_CLASS,'display-map-htmllayer', ATTR_ID,this.htmlLayerId]));
	    }
	    if(this.htmlPopupLayerId) {
		//		jqid(this.htmlPopupLayerId).html(HU.div([ATTR_STYLE,'position:absolute;top:50px;left:100px'],'xxxx'));
		jqid(this.htmlPopupLayerId).html(this.htmlPopup);
	    }
	    $('#'+ this.htmlLayerId).html(HU.div([ATTR_STYLE,'position:relative;'],this.htmlLayer));
	    


	},
        createHtmlLayer: function(records, fields) {
	    let _this = this;
	    _this.htmlLayerMouseOver = null;
	    let htmlLayerField = this.getFieldById(fields,this.getHtmlLayerField());
	    this.htmlLayerInfo = {
		records:records,
		fields:fields,
	    };
	    this.htmlLayer = '';
	    this.htmlPopup = '';
	    let fillColor = this.getFillColor("#619FCA");
	    let strokeColor = this.getStrokeColor("#888");
	    let popupLabelField = this.getFieldById(fields, this.getHtmlLayerPopupLabelField());
	    let flipYAxis = this.getHtmlLayerFlipYAxis();
	    let drawAxisLabels = this.getHtmlLayerDrawAxisLabels();	    	    
	    let drawPopupAxisLabels = this.getHtmlLayerPopupDrawAxisLabels();	    	    
	    let scaleAll = this.getHtmlLayerScaleWithAll(true);	    

	    let w = this.getHtmlLayerWidth(30);
	    let h = this.getHtmlLayerHeight(15);
	    let shape = this.getHtmlLayerShape("barchart");
	    if(shape=="barchart")
		this.setProperty("colorBy",htmlLayerField.getId());
	    if(this.getHtmlLayerScale()) {
		let zooms = [];		
		this.getHtmlLayerScale().split(",").forEach(t=>{
		    zooms.push(t.split(":"));
		});
		//3:0.5,4:1,5:2
		let zoom = this.map.map.getZoom();
		let scale = 1.0;
		if(zooms.length==1 && zooms[0].length==1) {
		    scale=zooms[0][0];
		} else {
		    zooms.every(t=>{
			scale=t[1];
			if(t[0] >= zoom) {
			    return false;
			}
			return true;
		    });
		}
		w*=scale;h*=scale;
	    }
	    let style = this.getHtmlLayerStyle("");
	    let infos = [];
	    let allData = this.getColumnValues(records, htmlLayerField);
	    let groups = RecordUtil.groupBy(records, this, false,"latlon");
	    let container = $($(this.map.getMap().getViewport()).children()[0]);
	    let cleft = +container.css("left").replace("px","");
	    let ctop = +container.css("top").replace("px","");
	    let hoverW = w*3;
	    let hoverH = h*3;
	    let layerRecords = [];

	    groups.values.forEach((value,idx)=>{
		let recordsAtTime = groups.map[value];
		let data = [];
		layerRecords.push(recordsAtTime[0]);
		recordsAtTime.forEach((r,idx)=>{
		    data.push(r.getValue(htmlLayerField.getIndex()));
		});
		let record = recordsAtTime[0];
		let px = this.map.getMap().getPixelFromLonLat(this.map.transformLLPoint(MapUtils.createLonLat(record.getLongitude(),record.getLatitude())));
		let id = this.getId() +"_sl"+ idx;
		let hid = id +"_hover";
		let html = 
		    HU.div([ATTR_ID,id,  ATTR_CLASS,'display-map-html-item',
			    ATTR_STYLE,style +HU.css('line-height','0px','z-index','1000','position','absolute','left', (px.x-w/2-cleft) +'px','top', (px.y-h/2-ctop)+'px')]);
		let label = '';
		if(record && popupLabelField) {
		    label = popupLabelField.getValue(record);
		}
		if(Utils.stringDefined(label)) {
		    label  = HU.div([ATTR_STYLE,'white-space:nowrap;position:absolute;font-size:8pt;top:25px;left:10px;'],label);
		}
		this.htmlPopup +=
		    HU.div([ATTR_ID,hid, RECORD_INDEX, idx,
			    ATTR_TITLE,"", ATTR_CLASS,'display-map-html-hitem',
			    ATTR_STYLE,style +HU.css('display','none','line-height','0px','z-index','2001','position','absolute','xleft', (px.x-hoverW/2-cleft) +'px','left','0px','top','0px','xtop', (px.y-hoverH/2-ctop)+'px')],label);
		this.htmlLayer += html;
		infos.push({
		    id:id,
		    hoverId: hid,
		    data:data,
		    min:Utils.getMin(data),
		    max:Utils.getMax(data),		    		    
		    records: recordsAtTime
		});
	    });
	    this.updateHtmlLayer();
            let colorBy = this.getColorByInfo(records);
	    infos.forEach((info,idx)=>{
		if(shape == "pie" || shape == "piechart") {
		    [0,1].forEach((cid,idx)=>{
			let id = HU.getUniqueId("pie");
			let cw = idx==0?w:hoverW;
			let ch = idx==0?h:hoverH;
			let pie = HU.tag(TAG_CANVAS,[ATTR_STYLE,HU.css('cursor','pointer'),
						     ATTR_ID,id ,ATTR_WIDTH,cw,ATTR_HEIGHT, ch]);
			if(idx==0)
			    $("#" + info.id).html(pie);
			else
			    $("#" + info.hoverId).html(pie);
			let canvas = document.getElementById(id);
			let color = colorBy&& colorBy.isEnabled()?colorBy.getColor(info.data[0]):fillColor;
			let ctx = canvas.getContext("2d");
			if(idx==1) {
			    ctx.fillStyle= '#fff';
			    ctx.beginPath();
			    ctx.moveTo(cw/2,ch/2);
			    ctx.arc(cw/2,ch/2, cw/2-2, 0-Math.PI/2, 2*Math.PI);
			    ctx.closePath();
			    ctx.fill();
			}
			ctx.beginPath();
			ctx.moveTo(cw/2,ch/2);
			ctx.arc(cw/2,ch/2, cw/2-2, 0-Math.PI/2, info.data[0]*2 * Math.PI-Math.PI/2);
			ctx.lineTo(cw/2,ch/2);
			ctx.closePath();
			ctx.strokeStyle= strokeColor;
			ctx.fillStyle= color;
			ctx.fill();
			ctx.stroke();
			ctx.beginPath();
			ctx.arc(cw/2,ch/2, cw/2-2, 0, 2 * Math.PI);
			ctx.closePath();
			ctx.stroke();
		    });
		} else {
		    let props1 = {
			flipYAxis:flipYAxis,
			drawAxisLabels:drawAxisLabels,
			//drawAxis:false
		    };
		    let props2 = {
			flipYAxis:flipYAxis,
			drawAxisLabels:drawAxisLabels||drawPopupAxisLabels,
		    }

		    let min = allData.min;
		    let max = allData.max;		    
		    if(!scaleAll) {
			min = info.min;
			max = info.max;
		    }
		    min = this.getHtmlLayerMin(min);
		    max = this.getHtmlLayerMax(max);		    
		    drawSparkline(this,"#"+ info.id,w,h,info.data,info.records,min,max,colorBy,props1);
		    $('#' + info.hoverId).css('background','#fff').css('border','1px solid #ccc');
		    drawSparkline(this,"#"+ info.hoverId,hoverW,hoverH,info.data,info.records,min,max,colorBy,props2);
		}
	    });
	    let items = this.find(".display-map-html-item");			
	    let hitems = this.find(".display-map-html-hitem");
	    this.makeTooltips(hitems, layerRecords);
	    
	    items.mouseenter(function() {
		//		$(this).css('display','none');
		hitems.hide();
		let popup = 	$('#'+$(this).attr(ID)+'_hover');
		popup.show();
		//		$('#'+$(this).attr(ID)+'_hover').fadeIn(1000);
	    });
	    items.mouseleave(function() {
		hitems.hide();
	    });
	    hitems.mouseleave(function() {
		$('#'+ $(this).attr(ID).replace('_hover','')).css('display','block');
		$(this).css('display','none');
	    });
	    if(colorBy.hasField()) {
		this.showColorTable(colorBy);
	    }
	},


        makeVoronoi: function(records, fields, points,bounds) {
	    if(!MapUtils.loadTurf(()=>{this.makeVoronoi(records, fields, points,bounds);})) {
		return;
	    }

	    let pad;
	    //pad the bounds
	    if(pad = this.getVoronoiPadding(0)) {
		let  w = bounds.east-bounds.west;
		let  h = bounds.north-bounds.south;		
		let b = $.extend({},bounds);
		b.west = Math.max(-180, b.west-w*pad);
		b.east = Math.min(180,b.east+w*pad);
		b.north=  Math.min(90,b.north+h*pad);
		b.south = Math.max(-90,b.south-h*pad);				
		bounds = b;
	    }

	    let options = {
		bbox: this.makeTurfBounds(bounds)
	    };
	    let geojsonPoints = [];
	    let dups = {};
	    let vpoints = [];
	    points.forEach((p,idx)=>{
		let record = records[idx];
		let key =p.x+'_'+p.y;
		if(dups[key]) return;
		dups[key] = true;
		geojsonPoints.push(turf.point([p.x,p.y]));
		vpoints.push({point:p,record:record});
	    });
	    let collection = turf.featureCollection(geojsonPoints);
	    //	    let points = turf.randomPoint(1000, options);
	    let  voronoiPolygons= turf.voronoi(collection, options);
	    this.voronoiLayer =this.createGeoJsonLayer('Voronoi',voronoiPolygons,this.voronoiLayer);
            let colorBy = this.getColorByInfo(records,'voronoiColorBy',null,null,null,this.lastColorBy);
	    this.lastColorBy = colorBy;
	    let textGetter = this.getTextGetter(fields);
	    let style = {
		strokeColor:this.getVoronoiStrokeColor(),
		strokeWidth:this.getVoronoiStrokeWidth(),
		strokeDashstyle:this.getVoronoiStrokeDashstyle(),
		fillColor:this.getVoronoiFillColor(),
		fillOpacity:this.getVoronoiFillOpacity()		
	    }
	    this.voronoiLayer.features.forEach((f,idx)=>{
		let record = vpoints[idx].record;
		let s =Utils.clone({},style);
		if(colorBy.isEnabled()) {
		    s.fillColor= colorBy.getColorFromRecord(record);
		}
		f.style=s;
		f.record  =record;
		f.textGetter  = textGetter;
	    });
	    this.voronoiLayer.redraw();
            if (colorBy.isEnabled()) {
		colorBy.displayColorTable();
	    }
	    this.notifyExternalDisplay();

	},

        makeHexmap: function(records, fields, points,bounds) {
	    if(!MapUtils.loadTurf(()=>{this.makeHexmap(records, fields, points,bounds);})) {
		return;
	    }
	    let bbox =  this.makeTurfBounds(this.getHexmapUseFullBounds()?this.fullBounds:bounds,this.getHexmapPadding());
	    let cellSide = this.getHexmapCellSide();
	    let options = {units: this.getHexmapUnits()};
	    let hexgrid;
	    let mapType = this.getProperty('mapType');
	    if(this.getDoTrianglemap() || mapType=='triangle') {
		hexgrid = turf.triangleGrid(bbox, cellSide, options);
	    } else if(this.getDoSquaremap() || mapType=='square') {
		hexgrid = turf.squareGrid(bbox, cellSide, options);
	    } else {
		hexgrid = turf.hexGrid(bbox, cellSide, options);
	    }
	    let vpoints = [];
	    let yes= 0, no=0;


	    points.forEach((p,idx)=>{
		let record = records[idx];
		let pts = turf.points([[p.x,p.y]]);
		let isIn = false;
		hexgrid.features.every((feature,fidx)=>{
		    if(!feature.searchWithin) {
			let coords = feature.geometry.coordinates[0];
			feature.searchWithin = turf.polygon([coords]);
			feature.bbox = turf.bbox(feature.searchWithin);
			feature.records=[];
		    }
		    if(p.x>=feature.bbox[0] && p.x<= feature.bbox[2] &&
		       p.y>=feature.bbox[1] && p.y<=feature.bbox[3]) {
			let ptsWithin = turf.pointsWithinPolygon(pts,feature.searchWithin);
			if(ptsWithin.features.length>0) {
			    isIn = true;
			    feature.records.push(record);
			    return false;
			}
		    }
		    return true;
		});
		if(isIn) yes++;
		else no++;
	    });
	    let maxCount = -1,minCount=-1;
	    hexgrid.features.forEach((feature,fidx)=>{
		if(feature.records && feature.records.length>0) {
		    maxCount=maxCount==-1?feature.records.length:Math.max(maxCount, feature.records.length);
		    minCount=minCount==-1?feature.records.length:Math.min(minCount, feature.records.length);		    
		}
	    });
	    this.hexmapLayer =this.createGeoJsonLayer('Hexmap',hexgrid,this.hexmapLayer);
            let colorBy = this.getColorByInfo(records,'hexmapColorBy',null,null,null,
					      this.lastColorBy,
					      {isString:this.getHexmapUseEnum(),
					       colorTableProperty:'hexmapColorTable',
					       minValue:this.getHexmapMinValue(),
					       maxValue:this.getHexmapMaxValue()});
	    if(this.getHexmapUseEnum()) {
		colorBy.setDoEnum(true);
	    } else  if(this.getHexmapUseCount(this.getProperty('hexmapShowCount'))) {
		colorBy.setDoCount(minCount,maxCount);
	    } else {
		let doTotal = this.getHexmapShowTotal();
		colorBy.setDoTotal(doTotal);
		//recalculate the color ranges based on the average value
		let minValue = NaN;
		let maxValue = NaN;		
		this.hexmapLayer.features.forEach((f,idx)=>{
		    let records=hexgrid.features[idx].records;
		    if(!records || records.length==0) return;
		    let value = doTotal?
			colorBy.doTotal(records):
			colorBy.doAverage(records);
		    minValue = Utils.min(minValue,value);
		    maxValue = Utils.max(maxValue,value);		    
		});
		colorBy.setRange(minValue,maxValue, true);
	    }
	    this.lastColorBy = colorBy;
	    let textGetter = this.getTextGetter(fields,true);
	    let style = {
		strokeColor:this.getHexmapStrokeColor(),
		strokeDashstyle:this.getHexmapStrokeDashstyle(),
		strokeWidth:this.getHexmapStrokeWidth(),
		fillColor:this.getHexmapFillColor('transparent'),
		fillOpacity:this.getHexmapFillOpacity()				
	    }
	    let emptyStyle = {
		strokeColor:this.getHexmapEmptyStrokeColor(style.strokeColor),
		strokeWidth:this.getHexmapEmptyStrokeWidth(style.strokeWidth),
		fillColor:this.getHexmapEmptyFillColor(style.fillColor),
		fillOpacity:this.getHexmapFillOpacity()						
	    }
	    let baseStyle = {
		pointRadius:0,
		fontSize:this.getProperty('hexmapLabelFontSize',6),
		fontColor:this.getProperty('hexmapLabelFontColor','#000'),
		fontWeight: this.getProperty('hexmapLabelFontWeight','bold')
	    }

	    let labelTemplate =	 this.getHexmapLabelTemplate();
	    this.hexmapLayer.features.forEach((f,idx)=>{
		let records=hexgrid.features[idx].records;
		let s = (records && records.length>0)?style:emptyStyle;
		s = Utils.clone({},s);
		if(records && records.length>0) {
		    if(colorBy.isEnabled()) {
			s.fillColor= colorBy.getColorFromRecord(records,null,null,null);
			f.colorByValue=colorBy.lastValue;
			if(isNaN(colorBy.lastValue)) {
			    s.display='none';
			}
		    }
		    if(labelTemplate) {
			let l = labelTemplate.replace('${count}',records.length);
			l= l.replace('${colorbyvalue}',f.colorByValue)
			s =Utils.clone({},baseStyle,s);
			s.label = l;
		    }
		} 
		
		f.records  =records;
		f.style=s;
		f.textGetter  = textGetter;
	    });
	    this.hexmapLayer.redraw();
            if (colorBy.isEnabled()) {
		//		colorBy.displayColorTable();
		this.displayColorTable(colorBy, ID_COLORTABLE,colorBy.minValue,colorBy.maxValue);
	    }

	    this.notifyExternalDisplay();	    



	},
	


        addPoints: function(records, fields, points,bounds,debug) {
	    let mapType = this.getProperty('mapType');
	    if(mapType=='voronoi' || this.getProperty('doVoronoi',false)) {
		this.makeVoronoi(records,fields,points,bounds);
		if(!this.getShowPoints())
		    return;
	    }
	    if(mapType=='hex' ||
	       mapType=='triangle' ||
	       mapType=='square' ||
	       this.getDoHexmap() ||
	       this.getDoTrianglemap() ||
	       this.getDoSquaremap()) {
		this.makeHexmap(records,fields,points,bounds);
		if(!this.getShowPoints())
		    return;
	    }	    


	    if(this.getDoGridPoints()|| this.getDoHeatmap(false)) {
		let showMarkers = this.showMarkers;
		if(this.getHmShowPoints() || this.getShowPoints()) {
		    let show = true;
		    if(this.jq("showMarkersToggle").length>0) {
			show = this.jq("showMarkersToggle").is(":checked");
		    }
		    if(show) {
			this.createPoints(records, fields, points, bounds,debug);
			if(this.getHmShowToggle(false) && this.map.circles) {
			    this.map.setPointsVisibility(false);
			}
		    }
		}

		this.createHeatmap(records, fields, bounds);
		return;
	    }
	    if(this.getHtmlLayerField()) {
		this.createHtmlLayer(records, fields);
		if(!this.getShowPoints(false)) 
		    return;
	    }
	    if(debugMapTime)
		console.time('createPoints');
	    this.createPoints(records, fields, points, bounds,debug);
	    if(debugMapTime) {
		console.timeEnd('createPoints');
		console.log('#points:' + records.length);
	    }
	},
        createPoints: function(records, fields, points,bounds, debug) {
	    debug = debug ||displayDebug.displayMapAddPoints;
	    let _this = this;
	    let debugTimes  = false;
	    let features = [];
	    let featuresToAdd = [];
	    let pointsToAdd = [];
	    let linesToAdd = [];	    	    
	    //getColorByInfo: function(records, prop,colorByMapProp, defaultColorTable,propPrefix) {
            let colorBy = this.getColorByInfo(records,null,null,null,null,this.lastColorBy);
	    let hideNaN = this.getHideNaN();

	    this.lastColorBy = colorBy;
	    let cidx=0
	    let polygonField = this.getFieldById(fields, this.getPolygonField());
	    let polygonColorTable = this.getColorTable(true, "polygonColorTable",null);
	    let latlon = this.getProperty("latlon",true);
            let source = this;
            let radius = +this.getPropertyRadius(8);
	    let highlightRecords = this.getFilterHighlight();
	    let unhighlightFillColor = this.getUnhighlightColor();
	    let unhighlightStrokeWidth = this.getProperty("unhighlightStrokeWidth",0);
	    let unhighlightStrokeColor = this.getProperty("unhighlightStrokeColor","#aaa");
	    let unhighlightRadius = this.getUnhighlightRadius();
	    let strokeOpacity = this.getStrokeOpacity();
	    this.markers = {};

	    //change the order of the records if we are highlighting
	    if(highlightRecords) {
		let tmpRecords = [];
		let tmpPoints = [];		
		records.forEach((record,idx)=>{
		    if(!record.isHighlight(this)) {
			tmpRecords.push(record);
			tmpPoints.push(points[idx]);
		    }
		});
		records.forEach((record,idx)=>{
		    if(record.isHighlight(this)) {
			tmpRecords.push(record);
			tmpPoints.push(points[idx]);
		    }
		});

		records = tmpRecords;
		points = tmpPoints;
	    }



	    let radiusList = this.getRadiusList();
	    let numLocs = 0;
	    if(this.getScaleRadius()|| radiusList) {
		let seen ={};
		points.every(p=>{
		    let key = p.x+"_"+p.y;
		    if(!seen[key]) {
			numLocs++;
			seen[key] = true;
		    }
		    return true;
		});
	    }
	    if(this.getScaleRadius()) {
		let minRadius = this.getScaleRadiusMin();
		let maxRadius=this.getScaleRadiusMax();
		let maxLocs = this.getScaleRadiusMaxPoints();
		let perc = Math.min(1.0,numLocs/maxLocs);
		radius = Math.max(1,Math.round(maxRadius-(maxRadius-minRadius)*perc));
	    }
	    if(radiusList) {
		Utils.split(radiusList,',',true,true).every(tuple=>{
		    let pair = Utils.split(tuple,':',true,true);
		    if(pair.length!=2) return true;
		    let cnt =+pair[0];
		    if(numLocs<=cnt) {
			radius = +pair[1];
			return false;
		    }
		    return true;
		});
	    }


	    radius = Math.min(radius, this.getMaxRadius());
            let strokeWidth = +this.getPropertyStrokeWidth();
            let strokeColor = this.getPropertyStrokeColor();
            let isTrajectory = this.getDisplayProp(source, "isTrajectory", false);
            if (isTrajectory) {
		let tpoints = points.map(p=>{
		    return $.extend({},p);
		});
                let attrs = {
                    strokeWidth: this.getProperty('pathStrokeWidth',
						  this.getProperty("strokeWidth",2)),
                    strokeColor: this.getPathColor(this.getStrokeColor("blue")),
		    fillColor:this.getProperty("fillColor","transparent")
                }
		if(tpoints.length==1) {
		    featuresToAdd.push(this.map.createPoint(ID,  tpoints[0], attrs, null));
		} else {
		    if(this.getShowPathEndPoint()) {
			featuresToAdd.push(this.map.createMarker("startpoint", tpoints[0],RamaddaUtil.getCdnUrl("/icons/map/marker-green.png")));
			featuresToAdd.push(this.map.createMarker("endpoint", tpoints[tpoints.length-1],RamaddaUtil.getCdnUrl("/icons/map/marker-blue.png")));
		    }
		    let poly = this.map.createPolygon(ID, "", tpoints, attrs, null,true);
		    poly.noSelect = true;
		    featuresToAdd.push(poly);
		}
		if(!this.getProperty("showPoints")) {
		    this.addFeatures(featuresToAdd);
                    return;
		}
            }

            let latField1 = this.getFieldById(fields, this.getProperty("latField1"));
            let latField2 = this.getFieldById(fields, this.getProperty("latField2"));
            let lonField1 = this.getFieldById(fields, this.getProperty("lonField1"));
            let lonField2 = this.getFieldById(fields, this.getProperty("lonField2"));
	    let showSegments = this.getShowSegments(false);
	    let greatCircle = this.getUseGreatCircle();
            if (greatCircle && (
		showSegments && latField1 && latField2 && lonField1 && lonField2) ||
		polygonField) {
		if(!MapUtils.loadTurf(()=>{
		    this.createPoints(records, fields, points,bounds, debug);		
		})) {
		    return;
		}
	    }


            let sizeSegments = this.getSizeSegments();
            let sizeEndPoints = this.getProperty("sizeEndPoints", true);
            let showEndPoints = this.getProperty("showEndPoints", false);
            let endPointSize = parseInt(this.getProperty("endPointSize", "4"));
            let dfltEndPointSize = endPointSize;
            let segmentWidth = parseInt(this.getSegmentWidth(1));
            let dfltSegmentWidth = segmentWidth;
	    let haveLayer = this.getShowLayers() && (this.getProperty("geojsonLayer") || this.getProperty("kmlLayer") || this.getProperty("shapefileLayer"));
	    //	    if(haveLayer && Utils.isDefined(haveLayer.match) && 
	    if(!haveLayer) {
		if(this.getProperty('mapLayers')) {
		    this.getProperty('mapLayers').forEach(layer=>{
			if(layer.match) {
			    haveLayer = true;
			}
		    });
		}
	    }

            let showPoints = this.getProperty("showPoints", !haveLayer);
            let lineColor = this.getProperty("lineColor", "green");
	    let lineCap = this.getProperty('lineCap', 'round');
            let iconField = this.getFieldById(fields, this.getProperty("iconField"));

	    let makeLevelRange = v=>{
		if(!Utils.isDefined(v)) return null;
		let toks  = v.split(":");
		let r = {
		    min:Utils.stringDefined(toks[0])?+toks[0]:-1,
		    max:Utils.stringDefined(toks[1])?+toks[1]:100
		}
		if(isNaN(r.min)) r.min = -1;
		if(isNaN(r.max)) r.max = 100;
		return r;
	    };

	    this.glyphLevelRange =makeLevelRange(this.getProperty("glyphLevelRange"));
	    this.pointLevelRange =makeLevelRange(this.getProperty("pointLevelRange"));

	    let glyphs=RamaddaDisplayUtils.getGlyphs(this,fields,records);
	    let canvasBackground = this.getProperty('canvasBackground');
	    let canvasBorder = this.getProperty('canvasBorder');
	    let canvasWidth =this.getCanvasWidth();
	    let canvasHeight =this.getCanvasHeight();
	    let glyphSize =this.getProperty('glyphSize','32');
            let rotateField = this.getFieldById(fields, this.getProperty('rotateField'));	   
	    let rotateScale = this.getRotateScale();
	    let markerIcon = this.getMarkerIcon(this.getProperty('pointIcon'));
	    let usingIcon = markerIcon || iconField;
	    let showPoint = !usingIcon;
	    if(glyphs.length>0) showPoint=this.getProperty('showPoint',true);

            let iconSize = parseFloat(this.getProperty('iconSize',this.getProperty('radius',32)));
	    let iconMap = this.getIconMap();
	    let dfltShape = this.getProperty('defaultShape',null);
	    let dfltShapes = ['circle','triangle','star',  'square', 'cross','x', 'lightning','rectangle','church'];
	    let dfltShapeIdx=0;

	    let shapeBy = {
		id: this.getDisplayProp(source, 'shapeBy', null),
		field:null,
		map: {},
		labels:{},
		patterns:[]
	    }


	    if(this.getDisplayProp(source, 'shapeByMap', null)) {
		this.getDisplayProp(source, 'shapeByMap', null).split(',').forEach((pair)=>{
		    let tuple = pair.split(':');
		    shapeBy.map[tuple[0]] = tuple[1];
		    if(tuple[0].match('(\\*|\\.||\\+)')) {
			shapeBy.patterns.push({pattern:tuple[0],shape:tuple[1]});
			shapeBy.labels[tuple[0]] = tuple[2] ??tuple[0];
		    }

		})
	    }

	    let sizeBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records);

            for (let i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.getId() == shapeBy.id || ("#" + (i + 1)) == shapeBy.id) {
                    shapeBy.field = field;
		    if (field.isString()) shapeBy.isString = true;
                }
            }
            shapeBy.index = shapeBy.field != null ? shapeBy.field.getIndex() : -1;


            if (this.getProperty("showColorByMenu", false) && colorBy.field && !this.madeColorByMenu) {
                this.madeColorByMenu = true;
                let menu = HU.open(SELECT,[ATTR_CLASS,'ramadda-pulldown',
					   ATTR_ID,this.domId("colorByMenu")]);
                for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
                    if (!field.isNumeric() || field.isFieldGeo()) continue;
                    let extra = "";
                    if (colorBy.field.getId() == field.getId()) extra = "selected ";
                    menu += "<option value='" + field.getId() + "' " + extra + ">" + field.getLabel() + "</option>\n";
                }
                menu += HU.close(SELECT);
                this.writeHtml(ID_TOP_RIGHT, "Color by: " + menu);
                this.jq("colorByMenu").change(() => {
                    let value = this.jq("colorByMenu").val();
                    this.vectorMapApplied = false;
		    this.haveCalledUpdateUI = false;
                    this.setProperty("colorBy", value);
                    this.updateUI();
                });
            }



	    let dateMin = null;
	    let dateMax = null;

	    let dates = [];
            let justOneMarker = this.getPropertyJustOneMarker();

            for (let i = 0; i < records.length; i++) {
                let pointRecord = records[i];
		dates.push(pointRecord.getDate());
                if (dateMin == null) {
                    dateMin = pointRecord.getDate();
                    dateMax = pointRecord.getDate();
                } else {
                    let date = pointRecord.getDate();
                    if (date) {
                        if (date.getTime() < dateMin.getTime())
                            dateMin = date;
                        if (date.getTime() > dateMax.getTime())
                            dateMax = date;
                    }
                }
	    }


            if (dateMax) {
		if (this.getAnimationEnabled()) {
		    //TODO: figure out when to call this. We want to update the animation if it was from a filter change
		    //but not from an animation change. Hummmm.
		    //this.getAnimation().init(dateMin, dateMax,records);
		}
            }

	    this.removeFeatureLayer();
            let didColorBy = false;
            let seen = {};
	    let xnct =0;
	    let lastPoint;
	    let pathAttrs ={
		strokeColor: this.getProperty("pathColor",lineColor),
		strokeWidth: this.getPathWidth()
	    };

	    let fillColor = this.getFillColor();
	    let fillOpacity =  this.getFillOpacity();
	    let isPath = this.getIsPath();
	    if(this.getIsPathThreshold()>records.length) isPath=true;
	    if(isPath)
		showPoints = this.getProperty("showPoints", !isPath);

	    let groupByField = this.getFieldById(null,this.getGroupByField());
	    let groups;
	    if(groupByField)
		groups =  RecordUtil.groupBy(records, this, false, groupByField);
	    


	    let tooltip = this.getTooltip('${default}');
	    let haveTooltip = Utils.stringDefined(tooltip);
	    let highlight = this.getShowHighlight(this.getProperty("highlight"));
	    let highlightTemplate = this.getHighlightTemplate();
	    if(highlightTemplate)
		highlight=true;
	    
	    let highlightWidth = this.getHighlightWidth(300);
	    let highlightHeight = this.getHighlightHeight(-1);
	    let highlightSize = null;
	    if(highlightHeight>0) {
	    	highlightSize = MapUtils.createSize(highlightWidth,highlightHeight);
	    }
	    let addedPoints = [];
	    let textGetter = this.getTextGetter(fields);

	    let highlightGetter = f=>{
		if(f.record) {
                    return   HU.div([],this.getRecordHtml(f.record, fields, highlightTemplate|| tooltip));
                    return   HU.div([ATTR_STYLE,HU.css('background','#fff')],this.getRecordHtml(f.record, fields, highlightTemplate|| tooltip));
		}
		return null;
	    };	    
	    this.haveAddPoints = true;
	    this.recordToInfo = {};
	    let dummyUpLocation = this.fakeLocations();
	    let recordInfos = records.map((record,idx)=>{
		let recordInfo =  {
		    record:record,
		    features:[],
		    visible:true
		}
		if(!record.point) {
		    recordInfo.x = record.getLongitude();
		    recordInfo.y = record.getLatitude();
		    if(dummyUpLocation && isNaN(recordInfo.x)) {
			recordInfo.x = -105;
			recordInfo.y=40;
		    }
		} else {
		    recordInfo.x = record.point.x;
		    recordInfo.y = record.point.y;
		}


		this.recordToInfo[record.getId()]  =recordInfo;
		return recordInfo;
	    });




	    if(this.getHandleCollisions()) {
		let collisionTooltip = this.getCollisionTooltip('${default}');
		let collisionTextGetter = collisionTooltip==null?null:(records)=>{
		    let html = "#" + records.length+" records<hr class=ramadda-thin-hr>";
		    records.forEach(record=>{
			html+=HU.div([ATTR_STYLE,HU.css("border-bottom","1px solid #ccc")], this.getRecordHtml(record, null,collisionTooltip));
		    });
		    return html;
		};


		let collisionArgs = {
		    textGetter: collisionTextGetter,
		    fixed:this.getCollisionFixed(),
		    visible: false,
		    icon:this.getCollisionIcon(),
		    iconSize:this.getCollisionIconSize(),	
		    dotColor:this.getCollisionDotColor(),
		    dotOpacity:this.getCollisionDotOpacity(),
		    ringColor:this.getCollisionRingColor(),
		    ringWidth:this.getCollisionRingWidth(),		    		    
		    dotColorOn:this.getCollisionDotColorOn(),
		    dotRadius:this.getCollisionDotRadius(),
		    scaleDots:this.getPropertyCollisionScaleDots(),
		    labelTemplate:this.getCollisionLabelTemplate(),
		    labelColor:this.getCollisionLabelColor(),
		    labelFontSize:this.getCollisionLabelFontSize(),
		}

		let CH = new CollisionHandler(this.map, {
		    pointSize:this.getCollisionPointSize(),
		    collisionArgs:collisionArgs,
		    lineWidth: this.getProperty("collisionLineWidth","2"),			
		    lineColor: this.getProperty("collisionLineColor","#000"),
		    addCollisionLines:function(info,lines) {
			_this.addFeatures(lines,true);
		    },
		    setCollisionVisible: function(info,visible) {
			info.records.forEach(record=>{
			    let recordInfo = _this.recordToInfo[record.getId()];
			    if(!recordInfo) {
				return;
			    }
			    recordInfo.features.forEach(f=>{
				f.featureVisible = info.visible;
				_this.map.checkFeatureVisible(f,true);
			    });
			});
		    }
		});


		//First get the rounded point for each RecordInfo
		CH.initPoints(recordInfos);

		recordInfos.forEach((recordInfo,idx)=>{
		    let collisionPoint = recordInfo.collisionPoint;
		    if(collisionPoint ==null) return;
		    let cntAtPoint = CH.countAtPoint[collisionPoint];
		    if(cntAtPoint==1) {
			return;
		    } 
		    let record = recordInfo.record;
		    let info = CH.getCollisionInfo(collisionPoint);
		    info.addRecord(record);
		    recordInfo.collisionInfo = info;
		    recordInfo.visible = info.visible;		    
		    if(!collisionArgs.fixed) {
			let anglePer = 360/cntAtPoint;
			let lineOffset = CH.offset;
			let delta = cntAtPoint/8;
			if(delta>1)
			    lineOffset*=delta;
			let ep = Utils.rotate(collisionPoint.x,collisionPoint.y,collisionPoint.x,collisionPoint.y-lineOffset,
					      info.records.length*anglePer-180,true);
			let line = this.getMap().createLine("line-" + idx, "", collisionPoint.y,collisionPoint.x, ep.y,ep.x, {strokeColor:CH.lineColor,strokeWidth:CH.lineWidth});

			if(!info.visible) {
			    line.featureVisible = false;
			    this.map.checkFeatureVisible(line,true);
			}
			info.addLine(line);
			//set the rotated location of the point to use later
			recordInfo.x=ep.x;
			recordInfo.y=ep.y;
		    } else {
			recordInfo.dontShow = true;
		    }
		});
		CH.getCollisionInfos().forEach((info,idx)=>{
		    let dots = info.createDots(idx);
		    featuresToAdd.push(...dots);
		});
	    }


	    let featureCnt=0;
	    let sizeByFunc = function(percent, size) {
                if (sizeEndPoints &&!isNaN(percent)) {
		    endPointSize = dfltEndPointSize + parseInt(10 * percent);
                }
                if (sizeSegments) {
		    if(isNaN(percent)) {
			segmentWidth = dfltSegmentWidth + size;
		    } else {
			segmentWidth = dfltSegmentWidth + parseInt(10 * percent);
			segmentWidth=size;
			if(segmentWidth==0 || isNaN(segmentWidth)) segmentWidth=1;
		    }
                }
	    };


	    if(isPath && groups) {
		let pathWindowStrokeColor=this.getProperty('pathWindowStrokeColor');
		let pathWindowSize = this.getProperty('pathWindowSize',0);
		let pathWindowTime = this.getProperty('pathWindowTime');
		let pathWindowTimeMS;
		if(pathWindowTime)
		    pathWindowTimeMS = DataUtils.timeToMillis(pathWindowTime);
		let dots = [];
		groups.values.forEach(value=>{
		    let firstRecord = null;
		    let lastRecord = null;
		    let secondRecord = null;		    
		    let groupRecords=groups.map[value];
		    let length=groupRecords.length;
		    let windowStartIndex=-1;
		    if(pathWindowTime) {
			let last = groupRecords[groupRecords.length-1];
			if(last && last.recordTime) {
			    let endMS = last.recordTime.getTime();
			    let startMS = endMS-pathWindowTimeMS;
			    //			    console.log("START:" + new Date(startMS) +" end:" + new Date(endMS));
			    for(let idx=groupRecords.length-1;idx>=0;idx--) {
				let record = groupRecords[idx];
				if(!record || !record.recordTime) continue;
				if(record.recordTime.getTime()<startMS) {
				    break;
				}
				windowStartIndex=idx;
			    }
			    //			    console.dir('start index',windowStartIndex);
			}
		    } else if(pathWindowSize>0) {
			windowStartIndex = Math.max(0,length-pathWindowSize);
		    }
		    groups.map[value].forEach((record,idx)=>{
			if(!firstRecord) firstRecord=record;
			featureCnt++;
			if(lastRecord) {
			    let attrs = $.extend({},pathAttrs);
			    let color=colorBy.getColorFromRecord(record, pathAttrs.strokeColor,true);
			    attrs.strokeColor = color;
			    let inWindow  =false;
			    if(windowStartIndex>=0) {
				inWindow = idx>=windowStartIndex;
			    }				
			    if(pathWindowStrokeColor) {
				attrs.strokeColor=pathWindowStrokeColor;
			    }

			    if(!inWindow) {
				if(attrs.strokeWidth>0) {
				    let line = this.map.createLine("line-" + featureCnt, "", lastRecord.getLatitude(), lastRecord.getLongitude(), record.getLatitude(),record.getLongitude(),attrs);
				    featuresToAdd.push(line);
				    line.record=record;
				    line.textGetter=textGetter;
				}
			    } else {
				let percent = (idx-windowStartIndex)/(length-windowStartIndex);
				let dotPoint = {x:record.getLongitude(),y:record.getLatitude()}; 
				let dotAttrs =   {fillColor:color,
						  strokeWidth:0,
						  fillOpacity:Math.max(0.2,percent),
						  pointRadius:Math.max(2,Math.floor(percent*radius))};
				let dot = this.map.createPoint("endpoint",dotPoint,dotAttrs, null);
				dot.record=record;
				dot.textGetter = textGetter;
				dots.push(dot);
			    }
			}
			secondRecord = lastRecord;
			lastRecord = record;
			if(secondRecord) {
			    /*
			      let angleDeg = Utils.getBearing({x:lastRecord.getLongitude(),
			      
			      y:lastRecord.getLatitude()},
			      {x:secondRecord.getLongitude(),
			      y:secondRecord.getLatitude()});							  
			      //			    let endPoint = this.map.createPoint("endpoint", {x:lastRecord.getLongitude(),y:lastRecord.getLatitude()}, {fillColor:"red",strokeColor:"#000",pointRadius:6,graphicName:"arrow",rotation:angleDeg}, null);
			      //featuresToAdd.push(endPoint);
			      //                            featuresToAdd.push(endPoint);
			      */
			}

		    });
		    featuresToAdd.push(...dots);


		    if(lastRecord) {
			let color=  colorBy.getColorFromRecord(lastRecord, pathAttrs.strokeColor);
			if(secondRecord && this.getShowPathEndPoint(false)) {
			    let shape = this.getProperty("pathEndPointShape",null);
			    let angleDeg = Utils.getBearing({lon:secondRecord.getLongitude(),
							     lat:secondRecord.getLatitude()},
							    {lon:lastRecord.getLongitude(),
							     lat:lastRecord.getLatitude()});							  
			    let endPoint = this.map.createPoint("endpoint", {x:lastRecord.getLongitude(),y:lastRecord.getLatitude()}, {fillColor:color,strokeColor:"#000",pointRadius:6,graphicName:shape,rotation:angleDeg}, null);
			    featuresToAdd.push(endPoint);
			}
			if(this.getProperty("showPathStartPoint",false)) {
			    let endPoint = this.map.createPoint("startpoint", {x:firstRecord.getLongitude(),y:firstRecord.getLatitude()}, {fillColor:color,pointRadius:2}, null);
			    featuresToAdd.push(endPoint);
			}			
		    }
		});

	    }


	    let colorByEnabled = colorBy.isEnabled();
	    let graphicName = this.getPropertyShape();

	    let didMarker = false;
	    let times=[new Date()];



	    //main loop
	    recordInfos.forEach((recordInfo,idx)=>{
		if(recordInfo.dontShow) return;

		featureCnt++;
		let record = recordInfo.record;
		let point  = recordInfo;

		if(!point) {
                    point = MapUtils.createPoint(record.getLongitude(), record.getLatitude());
		} else {
		    if(!Utils.isDefined(point.x) || !Utils.isDefined(point.y)) return;
		}


		if(justOneMarker) {
		    debug = false;
		    if(didMarker) {
			if(debug)
			    console.log("didMarker");
			return;
		    }
                    if(this.justOneMarker)
			this.map.removeMarker(this.justOneMarker);
                    if(!isNaN(point.x) && !isNaN(point.y)) {
			didMarker = true;
                        this.justOneMarker= this.map.createMarker(id, [point.x,point.y], null, "", "");
			featuresToAdd.push(this.justOneMarker);
			if(debug) console.log("\tadding justOneMarker had initial position:" + this.hadInitialPosition);
			if(!this.hadInitialPosition) {
			    let loc = MapUtils.createLonLat(point.x,point.y);
			    if(debug) console.log("\tsetting center:" + loc);
			    this.map.setCenter(loc);
			}
                        return;
                    } else {
			return;
                    }
                }

                let values = record.getData();
                let props = {
		    strokeOpacity:strokeOpacity,
                    pointRadius: radius,
                    strokeWidth: strokeWidth,
                    strokeColor: strokeColor,
		    fillColor: fillColor,
		    fillOpacity: fillOpacity
                };

		if(shapeBy.field) {
		    let gv = values[shapeBy.index];
		    if(gv)  {
			let _gv = String(gv).toLowerCase();
			let shape = null;
			shapeBy.patterns.every(pattern=>{
			    if(_gv.match(pattern.pattern)) {
				shape =  pattern.shape;
				return false;
			    }
			    return true;
			});

			if(!shape) shape = shapeBy.map[_gv];


			if(!shape) {
			    if(dfltShape) {
				//				shape = shapeBy.map[_gv] =  dfltShape;
				shape =   dfltShape;
				shapeBy.labels[_gv] = gv;
			    } else {
				if(dfltShapeIdx>=dfltShapes.length)
				    dfltShapeIdx = 0;
				shape = shapeBy.map[_gv] = dfltShapes[dfltShapeIdx++];
				shapeBy.labels[_gv] = gv;
			    }
			}
			if(!shape)
			    shape = shapeBy.map[_gv];
			if(Utils.isDefined(shape)) {
			    props.graphicName = shape;
			}
			
		    }
		}


                segmentWidth = dfltSegmentWidth;
                props.pointRadius = sizeBy.getSize(values, props.pointRadius,sizeByFunc);
		if(props.pointRadius<0) return;
		if(isNaN(props.pointRadius) || props.pointRadius == 0) props.pointRadius= radius;
		let hasColorByValue = false;
		let colorByValue;
		let colorByColor;
		let theColor =  null;

		if(colorBy.compareFields.length>0) {
		    let maxColor = null;
		    let maxValue = 0;
		    colorBy.compareFields.forEach((f,idx)=>{
			let value = record.getData()[f.getIndex()];
			if(idx==0 || value>maxValue) {
			    maxColor = colorBy.colors[idx];
			    maxValue = value;
			}
		    });
		    colorByValue = maxValue;
		    theColor = maxColor;
		} else {
		    if(colorByEnabled) {
			let value = record.getData()[colorBy.index];
			if(hideNaN && isNaN(value)) return;
			colorByValue = value;
			theColor =  colorBy.getColorFromRecord(record, theColor,false);
			//if(idx<5) console.log("%cpt:" + value + " " + theColor,"background:" + theColor);
		    }
                }

		

		if(theColor) {
                    didColorBy = true;
		    hasColorByValue  = true;
		    colorByColor = props.fillColor = colorBy.convertColor(theColor, colorByValue);
		}
		if(highlightRecords && !record.isHighlight(this)) {
		    props.fillColor =  unhighlightFillColor;
		    props.strokeColor =  unhighlightStrokeColor;
		    props.strokeWidth=unhighlightStrokeWidth;
		    if(unhighlightRadius>0)
			props.pointRadius = unhighlightRadius;
		}

		if(polygonField) {
		    let s = values[polygonField.getIndex()];
		    let polygonProps ={};
		    $.extend(polygonProps,props);
		    polygonProps.fillColor = "transparent";
		    polygonProps.fillColor = props.fillColor;
		    if(polygonProps.strokeWidth==0)
			polygonProps.strokeWidth=1;
		    if(polygonColorTable) {
			if(cidx>=polygonColorTable.length) cidx=0;
			polygonProps.strokeColor=polygonColorTable[cidx++];
		    } else if(colorByColor) {
			polygonProps.strokeColor=colorByColor;
		    }
		    let polys = this.map.createPolygonFromString('',s, polygonProps,latlon,null);
		    polys.forEach(poly=>{
			poly.textGetter = textGetter;
			poly.record = record;
			let recordDate = record.getDate();
			if (recordDate) {
			    poly.date = recordDate.getTime();
			}
			featuresToAdd.push(poly);
		    });
		    polys.forEach(poly=>{
			featuresToAdd.push(poly);
		    });
		}


                if (showSegments && latField1 && latField2 && lonField1 && lonField2) {
                    let lat1 = values[latField1.getIndex()];
                    let lat2 = values[latField2.getIndex()];
                    let lon1 = values[lonField1.getIndex()];
                    let lon2 = values[lonField2.getIndex()];
                    let attrs = {};
                    if (props.fillColor)
                        attrs.strokeColor = props.fillColor;
                    else
                        attrs.strokeColor = lineColor;
		    attrs.strokeLinecap = lineCap;
		    attrs.strokeColor =   colorBy.getColorFromRecord(record, attrs.strokeColor);
                    attrs.strokeWidth = segmentWidth;
		    let line;
		    if(greatCircle) {
			let start = turf.point([lon1,lat1]);
			let end = turf.point([lon2,lat2]);
			let points = this.getTurfPoints(turf.greatCircle(start, end));
			let type = 'OpenLayers.Geometry.LineString';
			line =this.makeFeature(this.getMap(),type,attrs,points);		    
		    } else {
			line= this.map.createLine("line-" + featureCnt, "", lat1, lon1, lat2, lon2, attrs);
		    }
		    featuresToAdd.push(line);
		    line.record = record;
		    line.textGetter = textGetter;
		    if(highlight) {
			line.highlightTextGetter = highlightGetter;
			line.highlightSize = highlightSize;
		    }	
		    line.record = record;
                    featuresToAdd.push(line);
                    if (showEndPoints) {
                        let pointProps = {};
                        $.extend(pointProps, props);
                        pointProps.fillColor = attrs.strokeColor;
                        pointProps.strokeColor = attrs.strokeColor;
                        pointProps.pointRadius = dfltEndPointSize;
                        pointProps.pointRadius = endPointSize;
                        let p1 = MapUtils.createLonLat(lon1, lat1);
                        let p2 = MapUtils.createLonLat(lon2, lat2);
                        if (!Utils.isDefined(seen[p1])) {
                            seen[p1] = true;
			    let pt1 =this.map.createPoint("endpt-" + featureCnt, p1, pointProps);
			    featuresToAdd.push(pt1);
			    pt1.record = record;
			    pt1.textGetter = textGetter;
                            featuresToAdd.push(pt1);
                        }
                        if (!Utils.isDefined(seen[p2])) {
                            seen[p2] = true;
                            let pt2 = this.map.createPoint("endpt2-" + featureCnt, p2, pointProps);
			    featuresToAdd.push(pt2);
			    pt2.record = record;
			    pt2.textGetter = textGetter;
                            featuresToAdd.push(pt2);
                        }

                    }
		}
		let mapPoint=null;
		let recordFeatures =recordInfo.features;
		if(usingIcon) {
		    if(iconField) {
			let tuple = record.getData();
			let icon = tuple[iconField.getIndex()];
			if(iconMap) {
			    icon = iconMap[icon];
			    if(!icon) icon = this.getMarkerIcon(null,true);
			}
			let size = iconSize;
			if(sizeBy.index>=0) {
			    size = props.pointRadius;
			}
			mapPoint = this.map.createMarker("pt-" + featureCnt, point, icon, "pt-" + featureCnt,null,null,size);
			mapPoint.isMarker = true;
			recordFeatures.push(mapPoint);
			this.markers[record.getId()] = mapPoint;
			pointsToAdd.push(mapPoint);
		    } else  {
			let attrs = {
			}
			if(rotateField) {
			    attrs.rotation = rotateScale*record.getValue(rotateField.getIndex());
			}
			mapPoint = this.map.createMarker("pt-" + featureCnt, point, markerIcon, "pt-" + featureCnt,null,null,
							 iconSize,null,null,attrs);
			mapPoint.levelRange = this.pointLevelRange;
			mapPoint.textGetter= textGetter;
			pointsToAdd.push(mapPoint);
			mapPoint.isMarker = true;
			recordFeatures.push(mapPoint);
			this.markers[record.getId()] = mapPoint;
		    }
		}

		if(glyphs.length>0) {
		    let cid = HU.getUniqueId("canvas_");
		    let c = HU.tag(TAG_CANVAS,[ATTR_CLASS,"", ATTR_WIDTH,canvasWidth,ATTR_HEIGHT,canvasHeight,ATTR_ID,cid]);
		    $(document.body).append(c);
		    let canvas = document.getElementById(cid);
		    let ctx = canvas.getContext("2d");

		    if(canvasBackground) {
			ctx.fillStyle=canvasBackground;
			ctx.fillRect(0,0,canvasWidth,canvasHeight);
		    }
		    if(canvasBorder) {
			ctx.strokeStyle = canvasBorder;
			ctx.strokeRect(0,0,canvasWidth,canvasHeight);
		    }
		    ctx.strokeStyle ="#000";
		    ctx.fillStyle="#000";
		    let pending = [];
		    glyphs.forEach(glyph=>{
			let isReady =  glyph.draw({}, canvas, ctx, 0,canvasHeight,{record:record});
			if(isReady) pending.push(isReady);
		    });
		    let img = canvas.toDataURL();
		    let size = glyphSize;
		    if(sizeBy.index>=0) {
			size = props.pointRadius;
		    }
		    mapPoint = this.map.createMarker("pt-" + featureCnt, point, img, "pt-" + featureCnt,null,null,size);
		    mapPoint.levelRange=this.glyphLevelRange;
		    mapPoint.isMarker = true;
		    recordFeatures.push(mapPoint);
		    this.markers[record.getId()] = mapPoint;
		    pointsToAdd.push(mapPoint);
		}

		if(showPoint || colorByEnabled)  {
		    if(!props.graphicName)
			props.graphicName = graphicName;
		    if(rotateField) {
			props.rotation = rotateScale*record.getValue(rotateField.getIndex());
		    }
		    props.fillColor =   colorBy.getColorFromRecord(record, props.fillColor);
		    if(radius>0) {
			if(haveTooltip) {
			    props.cursor = 'pointer';
			}
			let propsToUse = props;
			mapPoint = this.map.createPoint("pt-" + featureCnt, point, propsToUse, null);
			mapPoint.levelRange = this.pointLevelRange;
			pointsToAdd.push(mapPoint);
			this.markers[record.getId()] = mapPoint;
			recordFeatures.push(mapPoint);
		    }
		}


		if(isPath && !groups && lastPoint) {
		    pathAttrs.strokeColor = colorBy.getColorFromRecord(record, pathAttrs.strokeColor);
		    let line = this.map.createLine("line-" + featureCnt, "", lastPoint.y, lastPoint.x, point.y,point.x,pathAttrs);
		    linesToAdd.push(line);
		}
		lastPoint = point;
		if(features) {
		    recordFeatures.forEach(f=>{features.push(f);});
		}
                let date = record.getDate();

		recordFeatures.forEach(mapPoint=>{
		    if(highlight) {
			mapPoint.highlightTextGetter = highlightGetter;
			mapPoint.highlightSize = highlightSize;
		    }
		    mapPoint.record = record;
		    mapPoint.textGetter = textGetter;
		    mapPoint.hasColorByValue = hasColorByValue;
		    mapPoint.colorByValue= colorByValue;
		    mapPoint.colorByColor = colorByColor;
		    if (date) {
			mapPoint.date = date.getTime();
		    }
		    if(!recordInfo.visible) {
			mapPoint.featureVisible = false;
			this.map.checkFeatureVisible(mapPoint,true,records.length<20);
		    }
		});

		if(recordInfo.collisionInfo) {
		    recordInfo.collisionInfo.addFeatures(recordFeatures);
		}
	    });
	    
	    times.push(new Date());
	    if(showPoints) {
		this.addFeatures(pointsToAdd);
	    }

	    this.addFeatures(linesToAdd);
	    this.myPoints = pointsToAdd;
	    this.addFeatures(featuresToAdd);
	    times.push(new Date());
	    if(debugTimes)
		Utils.displayTimes("map: #records:" + records.length+" times:",times, true,["create markers","add features"]);


	    if(records.length>0 && this.getProperty("selectFirstRecord")&& !this.haveSelectedFirstRecord) {
		this.haveSelectedFirstRecord = true;
		let record = records[0];
		this.propagateEventRecordSelection({record:record});
		let displayDiv = this.getProperty("displayDiv", null);
		if(displayDiv && this.textGetter) {
		    $("#" + displayDiv).html(this.textGetter({record:record}));
		}
		let marker =  this.markers[record.getId()];
		if(marker) {
		    this.map.handleFeatureclick(null,marker);
		}
	    }

	    if (showSegments) {
		this.map.centerOnMarkers();
	    }


	    let legendSide = this.getSizeByLegendSide();
	    if(legendSide) {
		let legend = sizeBy.getLegend(5,fillColor,legendSide=="left" || legendSide=="right");
		if(legend !="") {
		    let label = this.getSizeByLegendLabel();
		    if(label) legend=HU.div([ATTR_STYLE,'text-align:center;font-weight:bold'],label)+legend;
		    let style = this.getSizeByLegendStyle();
		    if(style) legend = HU.div([ATTR_STYLE,style],legend);
		    this.jq(ID_SIZEBY_LEGEND).html(legend);
		    this.callingUpdateSize = true;
		    this.map.getMap().updateSize();
		    this.callingUpdateSize = false;
		}
	    }
	    times = [new Date()];
	    if (didColorBy) {
		this.showColorTable(colorBy);
	    }
	    this.jq(ID_BOTTOM).append(HU.div([ATTR_ID,this.domId(ID_SHAPES)]));
	    times.push(new Date());
	    //	    Utils.displayTimes("final map points:",times, true);

	    if(iconField&& iconMap) {
		let html = "";
		for(a in iconMap) {
		    html+=HU.image(iconMap[a],["width","32"]) +" " + a+" ";
		}
		this.jq(ID_SHAPES).html(HU.center(html));
	    }

	    if(shapeBy.field) {
		let shapes = shapeBy.field.getLabel()+": ";
		for(v in shapeBy.map) {
		    let label = shapeBy.labels[v]??v;
		    let shape = shapeBy.map[v];
		    if(shape=="circle") shape=HU.getIconImage("fa-circle");
		    else if(shape=="square") shape=HU.getIconImage("fa-square");		    
		    else if(shape=="rectangle") shape=HU.getIconImage("fa-square");		    
		    else if(shape=="star") shape=HU.getIconImage("fa-star");
		    else if(shape=="diamond") shape=HU.getIconImage("fa-diamond");		    		    
		    else if(shape=="triangle") shape=HU.getIconImage("/icons/triangle.png",["width","16px"]);		    
		    else if(shape=="lightning") shape=HU.getIconImage("/icons/lightning.png",["width","16px"]);		    
		    else if(shape=="cross") shape=HU.getIconImage("/icons/cross.png",["width","16px"]);		    
		    else if(shape=="church") shape=HU.getIconImage("fa-cross");
		    shapes+=shape+" " + label +SPACE2;
		}
		this.jq(ID_SHAPES).html(HU.center(shapes));
	    }

	    if (this.getProperty("animationTakeStep", false)) {
		this.getAnimation().doNext();
	    }

	    if(this.pointLevelRange || this.glyphLevelRange) {
		this.checkLevelRange([this.myFeatureLayer],true);
	    }		


        },

	getTextGetter:function(fields,showCount) {
	    let tooltip = this.getTooltip('${default}');
	    return  this.textGetter = f=>{
		if(!Utils.stringDefined(tooltip)) {
		    if(debugPopup) console.log("No tooltip");
		    return null;
		}

		let records;
		if(f.record) records = [f.record];
		else records = f.records;
		if(!records || records.length==0) return null;
		if(this.properties.myTextGetter) {
		    let popup= this.properties.myTextGetter(this,records);
		    if(popup) return popup;
		}

		let text ='';
		let tooltipTemplate=this.getProperty('tooltipTemplate');
		let tooltipHeader=this.getProperty('tooltipHeader');		
		if(tooltipHeader) {
		    text+=tooltipHeader.replace("${count}",records.length);
		} else if(showCount && records.length>0) {
		    text+=HU.b('Count:  ') + records.length+'<br>';
		}

		records.forEach((record,idx)=>{
		    let v = this.getRecordHtml(record, fields, tooltip);
		    if(tooltipTemplate)
			v = tooltipTemplate.replace('${value}',v);
		    else   if(idx>0) text+='<thin_hr/>';
		    text +=   v;
		});
		if(debugPopup) console.log("textGetter: getRecordHtml:"  + text);
		if(text=="") return null;
		
		let  tabs = [];
		tabs.push({label:'Properties', contents:text});
		let mapDiv;
		let theRecord;
		if(records.length>0 && this.getShowMapInTooltip()) {
		    theRecord = records[0];
		    let lat = theRecord.getLatitude();
		    let lon = theRecord.getLongitude();		    
		    mapDiv= HU.getUniqueId('');
		    let div  = HU.div([ATTR_ID,mapDiv,ATTR_STYLE,HU.css('height','400px')]);
		    tabs.push({label:'Overview Map', contents:div});
		}
		if(tabs.length==1) {
		    return text;
		}

		let t =  HU.makeTabs(tabs);
		let tabInit = t.init;	
		let popupInit = () =>{
		    tabInit();
		    if(!mapDiv) return;
		    var params = {
			initialZoom:14,
			mapCenter:theRecord.getLongitude()+','+ theRecord.getLatitude(),
			defaultMapLayer:this.getTooltipMapLayer("osm"),
		    };
		    let theMap = new RepositoryMap(mapDiv, params);
		    theMap.initMap(false);
		}
		t.init = popupInit;
		return t;
	    };
	},


        addLabels:function(records, fields) {
	    let limit = this.getLabelLimit(1000);
	    if(records.length>limit) return;
            let labelTemplate = this.getLabelTemplate();
            let labelRecordTemplate = this.getProperty('labelRecordTemplate');
	    //	    if(!labelRecordTemplate) return;
	    let labelKeyField;
	    if(this.getLabelKeyField()) {
		labelKeyField = this.getFieldById(fields,this.getLabelKeyField());
	    }
            if(!labelTemplate && !labelKeyField) return;
	    let doUniqueLabelPosition=this.getProperty('doUniqueLabelPosition',true);
	    let labelPositions = {};
	    let pixelsPerCell = 10;
            let width = this.map.getMap().viewPortDiv.offsetWidth;
            let height = this.map.getMap().viewPortDiv.offsetHeight;
	    let bounds = this.map.getBounds();
	    let numCellsX = Math.round(width/pixelsPerCell);
	    let numCellsY = Math.round(height/pixelsPerCell);	    
	    let cellWidth = (bounds.right-bounds.left)/numCellsX;
	    let cellHeight = (bounds.top-bounds.bottom)/numCellsY;	    
	    let grid = {};
	    if(labelKeyField) labelTemplate= "${_key}";
	    labelTemplate = labelTemplate.replace(/_nl_/g,"\n");
	    let labelStyle = {
                fontColor: this.getProperty("labelFontColor","#000"),
		textBackgroundFillColor:this.getLabelBackground(),
		textBackgroundStrokeColor:this.getLabelStrokeColor(),
		textBackgroundStrokeWidth:this.getLabelStrokeWidth(),				
                fontSize: this.getProperty("labelFontSize","10pt"),
                fontFamily: this.getProperty("labelFontFamily","'Open Sans', Helvetica Neue, Arial, Helvetica, sans-serif"),
                fontWeight: this.getProperty("labelFontWeight","plain"),
                labelAlign: this.getProperty("labelAlign","cc"),
                labelXOffset: this.getProperty("labelXOffset","0"),
                labelYOffset: this.getProperty("labelYOffset","0"),
                labelOutlineColor:this.getProperty("labelOutlineColor","#fff"),
                labelOutlineWidth: this.getProperty("labelOutlineWidth","0"),
		labelSelect:true,
	    };

	    if(!this.map.labelLayer) {
		this.map.labelLayer = MapUtils.createLayerVector("Labels", {
		    styleMap: MapUtils.createStyleMap({'default':labelStyle}),
                });
		this.map.addVectorLayer(this.map.labelLayer, true);
                this.map.labelLayer.setZIndex(100);
	    }


	    let keyMap={};
	    let keyLegend="";
	    let features =  [];
            let seen = {};
	    let colorBy = this.getProperty("colorBy");
	    let sizeBy = this.getProperty("sizeBy");
	    let keyIndex = 0;
	    let alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
	    let  keys = [];
	    for(let j=0;j<3;j++) {
		alpha.forEach(c=>{
		    let cc = "";
		    for(let i=0;i<=j;i++) {
			cc+=c;
		    }
		    keys.push(cc);
		});
	    }
	    let labelFeatures = [];
            for (let i = 0; i < records.length; i++) {
		let record = records[i];
		let lat = record.getLatitude();
		let lon = record.getLongitude();		
		let point = {x:record.getLongitude(),y:record.getLatitude()};
                let center = MapUtils.createPoint(point.x, point.y);
                center.transform(this.map.displayProjection, this.map.sourceProjection);
		let text = this.applyRecordTemplate(record,this.getDataValues(record),null, labelTemplate);
		let style = $.extend({label:text},labelStyle);
		let labelFeature = MapUtils.createVector(center,null,style);
                labelFeature.noSelect = true;
                labelFeature.attributes = {};
                labelFeature.attributes[RECORD_INDEX] = (i+1);
                labelFeature.attributes["recordIndex"] = (i+1)+"";
		if(labelRecordTemplate) {
		    labelFeature.attributes['recordtemplate'] = text;
		}
		if(labelKeyField) {
		    let v = labelKeyField.getValue(record);
		    if(!keyMap[v]) {
			if(keyIndex>=keys.length) keyIndex=0;
			keyMap[v] = keys[keyIndex++];
			keyLegend+=keyMap[v]+": " + v+"<br>";
		    }
		    labelFeature.attributes["_key"] = keyMap[v];
		    style.label = style.label.replace('${_key}',keyMap[v]);
                }
                features.push(labelFeature);
	    }

	    if(!this.haveAddedZoomListener) {
		this.haveAddedZoomListener = true;
		if(this.getDeclutterLabels()) {
		    this.getMap().getMap().events.register('zoomend', '', () =>{
			Utils.bufferedCall(this.getId()+'_checklabels', 
					   ()=>{this.declutterLabels();});
		    },true);
		    this.getMap().getMap().events.register('moveend', '', () =>{
			Utils.bufferedCall(this.getId()+'_checklabels', 
					   ()=>{this.declutterLabels();});
		    },true);
		}
	    }

	    if(keyLegend.length>0) {
		if(!this.legendId) {
		    this.legendId = this.domId("legendid");
		    this.jq(ID_RIGHT).append(HU.div([ATTR_ID,this.legendId,
						     ATTR_CLASS,"display-map-legend",ATTR_STYLE, HU.css("max-height",this.getHeight("400px"))]));
		}
		this.jq("legendid").html(keyLegend);
	    }
	    if(this.labelFeatures)
		this.map.labelLayer.removeFeatures(this.labelFeatures);
            this.map.labelLayer.addFeatures(features);
	    this.labelFeatures = features;
	    if(this.getDeclutterLabels()) {
		this.declutterLabels();
	    }
	    $("#" + this.map.labelLayer.id).css("z-index",900);
        },


	declutterLabels:function() {
	    if(!this.labelFeatures) return;
	    MapUtils.declutter(this.getMap(), this.labelFeatures,this.getDeclutterArgs());
	    this.map.labelLayer.redraw();
	},
	getDeclutterArgs:function() {
	    let get = v=>{
		if(!v) return null;
		return +v;
	    }
	    let args ={
		fontSize: this.getProperty("labelFontSize","10pt"),
		padding: +this.getProperty('labelDeclutterPadding',1),
		granularity: +this.getProperty('labelDeclutterGranularity',1),		
		pixelsPerLine:get(this.getProperty('labelDeclutterPixelsPerLine')),
		pixelsPerCharacter:get(this.getProperty('labelDeclutterPixelsPerCharacter'))
	    };
	    return args;
	},
	
        handleEventRemoveDisplay: function(source, display) {
            if (!this.map) {
                return;
            }
            let mapEntryInfo = this.mapEntryInfos[display];
            if (mapEntryInfo != null) {
                mapEntryInfo.removeFromMap(this.map);
            }
            let feature = this.findFeature(display, true);
            if (feature != null) {
                if (feature.line != null) {
                    this.map.removePolygon(feature.line);
                }
            }
        },
        findFeature: function(source, andDelete) {
            for (let i in this.features) {
                let feature = this.features[i];
                if (feature.source == source) {
                    if (andDelete) {
                        this.features.splice(i, 1);
                    }
                    return feature;
                }
            }
            return null;
        },

        getMarkerIcon: function(dflt,autoVersion) {
            if (this.getProperty("markerIcon")) {
                let icon = this.getProperty("markerIcon");
		if(icon.startsWith('cdn:')) {
		    icon=markerIcon.replace('cdn:','');
                    icon =  RamaddaUtil.getCdnUrl(icon);
		}
                return icon;
            }
	    if(dflt) return dflt;
	    if(!autoVersion) return null;
            displayMapCurrentMarker++;
            if (displayMapCurrentMarker >= displayMapMarkers.length) displayMapCurrentMarker = 0;
            return RamaddaUtil.getCdnUrl("/lib/openlayers/v2/img/" + displayMapMarkers[displayMapCurrentMarker]);
        },
	highlightMarkers:null,
        handleEventRecordHighlight: function(source, args) {
	    SUPER.handleEventRecordHighlight.call(this,source,args);
	    if(displayDebug.handleEventRecordSelect)
		this.logMsg("handleEvent");
	    
	    if(this.getRecordHighlightFeature() ||
	       isNaN(args.record.getLatitude()) ||
	       isNaN(args.record.getLongitude())) {
		if(this.recordToFeature) {
		    let feature = this.recordToFeature[args.record.getId()];
		    if(this.highlightedFeature) {
			this.getMap().unhighlightFeature(this.highlightedFeature);
		    }
		    this.highlightedFeature = feature;
		    if(feature) {
			let style = {};
			if(feature.style) style = $.extend(style,feature.style);
			style = $.extend(style,{
			    strokeColor: this.getRecordHighlightStrokeColor(),
			    strokeWidth: this.getRecordHighlightStrokeWidth(3)}
					);
			this.getMap().highlightFeature(feature,style);
			
		    }
		}
	    } else {
		let records = args.records??[args.record];
		records.forEach((record,idx)=>{
		    this.highlightPoint(record.getLatitude(),record.getLongitude(),args.highlight,idx==0,idx!=0);
		});
	    }
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
            if (!this.map) {
                return;
            }
	    args.highlight = true;
            if (!this.getShowRecordSelection(true)) {
		return;
	    }
	    this.handleEventRecordHighlight(source,args);
	    //For now return
	    if(true) return;

            let record = args.record;
            if (record.hasLocation()) {
                let latitude = record.getLatitude();
                let longitude = record.getLongitude();
                if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) return;
                let point = MapUtils.createLonLat(longitude, latitude);



                let marker = this.myMarkers[source];
                if (marker != null) {
                    this.map.removeMarker(marker);
                }
                let icon = displayMapMarkerIcons[source];
                if (icon == null) {
                    icon = this.getMarkerIcon(null,true);
                    displayMapMarkerIcons[source] = icon;
                }
                this.myMarkers[source] = this.map.addMarker(source.getId(), point, icon, "", args.html, null, 24);
            }
        }
    });
}

function MapEntryInfo(entry) {
    RamaddaUtil.defineMembers(this, {
        entry: entry,
        marker: null,
        rectangle: null,
        removeFromMap: function(map) {
            if (this.marker != null) {
                map.removeMarker(this.marker);
            }
            if (this.rectangle != null) {
                map.removePolygon(this.rectangle);
            }
            if (this.polygon != null) {
                map.removePolygon(this.polygon);
            }
            if (this.circle != null) {
                map.removePoint(this.circle);
            }
        }

    });
}









const DISPLAY_MAPGRID = "mapgrid";
const DISPLAY_MAPCHART = "mapchart";
const DISPLAY_MAPARRAY = "maparray";
const DISPLAY_MAPSHRINK = "mapshrink";
const DISPLAY_MAPIMAGES = "mapimages";

addGlobalDisplayType({
    type: DISPLAY_MAPGRID,
    label: "Map Grid",
    category:CATEGORY_MAPS,
    preview: "mapgrid.png",
    desc:"Can display US States or World countries",    
});

addGlobalDisplayType({
    type: DISPLAY_MAPCHART,
    label: "Map Chart",
    requiresData: true,
    category:CATEGORY_MAPS,
    preview:"mapchart.png",
    desc:"Plot numeric data as heights. Can display US States, European countries or world countries",        
});


addGlobalDisplayType({
    type: DISPLAY_MAPSHRINK,
    label: "Map Shrink",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Show values as relative size of map regions","mapshrink.png","Can display US States, European countries or world countries"),            
});


addGlobalDisplayType({
    type: DISPLAY_MAPARRAY,
    label: "Map Array",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Colored map regions displayed separately","maparray.png","Can display US States, European countries or world countries"),                
});
addGlobalDisplayType({
    type: DISPLAY_MAPIMAGES,
    label: "Map Images",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Display images in map regions","mapimage.png","Can display US States, European countries or world countries"),                    
});



let ramaddaGridState = {
    grids:{
    },
    loading:{
    }

};

function RamaddaMapgridDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MAPGRID, properties);
    let myProps = [
	{label:'Grid Map Attributes'},
	{p:'localeField',ex:''},
	{p:'grid',ex:'countries|us'},
	{p:'cellSize',ex:'30',tt:'use 0 for flexible width'},
	{p:'cellHeight',ex:'30'},
	{p:'showCellLabel',ex:'false'},
    ];
    myProps.push(...RamaddaDisplayUtils.sparklineProps);

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        displayData: function(reload) {
	    this.updateUI();
	},
	handleEventFieldsSelected: function(source, fields) {
	    if(this.getProperty("selectedFieldIsColorBy") && fields.length>0) {
		this.colorByFieldChanged(fields[0]);
	    }
        },
	colorByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("colorBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({colorByFieldChanged:true});
	},
	updateUI: function() {
	    let what = this.getProperty("grid","us");
	    let grid = ramaddaGridState.grids[what];
	    if(!grid) {
		if(ramaddaGridState.loading[what]) return;
		ramaddaGridState.loading[what] = true;
		let url = RamaddaUtil.getCdnUrl("/resources/grid_"+ what+".json");
		$.getJSON(url, ( data ) =>{
		    ramaddaGridState.grids[what] = data;
		    this.updateUI();
		}).fail(function(err) {
		    console.log( "error loading " + url);
		    console.dir(err)
		})
		return;
	    }


	    let records = this.filterData();
	    if(!records) return;
            let fields = this.getData().getNonGeoFields();
	    let localeField = this.getFieldById(fields,this.getProperty("localeField","state"));
	    if(localeField==null) {
		localeField = this.getFieldById(fields,"state");
	    }
	    let minx = Number.MAX_VALUE;
	    let miny = Number.MAX_VALUE;
	    let maxx = Number.MIN_VALUE;
	    let maxy = Number.MIN_VALUE;
	    let map = {};


	    grid.forEach(o=>{
		minx = Math.min(minx,o.x);
		maxx = Math.max(maxx,o.x);
		miny = Math.min(miny,o.y);
		maxy = Math.max(maxy,o.y);
		map[this.domId("cell_" +o.x+ "_"+o.y)] = o;
	    });

            let colorBy = this.getColorByInfo(records);
	    let sparkLinesColorBy = this.getColorByInfo(records,"sparklineColorBy");
	    let strokeColorBy = this.getColorByInfo(records,"strokeColorBy","strokeColorByMap");
	    let sparkLineField = this.getFieldById(fields,this.getProperty("sparklineField"));
	    let table =HU.open(TABLE,[WIDTH,"100%"]);
	    let width = this.getProperty("cellWidth", this.getProperty("cellSize",0));
	    let height = this.getProperty("cellHeight",width);
	    if(height==0) height=30;
	    let showLabel  = this.getProperty("showCellLabel",true);
	    let cellStyle  = this.getProperty("cellStyle","");
	    let cellMap = {};
	    for(let y=1;y<=maxy;y++) {
		table+=HU.open(TR);
		for(let x=1;x<=maxx;x++) {
		    let id = this.domId("cell_" +x+ "_"+y);
		    let o = map[id];
		    let extra = " id='" + id +"' ";
		    let style = HU.css('position','relative','margin','1px','vertical-align','center','text-align','center',HEIGHT, height+"px");
		    if(width>0) style+=HU.css(WIDTH,width+'px');
		    let c = "";
		    if(o) {
			style+="background:#ccc;" + cellStyle;
			if(!sparkLineField) {
			    extra += " title='" + o.name +"' ";
			}
			extra += HU.attr(CLASS,'display-mapgrid-cell');
			c = HU.div([STYLE,HU.css('padding-left','3px')], (showLabel?o.codes[0]:""));
			o.codes.forEach(c=>cellMap[c] = id);
			cellMap[o.name] = id;
		    }
		    let td = HU.td([],"<div " + extra +" style='" + style +"'>" + c+"</div>");
		    table+=td;
		}
		table+=HU.close(TR);
	    }
	    table +=HU.tr([],HU.td(["colspan", maxx],"<br>" +   HU.div([ID,this.domId(ID_COLORTABLE)])));
	    table+=HU.close(TABLE);
	    this.setContents(HU.center(table));

	    let states = [];
	    let stateData = this.stateData = {
	    }
	    let minData = 0;
	    let maxData = 0;
	    let seen = {};
	    let contents = this.getContents();
	    for(let i=0;i<records.length;i++) {
		let record = records[i]; 
		let tuple = record.getData();
		let state = tuple[localeField.getIndex()];
		let cellId = cellMap[state];
		if(!cellId) {
		    cellId = cellMap[state.toUpperCase()];
		}
		if(!cellId) {
		    //		    console.log("Could not find cell:" + state);
		    continue;
		}
		$("#"+cellId).attr(RECORD_INDEX,i);

		if(!stateData[state]) {
		    states.push(state);
		    stateData[state] = {
			cellId: cellId,
			data:[],
			records:[]
		    }
		}
		if(sparkLineField) {
		    let value = record.getValue(sparkLineField.getIndex());
		    if(!isNaN(value)) {
			minData = i==0?value:Math.min(minData, value);
			maxData = i==0?value:Math.max(maxData, value);
			stateData[state].data.push(value);
			stateData[state].records.push(record);
		    }
		}

		let colorByEnabled = colorBy.isEnabled();

		//TODO: sort the state data on time
                if (colorByEnabled) {
                    let value = record.getData()[colorBy.index];
		    let color = colorBy.getColorFromRecord(record);
		    let cell = contents.find("#" + cellId);
		    cell.css("background",color);
		    let foreground = Utils.getForegroundColor(color);
		    if(foreground) {
			cell.css('color', foreground);
		    }
		    cell.attr(RECORD_INDEX,i);
                }
		if (strokeColorBy.isEnabled()) {
                    let value = record.getData()[strokeColorBy.index];
		    let color = strokeColorBy.getColor(value, record);
		    let cell = contents.find("#" + cellId);
		    cell.css("border-color",color);
		    cell.css("border-width","2px");
                }
	    }

	    if(sparkLineField) {
		let vOffset = 0;
		states.forEach((state,idx)=>{
		    let s = stateData[state];
		    let innerId = s.cellId+"_inner";
		    let cellWidth = width;
		    if(cellWidth==0) {
			cellWidth = $("#" + s.cellId).width();
		    }
		    let style = HU.css(WIDTH,cellWidth+'px',HEIGHT, (height-vOffset) +'px','position','absolute','left','0px','top', vOffset+'px');
		    let innerDiv = HU.div([ID, innerId, STYLE,style]);
		    $("#" + s.cellId).append(innerDiv);
		    drawSparkline(this, "#"+innerId,cellWidth,height-vOffset,s.data,s.records,minData,maxData,sparkLinesColorBy);
		});
	    }

	    this.makePopups(contents.find(".display-mapgrid-cell"), records);
	    let _this = this;
	    contents.find(".display-mapgrid-cell").click(function() {
		let record = records[$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });	
	    if(!sparkLineField) {
		this.makeTooltips(contents.find(".display-mapgrid-cell"), records, null, "${default}");
	    }
            if (colorBy.index >= 0) {
		colorBy.displayColorTable();
	    }
	    if (sparkLinesColorBy.index >= 0) {
		sparkLinesColorBy.displayColorTable();
	    }
	},

        handleEventRecordSelection: function(source, args) {
	    let contents = this.getContents();
	    if(this.selectedCell) {
		this.selectedCell.css("border",this.selectedBorder);
	    }
	    let index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    this.selectedCell = contents.find(HU.attrSelect(RECORD_INDEX, index));
	    this.selectedBorder = this.selectedCell.css("border");
	    this.selectedCell.css("border","1px solid red");
	},
    })}




const ID_BASEMAP = "basemap";
function RamaddaOtherMapDisplay(displayManager, id, type, properties) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    let myProps = [
	{label:'Base map properties'},
	{p:'regionField',ex:''},
	{p:'mapFile',ex:'usmap.json|countries.json',d:"usmap.json"},
	{p:'mapEntry',tt:'entry id of geojson map file'},
	{p:'mapFeature',tt:'feature name to match data with',canCache:true},		
	{p:'valueField',tt:'Field to get the height of each polygon from',ex:''},
	{p:'skipRegions',ex:'Alaska,Hawaii'},
	{p:'pruneMissing',ex:'true'},				
	{p:'mapBackground',ex:'transparent'},
	{p:'transforms',ex:"Alaska,0.4,30,-40;Hawaii,2,50,5;Region,scale,offsetX,offsetY"},
	{p:'prunes',ex:'Alaska,100;Region,maxCount'},
	{p:'mapWidth',ex:'600'},
	{p:'mapHeight',ex:'400'},
	{p:'maxLon'},
	{p:'minLon'},
	{p:'maxLat'},
	{p:'minLat'},			
	{p:"strokeColor"},
	{p:"strokeWidth"},
	{p:"missingFill"},			
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        checkLayout: function() {
            this.updateUI();
        },
        makeMap: function() {
	},
	makePoly:function(polygon) {
	    let poly = [];
	    polygon.forEach(point=>{
		let lon = point[0];
		let lat = point[1];
		if(isNaN(lon) || isNaN(lat)) return;
		poly.push({x:lon,y:lat});
	    });
	    return poly;
	},
	findValues:function(region, valueMap) {
	    if(valueMap[region]) return valueMap[region];
	    let values = null;
	    if(!this.aliasMap[region]) {
		return null;
	    }
	    this.aliasMap[region].forEach(alias=>{
		if(valueMap[alias]) values = valueMap[alias];
	    });
	    return values;
	},
	makeValueMap: function(records,needsValue) {
	    let regionField=this.getFieldById(null,this.getPropertyRegionField());
	    let valueField=this.getFieldById(null,this.getPropertyValueField());	    
	    if(!regionField) {
                this.displayError("No region field specified");
		return null
	    }
	    if(!valueField && needsValue) {
                this.displayError("No value field specified");
		return null
	    }	    
	    //If the colorBy wasn't set then use the value field
	    if(valueField) {
		if(this.getProperty("colorBy")==null) this.setProperty("colorBy",valueField.getId());
		if(this.getProperty("sizeBy")==null) this.setProperty("sizeBy",valueField.getId());	    
	    }
	    let valueMap = {};
	    this.valueRange = {
		min: null,
		max:null
	    };
	    this.idToRecord = {};
	    records.forEach(record=>{
		let region = record.getValue(regionField.getIndex());
		this.idToRecord[record.getId()] = record;
		let values  = valueMap[region] = {
		    record:record
		}
		if(valueField) { 
		    let value = record.getValue(valueField.getIndex());
		    values.value = value;
		    this.valueRange.min = this.valueRange.min===null?value:Math.min(value,this.valueRange.min);
		    this.valueRange.max = this.valueRange.max===null?value:Math.max(value,this.valueRange.max);
		}
	    });
	    if(valueField) {
		records.forEach(record=>{
		    let region = record.getValue(regionField.getIndex());
		    let values  = valueMap[region];
		    let value = values.value
		    let percent = (value-this.valueRange.min)/(this.valueRange.max-this.valueRange.min);
		    values.percent = percent;
		});
	    }
	    return valueMap;
	},
	writeMap:function(skipHeight)  {
	    let width = this.getMapWidth(this.getProperty("width",800));
	    let css = HU.css(BACKGROUND,this.getMapBackground("transparent"),WIDTH,HU.getDimension(width));
	    let height;
	    if(!skipHeight) {
		height = this.getMapHeight(this.getProperty("height"));
		let mw = this.mapRange.maxLon-this.mapRange.minLon;
		let mh = this.mapRange.maxLat-this.mapRange.minLat;
		if(!height)
		    height = mh/mw*width;
		if(isNaN(height)) height=400; 
		css+=HU.css(HEIGHT,HU.getDimension(height));
	    }
	    
	    this.mapRange.maxLon= this.getPropertyMaxLon(this.mapRange.maxLon);
	    this.mapRange.minLon= this.getPropertyMinLon(this.mapRange.minLon);
	    this.mapRange.maxLat= this.getPropertyMaxLat(this.mapRange.maxLat);
	    this.mapRange.minLat= this.getPropertyMinLat(this.mapRange.minLat);	    	    
	    this.setContents(HU.div([ID,this.domId(ID_BASEMAP),STYLE,css]));
	    if(isNaN(width)) {
		width = this.getContents().width();
	    }
	    return [width,height];

	},
	makeSvg: function(width,height) {
	    const svg = d3.select("#" + this.domId(ID_BASEMAP)).append('svg')
		  .attr('width', width)
		  .attr('height', height)
		  .append('g')
	    let padx = 0;
	    let pady = padx;
	    let scaleX  = d3.scaleLinear().domain([this.mapRange.minLon, this.mapRange.maxLon]).range([padx, width-padx]);
	    let scaleY  = d3.scaleLinear().domain([this.mapRange.maxLat, this.mapRange.minLat]).range([pady, height-pady]);
	    return [svg,scaleX,scaleY];
	},

	clearTooltip: function() {
	    if(this.tooltipDiv)
		this.tooltipDiv.style("opacity", 0);
	},
	makeTooltipDiv: function() {
	    if(!this.tooltipDiv) {
		this.tooltipDiv = d3.select("body").append("div")
		    .attr(ATTR_CLASS, "ramadda-shadow-box  display-tooltip")
		    .style("opacity", 0)
		    .style("position", "absolute")
		    .style("background", "#fff")
	    }
	    this.clearTooltip();
	    return this.tooltipDiv;
	},
	addEvents:function(polys, idToRecord, tooltipDiv) {
	    let _this = this;
	    idToRecord  = idToRecord|| this.idToRecord;
	    tooltipDiv = tooltipDiv || this.makeTooltipDiv();
	    polys.on('click', function (event, d) {
		let poly = d3.select(this);
		let record = idToRecord[poly.attr(RECORD_ID)];
		if(record)
		    _this.propagateEventRecordSelection({record: record});
	    });
	    polys.on('mouseover', function (event, i) {
		let poly = d3.select(this);
		let record = idToRecord[poly.attr(RECORD_ID)];
		poly.attr("lastStroke",poly.attr("stroke"))
		    .attr("lastFill",poly.attr("fill"));
		poly.attr("stroke",_this.getProperty('highlightStrokeColor','blue')).attr("stroke-width",_this.getProperty('highlightStrokeWidth',1))
		    .attr("fill",_this.getProperty('highlightFillColor','blue'));
		let tooltip = _this.getProperty("tooltip");
		if(!tooltip) return;
		let regionName = poly.attr("regionName");
		let tt = null;
		if(!record) {
		    tt = regionName;
		    console.log("no record found for region:" +regionName);
		} else {
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		    tt =  _this.getRecordHtml(record,null,tooltip);
		}
		if(tt) {
		    _this.tooltipDiv.html(tt)
			.style("left", (event.pageX + 10) + "px")
			.style("top", (event.pageY + 20) + "px");
		    _this.tooltipDiv.style("opacity", 1);
		    //For now don't transition as it seems to screw up
		    //subsequent mouse overs
		    /*
		    _this.tooltipDiv.transition()
			.delay(500)
			.duration(500)
			.style("opacity", 1);
		    */
		}
	    });
	    polys.on('mouseout', function (d, i) {
//		_this.tooltipDiv.transition();
		let poly = d3.select(this);
		poly.attr("stroke",poly.attr("lastStroke"))
		    .attr("fill",poly.attr("lastFill"))
		    .attr("stroke-width",1);
		_this.tooltipDiv.style("opacity", 0);
	    });
	},
        updateUI: function() {
	    this.clearTooltip();
	    if(!this.mapJson) {
		if(!this.gettingFile) {
		    this.gettingFile = true;
		    let mapFile = this.getPropertyMapFile();
		    let mapEntry = this.getMapEntry();
		    if(mapEntry!=null) {
			mapFile = RamaddaUtil.getUrl("/entry/get?entryid=" + mapEntry);
		    } else {
			if(!mapFile.startsWith("/") && !mapFile.startsWith("http")) {
			    mapFile =RamaddaUtil.getCdnUrl("/resources/" + mapFile);
			}
		    }
		    $.getJSON(mapFile, (data) =>{
			this.mapJson = data;
			this.regionNames=[];
			this.makeRegions();
			this.updateUI();
		    });
		}
		return;
	    }
	    if(!this.regions) {
		if(!this.makeRegions()) return;
	    }
	    this.makeMap();
	},
	makeRegions:function() {
	    if(!this.mapJson) return false;
	    let debug = this.getProperty("debug");
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let allRegions = {};
	    if(this.getData()==null) {
		return false;
	    }
	    let allRecords = this.getData().getRecords()
	    if(!allRecords) return;
	    let regionField=this.getFieldById(null,this.getPropertyRegionField());
	    if(regionField==null) {
		this.displayError("No region field");
		return false;
	    }
	    allRecords.forEach(record=>{
		let v = record.getValue(regionField.getIndex());
//		console.log("data region:" + v);
		allRegions[v] = true;
	    });
	    this.regions = {};
	    this.mapRange  = {
		minLon:null,
		maxLon:null,
		minLat:null,
		maxLat:null
	    };
	    let transforms = {}
	    let prunes = {}	    
	    this.getPropertyTransforms("").split(";").map(t=>t.split(",")).forEach(tuple=>{
		let region = tuple[0];
		transforms[region] = {
		    scale:tuple[1]!=null?+tuple[1]:1,
		    dx:tuple[2]!=null?+tuple[2]:0,
		    dy:tuple[3]!=null?+tuple[3]:0}
	    });

	    this.getPropertyPrunes("").split(";").map(t=>t.split(",")).forEach(tuple=>{
		let region = tuple[0];
		prunes[region] =  +tuple[1];
	    });

	    let tfunc=(region,polygon)=>{
		let prune = prunes[region];
		if(prune>0) {
		    if(polygon.length<prune) return null;
		}

		let transform = transforms[region];
		if(!transform) 
		    return polygon;
		let bounds = Utils.getBounds(polygon);
		let centerx = bounds.minx + (bounds.maxx-bounds.minx)/2;
		let centery = bounds.miny + (bounds.maxy-bounds.miny)/2;		
		polygon.map(pair=>{
		    pair[0]= (pair[0]-centerx)*transform.scale+centerx;
		    pair[1]= (pair[1]-centery)*transform.scale+centery;		    		    
		    pair[0] += transform.dx;
		    pair[1] += transform.dy;
		    return pair;
		});
		return polygon;		
	    };
	    
	    this.skipRegions = this.getPropertySkipRegions("").split(",").map(r=>r.replace(/_comma_/g,","));
	    let features = this.mapJson.geojson;
	    if(!features)
		features = this.mapJson.features;

	    this.aliasMap = {};
	    let mapFeature = this.getMapFeature();
	    features.forEach(blob=>{
		let region;
		if(mapFeature) {
		    region = blob.properties[mapFeature];
		} else  {
		    region = blob.properties.name || blob.properties.name_long || blob.properties.NAME || blob.properties.ADMIN;
		}
		let aliases = [region];
		//Some hacks
		if(region=="United States of America") aliases.push("United States");
		if(region=="United Republic of Tanzania") aliases.push("Tanzania");
		if(region=="Democratic Republic of the Congo") aliases.push("Democratic Republic of Congo");
		if(region=="Czech Rep.") aliases.push("Czech Republic");
		if(region=="Bosnia and Herz.") aliases.push("Bosnia and Herzegovina");
		this.aliasMap[region] = aliases;
		if(blob.properties.ISO_A3)
		    aliases.push(blob.properties.ISO_A3);
		if(blob.properties.STUSPS)
		    aliases.push(blob.properties.STUSPS);
		if(blob.properties.STATEFP)
		    aliases.push(blob.properties.STATEFP);		
		if(!blob.geometry) {
		    if(debug)
			console.log(region +" no geometry");
		    return;
		}
		if(debug)
		    console.log("region:" + region);
		let ok = true;
		aliases.forEach(alias=>{
		    if(this.skipRegions.includes(alias)) ok = false;});
		if(!ok) {
		    return;
		}
		ok = false;
		aliases.forEach(alias=>{
		    if(allRegions[alias]) {
			ok =true;
		    }});
		if(!ok) this.handleWarning("Missing data for map region:" + region);
		if(pruneMissing && !ok) {
		    if(debug)console.log("missing data:" + region);
//		    return;
		}
		this.regionNames.push(region);
		let coords = blob.geometry.coordinates;
		let info = {
		    name:region,
		    aliases: aliases,
		    polygons:[],
		    bounds:null
		};
		aliases.forEach(alias=>{
		    this.regions[alias] = info;
		});
		if(blob.geometry.type  == "MultiPolygon") {
		    coords.forEach(group=>{
			group.forEach(polygon=>{
			    polygon  = tfunc(region,polygon);
			    if(polygon)info.polygons.push(polygon);
			});
		    });
		} else {
		    coords.forEach(polygon=>{
			info.polygons.push(tfunc(region,polygon));
		    });
		}
		info.polygons.forEach(polygon=>{
		    polygon.forEach(point=>{
			let lon = point[0];
			let lat = point[1];
			if(isNaN(lon) || isNaN(lat)) return;
			this.mapRange.minLon= this.mapRange.minLon===null?lon:Math.min(this.mapRange.minLon,lon);
			this.mapRange.maxLon= this.mapRange.maxLon===null?lon:Math.max(this.mapRange.maxLon,lon);
			this.mapRange.minLat= this.mapRange.minLat===null?lat:Math.min(this.mapRange.minLat,lat);
			this.mapRange.maxLat= this.mapRange.maxLat===null?lat:Math.max(this.mapRange.maxLat,lat);						
		    });
		});
		let bounds = null;
		info.polygons.forEach(polygon=>{
		    bounds = Utils.mergeBounds(bounds, Utils.getBounds(polygon));
		});
		info.bounds = bounds;
	    });
	    return true;
	},
	
    });
}


function RamaddaMapchartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaOtherMapDisplay(displayManager, id, DISPLAY_MAPCHART, properties);
    let myProps = [
	{label:'Map chart Properties'},
	{p:'fixedFillColor',tt:'Use this color for all polygons',ex:'red'},
	{p:'fixedStrokeColor',tt:'Use this color for all polygons',ex:'red'},	
	{p:'missingLineColor'},
	{p:'missingFillColor'},		
	{p:'maxLayers',ex:'10'},
	{p:'translateX',ex:'0'},
	{p:'translateY',ex:'0'},	
	{p:'skewX',ex:'-10'},
	{p:'skewY',ex:'0'},	
	{p:'rotate',ex:'10'},
	{p:'scale',ex:'0'},
	{p:'fillColor',ex:'red'},
	{p:'blur',ex:'4'},			
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let allRecords = this.getData().getRecords()
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let maxLayers = +this.getPropertyMaxLayers(20);
	    Object.keys(valueMap).forEach(region=>{
		let values = valueMap[region];
		values.layers = Math.round(values.percent*(maxLayers-1))+1;
	    });
	    this.colorBy = this.getColorByInfo(allRecords);

	    let [width,height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);
	    SU.transform(svg,SU.translate(width/2, height/2), SU.scale(0.9), SU.rotate(this.getPropertyRotate(0)), SU.translate(-width/2,-height/2), SU.translate(this.getPropertyTranslateX(30),this.getPropertyTranslateY(0)), SU.skewX(this.getPropertySkewX(-10)), SU.scale(this.getPropertyScale(1)));
	    let defs = svg.append("defs");
	    SU.makeBlur(svg,"blur", this.getPropertyBlur(3));
	    pruneMissing=false;
	    let fixedFillColor = this.getFixedFillColor();
	    let fixedStrokeColor = this.getFixedStrokeColor();	    	    
//	    console.dir(this.colorBy);
	    for(let layer=0;layer<maxLayers;layer++) {
		this.regionNames.forEach(region=>{
		    let values= this.findValues(region, valueMap);
		    let maxLayer = 1;
		    let value = NaN;
		    let missing = values==null;
		    let record = null;
		    if(!missing) {
			maxLayer = values.layers;
			value = values.value;
			record = values.record;
		    } else {
			if(pruneMissing) return;
			maxLayer = 1;
			if(layer>0) return;
		    }
		    let recordId = record?record.getId():"";
		    if(!Utils.isDefined(maxLayer)) maxLayer = 1;
		    if(layer>maxLayer) return;
		    this.regions[region].polygons.forEach(polygon=>{
			let uid = HtmlUtils.getUniqueId('selector_');
			let poly = this.makePoly(polygon);
			let fillColor = "transparent";
			if(missing) {
			    fillColor = this.getMissingFillColor("#ccc");
			    lineColor=this.getMissingLineColor("#000"); 
			} else {
			    if(layer==maxLayer-1) {
				fillColor = this.colorBy.getColorFromRecord(record);
				lineColor  = Utils.pSBC(0.1,fillColor);
			    } else {
				lineColor  = Utils.pSBC(-0.3,this.colorBy.getColor(value));
			    }
			    if(fixedFillColor)
				fillColor=fixedFillColor;
			    if(fixedStrokeColor)
				lineColor=fixedStrokeColor;			    
			}
			if(missing) {
			    svg.selectAll(uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
				.attr("regionName",region)
				.attr("fill",fillColor)
		    		.attr("stroke-width",1)
			    	.attr("stroke",lineColor);
			    return;
			}

			

			if(layer==0) {
			    svg.selectAll(uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
		    		.attr("stroke-width",3)
				.attr("stroke","black")
				.style("filter","url(#blur)");
			}
			let polys = 
			    svg.selectAll(uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill",fillColor)
			    .attr("opacity",1)
			    .attr("stroke",lineColor)
			    .attr("stroke-width",1)
			    .style("cursor", "pointer")
			    .attr(RECORD_ID,recordId);
			this.addEvents(polys);
		    });
		});
	    }
	    if(!fixedFillColor)
		this.colorBy.displayColorTable();
	}
    });
}



function RamaddaMaparrayDisplay(displayManager, id, properties) {
    const ID_MAPBLOCK = "mapblock";
    const ID_MAPLABEL = "maplabel";        
    const SUPER = new RamaddaOtherMapDisplay(displayManager, id, DISPLAY_MAPARRAY, properties);
    let myProps = [
	{label:'Map array properties'},
	{p:'blockWidth',ex:''},
	{p:'sortByValue',ex:'true'},
	{p:'fillColor',ex:'red'},
	{p:'showValue',ex:'true'},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let allRecords = this.getData().getRecords()
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap(true);
	    let blockWidth= this.getPropertyBlockWidth(75);
	    let blockHeight= blockWidth;
	    let pruneMissing = this.getPropertyPruneMissing(true);
	    let sortedRegions = this.regionNames;
	    if(this.getSortByValue(true)) {
		sortedRegions.sort((a,b)=>{
		    if(!valueMap[a]) return 1;
		    if(!valueMap[b]) return -1;		    
		    return valueMap[a].value-valueMap[b].value;
		});
	    } else {
		sortedRegions.sort();
	    }

	    let html = "";
	    sortedRegions.forEach((region,idx)=>{
		html+= HU.div([CLASS,"display-maparray-block"],
			      HU.div([CLASS,"display-maparray-header"],region) +
			      HU.div([ID,this.domId(ID_MAPBLOCK+"_"+idx),CLASS,"display-maparray-map",STYLE,HU.css(WIDTH,blockWidth+"px",HEIGHT,blockHeight+"px")]) +
			      HU.div([ID,this.domId(ID_MAPLABEL+"_"+idx),"display-maparray-label"]));			      


		    
	    });
	    this.jq(ID_BASEMAP).html(html+"<p>");

	    let showValue = this.getPropertyShowValue(true);

	    sortedRegions.forEach((region,idx)=>{
		let info = this.regions[region];
		let svg = d3.select("#" + this.domId(ID_MAPBLOCK+"_"+idx)).append('svg')
		    .attr('width', blockWidth)
		    .attr('height', blockHeight)
		    .append('g')
		let padx=5;
		let pady=5;
		let mapWidth = info.bounds.getWidth();
		let mapHeight = info.bounds.getHeight();
		let scaleX;
		let scaleY;
		if(mapWidth>mapHeight) {
		    scaleX= d3.scaleLinear().domain([info.bounds.minx, info.bounds.maxx]).range([0, blockWidth-padx]);
		    scaleY= d3.scaleLinear().domain([info.bounds.maxy, info.bounds.miny]).range([0, (mapHeight/mapWidth)*blockHeight-pady]);
		} else {
		    scaleX= d3.scaleLinear().domain([info.bounds.minx, info.bounds.maxx]).range([0, (mapWidth/mapHeight)*blockWidth-padx]);
		    scaleY= d3.scaleLinear().domain([info.bounds.maxy, info.bounds.miny]).range([0, blockHeight-pady]);
		}
		let values = valueMap[region];
		let value = NaN;
		let missing = values==null;
		let record = null;
		if(!missing) {
		    value = values.value;
		    record = values.record;
		    if(showValue) {
			this.jq(ID_MAPLABEL+"_"+idx).html(value);
		    }
		} else {
		    if(pruneMissing) return;
		}

		let recordId = record?record.getId():"";
		info.polygons.forEach(polygon=>{
		    let uid = HtmlUtils.getUniqueId();
		    let poly = this.makePoly(polygon);
		    let fillColor = "transparent";
		    if(missing) {
			fillColor = "#ccc";
			lineColor="#000" 
		    } else {
			fillColor = this.colorBy.getColor(value);
			lineColor = "#ccc";
		    }
		    if(missing) {
			svg.selectAll(uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill","#ccc")
		    	    .attr("stroke-width",1)
			    .attr("stroke","black");
			return;
		    }
		    let polys = 
			svg.selectAll(uid)
			.data([poly])
			.enter().append("polygon")
			.attr("points",function(d) { 
			    return d.map(d=>{return [+scaleX(d.x),+scaleY(d.y)].join(",");}).join(" ");
			})
			.attr("fill",fillColor)
			.attr("opacity",1)
			.attr("stroke",lineColor)
			.attr("stroke-width",1)
			.style("cursor", "pointer")
			.attr(RECORD_ID,recordId);
		    this.addEvents(polys);
		});
	    });
	    this.colorBy.displayColorTable();
	}
    });
}




function RamaddaMapshrinkDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaOtherMapDisplay(displayManager, id, DISPLAY_MAPSHRINK, properties);
    let myProps = [
	{label:'Map shrink Properties'},
   ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let allRecords = this.getData().getRecords()
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let sizeBy = new SizeBy(this, allRecords);
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);

	    for(let layer=0;layer<2;layer++) {
		this.regionNames.forEach(region=>{
		    let values= this.findValues(region, valueMap);
		    let value = NaN;
		    let missing = values==null;
		    let record = null;
		    if(!missing) {
			value = values.value;
			record = values.record;
		    } else {
			if(pruneMissing) return;
			if(layer>0) return;
		    }
		    let recordId = record?record.getId():"";
		    this.regions[region].polygons.forEach(polygon=>{
			let uid = HtmlUtils.getUniqueId();
			let poly = this.makePoly(polygon);
			let fillColor = "red";
			let transform  = "";
			lineColor="#000" 
			if(layer==0) {
			    fillColor = "#fff";
			} else {
			    lineColor="transparent" 
			    fillColor = this.colorBy.getColor(value);
			    let bounds = Utils.getBounds(polygon);
			    let center = bounds.getCenter();
			    let p=0;
			    let sizeByFunc = function(p, size) {
				percent = p;
				return percent;
			    }
			    sizeBy.getSizeFromValue(value,sizeByFunc);
			    transform = SU.translate(scaleX(center.x),scaleY(center.y)) + SU.scale(percent) + SU.translate(-scaleX(center.x),-scaleY(center.y))
			}
			if(missing) {
			    svg.selectAll("base"+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
				.attr("fill","#ccc")
		    		.attr("stroke-width",1)
			    	.attr("stroke","black");
			    return;
			}
			if(layer==0) {
			    svg.selectAll("base"+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(","); }).join(" ");
				})
		    		.attr("stroke-width",1)
				.attr("stroke","black")
				.attr('transform',transform);
			}
			let polys = 
			    svg.selectAll(uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill",fillColor)
			    .attr("opacity",1)
			    .attr("stroke",lineColor)
			    .attr("stroke-width",1)
			    .attr('transform',transform)
			    .style("cursor", "pointer")
			    .attr(RECORD_ID,recordId);
			if(layer==1)
			    this.addEvents(polys);
		    });
		});
	    }
	    this.colorBy.displayColorTable();
	}
    });
}


function RamaddaMapimagesDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaOtherMapDisplay(displayManager, id, DISPLAY_MAPIMAGES, properties);
    let myProps = [
	{label:'Map Images Properties'},
	{p:'imageField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getHeightForStyle: function(dflt) {
	    return null;
	},
	addMacroAttributes:function(macros,row,attrs) {
	    SUPER.addMacroAttributes.call(this,macros,row,attrs);
	    if(!this.imageField) return;
	    let f = this.imageField;
	    let value = row[f.getIndex()];
	    let imageAttrs = [];
	    let tokenAttrs  = macros.getAttributes("imageField_image");
	    let width = tokenAttrs?tokenAttrs["width"]:null;
	    if(width) {
		imageAttrs.push("width");
		imageAttrs.push(width);
	    } else if(this.getProperty("imageWidth")) {
		imageAttrs.push("width");
		imageAttrs.push(this.getProperty("imageWidth")); 
	    } else  {
		imageAttrs.push("width");
		imageAttrs.push("100%");
	    }
	    imageAttrs.push(ATTR_STYLE);
	    imageAttrs.push("vertical-align:top");
	    let img =  HU.image(value, imageAttrs);
	    attrs["imageField" +"_image"] =  img;
	    attrs["imageField" +"_url"] =  value;
	},
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    this.imageField = this.getFieldById(null,this.getPropertyImageField());	    
	    if(this.imageField == null) {
		this.imageField =  this.getFieldByType(null, "image");
	    }
	    let strokeWidth = this.getStrokeWidth(1);
	    let strokeColor = this.getStrokeColor("#000");
	    if(this.imageField==null) {
                this.displayError("No image fields");
		return
	    }
	    let valueMap = this.makeValueMap(records);
	    if(!valueMap) return;
	    Object.keys(valueMap).forEach(region=>{
		let values = valueMap[region];
		values.image = values.record.getValue(this.imageField.getIndex());
	    });
	    let [width, height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);
	    let defs = svg.append("defs");
	    this.regionNames.forEach((region,idx)=>{
		let values= this.findValues(region, valueMap);
		let recordId = values!=null?values.record.getId():"";
		let regionClean = Utils.cleanId(region);
		this.regions[region].polygons.forEach(polygon=>{
		    let uid = HtmlUtils.getUniqueId();
		    if(values!=null) {
			defs.append("svg:pattern")
			    .attr(ATTR_ID, "bgimage"+ uid)
			    .attr("x", "1")
			    .attr("y", "1")
			    .attr("width", "100%")
		            .attr("height", "100%")
			    .attr("patternContentUnits","objectBoundingBox")
			    .append("svg:image")
			    .attr("xlink:href", values.image)
			    .attr("preserveAspectRatio","none")
			    .attr("width", 1)
			    .attr("height", 1)
			    .attr("x", "0")
			    .attr("y", "0");
		    }
		    let polys = svg.selectAll(regionClean+"base"+uid)
			.data([this.makePoly(polygon)])
			.enter().append("polygon")
			.attr("regionName",region)
			.attr("points",function(d) { 
			    return d.map(d=>{return [scaleX(d.x),scaleY(d.y)].join(",");}).join(" ");
			})
			.attr(RECORD_ID,recordId)
		    	.attr("stroke-width",strokeWidth)
			.attr("stroke",strokeColor);
		    if(values!=null)
			polys.style("fill", "url(#bgimage"+ uid+")")
		    else
			polys.style("fill",this.getPropertyMissingFill("#fff"));
		    this.addEvents(polys);
		});
	    });
	}
    });
}

/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/

var DISPLAY_IMDV = 'imdv';
var DISPLAY_EDITABLEMAP = 'editablemap';
addGlobalDisplayType({
    type: DISPLAY_IMDV,
    label: 'Integrated Map Data',
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip('Integrated Map Data','imdv.png','Create interactive maps with points, routes, data, etc'),        
});


var GLYPH_FIXED = 'fixed';
var GLYPH_GROUP = 'group';
var GLYPH_ZOOM = 'zoom';
var GLYPH_MARKER = 'marker';
var GLYPH_POINT = 'point';
var GLYPH_LABEL = 'label';
var GLYPH_BOX = 'box';
var GLYPH_CIRCLE = 'circle';
var GLYPH_TRIANGLE = 'triangle';
var GLYPH_HEXAGON = 'hexagon';
var GLYPH_LINE = 'line';
var GLYPH_RINGS = 'rings';
var GLYPH_ROUTE = 'route';
var GLYPH_ISOLINE= 'isoline';
var GLYPH_POLYLINE = 'polyline';
var GLYPH_FREEHAND = 'freehand';
var GLYPH_POLYGON = 'polygon';
var GLYPH_FREEHAND_CLOSED = 'freehand_closed';
var GLYPH_IMAGE = 'image';
var GLYPH_ENTRY = 'entry';
var GLYPH_MULTIENTRY = 'multientry';
var GLYPH_MAP = 'map';
var GLYPH_MAPSERVER = 'mapserver'

var GLYPH_DATA = 'data';
var GLYPH_OSM_LOCATIONS = 'osmlocations';
var GLYPH_TYPES_SHAPES = [GLYPH_POINT,GLYPH_BOX,GLYPH_CIRCLE,GLYPH_TRIANGLE,GLYPH_HEXAGON,GLYPH_LINE,GLYPH_POLYLINE,GLYPH_FREEHAND,GLYPH_POLYGON,GLYPH_FREEHAND_CLOSED];
var GLYPH_TYPES_LINES_OPEN = [GLYPH_LINE,GLYPH_POLYLINE,GLYPH_FREEHAND,GLYPH_ROUTE];
var GLYPH_TYPES_LINES = [GLYPH_LINE,GLYPH_POLYLINE,GLYPH_FREEHAND,GLYPH_POLYGON,GLYPH_FREEHAND_CLOSED,GLYPH_ROUTE];
var GLYPH_TYPES_LINES_STRAIGHT = [GLYPH_LINE,GLYPH_POLYLINE];
var GLYPH_TYPES_CLOSED = [GLYPH_POLYGON,GLYPH_FREEHAND_CLOSED,GLYPH_BOX,GLYPH_TRIANGLE,GLYPH_HEXAGON];
var MAP_TYPES = ['geo_geojson','geo_gpx','geo_shapefile','geo_kml'];

var LEGEND_IMAGE_ATTRS = [ATTR_STYLE,'color:#ccc;font-size:9pt;'];
var BUTTON_IMAGE_ATTRS = [ATTR_STYLE,'color:#ccc;'];
var CLASS_IMDV_STYLEGROUP= 'imdv-stylegroup';
var CLASS_IMDV_STYLEGROUP_SELECTED = 'imdv-stylegroup-selected';
var PROP_DONT_SHOW_IN_LEGEND='dontShowInLegend';
var PROP_SHOW_LAYER_SELECT_IN_LEGEND = "showLayerSelectInLegend";
var PROP_LAYERS_STEP_SHOW= "showLayersStep";
var PROP_LAYERS_SHOW_SEQUENCE= "showLayersInSequence";
var PROP_LAYERS_ANIMATION_SHOW = "showLayersAnimation";
var PROP_LAYERS_ANIMATION_PLAY = "layersAnimationPlay";
var PROP_SHOW_CONTROL_IN_HEADER= "showControlInHeader";

var PROP_MOVE_TO_LATEST_LOCATION = "moveToLatestLocation";
var PROP_LAYERS_ANIMATION_DELAY = "layersAnimationDelay";
var PROP_LAYERS_ANIMATION_ON = "layersAnimatioOn";

var ATTR_BUTTON_COMMAND='buttoncommand';

var IMDV_PROPERTY_HINTS= ['filter.live=true','filter.show=false',
			  'filter.zoomonchange.show=false',
			  'filter.toggle.show=false',
			  'filter.sortOnCount=true',
			  'filter.showRawValues=true',
			  'legendTooltip=',
			  'showLabelInMap=true',
			  PROP_MOVE_TO_LATEST_LOCATION+'=true',
			  'showLabelInMapWhenVisible=true',
			  'showViewInLegend=true',
			  PROP_SHOW_LAYER_SELECT_IN_LEGEND +'=true',			  
			  'inMapLabel=',			  			  
			  'showLegendInMap=true',			  
			  PROP_DONT_SHOW_IN_LEGEND +'=true',
			  'showDisplayHeader=false',
			  'showInHeader=true',			  
			  'showIconInHeader=true',
			  'mapLegendHeight=300px',
			  'showLegendBox=true',
			  'showButtons=false',
			  'showMeasures=false',
			  'showTextSearch=true'];


var IMDV_GROUP_PROPERTY_HINTS= [PROP_LAYERS_STEP_SHOW+'=true',
				PROP_LAYERS_SHOW_SEQUENCE+'=true',
				PROP_LAYERS_ANIMATION_SHOW+'=true',
				PROP_LAYERS_ANIMATION_DELAY+'=1000',
				PROP_LAYERS_ANIMATION_PLAY+'=true'];				



var CLASS_LEGEND_LABEL = 'imdv-legend-label';
var CLASS_LEGEND_LABEL_INVISIBLE = 'imdv-legend-label-invisible';
var CLASS_LEGEND_LABEL_HIGHLIGHT = 'imdv-legend-label-highlight';
var CLASS_LEGEND_ITEM = 'imdv-legend-item';
var CLASS_LEGEND_OFFSET = 'imdv-legend-offset';
var CLASS_LEGEND_INNER = 'imdv-legend-inner';
var CLASS_LEGEND_ITEM_VIEW = 'imdv-legend-item-view';
var CLASS_LEGEND_ITEM_DROPPABLE= 'imdv-legend-item-droppable';



var CLASS_FILTER_SLIDER = 'imdv-filter-slider';
var CLASS_FILTER_SLIDER_LABEL = 'imdv-filter-slider-label';
var CLASS_FILTER_PLAY = 'imdv-filter-play';
var CLASS_FILTER_STRING = 'imdv-filter-string';
var CLASS_FILTER_STRINGS = 'imdv-filter-strings';
 

var ID_GLYPH_ID='glyphid';
var ID_GLYPH_LEGEND = 'glyphlegend';

var ID_LEVEL_RANGE_SLIDER = 'level_range_slider';
var ID_LEVEL_RANGE_CLEAR = 'level_range_clear';
var ID_LEVEL_RANGE_CHANGED = 'level_range_changed';
var ID_LEVEL_RANGE_MIN = 'level_range_min';
var ID_LEVEL_RANGE_MAX = 'level_range_max';

var ID_LEVEL_RANGE_SAMPLE_MIN = 'level_range_sample_min';
var ID_LEVEL_RANGE_SAMPLE_MAX = 'level_range_sample_max';
var ID_OSM_LABEL = 'osmlabel';
var ID_OSM_TEXT = 'osmtext';

let ImdvUtils = {
    getImdv: function(id) {
	return Utils.displaysMap[id];
    },


    applyFeatureStyle:function(feature,style) {
	if(!feature.style) {
	    feature.style=style;
	    return;
	}
	let geom = feature?.geometry?.CLASS_NAME;
	//If it is a point and has a graphic then we want to try to use the original graphic
	//if there isn't one in the new style
	if(geom=='OpenLayers.Geometry.Point' && Utils.stringDefined(feature.style.externalGraphic)) {
	    style = $.extend({},style);
	    if(!feature.originalGraphic)
		feature.originalGraphic = feature.style.externalGraphic;

	    if(!Utils.stringDefined(style.externalGraphic)) {
		style.externalGraphic = feature.originalGraphic;
	    }
	    feature.style= style;
	} else {
	    feature.style= style;
	}
    },
    findGlyph:function(list, id) {
	if(!list) return null;
	let glyph;
	for(let i=0;i<list.length;i++) {
	    let mapGlyph = list[i].findGlyph(id);
	    if(mapGlyph) return mapGlyph;
	}
	return null;
    },
    //We use this to call redraw so we don't have to keep track of when to redraw when
    //we're updating the map
    scheduleRedraw:function(layer,feature) {
	if(!layer) return;
	if(layer.redrawPending) {
	    return;
	}
	layer.redrawPending = true;
	setTimeout(()=>{
//	    console.log('redrawing layer:',layer.name);
	    layer.redraw();
	    layer.redrawPending = false;
	},1)
    }
}


function RamaddaImdvDisplay(displayManager, id, properties) {
    this.mapProperties = {};
    Utils.importJS(ramaddaBaseHtdocs+'/wiki.js');
    MapUtils.initMapResources();
    ImageHandler = OpenLayers.Class(OpenLayers.Handler.RegularPolygon, {
	CLASS_NAME:'IMDV Image Handler',
	initialize: function(control, callbacks, options) {
	    OpenLayers.Handler.RegularPolygon.prototype.initialize.apply(this,arguments);
	    this.display = options.display;
	},
	finalize: function(cancel) {
	    if(cancel || !this.image) return
	    let image = this.image;
	    this.theImage = image;
	    this.image =null;
	    this.display.featureChanged();	    
	    OpenLayers.Handler.RegularPolygon.prototype.finalize.apply(this,arguments);
	    //call deactivate in a bit. If we do this now then there is an error in OL
	    setTimeout(()=>{
		let box = this.display.getNewFeature();
                box.style.strokeColor = 'transparent';
		let mapGlyph =this.display.handleNewFeature(box,this.style);
		mapGlyph.setImage(image);
//		mapGlyph.checkImage(null,true);
		mapGlyph.setRotation(mapGlyph.style.rotation);
		box.mapGlyph = mapGlyph;
                this.display.myLayer.redraw(box);
		this.display.clearCommands();
	    },250);
	},
	move: function(evt) {
	    if(!this.checkingImageSize) {
		this.checkingImageSize = true;
		const img = new Image();
		img.onload = ()=> {
		    this.imageBounds={width:img.width,height:img.height};
		}
		img.src = this.style.imageUrl;		
	    }
	    OpenLayers.Handler.RegularPolygon.prototype.move.apply(this,arguments);
	    let mapBounds = this.feature.geometry.getBounds();
	    let b = this.display.map.transformProjBounds(mapBounds);
	    if(this.imageBounds && !evt.shiftKey) {
		let aspect1 = this.imageBounds.width/this.imageBounds.height;
		let aspect2 = this.imageBounds.height/this.imageBounds.width;
		let rh = b.top-b.bottom;
		let rw = b.right-b.left;
		//		b.right = aspect1*(rh) + b.left
		b.bottom = b.top-aspect2*rw;
	    }
	    this.lastBounds = b;
	    if(isNaN(b.bottom)) b.bottom = b.top;
	    if(isNaN(b.top)) b.top= b.bottom;	    
	    if(!this.image) {
		this.image=  this.display.getMap().addImageLayer('IMDV Image','IMDV Image','',this.style.imageUrl,true,  b.top,b.left,b.bottom,b.right);
	    } else {
		b = this.display.map.transformLLBounds(b);
		this.image.extent = b;
		this.image.moveTo(b,true,true);
	    }
	    this.image.setOpacity(this.style.imageOpacity);
	}
	
    });

    MyPoint = OpenLayers.Class(OpenLayers.Handler.Point, {
	finalize: function(cancel) {
	    OpenLayers.Handler.Point.prototype.finalize.apply(this,arguments);
	    if(!cancel) {
		this.display.handleNewFeature(this.display.getNewFeature());
	    }
	},
    });

    MyEntryPoint = OpenLayers.Class(OpenLayers.Handler.Point, {
	finalize: function(cancel) {
	    OpenLayers.Handler.Point.prototype.finalize.apply(this,arguments);
	    if(!cancel)this.display.handleNewFeature(this.display.getNewFeature());
	    this.display.clearCommands();	    	    
	},
    });

    MyPolygon = OpenLayers.Class(OpenLayers.Handler.Polygon, {
	finalize: function(cancel) {
	    OpenLayers.Handler.Path.prototype.finalize.apply(this,arguments);
	    if(cancel) return;
	    let line =  this.display.getNewFeature();
	    if(!line || !line.geometry) {
		return;
	    }
	    this.display.handleNewFeature(line);
	},
	move: function(evt) {
	    OpenLayers.Handler.Path.prototype.move.apply(this,arguments);
	    this.display.showDistances(this.line.geometry,this.glyphType);
	}
    });

    MyPath = OpenLayers.Class(OpenLayers.Handler.Path, {
	finalize: function(cancel) {
	    OpenLayers.Handler.Path.prototype.finalize.apply(this,arguments);
	    if(cancel) return;
	    let line =  this.display.getNewFeature();
	    if(!line || !line.geometry) {
		return;
	    }
	    this.display.handleNewFeature(line);
	},
	move: function(evt) {
	    OpenLayers.Handler.Path.prototype.move.apply(this,arguments);
	    this.display.showDistances(this.line.geometry,this.glyphType);
	}
    });

    MyRoute = OpenLayers.Class(OpenLayers.Handler.Path, {
	finalize: function(cancel) {
	    if(this.makingRoute) return;
	    OpenLayers.Handler.Path.prototype.finalize.apply(this,arguments);
	    if(cancel) return;
	    if(this.finishedWithRoute) return;
	    //A hack to get the line that was just drawn
	    let line =  this.display.getNewFeature();
	    if(!line || !line.geometry) {
		return;
	    }
	    let pts = this.display.getLatLonPoints(line.geometry);
	    if(pts==null) return;
	    this.display.createRoute(this.display.routeProvider,this.display.routeType,pts,{line:line});
	},
	move: function(evt) {
	    if(this.makingRoute) return;
	    OpenLayers.Handler.Path.prototype.move.apply(this,arguments);
	}
	
    });


    MyRegularPolygon = OpenLayers.Class(OpenLayers.Handler.RegularPolygon, {
	dragend: function() {
	    OpenLayers.Handler.RegularPolygon.prototype.dragend.apply(this,arguments);
	    this.display.handleNewFeature(this.display.getNewFeature(),this.style);
	},
	move: function(evt) {
	    OpenLayers.Handler.RegularPolygon.prototype.move.apply(this,arguments);
	    if(!this.feature || !this.feature.geometry) return;
	    this.display.showDistances(this.feature.geometry,this.glyphType);
	}
    });    
    





    const LABEL_NONE = '<none>';
    const LIST_ROW_CLASS  = 'imdv-feature-row';
    const LIST_SELECTED_CLASS  = 'imdv-feature-selected';
    const ID_MAP_MENUBAR = 'mapmenubar';
    const ID_TOPWIKI = 'topwiki';
    const ID_BOTTOMWIKI = 'bottomwiki';    
    const ID_EDIT_NAME  ='editname';
    const ID_MESSAGE  ='message';
    const ID_MESSAGE2  ='message2';    
    const ID_MESSAGE3  ='message3';
    const ID_GLYPH_LABELS  ='glyphlabels';
    const ID_MAP_HEADER  ='mapheader';
    const ID_ADDRESS  ='address';
    const ID_ADDRESS_INPUT  ='address_input';
    const ID_ADDRESS_WAIT  ='address_wait';
    const ID_ADDRESS_CLEAR  ='address_clear';
    const ID_ADDRESS_ADD  ='address_add';                    
    const ID_LIST_DELETE  ='listdelete';
    const ID_LIST_OK  ='listok';
    const ID_LIST_CANCEL = 'listcancel';
    const ID_DELETE  ='delete';
    const ID_SELECT  ='select';
    const ID_OK  ='ok';
    const ID_APPLY  ='apply';
    const ID_CANCEL = 'cancel';
    const ID_MENU_NEW = 'new_file';
    const ID_MENU_FILE = 'menu_file';
    const ID_MENU_EDIT = 'menu_edit';    
    const ID_MENU_VIEW = 'menu_view';
    const ID_TOBACK = 'toback';
    const ID_TOFRONT = 'tofront';    

    const ID_CUT = 'cut';
    const ID_COPY= 'copy';
    const ID_PASTE= 'paste';        
    const ID_COMMANDS = 'commands';
    const ID_CLEAR = 'clear';
    const ID_CMD_LIST = 'cmdlist';
    const ID_LIST = 'list';        
    const ID_PROPERTIES = 'properties';
    const ID_NAVIGATE = 'navigate';

    const ID_SAVE = 'save';
    const ID_SAVEAS = 'saveas';    
    const ID_REFRESH = 'refresh';
    const ID_IMPORT = 'import';
    const ID_DOWNLOAD = 'download';    
    const ID_SELECTOR = 'selector';
    const ID_SELECT_ALL = 'selectall';    
    const ID_EDIT = 'edit';
    const ID_MOVER = 'mover';
    const ID_RESIZE = 'resize';
    const ID_RESHAPE = 'reshape';    
    const ID_ROTATE  = 'rotate';
    const ID_LEGEND = 'legend';
    const ID_LEGEND_LEFT = 'legend_left';
    const ID_LEGEND_RIGHT = 'legend_right';    
    const ID_LEGEND_MAP_WRAPPER = 'legend_map_wrapper';
    const ID_LEGEND_MAP = 'legend_map';            
    const ID_MAP_LABEL = 'map_label';
    const ID_MAP_PROPERTIES = 'mapproperties';
    const ID_MAP_REGIONS = 'showregions';
    const ID_MAP_CHOOSE = 'chooselatlon';    
    const ID_MAP_VIEWLAYERS = 'viewlayers';
    const ID_MAP_RESETMAPVIEW = 'resetmapview';
    const ID_MAP_MYLOCATION = 'mylocation';    
    const ID_DROP_BEGINNING = 'dropbeginning';
    const ID_DROP_END = 'dropend';
    //Set these so the glyphs can access them
    this.ID_LEGEND_MAP = ID_LEGEND_MAP;

//    if(!Utils.isDefined(properties.showOpacitySlider)&&!Utils.isDefined(getGlobalDisplayProperty('showOpacitySlider'))) 
//	properties.showOpacitySlider=false; 
    const SUPER = new RamaddaBaseMapDisplay(displayManager,  id, DISPLAY_IMDV,  properties);
    RamaddaUtil.inherit(this,SUPER);
    addRamaddaDisplay(this);
    this.defineSizeByProperties();
    //do this here as this might be used by displaymap for annotation
    this.map = this.getProperty('theMap');
    const myProps = [
	{label:'Editable Map Properties'},
	{p:'displayOnly',d:false},
	{p:'strokeColor',d:'blue'},
	{p:'strokeWidth',d:2},
	{p:'pointRadius',d:10},
	{p:'externalGraphic',d:'/map/blue-dot.png'},
	{p:'fontSize',d:'12px'},
	{p:'fontWeight',d:'normal'},
	{p:'fontStyle',d:'normal'},	
	{p:'fontFamily',d:"'Open Sans', Helvetica Neue, Arial, Helvetica, sans-serif"},
	{p:'imageOpacity',d:1},
	{p:'userCanChange',tt:'Set to false to not show menubar, etc for all users'},
	{p:'showLegendShapes',d:true,canCache:true},	
	{p:'showMapLegend',d:false,canCache:true},

    ];
    
    displayDefineMembers(this, myProps, {
	commands: [],
        myLayer: [],
	glyphs:[],
	markers:{},
	minLevel:2,maxLevel:20,
	levels: [['','None'],[2,'2 - Most zoomed out'],3,4,5,6,7,8,
		 9,10,11,12,13,14,15,16,17,18,19,[20,'20 - Most zoomed in']],
	DOT_STYLE:{
	    zIndex:1000,
	    fillColor:'#000',
	    fillOpacity:1,
	    strokeWidth:0,
	    pointRadius:4
	},

	getGlyphs: function() {
	    return this.glyphs;
	},
	selected:{},
	getMap: function() {
	    return this.map;
	},

	getUsedMarkers:function() {
	    return Object.keys(this.markers);
	},


	makeLabel:function(l) {
	    let _l = l.toLowerCase();
	    let v = this.getMapProperty(_l+'.label');
	    if(v) return v;
	    return MapUtils.makeLabel(l);
	},

	setLastDroppedTime:function(date) {
	    this.lastDroppedTime = date;
	},
	showFeatureProperty:function(p) {
	    let _p = p.toLowerCase();
	    return this.getMapProperty(_p+'.showFeature',true);
	},

	findGlyph:function(id) {
	    return ImdvUtils.findGlyph(this.glyphs,id);
	},
	
	addGlyph:function(glyph,dontNotify) {
	    if(Array.isArray(glyph))
		this.glyphs.push(...glyph);
	    else
		this.glyphs.push(glyph);
	    if(!dontNotify) this.handleGlyphsChanged();
	},

	isRouteEnabled:function() {
	    return this.isHereEnabled() || this.getProperty('googleRoutingEnabled');
	},
	isIsolineEnabled:function() {
	    return this.getProperty('isolineEnabled');
	},
	isHereEnabled:function() {
	    return this.getProperty('hereRoutingEnabled');
	},
	handleNewRoute:function(cmd,pts) {
	    let html = this.createRouteForm();
	    let buttons  =HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK') + SPACE2 +
		HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel');	    
	    html+=HU.div([ATTR_STYLE,HU.css('text-align','right','margin-top','5px')], buttons);
	    html=HU.div([ATTR_STYLE,HU.css('margin','5px')],html);
	    let dialog = HU.makeDialog({content:html,title:'Select Route Type',header:true,my:'left top',at:'left bottom',anchor:this.jq(ID_MENU_NEW)});
	    let message = 'New Route';
	    let ok = ()=>{
		this.routeProvider = this.jq('routeprovider').val();
		this.routeType = this.jq('routetype').val();
		dialog.remove();
		if(pts) {
		    this.createRoute(this.routeProvider,this.routeType,pts,{
			doSequence:true});
		    return
		}
		if(cmd) {
		    cmd.handler.finishedWithRoute = false;
		    this.showCommandMessage(message+': ' + Utils.makeLabel(this.routeType)+' - Draw one or more line segments');
		    cmd.activate();
		}
	    };
	    dialog.find('.ramadda-button-ok').button().click(ok);
	    dialog.find('.ramadda-button-cancel').button().click(()=>{
		dialog.remove();
	    });
	},
	createRouteForm:function(addSequence) {
	    let html='';
	    if(this.isRouteEnabled()) {
		html+=HU.formTable();
		let providers = [];
		if(this.getProperty('googleRoutingEnabled')) providers.push('google');
		if(this.getProperty('hereRoutingEnabled')) providers.push('here');			
		html+=HU.formEntry('Provider:', HU.select('',[ATTR_ID,this.domId('routeprovider')],providers,this.routeProvider));
		html+=HU.formEntry('Route Type:' , HU.select('',[ATTR_ID,this.domId('routetype')],['car','bicycle','pedestrian'],this.routeType));
		if(addSequence) {
		    if(this.getProperty('hereRoutingEnabled')) {
			html += HU.formEntry('',HU.checkbox(this.domId('routedosequence'),[],false,
							    'Calculate best route from locations'));
		    }
		}
		html += HU.close(TAG_TABLE);
	    } else {
		html="Routing is not enabled";
	    }

	    return html;
	},

	createRoute:function(provider,mode,pts,args) {
	    args = args??{};

	    let xys = [];
	    pts.forEach(pt=>{
		xys.push(Utils.trimDecimals(pt.y,6));
		xys.push(Utils.trimDecimals(pt.x,6));
	    });

	    let routeArgs = {
		mode:mode??'car',
		points:Utils.join(xys,','),
		provider:provider
	    };	    
	    if(args.doSequence) {
		routeArgs.dosequence=true;
	    }	    	    
	    let url = Ramadda.getUrl('/map/getroute?entryid='+this.getProperty('entryId'));


	    let reset=  ()=>{
		this.makingRoute = false;
		this.finishedWithRoute = false;
		this.clearMessage2();
		this.getMap().clearAllProgress();
		this.setCommandCursor();
	    };



	    let handleRouteData = data=>{
		reset();
		if(data.errors && data.errors.length) {
		    alert("An error occurred:" + data.errors[0]);
		    return;
		}
		if(data.error_description) {
		    alert("An error occurred:" + data.error_description);
		    return;
		}
		if(args.line)
		    this.myLayer.removeFeatures([args.line]);
		if(data.error) {
		    this.handleError(data.error);
		    return;
		}

//		console.dir(data);

		let instructions=[];
		let points = [];
		if(data.results && data.results.length>0) {
		    //for the route sequence from here
		    let result = data.results[0];
		    if(result.waypoints) {
			result.waypoints.forEach(pt=>{
			    points.push(MapUtils.createPoint(pt.lng,pt.lat));
			});		    
		    }
		} else if(data.routes && data.routes.length>0) {
		    let routeData = data.routes[0];
//		    console.dir(data);
		    if(routeData.legs) {
			routeData.legs.forEach(leg=>{
			    instructions.push(...leg.steps.map(step=>{
				return {instr:step.html_instructions,
					lat:step?.start_location.lat,
					lon:step?.start_location.lng}
			    }));
			});
		    }
		    if(routeData.overview_polyline) {
			let d = googleDecode(routeData.overview_polyline.points);
			d.forEach(pair=>{
			    points.push(MapUtils.createPoint(pair[1],pair[0]));
			});
		    } else {
			//from Here
			routeData.sections.forEach(section=>{
			    let decoded = hereDecode(section.polyline);
			    decoded.polyline.forEach(pair=>{
				points.push(MapUtils.createPoint(pair[1],pair[0]));
			    });
			    if(section.actions) {
				instructions.push(...section.actions.map(action=>{
				    return {instr:action.instruction,loc:action.start_location}
				}));
			    }
			});
		    }
		} else {

		}
//		console.log(instructions);
		if(points.length==0) {
		    alert('No routes found');
		    this.clearMessage2();
		    return;
		}

		if(routeArgs.dosequence) {
		    routeArgs.dosequence=false;
		    let xys = [];
		    points.forEach(pt=>{
			xys.push(Utils.trimDecimals(pt.y,6));
			xys.push(Utils.trimDecimals(pt.x,6));
		    });
		    $.post(url, routeArgs,data=>{
			handleRouteData(data);
		    }).fail(fail);
		    return;
		}


		let  route = this.getMap().createPolygon('', '', points, {
		    strokeWidth:4
		},null,true);
		let glyphType = this.getGlyphType(GLYPH_ROUTE);
		route.style = Utils.clone(glyphType.getStyle());
		this.addFeatures([route]);
		let name = null;
		if(provider)
		    name ="Route: " + provider  +" - " +mode;

		this.handleNewFeature(route,null,{name:name,type:GLYPH_ROUTE,routeProvider:this.routeProvider,routeType:this.routeType,instructions:instructions});
		this.showDistances(route.geometry,GLYPH_ROUTE,true);
	    };

	    let fail = err=>{
		reset();
		if(args.line)
		    this.myLayer.removeFeatures([args.line]);
		this.clearCommands();
		this.handleError(err);
	    }

	    this.finishedWithRoute = true;
	    this.showProgress('Creating route...');
	    this.makingRoute = true;
	    $.post(url, routeArgs,data=>{
		handleRouteData(data);
	    }).fail(fail);
	},	    
	addIsolineForCurrentMarker() {
	    if(!this.currentLocationMarker) return;
	    this.addIsolineAt(this.currentLocationMarker.location);
	},
	addIsolineForMarker:function(glyph) {
	    let center = this.getMap().transformProjPoint(glyph.getCentroid());
	    this.addIsolineAt(center);
	},

	addIsolineAt:function(center,lon) {
	    if(Utils.isDefined(lon) && (typeof center=='number')) {
		center = {y:center,x:lon};
	    }
	    this.getMap().closePopup();
	    let html = HU.formTable();
	    html+=HU.formEntry('Mode:' , HU.select('',[ATTR_ID,this.domId('isolinemode')],['car','bicycle','pedestrian'],this.isolineMode));
	    html+=HU.formEntry('Range:' , HU.input('',this.isolineValue??'10',[ATTR_ID,this.domId('isolinevalue'),'size','5']) +
			       HU.space(2)+
			       HU.select('',[ATTR_ID,this.domId('isolinetype')],[{label:'Time (minutes)',value:'time'},{label:'Distance (miles)',value:'distance'}],this.isolineType));	    
	    html+=HU.formTableClose();
	    let buttons  =HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK') + SPACE2 +
		HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel');	    
	    html+=HU.div([ATTR_STYLE,HU.css('text-align','right','margin-top','5px')], buttons);
	    html=HU.div([ATTR_STYLE,HU.css('margin','5px')],html);
	    let dialog = HU.makeDialog({content:html,title:'Select Isoline Type',draggable:true,header:true,my:'left top',at:'left bottom',anchor:this.jq(ID_MENU_NEW)});
	    let ok = ()=>{
		this.isolineMode=this.jq('isolinemode').val();
		this.isolineValue=this.jq('isolinevalue').val();		
		this.isolineType=this.jq('isolinetype').val();		
		dialog.remove();
		this.createIsoline(this.isolineMode,this.isolineValue,this.isolineType,Utils.getDefined(center.y,center.lat),Utils.getDefined(center.x,center.lon),{});
	    };
	    dialog.find('.ramadda-button-ok').button().click(ok);
	    dialog.find('.ramadda-button-cancel').button().click(()=>{
		dialog.remove();
	    });
	},
	createIsoline:function(mode,value,type,latitude,longitude,args) {
	    args = args??{};
	    let originalValue = value;
	    let unit;
	    if(type=='time') {
		//Convert to seconds
		value = 60*parseFloat(value);
		unit = "minutes";
	    } else {
		//convert to meters
		value = parseInt(1609.34*parseFloat(value));
		unit = "miles";
	    }

	    let url = Ramadda.getUrl('/map/getisoline?entryid='+this.getProperty('entryId'));
	    let routeArgs = {
		mode:mode??'car',
		latitude:latitude,
		longitude:longitude,
		'rangetype':type,
		'rangevalue':value
	    };	    
	    let reset=  ()=>{
		this.clearMessage2();
		this.getMap().clearAllProgress();
		this.setCommandCursor();
	    };

	    let handleIsolineData = data=>{
		reset();

		if(data.status==400) {
		    alert("An error occurred:" + data.cause);
		    return;
		}

		if(data.errors && data.errors.length) {
		    alert("An error occurred:" + data.errors[0]);
		    return;
		}
		if(data.error_description) {
		    alert("An error occurred:" + data.error_description);
		    return;
		}
		if(data.error) {
		    this.handleError(data.error);
		    return;
		}
		if(!data.isolines || !data.isolines[0]) {
		    alert('No isolines found');
		    return;
		}

		let latLons = hereDecode(data.isolines[0].polygons[0].outer).polyline;
		if(!latLons || latLons.length==0) {
		    alert('No isolines found');
		    this.clearMessage2();
		    return;
		}

		let points=[];
		latLons.forEach(pair=>{
		    points.push(MapUtils.createPoint(pair[1],pair[0]));
		});

		let  isoLine = this.getMap().createPolygon('', '', points, {
		    strokeWidth:4
		},null,false);
		let glyphType = this.getGlyphType(GLYPH_ISOLINE);
		isoLine.style = Utils.clone(glyphType.getStyle());
		this.addFeatures([isoLine]);
		let name = "Isoline: " + mode;
		let icon ='/icons/' + mode+'.png';
		this.handleNewFeature(isoLine,null,{name:name,icon:Ramadda.getUrl(icon),type:GLYPH_ISOLINE,legendText:"Mode: " + mode+"\nRange: " + originalValue+" " + unit});
		this.showDistances(isoLine.geometry,GLYPH_ISOLINE,true);
	    };

	    let fail = err=>{
		reset();
		if(args.line)
		    this.myLayer.removeFeatures([args.line]);
		this.clearCommands();
		this.handleError(err);
	    }

	    this.finishedWithRoute = true;
	    this.showProgress('Creating isoline...');
	    this.makingRoute = true;
	    $.post(url, routeArgs,data=>{
		handleIsolineData(data);
	    }).fail(fail);
	},	    


	handleEvent:function(event,lonlat) {
	    return;
	},
        handleKeyUp:function(event) {
	    if(event.key!='Shift') return false;
	    this.getSelected().forEach(glyph=>{
		if(glyph.isImage() && glyph.getImage()) {
                    glyph.getImage().setOpacity(1);
		}
	    });
	    return true;
	},
        handleKeyDown:function(event) {
	    if(event.key!='Shift') return false;
	    this.getSelected().forEach(glyph=>{
		if(glyph.isImage() && glyph.getImage()) {
                    glyph.getImage().setOpacity(0.3);
		}
	    });
	    return true;
	},	

	handleNewFeature:function(feature,style,mapOptions) {
	    style = Utils.clone({},style?? (feature?.style) ?? {});
	    mapOptions = Utils.clone({},mapOptions??feature?.mapOptions ?? style?.mapOptions);
	    delete style.mapOptions;
	    if(feature?.style?.mapOptions)
		delete feature.style.mapOptions;
	    let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, feature,style);
	    this.addGlyph(mapGlyph);
	    mapGlyph.glyphCreated();
	    this.clearMessage2(1000);
	    /*
	      not now...
	    if(mapGlyph.isMap()) {
	    setTimeout(()=>{mapGlyph.panMapTo();},100);
	    }
	    */
	    return mapGlyph;
	},
	handleGlyphsChanged: function (){
	    this.makeLegend();
	    this.addFeatureList();
	    this.featureChanged();	    
	},
	getLayer: function() {
	    return this.myLayer;
	},
	redraw: function(feature) {
	    ImdvUtils.scheduleRedraw(this.myLayer,feature);
	},
	getNewFeature: function() {
	    return this.myLayer.features[this.myLayer.features.length-1];
	},
	clearAddresses:function() {
	    if(this.addresses) {
		this.addresses.forEach(mapGlyph=>{
		    this.removeFeatures(mapGlyph.getFeatures());
		});
		this.addresses = null;
	    }
	},
	
	gotoAddress:function(widget,address) {
            let url = Ramadda.getUrl('/geocode?query=' + encodeURIComponent(address));
	    let add = loc=> {
		if(this.addresses == null)this.addresses=[];
		let pt = MapUtils.createLonLat(loc.longitude, loc.latitude);
		let label = '';
		let toks = Utils.split(loc.name,',',true,true);
		let offset = -10;
		for(let i=0;i<toks.length;i++) {
		    label +=toks[i]+'\n';
		    offset-=6;
		}
		offset = -12;
		label = label.trim();
		let style = {
		    label:label,
		    fontSize: '9pt',
		    labelYOffset:offset,
		    labelAlign: 'ct',
		    pointRadius:12		    
		};

		let addIt = this.jq(ID_ADDRESS_ADD).is(':checked');
		let points = [loc.latitude,loc.longitude];
		style.externalGraphic=Ramadda.getUrl(addIt?'/icons/map/marker-blue.png':'/icons/map/marker.png');
		let mapGlyph = this.createMapMarker(GLYPH_MARKER,{type:GLYPH_MARKER,name:loc.name}, style,points,addIt)
		if(!addIt)
		    this.addresses.push(mapGlyph);
		mapGlyph.panMapTo();
	    };
	    
	    let clear = ()=>{
		widget.css('background','#fff');
		this.jq(ID_ADDRESS_WAIT).html('');
	    }

	    widget.css('background','#eee');
	    this.jq(ID_ADDRESS_WAIT).html(HU.getIconImage(icon_wait));
            let jqxhr = $.getJSON(url, (data)=> {
		clear();
                if (data.result.length == 0) {
                    wait.html('Nothing found');
                    return;
                } else if(data.result.length==1) {
		    add(data.result[0]);
		} else {
		    let html = '';
		    data.result.forEach((loc,idx)=>{
			html+=HU.div(['index',idx,ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'ramadda-menu-item')],loc.name);
		    });
		    html = HU.div([ATTR_STYLE,'max-height:200px;overflow-y:auto;'], html);
		    let dialog = HU.makeDialog({content:html,header:false,anchor:widget,my:'left top',at:'left bottom'});
		    let _this = this;
		    dialog.find('.ramadda-menu-item').click(function() {
			let loc = data.result[$(this).attr('index')];
			dialog.remove();
			add(loc);
		    });
		}
	    }).fail((data)=>{
		clear();
		window.alert('Failed to find address');
	    });
	},

	makeRangeRings:function(center,radii,style,angle,ringStyle,labels) {
	    if(angle=='') angle = NaN;
	    style = style??{};
	    let rings = [];
	    let labelStyle = {labelAlign:style.labelAlign??'lt',
			      fontSize:style.fontSize??'10pt',
			      fontColor:style.fontColor??'#000'};
	    for(a in style) {
		if(a.indexOf('label')>=0|| a.indexOf('font')>=0 || a.indexOf('textBackground')>=0) {
		    labelStyle[a] = style[a];
		}
	    }
	    for(let idx=radii.length-1;idx>=0;idx--) {
		let km =radii[idx];
		if(km==null) continue;
		let skm = String(km).trim();
		if(skm.endsWith(UNIT_MILES)) {
		    km = 1.60934*parseFloat(skm.replace(UNIT_MILES,''));
		} else if(skm.endsWith(UNIT_NM)) {
		    km = 1.852*parseFloat(skm.replace(UNIT_NM,''));
		} else if (skm.endsWith(UNIT_FT)) {
		    km = 0.0003048*parseFloat(skm.replace(UNIT_FT,''));
		} else if (skm.endsWith(UNIT_KM)) {
		    km = skm.replace(UNIT_KM,'');
		} else if (skm.endsWith(UNIT_M)) {
		    km = parseFloat(skm.replace(UNIT_M,''))/1000;
		} else {
		    //console.log('unknown unit:' + skm);
		}
		let p1 = MapUtils.createLonLat(center.lon??center.x, center.lat??center.y);
		let p2 = Utils.reverseBearing(p1,Utils.isDefined(angle)&& !isNaN(angle)?angle:90+45,km);
		if(p2==null) {
		    console.error("Could not create range rings with center:",center,p2,km);
		    return null;
		}
		p1 = this.getMap().transformLLPoint(p1);
		p2 = this.getMap().transformLLPoint(p2);
		let dist = Utils.distance(p1.lon,p1.lat,p2.lon,p2.lat);
		let ring = OpenLayers.Geometry.Polygon.createRegularPolygon({x:p1.lon,y:p1.lat},
									    dist, 100,0);
		let _style = $.extend({},style??{strokeWidth:2,strokeColor:'blue',fillColor:'transparent'});
		if(ringStyle['*']) {
		    $.extend(_style,ringStyle['*']);
		}
		if(idx==2*(parseInt(idx/2))) {
		    if(ringStyle['even']) {
			$.extend(_style,ringStyle['even']);
		    }
		} else {
		    if(ringStyle['odd']) {
			$.extend(_style,ringStyle['odd']);
		    }
		}
		if(ringStyle && ringStyle[idx+1]) {
		    $.extend(_style,ringStyle[idx+1]);
		}
		if(idx==radii.length-1 && ringStyle['N']) {
		    $.extend(_style,ringStyle['N']);
		}

		rings.push(MapUtils.createVector(ring,null,_style));
		p2 = MapUtils.createPoint(p2.lon,p2.lat);
		let s = $.extend({},labelStyle);
		if(!isNaN(angle)) {
		    if(labels && idx<labels.length) {
			s.label = labels[idx].replace("${d}",skm);
		    } else {
			s.label=skm;
		    }
		}
		let label = MapUtils.createVector(p2,null,s);
		rings.push(label);
	    }
	    return rings;
	},

	showDistances:function(geometry, glyphType,fadeOut) {
	    let msg = this.getDistances(geometry,glyphType);
	    if(Utils.stringDefined(msg)) {
		this.showMessage2(msg,fadeOut);
	    }
	},

	getLatLonPoints:function(geometry) {
	    let components = geometry.components;
	    if(components==null) {
		if(geometry.x && geometry.y) {
		    let pt = MapUtils.createPoint(geometry.x,geometry.y);
		    pt = this.getMap().transformProjPoint(pt);
		    return [pt];
		}
		return null;
	    }
	    if(components.length) {
		if(components[0].components) components = components[0].components;
	    }
	    let pts = components.map(pt=>{
		return  this.getMap().transformProjPoint(pt)
	    });
	    return pts;
	},

	getDistances:function(geometry,glyphType,justDistance,forceAcres,asObject) {
	    if(!geometry) return null;
	    let pts = this.getLatLonPoints(geometry);
	    if(pts==null) return null;
	    //            let garea = MapUtils.squareMetersToSquareFeet(geometry.getGeodesicArea(this.map.getMap().getProjectionObject()));
            let garea = MapUtils.squareMetersToSquareFeet(geometry.getArea());
	    let area = -1;
	    let acres;

	    if(!glyphType) return '';
	    let distancePrefix = 'Distance: ';

	    if(glyphType == GLYPH_CIRCLE || glyphType == GLYPH_BOX || glyphType == GLYPH_POLYGON || glyphType == GLYPH_TRIANGLE || glyphType == GLYPH_FREEHAND_CLOSED || glyphType==GLYPH_IMAGE) {
		area = MapUtils.calculateArea(pts);
		acres = area/43560;
	    }

	    if(glyphType == GLYPH_CIRCLE || glyphType == GLYPH_BOX ||  glyphType == GLYPH_TRIANGLE  || glyphType==GLYPH_IMAGE) {
		distancePrefix = 'Perimeter: ';
	    }
	    let feet=0;

	    let msg = 'Distance: ';
	    if(glyphType == GLYPH_BOX || glyphType == GLYPH_IMAGE) {
		msg = '';
		let w = MapUtils.distance(pts[0].y,pts[0].x,pts[1].y,pts[1].x);
		let h = MapUtils.distance(pts[1].y,pts[1].x,pts[2].y,pts[2].x);		
		feet = w*2+h*2;
		let unit = UNIT_FT;
		if(w>5280 || h>5280) {
		    unit = UNIT_MILES;
		    w = w/5280;
		    h = h/5280;		    
		}
		msg= 'W: ' + Utils.formatNumberComma(w,1) + ' ' + unit +
		    ' H: ' + Utils.formatNumberComma(h,1) + ' ' + unit;
	    } else {
		let segments = '';
		let total = 0;
		for(let i=0;i<pts.length-1;i++) {
		    let pt1 = pts[i];
		    let pt2 = pts[i+1];		
		    let d = MapUtils.distance(pt1.y,pt1.x,pt2.y,pt2.x);
		    if(!isNaN(d)) {
			feet+=d;
		    }
		    total+=d;
		    let unit = UNIT_FT;
		    if(d>5280) {
			unit = UNIT_MILES;
			d = d/5280;
		    }
		    d = Utils.formatNumberComma(d);
		    segments+= d +' ' + unit +' ';
		}
		let unit = UNIT_FT;
		if(total>3500) {
		    unit = UNIT_MILES;
		    total = total/5280;
		}
		msg = distancePrefix + Utils.formatNumberComma(total) +' ' + unit;
		if(pts.length>2 && pts.length<6)  {
//		    msg+='<br>Segments:' + segments;
		}
		if(pts.length<=1) msg='';
	    }
	    if(asObject) {
		return {
		    feet:feet,
		    sqfeet:area,
		    sqmiles:area/MapUtils.squareFeetInASquareMile,
		    acres:acres

		}
	    }
	    if(!justDistance&&area>0) {
		unit=UNIT_FT;
		if(area>MapUtils.squareFeetInASquareMile) {
		    unit = UNIT_MILES;
		    area = area/MapUtils.squareFeetInASquareMile;
		    msg+=   '<br>' +
			'Area: ' + Utils.formatNumber(area) +' sq ' + unit;
		    if(forceAcres) {
			msg+=   SPACE + Utils.formatNumber(acres) +' acres';
		    }
		} else {
		    msg+=   '<br>' +
			'Area: ' + Utils.formatNumber(acres) +' acres';
		}
	    }

	    return msg;
	},


	setCommandCursor: function(cursor) {
	    this.getMap().setCursor(cursor??'pointer');
	},


	wrapDialog:function(html) {
	    return HU.div([ATTR_STYLE,'margin:5px;'],html);
	},

	setCommand:function(command, args) {
	    this.clearCommands();
	    if(command!=ID_SELECTOR && command!=ID_MOVER) {
		this.unselectAll();
	    }
	    this.command = command;
	    let glyphType = this.getGlyphType(command);
	    this.commands.forEach(cmd=>{
		cmd.deactivate();
	    });
	    if(!command) {
		return;
	    }
	    this.jq('new_' + command).addClass('imdv-command-active');
	    this.commands.every(cmd=>{
		if(cmd.name != command) {
		    return true;
		}
		if(!glyphType) {
		    this.showCommandMessage(cmd.message);
		    cmd.activate();
		    return false;
		}
		this.initGlyphCommand(glyphType, cmd,args);
		return false;
	    });
	},
	initGlyphCommand:function(glyphType, cmd,args) {
	    if(glyphType.isOSM()) {
		this.initOSMSearch();
		return;
	    }

	    args = args ??{};
	    this.setCommandCursor();
	    let styleMap = MapUtils.createStyleMap({'default':{}});
	    let tmpStyle = Utils.clone({},glyphType.getStyle());
	    let tmpMapOptions =  tmpStyle.mapOptions = {
		type:glyphType.type
	    }
	    if(glyphType.isZoom() || glyphType.isFixed() || glyphType.isGroup()) {
		let text = args.text;
		if(!text) text = prompt(glyphType.isZoom()?'Enter zoom to label':glyphType.isFixed()?'Text:':'Name:');
		if(!text) return;
		let style = Utils.clone({},tmpStyle);
		let mapOptions = Utils.clone({},tmpMapOptions);
		style.text = text;
		if(glyphType.isGroup()) {
		    style.externalGraphic = glyphType.getIcon();
		    mapOptions.name = text;
		}
		this.clearCommands();
		if(glyphType.isZoom()) {
		    mapOptions.name = text;
		    delete  style.text;
		    this.setZoomOptions(mapOptions);
		}
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		this.addGlyph(mapGlyph);
		this.clearMessage2(1000);
		this.clearCommands();
		if(glyphType.isFixed()) {
		    mapGlyph.addFixed();
		}
		return mapGlyph;
	    }

	    if(glyphType.isMapServer()) {
		if(this.mapServerDialog) {
		    this.mapServerDialog.show();
		    return;
		}
		let wmtHtml = '';
		wmtHtml+='<br>';
		wmtHtml+='<br>Or enter either a TMS/WMS server URL with a layer name:';
		let form = (label,name,size)=>{
		    wmtHtml+=HU.formEntry(label+':',HU.input('',this.cache[name]??'',[ATTR_ID,this.domId(name),'size',size??'60']));
		}
		let args = [
		    ['Name','servername'],
		    ['Server URL','serverurl'],
		    ['WMS Layer','wmslayer','20'],
		    ['Legend URL','maplegend']
		];

		this.cache = this.cache??{};
		wmtHtml +=  HU.formTable();
		args.forEach(a=>{
		    form(a[0],a[1],a[2]);
		});
		wmtHtml+='</table>';
		wmtHtml+='<br>Or enter Tile JSON URL:';
		wmtHtml +=  HU.formTable();
		form("Tile JSON",'tilejson',60);
		wmtHtml +=  '</table>';

		let contents = [];
		let ids =Utils.mergeLists([{value:'',label:'Select'}],RAMADDA_MAP_LAYERS.map(l=>{return [l.id,l.name]}));
		let predefined =  HU.select('',[ATTR_ID,this.domId('predefined')],ids,this.cache['predefined']);	
		let html = 'Pre-defined layer: ' + predefined;
		html+=wmtHtml;


		let buttons = HU.buttons([
		    HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK'),
		    HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel')]);
		html+=buttons;
		contents.push({label:'WMS/WMTS',contents:html});

		let datacube = HU.div([ATTR_ID,this.domId('datacube_contents')],'Loading...');
//		contents.push({label:'Data Cubes',contents:datacube});

		let stac = HU.div([ATTR_ID,this.domId('stac_contents')]);
//		contents.push({label:'STAC',contents: stac});

//		let tabs = HU.makeTabs(contents)
		//For now just show the WMS
		let tabs = HU.div([],HU.b(contents[0].label)) +
		    contents[0].contents;
//		html=HU.div([ATTR_STYLE,'min-width:600px;min-height:400px;margin:10px;'], tabs.contents);
		html=HU.div([ATTR_STYLE,'min-width:600px;min-height:400px;margin:10px;'], tabs);

		let dialog = this.mapServerDialog = HU.makeDialog({remove:false,content:html,title:'Map Server',header:true,my:'left top',at:'left bottom',draggable:true,anchor:this.jq(ID_MENU_NEW)});
		//We don't want to remove the dialog, just show it
		dialog.remove= () =>{
		    dialog.hide();
		}
//		tabs.init();
		this.initDatacube(dialog);
		this.initStac(dialog);
		let cancel = ()=>{
		    dialog.hide();
		}
		let loadLayer= (args) =>{
		    args = args??{};
		    let style = Utils.clone({},tmpStyle);
		    let mapOptions = Utils.clone({},tmpMapOptions);
		    mapOptions.bounds=args.bounds;
		    mapOptions.name = args.name;
		    mapOptions.legendText = args.legendText;
		    this.clearCommands();
		    let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		    mapGlyph.setMapServerUrl(args.url,args.layerName,args.legendUrl,this.jq('predefined').val());
		    mapGlyph.checkMapServer();
		    this.addGlyph(mapGlyph);
		    this.clearMessage2(1000);
		    dialog.remove();
		    if(mapGlyph.hasBounds()) {
			mapGlyph.panMapTo();
		    }
		}
		let ok = ()=>{
		    args.forEach(a=>{
			this.cache[a[1]] =  this.jq(a[1]).val().trim();
		    });
		    let predefined = this.jq('predefined').val().trim();
		    let tileJson = this.jq('tilejson').val();
		    if(Utils.stringDefined(tileJson)) {
			$.getJSON(tileJson, (data)=> {
			    let args = {
				name:data.name,
				url:data.tiles[0],
			    };
			    if(data.attribution && data.attribution_link) {
				args.legendText = HU.href(data.attribution_link,"Courtesy: "+ data.attribution,['target',
												  '_other']);
			    }
			    if(data.bounds) {
				args.bounds=data.bounds;
			    }
			    loadLayer(args);
			}).fail((data)=>{
			    window.alert('Failed to find address');
			});
			return;
		    }

		    let url = this.jq('serverurl').val();
		    if(!Utils.stringDefined(url) && !Utils.stringDefined(predefined)) {
			alert('Please enter a map server');
			return;
		    }
		    loadLayer({
			name:this.jq('servername').val(),
			url:url,
			layerName:this.jq('wmslayer').val(),
			legendUrl:this.jq('maplegend').val()
		    });

		}
		dialog.find('.ramadda-button-ok').button().click(ok);
		dialog.find('.ramadda-button-cancel').button().click(()=>{
		    dialog.hide();
		});
		return;
	    }




	    if(glyphType.isImage() || glyphType.isEntry()||glyphType.isMultiEntry() || glyphType.isMap() || glyphType.isData()) {
		let callback = (entryId,imageUrlOrEntryAttrs,resourceId) =>{
		    let attrs = {};
		    let imageUrl;
		    if(typeof imageUrlOrEntryAttrs == 'string') {
			imageUrl = imageUrlOrEntryAttrs;
		    } else {
			attrs = imageUrlOrEntryAttrs;
		    }
		    let mapOptions = Utils.clone({},tmpMapOptions);
		    attrs.entryId = entryId;
		    let style = Utils.clone({},tmpStyle);

		    if(glyphType.isMultiEntry()) {
			style.externalGraphic = attrs.icon??glyphType.getIcon();
		    }

		    if(glyphType.isImage()) {
			style.strokeColor='#ccc';
			style.fillColor = 'transparent';
		    } else {
			$.extend(mapOptions,attrs);
		    }
		    mapOptions.entryId = entryId;
		    mapOptions.entryType = attrs.entryType;
		    mapOptions.thumbnailUrl = attrs.thumbnailUrl;
		    attrs.name = attrs.name??Utils.makeLabel(attrs.entryName);
		    delete attrs.entryName;
		    if(glyphType.isMap()) {
			if(resourceId) {
			    let resource  =MapUtils.MAP_RESOURCES_MAP[resourceId];
			    attrs.name = Utils.makeLabel(resource.name);
			    attrs.entryType = resource.type;
			    attrs.resourceUrl = resource.url;
			    if(resource.style) $.extend(style,resource.style);
			}

			$.extend(mapOptions,attrs);
			let mapGlyph = this.handleNewFeature(null,style,mapOptions);
			mapGlyph.checkMapLayer(true);
//			this.clearCommands();
			return;
		    } 

		    //Hacky, gotta clean up all of this
		    if(attrs.name && !glyphType.isImage()) {
			style.label = attrs.name;				
		    }

		    if(glyphType.isMultiEntry()) {
			this.clearCommands();
			mapOptions.name = mapOptions.entryName?? attrs.entryName;
			delete mapOptions['icon'];
			delete mapOptions['entryName']
			let mapGlyph = this.handleNewFeature(null,style,mapOptions);
			mapGlyph.addEntries(true);
			this.clearCommands();
			return
		    }

		    if(glyphType.isData()) {
			this.clearCommands();
			mapOptions.name = mapOptions.entryName?? attrs.entryName;
			delete mapOptions['entryName']
			this.createData(mapOptions);
			this.clearCommands();
			return;
		    }

		    if(glyphType.isImage() && Utils.isDefined(attrs.north) &&
		       Utils.isDefined(attrs.west) &&
		       Utils.isDefined(attrs.south) &&
		       Utils.isDefined(attrs.east)) {
			style.strokeColor='transparent';
			let feature = this.makeFeature(this.getMap(),'OpenLayers.Geometry.Polygon', style,
						       [attrs.north,attrs.west,attrs.north, attrs.east,
							attrs.south,attrs.east,
							attrs.south, attrs.west]);
			attrs.type = GLYPH_IMAGE;
			if(!attrs.isImage) {
			    style.imageUrl = attrs.thumbnailUrl;
			    if(!style.imageUrl) {
				alert("Selected entry does not have an image");
				return;
			    }
			} else {
			    style.imageUrl = Ramadda.getUrl('/entry/get?entryid=' + entryId);
			}
			let mapGlyph = new  MapGlyph(this, GLYPH_IMAGE,attrs,feature,style);
			mapGlyph.checkImage(feature);
			this.addGlyph(mapGlyph);
			mapGlyph.panMapTo();
			return;
		    }

		    if(glyphType.isEntry() && (Utils.isDefined(attrs.latitude) || Utils.isDefined(attrs.north))) {
			if(confirm('Do you want to use this entry\'s location?')) {
			    style = $.extend({},style);
			    style.externalGraphic =attrs.icon;
			    mapOptions.useentrylocation = true;
			    mapOptions.name = attrs.name;
			    let points = Utils.isDefined(attrs.latitude)?[attrs.latitude,attrs.longitude]:[attrs.north,attrs.west];
			    let mapGlyph = this.createMapMarker(GLYPH_ENTRY,mapOptions, style,points,true);
			    mapGlyph.applyDataIcon();
			    this.clearCommands();
			    mapGlyph.panMapTo();
			    return
			}
		    }

		    if(glyphType.isImage()) {
			let url = imageUrl ?? attrs.url;
			if(!url) {
			    if(!attrs.isImage) {
				url = attrs.thumbnailUrl;
				if(!url) {
				    alert("Selected entry does not have an image X");
				    return;
				}
			    } else {
				url = Ramadda.getUrl('/entry/get?entryid=' + entryId);
			    }
			}
			this.lastImageUrl = url;
			style.imageUrl = url;
		    } else if(attrs.icon) {
			style.externalGraphic = attrs.icon;
		    }
		    mapOptions.entryId = entryId;
		    mapOptions.name = attrs.name;			    
		    cmd.handler.style = style;
		    style.mapOptions = Utils.clone({},mapOptions);
		    cmd.handler.layerOptions.styleMap=styleMap;
		    this.showCommandMessage(glyphType.isImage()?'Click and drag to create image':'New Entry Marker');
		    cmd.activate();
		    if(this.selector) this.selector.cancel(true);
		};

		if(args.url) {
		    if(args.entryId)
			callback(args.entryId,args);
		    else
			callback(null, args.url);
		    return;
		}
		
		//Do this a bit later because the dialog doesn't get popped up
		let initCallback = ()=>{
		    this.jq('mapresource').change(()=>{
			callback('',{},this.jq('mapresource').val());
			if(this.selector) this.selector.cancel();
		    });
		    this.jq('imageurl').keypress(function(e){
			if(e.keyCode == 13) {
			    callback('',$(this).val());
			}
		    });
		};
		let extra = null;
		if(glyphType.isImage()) {
		    extra = HU.b('Enter Image URL: ') + HU.input('',this.lastImageUrl??'',[ATTR_ID,this.getDomId('imageurl'),'size','40']);
		} else if(glyphType.isMap() && MapUtils.MAP_RESOURCES) {
		    let ids = MapUtils.MAP_RESOURCES.map((r,idx)=>{
			return [idx,r.name];
		    });
		    ids = Utils.mergeLists([['','Select Resource']],ids);
		    extra = HU.b('Load Map: ') + HU.select('',[ATTR_ID,this.domId('mapresource')],ids);
		}			    
		if(extra!=null) {
		    extra = this.wrapDialog(extra + '<br>Or select entry:');
		}



		let props = {title:glyphType.isImage()?'Select Image':
			     (glyphType.isEntry()||glyphType.isMultiEntry()?'Select Entry':glyphType.isData()?'Select Data':'Select Map'),
			     extra:extra,
			     initCallback:initCallback,
			     callback:callback,
			     'eventSourceId':this.domId(ID_MENU_NEW)};
		let entryType = glyphType.isImage()?'type_image,type_document_pdf,geo_gdal,latlonimage':glyphType.isMap()?Utils.join(MAP_TYPES,','):'';
		props.typeLabel  = glyphType.isImage()?'Images':glyphType.isMap()?'Maps':'';
		this.selector = RamaddaUtils.selectCreate(null, HU.getUniqueId(''),'',false,'entryid',this.getProperty('entryId'),entryType,null,props);
		return
	    } 
	    if(glyphType.getType() == GLYPH_MARKER) {
		let input =  HU.textarea('',this.lastText??'',[ATTR_ID,this.domId('labeltext'),'rows',3,'cols', 40]);
		let html =  HU.formTable();
		html += HU.formEntryTop('Label:',input);
		let prop = 'externalGraphic';
		let icon = this.lastIcon || tmpStyle.externalGraphic;
		let targetIconId = this.domId(prop+'_image');
		let icons = HU.image(icon,[ATTR_ID,targetIconId]) +
		    HU.hidden('',icon,[ATTR_ID,this.domId(prop)]);
		if(!Utils.isDefined(this.lastIncludeIcon)) this.lastIncludeIcon = true;
		html += HU.formEntry('',HU.checkbox(this.domId('includeicon'),[],this.lastIncludeIcon,'Include Icon')+' ' + icons);
		html+='</table>';
		html+=HU.div([ATTR_STYLE,HU.css('text-align','center','padding-bottom','8px','margin-bottom','8px','border-bottom','1px solid #ccc')],
			     HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK') + SPACE2 +
			     HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel'));
		
		html+=HU.b('Select Icon');
		html+=HU.div([ATTR_ID,this.domId('recenticons')]);
		html+=HU.div([ATTR_ID,this.domId('icons'),'icon-property',prop]);
		html=HU.div([ATTR_STYLE,HU.css('margin','5px')],html);
		let dialog =  HU.makeDialog({content:html,title:'Marker',header:true,my:'left top',at:'left bottom',draggable:true,anchor:this.jq(ID_MENU_NEW)});

		let closeDialog = () =>{
		    dialog.remove();
		}

		this.initIconSelection(this.jq('icons'));
		let cancel = ()=>{
		    closeDialog();
		}
		let ok = ()=>{
		    let style = Utils.clone({},tmpStyle);
		    style.mapOptions = Utils.clone({},tmpMapOptions);
		    let doIcon = this.lastIncludeIcon  = this.jq('includeicon').is(':checked');
		    if(!doIcon) {
			style.externalGraphic=icon_blank;
		    } else {
			this.lastIcon = this.jq('externalGraphic').val();
			style.externalGraphic = this.lastIcon;
			style.labelAlign='cb';
			style.labelYOffset='12';
		    }
		    let text = this.jq('labeltext').val();
		    closeDialog();
		    //			    if(!Utils.stringDefined(text)) return;
		    this.lastText = text;
		    style.label = text;
		    cmd.handler.style = style;
		    cmd.handler.layerOptions.styleMap=styleMap;
		    this.showCommandMessage('New Marker');
		    cmd.activate();
		}
		dialog.find('.ramadda-button-ok').button().click(ok);
		dialog.find('.ramadda-button-cancel').button().click(()=>{
		    closeDialog();
		});
		return;
	    }
	    cmd.handler.style = Utils.clone({},tmpStyle);
	    cmd.handler.layerOptions.styleMap=styleMap;
	    let message = glyphType?'New ' + glyphType.getName():cmd.message??'';

	    if(glyphType.isRoute()) {
		this.handleNewRoute(cmd);
		return
	    }

	    this.showCommandMessage('New ' + glyphType.getName() +(glyphType.getNewHelp()?
								   ' - '+ glyphType.getNewHelp():''));
	    cmd.activate();	    

	},
	
	setZoomOptions:function(mapOptions) {
	    mapOptions.zoomLevel = this.getCurrentLevel();
	    mapOptions.mapCenter = this.getMap().getMapCenterLatLon();
	},
	setOSMLabel:function(l,hide) {
	    this.jq(ID_OSM_LABEL).html(l);
	    this.jq(ID_OSM_LABEL).show();
	    if(hide) {
		setTimeout(() =>{
		    this.jq(ID_OSM_LABEL).fadeOut(500)
		},1500);
	    }
	},

	initOSMSearch:function() {
	    if(!this.osm) this.osm = {
		markers:[],
		ids:{}

	    }
	    if(this.osm.dialog) return;

	    let makeList = l=> {
		return l.map(a=>{return [a,Utils.makeLabel(a)];});
	    };


	    let places = makeList(['city', 'town', 'village', 'hamlet',  'island', 'suburb', 'locality']);
	    let tourism = makeList(['hotel','motel','guest_house','alpine_hut','apartment','artwork','attraction','camp_site','caravan_site','chalet','gallery','heritage','hostel','information','museum','picnic_site','theme_park','viewpoint','wilderness_hut','zoo']);
	    let shops = makeList(['supermarket', 'convenience', 'bakery', 'butcher',    'clothes', 'electronics', 'hardware', 'books',    'car', 'bicycle', 'sports', 'shoes' ]);
	    let amenities =makeList(['bar','bbq','bicycle_parking','bicycle_rental','biergarten','bus_station','cafe','car_rental','car_sharing','car_wash','charging_station','cinema','clinic','college','community_centre','courthouse','dentist','doctors','drinking_water','fast_food','ferry_terminal','fire_station','food_court','fountain','fuel','gym','hospital','ice_cream','kindergarten','library','marketplace','monastery','nightclub','nursing_home','park','parking','pharmacy','place_of_worship','police','post_box','post_office','prison','public_bath','pub','recycling','restaurant','school','shelter','taxi','theatre','toilets','townhall','university','veterinary','waste_basket','waste_disposal','water_point']);

	    let html = ''
	    html += HU.formTable();
	    let bbox = this.getMap().getBounds();

	    let fmt = v=>{
		return Utils.trimDecimals(v,1);
	    }
//	    html+=HU.formEntry('BBOX:','N: '+ fmt(bbox.top) +' W: '+fmt(bbox.left) +' S: ' + fmt(bbox.bottom) +
//			       ' E: '+  fmt(bbox.right));
	    html+=HU.formEntry('Text:',
			       HU.input('',this.osm.text??'',[ATTR_ID,this.domId(ID_OSM_TEXT)]));
	    let widgets = [];
	    let widget = (id,label,list) =>{
		widgets.push(HU.b(label+=':')+'<br>'+
			     HU.select('',[ATTR_STYLE,'min-width:200px;',ATTR_ID,this.domId('osm' + id),'multiple','true','size','3'],
				       list,null));
	    }
	    widget('tourism','Tourism',tourism);
	    widget('place','Place',places);
	    widget('shop','Shop',shops);
	    widget('amenity','Amenity',amenities);	    	    	    	    

	    html += HU.formTableClose();
	    html += HU.formTable();	    
	    for(let i=0;i<widgets.length;i+=2) {
		html+=HU.tr([],HU.tds([],[widgets[i],widgets[i+1]]));
	    }
	    html += HU.formTableClose();
	    html += HU.formTable();	    
	    html+=HU.formEntry('Limit:',
			       HU.input('',this.osm.limit??'100',[ATTR_ID,this.domId('osmlimit'),ATTR_SIZE,10]));	    
	    html += HU.formTableClose();	    
	    let buttons =Utils.join([HU.div([ATTR_CLASS,'ramadda-button-ok ramadda-button'], 'Search'),
				     HU.div([ATTR_CLASS,'ramadda-button-clear ramadda-button'], 'Clear Markers'),
				     HU.div([ATTR_CLASS,'ramadda-button-add ramadda-button',ATTR_TITLE,'Add markers as glyphs'], 'Add'),				     
				    HU.div([ATTR_CLASS,'ramadda-button-cancel ramadda-button'], 'Close')],
				    SPACE1);

	    html+=HU.vspace();
	    html+=HU.center(buttons);
	    html+=HU.div([ATTR_STYLE,HU.css('min-width','150px')],
			 "&nbsp;" +
			 HU.span([ATTR_ID,this.domId(ID_OSM_LABEL)],'&nbsp;'));
	    html = HU.div([ATTR_CLASS, 'ramadda-dialog'],html);
	    this.osm.dialog = HU.makeDialog({content:html,anchor:this.jq(ID_MENU_NEW),
					     callback:()=>{this.osm.dialog=null;},
					     draggable:true,title:'Open Street Map Query',header:true});

	    let _this = this;
	    this.jq(ID_OSM_TEXT).keydown(e=>{
		if(Utils.isReturnKey(e)) {
		    this.doOSMSearch();
		}
	    });
	    this.osm.dialog.find('.ramadda-button-cancel').button().click(function() {
		_this.osm.dialog.remove();
		_this.osm.dialog=null;
	    });
	    this.osm.dialog.find('.ramadda-button-add').button().click(()=> {
		this.addOSMMarkers();
	    });
	    this.osm.dialog.find('.ramadda-button-clear').button().click(() =>{
		this.clearOSMMarkers();
	    });
	    this.osm.dialog.find('.ramadda-button-ok').button().click(() =>{
		this.doOSMSearch();
	    });
	},

	doOSMSearch:function() {
	    let bbox = this.getMap().getBounds();
	    let bboxq ='(' + Utils.join([bbox.bottom,bbox.left,bbox.top,bbox.right],',') +')';
	    let query = '[out:json];(\n';
	    let clauses = [];
	    let add = key=>{
		let l=this.osm[key] = this.jq('osm' + key).val();
		if(typeof l=='string') {
		    l = [l];
		}
		l.forEach(v=>{
		    if(v!='---') {
			clauses.push('["' + key +'"="' + v+'"]');
		    }
		});	    
	    };
	    add('tourism');
	    add('place');
	    add('shop');
	    add('amenity');

	    let text = this.osm.text = this.jq(ID_OSM_TEXT).val();
	    if(Utils.stringDefined(text)) {
		clauses.push('["name"~"' + text+'", i]');
	    }

	    if(clauses.length==0) {
		alert('Please select a search criteria');
		return;
	    }
	    clauses.forEach(c=>{
		query+='node' +c+bboxq+';\n';
	    });

	    query +=');\nout body;';
	    console.log('osm query:',query);
	    this.setOSMLabel(HU.image(icon_progress) +'&nbsp;&nbsp;Searching...');
	    let url = "https://overpass-api.de/api/interpreter";
	    let callback = data => {
		if(!data.elements?.length) {
		    this.setOSMLabel('No locations found',true);
		    return;
		}
		let limit = this.osm.limit = (this.jq('osmlimit').val()??'500');
		this.handleOSMResults(data,limit);
		this.setOSMLabel('Found ' + data.elements.length +' locations',true);
	    };
	    let  error = error => {
		console.error("Error fetching data:", error)
		let msg = 'An error has occurred.';
		if(error.statusText) msg+=' Error:' + error.statusText;
		this.setOSMLabel(msg);
	    };
	    $.post(url,{data:query},callback).fail(error);
	},

	clearOSMMarkers: function() {
	    this.osm.markers.forEach(m=>{
		this.getMap().removeMarker(m.marker);
	    });
	    this.osm.markers=[];
	    this.osm.ids={};
	},
	addOSMMarkers:function() {
	    let group =    this.initGlyphCommand(this.groupGlyphType,null,{text:'OSM Group'});
	    this.osm.markers.forEach(m=>{
		let points = [m.latitude,m.longitude];
		let style = $.extend({},this.markerGlyphType.glyphStyle);
		style.label = m.name??'';
		style.popupText = m.text;
		let mapGlyph = this.createMapMarker(GLYPH_MARKER,{type:GLYPH_MARKER,name:m.name,legendText:m.text}, style,points,true);
		group.addChildGlyph(mapGlyph);
	    });
	    this.clearOSMMarkers();
	    this.makeLegend();

	},
	handleOSMResults: function(data,limit) {
	    limit = +limit;
//	    console.dir(data);
	    let cnt = 0;
	    let bounds = new RamaddaBounds();
	    data.elements.every((e,idx)=>{
		if(idx>=limit) return false;
		if(this.osm.ids[e.id]) return true;
		this.osm.ids[e.id] = true;
		let lonlat = MapUtils.createLonLat(e.lon,e.lat);
		let name =null;

		let popup = '<table>';
		if(e.tags) {
		    Object.keys(e.tags).forEach(k=>{
			let v = e.tags[k];
			if(k=='name') {
			    name = v;
			    return;
			}
			v  = String(v);
			if(v.startsWith('http')) {
			    v = HU.href(v,v);
			}
			let label  =k;
			if(label.startsWith('addr:')) label = label.substring('addr:'.length);
			label = Utils.makeLabel(label);
			popup+=HU.formEntry(label+':',v);
		    });
		}
		popup += '</table>';

		if(name) popup  =HU.center(HU.b(name)) + popup;
		let marker = this.getMap().addMarker('location', lonlat, null, '', popup, 20, 20);
		cnt++;
		bounds.expand(e.lat,e.lon);
		this.osm.markers.push({ latitude:e.lat,longitude:e.lon,
					marker:marker,name:name??'',
					text:popup,data:e});
		return true;
	    });
	    if(cnt>0) {
		this.getMap().setViewToBounds(bounds);
	    }
	},
	initStac:function(dialog) {
	    let load;
	    let stac= HU.div([ATTR_ID,this.domId('stac_top')]) +
		HU.div([ATTR_ID,this.domId('stac_output')]);
	    this.jq('stac_contents').html(stac);
	    let catalogUrl = Ramadda.getUrl('/resources/stac_catalogs.json');
	    let stacLinks = [{value:'',label:'Select'}, {value:catalogUrl,label:'Stac Catalogs'},
			     {value:Ramadda.getUrl('/resources/pc_catalog.json'),label:'Planet Earth Catalogs'}];
	    let seenStacUrls = {};
	    seenStacUrls[catalogUrl]=true;
	    let makeTop=(current)=>{ 
		let input = this.jq('stac_input').val()??'';
		let plus = HU.span([ATTR_ID,this.domId('stac_add'),ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Add a STAC catalog URL'],HU.getIconImage('fas fa-plus'));
		let back  = HU.span([ATTR_ID,this.domId('stac_back'),ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Go back'],HU.getIconImage('fas fa-rotate-left'));

		let top = back +' ' + plus+' '+HU.select("",[ATTR_STYLE,'max-width:500px;overflow:none;',ATTR_ID,this.domId('stac_url')],stacLinks,current,100);
		top = HU.div([ATTR_STYLE,'border-bottom:1px solid #ddd;padding-bottom:6px;margin-bottom:6px;'], top);
		this.jq('stac_top').html(top);
		this.jq('stac_url').change(()=>{
		    let url = this.jq('stac_url').val();
		    if(Utils.stringDefined(url)) {
			load(url);
		    }
		});
		this.jq('stac_input').keypress((event)=>{
                    if (event.which == 13) {
			let url = this.jq('stac_input').val();
			if(!Utils.stringDefined(url)) {
			    return;
			}
			load(url);
		    }
		});
		this.jq('stac_back').click(()=>{
		    if(!this.currentStacUrl) return;
		    let index = stacLinks.findIndex(item=>{return item.value==this.currentStacUrl});
		    if(index>0) {
			load(stacLinks[index-1].value);
		    }
		});


		this.jq('stac_add').click(function() {
		    let link = HU.href('https://stacindex.org/catalogs',HU.getIconImage('fas fa-binoculars'),['target','_stacindex',ATTR_TITLE,'Look for catatalogs on stacindex.org']);
		    let input = HU.input('','',[ATTR_ID,_this.domId('stac_add_url'),ATTR_STYLE,'width:400px;'])+' ' +link;
		    let html = HU.b('STAC  Catalog URL: ') + input;
		    html+= HU.buttons([
			HU.div([ATTR_CLASS,'stac-add-ok display-button'], 'OK'),
			HU.div([ATTR_CLASS,'stac-add-cancel display-button'], 'Cancel')]);
		    html=HU.div([ATTR_STYLE,'margin:5px;margin-top:10px;'],html);	
		    let dialog =  HU.makeDialog({content:html,anchor:$(this),remove:false,xmodal:true,sticky:true});

		    _this.jq('stac_add_url').keypress((event)=>{
			if (event.which == 13) {
			    let url = _this.jq('stac_add_url').val();
			    if(Utils.stringDefined(url))
				load(url);
			    dialog.remove();
			}
		    });
		    dialog.find('.display-button').button().click(function() {
			if($(this).hasClass('stac-add-ok')) {
			    let url = _this.jq('stac_add_url').val();
			    if(Utils.stringDefined(url))
				load(url);
			}
			dialog.remove();
		    });
		});



		this.jq('stac_go').button().click(()=>{
		    let url = this.jq('stac_input').val();
		    if(!Utils.stringDefined(url)) {
			url = this.jq('stac_url').val();
		    }
		    if(!Utils.stringDefined(url)) {
			return;
		    }
		    load(url);
		});
	    };
	    makeTop();

	    let _this = this;
	    let showStac=(data,baseUrl)=>{
		//is it the stac_catalogs.json
		if(Array.isArray(data)) {
		    data = {
			title:'Stac Catalogs',
			links:data
		    }
		}
		
		let html = '';
		let title = (data.title??baseUrl)+HU.space(1) + HU.href(baseUrl,HU.getIconImage('fas fa-link',[],[ATTR_STYLE,'font-size:9pt;']),['target','_stac']);
		html+=HU.center(HU.b(title));
		if(data.description) {
		    let desc = Utils.stripTags(data.description);
		    //		    console.log('BEFORE:'+desc);
		    desc = desc.replace(/[\n\s*\n]\n+/g,'\n').trim();
		    //		    console.log("AFTER:" +desc);
		    desc = desc.replace(/[\n\n]+/g,'\n').replace(/\n/g,'<br>');
		    html+=HU.div([ATTR_CLASS,'boxquote',ATTR_STYLE,'max-width:600px;overflow-z:auto;max-height:100px;overflow-y:auto;'],desc);
		}
		let linksHtml1 ='';
		let linksHtml2 ='';		
		if(data.links) {
		    let cnt = 0;
		    data.links.forEach(link=>{
			let url = link.href??link.url??link.link;
			if(!Utils.stringDefined(url) ||link.rel=='self') return;
			if(baseUrl.startsWith("http:")  || baseUrl.startsWith("https:")) 
			   url = new URL(url,baseUrl).href;
			let label = link.title;
			if(!label)
			    label  = url.replace(/.*\/([^\/]+$)/,"$1");
			let href = HU.href(url,HU.getIconImage('fas fa-link',[],[ATTR_TITLE,link.summary??'',ATTR_STYLE,'font-size:9pt;'])+' '+label+(link.rel?' ('+link.rel+')':''),['target','_stactarget',ATTR_CLASS,CLASS_CLICKABLE]);

			let isJson;
			if(Utils.isDefined(link.variables)) {
			    isJson = true;
			} else if(Utils.stringDefined(link.type)) {
			    isJson  = link.type == 'application/json' || link.type == 'application/geo+json';
			} else {
			    //Some guess work
			    if(link.rel)
				isJson = ['next','search','parent','root','child','items','search'].includes(link.rel);
			    if(!isJson) isJson = url.endsWith('json');
			}

			if(!isJson) {
			    linksHtml2+=HU.tr(HU.td([ATTR_WIDTH,'10%','nowrap','true'],'')+HU.td(href));
			} else {
			    linksHtml1+=HU.tr(HU.td([ATTR_WIDTH,'10%','nowrap','true'],
						    HU.div([ATTR_TITLE,url,ATTR_CLASS,'imdv-stac-item'],HU.span(['link',url,ATTR_CLASS,'imdv-stac-link'], 'Load'))) +
					      HU.td(href));
			}

		    });
		}

		let assetsHtml = '';
		if(data.assets) {
		    let table='';
		    let images = '';
		    let other = '';
		    Object.keys(data.assets).forEach((key,idx)=>{
			//limit the number
			if(idx>200) return;
			let asset = data.assets[key];
			if(!Utils.stringDefined(asset.href)) return;
			if(table=='') {
			    table+=HU.b('Assets: ')+'note: the IMDV does not handle all projections. Try the thumbnail<br>';
			    table +='<table width=100%>';
			}

			let label = asset.name??asset.title??key;
			let assetUrl = new URL(asset.href,baseUrl).href;
			let link = HU.href(assetUrl,HU.getIconImage('fas fa-link',[],[ATTR_STYLE,'font-size:9pt;'])+' ' +label +' ('+ asset.type+')',[ATTR_TITLE,assetUrl,'target','_stactarget',ATTR_CLASS,CLASS_CLICKABLE]);
			let type= asset.type??asset.media_type;
			let isImage = type&& type.indexOf('image')>=0;

			if(asset.href.endsWith('ovr')) isImage= false;
			if(isImage) {
			    images+=HU.tr(HU.td([ATTR_WIDTH,'10%','nowrap','true'], HU.div([ATTR_CLASS,'imdv-stac-item'],HU.span(['asset-id',key,ATTR_CLASS,'imdv-stac-asset'], 'Add Image')))+
					  HU.td(link));
			} else {
			    other+=HU.tr(HU.td('')+ HU.td(link));
			}
		    });
		    table+=images;
		    table+=other;
		    table+'</table>';
		    assetsHtml=table;
		}
		let linksHtml = linksHtml1+linksHtml2;
		if(linksHtml!='') {
		    html+=HU.b('Links:<br>');
		    linksHtml=HU.table(linksHtml);
		    if(assetsHtml!='') 
			html+=HU.div([ATTR_STYLE,'max-height:5em;overflow-y:auto;'], linksHtml);
		    else
			html+= linksHtml;		    
		}

		html+=assetsHtml;
		html=HU.div([ATTR_STYLE,'max-height:300px;overflow-y:auto;'], html);
		this.jq('stac_output').html(html);
		this.jq('stac_output').find('.imdv-stac-link').button().click(function() {
		    load($(this).attr('link'));
		});
		this.jq('stac_output').find('.imdv-stac-asset').button().click(function() {
		    let bbox=data.bbox;
		    if(!data.bbox) {
			bbox = data?.extent?.spatial?.bbox;
			if(bbox) {
			    bbox=bbox[0];
			    if(bbox) bbox = [bbox[0],bbox[3],bbox[2],bbox[1]];
			}
		    }
		    if(!bbox) {
			alert('No bbox found');
			return
		    }
//		    console.log(bbox);
		    let asset =  data.assets[$(this).attr('asset-id')];
		    let url = new URL(asset.href,baseUrl).href;
		    if(asset.type&& asset.type.indexOf('image/tiff')>=0) {
			url =   Ramadda.getUrl('/tifftopng?url=' + encodeURIComponent(url));
		    }
		    console.log(url);
		    let attrs = {
			type:GLYPH_MAP,
			entryType:'stacimage',
			icon:'/repository/icons/mapfile.png',
			name:asset.name??asset.title,
			bbox:bbox,
			resourceUrl:url
		    }
		    let mapGlyph = _this.handleNewFeature(null,{rotation:0,transform:''},attrs);
		    mapGlyph.checkMapLayer(true);
		});
	    };
	    load = (url) =>{
		if(!Utils.stringDefined(url)) return;
		this.currentStacUrl = url
		this.jq('stac_url').val(url);
		let _this = this;
		this.jq('stac_output').html('Loading...');
		$.getJSON(url, data=>{
		    if(!seenStacUrls[url]) {
			seenStacUrls[url]=true;
			stacLinks.push({value:url,label:data.title??url});
			makeTop(url);
		    }
		    showStac(data,url);
		}).fail(err=>{
		    //		    console.dir(err);
		    //JSON.parse(err.responseText)
		    console.dir(err);
		    this.jq('stac_output').html('Load failed. URL: ' + url);
		});
	    }
	},
	initDatacube:function(dialog) {
	    let _this = this;
	    let datacube= HU.div([ATTR_ID,this.domId('datacube_top')]) +
		HU.div([ATTR_ID,this.domId('datacube_output')]);
	    this.jq('datacube_contents').html(datacube);

	    let load;
	    let datacubeLinks = [{value:'',label:'Select'}];
	    MapUtils.getMapProperty('datacubeservers','').split(',').forEach(c=>{
		datacubeLinks.push(c);
	    });

	    let makeTop=(current)=>{ 
		let input = this.jq('datacube_input').val()??'';
		let plus = HU.span([ATTR_ID,this.domId('datacube_add'),ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Add a Data Cube server URL'],HU.getIconImage('fas fa-plus'));
		let top =plus +' ' +HU.select("",[ATTR_STYLE,'max-width:500px;overflow:none;',ATTR_ID,this.domId('datacube_url')],datacubeLinks,current,100);
		top = HU.div([ATTR_STYLE,'border-bottom:1px solid #ddd;padding-bottom:6px;margin-bottom:6px;'], top);
		this.jq('datacube_top').html(top);

		this.jq('datacube_add').click(function() {
		    let input = HU.input('','',[ATTR_ID,_this.domId('datacube_add_url'),ATTR_STYLE,'width:400px;']);
		    let html = HU.b('DATACUBE  Catalog URL: ') + input;
		    html+= HU.buttons([
			HU.div([ATTR_CLASS,'datacube-add-ok display-button'], 'OK'),
			HU.div([ATTR_CLASS,'datacube-add-cancel display-button'], 'Cancel')]);
		    html=HU.div([ATTR_STYLE,'margin:5px;margin-top:10px;'],html);
		    let dialog =  HU.makeDialog({content:html,anchor:$(this),remove:false,xmodal:true,sticky:true});

		    let add = ()=>{
			let url = _this.jq('datacube_add_url').val();
			if(Utils.stringDefined(url)) {
			    load(url);
			    if(!datacubeLinks.includes(url)) {
				datacubeLinks.push(url);
				makeTop(url);
			    }
			}
			dialog.remove();
		    }
		    _this.jq('datacube_add_url').keypress((event)=>{
			if (event.which == 13) {
			    add();
			}
		    });
		    dialog.find('.display-button').button().click(function() {
			if($(this).hasClass('datacube-add-ok')) {
			    add();
			}
			dialog.remove();
		    });
		});


		this.jq('datacube_url').change(()=>{
		    let url = this.jq('datacube_url').val();
		    if(Utils.stringDefined(url)) {
			load(url);
		    }
		});
	    };
	    makeTop();
	    let showDatacube=(data,baseUrl)=>{
		let html='';
		html += HU.formTable();
		let selects = [];
		let variableMap = {}
		let idToMaps = {}	    
		let selectStyle='max-width:300px;overflow-x:hidden;'
		data.datasets.forEach((dataset,idx)=>{
		    let variables  = {};
		    variableMap[''+idx] = variables;
		    if(!dataset.variables) return;
		    let items = [{label:'Select Variable',value:''}];
		    dataset.variables.forEach(v=>{
			variables[v.id] =v;
			items.push({label:v.title,value:v.id});
		    });
		    let selectId = HU.getUniqueId('select_');
		    selects.push(selectId);	
		    html+=HU.formEntry(dataset.title+':',
				       HU.select("",[ATTR_STYLE,selectStyle,ATTR_ID,selectId,'dataset',idx],items));
		    if(dataset.placeGroups) {
			let maps=[{value:'',label:'Select'}];
			dataset.placeGroups.forEach((group,idx)=>{
			    let url = baseUrl+'/places/' + group.id
			    let uid  = Utils.getUniqueId('map');
			    idToMaps[uid] = {label:group.title,value:group.id,url:url};
			    maps.push({label:group.title,value:uid});
			});
			if(maps.length>1) {
			    let selectId = HU.getUniqueId('mapselect_');
			    selects.push(selectId);	
			    html+=HU.formEntry("Maps:",
					       HU.select("",['ismap','true',ATTR_STYLE,selectStyle,ATTR_ID,selectId],maps));
			}
		    }
		});
		html+='</table>';
		html = HU.div([ATTR_STYLE,'auto;max-height:400px;overflow-y:auto;'], html);
		html+= HU.buttons([
		    HU.div([ATTR_CLASS,'ramadda-button-ok-datacube display-button'], 'OK'),
		    HU.div([ATTR_CLASS,'ramadda-button-cancel-datacube display-button'], 'Cancel')]);
		
		let datacubeDialog=this.jq('datacube_output');
		datacubeDialog.html(html);
		datacubeDialog.find('.ramadda-button-ok-datacube').button().click(()=>{
		    let variable;
		    let mapInfo
		    selects.every(sid=>{
			let select=jqid(sid);
			let id = select.val();
			if(Utils.stringDefined(id)) {
			    if(select.attr('ismap')) {
				mapInfo  = idToMaps[id];
			    } else {
				variable=variableMap[select.attr('dataset')][id];
			    }
			    return false;
			}
			return true;
		    });
		    dialog.hide();
		    if(mapInfo) {
			let glyphType = this.getGlyphType(GLYPH_MAP);
			let attrs = {
			    type:GLYPH_MAP,
			    entryType:'geo_geojson',
			    icon:'/repository/icons/mapfile.png',
			    name:mapInfo.label,
			    resourceUrl:mapInfo.url,
			}
			let mapGlyph = this.handleNewFeature(null,glyphType.getStyle(),attrs);
			mapGlyph.checkMapLayer();
			return
		    }		    
		    if(variable) {
			let url = variable.tileUrl;
			url = url.replace('http:','https:');
			url=HU.url(url,['crs','EPSG:3857'])+'&cbar={colorbar}&vmin={vmin}&vmax={vmax}&time={time}';
			delete variable.htmlRepr;
			let mapOptions = {name:variable.title,
					  variable:variable};
			this.clearCommands();
			mapOptions.icon = Ramadda.getUrl('/icons/xcube.png');
			mapOptions.type=GLYPH_MAPSERVER;
			let mapGlyph = new MapGlyph(this,GLYPH_MAPSERVER, mapOptions, null,{});
			mapGlyph.setMapServerUrl(url,'','','');
			mapGlyph.checkMapServer();
			this.addGlyph(mapGlyph);
			this.clearMessage2(1000);
		    }
		});
		datacubeDialog.find('.ramadda-button-cancel-datacube').button().click(()=>{
		    dialog.hide();
		});
	    };

	    load = (url) => {
		if(!Utils.stringDefined(url)) return;
		let baseUrl = url
		//https://api.earthsystemdatalab.net/api/datasets?details=1
		if(url.indexOf('/api/datasets')<0) {
		    url = url +'/datasets?details=1';
		}
		this.jq('datacube_output').html('Loading...');
		console.log(url);
		$.getJSON(url, data=>{
		    showDatacube(data,baseUrl);
		}).fail(err=>{
		    console.error('Failed loading datacube datasets:' + err);
		});
	    };
	},

	createMapMarker:function(glyphType, glyphAttrs,style,points,andAdd) {
	    let feature = this.makeFeature(this.getMap(),'OpenLayers.Geometry.Point', style, points);
	    feature.style = style;
	    this.addFeatures([feature]);
	    let mapGlyph = new MapGlyph(this,glyphType, glyphAttrs, feature,style);
	    mapGlyph.checkImage(feature);
	    if(andAdd) {
		this.addGlyph(mapGlyph);
	    }
	    return mapGlyph;
	},

	clearCommands:function() {
	    this.getMap().closePopup();
	    this.clearMessage2();
	    this.getMap().clearAllProgress();
	    //	    this.unselectAll();
	    HtmlUtils.hidePopupObject();
	    this.showCommandMessage('');
	    let buttons = this.jq(ID_COMMANDS).find('.' + CLASS_CLICKABLE);
	    buttons.removeClass('imdv-command-active');
	    buttons.each(function() {
		$(this).attr('selected',false);
	    });
	    this.commands.forEach(cmd=>{
		cmd.deactivate();
	    });
	    this.command= null;
	},
	getMapOptions: function(feature) {
	    if(feature.mapOptions) return feature.mapOptions;
	    let mapOptions = feature.style?feature.style.mapOptions:{};
	    if(!mapOptions) {
		mapOptions = {};
		if(feature.style) {
		    mapOptions.type = feature.style.type;
		}
	    }  else if(feature.style) {
		delete feature.style.mapOptions;
	    }
	    feature.mapOptions = mapOptions;
	    return mapOptions;
	},
	initGlyphButtons:function(dom) {
	    if(!dom) return;
	    let _this = this;
	    //init any buttons
	    dom.find('.ramadda-button').button();

	    dom.find('[' + ATTR_BUTTON_COMMAND +']').click(function(event) {
		event.preventDefault();
		let command  = $(this).attr(ATTR_BUTTON_COMMAND);
		let id  = $(this).attr(ID_GLYPH_ID);
		let mapGlyph   = _this.findGlyph(id);
		if(!mapGlyph) {
		    console.error('No map glyph from id:' + id);
		    return;
		}
		if(command=='toback') _this.changeOrder(false,mapGlyph);
		else if(command==PROP_LAYERS_STEP_SHOW) mapGlyph.toggleLayersVisibility(event);
		else if(command==PROP_LAYERS_ANIMATION_PLAY) mapGlyph.toggleLayersAnimation(event);
		else if(command=='tofront') _this.changeOrder(true,mapGlyph);		
		else if(command=='popup')   _this.handleMapGlyphClick(mapGlyph);
		else if(command=='edit')  _this.editFeatureProperties(mapGlyph,$(this));
		else if(command=="addisoline")  _this.addIsolineForMarker(mapGlyph);
		else if(command==ID_SELECT) {
		    if(mapGlyph.isSelected()) 
			_this.unselectGlyph(mapGlyph);
		    else
			_this.selectGlyph(mapGlyph);
		} else if(command==ID_DELETE) {
		    if(_this.dontAskDelete) {
			_this.removeMapGlyphs([mapGlyph]);
		    } else {
			let dontAsk = HU.checkbox(_this.domId('dontask'),[ATTR_ID,_this.domId('dontask'),ATTR_CLASS,''],false,'Don\'t ask again');
			HU.makeOkCancelDialog($(this),'Are you sure you want to delete this glyph?',
					      ()=>{
						  _this.dontAskDelete  = _this.jq('dontask').is(':checked');
						  _this.removeMapGlyphs([mapGlyph]);},null,dontAsk);
		    }
		}
	    });
	},
	
	makeGlyphButtons:function(mapGlyph,includeEdit,debug) {
	    let buttons = [];
	    let icon = i=>{
		return HU.getIconImage(i,[],BUTTON_IMAGE_ATTRS);
	    };
	    let showPopup =(mapGlyph.isEntry() ||  Utils.stringDefined(mapGlyph.getPopupText()));
	    if(showPopup) {
		buttons.push(HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Map Popup',ID_GLYPH_ID,mapGlyph.getId(),
				      ATTR_BUTTON_COMMAND,'popup'],
				     icon('fas fa-arrow-up-from-bracket')));
	    }
	    if((this.canChange() && includeEdit)) {
		buttons.push(HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Settings',ID_GLYPH_ID,mapGlyph.getId(),
				      ATTR_BUTTON_COMMAND,'edit'],
				     icon('fas fa-cog')));
		buttons.push(
		    HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Select',ID_GLYPH_ID,mapGlyph.getId(),
			     ATTR_BUTTON_COMMAND,ID_SELECT],
			    icon('fas fa-hand-pointer')));
		buttons.push(HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Delete',ID_GLYPH_ID,mapGlyph.getId(),
				      ATTR_BUTTON_COMMAND,ID_DELETE],icon('fas fa-eraser')));

		if(mapGlyph.isMarker() && this.isIsolineEnabled()) {
		    buttons.push(HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Add Isoline',
					  ID_GLYPH_ID,mapGlyph.getId(),ATTR_BUTTON_COMMAND,"addisoline"],icon('fa-regular fa-circle-dot')));
		}
	    }
	    if(buttons.length==0) return '';
	    let attrs = [ATTR_STYLE,HU.css('margin-right','8px')];
	    let bar =  Utils.wrap(buttons,HU.open('span',attrs),'</span>');
	    return bar;
	},
	makeListItem:function(mapGlyph,idx) {
	    let style  = mapGlyph.getStyle()||{};
	    let line = "";
	    let type = mapGlyph.getType();
	    let select = HU.span([ATTR_TITLE,'Click to select',ATTR_STYLE,HU.css('padding-left','0px','padding-right','5px'), ID_GLYPH_ID,mapGlyph.getId(),
				  ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'imdv-feature')], HU.getIconImage('fas fa-arrow-pointer'));
	    let visible = HU.checkbox('',[ATTR_STYLE,'margin-right:5px;',ATTR_TITLE,'Visible',ID_GLYPH_ID,mapGlyph.getId(),
					  ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'imdv-feature-visible')],mapGlyph.getVisible());
	    let title =  mapGlyph.getLabel();
	    title+=HU.div([], visible +	mapGlyph.makeLegendButtons());
//		this.makeGlyphButtons(mapGlyph,true);
 	    line += HU.td(['nowrap','',ATTR_STYLE,HU.css('padding','5px')], title);
	    let col = mapGlyph.getDecoration();
	    let msg = this.getDistances(mapGlyph.getGeometry(),mapGlyph.getType());
	    if(msg) {
		col+='' + msg.replace(/<br>/g,' ');
	    }
	    line+= HU.td([ID_GLYPH_ID,mapGlyph.getId(),
			  STYLE,HU.css('padding','5px')],col);
	    return line;
	},	    

	createData:function(mapOptions) {
	    let displayAttrs = {};
	    let callback = text=>{
		let ff = text.match(/"filterFields":\"([^\"]+)"/);
		let regexp = /createDisplay *\( *\"map\" *(.*?)}\);/;
		regexp = /createDisplay\s*\(\s*\"map\"\s*,\s*({[\s\S]+?\})\);/;				
		let match = text.match(regexp);
		let attrs = {};
		let inner;
		let pointDataUrl = null;
		let msg = "";
		if(!match) {
		    msg = "There doesn't seem to be any map displays defined for this entry<br>";
		}
		if(match) {
		    inner = match[1];
		    inner = inner.replace(/\n/g," ");
		    let dr=/\"data\" *: *new *PointData[^\)]+?\)/g;
		    dr=/\"data\"\s*:\s*new\s*PointData\s*\((.*?)\)/g;
		    match  = inner.match(dr);
		    if(match) {
			let re = new RegExp("\"(" + Ramadda.getBaseUrl()+"[^\"]+)\"");
			match = match[0].match(re);
			if(match) 
			    pointDataUrl = match[1];
		    }
		    inner = inner.replace(dr,"");
		    inner = inner.replace(/,\s*\}/g,"}");
                    inner = inner.replace(/,\s*,/g,",");
		    try {
			attrs = JSON.parse(inner);
			if(ff && !attrs.filterFields) attrs.filterFields=ff[1];
		    } catch(err) {
			console.error(err);
			console.error(inner);
		    }
		}
		let skip = ['hereRoutingEnabled','googleRoutingEnabled','canEdit',ATTR_TITLE,'bounds','zoomLevel','mapCenter',ATTR_WIDTH,'height','user','entryIcon','entryId','thisEntryType','fileUrl','popupWidth','popupHeight','divid'];
		let userInput = "";
		for(key in attrs) {
		    if(skip.includes(key)) continue;
		    let value  = attrs[key];
		    if(Array.isArray(value)) continue;
		    userInput+=key+"=" + value+"\n";
		}
		let widget =  msg+HU.textarea("",userInput,[ATTR_ID,this.domId('displayattrs'),"rows",10,"cols", 60]);
		let andZoom = HU.checkbox(this.domId('andzoom'),[],true,"Zoom to display");
		let buttons  =HU.center(HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], "OK") + SPACE2 +
					HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], "Cancel"));
		
		widget = HU.div([ATTR_STYLE,HU.css('margin','4px')], widget+"<br>"+andZoom + buttons);
		
		let dialog =  HU.makeDialog({content:widget,anchor:this.jq(ID_MENU_FILE),title:"Map Display Attributes",header:true,draggable:true,remove:false});

		
		dialog.find('.ramadda-button-ok').button().click(()=>{
		    let displayAttrs = this.parseDisplayAttrs(this.jq('displayattrs').val());
		    displayAttrs.pointDataUrl = pointDataUrl;
		    let mapGlyph = this.handleNewFeature(null,null,mapOptions);
		    mapGlyph.addData(displayAttrs,this.jq("andzoom").is(":checked"));
		    dialog.remove();
		});
		dialog.find('.ramadda-button-cancel').button().click(()=>{
		    dialog.remove();
		});		
	    };
	    let error = text=>{
		alert("An error occurred:" + text);
	    };	    
	    let url = Ramadda.getUrl("/getwiki");
	    $.post(url,{
		entryid:mapOptions.entryId},
		   callback).fail(error);
	},

	parseDisplayAttrs:function(val) {
	    let displayAttrs = {};
	    let lines =  Utils.split(String(val),"\n",true,true,[]);
	    lines.forEach(line=>{
		let toks  =Utils.splitFirst(line,"=");
		if(toks.length==1) {
		    displayAttrs[toks[0]] = "";
		} else 	if(toks.length>=2) {
		    let v = toks[1];
		    if(v=="true") v = true;
		    else if(v=="false") v = false;			    
		    displayAttrs[toks[0]] = v;
		}
	    });
	    return displayAttrs;
	},
	
	addFeatureList:function() {
	    let features="<table width=100%>";
	    this.glyphListMap = {};
            this.glyphs.forEach((mapGlyph,idx)=>{
		this.glyphListMap[idx]  = mapGlyph;
		let clazz = "";
		if(mapGlyph.isSelected()) {
		    clazz+= " " + LIST_SELECTED_CLASS;
		}
		features+=HU.openTag("tr",[ATTR_CLASS,LIST_ROW_CLASS+" " + clazz,ATTR_VALIGN,'top',ATTR_STYLE,'border-bottom:1px solid #ccc',"glyphid",mapGlyph.getId()]);
		let tds=this.makeListItem(mapGlyph,idx);
		features+=tds;
		features+="</tr>";
	    });
	    features+="</table>";
	    let _this  = this;
	    this.jq(ID_LIST).html(features);
	    this.initGlyphButtons(this.jq(ID_LIST));
	    this.jq(ID_LIST).find('.imdv-feature-visible').change(function(){
		let id  = $(this).attr("glyphid");
		let mapGlyph   = _this.findGlyph(id);
		if(!mapGlyph) {
		    console.error("No map glyph from id:" + id);
		    return;
		}
		mapGlyph.setVisible($(this).is(':checked'),true);
	    });
	    this.jq(ID_LIST).find(".imdv-feature").click(function(event) {
		let clazz  = LIST_SELECTED_CLASS;
		let id  = $(this).attr("glyphid");
		let mapGlyph   = _this.findGlyph(id);
		if(!mapGlyph) {
		    console.error("No map glyph from id:" + id);
		    return;
		}
		if (event.shiftKey) {
		    _this.editFeatureProperties(mapGlyph);
		    return;
		}
		let row = $(this).closest('.' + LIST_ROW_CLASS)
		if(row.hasClass(clazz)) {
		    row.removeClass(clazz);
		    _this.unselectGlyph(mapGlyph);
		} else {
		    row.addClass(clazz);
		    _this.selectGlyph(mapGlyph);
		}
	    });
	},
	
	listFeatures:function() {
	    this.clearCommands();
	    let close = () =>{
		if(this.listDialog) {
		    this.listDialog.hide();
		    this.listDialog.remove();
		}
		this.listDialog = null;
	    };
	    close();

	    let html ='';
	    html+=HU.div([ATTR_ID,this.domId(ID_LIST), STYLE,HU.css('margin-bottom','10px','border','1px solid #ccc', 'max-height','300px','max-width','600px','overflow-x','auto','overflow-y','auto')], '');

	    html+='<center>';
	    html +=HU.div([ATTR_ID,this.domId(ID_LIST_DELETE), ATTR_CLASS,'display-button'], 'Delete Selected');
	    html += SPACE2;	    
	    html +=HU.div([ATTR_ID,this.domId(ID_LIST_CANCEL), ATTR_CLASS,'display-button'], 'Close');	    
	    html+='</center>';
	    html  = HU.div([ATTR_CLASS,'wiki-editor-popup'], html);
	    let dialog = this.listDialog  = HU.makeDialog({content:html,anchor:this.jq(ID_MENU_FILE),title:'Features',header:true,draggable:true,remove:false});
	    this.addFeatureList();
	    let _this  = this;
	    this.jq(ID_LIST_DELETE).button().click(()=>{
		let cut  = [];
		this.jq(ID_LIST).find('.imdv-feature-selected').each(function() {
		    let id  = $(this).attr(ID_GLYPH_ID);
		    let mapGlyph   = _this.findGlyph(id);
		    if(!mapGlyph) {
			console.error('No map glyph from id:' + id);
			return;
		    }
		    cut.push(mapGlyph);
		});
		this.removeImages(cut);
		this.setClipboard(cut);
		this.removeMapGlyphs(cut);
	    });
	    this.jq(ID_LIST_CANCEL).button().click(close);
	},
	addFeatures:function(features) {
	    let layer = this.myLayer;
	    layer.addFeatures(features);
	    features.forEach(feature=>{
		feature.layer = layer;
	    });
	    //	    this.featureChanged();
	},
	
	removeMapGlyph:function(mapGlyph) {
	    Utils.removeItem(this.glyphs, mapGlyph);
	},

	removeMapGlyphs: function(mapGlyphs) {
	    mapGlyphs.forEach(mapGlyph=>{
		Utils.removeItem(this.glyphs, mapGlyph);
		mapGlyph.doRemove();
	    });
	    this.handleGlyphsChanged();
	},
	removeFeatures: function(features) {
	    if(features)
		this.myLayer.removeFeatures(features);

	},
	addControl:function(name,msg,control) {
	    control.name = name;
	    control.message=msg;
	    this.map.getMap().addControl(control);
	    this.commands.push(control);
	    return control;
	},

	pasteCount:0,
	doPaste: function(evt) {
	    if(!this.clipboard) return;
	    let clipboard = this.clipboard;
	    this.unselectAll();
	    let newOnes = clipboard.map(mapGlyph=>{
		return  mapGlyph.clone();
	    });
	    for(let i=0;i<newOnes.length;i++) {
		newOnes[i].type = clipboard[i].type;
	    }
	    let h = this.map.getMap().getExtent().getHeight();
	    this.pasteCount++;
	    let delta = (this.pasteCount*0.05)*h;
	    newOnes.forEach(mapGlyph=>{
		mapGlyph.move(delta,-delta);
		mapGlyph.checkImage();
		if(mapGlyph.isMap()) {
		    mapGlyph.checkMapLayer();
		} else if(mapGlyph.isMapServer()) {
		    mapGlyph.checkMapServer();
		}
	    });
	    this.addGlyph(newOnes);
	    newOnes.forEach(mapGlyph=>{
		this.selectGlyph(mapGlyph);});
	},

	initSideHelp:function(dialog) {
	    dialog.find('.imdv-property').click(function(){
		let value = $(this).attr('value');
		if(!value) return;
		value = value.replace(/\\n/g,'\n');
		let target = $(this).attr('target');		
		let textComp = GuiUtils.getDomObject(target);
		if(textComp) {
		    WikiUtil.insertAtCursor('', textComp.obj, value);
		}
	    });
	},
	makeSideHelp:function(lines,target,props){
	    props = props??{};
	    if(!props.prefix) props.prefix='';
	    if(!props.suffix) props.suffix='';	    
	    let help = '';
	    lines.forEach((line)=>{
		if(line=='<hr>') {
		    help+='<thin_hr>';
		    return
		}
		if(line.info) {
		    help+=HU.div([ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'imdv-property-popup'),'target',target,
				  'info-id',line.info], line.title);
		    return;
		}
		let attrs = [ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'imdv-property'),'target',target];
		if(line.title) {
		    attrs.push(ATTR_TITLE,line.title);
		}
		let skip = line.skip;
		if(line.line) {
		    line = line.line;
		}
		if(skip) {
		    help+=HU.div([],line);
		    return;
		}
		attrs.push('value',props.prefix + line + props.suffix);
		help+=HU.div(attrs,line);
	    });
	    help = HU.div([ATTR_CLASS,'imdv-side-help',ATTR_STYLE,props.style??''], help);
	    return help;
	},
	getFeaturePropertyApply:function() {
	    return (mapGlyph, props)=>{
		this.featureChanged();	    
		let style = {};
		if(mapGlyph.isData()) {
		    let displayAttrs = this.parseDisplayAttrs(this.jq('displayattrs').val());
		}
		if(props) {
		    props.forEach(prop=>{
			//Remove the extra _cleared props added from a past bug
			if(prop.endsWith('_cleared')) return;
			let id = 'glyphedit_' + prop;
			if(prop.toLowerCase().indexOf('externalgraphic')>=0 || prop=='childIcon')  {
			    if(Utils.isTrue(this.jq(prop).attr('clearpressed'))) {
				style[prop+'_cleared'] = true;
			    } else {
				style[prop+'_cleared'] = false;
			    }
			    id =prop;
			}
			if(prop=='labelSelect') return;
			let v = this.jq(id).val();
			if(prop=='label') {
			    v = v.replace(/\\n/g,'\n');
			}
			if(prop=='showLabels') {
			    v = this.jq(id).is(':checked');
			}
			style[prop] = v;
		    });
		}
		if(style.externalGraphic && !style.externalGraphic.startsWith('data:')) {
		    mapGlyph.attrs.icon=style.externalGraphic;
		}
		if(Utils.stringDefined(style.popupText)) {
		    style.cursor = 'pointer';
		} else {
		    style.cursor = 'pointer';
		}



		if(mapGlyph.isData()) {
		    let displayAttrs = this.parseDisplayAttrs(this.jq('displayattrs').val());
		    mapGlyph.applyDisplayAttrs(displayAttrs);
		} else if(mapGlyph.isMultiEntry()) {
		    mapGlyph.addEntries();
		}

		mapGlyph.applyPropertiesComponent(style);
		mapGlyph.applyPropertiesDialog(style);


//		mapGlyph.applyStyle(style);
		mapGlyph.makeLegend();
		mapGlyph.initLegend();
		this.showMapLegend();
		mapGlyph.redraw();
	    };
	},
	doEdit: function(mapGlyph) {
	    if(!mapGlyph) {
		if(this.getSelected().length==0) return;
		mapGlyph = this.getSelected()[0];
	    }
	    if(!mapGlyph) return;
	    let style = mapGlyph.style;
	    let html =HU.div([STYLE,HU.css('margin','8px')], 'Feature: ' + mapGlyph.type); 
	    this.redraw(mapGlyph);
	    if(mapGlyph.image && Utils.isDefined(mapGlyph.image.opacity)) {
		mapGlyph.style.imageOpacity=mapGlyph.image.opacity;
	    }
	    this.editFeatureProperties(mapGlyph);
	},
	
	makeMenu: function(html) {
	    return  HU.div([ATTR_CLASS,'wiki-editor-popup'], html);
	},
	menuItem: function(id,label,cmd) {
	    if(cmd) {
		//		HU.image(icon_command,[ATTR_WIDTH,'12px']);
		let prefix = '';
		if(cmd!='Esc') prefix = 'Ctrl-';
		label = HU.leftRightTable(label,HU.div([ATTR_STYLE,'margin-left:8px;'], HU.span([ATTR_STYLE,'color:#ccc'], prefix+cmd)));
	    }
	    return  HU.div([ATTR_ID,id,ATTR_CLASS,CLASS_CLICKABLE],label);
	},
	editFeatureProperties:function(mapGlyph,anchor) {
	    this.doProperties(mapGlyph.getStyle(), this.getFeaturePropertyApply(), mapGlyph,anchor);
	},


	makeColorBar:function(domId) {
	    let colors = Utils.split('transparent,#ff0000,#ffa500,#ffff00,#fffeec,#008000,#0000ff,#4b0082,#ee82ee,#ffffff,#000000,#cd5c5c,#f08080,#fa8072,#e9967a,#ffa07a,#dc143c,#ff0000,#b22222,#8b0000,#ffc0cb,#ffb6c1,#ff69b4,#ff1493,#c71585,#db7093,#ff7f50,#ff6347,#ff4500,#ff8c00,#ffa500,#ffd700,#ffff00,#ffffe0,#fffacd,#fafad2,#ffefd5,#ffe4b5,#ffdab9,#eee8aa,#f0e68c,#bdb76b,#e6e6fa,#d8bfd8,#dda0dd,#ee82ee,#da70d6,#ff00ff,#ff00ff,#ba55d3,#9370db,#663399,#8a2be2,#9400d3,#9932cc,#8b008b,#800080,#4b0082,#6a5acd,#483d8b,#7b68ee,#adff2f,#7fff00,#7cfc00,#00ff00,#32cd32,#98fb98,#90ee90,#00fa9a,#00ff7f,#3cb371,#2e8b57,#228b22,#006400,#9acd32,#6b8e23,#808000,#556b2f,#66cdaa,#8fbc8f,#20b2aa,#008b8b,#008080,#00ffff,#00ffff,#e0ffff,#afeeee,#7fffd4,#40e0d0,#48d1cc,#00ced1,#5f9ea0,#4682b4,#b0c4de,#b0e0e6,#add8e6,#87ceeb,#87cefa,#00bfff,#1e90ff,#6495ed,#7b68ee,#4169e1,#0000ff,#0000cd,#00008b,#000080,#191970,#fff8dc,#ffebcd,#ffe4c4,#ffdead,#f5deb3,#deb887,#d2b48c,#bc8f8f,#f4a460,#daa520,#b8860b,#cd853f,#d2691e,#8b4513,#a0522d,#a52a2a,#800000,#fffafa,#f0fff0,#f5fffa,#f0ffff,#f0f8ff,#f8f8ff,#f5f5f5,#fff5ee,#f5f5dc,#fdf5e6,#fffaf0,#fffff0,#faebd7,#faf0e6,#fff0f5,#ffe4e1,#dcdcdc,#d3d3d3,#c0c0c0,#a9a9a9,#808080,#696969,#778899,#708090,#2f4f4f',',');

	    let bar = "";
	    let cnt = 0;
	    colors.forEach(color=>{
		bar += HU.div([ATTR_TITLE,color,'color',color,'widget-id',domId,
			       ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'ramadda-color-select','ramadda-dot'),
			       ATTR_STYLE,HU.css('background',color)]) +HU.space(1);
		cnt++;
		if(cnt>=10) {
		    cnt = 0;
		    bar+="<br>";
		}
	    });
	    bar = HU.div([ATTR_STYLE,'max-height:150px;overflow-y:auto;border:1px solid #ccc;'],bar);
	    return bar;
	},
	

	getFillPatternSelect:function(domId,v) {
	    let patterns = ['',...Object.keys(IMDV_PATTERNS).sort()];
	    let opts = patterns.map(p=>{
		if(p=='') return {value:'',label:'None'};
		return {value:p,label:p};
	    });
	    return  HU.select("",[ATTR_ID,domId],opts,v);
	},


	makeStyleForm:function(style,mapGlyph) {
	    let html = "";
	    let props;
	    let values = {};
	    html +=HU.formTable();
	    if(mapGlyph) {
		html+=(mapGlyph.addToStyleDialog(style)??'');
	    }

	    let isGroup = mapGlyph?mapGlyph.isGroup():false;
	    if(style) {
		if(mapGlyph) {
		    style = mapGlyph.getStyleForProperties(style);
		}
		props = [];
		let isImage = style.imageUrl;
		for(a in style) {
		    if(isImage) {
//			if(a!='transform' && a!='rotation' && a!="imageUrl" && a!="imageOpacity" && a!="popupText") continue;
		    }
		    props.push(a);
		    values[a] = style[a];
		}
	    } else {
		props = ['strokeColor','strokeWidth','strokeDashstyle','strokeOpacity',
			 'fillColor','fillOpacity','fillPattern',
			 'pointRadius','externalGraphic','graphicName',
			 'imageOpacity','fontSize','fontWeight','fontStyle','fontFamily','labelAlign','labelXOffset','labelYOffset'];
	    }

	    
	    if(props.includes("entryId") && !props.includes("wikiText")) props.push("wikiText");
	    if(!props.includes("wikiText") && !props.includes("text") && !props.includes("popupText")) {
		props.push("popupText");
	    }
	    if(mapGlyph && mapGlyph.isGroup() &&  !props.includes("popupText")) {
		props.push("popupText");
	    }


	    let notProps = ['mapOptions','labelSelect','cursor','display']
	    let strip=null;
	    let headers = {
		strokeColor: {label:'Stroke',strip:'stroke'},
		fillColor: {label:'Fill',strip:'fill'},
		fontColor: {label:'Font',strip:'font'},
		dotSize: {label:'Line Dots',strip:'dot'},
		labelAlign: {label:'Label',strip:'label'},
		textBackgroundStrokeColor: {label:'Text Background',strip:'textBackground'},		
		transform:{label:'Image Transforms'}
	    };

	    props.forEach(prop=>{
		let shared = true;
		let id = "glyphedit_" + prop;
		let domId = this.domId(id);
		if(notProps.includes(prop)) return;
		let header = headers[prop];
		if(header) {
		    strip=header.strip;
		    html+=HU.tr([],HU.td(['colspan',2],HU.div([ATTR_CLASS,'imdv-form-header'],header.label)));
		}  else if(strip && !prop.startsWith(strip)) {
		    html+=HU.tr([],HU.td(['colspan',2],''));
		    strip = null;
		}
		let label = prop;
		if(strip) label = label.replace(strip,'');
		label =  Utils.makeLabel(label);		
		if(prop.endsWith('_cleared')) return;
		if(prop=="pointRadius") label = "Size";
		let widget;
		let extra ='';
		if(prop=='externalGraphic' || prop.indexOf('ExternalGraphic')>=0 || prop=='childIcon') {
//		    shared = false;
		    label="Marker"
		    if(prop=='childIcon') label = 'Child Entry Icon';
		    let options = "";
		    let graphic = values[prop];
		    if(!Utils.isDefined(graphic))
			graphic = this.getExternalGraphic();
		    domId = this.domId(prop);
		    let div = HU.div([ATTR_CLASS,'imdv-icons',
				ATTR_STYLE,'margin-left:5px;display:inline-block;',
				'icon-property',prop,
				      ATTR_ID,this.domId(prop+"_icons")],'Loading...');
		    widget = HU.hidden("",graphic,[ATTR_ID,domId]) +
			'<table><tr valign=top><td width=1%>' +
			HU.image(graphic,[ATTR_WIDTH,'24px',ATTR_ID,this.domId(prop+'_image')]) +
			'</td><td>' +
			div +
			"</td></tr></table>";
		} else {
		    let v = values[prop];
		    if(!Utils.isDefined(v) && prop!="wikiText") {
			let propFunc = "get" + prop[0].toUpperCase()+prop.substring(1);
			v = this[propFunc]?this[propFunc]():this.getProperty(prop);
		    }
		    let size = "20";
		    let rows = 1;
		    if(prop=="label") {
			size="80";
			if(mapGlyph.attrs.labelTemplate) {
			    v= mapGlyph.attrs.labelTemplate;
			}
			widget =  HU.textarea("",v,[ATTR_ID,domId,"rows",3,"cols", 60]);
			if(mapGlyph.isEntry()) {
			    widget+="<br>" +HU.checkbox(this.domId("useentrylabel"),[],mapGlyph.getUseEntryLabel(),"Use label from entry");
			}
		    } else if(prop=="popupText") {
			return;
			//skip this
		    } else if(prop=="wikiText"|| prop=="text") {
			size="80"
			let icons = this.getUsedMarkers();
			widget =  HU.textarea("",v||"",[ATTR_ID,domId,"rows",5,"cols", 60]);
			if(icons.length>0) {
			    let hdr = HU.b("Add icon: ");
			    icons.forEach(icon=>{
				hdr+=HU.span([ATTR_CLASS,
					      HU.classes(CLASS_CLICKABLE,'ramadda-icons-recent'),
					      'icon',icon,'textarea',domId],
					     HU.getIconImage(icon,[ATTR_WIDTH,'16px']));
				hdr+=' ';
			    });
			    widget = HU.div([],hdr)+widget;
			}
		    } else if(prop=="strokeDashstyle") {
			widget = HU.select("",[ATTR_ID,domId],['solid','dot','dash','dashdot','longdash','longdashdot'],v);
		    } else if(prop=="strokeLinecap") {
			widget = HU.select("",[ATTR_ID,domId],['butt','round','square'],v);
		    } else if(prop=="fontWeight") {
			widget = HU.select("",[ATTR_ID,domId],["normal","bold","lighter","bolder","100","200","300","400","500","600","700","800","900"],v);
 		    } else if(prop=="fontStyle") {
			widget = HU.select("",[ATTR_ID,domId],["normal","italic"],v);			
		    } else if(prop=='textBackgroundShape') {
			widget = HU.select('',[ATTR_ID,domId],['rectangle','circle','ellipse'],v);
		    } else {
			if(prop == "pointRadius") {
			    label="Size";
			} 
			if(prop=="textBackgroundFillOpacity" || prop=="textBackgroundPadding" || prop=="strokeWidth" || prop=="pointRadius" || prop=="fontSize" || prop=="imageOpacity" || prop=='dotSize') size="4";
			else if(prop=="fontFamily") size="60";
			else if(prop.toLowerCase().indexOf('url')>=0) size="60";
			else if(prop=='imagecss') {
			    label = 'Image CSS';
			    size='60';
			    rows=5;
			    extra = '<pre>property=value...</pre>'
			} else if(prop=='imagefilter') {
			    label = 'Image Filter'
			    size='60';
			    extra='<br>e.g.:<pre>contrast(200%) grayscale(80%) brightness(0.4)\ninvert(75%) saturate(30%) sepia(60%)</pre>';
			    extra += HU.href('https://developer.mozilla.org/en-US/docs/Web/CSS/filter','Help',['target','_help']);
			} else if(prop=='clippath') {
			    label='Image Clip Path';
			    size='60';
			    extra = '<br>' + HU.span([ATTR_ID,'clippathdraw', ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Draw polygon'],HU.getIconImage('fas fa-draw-polygon')+' clip the image') +', e.g.,<pre>polygon(x1 y1,x2 y2,x3 y3,x4 y4)\n'+
				'e.g., to clip 5% from left, 18% from top and 10% from right do:\n'+
				'polygon(5% 18%,95% 18%,95% 90%,5% 90%)'+
				'</pre>';
			    extra += HU.href('https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path','Help',['target','_help']);
			} else if(prop=='transform') {
			    label='Image Transform';
			    size='60';
			    extra = '<br>Apply CSS transform. e.g., to shrink the lower part of an image do:<pre>perspective(10px) rotateX(-0.05deg)</pre>';
			    extra += HU.href('https://developer.mozilla.org/en-US/docs/Web/CSS/transform','Help',['target','_help']);
			}
			if(prop.indexOf("Color")>=0) {
			    widget =  HU.input("",v,[ATTR_CLASS,'ramadda-imdv-color',ID,domId,"size",8]);
			    widget+=SPACE1;
			    widget +=  HU.input("",v,[ATTR_STYLE,HU.css('border-radius','var(--default-radius)'),
						      'type','color','baseid',domId,ATTR_CLASS,'ramadda-imdv-color-hidden',ID,domId+'colorinput',"size",8]);

/*
			    widget +=  HU.span([ATTR_TITLE,'Show color chooser',
						ATTR_CLASS,'ramadda-clickable ramadda-imdv-color-select','baseid',domId,
						ID,domId+'_select'],HU.getIconImage('fas fa-palette'));
						*/
			    
/*			    widget =  HU.div([ATTR_ID,domId+'_display',ATTR_CLASS,'ramadda-dot', ATTR_STYLE,HU.css('background',Utils.stringDefined(v)?v:'transparent')]) +
				HU.space(2)+widget;
			    //			    widget  = HU.table(['cellpadding','0','cellspacing','0'],HU.tr([ATTR_VALIGN,'top'],HU.tds([],[widget,bar])));
*/
			} else if(prop=="labelAlign") {
			    html +=HU.formTableClose();
			    html +=HU.formTable();			    
			    //lcr tmb
			    let items = [["lt","Left Top"],["ct","Center Top"],["rt","Right Top"],
					 ["lm","Left Middle"],["cm","Center Middle"],["rm","Right Middle"],
					 ["lb","Left Bottom"],["cb","Center Bottom"],["rb","Right Bottom"]];
			    widget =  HU.select("",[ATTR_ID,domId],items,v);			
			} else if(prop=="showLabels") {
			    widget = HU.checkbox(domId,[],v);
			} else if(prop=='graphicName') {
			    label = 'Graphic';
			    let g = ['','circle', 'square', 'star', 'x', 'cross', 'triangle',
				     'lightning','rectangle','church','_x','arrow','plane','arrow'];
			    let opts = g.map(p=>{
				if(p=='') return {value:'',label:'None'};
				return {value:p,label:p};
			    });
			    widget =  HU.select("",[ATTR_ID,domId],opts,v);			
			} else if(prop=='fillPattern') {
			    widget = this.getFillPatternSelect(domId,v);
			} else if(prop.indexOf('Radius')>=0 ||
				  prop.indexOf("Width")>=0 ||
				  prop.indexOf("Padding")>=0 ||
				  prop.indexOf("Offset")>=0 ||
				  prop=="rotation") {
			    let isRotation = prop=="rotation";
			    let isOffset = prop.indexOf('Offset')>=0;
			    if(!Utils.isDefined(v)) {
				v=isRotation?0:1;
			    } else if(v==="") {
				v=isRotation?0:1;
			    }
			    let min  = isRotation?-360:(isOffset?-50:0);
			    let max = isRotation?360:50;
			    let size = 4;
			    if(prop.indexOf("Offset")>=0) size=8;
			    widget =  HU.input("",v,[ATTR_ID,domId,"size",size])+HU.space(4) +
				
			    HU.div(['slider-min',min,'slider-max',max,'slider-step',1,'slider-value',v,'slider-id',domId,ID,domId+'_slider',ATTR_CLASS,'ramadda-slider',ATTR_STYLE,HU.css("display","inline-block","width","200px")],"");

			} else if(prop.toLowerCase().indexOf("opacity")>=0) {
			    if(!v || v=="") v= 1;
			    widget =  HU.input("",v,[ATTR_ID,domId,"size",4])+HU.space(4) +
				HU.div(['slider-min',0,'slider-max',1,'slider-value',v,'slider-id',domId,ID,domId+'_slider',ATTR_CLASS,'ramadda-slider',ATTR_STYLE,HU.css("display","inline-block","width","200px")],"");
			} else  if (rows>1) {
			    widget =
				HU.textarea("",v,[ATTR_ID,this.domId(id),"rows",rows,"cols",size]);

			} else {
			    widget =  HU.input("",v,[ATTR_ID,this.domId(id),"size",size]);
			}
		    }
		}
		let suffix='';
		if(isGroup && shared) {
		    suffix=HU.span([ATTR_TITLE,'Apply this style to children glyphs',
				    ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'imdv-style-suffix'),
				    'widget-id',domId,'property',prop],HU.getIconImage('fas fa-folder-tree'));
		}
		if(label=='') label='Label';

		html+=HU.formEntry(label+":",widget+suffix+extra);
		html+='\n';
	    });
	    html+="</table>";
	    html = HU.div([ATTR_CLASS,'imdv-form',ATTR_STYLE,HU.css("max-height","350px","overflow-y","scroll","margin-bottom","5px")], html);
	    return {props:props,html:html};
	},
	
	setLevelRangeTick:function() {
	    let current = this.getCurrentLevel();
	    let perc = 100*(current-this.minLevel)/(this.maxLevel-this.minLevel);
	    this.jq('level_range_tick').css('left',perc+'%');
	    this.jq('level_range_tick').attr(ATTR_TITLE,'Current level:' + current);
	},
	getLevelRangeWidget:function(level,showMarkerToo) {
	    if(!level) level={};
	    let visibleCbx =
		HU.checkbox(this.domId('showmarkerwhennotvisible'),[ATTR_ID,this.domId('showmarkerwhennotvisible')],
			    showMarkerToo,'Show marker instead');
	    let min = level.min??this.minLevel;
	    let max = level.max??this.maxLevel;	    
	    let current = this.getCurrentLevel();
	    let perc = 100*(current-this.minLevel)/(this.maxLevel-this.minLevel);
	    let width = '400px';
	    let widget =   HU.b("Visible between levels:") + HU.space(3) +visibleCbx +'<br>';
	    widget+=HU.hidden('',level.min??this.minLevel,
			      [ATTR_ID,this.domId(ID_LEVEL_RANGE_MIN)]) +
		HU.hidden('',level.max??this.maxLevel,[ATTR_ID,this.domId(ID_LEVEL_RANGE_MAX)])
	    widget+=HU.hidden('','',[ATTR_ID,this.domId(ID_LEVEL_RANGE_CHANGED)]);
	    let slider =
		HU.div([ATTR_ID,this.domId(ID_LEVEL_RANGE_SLIDER),ATTR_STYLE,HU.css('margin-bottom','110px','margin-top','10px','position','relative',ATTR_WIDTH,width)]);

	    let clear = HU.span([ATTR_TITLE,'Clear range values',
				 ATTR_STYLE,HU.css('margin-left','10px'),
				 ATTR_CLASS,'ramadda-clickable',
				 ATTR_ID,this.domId(ID_LEVEL_RANGE_CLEAR)],
				HU.getIconImage('fas fa-delete-left'));
	    slider= HU.hbox([slider,clear]);

	    let tick = HU.image(icon_downdart,
				[ATTR_ID,
				 this.domId('level_range_tick'),
				 ATTR_STYLE,HU.css('position','absolute','top','0px')]);
	    let sample1 = HU.image(RamaddaUtil.getCdnUrl('/map/zoom/zoom' + min+'.png'),
				   [ATTR_ID,this.domId(ID_LEVEL_RANGE_SAMPLE_MIN),
				    ATTR_STYLE,'position:absolute;left:0px;bottom:0px;',
				    ATTR_WIDTH,'120px']);
	    let sample2 = HU.image(RamaddaUtil.getCdnUrl('/map/zoom/zoom' + max+'.png'),
				   [ATTR_ID,this.domId(ID_LEVEL_RANGE_SAMPLE_MAX),
				    ATTR_STYLE,'position:absolute;right:0px;bottom:0px;',
				   ATTR_WIDTH,'120px']);	    
	    let container = HU.div([ATTR_STYLE,HU.css('display','inline-block','position','relative')],
				   slider +tick+sample1+sample2);


	    return widget+container;
	},
	doProperties: function(style, apply,mapGlyph,_anchor) {
	    let _this = this;
	    style = style ?? mapGlyph?mapGlyph.getStyle():style;
	    let props;
	    let buttons = "";
	    buttons+="<center>";
	    buttons +=HU.div([ATTR_CLASS,"display-button","command",ID_APPLY], "Apply");
	    buttons += SPACE2;
	    buttons +=HU.div([ATTR_CLASS,"display-button","command",ID_OK], "Ok");
	    buttons += SPACE2;
	    if(mapGlyph) {
		buttons +=HU.div([ATTR_CLASS,"display-button","command",ID_DELETE], "Delete");
		buttons += SPACE2;
	    }
	    buttons +=HU.div([ATTR_CLASS,"display-button","command",ID_CANCEL], "Cancel");	   
	    buttons+="</center>";
	    let content =[];
	    if(mapGlyph) {
		mapGlyph.addToPropertiesDialog(content,style);
	    }
	    let blocks;
	    if(mapGlyph&&mapGlyph.isData()) {
		let menuAttrs  = mapGlyph?.displayInfo?.display?mapGlyph.displayInfo.display.getWikiEditorTags():null;
		let menuBar = "";
		if(menuAttrs) {
		    blocks = getWikiEditorMenuBlocks(menuAttrs,true);
		    let ctItems =  Utils.getColorTablePopup(null, true);
		    blocks.push({title:"Color table",items:ctItems});
		    //		    menuBar =getWikiEditorMenuBar(blocks,this.domId("displayattrsmenubar"));
		    let cnt = 0
		    let items = [];
		    let seen = {};
		    blocks.forEach((block,idx)=>{
			if(typeof block=="string") {
			    return;
			}
			if(block.items.length==0) return
			if(seen[block.title]) return;
			seen[block.title] = true;
			items.push(HU.div([ATTR_CLASS,CLASS_CLICKABLE,'blockidx',idx], block.title));
		    });
		    menuBar = HU.div([],HU.b("Add:"))+HU.div([ATTR_ID,this.domId('displayattrsmenubar'),ATTR_STYLE,HU.css('margin-left','5px','max-height','200px','overflow-y','auto')], Utils.join(items,""));
		}
		let displayAttrs = mapGlyph.getDisplayAttrs();
		let attrs = "";
		Object.keys(displayAttrs).sort().forEach(key=>{
		    if(Utils.isDefined(displayAttrs[key])) {
			attrs+=key+"="+ displayAttrs[key]+"\n";
		    }
		});
		let textarea = HU.textarea("",attrs,[ATTR_ID,this.domId('displayattrs'),"rows",15,"cols", 60]);
		content.push({header:"Display Properties", contents: HU.hbox([textarea, menuBar])});
	    }// else {
		let r =  this.makeStyleForm(style,mapGlyph);
		let div =
		    HU.leftRightTable('',
				      HU.span([ATTR_TITLE,'Apply style actively'],
					      HU.checkbox(this.domId('styledialogactive'),[ATTR_ID,
											   this.domId('styledialogactive')], false,
							  'Active'))) +r.html;
		content.push({header:"Style",contents:HU.div([ATTR_ID,this.domId('styledialog')],div)});
		props = r.props;
//	    }
	    if(mapGlyph) {
		mapGlyph.getPropertiesComponent(content);
	    }
	    let html = buttons;
	    let accord;
	    if(mapGlyph) {
		accord= HU.makeTabs(content,{contentsStyle:'min-height:400px;min-width:750px;'});
		html+=accord.contents;
	    } else {
		html+=HU.center(HU.b('Default Style')) + content[0].contents;
	    }
	    html+=buttons;
	    html  = HU.div([ATTR_STYLE,HU.css('min-width','700px','min-height','400px'),ATTR_CLASS,"wiki-editor-popup"], html);
	    this.map.ignoreKeyEvents = true;
	    let anchor = this.jq(ID_MENU_FILE);
	    if(anchor.length==0) {
		anchor = _anchor;
	    }
	    let dialog = HU.makeDialog({content:html,anchor:anchor,title:"Map Properties" + (mapGlyph?": "+mapGlyph.getName():""),header:true,draggable:true,resizable:true});
	    if(accord) 
		accord.init();
	    if(mapGlyph)
		mapGlyph.initSideHelp(dialog);
	    this.initSideHelp(dialog);


	    if(apply==null) {
		apply = () =>{
		    let style = {};
		    props.forEach(prop=>{
			let value = this.jq('glyphedit_'+prop).val();
			if(!Utils.stringDefined(value)) {
			    this.setProperty(prop, null);
			    return;
			}
			this.setProperty(prop, value);
			if(prop == 'externalGraphic' || prop=='childIcon') {
			    value = this.jq(prop+'_image').val();
			    if(value && Ramadda.isRamaddaUrl(value))
				value = Ramadda.getUrl(value);
			}
			style[prop] = value;
		    });
		    this.glyphTypes.forEach(g=>{
			g.applyStyle(style,true);
		    });
		}
	    }
	    let close = ()=>{
		this.map.ignoreKeyEvents = false;
		dialog.hide();
		//Do this in another thread because these dialogs are big and the remove call takes a little while
		setTimeout(()=>{dialog.remove();},0);
	    }

	    let applying =false;
	    let myApply = (andClose)=>{
		if(applying) return;
		applying = true;
		apply(mapGlyph,props);
		_this.handleGlyphsChanged();
		if(andClose)  close();
		applying = false;
	    };

	    let ifApply = () =>{
		if(this.jq('styledialogactive').is(':checked')) {
		    myApply();
		}
	    };

	    this.jq('styledialog').find('select').change(function() {
		ifApply();
	    });
	    this.jq('styledialog').find('input').change(function(event) {
		if($(this).attr(ATTR_ID)!=_this.domId('styledialogactive')) {
		    ifApply();
		}
	    });
	    this.jq('styledialog').find('input').keypress(function(event) {
		if(event.keyCode == 13) {
		    ifApply();
		}
	    });

	    dialog.find('.imdv-style-suffix').click(function() {
		let prop = $(this).attr('property');
		let id = $(this).attr('widget-id');
		let value = jqid(id).val();
		if(!value) {
		    value = jqid(id+'_image').val();
		}

		if(prop && value) {
		    mapGlyph.applyStyleToChildren(prop,value);
		}
	    });
	    dialog.find('.ramadda-icons-recent').click(function() {
		let textarea = $(this).attr('textarea');
		let icon = '<img src=' + $(this).attr('icon')+'>';
		HtmlUtils.insertIntoTextarea(textarea,icon);
	    });

	    let setLevelRange = (min,max)=>{		    
		this.jq(ID_LEVEL_RANGE_CHANGED).val('changed');
		this.jq(ID_LEVEL_RANGE_MIN).val(min);
		this.jq(ID_LEVEL_RANGE_MAX).val(max);		    
		this.jq(ID_LEVEL_RANGE_SAMPLE_MIN).attr('src',
							RamaddaUtil.getCdnUrl('/map/zoom/zoom' + min+'.png'));
		
		this.jq(ID_LEVEL_RANGE_SAMPLE_MAX).attr('src',
							RamaddaUtil.getCdnUrl('/map/zoom/zoom' + max+'.png'));
	    }
	    

	    this.jq(ID_LEVEL_RANGE_CLEAR).click(()=>{
		setLevelRange(this.minLevel,this.maxLevel);
		this.jq(ID_LEVEL_RANGE_CHANGED).val('cleared');
		this.jq(ID_LEVEL_RANGE_SLIDER).slider('values',[this.minLevel,this.maxLevel]);
	    });
	    this.jq(ID_LEVEL_RANGE_SLIDER).slider({
		range:true,
		min:this.minLevel,
		max:this.maxLevel,
		values:[
		    parseInt(this.jq(ID_LEVEL_RANGE_MIN).val()??this.minLevel),
		    parseInt(this.jq(ID_LEVEL_RANGE_MAX).val()??this.maxLevel)],		
		slide:(event,ui)=>{
		    let min = ui.values[0];
		    let max = ui.values[1];		    
		    setLevelRange(min,max);
		}

	    });

	    
	    this.jq('displayattrsmenubar').find('.' + CLASS_CLICKABLE).click(function() {
		let block = blocks[$(this).attr('blockidx')];
		let sub = Utils.join(block.items,"");
		sub = HU.div([ATTR_STYLE,'max-height:200px;overflow-y:auto;'], sub);
		let dialog = HU.makeDialog({content:sub,anchor:$(this)});
		let insert = line=>{
		    if(!line) return
		    line = line.trim()+"\n";
		    let v = _this.jq('displayattrs').val().trim();
		    if(v!="") v  +="\n";
		    v =v+line;
		    _this.jq('displayattrs').val(v);
		};
		dialog.find('[colortable]').click(function() {
		    insert("colorTable="+$(this).attr('colortable'));
		    dialog.remove();
		});
		dialog.find('.ramadda-menu-item').click(function() {
		    insert($(this).attr('data-attribute'));
		    dialog.remove();
		});
	    });


	    if(mapGlyph) {
		mapGlyph.initPropertiesComponent(dialog);
		this.initGlyphButtons(dialog);
		dialog.find('#clippathdraw').button().click(function(){
		    let input = _this.jq('glyphedit_clippath');
		    let html = HU.div([ATTR_ID,_this.domId('clippath_container'),ATTR_STYLE,HU.css('position','relative','display','inline-block','background','#ccc;')],
				      HU.image(mapGlyph.style.imageUrl,[ATTR_TITLE,'Click to select point\nshift-click:use previous X\nmeta-click: use previous Y', ATTR_WIDTH,'600px',ATTR_CLASS,'theimage',ATTR_STYLE,HU.css('cursor','pointer','border','1px solid #ccc')]));
		    let buttons = HU.buttons([HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK'),
					      HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel')]);

		    let tryIt = true;
		    html = buttons+
			HU.div([ATTR_CLASS,'ramadda-button-clear display-button'], 'Clear')+HU.space(1)+
			HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_ID,'pathtry',ATTR_STYLE,'width:4em'],
				'Try') +HU.space(1) +
HU.input('','',[ATTR_CLASS,'pathoutput','size','60',ATTR_STYLE,'margin-bottom:0.5em;']) +
			'<br>'+html;
		    html = HU.div([ATTR_STYLE,HU.css('margin','10px','text-align','center')],html);
		    let path='';
		    let dialog = HU.makeDialog({content:html,title:'Edit Clip Path',draggable:true,header:true,anchor:$(this),my:"left top",at:"left bottom"});
		    let output = dialog.find('.pathoutput');
		    let image = dialog.find('.theimage');
		    let canvas;
		    let ctx;
		    image.on('load', function() {
			let container = _this.jq('clippath_container');
			container.append(
			    HU.tag(TAG_CANVAS,[ATTR_ID,_this.domId('clippath_canvas'),
					     ATTR_WIDTH,image.width(),
					     ATTR_HEIGHT,image.height(),					     
					     ATTR_STYLE,HU.css('position','absolute','pointer-events','none','left','0px','top','0px',
							       'background','transparent')]));
			
			canvas = document.getElementById(_this.domId('clippath_canvas'));
			ctx = canvas.getContext("2d");
			ctx.strokeStyle= "blue";
			ctx.lineWidth=1;
		    });


		    let clear = () =>{
			if(!ctx) return;
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		    };

		    let tryButton = dialog.find('#pathtry').button();
		    tryButton.click(function(){
			if(tryIt) {
			    image.css('clip-path',output.val());
			    $(this).html('Reset');
			} else {
			    image.css('clip-path','');
			    $(this).html('Try');
			}
			tryIt = !tryIt;
		    });
		    dialog.find('.ramadda-button-clear').button().click(()=>{
			path='';
			output.val('');
			image.css('clip-path','');
			tryButton.html('Try');
			tryIt=true;
			clear();
		    });
		    dialog.find('.ramadda-button-ok').button().click(()=>{
			let val = output.val();
			dialog.remove();
			input.val(val);
		    });
		    dialog.find('.ramadda-button-cancel').button().click(()=>{
			dialog.remove();
		    });		    

		    let w = image.width();
		    let h = image.height();		    
		    let lastX=0;
		    let lastY=0;		    
		    
		    image.mousedown(function(e){
			let offset = $(this).offset();
			let x=e.pageX - offset.left;
			let y  =e.pageY - offset.top;
			if(e.originalEvent.shiftKey) x = lastX;
			if(e.originalEvent.metaKey) y = lastY;			
			if(ctx && path!='') {
			    ctx.beginPath();
			    ctx.moveTo(lastX,lastY);
			    ctx.lineTo(x,y);			    
			    ctx.stroke();
			}


			lastX = x; lastY = y;
			if(path!='') path+=', ';
			let xp = parseInt(100*(x/w));
			let yp = parseInt(100*(y/h));			
			path+=xp+'% ' + yp +'%'; 
			output.val('polygon(' + path +')');
		    });
		});
	    }



	    let icons =dialog.find('.imdv-icons');
	    if(icons.length>0) {
		this.initIconSelection(icons);
	    }

	    this.setLevelRangeTick();
	    dialog.find('.ramadda-slider').each(function() {
		let min = $(this).attr('slider-min');
		let max = $(this).attr('slider-max');
		let step = $(this).attr('slider-step')??0.01;
		$(this).slider({		
		    min: +min,
		    max: +max,
		    step:+step,
		    value:$(this).attr('slider-value'),
		    slide: function( event, ui ) {
			let id = $(this).attr('slider-id');
			$("#"+ id).val(ui.value);
			ifApply();
		    }});
	    });

	    dialog.find('.ramadda-imdv-color-hidden').on('input',function() {
		let id = $(this).attr('baseid');
		let val = $(this).val();
		$("#"+ id).val(val);
		$("#"+ id+'_display').css('background',val);
		ifApply();
	    });
	    dialog.find('.ramadda-imdv-color-select').click(function() {
		let base = $(this).attr('baseid');
		jqid(base+'colorinput').click();
	    });
	    dialog.find('.ramadda-imdv-color').focus(function() {
		let id = $(this).attr(ATTR_ID);
		let bar = _this.makeColorBar(id);
		let dialog = HU.makeDialog({content:bar,header:false,anchor:$(this),my:"left top",at:"left bottom"});
		dialog.find('.ramadda-color-select').click(function(){
		    let c = $(this).attr('color');
		    let id = $(this).attr('widget-id');
		    jqid(id).val(c);
		    jqid(id+'_display').css('background',c);
		    jqid(id+'colorinput').val(c);
		    dialog.remove();
		    ifApply();
		});

	    });

	    dialog.find('.ramadda-imdv-color').change(function() {
		let c = $(this).val();
		let id = $(this).attr(ATTR_ID);
		$("#"+ id+'_display').css('background',c);
		ifApply();
	    });


	    dialog.find('.display-button').button().click(function() {
		let command = $(this).attr("command");
		switch(command) {
		case ID_OK: 
		    myApply(true);
		    break;
		case ID_APPLY:
		    myApply();
		    break;
		case ID_CANCEL:
		    close();
		    break;
		case ID_DELETE:
		    _this.removeMapGlyphs([mapGlyph]);
		    close();
		    break;
		default:
		    alert('unknown command:' +command);
		}
	    });
	},
	initIconSelection:function(icons, callback) {
	    let _this = this;
	    icons.each(function() {
		_this.addIconSelection($(this),callback);
	    });
	},

	addIconSelection:function(icons, callback) {
	    let _this = this;
	    let used = this.getUsedMarkers();
	    let prop = icons.attr('icon-property');
	    let apply = (icon,clear)=>{
		this.jq(prop+'_image').attr(ATTR_SRC,icon);
		if(clear) {
		    this.jq(prop).attr('clearpressed',true);
		} else {
		    this.jq(prop).attr('clearpressed',false);
		}
		this.jq(prop).val(icon);			
		if(callback) callback(icon);
		if(Utils.stringDefined(icon)) {
		    Utils.copyToClipboard(icon);
		    console.log('icon:' + icon +' copied to clipboard');
		}
	    }

	    if(used.length>0) {
		let html = HU.b("Recent: ");
		used.forEach(icon=>{
		    html+=HU.span([ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'ramadda-icons-recent'),
				   'icon',icon],
				  HU.getIconImage(icon,[ATTR_WIDTH,'24px']));
		});
		this.jq('recenticons').html(html);
		this.jq('recenticons').find('.ramadda-icons-recent').click(function(){
		    apply($(this).attr('icon'));
		});
	    }


	    //Note: the emojis have to come from this RAMADDA instead of the CDN
	    //because if we use the CDN icon in the data icon canvas we get an security error
	    HU.getEmojis(emojis=>{
		let prefix = HU.getUniqueId('icons_');
		let html = "";
		emojis.forEach(cat=>{
		    if(html!="") html+="</div>";
		    html+=HU.open('div',[ATTR_CLASS,'ramadda-imdv-image-category']);
		    html+=HU.div([ATTR_CLASS,'ramadda-imdv-image-category-label'],HU.b(cat.name));
		    cat.images.forEach(image=>{
			html+=HU.image(image.image,[ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'ramadda-imdv-image'),
						    ATTR_WIDTH,'24px',ATTR_STYLE,'margin-right:4px;margin-bottom:2px;','loading','lazy',ATTR_TITLE,image.name]);
		    });
		});
		html+="</div>";
		html = HU.div([ATTR_STYLE,HU.css(ATTR_WIDTH,'400px','max-height','200px','overflow-y','auto')], html);
		html = HU.input("","",[ATTR_ID,prefix+'_search','placeholder','Search','size','30']) +' ' +
		    HU.span([ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'ramadda-imdv-image-delete')],'Clear')+
		    HU.space(2) +
		    HU.span([ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'ramadda-imdv-image-add')],'Set URL')+		    
		    '<br>'+
		    html;
		icons.html(html);
		icons.find('.ramadda-imdv-image-delete').button().click(()=>{
		    apply('',true);
		});
		icons.find('.ramadda-imdv-image-add').button().click(()=>{
		    let url = prompt("Image URL:");
		    if(!url) return;
		    apply(url);
		});		
		let images = icons.find('.ramadda-imdv-image');
		images.click(function() {
		    apply($(this).attr(ATTR_SRC));
		});
		let cats = icons.find('.ramadda-imdv-image-category');
		let search = (value) =>{
		    images.each(function() {
			let textOk = true;		
			if(value) {
			    textOk = false;
			    let html = $(this).attr(ATTR_TITLE).toLowerCase();
			    if(html.indexOf(value)>=0) {
				textOk=true;
			    }
			}
			$(this).attr('imagevisible',textOk);
			if(!textOk) {
			    $(this).fadeOut();
			} else {
			    $(this).show();
			}
		    });
		    cats.each(function() {
			let anyVisible = false;
			$(this).find('.ramadda-imdv-image').each(function() {
			    if($(this).attr('imagevisible')=='true') {
				anyVisible = true;
			    }
			});

			let label = $(this).find('.ramadda-imdv-image-category-label');
			if(!anyVisible) {
			    label.fadeOut();
			} else {
			    label.show();
			}
			
		    });

		};
		jqid(prefix+'_search').keyup(function() {
		    search($(this).val());
		});
	    });
	},	    

	doSaveAs: function() {
	    let name = prompt("New entry name:");
	    if(!name) return;
	    let args = {
		name:name,
		type:"geo_editable_json",
		group:this.getProperty("parentEntryId"),
		authtoken:this.getProperty("authToken"),
		response:"json"
	    }
	    let url = Ramadda.getUrl("/entry/change");
            $.post(url, args, (result) => {
		if(result.entries && result.entries.length) {
		    this.setProperty("entryId",result.entries[0]);
		    this.doSave();
		    this.showMessage("Saved");
		    return
		}
		this.clearFeatureChanged();
		if(result.error) {
		    this.showMessage(result.error);
		} else {
		    this.showMessage(result.message);
		}
	    }).fail(function(jqxhr, textStatus, error) {
		console.log("fail:" + result);
		this.showMessage("failed to save map:" + textStatus +" " + error);
	    });
	},
	doSave: function() {
	    let _this = this;
	    if(this.getProperty("thisEntryType")!="geo_editable_json" && this.getProperty("thisEntryType")!="geo_imdv") {
		this.showMessage("Entry is not the correct type");
		return;
	    }
	    let json = this.makeJson();
//	    console.log(json);
	    let url = Ramadda.getUrl("/entry/setfile"); 
	    let formdata = new FormData();
	    formdata.append("entryid",this.getProperty("entryId"));
	    formdata.append("authtoken",this.getProperty("authToken"));	    
	    formdata.append("file",json);
	    let bounds = this.getFullBounds(true);
	    if(bounds) {
		formdata.append("bounds",bounds.top+"," + bounds.left+","+bounds.bottom+","+bounds.right);
	    }
	    $.ajax({
		url: url,
		cache:false,
		data: formdata,
		processData: false,
		contentType: false,
		type: 'POST',
		enctype: 'multipart/form-data',
		success: function (result) {
		    if(result.error) {
			_this.showMessage(result.error);
		    } else {
			_this.clearFeatureChanged();
			_this.showMessage(result.message);
		    }
		}
	    }).fail(function(jqxhr, textStatus, error) {
		_this.showMessage("failed to save map:" + textStatus +" " + error);
	    });
	},
	loadIMDVUrl:function(url, finish,parentGlyph) {
	    $.ajax({
                url: url,
		cache:false,
                dataType: 'text',
                success: (data) => {
		    if(data=="") data="[]";
		    let json = JSON.parse(data);
		    this.loadIMDVJson(json,this.map,parentGlyph);
		    if(finish) finish();
		}
	    }).fail(err=>{
		if(finish)
		    finish();
		this.handleError(err);
	    });		    
	},
	doImport: function() {
	    let callback = (entryId) =>{
		let url = Ramadda.getUrl("/entry/get?entryid=" + entryId);
		this.showProgress("Importing map...");
		let finish = ()=>{
		    this.display.clearMessage2();
		    this.getMap().clearAllProgress();
		    this.featureChanged(true);
		}
		this.loadIMDVUrl(url,finish);
	    };
	    let props = {title:'Select IMDV entry to import',
			 callback:callback,
			 'eventSourceId':this.domId(ID_MENU_FILE),
			 typeLabel:'IMDV Entries'};
	    this.selector = RamaddaUtils.selectCreate(null, HU.getUniqueId(""),"",false,'entryid',this.getProperty('entryId'),'geo_imdv',null,props);

	},
	

	doDownload: function() {
	    let json = this.makeJson();
	    Utils.makeDownloadFile("imdvmap.json",json);
	},
	makeJson: function() {
	    let _this = this;
	    let list =[];
            this.getGlyphs().forEach(mapGlyph=>{
		let json = mapGlyph.makeJson();
		list.push(json);
	    });
	    let latlon = this.getMap().getBounds();
	    let tbounds =  _this.getMap().transformLLBounds(latlon);
	    let json  = {
		mapProperties:this.mapProperties||{},
		glyphs:list,
		zoomLevel:this.getCurrentLevel(),
		bounds:{
		    north:latlon.top,
		    west:latlon.left,
		    south:latlon.bottom,
		    east:latlon.right,
		}
	    };
            let baseLayer = this.getMap().getMap().baseLayer?.ramaddaId;
	    if(baseLayer) {
		json.baseLayer = baseLayer;
	    }
	    return  JSON.stringify(json);
	},

	makeBox: function(type) {
	    type = type??GLYPH_BOX;
	    let html = '';
	    let style = HU.css('margin','1px');
	    let r = this.dialogRectangle??{
	    };
	    html+=HU.center(HU.input('',r.n,[ATTR_STYLE, style,ATTR_ID,this.domId('_north'),'size','6','placeholder','North']));
	    html+=HU.input('',r.w,[ATTR_STYLE, style,ATTR_ID,this.domId('_west'),'size','6','placeholder','West']);
	    html+=HU.input('',r.e,[ATTR_STYLE, style,ATTR_ID,this.domId('_east'),'size','6','placeholder','East']);
	    html+=HU.center(HU.input('',r.s,[ATTR_STYLE, style,ATTR_ID,this.domId('_south'),'size','6','placeholder','South']));
	    
	    let buttons = HU.buttons([HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK'),
				      HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel')]);
	    html+=buttons;
	    html = HU.div([ATTR_CLASS, 'ramadda-dialog'],html);
	    let dialog = HU.makeDialog({content:html,anchor:this.domId(ID_MENU_NEW),draggable:true,
					title:'Make box',header:true});
	    dialog.find('.ramadda-button-ok').button().click(()=>{
		let r = this.dialogRectangle = {
		    n:this.jq('_north').val(),
		    w:this.jq('_west').val(),		    		    
		    s:this.jq('_south').val(),		    
		    e:this.jq('_east').val(),		    
		};

		this.createBox(r.n,r.w,r.s,r.e,type);
		dialog.remove();
	    });
	    dialog.find('.ramadda-button-cancel').button().click(()=>{
		dialog.remove();
	    });	    
	},

	createBox: function(n,w,s,e,type,style) {
	    let props = {
		geometryType:'OpenLayers.Geometry.Polygon',
		points:[n,w,n,e,s,e,s,w]
	    }
	    let _style = Utils.clone(this.boxStyle);
	    if(style) {
		_style = Utils.clone(_style, style);
	    }
	    let attrs = {
		type:type,
	    }
	    let glyph = new MapGlyph(this,type??GLYPH_BOX,attrs,null,_style,true,props);
	    this.addGlyph(glyph);
	    glyph.panMapTo();
	},
	loadIMDVJson: function(mapJson,map,parentGlyph) {
	    let glyphs = mapJson.glyphs||[];
//	    this.createBox(40,-107,30,-100,{fillColor:'red'});
	    glyphs.forEach((jsonObject,idx)=>{
		let mapGlyph = this.makeGlyphFromJson(jsonObject);
		if(mapGlyph) {
		    if(parentGlyph) parentGlyph.addChildGlyph(mapGlyph);
		    else this.addGlyph(mapGlyph,true);
		}
	    });
	    if(this.getMapProperty('mapLegendPosition')) {
		this.createMapLegendWrapper();
	    }
	    this.editState = null;
	    this.clearFeatureChanged();
	    this.checkMapProperties();
	    this.makeMenuBar();
	    this.makeControls();
	    this.makeLegend();
	    this.showMapLegend();
	    this.checkVisible();
	},

	makeGlyphFromJson:function(jsonObject) {
	    let mapOptions = jsonObject.mapOptions;
	    if(!mapOptions) {
		mapOptions = {
		    type:jsonObject.type
		}
	    }
	    if(Utils.isDefined(mapOptions.showmultidata))  {
		mapOptions.showdataicons = mapOptions.showmultidata;
		delete mapOptions.showmultidata;
	    }

	    mapOptions.id = jsonObject.id;
	    let type = jsonObject.type||mapOptions.type;
	    //for backwards compatabity
	    if(type=='label') {
		mapOptions.type = type =GLYPH_MARKER;

	    }
	    let glyphType = this.getGlyphType(type);
	    if(!glyphType) {
		console.log("no type:" + type,jsonObject);
		return null;
	    }
	    let style = $.extend({},glyphType.getStyle());
	    if(jsonObject.style) $.extend(style,jsonObject.style);
	    style = $.extend({},style);
	    if(Utils.stringDefined(style.externalGraphic)) {
		this.markers[style.externalGraphic] = true;
	    }
	    if(Utils.stringDefined(style.popupText)) {
		style.cursor = 'pointer';
	    } else {
		style.cursor = 'pointer';
	    }
	    if(glyphType.isData()) {
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions,null,style);
		mapGlyph.addData(mapOptions.displayAttrs,false);
		return mapGlyph;
	    }

	    if(glyphType.isMultiEntry()) {
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		mapGlyph.addEntries();
		return mapGlyph;
	    }  
	    if(glyphType.isFixed()) {
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		mapGlyph.addFixed();
		return mapGlyph;
	    }
	    if(glyphType.isZoom()) {
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		return mapGlyph;
	    }	    
	    if(glyphType.isGroup()) {
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		mapGlyph.loadJson(jsonObject);
		return mapGlyph;
	    }
	    if(glyphType.isMap()) { 
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		mapGlyph.checkMapLayer(false);
		return mapGlyph;
	    }
	    if(glyphType.isMapServer()) {
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style);
		mapGlyph.checkMapServer(false);
		return mapGlyph;
	    }  		
	    let points=jsonObject.points;
	    if(!points || points.length==0) {
		console.dir("No points defined for glyph:", glyphType.type);
		console.dir(jsonObject);
		return null;
	    }

	    try {
		let mapGlyph = new MapGlyph(this,mapOptions.type, mapOptions, null,style,true,jsonObject);
		return mapGlyph;
	    } catch(err) {
		this.handleError("Error creating glyph",err);
		console.log(err);
	    }
	    

	    console.log("Couldn't make feature:" + mapOptions.type);
	    return null;
	},


	doMapProperties:function() {
	    if(!this.mapProperties)this.mapProperties={};
	    let accords = [];

	    let buttons = HU.buttons([HU.div([ATTR_CLASS,'ramadda-button-apply display-button'], 'Apply'),
				      HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK'),
				      HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel')]);
	    let cbxs = [
		HU.checkbox(this.domId('showopacityslider'),[],
			    this.getMapProperty('showOpacitySlider',this.getShowOpacitySlider()),'Show Opacity Slider'),
		HU.checkbox(this.domId('showgraticules'),[],
			    this.getMapProperty('showGraticules',false),'Show Graticules'),
		HU.checkbox(this.domId('showoverviewmap'),[],
			    this.getMapProperty('showOverviewMap',false),'Show Overview Map'),		
		HU.checkbox(this.domId('showmouseposition'), [],
			    this.getMapProperty('showMousePosition',false),'Show Mouse Position'),
		HU.checkbox(this.domId('showaddress'), [],
			    this.getMapProperty('showAddress',false),'Show Address Search'),
		HU.checkbox(this.domId('usercanchange'),[ATTR_TITLE,'Non logged in users can add glyphs and change styles but can\'t save'],
			    this.getMapProperty('userCanChange',false),'Anon. users can change'),
		
	    ];
	    let basic = '';
	    basic+=Utils.join(cbxs,'<br>');

	    let right = HU.formTable();
	    right+=HU.formEntry('Legend position:',
				HU.select('',[ATTR_ID,this.domId('legendposition')],[{label:'Left',value:'left'},
										  {label:'Right',value:'right'},
										  {label:'In Map',value:'map'},
										  {label:'None',value:'none'}],
					  this.getMapProperty('legendPosition','left')));
	    right+=HU.formEntry('Legend width:',
				HU.input('',this.getMapProperty('legendWidth',''),[ATTR_ID,this.domId('legendwidth'),'size','4']));
	    
	    right+=HU.formTableClose();
	    right+=HU.checkbox(this.domId('showbasemapselect'), [],
			       this.getMapProperty('showBaseMapSelect'),'Show Base Map Select');


	    
	    basic=HU.table([],HU.tr([ATTR_VALIGN,'top'],HU.td([],basic) + HU.td([ATTR_WIDTH,'50%'], right)));
	    basic+='<p>';
	    basic+=this.getLevelRangeWidget(this.getMapProperty('visibleLevelRange'),
					    this.getMapProperty('showMarkerWhenNotVisible'));

	    accords.push({header:'Basic', contents:basic});
	    accords.push({header:'Header/Footer',
			  contents:
			  HU.b('Top Wiki Text:') +'<br>' +
			  HU.textarea('',this.getMapProperty('topWikiText',''),
				      [ATTR_ID,this.domId('topwikitext_input'),'rows','4','cols','80']) +"<br>" +
			  HU.b('Bottom Wiki Text:') +'<br>' +
			  HU.textarea('',this.getMapProperty('bottomWikiText',''),
				      [ATTR_ID,this.domId('bottomwikitext_input'),'rows','4','cols','80']) +'<br>'
			 });

	    let props = this.getMapProperty('otherProperties','');
	    let lines = ['legendLabel=Some label',
			 'showViewInLegend=true',
			 ...IMDV_PROPERTY_HINTS,
			 'dragPanEnabled=false',
			 'zoomPanEnabled=false',			 
			 'addCurrentLocationMarker=true',
			 'centerOnCurrentLocation=true',
			 'currentLocationUpdateTime=seconds',
			 'showAddress=true',
			 'graticuleStyle=strokeColor:#000,strokeWidth:1,strokeDashstyle:dot'];
	    let help = HU.b('Add property: ') + HU.span([ATTR_ID,this.domId('propsearch')]) +
		this.makeSideHelp(lines,this.domId('otherproperties_input'),{suffix:'\n'});
	    accords.push({header:'Other Properties',
			  contents:
			  HU.hbox([
			      HU.textarea('',props,[ATTR_ID,this.domId('otherproperties_input'),'rows','8','cols','40']),HU.space(2),help])
			 });
	    

	    //	    let accord = HU.makeAccordionHtml(accords);
	    let accord = HU.makeTabs(accords);	    
	    let html = buttons + accord.contents;
	    html  = HU.div([ATTR_STYLE,'min-width:700px;min-height:300px;margin:10px;'],html);
	    let anchor = this.jq(ID_MENU_FILE);
	    let dialog = HU.makeDialog({content:html,title:'Properties',header:true,
					my:'left top',at:'left bottom',draggable:true,anchor:anchor});

	    this.initSideHelp(dialog);
	    accord.init();
	    //	    HU.makeAccordion('#'+accord.id);
	    let close=()=>{
		dialog.hide();
		dialog.remove();
	    }
	    let apply = ()=>{
		this.setMapProperty('userCanChange', this.jq('usercanchange').is(':checked'),
				    'showOpacitySlider', this.jq('showopacityslider').is(':checked'),
				    'showGraticules',this.jq('showgraticules').is(':checked'),
				    'showOverviewMap',this.jq('showoverviewmap').is(':checked'),				    
				    'showMousePosition', this.jq('showmouseposition').is(':checked'),
				    'showAddress', this.jq('showaddress').is(':checked'),
				    'legendPosition',this.jq('legendposition').val(),
				    'legendWidth',this.jq('legendwidth').val(),
				    'showBaseMapSelect',this.jq('showbasemapselect').is(':checked'),
				    'topWikiText', this.jq('topwikitext_input').val(),
				    'bottomWikiText', this.jq('bottomwikitext_input').val(),
				    'otherProperties', this.jq('otherproperties_input').val());		

		this.propertyCache = {}
		this.parsedMapProperties = null;
		let min = this.jq("minlevel").val()?.trim();
		let max = this.jq("maxlevel").val()?.trim();
		if(min=="") min = null;
		if(max=="") max = null;	
		this.setMapProperty('visibleLevelRange', {min:min,max:max},
				    'showMarkerWhenNotVisible', this.jq('showmarkerwhennotvisible').is(':checked'));
		this.checkMapProperties();
		this.makeLegend();
		this.featureChanged(true);

	    };

	    HU.initPageSearch('.imdv-property',
			      this.domId('otherproperties_input'),null,true,
			      {target:'#'+this.domId('propsearch')});


	    dialog.find('.ramadda-button-apply').button().click(()=>{
		apply();
	    });
	    dialog.find('.ramadda-button-ok').button().click(()=>{
		apply();
		close();
	    });
	    dialog.find('.ramadda-button-cancel').button().click(()=>{
		close();
	    });

	},

	checkMapProperties: function() {
	    this.mapProperties=this.mapProperties??{};
	    this.checkOpacitySlider();
	    this.checkTopWiki();
	    if(!this.getMap()) return;
	    this.getMap().applyHighlightStyle(this.getOtherProperties());

	    let gratStyle = this.getMapProperty('graticuleStyle');
	    if(Utils.stringDefined(gratStyle)) {
		try {
		    let tmp = {};
		    gratStyle.split(",").forEach(tok=>{
			let toks =tok.split(":");
			if(toks.length==2) {
			    let prop = toks[0].trim();
			    let v =toks[1].trim();
			    if(prop=='strokeWidth') v = parseInt(v);
			    tmp[prop] = v;
			}
		    });
		    gratStyle=tmp;
		} catch(err) {
		    console.log("Error parsing graticule style:" + gratStyle +"\n\terror:" + err);
		    gratStyle;
		}
	    }
	    this.getMap().setGraticulesVisible(this.getMapProperty('showGraticules'),gratStyle);
	    this.getMap().setShowOverviewMap(this.getMapProperty('showOverviewMap'));
	    if(this.getMapProperty('showMousePosition'))
		this.getMap().initMousePositionReadout();
	    else
		this.getMap().destroyMousePositionReadout();		

	    this.map.setDragPanEnabled(this.getMapProperty('dragPanEnabled',true));
	    this.map.setZoomPanEnabled(this.getMapProperty('zoomPanEnabled',true));	    

	    this.checkCurrentLocation();
	},
	
	xcnt:0,
	geoOptions: {
	    enableHighAccuracy: true, 
	    maximumAge        : 30000, 
	    timeout           : 27000
	},

	checkCurrentLocation:function() {
	    if(this.currentLocationMarker) {
		this.getMap().removeMarker(this.currentLocationMarker);
		this.currentLocationMarker=null;
	    }
	    if(!this.getMapProperty('addCurrentLocationMarker',false)) {
		return;
	    }
            if (!navigator.geolocation) {
		console.log('no navigator.geolocation available');
		return;
	    }


            navigator.geolocation.getCurrentPosition(position=> {
		let lat = position.coords.latitude;
		let lon = position.coords.longitude;
		let lonlat = MapUtils.createLonLat(lon,lat);
		if(this.currentLocationMarker) {
		    this.getMap().removeMarker(this.currentLocationMarker);
		    this.currentLocationMarker=null;
		}

		let popup = '<center><h2>Current Location</h2></center>';

		if(this.isIsolineEnabled()) {
		    popup+=HU.onClick('ImdvUtils.getImdv(\'' + this.getId() +'\').addIsolineForCurrentMarker()',	    HU.getIconImage('fa-regular fa-circle-dot')+' ' +'Add Isoline');
		}
		this.currentLocationMarker =
		    this.getMap().addMarker('location', lonlat, null, '', popup, 20, 20);
		if(this.getMapProperty('centerOnCurrentLocation')) {
		    this.getMap().setCenter(lonlat);
		}
            },error=>{
		console.error(error);
	    },this.geoOptions);

	    //Add a timeout callback
	    if(this.checkCurrentLocationTimeout) clearTimeout(this.checkCurrentLocationTimeout);
	    if(Utils.isDefined(this.getMapProperty('currentLocationUpdateTime'))) {
		this.checkCurrentLocationTimeout = setTimeout(()=>{
		    this.checkCurrentLocation();
		},1000*parseFloat(this.getMapProperty('currentLocationUpdateTime',30)));
	    }		

	},
	checkOpacitySlider:function() {
	    let visible;
	    if(Utils.isDefined(this.getMapProperty('showOpacitySlider')))
		visible = this.getMapProperty('showOpacitySlider');
	    else
		visible = this.getShowOpacitySlider(false);
	    this.getMap().showOpacitySlider(visible);

	},
	showFileMenu: function(button) {
	    let _this = this;
	    let html ="";
	    let div = '<div class=ramadda-menu-divider></div>';
	    if(this.canEdit()) {
		html +=this.menuItem(this.domId(ID_SAVE),"Save",'S');
	    }
	    html+= this.menuItem(this.domId(ID_DOWNLOAD),"Download")
	    html+=div;
	    html+= this.menuItem(this.domId(ID_IMPORT),"Import")
	    html+=div;
	    html+= this.menuItem(this.domId(ID_CMD_LIST),"List Features...");
	    html+= this.menuItem(this.domId(ID_CLEAR),"Clear Commands","Esc");
	    //	    html+= this.menuItem(this.domId(ID_REFRESH),"Refresh");	    
	    html+=div;
	    html+= this.menuItem(this.domId(ID_PROPERTIES),"Set Default Style...");
	    html+= this.menuItem(this.domId(ID_MAP_PROPERTIES),"Properties...");
	    html+=div;
	    html+= HU.href(Ramadda.getUrl('/userguide/imdv/index.html'),'Help',['target','_help']);
	    html  = this.makeMenu(html);
	    //	    console.log('creating file menu');
	    this.dialog = HU.makeDialog({content:html,anchor:button});
	    let clear = () =>{
		this.clearCommands();
		HU.hidePopupObject(null,true);
	    };

	    this.jq(ID_NAVIGATE).click(()=> {
		clear();
		this.setCommand(null);
	    });
	    this.jq(ID_MAP_PROPERTIES).click(()=>{
		clear();
		this.doMapProperties();
	    });
	    this.jq(ID_SAVE).click(()=>{
		clear();
		this.doSave();
	    });
	    this.jq(ID_SAVEAS).click(()=>{
		clear();
		this.doSaveAs();
	    });	    
	    this.jq(ID_DOWNLOAD).click(()=>{
		clear();
		this.doDownload();
	    });	    
	    this.jq(ID_IMPORT).click(()=>{
		clear();
		this.doImport();
	    });
	    this.jq(ID_PROPERTIES).click(()=>{
		clear();
		this.doProperties();
	    });
	    this.jq(ID_REFRESH).click(()=>{
		clear();
		ImdvUtils.scheduleRedraw(this.myLayer);
	    });
	    this.jq(ID_CLEAR).click(()=>{
		clear();
		this.unselectAll();
	    });	    
	    this.jq(ID_CMD_LIST).click(()=>{
		clear();
		this.listFeatures();
	    });	    
	},

	getZoomImage:function(level) {
	    return RamaddaUtil.getCdnUrl('/map/zoom/zoom' + level+'.png')
	},
	makeViewMenu:function(addLabel,suffix,makeHtml) {
	    let html = '';
	    if(!makeHtml) {
		makeHtml = (id,label)=>{
		    return this.menuItem(id,label);
		}
	    }
	    let lbl = (l,i) =>{
		if(!addLabel) 
		    return (HU.getIconImage(i));
		return (i?HU.getIconImage(i):HU.div([ATTR_STYLE,'display:inline-block;width:20px;']))+HU.space(1)+
		    HU.span([],l);
	    }

	    let make = (id,label,icon)=>{
		return HU.span([ATTR_TITLE,label], makeHtml(id,lbl(label,icon)));
	    }
	    suffix = suffix??'';
	    if(this.initialLocation) {
		html+= make(this.domId(ID_MAP_RESETMAPVIEW+suffix),"Initial View","fas fa-house");
	    }

	    html+= make(this.domId(ID_MAP_VIEWLAYERS+suffix),'Set View to All','fas fa-eye');

            if (navigator.geolocation) {
		html+= make(this.domId(ID_MAP_MYLOCATION+suffix),"Your Location","fas fa-street-view");
	    }

	    html+= make(this.domId(ID_MAP_REGIONS+suffix),"Regions","fas fa-map");
	    html+= make(this.domId(ID_MAP_CHOOSE+suffix),"Set Location/Zoom","fas fa-compass");	    
	    return html;
	},
	initViewMenu:function(suffix,anchor) {
	    let _this = this;
	    suffix = suffix??'';
	    let clear = () =>{
		this.clearCommands();
		HU.hidePopupObject(null,true);
	    };

	    this.jq(ID_MAP_CHOOSE+suffix).click(function(){
		clear();
		let html = HU.formTable();
		html+=HU.formEntry('Latitude:',HU.input('','',[ATTR_ID,_this.domId('choose_latitude')]));
		html+=HU.formEntry('Longitude:',HU.input('','',[ATTR_ID,_this.domId('choose_longitude')]));		

		let opts = [2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,18].map(v=>{
		    return {label:v,value:v,
			    image:_this.getZoomImage(v)
			   };
		});
		let zoomPopup  = '';
		opts.forEach(level=>{
		    zoomPopup+=
			HU.div([ATTR_STYLE,HU.css('margin-bottom','2px')],
			       HU.image(level.image,
					['data-level',level.value,
					 ATTR_TITLE,'Level:' + level.value,
					 ATTR_WIDTH,'100px',ATTR_CLASS,'ramadda-clickable']));
		});
		zoomPopup=HU.div([ATTR_STYLE,'text-align:center;max-height:300px;overflow-y:auto;'], zoomPopup);
		html+= HU.hidden('',_this.getCurrentLevel(),
				 [ATTR_ID,_this.domId('choose_zoom_value')]);
		let zoomButton = HU.div([ATTR_ID,_this.domId('choose_zoom_button')],
					HU.image(_this.getZoomImage(_this.getCurrentLevel()),
						 [ATTR_TITLE,'Click to select level',
						  ATTR_ID,_this.domId('choose_zoom_image'),
					  
						  ATTR_WIDTH,'100px',ATTR_CLASS,'ramadda-clickable']));
		html+=HU.formEntry('Zoom Level:',zoomButton);
		html+=HU.formTableClose();
		let buttons =HU.div([ATTR_CLASS,'ramadda-button-apply display-button'], 'Apply') + SPACE2 +
		    HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK') + SPACE2 +
		    HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel');	    
		html+=HU.center(buttons);
		html = HU.div([ATTR_CLASS, 'ramadda-dialog'],html);
		let dialog = HU.makeDialog({content:html,anchor:anchor??$(this),draggable:true,
					    title:'Set Location/Zoom',header:true});
		let zoomDialog;
		_this.jq('choose_zoom_button').click(function(){
		    if(zoomDialog) zoomDialog.remove();
		    zoomDialog =HU.makeDialog({content:zoomPopup,anchor:$(this),header:true,title:'&nbsp;&nbsp;Select Zoom Level'});
		    zoomDialog.find('.ramadda-clickable').click(function() {
			let zoom  = $(this).attr('data-level');
			_this.jq('choose_zoom_value').val(zoom);
			_this.jq('choose_zoom_image').attr('src',$(this).attr('src'));
			zoomDialog.remove();
			zoomDialog=null;
		    });
		});
		dialog.find('.display-button').button().click(function(){
		    if($(this).hasClass('ramadda-button-ok') || $(this).hasClass('ramadda-button-apply')) {
			let lat = _this.jq('choose_latitude').val().trim();
			let lon = _this.jq('choose_longitude').val().trim();			
			if(lat!='' && lon!='') {
			    let lonlat = MapUtils.createLonLat(lon,lat);
			    _this.getMap().setCenter(lonlat);
			}
			_this.getMap().setZoom(parseInt(_this.jq('choose_zoom_value').val()));
		    }
		    if($(this).hasClass('ramadda-button-apply'))  return;
		    if(zoomDialog) zoomDialog.remove();
		    dialog.remove();
		});
	    });
	    this.jq(ID_MAP_VIEWLAYERS+suffix).click(()=>{
		clear();
		this.zoomToLayers();
	    });

	    this.jq(ID_MAP_RESETMAPVIEW+suffix).click(()=>{
		clear();
		if(this.initialLocation?.zoomLevel>=0 && Utils.isDefined(this.initialLocation?.zoomLevel)) {
		    this.getMap().setZoom(this.initialLocation?.zoomLevel);
		}
		if(this.initialLocation?.bounds) {
		    this.map.getMap().setCenter(this.initialLocation?.bounds.getCenterLonLat());
		}
	    });
	    this.jq(ID_MAP_MYLOCATION+suffix).click(()=>{
		clear();
		navigator.geolocation.getCurrentPosition(position=> {
		    let lat = position.coords.latitude;
		    let lon = position.coords.longitude;
		    let lonlat = MapUtils.createLonLat(lon,lat);
		    this.getMap().setCenter(lonlat);
		    this.getMap().setZoom(8);
		},error=>{
		    console.error(error);
		},this.geoOptions);
	    });
	    this.jq(ID_MAP_REGIONS+suffix).click(function(){
		clear();
		_this.initRegionsSelector(anchor??$(this));
	    });
	},


	showViewMenu: function(button) {
	    let html ="";
	    let div = '<div class=ramadda-menu-divider></div>';
	    html+=this.makeViewMenu(true);
	    html  = this.makeMenu(html);
	    this.dialog = HU.makeDialog({content:html,anchor:button});
	    this.initViewMenu(null,this.jq(ID_MENU_VIEW));
	},

	getFullBounds:function(toLatLon) {
	    let bounds=null;
            this.getGlyphs().forEach((mapGlyph,idx)=>{
		bounds =  MapUtils.extendBounds(bounds,mapGlyph.getBounds());
	    });
	    if(bounds && toLatLon) {
		bounds = this.getMap().transformProjBounds(bounds);
	    }
	    return bounds;
	},

	zoomToLayers:function() {
	    let bounds=this.getFullBounds();
	    if(bounds)
		this.getMap().zoomToExtent(bounds);
	},
	handleEditEvent:function() {
	    if(this.getSelected().length==1) {
		this.doEdit(this.getSelected()[0]);
		return;
	    }
	    this.setCommand(ID_EDIT);
	},
	getDecoration:function(style) {
	    let color = style.strokeColor??"black";
	    let line = "solid";
	    if(style.strokeDashstyle) {
		if(['dot','dashdot'].includes(style.strokeDashstyle)) {
		    line = "dotted";
		} else  if(style.strokeDashstyle.indexOf("dash")>=0) {
		    line = "dashed";
		}
	    }
	    let cssStyle = "";
	    if(color) cssStyle= HU.css('border-bottom' , "3px " + line+ " " +color);
	    let dim = 'width:30px;height:6px;';
	    return  HU.div([ATTR_STYLE,'margin-bottom:5px;margin-right:5px;display:inline-block;'+dim + cssStyle]);
	},

	showMapLegend: function() {
	    if(!this.getShowMapLegend(true)) return;
	    let _this = this;
	    let html = "";
	    let map = {};
            this.getGlyphs().forEach((mapGlyph,idx)=>{
		if(mapGlyph.getType()!=GLYPH_ROUTE && mapGlyph.getType()!=GLYPH_FREEHAND) return;
		let feature = mapGlyph.getFeature();
		if(!feature) return;
		let msg = this.getDistances(mapGlyph.getGeometry(),mapGlyph.getType(),true);
		let id = HU.getUniqueId('feature_');
		feature.legendId = id;
		map[id] = mapGlyph;
		let item = this.getDecoration(feature.style) + msg;
		html+=HU.div([ATTR_CLASS,CLASS_CLICKABLE,ATTR_ID,id],item);
	    });
	    if(html!="") {
		html = HU.div([ATTR_STYLE,'padding:5px;border : var(--basic-border);  background-color : var(--color-mellow-yellow);'], html);
	    }
	    this.jq(ID_MESSAGE3).html(html);
	    this.jq(ID_MESSAGE3).find('.' + CLASS_CLICKABLE).click(function() {
		let id = $(this).attr(ATTR_ID);
		_this.selectGlyph(map[id]);
	    });
	},
	featureChanged:function(skipRedoLegend) {
	    this.featureHasBeenChanged = true;
	},
	clearFeatureChanged:function() {
	    this.featureHasBeenChanged = false;
	},
	showNewMenu: function(button) {
	    let _this = this;
	    let html ='<table><tr valign=top><td>';
	    let tmp = Utils.splitList(this.glyphTypes,this.glyphTypes.length/3);
	    this.glyphTypes.forEach(glyphType=>{
		if(glyphType.type=='map' || glyphType.type=='freehand') {
		    html+='<td>&nbsp;</td><td>';
		}
		if(!glyphType.handler) return;
		let icon = glyphType.options.icon||Ramadda.getUrl('/map/marker-blue.png');
		let label = HU.image(icon,[ATTR_WIDTH,'16']) +SPACE1 + glyphType.getName();
		if(glyphType.getTooltip())
		    label = HU.span([ATTR_TITLE,glyphType.getTooltip()],label);
		html+= this.menuItem(this.domId('menunew_' + glyphType.type),label+SPACE2);
	    });
	    html+='</td></tr></table>';
	    html  = this.makeMenu(html);
	    this.dialog = HU.makeDialog({content:html,anchor:button});
	    this.glyphTypes.forEach(g=>{
		this.jq('menunew_' + g.type).click(function(){
		    HtmlUtils.hidePopupObject(null,true);
		    _this.setCommand(g.type);
		});
	    });

	},


	showEditMenu: function(button) {
	    let html = [[ID_CUT,'Cut','X'],[ID_COPY,'Copy','C'],[ID_PASTE,'Paste','V'],null,
			[ID_SELECTOR,'Select'],
			[ID_SELECT_ALL,'Select All','A'],			
			null,
			[ID_MOVER,'Move',UNIT_M],
			[ID_RESHAPE,'Reshape'],
			[ID_RESIZE,'Resize'],
			[ID_ROTATE,'Rotate'],			
			null,
			[ID_TOFRONT,'To Front','F'],
			[ID_TOBACK,'To Back','B'],
			null,
			[ID_EDIT,'Edit Properties','P']].reduce((prev,tuple)=>{
			    prev = prev || '';
			    if(!tuple) return prev+ HU.div([ATTR_CLASS,'ramadda-menu-divider']);						
			    return prev + 	this.menuItem(this.domId(tuple[0]),tuple[1],tuple[2]);
			},'');
	    
	    this.dialog = HU.makeDialog({content:this.makeMenu(html),anchor:button});
	    let clear = () =>{
		HU.hidePopupObject(null,true);
	    };

	    this.jq(ID_CUT).click(()=>{
		clear();
		this.doCut();
	    });
	    this.jq(ID_SELECT_ALL).click(()=>{
		clear();
		this.selectAll();
	    });
	    
	    this.jq(ID_COPY).click(()=>{
		clear();
		this.doCopy();
	    });	    
	    this.jq(ID_PASTE).click(()=>{
		clear();
		this.doPaste();
	    });
	    this.jq(ID_EDIT).click(()=>{
		clear();
		this.handleEditEvent();
	    });	    
	    [ID_SELECTOR,ID_MOVER,ID_RESHAPE,ID_RESIZE,ID_ROTATE].forEach(command=>{
		this.jq(command).click(()=>{
		    clear();
		    this.setCommand(command);
		});
	    });
	},
	checkSelected:function(mapGlyph) {
	    if(mapGlyph.isSelected()) {
		this.unselectGlyph(mapGlyph);
		this.selectGlyph(mapGlyph);
	    }
	},
	unselectGlyph:function(mapGlyph) {
	    if(!mapGlyph) return;
	    mapGlyph.unselect();
	},
	selectGlyph:function(mapGlyph,maxPoints,dontRedraw) {
	    return mapGlyph.select(maxPoints,dontRedraw);
  	},

	toggleSelectGlyph:function(mapGlyph) {
	    if(mapGlyph.isSelected()) {
		this.unselectGlyph(mapGlyph);
	    } else {
		this.selectGlyph(mapGlyph);
	    }
	},
	selectFeatures:function(mapGlyph,features,maxPoints,debug) {
	    let pointCount = 0;
	    if(!features || features.length==0) return pointCount;
	    let vertices = [];
	    features.forEach(feature=>{
		if(!feature.geometry) return;
		let geom  = feature.geometry.getVertices();
		vertices.push(...geom);
	    });
	    let step = 0;
	    if(vertices.length>maxPoints) {
		step = Math.round(vertices.length/maxPoints);
	    }
	    if(debug) console.log(vertices.length,step);
	    vertices.forEach((pt,idx)=>{
		if(step>0) {
		    if(idx>0 && idx!=vertices.length-1) {
			if(idx%step!=0) return
		    }
		}
		//Make a copy since this if there is a shared point it screws up the redraw of the original feature
                pt = MapUtils.createPoint(pt.x,pt.y);
		let dot = MapUtils.createVector(pt,null,this.DOT_STYLE);
		mapGlyph.selectDots.push(dot);
		pointCount++;
	    });
	    return pointCount;
	},

	getSelected: function() {
	    let selected=[];
	    this.getGlyphs().forEach(mapGlyph=>{
		mapGlyph.getSelected(selected);
	    });
	    return selected;
	},
	selectAll:function() {
	    this.getGlyphs().forEach(mapGlyph=>{
		this.selectGlyph(mapGlyph,20,true);
	    });
	},
	unselectAll:function(except) {
	    this.getGlyphs().forEach(mapGlyph=>{
		if(except == mapGlyph) return;
		this.unselectGlyph(mapGlyph);
	    });
	},	
	setClipboard:function(mapGlyphs) {
	    if(mapGlyphs)
		this.clipboard = mapGlyphs.map(mapGlyph=>{return mapGlyph;});
	    else
		this.clipboard=null;
	    this.pasteCount=0;
	},
	removeImages: function(mapGlyphs) {
	    if(!mapGlyphs) return;
	    mapGlyphs.forEach(mapGlyph=>{
		mapGlyph.removeImage();
	    });
	},
	clearBounds:function(geom) {
	    if(geom.clearBounds) geom.clearBounds();
	    if(geom.components) {
		geom.components.forEach(g=>{
		    this.clearBounds(g);
		});
	    }
	},
	changeOrder: function(toFront, mapGlyph) {
	    let selected = mapGlyph?[mapGlyph]:this.getSelected();
	    if(!selected || selected.length==0) {
		return;
	    }
	    selected.forEach(mapGlyph=>{
		if(toFront)
		    Utils.toFront(this.getGlyphs(),mapGlyph);
		else
		    Utils.toBack(this.getGlyphs(),mapGlyph);
		mapGlyph.changeOrder(toFront);
	    });
	    this.featureChanged();
	    this.redraw();
	},

	moveGlyphBefore:function(glyph1,glyph2,list) {
	    Utils.moveBefore(list??this.glyphs,glyph1,glyph2);
	    glyph2.changeOrder(false);
	    this.featureChanged();
	    this.redraw();
	},

	doCut: function() {
	    let selected = this.getSelected();
	    if(selected.length>0) {
		this.removeImages(selected);
		let tmp = selected.map(feature=>{return feature;});
		this.setClipboard(tmp);
		this.removeMapGlyphs(tmp);
	    }
	    this.clearCommands();
	},
	doCopy: function() {
	    if(this.getSelected().length==0) return;
	    this.setClipboard(this.getSelected().map(mapGlyph=>{return mapGlyph;}));
	},
	addGlyphType: function(glyph) {
	    this.glyphTypes.push(glyph);
	    this.glyphTypeMap[glyph.getType()]  = glyph;
	},
	getGlyphType:function(type) {
	    return this.glyphTypeMap[type];
	},
	createMapGlyph: function(attrs,style,andZoom) {				
	    style = style??{};
	    let layer = this.addMapLayer(attrs,style,andZoom);
	    if(!layer) return;
	    layer.style = style;
	    return layer;
	},
	createMapLayer:function(mapGlyph,opts,style,andZoom) {
	    let url;
	    if(opts.resourceUrl) {
		//For now proxy the request through our ramadda
		if(opts.resourceUrl.indexOf('ramadda.org')>=0)
		    url =   Ramadda.getUrl('/proxy?url=' + encodeURIComponent(opts.resourceUrl));
		else
		    url =   opts.resourceUrl;
	    } else {
		url = Ramadda.getUrl("/entry/get?entryid="+opts.entryId);
	    }
	    url = url.replace(/\${root}/,ramaddaBaseUrl);
	    mapGlyph.setDownloadUrl(url);
	    let selectCallback = (feature,layer,event)=>{
		//Don't handle the feature selected if we have a drawing command
		if(Utils.stringDefined(this.command)) return;
		mapGlyph.featureSelected(feature,layer,event);
	    }
	    let unselectCallback = (feature,layer,event)=>{
		mapGlyph.featureUnselected(feature,layer,event);
	    }	    
	    let errorCallback = (url,err)=>{
		this.handleError(err,url);
	    };

	    let loadCallback = (map,layer)=>{
		if(layer.mapGlyph) {
		    layer.mapGlyph.handleMapLoaded(map,layer);
		}
		this.makeLegend()
	    }
	    switch(opts.entryType) {
	    case 'stacimage': 
		//TODO: handle the 3d bbox with 6 values
		let west,south,east,north;
		if(opts.bbox.length==4)
		    [west,south,east,north] = opts.bbox;
		else
		    [west, south, lowest, east, north, highest] = opts.bbox;		    
		console.log("BBOX:" + west,south,east,north);
		let iw = 2048;
		let ih = 1024;
		//sanity check for bad bbox
		if(north<-90) {
		    [south,west,north,east] = opts.bbox;		    
		}
		//		console.log("north:" +north+" west:" +west +" south:" +south +" east:" + east);
		let ilayer =  this.getMap().addImageLayer('', opts.name,"",url,true,
							  north,west,south,east, iw,ih,{},loadCallback);
		ilayer.mapGlyph = mapGlyph;
		mapGlyph.initImageLayer(ilayer);
		mapGlyph.handleMapLoaded(this.getMap(),ilayer);
		if(andZoom)
		    this.getMap().zoomToLayer(ilayer);
		return ilayer;
		
	    case 'latlonimage': 
		let w = 2048;
		let h = 1024;
		return this.getMap().addImageLayer(opts.entryId, opts.name,"",url,true,
						   opts.north, opts.west,opts.south,opts.east, w,h);
	    case 'geo_gpx': 
		return this.getMap().addGpxLayer(opts.name,url,true, selectCallback, unselectCallback,style,loadCallback,andZoom,errorCallback);
		break;
	    case 'geo_shapefile_fips': 
	    case 'geo_shapefile': 
		url = Ramadda.getUrl('/entry/show?entryid=' + opts.entryId+'&output=geojson.geojson&formap=true');
		//fall thru to geojson

	    case 'geo_geojson': 
		return this.getMap().addGeoJsonLayer(opts.name,url,true, selectCallback, unselectCallback,style,loadCallback,andZoom,errorCallback);
		break;		

	    case 'geo_kml': 
		let loadCallback2 = (map,layer)=>{
		    if(layer.features) {
			layer.features.forEach(f=>{
			    ImdvUtils.applyFeatureStyle(f,style);
			});
		    }
		    loadCallback(map,layer);
		};
		url =  Ramadda.getUrl("/entry/show?entryid=" + opts.entryId +"&output=kml.doc&converthref=true");

		let layer =  this.getMap().addKMLLayer(opts.name,url,true, selectCallback, unselectCallback,style,loadCallback2,andZoom,errorCallback);
		return layer;
	    default:
		this.showMessage('Unknown map type:' + opts.entryType,4000);
		return null;
	    }
	},
	loadMap: function(entryId) {
	    let _this = this;
	    //Pass in true=skipParent
	    let url = this.getProperty("fileUrl",null,false,true);
	    if(!url && entryId)
		url = Ramadda.getUrl("/entry/get?entryid=" + entryId);
	    if(!url) return;
	    this.showProgress("Loading map...");
	    let finish = ()=>{
		this.showCommandMessage('');
		this.getMap().clearAllProgress();
	    }
            $.ajax({
                url: url,
                dataType: 'text',
		cache:false,
                success: (data) => {
		    finish();
		    if(data=="") data="[]";
		    try {
			let json = JSON.parse(data);
			let bounds = null;
			let zoomLevel = -1;
			if(json.baseLayer) {
			    let base = _this.map.baseLayers[json.baseLayer];
			    if(base) {
				_this.map.getMap().setBaseLayer(base);
			    }


			}
			if(!_this.getProperty("embedded") && !_this.getProperty("zoomLevel")) {
			    if(json.bounds) {
				zoomLevel = json.zoomLevel;
				bounds =  MapUtils.createBounds(json.bounds.west,
								json.bounds.south,
								json.bounds.east,
								json.bounds.north);

				bounds =  _this.getMap().transformLLBounds(bounds);
				this.initialLocation = {
				    zoomLevel:zoomLevel,
				    bounds:bounds
				}
			    } else {
				_this.getGlyphs().forEach(mapGlyph=>{
				    let feature = mapGlyph.getFeature();
				    if(!feature) return;
				    if(!bounds)
					bounds = MapUtils.createBounds();
				    bounds.extend(feature.geometry.getBounds());
				    if(feature.mapLayer) {
					let dataBounds = feature.mapLayer.getDataExtent();
					if(dataBounds) {
					    bounds.extend(dataBounds);
					}
				    }
				});
			    }				     
			}
			this.mapProperties = json.mapProperties||this.mapProperties||{};
			this.parsedMapProperties= null;

			//Check the map legend
			if(this.mapLegendToggleId) {
			    if(Utils.isDefined(this.getMapProperty('mapLegendOpen'))) {
				if(!this.getMapProperty('mapLegendOpen')) {
				    $("#" + this.mapLegendToggleId).css('display','none');
				}
			    }
			}

			this.getMap().applyHighlightStyle(this.getOtherProperties());

			//If there was a location in the URL then don't set the location here
			if(Utils.stringDefined(HU.getUrlArgument(ARG_ZOOMLEVEL))) {
			    zoomLevel=null;
			}
			if(Utils.stringDefined(HU.getUrlArgument(ARG_MAPCENTER))) {
			    bounds = null;
			}

			if(zoomLevel>=0 && Utils.isDefined(zoomLevel)) {
			    _this.getMap().setZoom(zoomLevel);
			}
			if(bounds) {
			    _this.map.getMap().setCenter(bounds.getCenterLonLat());
			}
			try {
			    this.loadIMDVJson(json,_this.map);
			} catch(err) {
			    this.handleError(err);
			}
			this.clearFeatureChanged();
			this.checkMapProperties();
			this.makeLegend();
			this.showMapLegend();
			this.checkVisible();
		    } catch(err) {
			this.showMessage("Failed to load map:" + err);
			console.log("error:" + err);
			console.log(err.stack);
			console.log("map json:" + data);
		    }

                }
            }).fail(err=>{
		finish();
		this.handleError(err);
	    });
	},
	handleError:function(err,url) {
	    if(err.stack) console.error(err.stack);
	    let message;
	    let responseText = err.responseText??err?.priv?.responseText;
	    if(responseText) {
		let match = responseText.match(/<div\s+class\s*=\s*"ramadda-message-inner">(.*?)<\/div>/);
		if(match) message = match[1];
		if(!message) {
		    if(responseText.startsWith("{")) {
			match = responseText.match(/error:'(.*)'/);
			if(match)   message = match[1];
		    }
		}
	    }
	    if(message ==null && (typeof err) =="object") {
		if(err.error) message= err.error;
		else {
		    if(err.responseText) {
			message= Utils.stripTags(responseText);
		    }
		}
	    }
	    err = message??err;
	    if(url) err="Error loading URL:" + url+"<br>"+err;
	    this.showMessage(err);
	},
	doMakeMapGlyphs:function() {
	    let externalGraphic = this.getExternalGraphic();
	    if(!Ramadda.isRamaddaUrl(externalGraphic)) externalGraphic = Ramadda.getUrl(externalGraphic);
	    let textBackgroundStyle={
		textBackgroundStrokeColor:'',
		textBackgroundStrokeWidth:1,			   			   
		textBackgroundFillColor:'',
		textBackgroundFillOpacity:1.0,
		textBackgroundPadding:2,
		textBackgroundShape:'rectangle',
		textBackgroundRadius:0};


	    let textStyle = {
		fontColor: this.getProperty("labelFontColor","#000"),
		fontSize: this.getFontSize(),
		fontFamily: this.getFontFamily(),
		fontWeight: this.getFontWeight(),
		fontStyle: this.getFontStyle(),
		labelAlign: this.getProperty("labelAlign","cb"),
		labelXOffset: this.getProperty("labelXOffset","0"),
		labelYOffset: this.getProperty("labelYOffset","14"),
		labelOutlineColor:this.getProperty("labelOutlineColor","#fff"),
		labelOutlineWidth: this.getProperty("labelOutlineWidth","0")};

	    let lineStyle = {strokeColor:this.getStrokeColor(),
			     strokeWidth:this.getStrokeWidth(),
			     strokeOpacity:1,
			     strokeDashstyle:'solid',
			     strokeLinecap: 'butt'};
	    
	    let boxStyle = this.boxStyle =  Utils.clone(lineStyle,{
		fillColor:"transparent",
		fillOpacity:1.0,fillPattern:''});

	    let dotStyle = {dotSize:3,
			    dotStrokeColor:'blue',
			    dotStrokeWidth:1,			   
			    dotFillColor:'blue',
			    dotExternalGraphic:''};
	    

	    this.groupGlyphType =
		new GlyphType(this,GLYPH_GROUP,"Group",
			  Utils.clone(
			      {externalGraphic: externalGraphic,
			       label:'',
			       pointRadius:this.getPointRadius(10)},
			      {fillColor:'transparent',
			       fillOpacity:1,
			       pointRadius:6,
			       labelSelect:true},
			      lineStyle,
			      textStyle,
			      textBackgroundStyle,
			      {transform:'', clippath:'', imagefilter:'',imagecss:''}), 
			  MyEntryPoint,
			      {isGroup:true,
			       tooltip:'Add group',			  
			   icon:Ramadda.getUrl("/icons/chart_organisation.png")});
	    this.markerGlyphType =
		new GlyphType(this,GLYPH_MARKER,"Marker",
			  Utils.clone({label : "label",
				       externalGraphic: externalGraphic,
				       pointRadius:this.getPointRadius(10),
				       rotation:0,
				       label:''},
				      textStyle,
				      {fillColor:'transparent',
				       labelSelect:true},textBackgroundStyle), 
			  MyPoint,
			  {icon:Ramadda.getUrl("/map/blue-dot.png")});

	    new GlyphType(this,GLYPH_POINT,"Point",
			  Utils.clone(
			      {graphicName:'circle',
			       pointRadius:6},
			      lineStyle,
			      {
			       fillColor:"blue",
			       fillOpacity:1,
			       rotation:0,
			       label:''},
			      textStyle,textBackgroundStyle),
			  MyPoint,
			  {icon:Ramadda.getUrl("/icons/dots/blue.png")});
	    new GlyphType(this,GLYPH_FIXED,"Fixed Text", {
		text:"",
		right:"50%",
		bottom:'5px',
		left:'',
		top:'',
		borderWidth:1,
		borderColor:"#ccc",
		fillColor:"#fffeec",
		fontColor:"#000",
		fontSize:"12pt"			      
		
	    },
			  MyEntryPoint,
			  {isFixed:true, tooltip:'Add fixed text',
			   icon:Ramadda.getUrl("/icons/sticky-note-text.png")});			    

	    new GlyphType(this,GLYPH_LINE, "Line",
			  Utils.clone(lineStyle, dotStyle),
			  MyPath,
			  {maxVertices:2,
			   newHelp:'Click and drag to create a new line',
			   icon:Ramadda.getUrl("/icons/line.png")});		
	    new GlyphType(this,GLYPH_POLYLINE, "Polyline",
			  Utils.clone(lineStyle,dotStyle),
			  MyPath,
			  {
			      newHelp:'Click and drag to create a new polyline',
			      icon:Ramadda.getUrl("/icons/polyline.png")});
	    new GlyphType(this,GLYPH_POLYGON, "Polygon",
			  Utils.clone(lineStyle,
				      {fillColor:"transparent",
				       fillOpacity:1.0,
				       fillPattern:''}),
			  MyPolygon,
			  {
			      newHelp:'Click and drag to create a new polygon',
			      icon:Ramadda.getUrl("/icons/polygon.png")});

	    new GlyphType(this,GLYPH_FREEHAND,"Freehand",
			  Utils.clone(lineStyle),			  
			  MyPath,
			  {freehand:true,
			   newHelp:'Click and drag to create a freehand line',			   
			   icon:Ramadda.getUrl("/icons/freehand.png")});
	    new GlyphType(this,GLYPH_FREEHAND_CLOSED,"Closed",
			  Utils.clone(lineStyle,
				      {fillColor:"transparent",
				       fillOpacity:1.0,fillPattern:''}),
			  MyPolygon,
			  {freehand:true,
			   newHelp:'Click and drag to create a new closed freehand line',
			   icon:Ramadda.getUrl("/icons/freehandclosed.png")});

	    new GlyphType(this,GLYPH_BOX, "Box",
			  Utils.clone(this.boxStyle),
			  MyRegularPolygon,
			  {snapAngle:90,sides:4,irregular:true,
			   tooltip:'Create box; ctrl-b: to manually enter bounds',
			   newHelp:'Click and drag to create a new box',
			   icon:Ramadda.getUrl("/icons/rectangle.png")});
	    new GlyphType(this,GLYPH_CIRCLE, "Circle",
			  Utils.clone(this.boxStyle),
			  MyRegularPolygon,
			  {snapAngle:45,sides:40,
			   newHelp:'Click and drag to create a new circle',			   
			   icon:Ramadda.getUrl("/icons/ellipse.png")});

	    new GlyphType(this,GLYPH_TRIANGLE, "Triangle",
			  Utils.clone(lineStyle,{
			      fillColor:"transparent",
			      fillOpacity:1.0,fillPattern:''}),
			  MyRegularPolygon,
			  {snapAngle:10,sides:3,
			   newHelp:'Click and drag to create a new triangle',			   
			   icon:Ramadda.getUrl("/icons/triangle_blue.png")});				
	    new GlyphType(this,GLYPH_HEXAGON, "Hexagon",
			  Utils.clone(lineStyle,{
			      fillColor:"transparent",
			      fillOpacity:1.0,fillPattern:''}),
			  MyRegularPolygon,
			  {snapAngle:90,sides:6,
			   newHelp:'Click and drag to create a new hexagon',			   
			   icon:Ramadda.getUrl("/icons/hexagon_blue.png")});		
	    new GlyphType(this,GLYPH_RINGS,"Range Rings",
			  Utils.clone(lineStyle,
				      {fillColor:"transparent",
				      pointRadius:6,
				      rotation:0},
				      textStyle,
				      textBackgroundStyle),
			  MyPoint,
			  {
			      newHelp:'Click to create a new range ring',
			      icon:Ramadda.getUrl("/icons/rangerings.png")});



	    new GlyphType(this,GLYPH_MAP,"Map File",
			  Utils.clone(lineStyle,
				      {fillColor:"transparent",
				       fillOpacity:1.0,
				       fillPattern:'',
				       pointRadius:6,
				       externalGraphic:'',
				       graphicName:''},
				      textStyle,
				      textBackgroundStyle),
			  MyEntryPoint,
			  {isMap:true,
			   tooltip:"Select a gpx, geojson or  shapefile map",
			   icon:Ramadda.getUrl("/icons/mapfile.png")});	


	    new GlyphType(this,GLYPH_MAPSERVER,"Map Server",
			  {
			      opacity:1.0,
			      legendUrl:""
			  },
			  MyEntryPoint,
			  {isMapServer:true,
			   tooltip:"Provide a Web Map Service URL",
			   icon:Ramadda.getUrl("/icons/drive-globe.png")});	

	    new GlyphType(this,GLYPH_ROUTE, "Route",
			  Utils.clone(lineStyle),						   
			  MyRoute,{icon:Ramadda.getUrl("/icons/route.png")});

	    new GlyphType(this,GLYPH_ISOLINE, "Isoline",
			  Utils.clone({},lineStyle,{fillColor:'transparent',fillOpacity:1}),						   
			  null,{icon:Ramadda.getUrl("/icons/route.png")});

	    new GlyphType(this,GLYPH_IMAGE, "Image",
			  Utils.clone({},
				      {imageOpacity:this.getImageOpacity(1)},
				      lineStyle,
				      {rotation:0,
				       transform:'', clippath:'', imagefilter:'',imagecss:''}),
				      ImageHandler,
				      {tooltip:"Select an image entry to display",
				       snapAngle:90,sides:4,irregular:true,isImage:true,
				       icon:Ramadda.getUrl("/icons/imageicon.png")}
				     );
	    new GlyphType(this,GLYPH_ENTRY,"Entry Marker",
			  Utils.clone(
			      {externalGraphic: Ramadda.getUrl("/icons/entry.png"),
			       pointRadius:12,
			       label:"label"},
			      textStyle),
			  MyEntryPoint,
			  {tooltip:"Add an entry as a marker",
			   isEntry:true,
			   icon:Ramadda.getUrl("/icons/entry.png")});
	    new GlyphType(this,GLYPH_MULTIENTRY,"Multi Entry",
			  Utils.clone(	
			      {externalGraphic: externalGraphic},
			      {childIcon:''},
			      {showLabels:true, pointRadius:12},
			      textStyle,textBackgroundStyle),
			  MyEntryPoint,
			  {tooltip:"Display children entries of selected entry",
			   isMultiEntry:true,
			   icon:Ramadda.getUrl("/icons/folder.png")});

	    new GlyphType(this,GLYPH_DATA,"Data",
 			  {externalGraphic: externalGraphic},
			  MyEntryPoint,
			  {isData:true,
			   tooltip:'Select a map data entry to display',
			   icon:Ramadda.getUrl("/icons/chart.png")});
	    new GlyphType(this,GLYPH_OSM_LOCATIONS,"Query OSM",
 			  {externalGraphic: externalGraphic},
			  MyEntryPoint,
			  {isOsm:true,
			   tooltip:'Query Open Stree Map for locations',
			   icon:Ramadda.getUrl("/icons/osm.png")});
	    new GlyphType(this,GLYPH_ZOOM,"Zoom To",
 			  {},
			  MyEntryPoint,
			  {isZoom:true,
			   tooltip:'Add a zoom to location',
			   icon:Ramadda.getUrl("/nps/birding-wildlife-viewing-black-22.svg")});	    	    

	},
	clearMessage2:function(time) {
	    this.jq(ID_MESSAGE2).hide(time);
	},
	showMessage2:function(msg,fadeOut) {
	    if(Utils.stringDefined(msg)) {
		this.jq(ID_MESSAGE2).html(msg);
		this.jq(ID_MESSAGE2).show();
	    }
	    if(fadeOut) {
		setTimeout(()=>{
		    this.clearMessage2(1000);
		},2000);
	    }
	},
	showCommandMessage:function(msg)  {
	    this.showMessage(msg,-1);
	},
	showMessage:function(msg,clearTime)  {
	    if(msg!='')
		msg = HU.div([ATTR_CLASS,'imdv-message-inner'],msg);
	    else if(this.messageIsTimed) return;
	    this.jq(ID_MESSAGE).html(msg);
	    this.jq(ID_MESSAGE).show();
	    if(this.messageErase) clearTimeout(this.messageErase);
	    this.messageErase = null;
	    if(clearTime>0 || !Utils.isDefined(clearTime)) {
		this.messageIsTimed = true;
		this.messageErase = setTimeout(()=>{
		    this.messageIsTimed = false;
		    this.jq(ID_MESSAGE).hide();
		    this.jq(ID_MESSAGE).html('');
		},clearTime??3000);
	    }
	},
	showProgress:function(msg) {
	    this.showMessage(msg);
	},
	//Override base class method
	setErrorMessage: function(msg) {
	    //8 second time
	    this.showMessage(msg,8000);
	},
	getCurrentLevel: function() {
	    return this.getMap().getZoom();
	},
	checkVisible:function() {
	    this.getGlyphs().forEach(mapGlyph=>{
		mapGlyph.checkVisible();
	    });
	},
	initMap: function(map) {
	    SUPER.initMap.call(this)
	},
	initMapParams:function(params) {
	    SUPER.initMapParams.call(this,params);
	},
	
	getOtherProperties: function() {
	    if(!this.parsedMapProperties) {
		this.parsedMapProperties = Utils.parseMap(this.mapProperties.otherProperties,"\n","=")??{};
	    }
	    return this.parsedMapProperties;
	},

	setMapProperty:function() {
//	    console.log("setMapProperty");
	    for(let i=0;i<arguments.length;i+=2) {
//		console.log("\t" +arguments[i]+'='+arguments[i+1]);
		this.mapProperties[arguments[i]]=arguments[i+1];
	    }
	},
	propertyCache:{
	},
	getMapProperty: function(name,dflt,debug) {
	    if(debug)
		console.log("getProperty:" + name);

	    let value=  this.propertyCache[name];
	    if(Utils.isDefined(value)) {
		if(debug)
		    console.log('\tfrom cache:'+ value);
		return value;
	    }
	

	    //The wiki tag property overrides the map properties
	    value = this.propertyCache[name] = this.getProperty(name,null);
	    if(Utils.isDefined(value)) {
		if(debug)
		    console.log('\tfrom display property:'+ value);
		return Utils.getProperty(value);
	    }

	    value = this.getOtherProperties()[name];
	    if(debug) console.log('\tfrom other properties:', value);
	    if(!Utils.isDefined(value)) {
		value = this.mapProperties[name];
		if(debug) console.log('\tfrom map properties:', value);
	    }

	    if(!Utils.isDefined(value)) {
		value = dflt;
		if(debug) console.log('\tusing dflt:', value);
	    }


	    if(Utils.isDefined(value)) {
		value = Utils.getProperty(value);
	    }
		    
	    return value;
	},
	makeLegendDroppable:function(droppedOnGlyph,label,notify) {
	    notify = notify?? (()=>{this.setLastDroppedTime(new Date());});
	    label.droppable( {
		hoverClass: CLASS_LEGEND_ITEM_DROPPABLE,
		accept:'.' + CLASS_LEGEND_ITEM,
		tolerance:'pointer',
		drop: (event,ui)=>{
		    notify();
		    let draggedGlyph = this.findGlyph(ui.draggable.attr(ID_GLYPH_ID));
		    if(!draggedGlyph) {
			console.log('Could not find dragged glyph');
			return;
		    }
		    this.handleDroppedGlyph(draggedGlyph,droppedOnGlyph,label);
		}
	    });
	},
	handleDroppedGlyph:function(draggedGlyph,targetGlyph,target) {
	    let debug = false;
	    if(this.handleDropTimeout) {
		if(debug)	    console.log('clearing pending drop');
		clearTimeout(this.handleDropTimeout);
	    }
	    this.handleDropTimeout = setTimeout(()=>{
		this.handleDropTimeout = null;
		this.removeMapGlyph(draggedGlyph);
		draggedGlyph.setParentGlyph(null);
		if(targetGlyph) {
		    if(debug)	    console.log('handleDrop: target:' + targetGlyph.getName());
		    if(targetGlyph.isGroup()) {
			if(debug)		console.log('landed on group',targetGlyph.getName());
			targetGlyph.addChildGlyph(draggedGlyph);
			draggedGlyph.changeOrder(false);
		    } else {
			if(targetGlyph.getParentGlyph() && targetGlyph.getParentGlyph().isGroup()) {
			    if(debug) console.log('landed on glyph in a group');
			    targetGlyph.getParentGlyph().addChildGlyph(draggedGlyph);
			    this.moveGlyphBefore(targetGlyph, 
						 draggedGlyph,
						 targetGlyph.getParentGlyph().getChildren());
			} else {
			    if(debug) console.log('moving before:' + targetGlyph.getName());
			    this.moveGlyphBefore(targetGlyph, draggedGlyph);
			}
		    }
		} else if(target) {
		    draggedGlyph.setParentGlyph(null);
		    Utils.removeItem(this.getGlyphs(),draggedGlyph);
		    if(target.attr(ATTR_ID)==this.domId(ID_DROP_BEGINNING)) {
			if(debug) console.log('dropped on beginning');
			this.getGlyphs().unshift(draggedGlyph);
		    } else  {
			if(debug) console.log('dropped on end');
			this.getGlyphs().push(draggedGlyph);
		    }
		    draggedGlyph.changeOrder(false);
		    this.featureChanged();
		    this.redraw();
		}
		draggedGlyph.glyphHasBeenDropped();
		this.handleGlyphsChanged();
		this.redraw();
	    },1);
	},

	getShowLegendInMap() {
	    return  this.getMapProperty('legendPosition','left')=='map';
	},
	checkGlyphLayers:function() {
	    let baseIndex = 100;
	    this.getGlyphs().forEach((mapGlyph,idx)=>{
		baseIndex = mapGlyph.setLayerLevel(baseIndex);
	    });
	    this.getMap().checkLayerOrder();
	},
	makeLegend: function() {
	    let _this = this;
	    let legendDiv = this.getMapProperty("legendDivId");
	    let legendPosition = this.getMapProperty('legendPosition','left');
	    let leftLegend = this.jq(ID_LEGEND_LEFT);
	    let mapLegend = this.jq(ID_LEGEND_MAP_WRAPPER);	    
	    let rightLegend = this.jq(ID_LEGEND_RIGHT);
	    this.jq(ID_LEGEND).remove();
	    //Remove the old one
	    this.jq(ID_LEGEND).remove();
	    let showShapes = this.getMapProperty('showShapes',true);
	    let legendWidth=this.getMapProperty("legendWidth",'200px');
	    if(!Utils.stringDefined(legendWidth)) legendWidth='200px';
	    let legendLabel= this.getMapProperty("legendLabel","");
	    let showViewInLegend= this.getMapProperty("showViewInLegend",false);
	    let idToGlyph={};
	    let glyphs = this.getGlyphs();
	    let html = '';
	    if(this.getMapProperty('showBaseMapSelect')) {
		html+=HU.div([ATTR_STYLE,'margin-bottom:4px;',ATTR_CLASS,CLASS_LEGEND_OFFSET], HU.b('Base Map: ') +this.getBaseLayersSelect());
	    }

	    if(this.getMapProperty('showAddress',false)) {
		this.jq(ID_ADDRESS).show();
	    } else {
		this.jq(ID_ADDRESS).hide();
	    }
	    this.checkGlyphLayers();
	    //xxxxxx
	    this.inMapLegend='';
	    if(glyphs.length)
		html+=HU.div([ATTR_ID,this.domId(ID_DROP_BEGINNING),ATTR_STYLE,'width:100%;height:1px;'],'');
	    glyphs.forEach((mapGlyph,idx)=>{
		html+=mapGlyph.makeLegend({idToGlyph:idToGlyph});
	    });
	    if(glyphs.length)
		html+=HU.div([ATTR_ID,this.domId(ID_DROP_END),ATTR_CLASS,CLASS_LEGEND_ITEM,ATTR_STYLE,'width:100%;height:1em;'],'');

	    let top = '';
	    if(Utils.stringDefined(legendLabel)) {
		legendLabel=legendLabel.replace(/\\n/,'<br>');
		top = HU.div([],legendLabel);
	    }
	    if(this.getMapProperty(PROP_SHOW_LAYER_SELECT_IN_LEGEND,false)) {
		top+=HU.div([ATTR_STYLE,'text-align:center;margin-bottom:2px;'],
			    this.getBaseLayersSelect());
	    }
	    if(showViewInLegend) {
		top +=HU.center(this.makeViewMenu(false,'_legend',(id,lbl)=>{return HU.span([ATTR_STYLE,'margin-right:6px;',ATTR_ID,id,ATTR_CLASS,CLASS_CLICKABLE], lbl);}));
	    }
	    html=top+html;

	    let inMap  =(legendPosition=='map');
	    if(Utils.isMobile()) {
		if(legendPosition=='left' || legendPosition=='right') {
		    inMap = true;
		}
	    }
	    if(html!="") {
		let height= this.getProperty('height');
		let legendHeight= this.getProperty('legendHeight',height);		
		let css  = HU.css('max-width',HU.getDimension(legendWidth),ATTR_WIDTH,HU.getDimension(legendWidth));
		if(height && !inMap && !legendDiv) css+=HU.css('height',legendHeight);
		if(!legendDiv) {
		    let attrs = [ATTR_CLASS,'imdv-legend',ATTR_STYLE,css]
		    html  = HU.div(attrs,html);
		}
	    }

	    if(inMap) {
		this.inMapLegend = html;
	    }
	    this.jq(ID_LEGEND_MAP_WRAPPER).html('');
	    if(this.inMapLegend!='' || inMap) {
		let inMapLegend=HU.div([ATTR_ID,this.domId(ID_LEGEND_MAP)],this.inMapLegend);
		let toggleResult = {};
		let toggleListener = (id,vis)=>{
		    this.setMapProperty('mapLegendOpen',vis);
		};

		inMapLegend=HU.toggleBlock('Legend' + HU.space(2),inMapLegend,
					   this.getMapProperty('mapLegendOpen',true),
					   {animated:300,listener:toggleListener},toggleResult);
		if(inMap) {
		    inMapLegend = HU.div([ATTR_ID,this.domId(ID_LEGEND)], inMapLegend);
		}
		this.jq(ID_LEGEND_MAP_WRAPPER).html(inMapLegend);
		this.mapLegendToggleId = toggleResult.id;
	    } 


	    let legendContainer;
	    if(legendDiv) {
		legendContainer = $('#'+legendDiv);
	    } else if(legendPosition=='left') {
		legendContainer=leftLegend;
	    } else   if(legendPosition=='right') {
		legendContainer=rightLegend;
	    } else   if(legendPosition=='map') {
		legendContainer = this.jq(ID_LEGEND_MAP_WRAPPER);
	    } else {
	    }

	    if(legendContainer && !inMap) {
		legendContainer.show();
		legendContainer.html(HU.div([ATTR_ID,this.domId(ID_LEGEND)],''));
		this.jq(ID_LEGEND).html(html);
	    }

	    this.initViewMenu('_legend');

	    this.makeLegendDroppable(null,this.jq(ID_DROP_BEGINNING),null);
	    this.makeLegendDroppable(null,this.jq(ID_DROP_END),null);


	    HU.initToggleBlock(this.jq(ID_LEGEND),(id,visible,element)=>{
		let mapGlyph = idToGlyph[element.attr('map-glyph-id')];
		if(mapGlyph) mapGlyph.setLegendVisible(visible);
	    });


	    this.getContainer().find('.imdv-legend-item-edit').click(function(event) {
		event.stopPropagation();
		let id = $(this).attr(ID_GLYPH_ID);
		let mapGlyph = _this.findGlyph(id);
		if(!mapGlyph) return;
		_this.editFeatureProperties(mapGlyph);
	    });

	    this.getContainer().find('.' + CLASS_LEGEND_ITEM_VIEW).click(function(event) {
		event.stopPropagation();
		let id = $(this).attr(ID_GLYPH_ID);
		let mapGlyph = _this.findGlyph(id);
		if(!mapGlyph) return;
		mapGlyph.panMapTo(event.shiftKey);
	    });

	    this.initBaseLayersSelect();
	    this.getGlyphs().forEach((mapGlyph,idx)=>{
		mapGlyph.initLegend();
	    });
	    this.initGlyphButtons(this.getContainer());
	    let items = this.getContainer().find('.' + CLASS_LEGEND_LABEL);
	    items.tooltip({
		content: function () {
		    let title =  $(this).prop(ATTR_TITLE);
		    title=HU.div([ATTR_STYLE,'font-size:10pt;'],title);
		    return title;
		},
		show: {
		    delay: 1000,
		}
	    }	    );
	    items.click(function(event) {
		//If we have recently been dragging and dropping the glyphs then don't
		//handle the click
		if(_this.lastDroppedTime) {
		    let now = new Date();
		    if(now.getTime()-_this.lastDroppedTime.getTime()<2000) {
			return
		    }
		}
		let id = $(this).attr(ID_GLYPH_ID);
		let mapGlyph = _this.findGlyph(id);
		if(!mapGlyph) return;
		if(event.shiftKey) {
		    _this.toggleSelectGlyph(mapGlyph);
		    return
		}
		if(event.altKey || event.metaKey) {
		    mapGlyph.panMapTo();
		    return;
		}
		mapGlyph.setVisible(!mapGlyph.getVisible(),true);
	    });
	},

	addToMapLegend:function(glyph,contents) {
	    this.inMapLegend +=contents;
	},
	checkTopWiki:function() {
	    let  wiki=(dom,text) =>{
		if(!Utils.stringDefined(text)) {
		    this.jq(dom).html('');
		} else {
		    this.wikify(text,null,wiki=>{
			this.jq(dom).html(wiki);
		    });
		    
		}
	    };

	    wiki("topwikitext",this.getMapProperty('topWikiText'));
	    wiki("bottomwikitext",this.getMapProperty('bottomWikiText'));	    


	},
	editState:null,
	canChange: function() {
	    //Check if the user can edit the IMDV entry 
	    if(this.canEdit()) return true;
	    if(!this.editState) {
		let canchange = this.getUserCanChange(null);
		if(!Utils.isDefined(canchange)) {
		    canchange = this.getMapProperty('userCanChange');
		}
		this.editState = {
		    canchange:canchange
		}
	    }
	    return this.editState.canchange;
	},

        initDisplay: function(embedded) {
	    let _this = this;
	    SUPER.initDisplay.call(this)
	    this.myLayer = this.map.createFeatureLayer('IMDV Features',true,null,{rendererOptions: {zIndexing: true}});

	    this.selectionLayer = this.map.createFeatureLayer('Selection',false,null,{rendererOptions: {zIndexing: true}});	    
	    //	    this.selectionLayer = this.myLayer;
	    this.selectionLayer.canSelect=false;
	    this.selectionLayer.setZIndex(1001)
	    this.myLayer.setZIndex(1000)	    
//	    this.selectionLayer.canSelect = false;
	    //Always on top
	    this.myLayer.ramaddaLayerIndex = 1001;
	    this.icon = '/icons/map/marker-blue.png';
	    this.glyphTypes=[];
	    this.glyphTypeMap = {};
	    this.doMakeMapGlyphs();
	    if(embedded) {
		return;
	    }

	    setTimeout(()=>{
		this.getMap().getMap().events.register('zoomend', '', () =>{
		    Utils.bufferedCall(this.getId()+'_checkvisible', ()=>{this.checkVisible();});
		    this.setLevelRangeTick();
		    $('.imdv-currentlevellabel').html('(current level: ' + this.getCurrentLevel()+')');
		},true);
		this.getMap().getMap().events.register('moveend', '', () =>{
		    Utils.bufferedCall(this.getId()+'_checkvisible', ()=>{this.checkVisible();});
		},true);
	    },500);

	    this.getMap().featureClickHandler = e=>{
		let debug = false;
		let feature = e.feature;
		if(debug)
		    console.log('featureClick:' + feature);
		if(!feature) return;
		let mapGlyph = feature.mapGlyph || (feature.layer?feature.layer.mapGlyph:null);
		if(!mapGlyph) {
 		    if(debug)console.log('\tno mapGlyph');
		    return true;
		}
		return this.handleMapGlyphClick(mapGlyph,e.event? e.event.xy:null,e);
	    };

	    /*
	      Don't do this for now since if we have set the Show legend property=false that isn't set yet
	      legend = HU.toggleBlock('',legend,true,{orientation:'horizontal',
	      imgopen:'fa-solid fa-angles-down',
	      imgclosed:'fa-solid fa-angles-right',						    
	      });
	    */

	    this.createMapLegendWrapper();

	    let legendLeft = HU.div([ATTR_ID,this.domId(ID_LEGEND_LEFT),ATTR_STYLE,'display:none']);
	    this.jq(ID_LEFT).html(legendLeft);
	    let legendRight = HU.div([ATTR_ID,this.domId(ID_LEGEND_RIGHT),ATTR_STYLE,'display:none']);
	    this.jq(ID_RIGHT).html(legendRight);	    

	    this.jq(ID_HEADER0).append(HU.div([ATTR_ID,this.domId('topwikitext')]));
	    this.jq(ID_BOTTOM).append(HU.div([ATTR_ID,this.domId('bottomwikitext')]));	    
	    let message2 = HU.div([ATTR_ID,this.domId(ID_MESSAGE2),ATTR_CLASS,'ramadda-imdv-message2'],'');
	    this.jq(ID_MAP_CONTAINER).append(message2);
	    let message3 = HU.div([ATTR_ID,this.domId(ID_MESSAGE3),ATTR_CLASS,'ramadda-imdv-message3'],'');
	    if(this.getShowMapLegend()) {
		this.jq(ID_MAP_CONTAINER).append(message3);
	    }

	    let labels = HU.div([ATTR_ID,this.domId(ID_GLYPH_LABELS),ATTR_CLASS,'imdv-inmap-labels'],'');
	    this.jq(ID_MAP_CONTAINER).append(labels);

	    this.makeMenuBar();
	    this.makeControls();

	    $(window).bind('beforeunload', ()=>{
		if(this.canEdit() && this.featureHasBeenChanged) {
		    return 'Changes have been made. Are you sure you want to leave?';
		}
	    });


	    let cmds = '';
	    this.jq(ID_COMMANDS).html(cmds);
	    this.jq(ID_MAP).keydown(function(event){
		if(!event.ctrlKey) return;
		_this.getSelected().forEach(glyph=>{
		    glyph.handleKeyDown(event);
		});
		event.preventDefault();
	    });
	    this.jq(ID_MAP).mouseover(function(){
		$(this).focus();
	    });

	    if(this.getProperty('thisEntryType')=='geo_editable_json' || this.getProperty('thisEntryType')=='geo_imdv') {
		this.loadMap();
	    }
	},

	handleMapGlyphClick:function(mapGlyph,xy,event) {	
	    if(mapGlyph==null) return false;
	    let debug = false;
	    if(mapGlyph.isMap()) {
		if(event && event.event && event.feature && event.event.altKey) {
//		    return false;
		}
 		if(debug)console.log('\tis map');
		return true;
	    }
	    if(this.command==ID_EDIT) {
 		if(debug)console.log('\tdoing edit');
		this.doEdit(mapGlyph);
		return false;
	    }

	    if(this.command!=null) {
 		if(debug)console.log('\tdoing command:' + this.command);
		return false;
	    }
	    let showPopup = (html,props)=>{
		this.getMap().lastClickTime  = new Date().getTime();
		let id = HU.getUniqueId('div');
		let div = HU.div([ATTR_ID,id]);
//		let location = e.feature.geometry.getBounds().getCenterLonLat();
		let location = mapGlyph.getCentroid();
		if(this.getMap().currentPopup) {
		    this.getMap().onPopupClose();
		}
		if(location!=null) 
		    location = MapUtils.createLonLat(location.x, location.y);
		else
		    location = this.getMap().getMap().getLonLatFromViewPortPx({x:50,y:10});
		if(xy)    location = this.getMap().getMap().getLonLatFromViewPortPx(xy);
		let popup =this.getMap().makePopup(location,div,props);
		this.getMap().currentPopup = popup;
		this.getMap().getMap().addPopup(popup);
		if(this.isIsolineEnabled()) {
		    let latlon =   this.getMap().transformProjPoint(location);
		    html+='<p>'+
			HU.onClick('ImdvUtils.getImdv(\'' + this.getId() +'\').addIsolineAt('+ latlon.lat+',' + latlon.lon+')',
				   HU.getIconImage('fa-regular fa-circle-dot')+' ' +'Add Isoline');
		}
		jqid(id).html(html);
		//For some reason the links don't work in the popup
		//so we do this and handle the clicks here
		jqid(id).find('a').each(function() {
		    $(this).click(function(){
			let url = $(this).attr('href');
			if(url) {
			    window.open(url,'_blank');
			}
		    });
		});

	    }


	    let doPopup = (html,props)=>{
 		if(debug)console.log('\tdoPopup:'+ html)
		let js =[];
		//Parse out any script tags 
		let regexp = /<script *src=("|')?([^ "']+)("|')?.*?<\/script>/g;
		let array = [...html.matchAll(regexp)];
		array.forEach(tuple=>{
		    html = html.replace(tuple[0],'');
		    let url = tuple[2];
		    url = url.replace(/'/g,'');
		    js.push(url);
		});


		//Run through any script tags and load them
		//once done show the popup
		let cb = ()=>{
		    if(js.length==0 && js[0]==null) {
 			if(debug)console.log('\tshowPopup:'+ html)
			showPopup(html,props);

			return;
		    }
		    let url = js[0];
		    js.splice(0,1);
		    Utils.loadScript(url,cb);
		};
		cb();
	    };
	    let text= mapGlyph.getPopupText()??'';
	    if(mapGlyph.isEntry() || mapGlyph.isMultiEntry() || text.startsWith('<wiki>')) {
 		if(debug)console.log('\twikifying')
		let wiki = (text.startsWith('<wiki>')?text:mapGlyph.getWikiText())??'';
		let width = '400';
		let height='300';
		let widthRegexp = /popupWidth *= *(\d+)/;
		let widthMatch = wiki.match(widthRegexp);
		if(widthMatch) {
		    width=widthMatch[1];
		    wiki = wiki.replace(widthRegexp,'');
		}
		let heightRegexp = /popupHeight *= *(\d+)/;		    
		let heightMatch = wiki.match(heightRegexp);
		if(heightMatch) {
		    height=heightMatch[1];
		    wiki = wiki.replace(heightRegexp,'');
		}		    

		if(!Utils.stringDefined(wiki))
		    wiki = '{{mappopup}}';
		let wikiCallback = html=>{
		    html = mapGlyph.convertPopupText(html);
		    html = HU.div([ATTR_STYLE,'max-height:300px;overflow-y:auto;'],html);
		    doPopup(html,{width:this.getProperty('popupWidth',width),
				  height:this.getProperty('popupHeight',height)});
		};
		this.wikify(wiki, mapGlyph.getEntryId(),wikiCallback);
		return false;
	    }

	    if(!Utils.stringDefined(text)) {
 		if(debug)console.log('\tno text')
		return false;
	    }
	    text = mapGlyph.convertPopupText(text).replace(/\n/g,'<br>');
	    doPopup(text);
	    return false;
	},
	getLabels:function() {
	    return this.jq(ID_GLYPH_LABELS);
	},

	appendHeader:function(html) {
	    this.jq(ID_HEADER0).append(html);
	},
	makeMenuBar:function() {
	    if(!this.getMapProperty('showMenuBar',true)) return;
	    let _this = this;
	    let menuBar=  '';
	    [[ID_MENU_FILE,'File'],[ID_MENU_EDIT,'Edit'],[ID_MENU_NEW,'New'],[ID_MENU_VIEW,'View']].forEach(t=>{
		menuBar+=   HU.div([ATTR_ID,this.domId(t[0]),ATTR_CLASS,'ramadda-menubar-button'],t[1])});
	    menuBar = HU.div([ATTR_CLASS,'ramadda-menubar'], menuBar);

	    let address =
		HU.span([ATTR_STYLE,HU.css('position','relative')], 
			HU.div([ATTR_STYLE,'display:inline-block;',ATTR_ID,this.domId(ID_ADDRESS_CLEAR),ATTR_TITLE,'Clear',ATTR_CLASS,CLASS_CLICKABLE],HU.getIconImage('fa-solid fa-eraser',[],[ATTR_STYLE,'color:#ccc;'])) +
			' ' +
			HU.div([ATTR_ID,this.domId(ID_ADDRESS_WAIT),ATTR_STYLE,HU.css('position','absolute','right','0px',
										'display','inline-block','margin-right','2px',ATTR_WIDTH,'20px')])+
			HU.input('','',[ATTR_ID,this.domId(ID_ADDRESS_INPUT),'placeholder','Search for address','size','20']));

	    if(this.canChange()) {
		address = address +' ' +HU.checkbox(this.domId(ID_ADDRESS_ADD),[ATTR_ID,this.domId(ID_ADDRESS_ADD),ATTR_TITLE,'Add marker to map'],false);
	    }
	    address=HU.span([ATTR_STYLE,'margin-right:5px'], address);

	    address = HU.div([ATTR_STYLE,HU.css('white-space','nowrap','display','none','position','relative'),
			      ATTR_ID,this.domId(ID_ADDRESS)], address);	    
	    
	    let message = HU.div([ATTR_ID,this.domId(ID_MESSAGE),ATTR_CLASS,'imdv-message']);
	    let mapHeader = HU.div([ATTR_STYLE,HU.css('margin-left','10px'),
				    ATTR_ID,this.domId(ID_MAP_HEADER)]);
	    if(this.canChange()) {
		menuBar=  HU.table([ATTR_ID,this.domId(ID_MAP_MENUBAR),ATTR_WIDTH,'100%'],HU.tr([ATTR_VALIGN,'bottom'],HU.td([],menuBar) +
											 HU.td([ATTR_WIDTH,'50%'], message) +
											 HU.td(['align','right',ATTR_STYLE,'padding-right:10px;',ATTR_WIDTH,'50%'],mapHeader+address)));
	    } else {
		menuBar= HU.table([ATTR_ID,this.domId(ID_MAP_MENUBAR),ATTR_WIDTH,'100%'],HU.tr([ATTR_VALIGN,'bottom'],HU.td([],'') +
											 HU.td([ATTR_WIDTH,'50%'], message) +
											 HU.td(['align','right',ATTR_STYLE,'padding-right:10px;',ATTR_WIDTH,'50%'],mapHeader+address)));
	    }


	    this.jq(ID_TOP_LEFT).html(menuBar);
            this.jq(ID_ADDRESS_INPUT).keypress(function(event) {
                if (event.which == 13) {
		    let address = $(this).val();
		    if(!Utils.stringDefined(address)) return;
		    _this.gotoAddress($(this),address);
		}
	    });

	    this.jq(ID_ADDRESS_CLEAR).click(()=>{
		this.clearAddresses();
	    });

	    this.jq(ID_MENU_NEW).click(function() {
		_this.showNewMenu($(this));
	    });
	    this.jq(ID_MENU_FILE).click(function() {
		_this.showFileMenu($(this));
	    });
	    this.jq(ID_MENU_VIEW).click(function() {
		_this.showViewMenu($(this));
	    });	    
	    this.jq(ID_MENU_EDIT).click(function() {
		_this.showEditMenu($(this));
	    });
	},

	createMapLegendWrapper:function() {
	    let _this = this;
	    this.jq(ID_LEGEND_MAP_WRAPPER).remove();
	    let legendPosition = this.getMapProperty('mapLegendPosition',{left:'50px',top:'20px'});
	    let legendStyle = '';
	    //	    ['left','top','right','bottom'].forEach(pos=>{
	    ['left','top'].forEach(pos=>{
		if(legendPosition[pos]) {
		    legendStyle+=HU.css(pos,legendPosition[pos]);
		}
	    });
	    if(legendStyle=='') legendStyle='left:50px;top:20px;'

	    //gotta have this here or else the draggable sets it to relative
	    legendStyle+=HU.css('position','absolute');
	    let innerDiv = HU.div([ATTR_ID,this.domId(ID_LEGEND_MAP_WRAPPER),ATTR_CLASS,'imdv-legend-map-wrapper',ATTR_STYLE,legendStyle]);
	    let inner = $(innerDiv);

	    this.jq(ID_MAP_CONTAINER).append(inner);
	    let haveCleared = false;
	    inner.draggable({
		containment:this.jq(ID_MAP_CONTAINER),
		//A bit tricky - we clear all the style when we start dragging
		//so if right or bottom were set then those get nuked
		//because the drag drags left/top
		start:function() {
		    //		    inner.attr(ATTR_STYLE,'position:absolute;');
		},
		stop:function() {
		    let top = inner.position().top;
		    let left = inner.position().left;		    
		    let bottom = top+inner.height();
		    let right = left+inner.width();		    
		    let pw = inner.parent().width();
		    let ph = inner.parent().height();		    
		    let pos = _this.mapProperties.mapLegendPosition = {};
		    pos.left = inner.css('left');		    
		    pos.top = inner.css('top');

		    return
		    /* TODO?
		    let set = (which,v) =>{
			v =  Math.max(0,(parseInt(v)))+'px';
			pos[which] =v;
		    }
		    if(top<ph-bottom) set('top',top);
		    else set('bottom',(ph-bottom));
		    if(left<pw-right) set('left',left);
		    else set('right',pw-right);
		    */
		}
	    });
	},


	makeControls:function() {
	    let _this = this;
//	    if(!this.canChange()) return;
	    if(this.haveMadeControls) return;
	    this.haveMadeControls = true;
	    
	    Utils.initDragAndDrop(this.jq(ID_MAP),
				  event=>{},
				  event=>{},
				  (event,item,result) =>{
				      let entryId = this.getProperty('entryId') || this.entryId;
				      Ramadda.handleDropEvent(event, item, result, entryId,this.getProperty("authToken"),(data,entryid, name,isImage)=>{


					  name = name??data.name;
					  if(MAP_TYPES.includes(data.type)) {
					      let glyphType = this.getGlyphType(GLYPH_MAP);
					      let style = $.extend({},glyphType.getStyle());
					      let attrs = {
						  entryId:data.entryid,
						  type:glyphType.type,
						  name:name,
						  entryType:data.type,
					      }
					      let mapGlyph = this.handleNewFeature(null,style,attrs);
					      mapGlyph.checkMapLayer();
					      return;
					  } else {
					      this.setCommand(GLYPH_IMAGE,{url:data.geturl,
									   entryId:data.entryid,
									   name:name});
					  }
				      });
				  },
				  (file)=>{
				      if(file.type.match('image.*')) return true;
				      let _name = file.name.toLowerCase();
				      if(_name.match('.*\.(json|geojson|gpx|shz|zip|kml|kmz)')) return true;
				      return false;
				  }
				 );

	    this.jq(ID_MAP).css('caret-color','transparent');


	    //		this.jq(ID_LEFT).html(HU.div([ATTR_ID,this.domId(ID_COMMANDS),ATTR_CLASS,'imdv-commands']));
	    let keyboardControl = new OpenLayers.Control();
	    let control = new OpenLayers.Control();
	    let callbacks = {
		keydown: function(event) {
		    if(event.key=='MediaTrackPrevious') return;
		    HtmlUtils.hidePopupObject();
		    if(event.key=='Escape') {
			_this.clearCommands();
			_this.unselectAll();
			return;
		    }
		    if(!event.ctrlKey) return;
		    switch(event.key) {
		    case 'a': 
			_this.selectAll();
			break;
		    case 'p':
			_this.handleEditEvent();
			break;
		    case 'x': 
			_this.doCut();
			break;
		    case 'b':
			_this.makeBox(GLYPH_BOX);
			break;
		    case 'v': 
			if(!_this.clipboard ||  _this.clipboard.length==0) {
			    return;
			}
			_this.doPaste(event);
			break;
		    case 'c': 
			_this.doCopy();
			break;
		    case 'm':
			_this.setCommand(ID_MOVER);
			break;
		    case 's': 
			_this.doSave();
			break;			    
		    case 'e': 
			_this.doEdit();
			break;
		    default:
			return;
		    }
		    event.preventDefault();
		}};
	    let options = {};
	    let handler = new OpenLayers.Handler.Keyboard(control, callbacks, options);
	    handler.activate();
	    this.getMap().getMap().addControl(keyboardControl);
	    this.addControl(ID_SELECTOR,'Click-drag to select',
			    this.featureSelector = new OpenLayers.Control.SelectFeature(this.myLayer, {
				select: function(feature) {
				    if(this.isShiftKey() && feature.mapGlyph.isSelected()) {
					_this.unselectGlyph(feature.mapGlyph);
					return;
				    }
				    _this.selectGlyph(feature.mapGlyph);
				},
				selectBox: function(position) {
				    this.checkEvent();
				    OpenLayers.Control.SelectFeature.prototype.selectBox.apply(this,arguments);
				},
				isShiftKey:function() {
				    let event = this?.handlers?.feature?.evt;
				    if(!event) return false;
				    return event.shiftKey || event.metaKey;
				},
				checkEvent: function() {
				    if(!this.isShiftKey()) {
					_this.unselectAll();
				    }
				},
				selectStyle: {
				    pointRadius:this.getPointRadius(),
				    strokeWidth:2,
				    fillOpacity: 0.5,
				    fillColor: "blue",
				    cursor: "pointer"
				},
				clickout: true,
				toggle: true,
				multiple: true, 
				hover: false,
				toggleKey: "ctrlKey", // ctrl key removes from selection
				multipleKey: "shiftKey", // shift key adds to selection
				box: true
			    }));

	    this.addControl(ID_EDIT,'Click to edit properties',
			    new OpenLayers.Control.SelectFeature(this.myLayer, {
		onSelect: function(feature) {
		    _this.doEdit(feature.mapGlyph);
		},
		clickout: true,
		toggle: true,
		multiple: false, 
		hover: false,
		toggleKey: "ctrlKey", // ctrl key removes from selection
		multipleKey: "shiftKey", // shift key adds to selection
		box: false
	    }));



	    let imageChecker = feature=>{
		if(feature.mapGlyph) {
		    feature.mapGlyph.checkImage(feature);
		}
		_this.featureChanged();
	    };
	    let mover =  this.addControl(ID_MOVER,'Click &amp; drag to move',
					 new OpenLayers.Control.DragFeature(this.myLayer,{
		moveFeature: function(pixel) {
		    let mapGlyph = this.feature.mapGlyph;
		    if(!mapGlyph) {
			console.log('no map glyph');
			return;
		    }
		    //If it isn't selected then clear any existing selection and select this one
		    if(!mapGlyph.isSelected()) {
			_this.unselectAll();
			mapGlyph.select();
		    }
		    let selected = _this.getSelected();
		    let res = this.map.getResolution();
		    let dx = res * (pixel.x - this.lastPixel.x);
		    let dy = res * (this.lastPixel.y - pixel.y);
		    selected.forEach(mapGlyph=>{
			mapGlyph.move(dx,dy);
		    });
		    this.lastPixel = pixel;
		    _this.featureChanged();	    
		},
		onDrag: function(feature, pixel) {
		}
	    }));

	    let MyMover =  OpenLayers.Class(OpenLayers.Control.ModifyFeature, {
		dragStart: function(feature) {
		    OpenLayers.Control.ModifyFeature.prototype.dragStart.apply(this, arguments);
		    if(feature && feature.mapGlyph) {
			_this.unselectAll(feature.mapGlyph);
			if(!feature.mapGlyph.isSelected()) {
			    _this.selectGlyph(feature.mapGlyph);
			}
		    }

		},
		dragComplete: function() {
		    OpenLayers.Control.ModifyFeature.prototype.dragComplete.apply(this, arguments);
		    this.theDisplay.featureChanged();	    
		    this.theDisplay.clearMessage2(1000);
		},
		isShiftKey:function() {
		    let event = this?.handlers?.drag?.evt;
		    if(!event) return false;
		    return event.shiftKey || event.metaKey;
		},
		dragVertex: function(vertex, pixel) {
		    if(Utils.isDefined(this.feature.isDraggable) && !this.feature.isDraggable) return
		    let mapGlyph = this.feature.mapGlyph;
		    if(!mapGlyph) return;

		    if(mapGlyph) {
			if(!mapGlyph.isSelected()) mapGlyph.select();
		    }
		    this.theDisplay.showDistances(this.feature.geometry,this.feature.type);
		    if(!this.feature.image &&
		       mapGlyph.getType()!=GLYPH_BOX &&
		       !mapGlyph.isPolygon() && 
		       !mapGlyph.isImage()) {
			OpenLayers.Control.ModifyFeature.prototype.dragVertex.apply(this, arguments);
			mapGlyph.vertexDragged(this.feature,vertex,pixel);
			return;
		    }
		    let vertices  = this.feature.geometry.getVertices();
		    let p  = vertex.geometry.getVertices()[0];
		    let index = -1;
		    vertices.every((v,idx)=>{
			if(v.x==p.x && v.y == p.y) {
			    index = idx;
			    return false;
			}
			return true
		    });
		    
		    let pos = this.map.getLonLatFromViewPortPx(pixel);
		    let geom = vertex.geometry;
		    let dx = pos.lon - geom.x;
		    let dy  = pos.lat - geom.y;
		    geom.move(dx, dy);
		    p  = vertex.geometry.getVertices()[0];
		    if(mapGlyph.isPolygon()) {
			if(this.isShiftKey()) {
			    vertices.forEach((v,otherIndex)=>{
				let abs = Math.abs(otherIndex-index);
				if(abs<3) {
				    let percent =(10-abs)/10; 
				    let ndx = dx*percent;
				    let ndy = dy*percent;
				    v.move(ndx,ndy);
				}
			    });
			}
		    } else {
			if(index==0) {
			    //nw
			    vertices[3].x = p.x;
			    vertices[1].y = p.y;			    
			} else 	if(index==1) {
			    //ne
			    vertices[2].x = p.x;
			    vertices[0].y = p.y;
			} else 	if(index==2) {
			    //se
			    vertices[1].x = p.x;
			    vertices[3].y = p.y;			    
			} else 	if(index==3) {
			    //sw
			    vertices[0].x = p.x;
			    vertices[2].y = p.y;
			}
		    }
		    this.feature.geometry.clearBounds();
		    this.layer.drawFeature(this.feature, this.standalone ? undefined :
					   'select');
		    this.layer.drawFeature(vertex);
		    _this.checkSelected(mapGlyph);
		    if(this.mode==OpenLayers.Control.ModifyFeature.ROTATE) {
			if(mapGlyph.isImage()) {
			    this.feature.style={strokeColor:'transparent',fillColor:'transparent'};
			    let rotation = Utils.getRotation(v);
			    mapGlyph.style.rotation = rotation.angle;
			}
		    } 
		    imageChecker(this.feature);
		}
	    });

	    let resizer = new MyMover(this.myLayer,{
		theDisplay:this,
		onDrag: function(feature, pixel) {
		    imageChecker(feature);},
		mode:OpenLayers.Control.ModifyFeature.RESIZE|OpenLayers.Control.ModifyFeature.DRAG});

	    let reshaper = new MyMover(this.myLayer, {
		theDisplay:this,
		onDrag: function(feature, pixel) {
		    imageChecker(feature);
		},
		createVertices:false,
		mode:OpenLayers.Control.ModifyFeature.RESHAPE});
	    let rotator = new MyMover(this.myLayer, {
		theDisplay:this,
		createVertices:false,
		mode:OpenLayers.Control.ModifyFeature.ROTATE});		

	    this.addControl(ID_RESIZE,'Click to resize',resizer);
	    this.addControl(ID_RESHAPE,'Click to reshape',reshaper);
	    this.addControl(ID_ROTATE,'Click to rotate',rotator);		

	    this.glyphTypes.forEach(g=>{
		this.glyphTypeMap[g.type]  = g;
		g.createDrawer();
	    });

	    
	}
    });
}



var MapObject = function(display, glyphType,feature) {
    this.id = HU.getUniqueId("");
    feature.objectId = this.id;
    this.display = display;
    this.feature = feature;
}

MapObject.prototype = {
    getId:function() {
	return this.id;
    }
}

var GlyphType = function(display,type,name,style,handler,options) {
    this.display = display;
    this.name = name;
    this.type = type;
    this.glyphStyle = style;
    this.handler = handler;
    this.options = options || {};
    this.options.glyphType = type;
    this.options.display = display;
    this.options.mapGlyph = this;
    display.addGlyphType(this);
};

GlyphType.prototype = {
    getName: function() {
	return this.name;
    },
    getTooltip: function() {
	return this.options.tooltip;
    },
    getNewHelp: function() {
	return this.options.newHelp;
    },    
    getIcon:function() {
	return this.options.icon;
    },
    getStyle:function() {
	return this.glyphStyle;
    },
    getType:  function() {
	return this.type;
    },
    isLabel:  function() {
	return this.getStyle().label!=null;
    },
    isImage:  function() {
	return this.options.isImage;
    },
    isEntry:  function() {
	return this.options.isEntry;
    },
    isMultiEntry:  function() {
	return this.options.isMultiEntry;
    },    
    isData:  function() {
	return this.options.isData;
    },
    isOSM:  function() {
	return this.options.isOsm;
    },    
    isFixed:  function() {
	return this.options.isFixed;
    },
    isZoom:  function() {
	return this.options.isZoom;
    },    
    isGroup:  function() {
	return this.options.isGroup;
    },	        
    isMap:  function() {
	return this.options.isMap;
    },
    isMapServer:  function() {
	return this.options.isMapServer;
    },			    
    isRoute: function() {
	return this.type == GLYPH_ROUTE;
    },
    isRings: function() {
	return this.type == GLYPH_RINGS;
    },    
    isIcon:  function() {
	return this.getStyle().externalGraphic!=null;
    },	
    applyStyle: function(style,forAll) {

	for(a in style) {
	    if(forAll && this.type ==GLYPH_LABEL) {
		//		    if(a=="pointRadius") continue;
		if(a=="strokeColor") continue;
		if(a=="fillColor") continue;		    
	    }
	    if(Utils.isDefined(this.getStyle()[a])) this.getStyle()[a] = style[a];
	}
    },
    newFeature: function(feature) {
	let glyph = new MapObject(this.display,this.type, feature);
    },
    createDrawer:function() {
	let _this = this;
	let layer = this.display.myLayer;
	let Drawer = OpenLayers.Class(OpenLayers.Control.DrawFeature, {
	    initialize: function(layer, options) {
		let defaultStyle = $.extend({}, MapUtils.getVectorStyle("default"));
		defaultStyle={};
		$.extend(defaultStyle, _this.getStyle());		    
		let styleMap = MapUtils.createStyleMap({"default":defaultStyle});
		options = {
		    handlerOptions:{
			style: defaultStyle,
			layerOptions:{
			    styleMap:styleMap
			}
		    }
		};
		$.extend(options.handlerOptions, _this.options);
		OpenLayers.Control.DrawFeature.prototype.initialize.apply(
		    this, [layer, _this.handler||OpenLayers.Handler.Point, options]
		);
	    },
	    drawFeature: function(geometry) {
		OpenLayers.Control.DrawFeature.prototype.drawFeature.apply(this, arguments);
		let feature =this.layer.features[this.layer.features.length-1];
		if(this.handler.theImage) {
		    feature.image = this.handler.theImage;
		}
		feature.type = _this.type;
		
		let newStyle;
		if(this.handler.style) {
		    newStyle=this.handler.style;
		}
		if(newStyle) {
		    for(a in _this.getStyle()) {
			if(!Utils.isDefined(newStyle[a])) {
			    newStyle[a] = _this.getStyle()[a];
			}
		    }
		    if(feature.style && feature.style.label)
			newStyle.label = feature.style.label;
		    let tmp = {};
		    $.extend(tmp, newStyle);
		    feature.style=tmp;
		}
		ImdvUtils.scheduleRedraw(this.layer);
		_this.newFeature(feature);
	    }
	});
	this.drawer = new Drawer(layer);
	this.display.addControl(this.type,"",this.drawer);
	return this.drawer;
    },
};



function RamaddaEditablemapDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaImdvDisplay(displayManager,  id,  properties);
    RamaddaUtil.inherit(this,SUPER);
}



/*
  this is a hook that OL calls to handle fillPatterns
  list of patterns from https://iros.github.io/patternfills/sample_svg.html
  and is generated with /bin/svgs.tcl
*/
window.olGetPatternId = function(ol,p,stroke,fill) {
    if(!ol.defs) {
        ol.defs = ol.createDefs();
    }
    if(!ol.idToSvgId) {
	ol.idToSvgId={};
    }
    stroke = stroke||'#000';
    fill = fill||'transparent';
    let id = p+'_'+stroke +'_'+fill;
    if(ol.idToSvgId[id]) return ol.idToSvgId[id];
    p = window.olGetSvgPattern(p,stroke,fill);
    if(!window.olPatternBaseId) window.olPatternBaseId = 1;
    let svgId = 'pattern_'+(window.olPatternBaseId++);
    let patternNode = ol.nodeFactory(null, "pattern");
    patternNode.setAttributeNS(null, ATTR_ID,svgId);
    patternNode.setAttributeNS(null, "width",p.width);
    patternNode.setAttributeNS(null, "height",p.height);
    patternNode.setAttributeNS(null, "patternUnits","userSpaceOnUse");
    let imageNode = ol.nodeFactory(null, "image");
    patternNode.appendChild(imageNode);
    imageNode.setAttributeNS(null, "x",0);	    
    imageNode.setAttributeNS(null, "y",0);
    imageNode.setAttributeNS(null, "width",p.width);
    imageNode.setAttributeNS(null, "height",p.height);
    imageNode.setAttributeNS(null, "href",p.url);
    ol.defs.appendChild(patternNode);
    ol.idToSvgId[id] = svgId;
    return svgId;
};


var IMDV_PATTERNS = {
    "diagonal-stripe-1":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>'/><path d='M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2' stroke='<%= foreground %>' stroke-width='1'/></svg> "},
    "diagonal-stripe-2":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>'/><path d='M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2' stroke='<%= foreground %>' stroke-width='2'/></svg>"},
    "diagonal-stripe-3":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>'/><path d='M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2' stroke='<%= foreground %>' stroke-width='3'/></svg>"},
    "diagonal-stripe-4":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>'/><path d='M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2' stroke='<%= foreground %>' stroke-width='4'/></svg>"},
    "diagonal-stripe-5":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>'/><path d='M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2' stroke='<%= foreground %>' stroke-width='5'/></svg>"},
    "diagonal-stripe-6":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>'/><path d='M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2' stroke='<%= foreground %>' stroke-width='6a'/></svg>"},
    "subtle-patch":{width:5,height:5,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='5' height='5'><rect width='5' height='5' fill='<%= background %>' /><rect x='2' y='2' width='1' height='1' fill='<%= foreground %>' /></svg>"},
    "sparse-rect-1":{
	width:30,height:30,
	svg:"<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30'><rect width='2' height='2' fill='<%= foreground %>' />' /></svg>"
    },
    "sparse-rect-2":{
	width:40,height:40,
	svg:"<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30'><rect width='2' height='2' fill='<%= foreground %>' />' /></svg>"
    },    
    "sparse-rect-3":{
	width:50,height:50,
	svg:"<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30'><rect width='2' height='2' fill='<%= foreground %>' />' /></svg>"
    },
    "sparse-rect-4":{
	width:60,height:60,
	svg:"<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30'><rect width='2' height='2' fill='<%= foreground %>' />' /></svg>"
    },    


    "whitecarbon":{width:6,height:6,svg:"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='6' height='6'><rect width='6' height='6' fill='<%= background %>'/><g id='c'><rect width='3' height='3' fill='<%= foreground %>'/><rect y='1' width='3' height='2' fill='<%= foreground %>'/></g><use xlink:href='#c' x='3' y='3'/></svg>"},
    "crosshatch":{width:8,height:8,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='8' height='8'><rect width='8' height='8' fill='<%= background %>'/><path d='M0 0L8 8ZM8 0L0 8Z' stroke-width='0.5' stroke='<%= foreground %>'/></svg> "},
    "houndstooth":{width:10,height:10,svg:"<svg width='10' height='10' xmlns='http://www.w3.org/2000/svg'><path d='M0 0L4 4' stroke='#aaa' fill='#aaa' stroke-width='1'/><path d='M2.5 0L5 2.5L5 5L9 9L5 5L10 5L10 0' stroke='<%= foreground %>' fill='<%= foreground %>' stroke-width='1'/><path d='M5 10L5 7.5L7.5 10' stroke='<%= foreground %>' fill='<%= foreground %>' stroke-width='1'/></svg> "},
    "verticalstripe":{width:6,height:49,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='6' height='49'><rect width='3' height='50' fill='<%= foreground %>'/><rect x='3' width='1' height='50' fill='#ccc'/></svg> "},
    "smalldot":{width:5,height:5,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='5' height='5'><rect width='5' height='5' fill='<%= background %>'/><rect width='1' height='1' fill='<%= foreground %>'/></svg>"},
    "lightstripe":{width:5,height:5,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='5' height='5'><rect width='5' height='5' fill='<%= background %>'/><path d='M0 5L5 0ZM6 4L4 6ZM-1 1L1 -1Z' stroke='<%= foreground %>' stroke-width='1'/></svg>"},
    "vertical-stripe-8":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='8' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-9":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='9' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-7":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='7' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-6":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='6' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-4":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='4' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-5":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='5' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-1":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='1' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-2":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='2' height='10' fill='<%= foreground %>' /></svg>"},
    "vertical-stripe-3":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='3' height='10' fill='<%= foreground %>' /></svg>"},
    "circles-6":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='3.5' cy='3.5' r='3.5' fill='<%= foreground %>'/></svg> "},
    "circles-7":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='4' cy='4' r='4' fill='<%= foreground %>'/></svg>"},
    "circles-5":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='3' cy='3' r='3' fill='<%= foreground %>'/></svg> "},
    "circles-4":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='2.5' cy='2.5' r='2.5' fill='<%= foreground %>'/></svg>"},
    "circles-1":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='1' cy='1' r='1' fill='<%= foreground %>'/></svg>"},
    "circles-3":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='2' cy='2' r='2' fill='<%= foreground %>'/></svg>"},
    "circles-2":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='1.5' cy='1.5' r='1.5' fill='<%= foreground %>'/></svg> "},
    "circles-9":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='5' cy='5' r='5' fill='<%= foreground %>'/></svg>"},
    "circles-8":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><circle cx='4.5' cy='4.5' r='4.5' fill='<%= foreground %>'/></svg>"},
    "horizontal-stripe-6":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='6' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-7":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='7' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-5":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='5' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-4":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='4' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-1":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='1' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-3":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='3' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-2":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='2' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-9":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='9' fill='<%= foreground %>' /></svg>"},
    "horizontal-stripe-8":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='10' height='8' fill='<%= foreground %>' /></svg>"},
    "dots-8":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='8' height='8' fill='<%= foreground %>' /></svg>"},
    "dots-9":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='9' height='9' fill='<%= foreground %>' /></svg>"},
    "dots-4":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='4' height='4' fill='<%= foreground %>' /></svg>"},
    "dots-5":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='5' height='5' fill='<%= foreground %>' /></svg>"},
    "dots-7":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='7' height='7' fill='<%= foreground %>' /></svg>"},
    "dots-6":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='6' height='6' fill='<%= foreground %>' /></svg>"},
    "dots-2":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='2' height='2' fill='<%= foreground %>' /></svg>"},
    "dots-3":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='3' height='3' fill='<%= foreground %>' /></svg> "},
    "dots-1":{width:10,height:10,svg:"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='<%= background %>' /><rect x='0' y='0' width='1' height='1' fill='<%= foreground %>' /></svg>"},
}



window.olGetSvgPattern = function(p,stroke,fill) {
    stroke = stroke||'#000';
    fill = fill||'transparent';

    p=IMDV_PATTERNS[p] ??IMDV_PATTERNS['diagonal-stripe-1'];
    let svg = p.svg.replace(/<%= *background *%>/g,fill).replace(/<%= *foreground *%>/g,stroke);
    let prefix = 'data:image/svg+xml;base64,';
    let url  = prefix+btoa(svg);
    return {
	width:p.width,
	height:p.height,
	url:url
    }
};


window.olDrawTextHook= function(renderer,style,label,featureId) {
    //check if we draw a background
    //returns true if the label.bbox.width==0
    let needRedo = olCheckLabelBackground(renderer,style,label,featureId);
    if (!label.parentNode) {
        renderer.textRoot.appendChild(label);
	if(needRedo) {
	    let bbox = label.getBBox();
	    renderer.textRoot.removeChild(label);
	    olCheckLabelBackground(renderer,style,label,featureId,bbox);
	    renderer.textRoot.appendChild(label);
	}
    }
}

function olCheckLabelBackground(renderer,   style,label,featureId,bbox) {
    if(style.textBackgroundFillColor !="" || style.textBackgroundStrokeColor !="") {
	bbox = bbox??label.getBBox();
	if(bbox.width==0 || bbox.height==0) {
	    return true;
	}
	let shape = 'rect';
	if(style.textBackgroundShape=='circle') shape='circle'
	else if(style.textBackgroundShape=='ellipse') shape='ellipse'	    
	let bg = renderer.nodeFactory(featureId + '_textbackground', shape);
	let pad=!isNaN(style.textBackgroundPadding)?style.textBackgroundPadding:0;
	let bgStyle = "";
	bgStyle+="fill:" +((style.textBackgroundFillColor=='' || !style.textBackgroundFillColor)?"transparent":style.textBackgroundFillColor)+";";
	if(style.textBackgroundStrokeColor!="") bgStyle+="stroke:" +style.textBackgroundStrokeColor+";";	    
	if(style.textBackgroundStrokeWidth>=0)
	    bgStyle+="stroke-width:" + style.textBackgroundStrokeWidth+";";
	if(!isNaN(style.textBackgroundFillOpacity))
	    bgStyle+="fill-opacity:" + style.textBackgroundFillOpacity+";";

	if(shape=='circle') {
	    bg.setAttribute("cx", bbox.x+bbox.width/2);
	    bg.setAttribute("cy", bbox.y+bbox.height/2);
	    bg.setAttribute("r", (bbox.width/2)+(+pad));
	} else   if(shape=='ellipse') {
	    bg.setAttribute("cx", bbox.x+bbox.width/2);
	    bg.setAttribute("cy", bbox.y+bbox.height/2);
	    bg.setAttribute("rx", (bbox.width/2)+(+pad));
	    bg.setAttribute("ry", (bbox.height/2)+(+pad));	    	    				
	} else {
	    bg.setAttribute("x", bbox.x-pad);
	    bg.setAttribute("y", bbox.y-pad);
	    bg.setAttribute("width", bbox.width+pad*2);
	    bg.setAttribute("height", bbox.height+pad*2);
	    if(style.textBackgroundRadius) {
		bg.setAttribute("rx", style.textBackgroundRadius);
	    }

	}
	bg.setAttribute(ATTR_STYLE, bgStyle);
	renderer.vectorRoot.appendChild(bg);
    }
    return false;
}



/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/

var debugDataIcons = false;

var DATAICON_PROPERTIES = ['externalGraphic','pointRadius','label'];
var DEFAULT_DATAICON_PROPS = 'font:50px sans-serif,lineWidth:5,requiredField:${_field},borderColor:#000,fill:#eee';
var DEFAULT_DATAICONS = 'label,pos:nw,dx:80,dy:-ch+20,label:${${_field} decimals=1 suffix=" ${unit}"}\nimage,pos:nw,dx:10,dy:10-ch,width:60,height:60,url:${icon}';
//DEFAULT_DATAICONS='label,pos:nw,dx:10,dy:-ch+20,label:${${_field} decimals=1 suffix=" ${unit}" prefix="${fieldName}"}\nimage,pos:nw,dx:10,dy:10-ch,width:60,height:60,url:${icon}'


var DEFAULT_DATAICON_FIELD='atmp|temp.*|.*temp';
var DEFAULT_DATAICON_FIELDS=DEFAULT_DATAICON_FIELD+',label=Temperature,unit=C\ndewpoint,label=Dewpoint,unit=C\n.*rh|relativehumidity,label=Relative Humidity,unit=%';


var LINETYPE_STRAIGHT='straight';
var LINETYPE_GREATCIRCLE='greatcircle';
var LINETYPE_CURVE='curve';
var LINETYPE_STEPPED='stepped';        

var ID_INMAP_LABEL='inmaplabel';

var ID_ADDDOTS = 'adddots';
var ID_LINETYPE = 'linetype';
var ID_SHOWDATAICONS = 'showdataicons';

var ID_DATAICON_USEENTRY = 'dataicon_useentry';
var ID_DATAICON_MARKERS = 'dataicon_markers';
var ID_DATAICON_LABEL='dataicon_label';
var ID_DATAICON_FIELDS='dataicon_fields';
var ID_DATAICON_INIT_FIELD='dataicon_init_field';
var ID_DATAICON_SELECTED_FIELD='dataicon_selected_field';
var ID_DATAICON_WIDTH='dataicon_width';
var ID_DATAICON_HEIGHT='dataicon_height';
var ID_DATAICON_SIZE='dataicon_size';
var ID_DATAICON_PROPS='dataicon_props';


//attr flags
var ID_DATAICON_SHOWING = 'dataIconShowing';
var ID_DATAICON_ORIGINAL = 'dataIconOriginal';
var ID_LEGEND_TEXT = 'legendText';

var ID_MAPFILTERS = 'mapfilters';
var ID_MAPFILTERS_OUTER = 'mapfiltersouter';
var ID_MAPLEGEND = 'maplegend';


function MapGlyph(display,type,attrs,feature,style,fromJson,json) {
    if(!type) {
	console.log("no type given for MapGlyph");
	console.trace();
	return
    }

    this.display = display;
    this.type = type;


    style = style??{};
    if(style.mapOptions) {
	delete style.mapOptions;
    }
    this.transientProperties = {};

    let glyphType = this.getGlyphType();
    if(attrs.routeProvider)
	this.name = "Route: " + attrs.routeProvider +" - " + attrs.routeType;
    else 
	this.name = attrs.name || glyphType.getName() || type;
    let mapGlyphs = attrs.mapglyphs;
    if(attrs.mapglyphs) delete attrs.mapglyphs;
    if(mapGlyphs) {
//	mapGlyphs = mapGlyphs.replace(/\\n/g,"\n");
	this.putTransientProperty("mapglyphs", mapGlyphs);
    }
    this.features = [];
    this.attrs = attrs;
    this.style = style;
    this.id = attrs.id ?? HU.getUniqueId("glyph_");
    if(this.isEntry()) {
	if(!Utils.isDefined(this.attrs.useentryname))
	    this.attrs.useentryname = true;
	if(!Utils.isDefined(this.attrs.useentrylabel))
	    this.attrs.useentrylabel = true;	
    }


    //Get the style with the macros applied
    style = this.getStyle(true);
    if(fromJson) {
	if(this.isStraightLine()) {
	    this.checkLineType(json.points);
	} else {
	    feature = this.display.makeFeature(this.display.getMap(),json.geometryType, style,
					       json.points);
	}
    }
    if(feature) {
	this.addFeature(feature);
	if(this.attrs.labelTemplate) {
	    style.label = this.attrs.labelTemplate.replace('${name}',this.getName());
	}
	MapUtils.setFeatureStyle(feature, style);
	this.display.addFeatures([feature]);
    }
    if(fromJson) {
	if(this.isImage()) {
	    this.checkImage(feature);
	}

	//If its an entry then fetch the entry info from the repository and use the updated lat/lon and name
	if(this.isEntry()) {
	    this.loadEntry();
	}

	//And call getBounds so the bounds object gets cached for later use on reload
	this.getBounds();
    }


    if(this.isRings()) {
	this.checkRings();
    }
    this.checkDataIconMenu();
}





MapGlyph.prototype = {
    CLASS_NAME:'MapGlyph',
    animationInfo:{},
    domId:function(id) {
	return this.getId() +'_'+this.display.domId(id);
    },
    jq:function(id) {
	return jqid(this.domId(id));
    },
    getFixedId: function() {
	return this.domId('_fixed');
    },
    initSideHelp:function(dialog) {
	let _this = this;
	dialog.find('.imdv-property-popup').click(function() {
	    let id  = $(this).attr('info-id');
	    let target  = $(this).attr('target');	    
	    let info = _this.getFeatureInfo(id);
	    if(!info) return;
	    let html = HU.b(info.getLabel());
	    let items =   ['filter.show=true','filter.rows=5','label=','filter.first=true','type=enum','filter.top=true','filter.showInMap=true']
	    if(info.isNumeric()) {
		items.push('format.decimals=0',
			   'filter.min=0',
			   'filter.max=100',
			   'filter.animate=true',
			   'filter.animate.step=1',
			   'filter.animate.sleep=100',
			   'filter.live=true');

	    }
	    if(info.isEnumeration()) {
		items.push('label.feature_value=');
	    }
	    items.push('colortable.select=true');

	    items.forEach(item=>{
		let label = item.replace('=.*','');
		html+=HU.div([ATTR_STYLE,'margin-left:10px;', ATTR_CLASS,HU.classes('ramadda-menu-item',CLASS_CLICKABLE),'item',item],item);
	    });

	    html = HU.div([ATTR_STYLE,'margin-left:10px;margin-right:10px;'],html);
	    let dialog =  HU.makeDialog({content:html, anchor:$(this)});
	    dialog.find('.' + CLASS_CLICKABLE).click(function() {
		dialog.remove();
		let item = $(this).attr('item');
		let line = info.id+'.' + item+'\n';
		let textComp = GuiUtils.getDomObject(target);
		if(textComp) {
		    WikiUtil.insertAtCursor('', textComp.obj, line);
		}
	    });
	});
    },

    getElevations:async function(points,callback,update) {
	let elevations = points.map(()=>{return 0;});
	let ok = true;
	let count=0;
	for(let i=0;i<points.length;i++) {
	    if(!ok) break;
	    let point = points[i];
	    let url = "https://nationalmap.gov/epqs/pqs.php?x="
		+ point.x + "&y=" + point.y
                + "&units=feet&output=json";
	    //	    console.log('url:'+ url);
            await  $.getJSON(url, (data)=> {
		let elevation = data?.USGS_Elevation_Point_Query_Service?.Elevation_Query?.Elevation;
		elevations[i]= elevation;
		count++;
		if(update)
		    ok = update(count,points.length);
		//		console.log("elevation #" + elevations.length+"/" + points.length+": " + elevation);
	    }).fail((data)=>{
		console.log('Failed to find elevation');
		console.dir(data);
		elevations.push(NaN);
	    });
	}
	callback(elevations,ok);
    },
    getIcon: function() {
	if(Utils.stringDefined(this.attrs.icon)) {
	    return this.attrs.icon;
	}
	if(this.attrs[ID_DATAICON_ORIGINAL] && Utils.stringDefined(this.attrs[ID_DATAICON_ORIGINAL].externalGraphic)) {
	    return this.attrs[ID_DATAICON_ORIGINAL].externalGraphic;
	}
	return this.style.externalGraphic ??this.getGlyphType().getIcon();
    },
    getGlyphType:function() {
	return  this.display.getGlyphType(this.getType());
    },
    putTransientProperty(name,value) {
	this.transientProperties[name] = value;
    },
    getTransientProperty(name) {
	return this.transientProperties[name];
    },    
    clone: function() {
	let style = Utils.clone(this.style);
	let attrs = Utils.clone(this.attrs);
	let cloned =  new MapGlyph(this.display, this.type,attrs,null,style);
	//give it a new ID
	cloned.id = HU.getUniqueId("glyph_");
	//clone the features and their styles
	let features = this.features.map(f=>{
	    f = f.clone();
	    if(f.style) {
		if(f.style.fixed) {
		    f.style = Utils.clone(f.style);
		} else {
		    f.style = style;
		}
	    }
	    f.layer=this.display.myLayer;
	    f.mapGlyph = cloned;
	    return f;
	});
	cloned.features=features;
	this.display.addFeatures(features);
	return cloned;
    },
    makeJson:function() {
	let attrs=this.getAttributes();
	let obj = {
	    mapOptions:attrs,
	    id:this.getId()
	};
	let style = this.getStyle();
	if(this.getMapLayer()) {
	    style = this.getMapLayer().style||style;
	}
	if(style) {
	    style = $.extend({},style);
	    if(this.getImage() && Utils.isDefined(this.getImage().opacity)) {
		style.imageOpacity=this.getImage().opacity;
	    }
	    obj.style = style;
	}

	//Set the location
	obj.points = this.getPoints(obj);

	if(this.isMultiEntry() && this.children) {
	    let locs = attrs.childrenLocations??{};
	    attrs.childrenLocations=locs;
	    this.children.forEach(child=>{
		if(child.overrideLocation) {
		    locs[child.attrs.entryId] = child.overrideLocation;
		}
	    });
	}
	if(!this.dontSaveChildren && this.haveChildren()) {
	    let childrenJson=[];
	    this.getChildren().forEach(child=>{
		if(child.isEphemeral) return;
		childrenJson.push(child.makeJson());
	    });
	    obj.children = childrenJson;
	}
	return obj;
    },	

    checkLayersAnimationButton:function() {
	if(this.attrs[PROP_LAYERS_ANIMATION_ON]) {
	    this.jq(PROP_LAYERS_ANIMATION_PLAY).html(HU.getIconImage(icon_stop));
	} else {
	    this.jq(PROP_LAYERS_ANIMATION_PLAY).html(HU.getIconImage(icon_play));
	}
    },
    checkLayersAnimation:function(skipCall) {
	if(this.animationTimeout) clearTimeout(this.animationTimeout);
	this.animationTimeout = null;
	if(!this.getProperty(PROP_LAYERS_ANIMATION_SHOW)) {
	    this.attrs[PROP_LAYERS_ANIMATION_ON] = false;
	    return;
	}
	this.checkLayersAnimationButton();
	if(!this.getVisible()) {
	    return;
	}
	if(skipCall) return;
	if(this.attrs[PROP_LAYERS_ANIMATION_ON]) {
	    let pause = this.getProperty(PROP_LAYERS_ANIMATION_DELAY,1000);
	    let stepAnimation = () =>{
		this.toggleLayersVisibility();
		this.checkLayersAnimation(true);
		this.animationTimeout = setTimeout(stepAnimation,pause);
		return;

//		this.jq(PROP_LAYERS_ANIMATION_PLAY).html(HU.getIconImage(icon_stop,null,[ATTR_STYLE,'color:blue;']));
		/*
		setTimeout(()=>{
		    this.jq(PROP_LAYERS_ANIMATION_PLAY).html(HU.getIconImage(icon_stop));
		},300);
*/
	    }
	    stepAnimation();
	}
    },
    toggleLayersAnimation:function() {
	this.attrs[PROP_LAYERS_ANIMATION_ON]	  =  !this.attrs[PROP_LAYERS_ANIMATION_ON];
	if(this.attrs[PROP_LAYERS_ANIMATION_ON] && !this.getVisible()) {
	    this.setVisible(true,null,null,true);
	}
	this.checkLayersAnimation();
    },
    toggleLayersVisibility:function(event) {
	let children = 	this.getChildren();
	if(!children||children.length==0) return;
	children.forEach(child=>{
	    child.highlighted=false;
	});
	event = event??{};
	if(event.shiftKey) {
	    children.forEach(child=>{
		child.setVisible(true,true);
	    });
	    return
	}
	if(event.metaKey) {
	    children.forEach(child=>{
		child.setVisible(false,true);
	    });
	    return
	}	

	if(this.getProperty(PROP_LAYERS_SHOW_SEQUENCE)) {
	    children.every(child=>{
		if(!child.isVisible()) {
		    child.setVisible(true,true);
		    return false;
		}
		return true;
	    });
	    return;

	}


	let nextIdx=0;
	if(!this.visibleChild) nextIdx=0;
	else {
	    nextIdx = children.indexOf(this.visibleChild);
	    if(nextIdx<0) nextIdx=0;
	    else if(nextIdx==children.length-1) nextIdx=0;
	    else nextIdx++;
	}
	children.forEach((child,idx) =>{
	    if(idx==nextIdx) {
		child.setVisible(true,true,true);
		this.visibleChild = child;
	    }  else {
		child.setVisible(false,true);
	    }
	});
    },
    applyStyleToChildren:function(prop,value) {
	this.applyChildren(child=>{
	    if(child.style) {
		child.style[prop] = value;
		child.applyStyle(child.style);
		child.applyStyleToChildren(prop,value);
		this.display.redraw(child);
	    }
	});
    },
    getPoints:function(obj) {
	if(this.attrs.originalPoints) return this.attrs.originalPoints;
	let geom = this.getGeometry();
	if(!geom) return null;
	obj.geometryType=geom.CLASS_NAME;
	let points = obj.points=[];
	let vertices  = geom.getVertices();
	let  p =d=>{
	    return Utils.trimDecimals(d,6);
	};
	if(false && this.getImage()) {
	    let b = this.getMap().transformProjBounds(geom.getBounds());
	    points.push(p(b.top),p(b.left),
			p(b.top),p(b.right),
			p(b.bottom),p(b.right),
			p(b.bottom),p(b.left));				    
	} else {
	    vertices.forEach(vertex=>{
		let pt = vertex.clone().transform(this.getMap().sourceProjection, this.getMap().displayProjection);
		points.push(p(pt.y),p(pt.x));
	    });
	}
	return points;
    },

    isMultiEntry:  function() {
	return this.type == GLYPH_MULTIENTRY;
    },
    getRadii:function() {
	if(!this.attrs.radii) {
	    let level = this.display.getCurrentLevel();
	    //	    console.log("level:" + level);
	    let r = (size,unit) =>{
		let s =[];
		for(let i=1;i<=5;i++) {
		    s.push((size*i)+unit);
		}
		this.attrs.radii = s;
		return s;
	    }
	    if(level>=19) return r(25,UNIT_FT);
	    if(level>=18) return r(50,UNIT_FT);
	    if(level>=17) return r(75,UNIT_FT);	    
	    if(level>=16) return r(150,UNIT_FT);
	    if(level>=15) return r(250,UNIT_FT);	    
	    if(level>=14) return r(500,UNIT_FT);
	    if(level>=13) return r(1500,UNIT_FT);
	    if(level>=12) return r(0.5,UNIT_MILES);
	    if(level>=11) return r(1,UNIT_MILES);
	    if(level>=10) return r(2,UNIT_MILES);
	    if(level>=9) return r(2.5,UNIT_MILES);	    	    	    
	    if(level>=8) return r(5,UNIT_MILES);
	    if(level>=7) return r(10,UNIT_MILES);
	    if(level>=6) return r(25,UNIT_MILES);
	    if(level>=5) return r(50,UNIT_MILES);
	    if(level>=4) return r(100,UNIT_MILES);	    	    	    	    
	    if(level>=3) return r(250,UNIT_MILES);	    	    	    	    
	    return	 r(500,UNIT_MILES);
	}
	return this.attrs.radii;
    },
    addToStyleDialog:function(style) {
	if(this.isRings()) {
	    return HU.formEntry('Rings Radii:',HU.input('',Utils.join(this.getRadii(),','),
							[ATTR_ID,this.domId('radii'),'size','40'])+' e.g., 1km, 2mi (miles), 100ft') +
		HU.formEntryTop('Rings Labels:',
				HU.hbox([HU.input('',this.attrs.rangeRingLabels??'',
						  [ATTR_ID,this.domId('rangeringlabels'),'size','40']),
					 'Use ${d} macro for the distance e.g.:<br> Label 1 ${d}, ..., Label N ${d}  '])) +

		HU.formEntry('Ring label angle:',
			     HU.input('',Utils.isDefined(this.attrs.rangeRingAngle)?this.attrs.rangeRingAngle:90+45,[
				 ATTR_ID,this.domId('rangeringangle'),'size',4]) +' Leave blank to not show labels') +
		HU.formEntryTop('Ring Styles',
				HU.hbox([HU.textarea('',this.attrs.rangeRingStyle??'',[ATTR_ID,this.domId('rangeringstyle'),'rows',5,'cols', 40]),
					 'Format:<br>ring #,style:value,style:value  e.g.:<br>1,fillColor:red,strokeColor:blue<br>2,strokeDashstyle:dot|dash|dashdot|longdash<br>N,strokeColor:black<br>*,strokeWidth:5<br>even,...<br>odd,...']));
	}
	if(this.isMapServer()) {
	    let url = this.getMapServerUrl();
	    if(Utils.stringDefined(url)) {
		let extra = HU.formEntry("Server URL:",
					 HU.input('',url,
						  [ATTR_PLACEHOLDER,'e.g. ...${z}/${x}/${y}.png',
						   ATTR_ID,this.domId('serverurl'),'size','60']));

		if(Utils.stringDefined(this.attrs.wmsLayer)) {
		    extra += HU.formEntry("WMS Layer:",
					  HU.input('',this.attrs.wmsLayer,[ATTR_ID,this.domId('wmslayer'),'size','20']));
		}
		return extra;
	    }

	}


	if(this.isMapServer() && this.getDatacubeVariable()) {
	    return HU.formEntry('Color Table:',HU.div([ATTR_ID,this.domId('colortableproperties')]));
	}	    

	if(this.isStraightLine()) {
	    return HU.formEntry('Line type:',
				HU.select('',[ATTR_ID,this.domId(ID_LINETYPE)],[
				    {value:LINETYPE_STRAIGHT,label:'Straight'},
				    {value:LINETYPE_STEPPED,label:'Stepped'},
				    {value:LINETYPE_CURVE,label:'Curve'},
				    {value:LINETYPE_GREATCIRCLE,label:'Great Circle'}],
					  this.attrs.lineType)) +
		HU.formEntry('',HU.checkbox(this.domId(ID_ADDDOTS),[ATTR_ID,this.domId(ID_ADDDOTS)],this.attrs.addDots,'Add dots'));
	}

	return '';
    },

    addToPropertiesDialog:function(content,style) {
	let html='';
	let layout = (lbl,widget)=>{
	    html+=HU.b(lbl)+'<br>'+widget+'<br>';
	}
	let nameWidget = HU.input('',this.getName(),[ATTR_ID,this.domId('mapglyphname'),'size','40']);
	if(this.isEntry()) {
	    nameWidget+='<br>' +HU.checkbox(this.domId('useentryname'),[],this.getUseEntryName(),'Use name from entry');
	    nameWidget+=HU.space(3) +HU.checkbox(this.domId('useentrylocation'),[],this.getUseEntryLocation(),'Use location from entry');
	}
	html+=HU.formTable();
	html+=HU.formEntry('Name:',nameWidget);
	if(this.isMap()) {
	    if(this.attrs.entryId) {
		html+=HU.formEntry('Entry ID:',HU.input('',this.attrs.entryId,
							[ATTR_ID,this.domId('entryid'),'size','60']));
	    }
	    if(this.attrs.resourceUrl) {
		html+=HU.formEntry('Map URL:',HU.input('',this.attrs.resourceUrl,[ATTR_ID,this.domId('resourceurl'),'size','60']));
	    }
	}	    
	html+=HU.formTableClose();


	let level = this.getVisibleLevelRange(true)??{};
	html+= HU.checkbox(this.domId('visible'),[],this.getVisible(),'Visible')
	if(this.getMapLayer()) {
	    html+= HU.space(4)+HU.checkbox(this.domId('canselect'),[],this.getCanSelect(),'Can Select');
	}
	html+='<br>';	
	html+=this.display.getLevelRangeWidget(level,this.getShowMarkerWhenNotVisible());

	let featureInfo = this.getFeatureInfoList();
	let 	lines = Utils.mergeLists(['_name','default'],featureInfo.map(info=>{return info.id;}));

	let makePopup = (id,label)=> {
	    let domId = this.display.domId('glyphedit_' +id);
	    let propsHelp =this.display.makeSideHelp(lines,domId,{prefix:'${',suffix:'}'});
	    let h = HU.leftRightTable(HU.b(label),
				    this.getHelp('#popuptext'));
	    let help = 'Add macro:'+ HU.div([ATTR_CLASS,'imdv-side-help'],propsHelp);
	    h+=  HU.hbox([HU.textarea('',style[id]??'',[ATTR_ID,domId,'rows',4,'cols', 40]),HU.space(2),help]);
	    return h;
	}
	html+=makePopup('popupText','Popup Text:');
	html+=HU.b('Legend Text:') +'<br>' +
	    HU.textarea('',this.attrs[ID_LEGEND_TEXT]??'',
			[ATTR_ID,this.domId(ID_LEGEND_TEXT),'rows',4,'cols', 40]);
	




	content.push({header:'Properties',contents:html});

	html='';
//	html=  this.getHelp('#miscproperties')+'<br>';
	let miscLines =[...IMDV_PROPERTY_HINTS];
	if(this.canHaveChildren()) {
	    miscLines.push(...IMDV_GROUP_PROPERTY_HINTS);
	}
	if(this.isMap()) {
	    miscLines.push('declutter.features=true');
	    miscLines.push('colortable.select=false');
	    miscLines.push('colortable.alpha=0.5');
	    miscLines.push('colortable.showDots=true');
	}

	this.getFeatureInfoList().forEach((info,idx)=>{
	    if(idx==0) {
		miscLines.push({skip:true,line:'<thin_hr></thin_hr><b>Features</b>'});
	    }		
	    miscLines.push({info:info.id,title:info.getLabel()});	    
	});

	let miscHelp =this.display.makeSideHelp(miscLines,this.domId('miscproperties'),{style:'height:350px;max-height:350px;',suffix:'\n'});
	let ex = HU.b('Add property: ') + HU.span([ATTR_ID,this.domId('propsearch')]) + miscHelp

	html += HU.hbox([HU.textarea('',this.attrs.properties??'',[ATTR_ID,this.domId('miscproperties'),'rows',16,'cols', 40]),
			 HU.space(2),ex]);
	content.push({header:'Flags',contents:html});

	if(this.isDataIconCapable()) {
	    let contents ='';
	    let help = this.getHelp('dataicons.html');
	    let dataIconsSelect= HU.b('Show data icons: ')+
		HU.select('',[ATTR_ID,this.domId(ID_SHOWDATAICONS)],
			  ['inherited','yes','no'],
			  this.attrs[ID_SHOWDATAICONS]??'inherited');
			  
	    contents+= HU.leftRightTable(dataIconsSelect,help);
	    contents+='<thin_hr></thin_hr>';
	    if(Utils.stringDefined(this.transientProperties.mapglyphs)) {
		let on = this.getAttribute(ID_DATAICON_USEENTRY);
		let id = this.domId(ID_DATAICON_USEENTRY);
		contents+=  HU.radio(id, id, '', 'true', on) +
		    HU.tag('label',['for', id,ATTR_TITLE,''],  'Use the default data icon specification for the entry');
		contents+='<br>';
		contents+=  HU.radio(id+'_oruse', id, '', 'false', !on) +
		    HU.tag('label',['for', id+'_oruse',ATTR_TITLE,''],  'Use parent group\'s or the below if defined');
		contents+='<br>';
	    }



	    let buttonList = [HU.span([ATTR_ID,this.domId('dataicon_add_default'),ATTR_TITLE,'Set example values'],'Apply Defaults')];
	    if(Utils.stringDefined(this.transientProperties.mapglyphs)) {
		buttonList.push(HU.span([ID_GLYPH_ID,this.getId(),ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Apply settings from entry',ATTR_ID,this.domId('applyentrydataicon')],'Apply from Entry'));
	    }
	    buttonList.push(HU.span([ATTR_ID,this.domId('dataicon_clear_default'),ATTR_TITLE,'Clear properties'],'Clear'));

	    let dataIconInfo  =this.getDataIconInfo();
	    contents+=  HU.buttons(buttonList,
				   null,HU.css('text-align','left'));

	    let fields1 = HU.b('Menu Fields:')+'<br>'+
		HU.textarea('',dataIconInfo[ID_DATAICON_FIELDS]??'',
			    ['placeholder','field pattern,label=<label>,unit=<unit>\ne.g.:\n'+
			     DEFAULT_DATAICON_FIELDS,ATTR_ID,this.domId(ID_DATAICON_FIELDS),'rows',4,'cols', 60]);
	    let  fields2= HU.b('Initial field:')+'<br>'+
		HU.input('',dataIconInfo[ID_DATAICON_INIT_FIELD]??'',[ATTR_ID,this.domId(ID_DATAICON_INIT_FIELD),'size','25','placeholder','Initial field']) +'<br>' +
		HU.b('Menu Label:') +'<br>'  +
		HU.input('',dataIconInfo[ID_DATAICON_LABEL]??'',[ATTR_ID,this.domId(ID_DATAICON_LABEL),'size','25']);

	    contents+=HU.table(HU.tr(['valign','top'],HU.td(fields1) +HU.td(HU.div([ATTR_STYLE,'margin-left:8px;'],fields2))));
	    contents+='<p>';
	    contents+=HU.b('Canvas: ') +
		'W: ' + HU.input('',dataIconInfo[ID_DATAICON_WIDTH]??'',[ATTR_ID,this.domId(ID_DATAICON_WIDTH),'size','3']) +
		' H: ' + HU.input('',dataIconInfo[ID_DATAICON_HEIGHT]??'',[ATTR_ID,this.domId(ID_DATAICON_HEIGHT),'size','3']) +
		HU.space(2) + HU.b('Icon Size: ') +
		HU.input('',dataIconInfo[ID_DATAICON_SIZE]??'',[ATTR_ID,this.domId(ID_DATAICON_SIZE),'size','3']);


	    contents+=  HU.div([ATTR_STYLE,'padding-bottom:0.5em;'],
			       HU.b('Properties:') + HU.space(1) +
			       HU.input('',dataIconInfo[ID_DATAICON_PROPS]??'',[ATTR_ID,this.domId(ID_DATAICON_PROPS),'size','80']));
	    contents+=HU.b('Icon Specification:')  +'<br>';
	    contents +=
		HU.textarea('',dataIconInfo[ID_DATAICON_MARKERS]??'',[ATTR_ID,this.domId(ID_DATAICON_MARKERS),'rows',4,'cols', 90]);
	    content.push({
		header:'Data Icons',
		contents: contents});

	}
	if(this.isMultiEntry()) {
	    let exc = 'Enter entry IDs to exclude. One per line. Note: this will take effect on map reload.<br>';

	    exc+= HU.textarea('',   this.getAttribute('excludes')??'',
			      [ATTR_ID,this.domId('excludes'),'rows','8','cols','60']);
	    content.push({
		header:'Exclude Entries',
		contents: exc});
	}


    },
    addElevations:async function(update,done) {
	let pts;
	if(this.mapLayer) {
	    pts = [];
	    let features= this.mapLayer.features;
	    features.forEach((feature,idx)=>{
		let pt = feature.geometry.getCentroid();
		pts.push(this.display.getMap().transformProjPoint(pt))
	    });
	} else {
	    pts = this.display.getLatLonPoints(this.getGeometry());
	}
	let callback = (points)=>{
	    this.attrs.elevations = points;
	    this.features[0].elevations = points;
	    done();
	};
	await this.getElevations(pts,callback,update);
    },

    applyPropertiesDialog: function(style) {
	//Clear out any feature infos
	this.featureInfo=null;

	//Make sure we do this after we set the above style properties
	this.setName(this.jq("mapglyphname").val());
	if(this.isMap()) {
	    let newEntryId = this.jq('entryid').val();
	    if(newEntryId && this.attrs.entryId!=newEntryId) {
		this.attrs.entryId = newEntryId;
		setTimeout(()=>{this.checkMapLayer(false,true);},10);
	    }

	    let newUrl = this.jq('resourceurl').val();
	    if(newUrl!=this.attrs.resourceUrl) {
		this.attrs.resourceUrl = newUrl;
		setTimeout(()=>{this.checkMapLayer(false,true);},10);
	    }
	}
	if(this.isMultiEntry()) {
	    this.attrs['excludes']  = this.jq('excludes').val();
	}	    

	this.attrs[ID_LEGEND_TEXT] = this.jq(ID_LEGEND_TEXT).val();
	if(this.isEntry()) {
	    this.setUseEntryName(this.jq("useentryname").is(":checked"));
	    this.setUseEntryLabel(this.jq("useentrylabel").is(":checked"));
	    this.setUseEntryLocation(this.jq("useentrylocation").is(":checked"));
	}
	this.setVisible(this.jq('visible').is(':checked'),true,null,true);
	if(this.jq('canselect').length) {
	    this.attrs.canSelect = this.jq('canselect').is(':checked');
	    if(this.getMapLayer()) this.getMapLayer().canSelect = this.attrs.canSelect;
	}

	this.parsedProperties = null;
	this.attrs.properties = this.jq('miscproperties').val();
	if(this.display.jq(ID_LEVEL_RANGE_CHANGED).val()=='changed') {
	    this.setVisibleLevelRange(this.display.jq(ID_LEVEL_RANGE_MIN).val(),
				      this.display.jq(ID_LEVEL_RANGE_MAX).val());
	} else 	if(this.display.jq(ID_LEVEL_RANGE_CHANGED).val()=='cleared') {
	    this.attrs.visibleLevelRange = null;
	    this.checkVisible();
	}
	this.setShowMarkerWhenNotVisible(this.display.jq('showmarkerwhennotvisible').is(':checked'));

	if(this.isMapServer()) {
	    let url = this.jq('serverurl').val();
	    if(url) {
		url = url.trim();
		url = url.replace(/\/(\d+)\/(\d+)\/(\d+)\.png/, "/${z}/${x}/${y}.png");
		url = url.replace(/\/(\d+)\/(\d+)\/(\d+)\.jpg/, "/${z}/${x}/${y}.jpg");
		url = url.replace(/\/(\d+)\/(\d+)\/(\d+)\.jpeg/, "/${z}/${x}/${y}.jpeg");
		this.attrs.mapServerUrl = url;
	    }
	}

	if(this.isMapServer()  && this.getDatacubeVariable()) {
	    if(this.currentColorbar!=this.getDatacubeVariable().colorBarName) {
		this.getDatacubeVariable().colorBarName = this.currentColorbar;
		this.mapServerLayer.url = this.getMapServerUrl();
		this.mapServerLayer.redraw();
	    }
	}
	if(this.isRings()) {
	    this.attrs.radii=Utils.split(this.jq('radii').val()??'',',',true,true);
	    this.attrs.rangeRingLabels =this.jq('rangeringlabels').val();
	    this.attrs.rangeRingAngle=this.jq('rangeringangle').val();
	    this.attrs.rangeRingStyle = this.jq('rangeringstyle').val();
	    if(this.features.length>0) this.features[0].style.strokeColor='transparent';
	}


	if(this.isMultiEntry()) {
	    this.applyChildren(child=>{
		let newStyle = $.extend({},style);
		if(!style.showLabels) {
		    newStyle.label=null;
		} else {
		    newStyle.label = child.style.label;
		}
		newStyle.externalGraphic = child.style.externalGraphic;		
		child.applyStyle(newStyle);
	    });
	}


	if(this.isDataIconCapable()) {
	    if(this.jq(ID_SHOWDATAICONS).length) {
		this.setShowDataIcons(this.jq(ID_SHOWDATAICONS).val());
	    }
	    this.setAttribute(ID_DATAICON_USEENTRY,this.jq(ID_DATAICON_USEENTRY).is(':checked'));
	    let dataIconInfo = this.getDataIconInfo();
	    [ID_DATAICON_MARKERS, ID_DATAICON_FIELDS,ID_DATAICON_INIT_FIELD,
	     ID_DATAICON_WIDTH, ID_DATAICON_HEIGHT, ID_DATAICON_SIZE,
	     ID_DATAICON_LABEL, ID_DATAICON_PROPS].forEach(prop=>{
		 dataIconInfo[prop] = this.jq(prop).val();
	     });
	}

	if(style.label && this.attrs.labelTemplate) {
	    this.attrs.labelTemplate= style.label;
	}

	this.applyStyle(style);

	if(this.isDataIconCapable()) {
	    this.applyDataIcon();
	    this.checkDataIconMenu();
	}

	if(this.getImage()) {
	    this.getImage().setOpacity(style.imageOpacity);
	    this.checkImage();
	}

	//If we are a group then this triggers a redraw of any descendent images
	//to apply the inherited image transform
	this.applyChildren(child=>{
	    if(child.getImage()) {
		child.checkImage();
	    }
	},true);



    },

    
    featureSelected:function(feature,layer,event) {
	if(this.selectedStyleGroup) {
	    let indices = this.selectedStyleGroup.indices;
	    if(indices.includes(feature.featureIndex)) {
		this.selectedStyleGroup.indices = Utils.removeItem(indices,feature.featureIndex);
		MapUtils.setFeatureStyle(feature,null,null);
	    } else {
		this.getStyleGroups().forEach((group,idx)=>{
		    group.indices = Utils.removeItem(group.indices,feature.featureIndex);
		});
		feature.originalStyle = MapUtils.setFeatureStyle(feature,$.extend(feature.style??{},this.selectedStyleGroup.style));
		indices.push(feature.featureIndex);
	    }
	    ImdvUtils.scheduleRedraw(layer,feature);
	    this.display.featureChanged(true);	    
	    return
	}
	this.display.getMap().onFeatureSelect(feature.layer,event)
    },
    featureUnselected:function(feature,layer,event) {
	//	this.display.getMap().onFeatureSelect(feature.layer,event)
    },
    glyphCreated:function() {
	this.applyDataIcon();
    },


    isDataIconCapable:function() {
	return this.isEntry() || this.isGroup()  || this.isMultiEntry();
    },
    getDataIconInfo:function(v) {
	let ID = 'dataIconInfo';
	//check for old property
	if(this.attrs.glyphInfo) {
	    if(!this.attrs[ID]) {
		this.attrs[ID] = this.attrs.glyphInfo;
	    }
	    this.attrs.glyphInfo = null;
	}

	if(!this.attrs[ID]) {
	    this.attrs[ID] = {};
	}
	let info =  this.attrs[ID];
	//backwards compat
	if(info.glyphs) {
	    if(!info[ID_DATAICON_MARKERS]) info[ID_DATAICON_MARKERS]= info.glyphs;
	    info.glyphs=null;
	}
	return info;
    },
    getDataIconProperty:function(property,dflt) {
	let debug = false;
//	debug=property==ID_DATAICON_SELECTED_FIELD;
	if(this.getAttribute(ID_DATAICON_USEENTRY)) {
	    return dflt;
	}	    

	if(debug) {
	    console.log("getDataIconProperty:" + this.getName()+' prop='+property);
	}
	let value = this.getDataIconInfo()[property];
	if(Utils.stringDefined(value)) {
	    if(debug) console.log("\tmine:" +value);
	    //If it is the field then make sure it is in the FIELDS
	    if(property==ID_DATAICON_SELECTED_FIELD) {
		let fields = this.getDataIconInfo()[ID_DATAICON_FIELDS];
		if(!Utils.stringDefined(fields) ||
		   (fields && fields.indexOf(value)<0)) {
		       value = null;
		   }
	    }
	    if(value)
		return value;
	}
	if(property==ID_DATAICON_INIT_FIELD) {
	    if(this.dataIconFieldsId) {
		glyphField = jqid(this.dataIconFieldsId).val();
		if(glyphField) return glyphField;
	    }
	}

	if(this.getParentGlyph()) {
	    if(debug)
		console.log("\tasking parent");
	    return this.getParentGlyph().getDataIconProperty(property,dflt);
	}
	return dflt;
    },

    getDataIconMarkers:function() {
	if(this.getAttribute(ID_DATAICON_USEENTRY)) {
	    if(Utils.stringDefined(this.transientProperties.mapglyphs)) {
		return this.transientProperties.mapglyphs;
	    }
	}
	let markers = this.getDataIconProperty(ID_DATAICON_MARKERS);
	if(Utils.stringDefined(markers)) {
	    return markers;
	}
	return this.transientProperties.mapglyphs;
    },


    checkDataIconMenu:function() {
	let _this = this;
	let dataIconInfo = this.getDataIconInfo();
	if(this.dataIconContainer) {
	    jqid(this.dataIconContainer).hide();
	}
	if(!this.getProperty('showGlyphMenu',true,true)) {
	    return
	}

	if(!Utils.stringDefined(dataIconInfo[ID_DATAICON_FIELDS])) {
	    return;
	}	    
	this.dataIconFieldsId = HU.getUniqueId('dataiconfields_');


	if(!this.dataIconContainer || jqid(this.dataIconContainer).length==0) {
	    this.dataIconContainer = HU.getUniqueId('dataiconfieldscontainer_');
	    this.display.jq(ID_HEADER1).append(HU.div([ATTR_STYLE,HU.css('display','inline-block','margin-right','20px'),ATTR_ID,this.dataIconContainer]));
	}
	jqid(this.dataIconContainer).show();


	let items = [];
	Utils.split(dataIconInfo[ID_DATAICON_FIELDS],'\n',true,true).forEach(item=>{
	    let toks = Utils.split(item,',',true,true);
	    let map = {};
	    for(let i=1;i<toks.length;i++) {
		let toks2 = Utils.split(toks[i],"=",true,true);
		if(toks2.length>1) map[toks2[0]] = toks2[1];
	    }
	    items.push({value:toks[0],label:map.label});
	});
	let menu = HU.select('',[ATTR_ID,this.dataIconFieldsId],
			     items,
			     Utils.getStringDefined(dataIconInfo[ID_DATAICON_SELECTED_FIELD],
						    dataIconInfo[ID_DATAICON_INIT_FIELD]));
	let label = Utils.getStringDefined(dataIconInfo[ID_DATAICON_LABEL],'Select field');
	let clazz = '';
	if(!this.isVisible()) {
	    clazz+=' ' + CLASS_LEGEND_LABEL_INVISIBLE;
	}
	let contents = HU.div([ATTR_CLASS,clazz,ATTR_STYLE,HU.css('padding','4px')],HU.b(label)+':'+HU.space(1)+menu);
	jqid(this.dataIconContainer).html(contents);

	jqid(this.dataIconFieldsId).change(function(){
	    _this.getDataIconInfo()[ID_DATAICON_SELECTED_FIELD] = $(this).val();
	    _this.applyDataIcon();
	});

    },


    getStyleForProperties:function(style) {
	return this.resetDataIconOriginal(style);
    },

    resetDataIconOriginal:function(style) {
	style = style??this.style;
	if(this.attrs[ID_DATAICON_ORIGINAL]) {
	    let o = this.attrs[ID_DATAICON_ORIGINAL];
	    DATAICON_PROPERTIES.forEach(prop=>{
		style[prop] = o[prop]??this.style[prop];
	    });
	}
	if(this.isDataIconCapable()) {
	    if(Utils.stringDefined(this.attrs.icon)) {
		style.externalGraphic = this.attrs.icon;
	    }
	}
	return style;
    },
    clearDataIcon: function() {
	if(this.getDataIconShowing()) {
	    this.setDataIconShowing(false);
	    this.resetDataIconOriginal();
	    this.attrs[ID_DATAICON_ORIGINAL] = null;
	    this.applyStyle();
	}
    },

    glyphHasBeenDropped:function() {
	if(this.getShowDataIcons()) {
	    this.applyDataIcon();
	} else {
	    this.clearDataIcon();
	}
    },


    applyDataIcon: function() {
	if(this.isEntry()) {
	    this.makeDataIcon();
	}
	this.applyChildren(child=>{
	    child.applyDataIcon();
	});
    },


    makeDataIcon:function(force) {
	let debug  = false;
//	debug=true;

	if(!this.isVisible())  {
	    return;
	}
	if(!force && !this.getShowDataIcons()) {
	    this.clearDataIcon();
	    return;
	}
	let markersString = this.getDataIconMarkers();
	if(!Utils.stringDefined(markersString)) {
	    return;
	}
	if(debug)	console.log('makeDataIcon',this.getName());
	let opts = {
	    entryId:this.attrs.entryId
	};

	let markerLines = [];
	markersString = markersString.replace(/\\ *\n/g,'');
	let rawLines = Utils.split(markersString,'\n',true,true);
	rawLines.forEach(line=>{
	    line = line.trim();
	    if(line.startsWith("#") || line == "") return;
	    //console.log('\tline:'+line);
	    markerLines.push(line);
	});
	if(markerLines.length==0) {
	    console.log("\tno markers-2");
	    return;
	}
	let markers = [];
	let lines=[];
	let props = {};
	markerLines.forEach(line=>{
	    line = line.trim();
	    if(line.startsWith("#")) return;
	    if(line.startsWith('props:')) {
		this.parseDataIconProps(props,line.substring('props:'.length));
		return;
	    }
	    lines.push(line);
	});
	this.parseDataIconProps(props,this.getDataIconProperty(ID_DATAICON_PROPS));

	let sampleCount = props.sampleCount??1;
	let url = Ramadda.getUrl("/entry/data?record.last="+ sampleCount+"&max=" + sampleCount+"&entryid=" + opts.entryId);
//	console.log('url',url);
	let pointData = new PointData("",  null,null,url, {entryId:opts.entryId});


	let callback = (data)=>{
	    this.makeDataIcons(pointData,data,markers,lines,props);
	}
	let fauxDisplay  = {
	    display:this.display,
	    type: "map glyph proxy",
	    getId() {
		return "ID";
	    },
	    pointDataLoaded:function(data,url) {
		callback(data);
	    },
            pointDataLoadFailed:function(err){
		this.display.pointDataLoadFailed(err);
	    },
	    applyRequestProperties:function(props) {
	    },
	    handleLog:function(err) {
		this.display.handleLog(err);
	    },
	    displayError:function(err) {
		console.log("Error:" + err);
	    }
	    
	}
	pointData.loadData(fauxDisplay,null);
    },
    parseDataIconProps:function(props,line) {
	Utils.split(line??'',',',true,true).forEach(line2=>{
	    let toks = Utils.split(line2,":",true,true);
	    if(toks.length==2) {
		props[toks[0]] = toks[1];
	    }
	});
    },
    getDataIconShowing: function() {
	return this.attrs[ID_DATAICON_SHOWING];
    },
    setDataIconShowing: function(v) {
	this.attrs[ID_DATAICON_SHOWING] =v;
    },    


    makeDataIcons: function(pointData,data,markers,lines,props) {

	let cvrt=(v,dflt)=>{
	    if(!Utils.stringDefined(v)) return dflt;
	    return v;
	};


	//This recurses up the glyph tree
	let size=cvrt(this.getDataIconProperty(ID_DATAICON_SIZE),props.iconSize??100);
	let canvasWidth=parseFloat(cvrt(this.getDataIconProperty(ID_DATAICON_WIDTH),props.canvasWidth??100));
	let canvasHeight=parseFloat(cvrt(this.getDataIconProperty(ID_DATAICON_HEIGHT),props.canvasHeight??100));
	let selectedField=this.getDataIconProperty(ID_DATAICON_SELECTED_FIELD);

	if(!Utils.stringDefined(selectedField)) {
	    selectedField=this.getDataIconProperty(ID_DATAICON_INIT_FIELD);
	}
	let markerFields = this.getDataIconProperty(ID_DATAICON_FIELDS);
	let attrs = {};
	if(debugDataIcons)
	    console.log({size,canvasWidth,canvasHeight});
	if(selectedField && markerFields) {
	    Utils.split(markerFields,'\n',true,true).every(item=>{
		let toks = Utils.split(item,',',true,true);
		if(toks[0]!=selectedField) return true;
		for(let i=1;i<toks.length;i++) {
		    let toks2 = Utils.split(toks[i],"=",true,true);
		    attrs[toks2[0]] = toks2[1]??'';
		}
		return false;
	    });
	}

	lines.forEach(line=>{
	    line = line.trim();
	    if(line.startsWith('#')) return;
	    if(selectedField) {
		line = line.replace(/\${_field}/g,selectedField.replace(/ /g,''));
	    }

	    let extra = '';
	    ['scale','offset1','offset2'].forEach(a=>{
		if(attrs[a]) extra+= ' ' + a +'=' + attrs[a] +' ';
	    });
	    line = line.replace(/\${_extra}/g,extra);
	    let unit = '';
	    Object.keys(attrs).forEach(key=>{
		if(key=='unit') {
		    unit = attrs[key];
		    return;
		}
		if(key=='label') return;
		line = line.replaceAll("\${" + key+"}",attrs[key]);
	    });

	    //In case there wasn't a unit
//	    line = line.replaceAll(/\${unit}/g,'');
	    line = line.replaceAll(/\${icon}/g,this.getIcon());	    
	    props = Utils.clone({},
				props,{
				    glyphField:selectedField,
				    canvasWidth:canvasWidth,
				    canvasHeight: canvasHeight,
				    entryname: this.getName(),
				    unit:unit
				},attrs);
	    if(debugDataIcons)
		console.log('line:'+ line);
	    markers.push(new Glyph(this.display,1.0, data.getRecordFields(),data.getRecords(),props,line));
	});
	let cid = HU.getUniqueId("canvas_");
	let c = HU.tag("canvas",[ATTR_CLASS,"", ATTR_STYLE,"xdisplay:none;", 	
				 ATTR_WIDTH,canvasWidth,ATTR_HEIGHT,canvasHeight,ATTR_ID,cid]);

	let isShown = true;
	markers.forEach(marker=>{
	    if(!marker.okToShow()) {
		isShown=false;
	    }
	});


	$(document.body).append(c);
	let canvas = document.getElementById(cid);
	let ctx = canvas.getContext("2d");
	if(isShown &&props.fill) {
	    ctx.fillStyle=props.fill;
	    ctx.fillRect(0,0,canvasWidth,canvasHeight);
	}
	ctx.strokeStyle ="#000";
	ctx.fillStyle="#000";
	let pending = [];
	let records = data.getRecords();
	let numberCount = 0;
	let missingCount = 0;	
	markers.forEach(marker=>{
	    //if its an image glyph then the image might not be loaded so the call returns a
	    //isReady function that we keep checking until it is ready
	    let isReady =  marker.draw(props, canvas, ctx, 0,canvasHeight,{
		findNonNan:props.findNonNan,
		records:records,
		recordIndex:records.length-1,
		record:records[records.length-1]
	    });
	    if(isReady) pending.push(isReady);
	    //check for missing
	    if(!marker.isImage()) {
		numberCount++;
		if(marker.hadMissingValue()) {
		    missingCount++;
		}
	    }
	});

	if(numberCount>0 && numberCount==missingCount) {
	    isShown=false;
	}

	if(isShown && props.borderColor) {
	    ctx.strokeStyle = props.borderColor;
	    ctx.lineWidth=parseFloat(props.borderWidth??1);
	    let d = 0.5*ctx.lineWidth;
	    ctx.strokeRect(0+d,0+d,canvasWidth-d*2,canvasHeight-d*2);
	    ctx.strokeStyle = null;
	    ctx.lineWidth=1;
	}

	//Save the original style
	if(!this.getDataIconShowing()) {
	    //Check for the case where the style has been set with a data icon when we have the properties dialog up
	    if(!this.style?.externalGraphic?.startsWith('data')) {
		this.attrs[ID_DATAICON_ORIGINAL] = {};
		DATAICON_PROPERTIES.forEach(prop=>{
		    this.attrs[ID_DATAICON_ORIGINAL][prop] = this.style[prop];
		});
	    }
	} 
	this.setDataIconShowing(true);
	let finish = ()=>{
	    //Check for a race condition
	    if(!this.getDataIconShowing())  {
		return;
	    }

	    try {
		let img = canvas.toDataURL();
		if($('#testimg').length) 
		    $("#testimg").html(HU.tag(TAG_IMG,[ATTR_SRC,img]));
		canvas.remove();
		this.style.label=null;
		this.style.pointRadius=size;
		if(!isShown) {
		    this.style.pointRadius=0;
		}
		this.style.externalGraphic=img;
	    } catch(err) {
		console.error('Error',err);
		if(String(err).indexOf('insecure')>=0) {
		    alert('There was an error making the data icon.\nPerhaps one of the images is from an external server');
		
		}
	    }
	    if(records && records.length>0 && this.features&& this.getProperty(PROP_MOVE_TO_LATEST_LOCATION,null,true)) {
		let record = records[records.length-1];
		let p1 = MapUtils.createLonLat(record.getLongitude(),record.getLatitude())
		p1 = this.getMap().transformLLPoint(p1);
		p1= new OpenLayers.Geometry.Point(p1.lon, p1.lat);
		this.features.forEach(feature=>{
		    let geometry = feature.geometry;
		    if(geometry && Utils.isDefined(geometry.x)) {
			geometry.x=p1.x;
			geometry.y=p1.y;			
			geometry.clearBounds();
		    }
		});
	    }

	    this.applyStyle(this.style,true,true);		
	    this.display.redraw();
	};

	let check = () =>{
	    let allGood = true;
	    pending.every(p=>{
		if(!p()) {
		    allGood=false;
		    return false;
		}
		return true;
	    });
	    if(allGood) {
		finish();
	    }  else {
		setTimeout(check,100);
	    }
	};

	check();
    },

    setDownloadUrl:function(url) {
	this.downloadUrl =url;
    },

    setAttribute:function(property,value) {
	this.attrs[property] = value;
    },
    getAttribute:function(property,value,dflt) {
	if(!Utils.isDefined(this.attrs[property])) return dflt;
	return Utils.getProperty(this.attrs[property]);
    },


    getUseEntryLocation: function() {
	return this.attrs.useentrylocation;
    },
    setUseEntryLocation: function(v) {
	this.attrs.useentrylocation = v;
	return this;
    },
    getUseEntryName: function() {
	return this.attrs.useentryname;
    },
    setUseEntryName: function(v) {
	this.attrs.useentryname=v;
	return this;
    },
    getUseEntryLabel: function() {
	return this.attrs.useentrylabel;
    },    
    setUseEntryLabel: function(v) {
	this.attrs.useentrylabel =v;
	return this;
    },
    getMultiEntries:function() {
	if(!this.entries) return null;
	let exclude = {};
	if(this.getAttribute('excludes')) {
	    Utils.split(this.getAttribute('excludes'),'\n',true,true).forEach(id=>{
		exclude[id] = true;
	    });
	}
	return this.entries.filter(entry=>{
	    if(exclude[entry.getId()]) return false;
	    return true;
	});

    },
    showMultiEntries:function() {
	let _this = this;
	let entries = this.getMultiEntries();
	if(!entries) return;
	let html = '';
	let map = {};
	entries.forEach(entry=>{
	    map[entry.getId()] = entry;
	    let link = entry.getLink(null,true,['target','_entry']);
	    link = HU.div([ATTR_STYLE,'white-space:nowrap;max-width:180px;overflow-x:hidden;',ATTR_TITLE,entry.getName()], link);
	    let add = '';
	    if(MAP_TYPES.includes(entry.getType().getId())) {
		add = HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'add map','entryid',entry.getId(),'command',GLYPH_MAP],HU.getIconImage('fas fa-plus'));
	    } else if(entry.isPoint) {
		add = HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'add data','entryid',entry.getId(),'command',GLYPH_DATA],HU.getIconImage('fas fa-plus'));
	    } else if(entry.isGroup) {
		add = HU.span([ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'add multi entry','entryid',entry.getId(),'command',GLYPH_MULTIENTRY],HU.getIconImage('fas fa-plus'));
	    } else {
	    }		
	    if(add!='') {
		link = HU.leftRightTable(link,add);
	    }

	    html+=HU.div([ATTR_STYLE,HU.css('white-space','nowrap')],link);
	});
	if(html!='') {
	    html = HU.div([ATTR_CLASS,'ramadda-cleanscroll', ATTR_STYLE,'max-height:200px;overflow-y:auto;'], HU.div([ATTR_STYLE,'margin-right:10px;'],html));
	    this.jq('multientry').html(HU.b('Entries')+html);
	}
	this.jq('multientry').find('[command]').click(function(){
	    let command = $(this).attr('command');
	    let entry = map[$(this).attr('entryid')];
	    let glyphType = _this.display.getGlyphType(command);
	    let style = $.extend({},glyphType.getStyle());
	    let mapOptions = {
		type:command,
		entryType: entry.getType().getId(),
		entryId:entry.getId(),
		name:entry.getName(),
		icon:entry.getIconUrl()
	    }
	    if(command===GLYPH_MAP) {
		let mapGlyph = _this.display.handleNewFeature(null,style,mapOptions);
		mapGlyph.checkMapLayer();
	    } else if(command==GLYPH_DATA) {
		_this.display.createData(mapOptions);
	    } else if(command==GLYPH_MULTIENTRY) {
		let mapGlyph = _this.display.handleNewFeature(null,style,mapOptions);
		mapGlyph.addEntries(true);
	    }
	});
    },
    getMap: function() {
	return this.display.getMap();
    },
    changeOrder:function(toFront) {
	if(this.mapServerLayer) {
	    if(toFront)
		this.getMap().toFrontLayer(this.mapServerLayer);
	    else
		this.getMap().toBackLayer(this.mapServerLayer);		    
	    return;		
	}
	if(this.getImage()) {
	    if(toFront)
		this.getMap().toFrontLayer(this.getImage());
	    else
		this.getMap().toBackLayer(this.getImage());		    
	    return;		
	}
	if(this.features.length) {
	    if(toFront)
		Utils.toFront(this.display.getLayer().features, this.features,true);
	    else
		Utils.toBack(this.display.getLayer().features, this.features,true);
	}
    },	
    getId:function() {
	return this.id;
    },
    getFilterable: function() {
	return false;
//	return this.attrs.filterable??true;
    },
    getAllFeatures: function() {
	let features=[];
	if(this.features) features.push(...this.features);
	if(this.mapLayer) features.push(...this.mapLayer.features);
	return features;
    },
    getFeatures: function() {
	return this.features;
    },
    redraw:function() {
	if(this.getMapLayer()) {
	    ImdvUtils.scheduleRedraw(this.getMapLayer(),this);
	} else {
	    this.display.redraw(this);
	}
    },
    checkLineType:function(points) {
	if(this.attrs.lineType==LINETYPE_GREATCIRCLE || this.attrs.lineType==LINETYPE_CURVE) {
	    if(!MapUtils.loadTurf(()=>{this.checkLineType(points);})) {
		return;
	    }
	}

	if(!this.attrs.originalPoints) {
	    this.attrs.originalPoints = points??this.getPoints({});
	}
	let pts = points??this.attrs.originalPoints;
	if(!pts || pts.length==0) return;
	let newPts = [];
	let getPoints = f=>{
	    let p=[];
	    let coords = f.geometry.coordinates;
	    coords.forEach(pair=>{
		p.push(pair[1],pair[0]);
	    });
	    return p;
	};
	let latlon=(pts,i) =>{
	    return [pts[i+0], pts[i+1]];
	}
	isDraggable = true;
	if(this.attrs.lineType==LINETYPE_STEPPED) {
	    isDraggable = false;
	    let mid = (v1,v2)=>{
		return v1+(v2-v1)/2;
	    };
	    for(let i=0;i<pts.length-2;i+=2) {
		let [lat1,lon1] = latlon(pts,i);
		let [lat2,lon2] = latlon(pts,i+2);				
		newPts.push(lat1,lon1);
		newPts.push(lat1,mid(lon1,lon2));
		newPts.push(lat2,mid(lon1,lon2));		
		newPts.push(lat2,lon2);
	    }
	} else if(this.attrs.lineType==LINETYPE_GREATCIRCLE) {
	    isDraggable = false;
	    let options = {units: 'miles'};
	    for(let i=0;i<pts.length-2;i+=2) {
		let [lat1,lon1] = latlon(pts,i);
		let [lat2,lon2] = latlon(pts,i+2);				
		let start = turf.point([lon1,lat1]);
		let end = turf.point([lon2,lat2]);
		let circlePts =this.display.getTurfPoints(turf.greatCircle(start, end)); 
		circlePts.forEach(pair=>{
		    if(Array.isArray(pair)) {
			newPts.push(pair[1],pair[0]);
		    } else {
			newPts.push(pair);
		    }
		});
	    }

	} else if(this.attrs.lineType==LINETYPE_CURVE) {
	    isDraggable = false;
	    let tmp = [];
	    for(let i=0;i<pts.length;i+=2) {
		tmp.push([pts[i+1],pts[i]]);
	    }
	    let line = turf.lineString(tmp);	
	    newPts = getPoints(turf.bezierSpline(line));
	} else  {
	    newPts = pts;
	    this.attrs.originalPoints=null;
	}
	this.addLine(newPts, isDraggable);
    },

    addLine: function(pts,isDraggable) {
	let features=[];
	let stride = 2;
	if(pts.length>20)
	    stride=parseInt(pts.length/10);
	let type = 'OpenLayers.Geometry.LineString';
	let feature = this.display.makeFeature(this.getMap(),type,this.style,pts);
	feature.isDraggable =isDraggable;
	features.push(feature);
	if(this.attrs.addDots) {
	    let dotStyle  = {
		strokeWidth:Utils.isDefined(this.style.dotStrokeWidth)?
		    this.style.dotStrokeWidth:1,
		pointRadius:this.style.dotSize??3,
		strokeColor: this.style.dotStrokeColor||this.style.strokeColor,
		fillColor: this.style.dotFillColor||this.style.strokeColor,		
	    }
	    if(Utils.stringDefined(this.style.dotExternalGraphic)) {
		dotStyle.externalGraphic = this.style.dotExternalGraphic;
	    }
	    let addPoint= (lat,lon)=>{
		let feature = this.display.makeFeature(this.getMap(),'OpenLayers.Geometry.Point',dotStyle,
						       [lat,lon]);
		features.push(feature);
		feature.fixedStyle = true;
		MapUtils.setFeatureStyle(feature,dotStyle);
		feature.isDraggable = false;
	    }
	    addPoint(pts[0],pts[1]);
	    for(let i=2;i<pts.length-2;i+=stride) {
		addPoint(pts[i],pts[i+1]);
	    }
	    addPoint(pts[pts.length-2],pts[pts.length-1]);
	}
	this.addFeatures(features,true,true);
    },	

    clearFeatures: function() {
	this.display.removeFeatures(this.features);
	this.features = [];
    },
    addFeatures: function(features,andClear,addToDisplay) {
	if(andClear) this.clearFeatures();
	this.features.push(...features);
	features.forEach(feature=>{
	    feature.mapGlyph = this;   
	});

	if(addToDisplay) {
	    this.display.addFeatures(features);
	}
    },

    addFeature: function(feature,andClear,addToDisplay) {
	this.addFeatures([feature],andClear,addToDisplay);
    },
    handleKeyDown:function(event) {
	if(event.key=='o' || event.key=='O') {
	    if(this.isImage() && this.image) {
		let delta = event.key=='o'?-0.05:0.05;
		let op =parseFloat(Utils.isDefined(this.style.imageOpacity)?this.style.imageOpacity:1);
		op = Math.max(Math.min(op+delta,1),0);
		this.style.imageOpacity = op;
		this.image.setOpacity(op);
	    }
	    return;
	}
	if(event.key=='v') {
	    this.setVisible(!this.getVisible(),true);
	    return
	}
	if(event.key=='r' || event.key=='l' || event.key=='R' || event.key=='L') {
	    if(this.isImage() && this.image) {
		let delta = 0.5;
		if(event.key=='l') delta=-0.5;
		else if(event.key=='R') delta=5;
		else if(event.key=='L') delta=-5;
		this.setRotation(this.style.rotation +delta);
		this.unselect();
		this.select();
	    }
	}
    },
    getStyleFromTree: function(prop,dflt) {
	if(Utils.stringDefined(this.style[prop])) return this.style[prop];
	if(this.getParentGlyph()) return this.getParentGlyph().getStyleFromTree(prop,dflt);
	return dflt;
    },

    getStyle: function(applyMacros) {
	if(applyMacros) {
	    let tmpStyle = this.style??{};
	    if(Utils.stringDefined(tmpStyle.labelYOffset) || Utils.stringDefined(tmpStyle.labelXOffset)) {
		tmpStyle=Utils.clone(tmpStyle);
		let a = v=>{
		    v= String(v??'');
		    let r = tmpStyle.pointRadius;
		    if(isNaN(r)) r=0;
		    v = v.replace(/\${size}/g,r).replace(/\${size2}/g,r/2);
		    try {
			v = eval(v);
		    } catch(err) {
			console.log('error applying macro:' +err);
		    }
		    return v;
		}
		tmpStyle.labelXOffset = a(tmpStyle.labelXOffset);
		tmpStyle.labelYOffset = a(tmpStyle.labelYOffset);
	    }	
	    return tmpStyle;
	}
	return this.style;
    },
    panMapTo: function(andZoomIn) {
	if(this.isZoom()) {
	    if(this.attrs.mapCenter) {
		this.getMap().setCenter(this.attrs.mapCenter);
	    }
	    if(andZoomIn && Utils.isDefined(this.attrs.zoomLevel)) {
		this.getMap().setZoom(this.attrs.zoomLevel);
	    }
	    return;
	}
	let bounds;
	if(this.attrs.bounds) {
	    //wsen
	    let b = this.attrs.bounds;
	    bounds = MapUtils.createBounds(b[0],b[1],b[2],b[3]);
	    bounds = this.getMap().transformLLBounds(bounds);
	}
	if(!bounds) {
	    bounds = this.getBounds();
	}
	if(bounds) {
	    this.getMap().zoomToExtent(bounds);
	    if(bounds.getWidth()==0) andZoomIn = true;
	}
	if(andZoomIn) {
	    //The -1 is a flag to use the singlePointZoom
	    this.getMap().zoomTo(-1,true);
	}
    },
    getBounds: function() {
	let bounds = null;
	if(this.haveChildren()) {
	    this.applyChildren(child=>{bounds =  MapUtils.extendBounds(bounds,child.getBounds());});
	}
	if(this.features && this.features.length) {
	    bounds = MapUtils.extendBounds(bounds,this.getMap().getFeaturesBounds(this.features));
	}
	if(this.extraFeatures) {
	    bounds = MapUtils.extendBounds(bounds, this.getMap().getFeaturesBounds(this.extraFeatures));
	}

	if(this.isMapServer()) {
	    if(this.getDatacubeVariable() && Utils.isDefined(this.getDatacubeAttr('geospatial_lat_min'))) {
		let attrs = this.getDatacubeAttrs();
		bounds= MapUtils.createBounds(attrs.geospatial_lon_min, attrs.geospatial_lat_min, attrs.geospatial_lon_max, attrs.geospatial_lat_max);
		bounds= this.display.getMap().transformLLBounds(bounds);
	    }
	} else if(this.getMapLayer()) {
	    if(this.getMapLayer().getVisibility()) {
		bounds =  this.display.getMap().getFeaturesBounds(this.getMapLayer().features);
		if(!bounds) {
		    if(this.getMapLayer().maxExtent) {
			let e = this.getMapLayer().maxExtent;
			bounds = MapUtils.createBounds(e.left,e.bottom,e.right,e.top);
		    }
		}
	    }
	    if(this.imageLayers) {
		this.imageLayers.forEach(obj=>{
		    if(!obj.layer || !obj.layer.getVisibility()) return;
		    bounds = MapUtils.extendBounds(bounds,
						   this.getMap().getLayerVisibleExtent(obj.layer)||obj.layer.extent);
		});
	    }
	} else	if(this.displayInfo?.display) {
	    if(this.displayInfo.display.myFeatureLayer && (
		!Utils.isDefined(this.displayInfo.display.layerVisible) ||
		    this.displayInfo.display.layerVisible)) {
		bounds =  this.display.getMap().getFeaturesBounds(this.displayInfo.display.myFeatureLayer.features);
	    } else  if(this.displayInfo.display.pointBounds) {
		bounds= this.display.getMap().transformLLBounds(this.displayInfo.display.pointBounds);
	    }
	}

	let entries = this.getMultiEntries();
	if(!MapUtils.boundsDefined(bounds) && this.isMultiEntry() && entries) {
	    entries.forEach(entry=>{
		let b = null;
		if(entry.hasBounds()) {
		    b =   MapUtils.createBounds(entry.getWest(),entry.getSouth(),entry.getEast(), entry.getNorth());
		} else if(entry.hasLocation()) {
		    b =   MapUtils.createBounds(entry.getLongitude(),entry.getLatitude(),
						entry.getLongitude(),entry.getLatitude());
		} 
		if(b) {
		    bounds = MapUtils.extendBounds(bounds,b);
		}
	    });
	    if(bounds) {
		bounds =  this.display.getMap().transformLLBounds(bounds);
	    }
	}
	//Cache the bounds
	if(MapUtils.boundsDefined(bounds)) {
//	    console.log(this.getName() +' getBounds defined:', bounds);
	    this.attrs.lastBounds = bounds;
	} else if(this.attrs.lastBounds) {
//	    console.log(this.getName() +' using last bounds:',this.attrs.lastBounds);
	    return MapUtils.createBounds(this.attrs.lastBounds);
	} else {
//	    console.log(this.getName() +' no bounds');
	}
	return bounds;
    },


    collectFeatures: function(features) {
	if(this.haveChildren()) {
	    this.applyChildren(child=>{child.collectFeatures(features);});
	} else 	if(this.features.length) {
	    features.push(...this.features);
	} else if(this.getMapLayer()) {
	    let f = this.getMapLayer().features;
	    if(f)
		features.push(...f);
	}
    },
    getGeometry: function() {
	if(this.features.length>0) return this.features[0].geometry;
	else return null;
    },
    setName: function(name) {
	this.attrs.name = name;
    },
    getName: function() {
	return this.attrs.name||this.name;
    },
    setName: function(name) {
	this.attrs.name = name;
    },    
    getFeature: function() {
	if(this.features.length>0) return this.features[0];
	return null;
    },
    getFeatures: function() {
	return this.features;
    },    
    getType: function() {
	return this.type;
    },
    getWikiText:function() {
	return this.style.wikiText || this.getPopupText();
    },

    getPopupText: function() {
	let text = this.getPopupTextInner();
	if(text) text = text.replace(/\${_name}/g,this.getName());
	return text;
    },
    getPopupTextInner: function() {	
	if(Utils.stringDefined(this.style.popupText)) return this.style.popupText;
	if(this.getParentGlyph()) return  this.getParentGlyph().getPopupTextInner();
	return null;
    },
    getEntryId: function() {
	return this.attrs.entryId;
    },
    hasBounds:function() {
	if(this.isMapServer()) {
	    if(this.attrs.bounds) return true;
	    if(this.getDatacubeVariable() && Utils.isDefined(this.getDatacubeAttr('geospatial_lat_min'))) {
		return true;
	    }
	    return false;
	}

	return  !this.isFixed();
    },

    getLabel:function(opts) {
	opts = opts??{};
	let args = {
	    forLegend:false,
	    addDecorator:false,
	    addIcon:true,
	    simple:false
	}
	$.extend(args,opts);
	let name = this.getName();
	let label;
	let theLabel;
	if(Utils.stringDefined(name)) {
	    if(!args.forLegend && !args.simple)
		theLabel= this.getType()+': '+name;
	    else
		theLabel = name;
	} else if(this.isFixed()) {
	    theLabel = this.style.text;
	    if(theLabel && theLabel.length>15) theLabel = theLabel.substring(0,14)+'...'
	} else {
	    theLabel =  this.getType();
	}
	if(args.simple) {
	    return theLabel;
	}

	label = theLabel;
	let url = null;
	let glyphType = this.getGlyphType();
	let right = '';
	if(args.addDecorator) {
	    //For now don't add the decoration (the graphic indicator)
	    //right+=this.getDecoration(true);
	}

	if(glyphType) {
	    let icon = Utils.getStringDefined(this.getProperty('icon'),this.style.externalGraphic,this.attrs.icon,glyphType.getIcon());
	    if(icon.startsWith('data:')) icon = this.attrs.icon;
	    if(icon && icon.endsWith('blank.gif')) icon = glyphType.getIcon();
	    icon = HU.image(icon,[ATTR_WIDTH,'18px']);
	    if(url && args.forLegend)
		icon = HU.href(url,icon,['target','_entry']);
	    let showZoomTo = args.forLegend && this.hasBounds();
	    if(this.canHaveChildren()) {
		if(this.getProperty(PROP_LAYERS_ANIMATION_SHOW)) {
		    right+=SPACE+HU.span([ATTR_CLASS,CLASS_CLICKABLE,
					  ATTR_TITLE,'Play',
					  ATTR_ID,this.domId(PROP_LAYERS_ANIMATION_PLAY),
					  ID_GLYPH_ID,this.getId(),ATTR_BUTTON_COMMAND,PROP_LAYERS_ANIMATION_PLAY],
					 HU.getIconImage(icon_play,[],BUTTON_IMAGE_ATTRS));
		}

		/** Don't do this for now as we add a Step button to the legend 
		if(this.getProperty(PROP_LAYERS_STEP_SHOW)) {
		    right+=SPACE+HU.span([ATTR_CLASS,CLASS_CLICKABLE,
					  ATTR_TITLE,'Cycle visibility children. Shift-key: all visible; Meta-key: all hidden',
					  ID_GLYPH_ID,this.getId(),ATTR_BUTTON_COMMAND,PROP_LAYERS_STEP_SHOW],
					  HU.getIconImage('fas fa-arrows-spin',[],BUTTON_IMAGE_ATTRS));
		}
		**/
	    }

	    if(showZoomTo) {
		right+=SPACE+
		    HU.span([ATTR_CLASS,HU.classes(CLASS_CLICKABLE, CLASS_LEGEND_ITEM_VIEW),
			     ID_GLYPH_ID,this.getId(),
			     TITLE,'Click:Move to; Shift-click:Zoom in',],
//<i class="fa-regular fa-eye"></i>
			    HU.getIconImage('fas fa-eye',[],LEGEND_IMAGE_ATTRS));
	    }
	    if(args.addIcon) {
		if(args.forLegend && this.getProperty('showLegendBox')) {
		    let boxStyle = this.getLegendStyle(this.style);
		    label = HU.div([ATTR_CLASS,'imdv-legend-box',
				    ATTR_STYLE,boxStyle], '')  + label;
		} else {
		    label = HU.span([ATTR_STYLE,'margin-right:5px;'], icon)  + label;
		}
	    }
	}

	if(args.forLegend) {
	    let extra = this.getProperty('legendTooltip',null);
	    if(extra) extra = HU.div([],extra);
	    let typeLabel =this.getGlyphType().getName();
	    if(this.entry) {
		let type = this.entry.getType();
		if(type) {
		    typeLabel+=HU.div([],"Type:" + type.name);
		}
	    }
	    
	    let title = HU.b(HU.center(theLabel))+
		HU.div([],typeLabel) +
		(extra??'') +
		'Click to toggle visibility<br>Shift-click to select';
	    label = HU.div([ATTR_TITLE,title,ATTR_STYLE,HU.css('overflow-x','hidden','white-space','nowrap')], label);	    
	}
	if(right!='') {
	    right= HU.span([ATTR_STYLE,HU.css('white-space','nowrap')], right);
	}
	if(args.forLegend) {
	    let clazz = CLASS_LEGEND_LABEL;
	    label = HU.div([ATTR_CLASS,HU.classes(CLASS_CLICKABLE, clazz),
			    ID_GLYPH_ID,this.getId()],label);
	    return [label,right];
	}
	return label;
    },


    loadJson:function(jsonObject) {
	if(jsonObject.children) {
	    jsonObject.children.forEach(childJson=>{
		let child = this.display.makeGlyphFromJson(childJson);
		if(child) {
		    this.addChildGlyph(child);
		}
	    });
	}
    },
    removeChild: function(child) {
	if(this.children) {
	    this.children = Utils.removeItem(this.children, child);
	}
    },
    clearChildren:function() {
	if(this.children) {
	    let tmp = [...this.children];
	    tmp.forEach(child=>{
		child.doRemove();
	    });
	    this.children=[];
	}
    },

    applyChildren:function(func,descend) {
	if(!this.haveChildren()) return;
	this.getChildren().forEach(child=>{
	    func(child);
	    if(descend) child.applyChildren(func,descend);
	});
    },
    getChildren: function() {
	if(!this.children) {
	    this.children = [];
	}
	return this.children;
    },
    haveChildren: function() {
	if(this.children && this.children.length>0) {
	    return true;
	}    
	return false;
    },
    findGlyph:function(id) {
	if(id == this.getId()) return this;
	return ImdvUtils.findGlyph(this.getChildren(),id);
    },
    addChildGlyph: function(child) {
//	console.log("add child:" + child.getName());
	this.getChildren().push(child);
	child.setParentGlyph(this);
    },
    getParentGlyph: function() {
	return this.parentGlyph;
    },
    setParentGlyph: function(parent) {
	if(this.parentGlyph) this.parentGlyph.removeChild(this);
	this.parentGlyph = parent;
	if(parent) this.display.removeMapGlyph(this);
    },    
    getLegendVisible:function() {
	return this.attrs.legendVisible;
    },
    setLegendVisible:function(visible) {
	this.attrs.legendVisible = visible;
    },
    getFiltersVisible:function() {
	return this.attrs.filtersVisible;
    },
    setFiltersVisible:function(visible) {
	this.attrs.filtersVisible = visible;
    },    
    convertText:function(text) {
	text =text.replace(/\n *\*/g,'\n &bull;');
	text =text.replace(/^ *\*/g,'&bull;');
	text = text.replace(/\"/g,"\\").replace(/\n/g,'<br>');
	return text;
    },
    

    getLegendDiv:function() {
	return this.jq(ID_GLYPH_LEGEND);
    },
    setLayerLevel:function(level) {
	let setIndex= (layer) =>{
	    if(layer) {
		level++;
		layer.ramaddaLayerIndex=level;
	    }
	}	    
	setIndex(this.getMapLayer());
	if(this.imageLayers) {
	    this.imageLayers.forEach(obj=>{
		setIndex(obj.layer);
	    });
	}
	setIndex(this.mapServerLayer);
	setIndex(this.image);
	if(this.displayInfo?.display?.getMyMapLayers) {
	    this.displayInfo.display.getMyMapLayers().forEach(layer=>{
		setIndex(layer);
	    });
	}

	this.applyChildren(mapGlyph=>{level = mapGlyph.setLayerLevel(level);});
	return level;
    },
    findFilter:function(clazz) {
	if(this.getProperty('filter.showInMap',false)) {
	    return this.jq(ID_MAPFILTERS).find(clazz);
	}
	return this.findInLegend(clazz);
    },


    findInLegend:function(clazz) {
	if(clazz.startsWith('imdv-'))  clazz='.'+ clazz;
	let sel = '#' + this.domId(ID_GLYPH_LEGEND) +' '+clazz;
	if(this.topHeaderId)
	    sel+=', #' +this.topHeaderId+ ' ' + clazz;
	return  $(sel);
    },
    

    checkInMapLabel:function() {
	let label= this.jq(ID_INMAP_LABEL);
	if(this.getProperty('showLabelInMapWhenVisible',false)) {
	    if(this.getVisible()) label.show();
	    else label.hide();	    
	}

	if(this.getVisible()) label.removeClass('imdv-inmap-label-invisible');
	else  label.addClass('imdv-inmap-label-invisible');	
    },

    addInMapLabel:function() {
	let label= this.jq(ID_INMAP_LABEL);
	label.remove();
	let showLabel = this.getProperty('showLabelInMap',false);
	if(showLabel || this.getProperty('showLabelInMapWhenVisible',false)) {
	    let clazz = (showLabel?CLASS_CLICKABLE:'')+' imdv-inmap-label';
	    this.display.getLabels().append(HU.div([ATTR_ID,this.domId(ID_INMAP_LABEL),
						    ATTR_CLASS,clazz],
						   this.getProperty('inMapLabel')??this.getName()));
	    if(showLabel) {
		this.jq(ID_INMAP_LABEL).click(()=>{
		    this.setVisible(!this.getVisible(),true);
		});
	    }
	    this.checkInMapLabel();
	}
    },
    makeLegend:function(opts) {
	if(this.getProperty(PROP_DONT_SHOW_IN_LEGEND)) return '';
	this.addInMapLabel();
	opts = opts??{};
	let html = '';
	if(!this.display.getShowLegendShapes() && this.isShape()) {
	    return "";
	}
	let label =  this.getLabel({forLegend:true,addDecorator:true});
	let body = HU.div([ATTR_CLASS,CLASS_LEGEND_INNER],this.getLegendBody());

	if(this.imageLayers) {
	    let cbx='';
	    if(this.getMapLayer() && this.getMapLayer().features.length) {
		cbx+=HU.div([],HU.checkbox(Utils.getUniqueId(''),['imageid','main',
								  ATTR_CLASS,'imdv-imagelayer-checkbox'],
					   this.isImageLayerVisible({id:'main'}),
					   'Main Layer'));
	    }
	    this.imageLayerMap = {};
	    this.imageLayers.forEach(obj=>{
		this.imageLayerMap[obj.id] = obj;
		cbx+=HU.div([],HU.checkbox(Utils.getUniqueId(''),['imageid',obj.id,
								  ATTR_CLASS,'imdv-imagelayer-checkbox'],
					   this.isImageLayerVisible(obj),
					   obj.name));
	    });
	    body+=HU.div([ATTR_CLASS,CLASS_LEGEND_OFFSET],cbx);
	}




	if(this.haveChildren()) {
	    if(this.getProperty('showTextSearch',false)) {
		let input =  HU.input('',this.getProperty('searchtext')??'',[ATTR_STYLE,'width:100%',ATTR_PLACEHOLDER,'Search Text',ATTR_ID,this.domId('searchtext')]);
		body+=HU.div([ATTR_STYLE,'margin-bottom:4px;margin-left:8px;margin-right:8px;'],input);
	    }



	    let child="";
	    this.applyChildren(mapGlyph=>{
		let childHtml = mapGlyph.makeLegend(opts);
		if(childHtml) child+=childHtml;
	    });
	    body+=HU.div([ATTR_CLASS,CLASS_LEGEND_OFFSET],child);
	}

	let block = HU.toggleBlockNew("",body,this.getLegendVisible(),
				      {separate:true,headerStyle:'display:inline-block;',
				       extraAttributes:['map-glyph-id',this.getId()]});		
	if(opts.idToGlyph)
	    opts.idToGlyph[this.getId()] = this;
	let clazz = "";
	if(!this.getVisible()) {
	    clazz+=' ' + CLASS_LEGEND_LABEL_INVISIBLE;
	}
	if(this.highlighted) {
	    clazz+= ' ' + CLASS_LEGEND_LABEL_HIGHLIGHT;
	}

	html+=HU.open('div',[ATTR_ID,this.domId(ID_GLYPH_LEGEND),ID_GLYPH_ID,this.getId(),
			     ATTR_CLASS,HU.classes(CLASS_LEGEND_ITEM,clazz)]);
	html+=HU.div([ATTR_STYLE,'display: flex;'],
		     HU.div([ATTR_STYLE,'margin-right:4px;'],block.header)+
		     HU.div([ATTR_STYLE,'width:80%;'], label[0])+
		     HU.div([],label[1]));

	html+=HU.div([ATTR_CLASS,'imdv-legend-body'],block.body);
	html+=HU.close('div');
	return html;
    },

    getLegendStyle:function(style) {
	style = $.extend($.extend({},this.style),style??{});
	let s = '';
	let lineColor;
	let lineStyle;
	let lineWidth;
	if(Utils.stringDefined(style.fillPattern)) {
	    let svg = window.olGetSvgPattern(style.fillPattern,
					     style.strokeColor,style.fillColor);
	    s+='background-image: url(\''+ svg.url+'\');background-repeat: repeat;';
	}  else if(style.fillColor) {
	    s+=HU.css('background',style.fillColor);
	} 
	if(Utils.stringDefined(style.strokeColor)) 
	    lineColor = style.strokeColor;
	if(Utils.stringDefined(style.strokeWidth)) 
	    lineWidth = style.strokeWidth;
	if(Utils.stringDefined(style.strokeDashstyle)) {
	    if(['dot','dashdot'].includes(style.strokeDashstyle)) {
		lineStyle = "dotted";
	    } else  if(style.strokeDashstyle.indexOf("dash")>=0) {
		lineStyle = "dashed";
	    }
	}
	if(lineColor || lineColor||lineWidth) {
	    s+=HU.css('border',HU.getDimension(lineWidth??'1px')+ ' ' + (lineStyle??'solid') + ' ' +
		      (lineColor??'black'));
	}
	return s;
    },
    canEdit: function() {
	return !this.isEphemeral;
    },
    makeLegendButtons:function() {
	let buttons = this.display.makeGlyphButtons(this,this.canEdit());
	if(this.isMap() && this.getProperty('showFeaturesTable',true))  {
	    this.showFeatureTableId = HU.getUniqueId('btn');
	    if(buttons!=null) buttons = HU.space(1)+buttons;
	    buttons =  HU.span([ATTR_ID,this.showFeatureTableId,ATTR_TITLE,'Show features table',
				ATTR_CLASS,CLASS_CLICKABLE],
			       HU.getIconImage('fas fa-table',[],BUTTON_IMAGE_ATTRS)) +buttons;
	}

	if(this.isZoom()) {
	    if(buttons!=null) buttons = HU.space(1)+buttons;
	    this.setLocationId = HU.getUniqueId('setlocation');
	    buttons =  HU.span([ATTR_ID,this.setLocationId,ATTR_TITLE,'Set location',
				ATTR_CLASS,CLASS_CLICKABLE],
			       HU.getIconImage('fas fa-binoculars',[],BUTTON_IMAGE_ATTRS)) +buttons;
	}



	if(this.attrs.entryId) {
	    if(buttons!=null) buttons = HU.space(1)+buttons;
	    url = RamaddaUtils.getEntryUrl(this.attrs.entryId);
	    buttons = HU.href(url,HU.getIconImage('fas fa-home',[],BUTTON_IMAGE_ATTRS),['target','_entry',ATTR_TITLE,'View entry',
											ATTR_CLASS,CLASS_CLICKABLE]) +buttons;
	}
	return buttons;
    },



    getLegendBody:function() {
	let showInMapLegend=this.getProperty('showLegendInMap',false) && !this.display.getShowLegendInMap();
	let inMapLegend='';
	let body = '';
	
	let debug = this.getName()=='Alerts';
	let buttons = this.makeLegendButtons();


	if((!this.display.canEdit() && !this.getProperty('showButtons',true))) {
	    buttons = '';
	}

	if(buttons!='') {
	    body+=HU.div([ATTR_CLASS,CLASS_LEGEND_OFFSET],buttons);
	}	    
	if(this.getProperty(PROP_LAYERS_STEP_SHOW)) {
	    body += HU.div([ATTR_CLASS,CLASS_CLICKABLE +' ' + 'ramadda-button',
			    ATTR_TITLE,'Cycle visibility children. Shift-key: all visible; Meta-key: all hidden',
			    ID_GLYPH_ID,this.getId(),ATTR_BUTTON_COMMAND,PROP_LAYERS_STEP_SHOW],
			   HU.getIconImage('fas fa-arrows-spin',[],BUTTON_IMAGE_ATTRS));
	}



	//	    body+=HU.center(buttons);
	if(Utils.stringDefined(this.attrs[ID_LEGEND_TEXT])) {
	    let text = this.attrs[ID_LEGEND_TEXT].replace(/\n/g,'<br>');
	    body += HU.div([ATTR_CLASS,HU.classes(CLASS_LEGEND_OFFSET,'imdv-legend-text')],text);
	}

	let boxStyle = 'display:inline-block;width:14px;height:14px;margin-right:4px;';
	let legend = '';
	let styleLegend='';
	if(this.isMap()) {
	    if(!this.mapLoaded) {
		if(this.isVisible()) 
		    body += HU.div([ATTR_CLASS,CLASS_LEGEND_INNER],'Loading...');
		return body;
	    }

	    this.getStyleGroups().forEach((group,idx)=>{
		styleLegend+=HU.openTag(TAG_TABLE,[ATTR_WIDTH,'100%']);
		styleLegend+= HU.openTag(TAG_TR,[ATTR_TITLE,this.display.canEdit()?'Select style':'',
					       ATTR_CLASS,HU.classes(CLASS_IMDV_STYLEGROUP,(this.display.canEdit()?CLASS_CLICKABLE:'')),'index',idx]);
		let style = boxStyle + this.getLegendStyle(group.style);
		styleLegend+=HU.tag(TAG_TD,[ATTR_WIDTH,'18px'],
				    HU.div([ATTR_STYLE, style]));
		styleLegend +=HU.tag(TAG_TD,[], group.label);
		styleLegend+='</tr>';
		styleLegend+='</table>'
	    });


	    if(styleLegend!='') {
		styleLegend=HU.div([ATTR_ID,'glyphstyle_' + this.getId()], styleLegend);
		if(showInMapLegend)
		    inMapLegend+=styleLegend;
		else
		    legend+=styleLegend;
	    }

	}
	//true=>forLegend
	let mapStyleRules;
	if((mapStyleRules=this.getMapStyleRules(true)).length>0) {
	    let rulesLegend = '';
	    let lastProperty='';
	    let ruleCnt = 0;
	    mapStyleRules.forEach(rule=>{
		if(rule.type=='use') return;
		if(!Utils.stringDefined(rule.property)) return;
		let propOp = rule.property+rule.type;
		if(lastProperty!=propOp) {
		    if(rulesLegend!='') rulesLegend+='</table>';
		    let type = rule.type;
		    if(type=='==') type='=';
		    type = type.replace(/</g,'&lt;').replace(/>/g,'&gt;');
		    rulesLegend+= HU.b(this.makeLabel(rule.property,true))+' ' +type+'<br><table width=100%>\n';
		}
		lastProperty  = propOp;
		let label = rule.value;
		let info = this.getFeatureInfo(rule.property);
		if(info) label = info.getValueLabel(rule.value);

		label   = HU.span([ATTR_STYLE,'font-size:9pt;'],label);
		let lineWidth;
		let lineStyle;
		let lineColor;
		let svg;
		let havePattern = rule.style.indexOf('fillPattern')>=0;
		let fillColor,strokeColor;
		let styleObj = {};
		rule.style.split('\n').forEach(line=>{
		    line  = line.trim();
		    if(line=='') return;
		    let toks = line.split(':');
		    styleObj[toks[0]] = toks[1];
		});
		ruleCnt++;
		let style = boxStyle +this.getLegendStyle(styleObj);
		let legendContents = null;
		//If there is a pointRadius and a graphic then show the graphic in the legend
		if(Utils.isDefined(styleObj.pointRadius) && 
		   Utils.stringDefined(styleObj.externalGraphic??this.style.externalGraphic)) {
		    legendContents =
			HU.image(styleObj.externalGraphic??this.style.externalGraphic,[ATTR_WIDTH,'14px']);
		}
		let div=legendContents??HU.div([ATTR_CLASS,'circles-1',ATTR_STYLE,style]);
		let item = HU.tr([],
				 HU.td([ATTR_WIDTH,'16px'], div) +
				 HU.td([],label));
		rulesLegend+=HU.div([],item);
	    });
	    if(!ruleCnt) rulesLegend=null;
	    if(Utils.stringDefined(rulesLegend)) {
		rulesLegend+= '</table>';
		legend+=rulesLegend;
	    }
	}


	if(legend!='') {
	    if(showInMapLegend)
		inMapLegend+=legend;
	    else
		body+=HU.toggleBlock(HU.span([ATTR_TITLE,'Legend'],HU.getIconImage('fas fa-list',null,[ATTR_STYLE,HU.css("font-size","8pt")])),
				     /*'Legend',*/legend,true);
	}


	let showAnimation = false;
	if(this.isMapServer() && this.getDatacubeVariable() && this.getDatacubeVariable().dims && this.getDatacubeVariable().shape && this.getDatacubeAttr('time_coverage_start')) {
	    let v = this.getDatacubeVariable();
	    body+='Time: ' + HU.span([ATTR_ID,this.domId('time_current')],this.getCurrentTimeStep()??'')+'<br>';
	    let idx=v.dims.indexOf('time');
	    let numTimes = v.shape[idx];
	    let start =new Date(v.attrs.time_coverage_start);
	    let end =new Date(v.attrs.time_coverage_end);
	    let value = end.getTime();
	    if(this.attrs.currentTimeStep) {
		value = new Date(this.attrs.currentTimeStep).getTime();
	    }

	    let slider = 
		HU.div([ATTR_TITLE,'Set time','slider-min',start.getTime(),'slider-max',end.getTime(),'slider-value',value,
			ID,this.domId('time_slider'),ATTR_CLASS,'ramadda-slider',STYLE,HU.css('display','inline-block',ATTR_WIDTH,'90%')],'');

	    let anim = HU.join([
		['Settings','fa-cog','settings'],
		['Go to start','fa-backward','start'],
		['Step backward','fa-step-backward','stepbackward'],
		['Play','fa-play','play'],
		['Step forward','fa-step-forward','stepforward'],
		['Go to end','fa-forward','end']
	    ].map(t=>{
		return HU.span([ATTR_CLASS,HU.classes('imdv-time-anim',CLASS_CLICKABLE),
				ATTR_TITLE,t[0],'action',t[2]],HU.getIconImage(t[1]));
	    }),HU.space(2));

	    if(this.getProperty('showAnimation',true)) {
		showAnimation  = true;
		body+=HU.center(anim);
		body+=slider;
		let fstart = this.formatDate(start);
		let fend = this.formatDate(end);
		body+=HU.leftRightTable(HU.span([ATTR_ID,this.domId('time_min')],fstart),
					HU.span([ATTR_ID,this.domId('time_max')],fend));
	    }
	}



	if(this.isMapServer() || Utils.stringDefined(this.style.imageUrl) || this.imageLayers || this.image) {
	    let v = (this.imageLayers||this.isImage())?this.style.imageOpacity:this.style.opacity;
	    if(!Utils.isDefined(v)) v = 1;
	    if(showAnimation)
		body+='Opacity:';
	    body += 
		HU.center(
		    HU.div([ATTR_TITLE,'Set image opacity','slider-min',0,'slider-max',1,'slider-value',v,
			    ID,this.domId('image_opacity_slider'),ATTR_CLASS,'ramadda-slider',STYLE,HU.css('display','inline-block',ATTR_WIDTH,'90%')],''));
	}

	if(this.display.canEdit() && (this.image || Utils.stringDefined(this.style.imageUrl))) {
/*
	    body+='Rotation:';
	    body += HU.center(
		HU.div([ATTR_TITLE,'Set image rotation','slider-min',-360,'slider-max',360,'slider-value',this.style.rotation??0,
		ID,this.domId('image_rotation_slider'),ATTR_CLASS,'ramadda-slider',STYLE,HU.css('display','inline-block',ATTR_WIDTH,'90%')],''));
		*/
	}

	let item  = (content,checkInMap,addDecoration) => {
	    if(checkInMap && showInMapLegend) {
		if(addDecoration && Utils.stringDefined(content)) {
		    content = HU.hbox([this.getDecoration(true),content]);
		}
		inMapLegend+=HU.div([ATTR_STYLE,'max-width:200px'],content);
	    } else {
		if(Utils.stringDefined(content)) {	
		    body+=HU.div([ATTR_CLASS,'imdv-legend-body-item'], content);
		}
	    }
	};


	let colorTableLegend ='';
	body+=HU.div([ATTR_ID,this.domId('legendcolortableprops')]);
	colorTableLegend+=HU.div([ATTR_ID,this.domId('legendcolortable_fill')]);
	colorTableLegend+=HU.div([ATTR_ID,this.domId('legendcolortable_stroke')]);	
	colorTableLegend+=HU.div([ATTR_ID,this.domId(ID_MAPLEGEND)]);
	if(showInMapLegend)
	    inMapLegend+=colorTableLegend;
	else
	    body+=colorTableLegend;

	//Put the placeholder here for map filters
	if(this.getProperty('filter.showInMap',false)) {
	    this.jq(ID_MAPFILTERS_OUTER).remove();
	    let label = HU.b(this.getLabel({simple:true}));
	    let inMap=HU.div([ATTR_ID,this.domId(ID_MAPFILTERS_OUTER),ATTR_STYLE,HU.css('background','#fff','position','absolute','top','10px','left','50px','padding','5px'),ATTR_CLASS,'ramadda-popup'],
			     label+HU.div([ATTR_ID,this.domId(ID_MAPFILTERS)]));
	    this.display.jq(ID_MAP_CONTAINER).append(inMap);
	    this.jq(ID_MAPFILTERS_OUTER).draggable();
	} else {
	    body+=HU.div([ATTR_ID,this.domId(ID_MAPFILTERS)]);
	}

	if(this.type==GLYPH_LABEL && this.style.label) {
	    item(this.style.label.replace(/\"/g,"\\"));
	}
	if(this.getProperty('showMeasures',true) && !this.isIsoline()) {
	    let distances = this.display.getDistances(this.getGeometry(),this.getType());
	    item(distances,true,true);
	}
	if(this.isMultiEntry()) {
//	    item(HU.div([ATTR_ID,this.domId('multientry')]));
	}

	if(this.isShape()) {
	    item('',true,true);
	}
	if(Utils.stringDefined(this.style.imageUrl)) {
	    let filter = this.getStyleFromTree('imagefilter');
	    item(HU.center(HU.href(this.style.imageUrl,HU.image(this.style.imageUrl,[ATTR_STYLE,HU.css('margin-bottom','4px','border','1px solid #ccc',ATTR_WIDTH,'150px','filter',filter??'')]),['target','_image'])));
	}
	if(Utils.stringDefined(this.style.legendUrl)) {
	    item(HU.center(HU.href(this.style.legendUrl,HU.image(this.style.legendUrl,[ATTR_STYLE,HU.css('margin-bottom','4px','border','1px solid #ccc',ATTR_WIDTH,'100%')]),['target','_image'])));
	}


	if(this.isRoute()) {
	    if(this.attrs.instructions && this.attrs.instructions.length>0) {
		let instr = '';
		this.attrs.instructions.forEach(step=>{
		    let title = '';
		    let attrs = [];
		    if(step.lat) {
			attrs.push(ATTR_TITLE,'Click to view',ATTR_CLASS,HU.classes('imdv-route-step',CLASS_CLICKABLE),
				   'lat',step.lat,
				   'lon',step.lon);
		    } else {
			attrs.push(ATTR_CLASS,'imdv-route-step');
		    }
		    instr+=HU.div(attrs, step.instr);
		});
		body+=HU.center(HU.b('Directions')) +
		    HU.div([ATTR_STYLE,'max-height:200px;overflow-y:auto;'],instr);
	    }
	}
	




	this.jq('maplegend').remove();
	if(inMapLegend!='') {
	    inMapLegend=
		HU.div([ATTR_TITLE,this.getName(),ATTR_STYLE,'white-space:nowrap;max-width:150px;overflow-x:hidden'],HU.b(this.getName())) +
		inMapLegend;

	    inMapLegend = HU.div([ATTR_STYLE,'border-bottom:var(--basic-border);padding:4px;',ATTR_ID,this.domId('maplegend')], inMapLegend);
	    this.display.addToMapLegend(this,inMapLegend);
	}
	



	return body;
    },
    canDrop: function() {
	if(this.getParentGlyph()) {
	    if(!this.isGroup() && !this.getParentGlyph().isGroup()) {
		return false;
	    }
	} 
	return true;
    },

    canDrag: function() {
	if(this.getParentGlyph() && !this.getParentGlyph().isGroup()) {
	    return false;
	}
	return true;
    },
    
    initLegend:function() {
	let _this = this;
	if(this.canHaveChildren()) {
	    if(this.getProperty(PROP_LAYERS_ANIMATION_SHOW)) {
		this.jq(PROP_LAYERS_ANIMATION_PLAY).click(()=>{
		    this.checkLayersAnimation();
		});
	    }
	    this.checkLayersAnimation();
	}	    


	let steps = this.getLegendDiv().find('.imdv-route-step');
	steps.click(function(){
	    let lon = $(this).attr('lon');
	    let lat = $(this).attr('lat');
	    if(!Utils.isDefined(lat)) return;
	    steps.removeClass('imdv-route-step-on');
	    $(this).addClass('imdv-route-step-on');
	    if(_this.stepMarker) {
		_this.display.removeFeatures([_this.stepMarker]);
	    }

	    _this.getMap().setCenter(MapUtils.createLonLat(lon,lat));
	    _this.stepMarker = _this.display.makeFeature(_this.getMap(),'OpenLayers.Geometry.Point',
							 {externalGraphic:'/emojis/1f699.png',
							  pointRadius:12},
							[lat,lon]);
		
	    _this.display.addFeatures([_this.stepMarker]);
	});


	if(this.imageLayers) {
	    this.getLegendDiv().find('.imdv-imagelayer-checkbox').change(function() {
		let visible = $(this).is(':checked');
		let id = $(this).attr('imageid');
		let obj = _this.imageLayerMap[id]??{id:id};
		_this.setImageLayerVisible(obj,visible);
	    });
	}


	if(this.display.canEdit()) {
	    let label = this.getLegendDiv().find('.' + CLASS_LEGEND_LABEL);
	    //Set the last dropped time so we don't also handle this as a setVisibility click
	    let notify = ()=>{_this.display.setLastDroppedTime(new Date());};
	    if(this.canDrag()) {
		this.getLegendDiv().draggable({
		    handle:label,
		    cursor: "crosshair",
		    start: notify,
		    drag: notify,
		    stop: notify,
		    containment:this.display.domId(ID_LEGEND),
		    revert: true
		});
	    }
	    if(this.canDrop()) {
		this.display.makeLegendDroppable(this,label,notify);
	    } 
	    let items = this.jq(ID_LEGEND).find('.' + CLASS_LEGEND_LABEL);
	    let rows = jqid('glyphstyle_'+this.getId()).find('.' + CLASS_IMDV_STYLEGROUP);

	    rows.click(function() {
		if($(this).hasClass(CLASS_IMDV_STYLEGROUP_SELECTED)) {
		    $(this).removeClass(CLASS_IMDV_STYLEGROUP_SELECTED);
		    _this.selectedStyleGroup = null;
		    return;
		}
		rows.removeClass(CLASS_IMDV_STYLEGROUP_SELECTED);
		$(this).addClass(CLASS_IMDV_STYLEGROUP_SELECTED);
		_this.selectedStyleGroup = _this.getStyleGroups()[$(this).attr('index')];

	    });
	}
	if(this.isMultiEntry() && this.entries) {
	    this.showMultiEntries();
	}
	if(this.setLocationId) {
	    jqid(this.setLocationId).click(()=> {
		this.display.setZoomOptions(this.attrs);
	    });

	}

	if(this.showFeatureTableId) {
	    $('#'+ this.showFeatureTableId).click(function() {
		_this.showFeaturesTable($(this));
	    });
	}

	let setRotation = (event,ui) =>{
	    this.setRotation(ui.value);
	}
	let setOpacity = (event,ui) =>{
	    if(this.isMapServer())
		this.style.opacity = ui.value;
	    else if(this.image || this.imageLayers) {
		this.style.imageOpacity = ui.value;
		if(this.image) {
		    this.image.setOpacity(this.style.imageOpacity);
		}
		if(this.imageLayers)
		    this.imageLayers.forEach(obj=>{
			if(obj.layer)
			    obj.layer.setOpacity(this.style.imageOpacity);
		    });
	    }
	    this.applyStyle(this.style);
	}

	let getSliderTime=(value)=>{
	    return new Date(parseFloat(value));
	}
	let getStep = ()=>{
	    let min =  +this.jq('time_slider').attr('slider-min');
	    let max= +this.jq('time_slider').attr('slider-max');
	    let temp = this.getDatacubeAttr('temporal_resolution');
	    let msPerDay = 1000*60*60*24;
	    if(temp) {
		let match = temp.match(/(\d+)D/);
		if(match) {
		    return +match[1]*msPerDay;
		}
	    }
	    return msPerDay;
	}	    
	let timeSliderStop=v=>{
	    let current = getSliderTime(v);
	    let s = current.format('isoDate');
	    this.jq('time_current').html(s);
	    this.attrs.currentTimeStep = current.getTime();
	    if(this.mapServerLayer) {
		this.mapServerLayer.url = this.getMapServerUrl();
		this.getMapServerLayer().setVisibility(false);
		this.getMapServerLayer().setVisibility(true);
		ImdvUtils.scheduleRedraw(this.getMapServerLayer());
	    }
	}


	this.getLegendDiv().find('.imdv-time-anim').click(function() {
	    let action = $(this).attr('action');
	    let slider=	_this.jq('time_slider');
	    let current = +slider.slider('value');
	    let min = +slider.attr('slider-min');
	    let max = +slider.attr('slider-max');	    
	    let step = +slider.slider('option','step');
	    let change = (v)=>{
		v = Math.min(max,Math.max(min,v));
		slider.slider('value',v);
		timeSliderStop(v);
	    }

	    switch(action) {
	    case 'play':
		if(_this.timeAnimationTimeout)
		    clearTimeout(_this.timeAnimationTimeout);
		_this.timeAnimationTimeout=null;
		if(_this.timeAnimationRunning) {
		    $(this).html(HU.getIconImage(icon_play));
		} else {
		    $(this).html(HU.getIconImage(icon_stop));
		    let stepTime = () =>{
			let current = +slider.slider('value');
			current = current+(_this.attrs.timeAnimationStep??1)*step;
			change(current);
			//			console.log("current time: " +new Date(current) +' step:' + _this.attrs.timeAnimationStep);
			if(current>=max) {
			    $(this).html(HU.getIconImage(icon_play));
			    _this.timeAnimationRunning = false;
			    return
			}
			_this.timeAnimationTimeout=setTimeout(stepTime,_this.attrs.timeAnimationPause??4000);
		    }
		    stepTime();
		}
		_this.timeAnimationRunning = !_this.timeAnimationRunning;
		break;
	    case 'start': 
		change(min);
		break;
	    case 'end': 
		change(max);
		break;		
	    case 'stepforward': 
		change(current+step);
		break;
	    case 'stepbackward': 
		change(current-step);
		break;		
	    case 'settings':
		let html = HU.formTable();

		html+=HU.formEntry('Time Pause:', HU.input("",_this.attrs.timeAnimationPause??4000,
							   [ATTR_ID,_this.domId('timeanimation_pause'),'size','4']) +' (ms)');
		html+=HU.formEntry('Time Step:', HU.input("",_this.attrs.timeAnimationStep??1,
							  [ATTR_ID,_this.domId('timeanimation_step'),'size','4']) +' Time steps to skip');		
		html+='</table>';

		let buttons = HU.buttons([
		    HU.div([ATTR_CLASS,'ramadda-button-ok ramadda-button-apply display-button'], 'Apply'),
		    HU.div([ATTR_CLASS,'ramadda-button-ok display-button'], 'OK'),
		    HU.div([ATTR_CLASS,'ramadda-button-cancel display-button'], 'Cancel')]);
		html+=buttons;
		html = HU.div([ATTR_STYLE,'margin:6px;'], html);
		let dialog = HU.makeDialog({content:html,title:'Time Animation Settings',draggable:true,header:true,my:"left top",at:"left bottom",anchor:$(this)});
		
		dialog.find('.display-button').button().click(function() {
		    if($(this).hasClass('ramadda-button-ok')) {
			_this.attrs.timeAnimationPause = parseFloat(_this.jq('timeanimation_pause').val());
			_this.attrs.timeAnimationStep = parseFloat(_this.jq('timeanimation_step').val());
			if($(this).hasClass('ramadda-button-apply')) return;
		    }
		    dialog.remove();
		});

		break
	    }
	});

	this.jq('time_slider').slider({
	    min: +this.jq('time_slider').attr('slider-min'),
	    max: +this.jq('time_slider').attr('slider-max'),
	    step:getStep(),
	    value:+this.jq('time_slider').attr('slider-value'),
	    slide: ( event, ui )=> {
		let current = getSliderTime(ui.value);
		this.jq('time_current').html(current.format('isoDate'));
	    },
	    stop: ( event, ui )=> {
		timeSliderStop(ui.value);
	    }});

	this.jq('image_rotation_slider').slider({
	    min: -360,
	    max: 360,
	    step:1,
	    value:this.jq('image_rotation_slider').attr('slider-value'),
	    slide:function(event,ui) {
		setRotation(event,ui);
	    },
	    stop: function( event, ui ) {
		setRotation(event,ui);
	    }});


	this.jq('image_opacity_slider').slider({		
	    min: 0,
	    max: 1,
	    step:0.01,
	    value:this.jq('image_opacity_slider').attr('slider-value'),
	    slide:function(event,ui) {
		setOpacity(event,ui);
	    },
	    stop: function( event, ui ) {
		setOpacity(event,ui);
	    }});
	
	if(this.haveChildren()) {
	    this.jq('searchtext').change(function(){
		let text=$(this).val();
		_this.setProperty('searchtext', text);
		_this.applyChildren(child=>{
		    child.applyFeatureFilters();
		},true);
	    });
	}


	if(!this.isGroup()) {
	    this.makeFeatureFilters();
	}
	if(this.isMap() && this.mapLoaded) {
	    let addColor= (obj,prefix, strings) => {
		if(obj && Utils.stringDefined(obj.property)) {
		    let div = this.getColorTableDisplay(obj.colorTable,obj.min,obj.max,true,obj.isEnumeration, strings,obj.stringValues);
		    let html = HU.b(HU.center(this.makeLabel(obj.property,true)));
		    if(obj.isEnumeration) {
			let maxHeight = this.getProperty('mapLegendHeight','150px');
			html+='\n';
			html+=HU.div([ATTR_STYLE,'max-height:' + maxHeight+';overflow-y:auto;'],div);
		    } else {
			html+=HU.center(div);
		    }

		    this.jq('legendcolortable_'+prefix.toLowerCase()).html(html);
		    this.initColorTableDots(obj,this.jq('legendcolortable_'+prefix.toLowerCase()));

		    if(obj.isEnumeration) {
			if(!this.extraFilter) this.extraFilter = {};
			let slices =jqid(this.domId('legendcolortable_'+ prefix.toLowerCase())).find('.display-colortable-slice'); 
			slices.css('cursor','pointer');
			slices.click(function() {
			    let ct = Utils.ColorTables[obj.colorTable];
			    let searchId = HU.getUniqueId('');
			    let html = HU.center(HU.div([ATTR_ID,searchId]));
			    html += Utils.getColorTableDisplay(ct, 0,0, {
				tooltips:strings,
				showColorTableDots:true,
				horizontal:false,
				showRange: false,
			    });
			    html = HU.div([ATTR_STYLE,'min-width:400px;max-width:400px;max-height:200px;overflow-y:auto;margin:2px;'], html);
			    let dialog = HU.makeDialog({content:html,
							title:HU.div([ATTR_STYLE,'margin-left:20px;margin-right:20px;'], _this.makeLabel(obj.property,true)+' Legend'),
							header:true,
							my:"left top",at:"left bottom",
							draggable:true,anchor:$(this)});
			    HU.initPageSearch('.display-colortable-dot-item',null,'Search',false,{target:'#'+ searchId}); 

			    _this.initColorTableDots(obj, dialog);
			});
		    }
		}	
	    };

	    let ctProps = [];
	    this.getFeatureInfoList().forEach(info=>{
		if(!info.isColorTableSelect()) return;
		ctProps.push(info);
	    });

	    if(ctProps.length>1) {
		let menu = HU.select('',[ATTR_ID,this.domId('colortableproperty')],
				     ctProps.map(info=>{return {
					 value:info.id,label:info.getLabel()}}),this.attrs.fillColorBy.property);
		this.jq('legendcolortableprops').html(HU.b('Color by: ') + menu);
		this.jq('colortableproperty').change(()=>{
		    let val = this.jq('colortableproperty').val();
		    let info = this.getFeatureInfo(val);
		    if(!info) return;
		    $.extend(this.attrs.fillColorBy,{
			property:info.id,
			min:info.min,
			max:info.max});
		    this.applyMapStyle();
		    this.display.makeLegend();
		});
	    }
	    if(this.getProperty('showColorTableLegend',true)) {
		addColor(this.attrs.fillColorBy,'Fill',this.fillStrings);
		addColor(this.attrs.strokeColorBy,'Stroke',this.strokeStrings);
	    }
	}	
	this.applyChildren(mapGlyph=>{mapGlyph.initLegend();});
    },

    convertPopupText:function(text) {
	if(this.getImage()) {
	    text = text.replace(/\${image}/g,HU.image(this.style.imageUrl,[ATTR_WIDTH,'200px']));
	}
	return text;
    },
    

    canHaveChildren:function() {
	return this.isGroup() || this.isMultiEntry();
    },
    isMarker:function() {
	return this.getType() ==GLYPH_MARKER;
    },
    isGroup:function() {
	return this.getType() ==GLYPH_GROUP;
    },
    isZoom:function() {
	return this.getType() ==GLYPH_ZOOM;
    },    
    isEntry:function() {
	return this.getType() ==GLYPH_ENTRY;
    },
    loadEntry: function() {
	if(!this.attrs.entryId) return;
	let callback = (entry)=>{
	    this.setEntry(entry);
	};
	getRamadda().getEntry(this.attrs.entryId, callback);
    },

    setEntry:function(entry) {		
	this.entry = entry;
	if(!this.isEntry()) return;
	//the mapglyphs are defined by the type
	this.putTransientProperty("mapglyphs", entry.mapglyphs);
	if(this.getUseEntryName()) 
	    this.setName(entry.getName());
	if(this.getUseEntryLabel())
	    this.style.label= entry.getName();
	if(this.getUseEntryLocation() && entry.hasLocation()) {
	    let feature = this.display.makeFeature(this.getMap(),"OpenLayers.Geometry.Point", this.style,
						   [entry.getLatitude(), entry.getLongitude()]);
	    MapUtils.setFeatureStyle(feature, this.style);
	    this.addFeature(feature,true,true);
	}

	this.applyDataIcon();
	this.applyMapStyle();
	this.display.redraw(this);
	this.display.makeLegend();
	//And call getBounds so the bounds object gets cached for later use on reload
	this.getBounds();
    },
    isPolygon:function() {
	return this.type==GLYPH_POLYLINE ||
	    this.type==GLYPH_POLYGON ||
	    this.type==GLYPH_FREEHAND_CLOSED ||
	    this.type==GLYPH_FREEHAND;
    },
    isImage:function() {
	return this.getType() ==GLYPH_IMAGE;
    },    
    isMap:function() {
	return this.getType()==GLYPH_MAP;
    },
    isIsoline:function() {
	return this.getType()==GLYPH_ISOLINE;
    },    
    isRoute:function() {
	return this.getType()==GLYPH_ROUTE;
    },    
    isRings:function() {
	return this.getType()==GLYPH_RINGS;
    },    
    isMapServer:function() {
	return this.getType()==GLYPH_MAPSERVER;
    },    
    isMultiEntry:function() {
	return this.getType()==GLYPH_MULTIENTRY;
    },
    getShowDataIcons:function() {
	if(this.attrs[ID_SHOWDATAICONS] ===true)
	    this.attrs[ID_SHOWDATAICONS] = 'yes';
	else if(this.attrs[ID_SHOWDATAICONS] ===false)
	    this.attrs[ID_SHOWDATAICONS] = 'no';	
	if(this.attrs[ID_SHOWDATAICONS] ==='yes') return true;
	if(this.attrs[ID_SHOWDATAICONS] ==='no') return false;	
	if(this.getParentGlyph()) {
	    return this.getParentGlyph().getShowDataIcons();
	}
	return false;
    },
    setShowDataIcons:function(v) {
	this.attrs[ID_SHOWDATAICONS] = v;
    },
    setMapServerUrl:function(url,wmsLayer,legendUrl,predefined,mapOptions) {
//	console.log('xxx',url);
	this.style.legendUrl = legendUrl;
	this.attrs.mapServerUrl = url;
	this.attrs.wmsLayer = wmsLayer;
	this.attrs.predefinedLayer = predefined;
	this.mapServerOptions = mapOptions;

	if(Utils.stringDefined(predefined)) {
	    if(!Utils.stringDefined(this.attrs.name)) {
		let mapLayer = RAMADDA_MAP_LAYERS_MAP[predefined];
		if(mapLayer) {
		    this.attrs.name = mapLayer.name;
		    this.style.legendUrl = mapLayer.opts.legend;
		    if(Utils.stringDefined(mapLayer.opts.attribution) &&
		       !Utils.stringDefined(this.attrs[ID_LEGEND_TEXT])) {
			this.attrs[ID_LEGEND_TEXT] = mapLayer.opts.attribution;
		    }
		}
	    }
	} else {
	    if(!Utils.stringDefined(wmsLayer)) {
		if(url.match('&request=GetMap')) {
		    try {
			let _url = new URL(url);
			url = _url.protocol+'//' + _url.host +_url.pathname;
			wmsLayer = _url.searchParams.get('layers');
		    } catch(err) {
			console.log(err);
		    }
		}
	    }
	    if(!Utils.stringDefined(this.attrs.name)) {
		let _url = new URL(url);
		this.attrs.name = _url.hostname;
	    }
	}



    },
    getAttributes: function() {
	return this.attrs;
    },
    getCanSelect:function() {
	if(!Utils.isDefined(this.attrs.canSelect)) return true;
	return this.attrs.canSelect;
    },
    setMapLayer:function(mapLayer) {
	this.mapLayer = mapLayer;
	if(mapLayer) {
	    mapLayer.canSelect=this.getCanSelect();
	    mapLayer.mapGlyph = this;
	    mapLayer.textGetter = (feature)=>{
		let text  = this.getPopupText();
		if(text=='none') return null;
		if(!Utils.stringDefined(text)) text = '${default}';
		if(!feature.attributes) return null;
		return this.applyMacros(text, feature.attributes);
	    };
	}
    },
    getMapLayer: function() {
	return this.mapLayer;
    },
    setMapServerLayer:function(mapLayer) {
	this.mapServerLayer = mapLayer;
	if(mapLayer)
	    mapLayer.mapGlyph = this;
    },
    getMapServerLayer: function() {
	return this.mapServerLayer;
    },    
    checkMapLayer:function(andZoom,force) {
	//Only create the map if we're visible
	if(!this.isMap() || !this.isVisible()) return;
	if(this.mapLayer!=null && force) {
	    this.display.getMap().removeLayer(this.mapLayer);
	    this.mapLayer = null;
	}


	if(this.mapLayer==null) {
	    if(!Utils.isDefined(andZoom)) {
		//Not sure why we do this
		//		andZoom = true;
	    }
	    if(this.attrs.entryType=='geo_imdv') {
		this.dontSaveChildren=true;
		if(this.mapLoaded) return;
		let url =Ramadda.getUrl("/entry/get?entryid=" + this.attrs.entryId+"&fileinline=true");
		let finish = (data)=>{
		    this.mapLoaded = true;
		    this.makeLegend();
		};
		this.display.loadIMDVUrl(url,finish,this);
		return
	    }
	    this.setMapLayer(this.display.createMapLayer(this,this.attrs,this.style,andZoom));
	    this.applyMapStyle();
	}
    },
    getMapServerUrl:function() {
	let url=this.attrs.mapServerUrl;
	//Convert malformed TMS url
	url = url.replace(/\/{/g,"/${");
	if(this.getDatacubeVariable()) {
	    let variable = this.getDatacubeVariable();
	    url = url.replace(/\{colorbar\}/,variable.colorBarName);
	    url = url.replace(/\{vmin\}/,variable.colorBarMin);
	    url = url.replace(/\{vmax\}/,variable.colorBarMax);	    	    
	    if(variable.attrs.time_coverage_start) {
		let time = this.getCurrentTimeStep();
		url = url.replace(/\{time\}/,encodeURIComponent(time));
	    }
	}
	return url;
    },

    getDatacubeVariable:function() {
	return  this.attrs.variable;
    },
    getDatacubeAttrs:function() {
	return this.getDatacubeVariable()?.attrs;
    },
    getDatacubeAttr:function(attr) {
	let attrs =  this.getDatacubeAttrs();
	return attrs?attrs[attr]:null;
    },    
    getCurrentTimeStep:function() {
	if(Utils.isDefined(this.attrs.currentTimeStep)) {
	    return  this.formatDate(new Date(this.attrs.currentTimeStep));
	}
	if(!this.getDatacubeAttr('time_coverage_end')) return null;		
	return this.formatDate(new Date(this.getDatacubeAttr('time_coverage_end')));
    },

    formatDate: function(date) {
	return date.format('isoDate');
    },
    createMapServer:function() {
	this.mapServerLayer =  this.display.getMap().createXYZLayer(this.getName(), this.getMapServerUrl());
    },
    
    checkMapServer:function(andZoom) {
	if(!this.isMapServer()) return;
	if(this.mapServerLayer==null) {
	    let url=this.attrs.mapServerUrl;
	    let wmsLayer=this.attrs.wmsLayer;
	    if(Utils.stringDefined(wmsLayer)) {
		this.mapServerLayer = MapUtils.createLayerWMS(this.getName(), url, {
		    layers: wmsLayer,
		    format: "image/png",
		    isBaseLayer: false,
		    srs: "epsg:4326",
		    transparent: true
		}, {
		    opacity:1.0
		});
	    } else if(Utils.stringDefined(url)) {
		this.createMapServer();
	    } else if(Utils.stringDefined(this.attrs.predefinedLayer)) {
		let mapLayer = RAMADDA_MAP_LAYERS_MAP[this.attrs.predefinedLayer];
		if(mapLayer) {
		    this.mapServerLayer = this.display.getMap().makeMapLayer(this.attrs.predefinedLayer);
		} else {
		    console.error("Unknown map layer:" +this.attrs.predefinedLayer);
		}
	    } else {
		console.error("No map server url defined");
		return;
	    }

	    if(!this.mapServerLayer) return;

	    if(!Utils.isDefined(andZoom)) andZoom = true;
	    if(Utils.isDefined(this.style.opacity)) {
		this.mapServerLayer.opacity = +this.style.opacity;
	    }

	    this.mapServerLayer.setVisibility(this.isVisible());
	    this.mapServerLayer.isBaseLayer = false;
	    this.mapServerLayer.visibility = this.isVisible();
	    this.mapServerLayer.canTakeOpacity = true;
	    this.display.getMap().addLayer(this.mapServerLayer,true);
	}
    },

    getImage:function() {
	return this.image;
    },
    setImage:function(image) {
	this.image = image;
	this.image.mapGlyph = this;
	this.initImageLayer(this.image);
    },     

    applyPropertiesComponent: function(newStyle) {
	let oldStyle = this.style;
	this.style=newStyle;
	if(this.isStraightLine()) {
	    let changed = false;
	    let dots=  this.jq(ID_ADDDOTS).is(':checked');
	    if(dots!=this.attrs.addDots) {
		this.attrs.addDots= dots;
		changed=true;
	    }
	    Object.keys(newStyle).forEach(key=>{
		if(key.indexOf('dot')>=0 && oldStyle[key]!=newStyle[key]) changed=true;
	    });
	    let v = this.jq(ID_LINETYPE).val();
	    if(v!=this.attrs.lineType) {
		changed=true;
		this.attrs.lineType = v;
	    }
	    if(changed) {
		this.checkLineType();
	    }
	}

	if(this.isMultiEntry()) {
	    let childIcon = this.style.childIcon;
	    if(Utils.stringDefined(childIcon)) {
		this.applyChildren(child=>{
		    child.style.externalGraphic = childIcon;
		    child.attrs.icon = childIcon;		    
		});
	    }
	}


	if(this.isMap()) {
	    this.attrs.subsetSkip = jqid(this.domId('subsetSkip')).val();
	    this.attrs.subsetReverse = jqid(this.domId('subsetReverse')).is(':checked');
	    this.attrs.subsetSimplify= jqid(this.domId('subsetSimplify')).is(':checked');
	    this.setMapPointsRange(jqid('mappoints_range').val());
	    this.setMapLabelsTemplate(jqid('mappoints_template').val());
	    this.attrs.declutter_labels=this.jq('declutter_labels').is(':checked');
	    ['labels_maxlength','labels_maxlinelength',
	     'declutter_pixelsperline','declutter_pixelspercharacter','declutter_padding'].forEach(id=>{
		 let v=this.jq(id).val();
		 if(v) v=v.trim();
		 this.attrs[id] = v;
	     });


	    
	    let styleGroups = this.getStyleGroups();
	    let groups = [];
	    for(let i=0;i<20;i++) {
		let prefix = 'mapstylegroups_' + i;
		let group = styleGroups[i];
		let label = jqid(prefix+'_label').val();
		if(!Utils.stringDefined(label)) continue;
		if(!group) group = {
		    style:{},
		    indices:[],
		}
		group.label = label
		group.style = {};

		let value;
		if(Utils.stringDefined(value=jqid(prefix+'_fillcolor').val())) group.style.fillColor = value;
		if(Utils.stringDefined(value=jqid(prefix+'_fillopacity').val())) group.style.fillOpacity = value;
		if(Utils.stringDefined(value=jqid(prefix+'_strokecolor').val())) group.style.strokeColor = value;
		if(Utils.stringDefined(value=jqid(prefix+'_strokewidth').val())) group.style.strokeWidth = value;
		if(Utils.stringDefined(value=jqid(prefix+'_fillpattern').val())) group.style.fillPattern = value;
		groups.push(group);
	    }
	    this.attrs.styleGroups = groups;
	}	    

	if(!this.canDoMapStyle()) return;
	this.attrs.fillColors = this.jq('fillcolors').is(':checked');
	let getColorBy=(prefix)=>{
	    return  {
		property:this.jq(prefix +'colorby_property').val(),
		min:parseFloat(this.jq(prefix +'colorby_min').val()),
		max:parseFloat(this.jq(prefix +'colorby_max').val()),		
		colorTable:this.jq(prefix +'colorby_colortable').val()};		
	};


	this.attrs.fillColorBy =  getColorBy('fill');
	this.attrs.strokeColorBy =  getColorBy('stroke');	
	let rules = [];
	for(let i=0;i<20;i++) {
	    if(!Utils.stringDefined(jqid('mapproperty_' + i).val()) &&
	       !Utils.stringDefined(jqid('mapstyle_' + i).val())) {
		continue;
	    }
	    let rule = {
		property:jqid('mapproperty_' + i).val(),
		type:jqid('maptype_' + i).val(),
		value:jqid('mapvalue_' + i).val(),
		style:jqid('mapstyle_' + i).val(),
	    }
	    rules.push(rule);
	}
	this.attrs.mapStyleRules =rules;
    },
    getColorTableDisplay:function(id,min,max,showRange,isEnum,strings,stringValues) {
	if(isEnum) showRange=false;
	let ct = Utils.ColorTables[id];
	if(!ct) {
	    return "----";
	}
	let showDots = isEnum&& strings.length<=30;
	//For now don't show the labels on the colortable
	let showLabels = false;
     	if(this.getProperty('colortable.showDots'))
	    showDots = true;
        let display = Utils.getColorTableDisplay(ct,  min??0, max??1, {
	    tooltips:strings,
	    stringValues:stringValues,
	    showColorTableDots:showDots,
	    horizontal:!isEnum || strings.length>15,
	    showRange: false,
            height: "20px",
	    showRange:showRange,
	    showLabels:showLabels
        });
	let attrs = [TITLE,id,ATTR_STYLE,'margin-right:4px;',"colortable",id]
	//	if(ct.colors.length>20)   attrs.push(STYLE,HU.css(ATTR_WIDTH,'400px'));
        return  HtmlUtils.div(attrs,display);
    },
    initColorTables: function(currentColorbar) {
	if(!currentColorbar)
	    this.currentColorbar=this.getDatacubeVariable()?.colorBarName;
	currentColorbar = currentColorbar??this.getDatacubeVariable()?.colorBarName;
	let items = [];
	let image;
	let html = '';
	this.display.colorbars.forEach(coll=>{
	    let cat=coll[0];
	    html+=HU.b(cat)+'<br>';
	    coll[2].forEach(c=>{
		let name = c[0];
		let url = 'data:image/png;base64,' + c[1];
		html+=HU.image(url,[ATTR_CLASS,CLASS_CLICKABLE,'colorbar',name, 'height','20px',ATTR_WIDTH,'256px',ATTR_TITLE,name]);
		html+='<br>';
		if(name==currentColorbar) {
		    image = c[1];
		}
	    });
	});
	let url = image?('data:image/png;base64,' + image):null;
	this.jq('colortableproperties').html(HU.div([ATTR_ID,this.domId('colortable'),ATTR_CLASS,CLASS_CLICKABLE,ATTR_TITLE,'Click to select color bar'],
						    url? HU.image(url,['height','20px',ATTR_WIDTH,'256px']):'No image'));

	let _this = this;
	html = HU.div([ATTR_STYLE,'margin:8px;max-height:200px;overflow-y:auto;'], html);
	this.jq('colortable').click(function() {
	    let colorSelect = HU.makeDialog({content:html,
					     my:'left top',
					     at:'left bottom',
					     anchor:$(this)});
	    colorSelect.find(TAG_IMG).click(function() {
		_this.currentColorbar = $(this).attr('colorbar');
		colorSelect.remove();
		_this.initColorTables(_this.currentColorbar);
	    });
	});
    },
    groupMakeGeoJson:function() {
	let separateFeatures = !this.jq('mergepolygons').is(':checked');
	let data=[];
	this.applyChildren(child=>{
	    let geometry=child.getGeometry();
	    if(!geometry) return;
	    data.push({
		geometry:geometry,
		name:child.name
	    });
	});
	this.makeGeoJson(separateFeatures,data);
    },
    makeGeoJson:function(separateFeatures,data) {
	let mergePts = [];
	data.forEach((d,idx)=>{
	    if(!d.geometry) return;
	    let pts = this.display.getLatLonPoints(d.geometry);
	    if(pts==null) return;
	    mergePts = Utils.mergeLists(mergePts,pts);
	    d.points=pts;
	});
	let features = [];
	if(!separateFeatures) {
	    let coords =mergePts.map(p=>{
		return [p.x,p.y]
	    });
	    let name='Polygon';
	    features.push({
		type: "Feature",
		properties: {
		    name: name
		},
		geometry: {
		    type: "Polygon",
		    coordinates: [coords]
		}});
	} else {
	    data.forEach((d,idx)=>{
		if(!d.points) return;
		let coords =d.points.map(p=>{
		    return [p.x,p.y]
		});
		let name=d.name??'Polygon ' + idx;
		let properties;
		if(d.attributes) properties=d.attributes;
		else properties={name: name };
		features.push({
		    type: "Feature",
		    properties: properties,
		    geometry: {
			type: coords.length==1?'Point':'LineString',
			coordinates: coords.length==1?coords[0]:coords
		    }});
	    });
	}


	let json = {
	    type: "FeatureCollection",
	    "features": features
	}
	let file = Utils.makeID(this.name)+'.geojson';
	Utils.makeDownloadFile(file,JSON.stringify(json));
    },

    groupMakeCsv:function() {
	let csv = 'name,latitude,longitude\n';
	this.applyChildren(child=>{
	    let geometry=child.getGeometry();
	    if(!geometry) return;
	    let centroid = geometry.getCentroid(true);
	    if(!centroid) return;
	    let lonlat = this.getMap().transformProjPoint(centroid)
	    csv+=child.name+','+lonlat.y+','+ lonlat.x+'\n';

	});
	let file = Utils.makeID(this.name)+'.csv';
	Utils.makeDownloadFile(file,csv);
    },

    initPropertiesComponent: function(dialog) {
	HU.initPageSearch('.imdv-property',
			  null,null,true,
			  {target:'#'+this.domId('propsearch')});

	if (this.isGroup()) {
	    this.jq('makegeojson').button().click(()=>{
		this.groupMakeGeoJson();
	    });
	    this.jq('makecsv').button().click(()=>{
		this.groupMakeCsv();
	    });	    
	}


	let props = [
	    [ID_DATAICON_FIELDS,  DEFAULT_DATAICON_FIELDS],
	    [ID_DATAICON_INIT_FIELD,DEFAULT_DATAICON_FIELD],
	    [ID_DATAICON_WIDTH,'300'],
	    [ID_DATAICON_HEIGHT,'100'],	     
	    [ID_DATAICON_SIZE,'40'],
	    [ID_DATAICON_LABEL,''],
	    [ID_DATAICON_PROPS,DEFAULT_DATAICON_PROPS,''],
	    [ID_DATAICON_MARKERS,DEFAULT_DATAICONS]];

	this.jq('applyentrydataicon').button().click(()=>{
	    let propsLine = '';
	    let markers='';
	    Utils.split(this.transientProperties.mapglyphs,'\n',true,true).forEach(line=>{
		if(line.startsWith("#")) return;
		if(line.startsWith('props:')) {
		    propsLine+=line.substring('props:'.length);
		} else {
		    markers+=line+'\n';
		}
	    });
	    let props = {};
	    this.parseDataIconProps(props,propsLine);
	    if(Utils.isDefined(props.canvasWidth)) {
		this.jq(ID_DATAICON_WIDTH).val(props.canvasWidth);
		delete props.canvasWidth;
	    }
	    if(Utils.isDefined(props.canvasHeight)) {
		this.jq(ID_DATAICON_HEIGHT).val(props.canvasHeight);
		delete props.canvasHeight;
	    }
	    if(Utils.isDefined(props.iconSize)) {
		this.jq(ID_DATAICON_SIZE).val(props.iconSize);
		delete props.iconSize;
	    }
	    let tmp = '';
	    Object.keys(props).forEach((key,idx)=>{
		if(idx>0) tmp+=',';
		tmp+=key+':'+props[key];
	    });

	    this.jq(ID_DATAICON_PROPS).val(tmp);
	    this.jq(ID_DATAICON_MARKERS).val(markers);	    
	});
	this.jq('dataicon_add_default').button().click(() =>{
	    props.forEach(tuple=>{	     	      
		 if(!Utils.stringDefined(this.jq(tuple[0]).val()))
		    this.jq(tuple[0]).val(tuple[1]);
	     });
	});
	this.jq('dataicon_clear_default').button().click(() =>{
	    props.forEach(tuple=>{	     	      
		this.jq(tuple[0]).val('');
	     });
	});

	this.jq('createroute').button().click(()=>{
	    this.makeGroupRoute();
	});


	let _this = this;
	if(this.isMapServer() && this.getDatacubeVariable()) {
	    if(!this.display.colorbars) {
		let dataCubeServers=  MapUtils.getMapProperty('datacubeservers','').split(',');
		let url = dataCubeServers[0]+'/colorbars';
		$.getJSON(url, (data)=> {
		    this.display.colorbars = data;
		    this.initColorTables();
		});
	    } else {
		this.initColorTables();
	    }
	}	    	


	let clearElevations = this.jq('clearelevations');
	clearElevations.button().click(function(){
	    _this.attrs.elevations = null;
	    $(this).attr('disabled','disabled');
	    $(this).addClass('ramadda-button-disabled');
	});
	if(!this.attrs.elevations) {
	    this.jq('clearelevations').prop('disabled',true);
	}

	this.jq('makeelevations').button().click(function(){
	    $(this).html('Fetching elevations');
	    let callback =(count,total)=>{
		$(this).html('Processed ' + count + ' of ' + total);
		return true;
	    }
	    let done = ()=>{
		clearElevations.removeClass('ramadda-button-disabled');
		clearElevations.attr('disabled',null);
		$(this).html('Done');
		setTimeout(()=>{
		    $(this).html('Add elevations');
		},3000);

	    }
	    _this.addElevations(callback,done)
	});


	let decorate = (prefix) =>{
	    let div = this.getColorTableDisplay(this.jq(prefix+'colorby_colortable').val(),NaN,NaN,false);
	    this.jq(prefix+'colorby_colortable_label').html(div);
	};

	decorate('fill');
	decorate('stroke');	
	dialog.find(".ramadda-colortable-select").click(function() {
	    let prefix = $(this).attr('prefix');
	    let ct = $(this).attr("colortable");
	    _this.jq(prefix+'colorby_colortable').val(ct);
	    decorate(prefix);
	});
	Utils.displayAllColorTables(this.display.domId('fillcolorby'));
	Utils.displayAllColorTables(this.display.domId('strokecolorby'));

	let initColor  = prefix=>{
	    dialog.find('#'+this.domId(prefix+'colorby_property')).change(function() {
		let prop =  $(this).val();
		_this.featureInfo.every(info=>{
		    if(info.property!=prop) return true;
		    if(info.isString() || info.isEnumeration()) {
			_this.jq(prefix+'colorby_min').val('');
			_this.jq(prefix+'colorby_max').val('');		    
		    }  else {
			_this.jq(prefix+'colorby_min').val(info.min);
			_this.jq(prefix+'colorby_max').val(info.max);
		    }
		    return true;
		});
	    });
	};
	initColor('fill');
	initColor('stroke');

	dialog.find('[mapproperty_index]').change(function() {
	    let info = _this.featureInfoMap[$(this).val()];
	    if(!info) return;
	    let index  = $(this).attr('mapproperty_index');	    
	    let tt = "";
	    let value = jqid('mapvalue_' + index).val();
	    let wrapper = jqid('mapvaluewrapper_' + index);
	    if(info.isNumeric()) {
		wrapper.html(HU.input("",value,[ATTR_ID,'mapvalue_' + index,'size','15']));
		tt=info.min +" - " + info.max;
	    }  else  if(info.samples.length) {
		tt = Utils.join(info.getSamplesLabels(), ", ");
		if(info.isEnumeration()) {
		    wrapper.html(HU.select("",[ATTR_ID,'mapvalue_' + index],info.samples,value,20));
		} else {
		    wrapper.html(HU.input("",value,[ATTR_ID,'mapvalue_' + index,'size','15']));
		}
	    }
	    jqid('mapvalue_' + index).attr(ATTR_TITLE,tt);
	});

	HU.initPageSearch(dialog.find('.dialog-feature'),
			  null,null,null,{target:this.jq('dialog_features_top')});

	dialog.find('.feature-name').click(function() {
	    let feature = getFeature($(this));
	    if(feature)
		_this.display.getMap().centerOnFeatures([feature]);
	});
	dialog.find('.feature-name').tooltip({
	    show: { delay: 1000 },
	    open: function(event, ui) {
		ui.tooltip.css("max-width", "600px"); 
            },
	    content: function() {
		let feature = getFeature($(this));
		let html = _this.getFeatureText(feature.attributes);
		html = HU.div([ATTR_STYLE,'font-size:9pt;width:600px;'],html);
		return html;

	    }});
	let visCbxs = dialog.find('.feature-visible');
	let selectCbxs = dialog.find('.feature-select');

	let cbxToggle = cbx=>{
	    let visible = cbx.is(':checked');
	    let index = cbx.attr('feature-index');
	    let feature = _this.indexToFeature[index];
	    if(!feature) return;
	    MapUtils.setFeatureVisible(feature,visible);
	    feature.isVisible=visible;
	    if(!visible)  {
		feature.forceHidden=true;
	    } else {
		feature.forceHidden=false;
	    }
	};

	this.jq('features_select_all').change(function() {
	    let visible = $(this).is(':checked');
	    selectCbxs.each(function() {
		if($(this).is(':visible')) {
		    $(this).prop('checked',visible);
		}
	    });
	});


	this.jq('features_visible_all').change(function() {
	    let visible = $(this).is(':checked');
	    visCbxs.each(function() {
		if($(this).is(':visible')) {
		    $(this).prop('checked',visible);
		    cbxToggle($(this));
		}
	    });
	    ImdvUtils.scheduleRedraw(_this.mapLayer);
	});



	visCbxs.change(function(){
	    cbxToggle($(this));
	    ImdvUtils.scheduleRedraw(_this.mapLayer);
	});

	let getFeature=ele=>{
	    let index = ele.attr('feature-index');
	    return  _this.indexToFeature[index];

	};


	dialog.find('.dialog-features-size').click(function(){
	    let feature = getFeature($(this));
	    if(!feature) return;
	    let name = $(this).attr('feature-name');
	    _this.display.handleNewFeature(feature,null, {type:GLYPH_POLYLINE,name:name});
	});


	this.jq('dialog_features_makemap').button().click(()=>{
	    let data=[];
	    visCbxs.each(function() {
		if(!$(this).is(':checked'))return;
		let feature = getFeature($(this));
		if(!feature)return;
		data.push({
		    geometry:feature.geometry,
		    attributes:feature.attributes
		});
	    });
	    if(data.length==0) {
		alert('No features selected');
		return;
	    }
	    this.makeGeoJson(true,data);
	});


    },

    getFeaturesTable:function(id) {
	let columns  =this.getFeatureInfoList().filter(info=>{
	    return info.showTable();
	});
	let table;
	this.featureTableMap = {};

	let featureInfo = this.getFeatureInfoList();
	let rowCnt=0;
	let stats;
	this.mapLayer.features.forEach((feature,rowIdx)=>{
	    if(Utils.isDefined(feature.isVisible) && !feature.isVisible) {
		return
	    }
	    let attrs = feature.attributes;
	    let first = rowCnt++==0;
	    if(first) {
		table = HU.openTag(TAG_TABLE,[ATTR_ID,id,'table-ordering','true','table-searching','true','table-height','400px',
					    ATTR_CLASS,'stripe rowborder ramadda-table'])
		table+='<thead><tr>';
		stats = [];
		columns.forEach((column,idx)=>{
		    table+=HU.tag('th',[],column.getLabel(true));
		    stats.push({total:0,count:0,min:0,max:0});
		});
		table+=HU.close(TAG_TR,'thead','tbody');
	    }
	    this.featureTableMap[rowIdx] =feature;
	    table+=HU.openTag(TAG_TR,[ATTR_TITLE,'Click to zoom to','featureidx', rowIdx,
				    ATTR_CLASS,HU.classes('imdv-feature-table-row',CLASS_CLICKABLE)]);
	    columns.forEach((column,idx)=>{
		let stat =  stats[idx];
		let v= this.getFeatureValue(feature,column.property)??'';
		if(v && Utils.isDefined(v.value)) v = v.value;
		let nv = +v;
		let sv = String(v);
		let isNumber = column.isNumeric();
		if(isNumber && sv!='' && !isNaN(nv)) {
		    stat.count++;
		    stat.min = first?nv:Math.min(nv, stat.min);
		    stat.max = first?nv:Math.max(nv, stat.max);		    
		    stat.total+=nv;
		}
		//Check for html. Maybe just convert to entities?
		if(sv.indexOf('<')>=0) {
		    sv = Utils.stripTags(sv);
		}
		sv=column.format(sv);
		table+=HU.tag(TAG_TD,[ATTR_STYLE,isNumber?'text-align:right':'','align',isNumber?'right':'left'],sv);
	    });
	});
	if(stats) {
	    table+='<tfoot><tr>';
	    let fmt = (label,amt) =>{
		return HU.tr(HU.td([ATTR_STYLE,'text-align:right','align','right'],HU.b(label)) +
			     HU.td([ATTR_STYLE,'text-align:right','align','right'],Utils.formatNumberComma(amt)));
	    };
	    columns.forEach((column,idx)=>{
		let stat =  stats[idx];
		table+='<td align=right>';
		if(stat.count!=0) {
		    let inner = '<table>';
		    inner +=
			fmt('Total:', stat.total) +
			fmt('Min:', stat.min) +
			fmt('Max:', stat.max) +
			fmt('Avg:', stat.total/stat.count);
		    inner+='</table>';
		    table+=inner;
		}
		table+='</td>';
	    });
	    table+='</tr></tfoot>';
	    table+=HU.close('tbody');
	}

	return table;
    },
    downloadFeaturesTable:function(id) {
	let columns;
	let csv='';
	this.mapLayer.features.forEach((feature,rowIdx)=>{
	    if(Utils.isDefined(feature.isVisible) && !feature.isVisible) {
		return;
	    }
	    let attrs = feature.attributes;
	    if(columns==null) {
		columns  =this.getFeatureInfoList().filter(info=>{
		    return info.showTable();
		});
		let rows = columns.map((column,idx)=>{ return column.getLabel();});
		csv+=Utils.join(rows,',');
		csv+='\n';
	    }
	    let rows = columns.map((column,idx)=>{
		let v = attrs[column.property]??'';
		if(Utils.isDefined(v.value)) v = v.value;
		return  String(v).replace(/\n/g,'_nl_');
	    });
	    csv+=Utils.join(rows,',');
	    csv+='\n';
	});
	Utils.makeDownloadFile('features.csv',csv);
    },

    updateFeaturesTable:function() {
	if(!this.featuresTableDialog) return;
	let tableId = HU.getUniqueId("table");
	let table =this.getFeaturesTable(tableId);
	let html='';
	if(!table) {
	    html += HU.div([ATTR_STYLE,'width:200px;margin:10px;'],'No data');
	} else {
	    html +=  
		HU.div([ATTR_STYLE,HU.css('margin','5px','max-width','1000px','overflow-x','scroll')],table);
	    html = HU.div([ATTR_STYLE,'margin:5px;'], html);
	}
	this.jq('featurestable').html(html);
	HU.formatTable('#'+tableId,{scrollX:true});
	let _this = this;
	this.featuresTableDialog.find('.imdv-feature-table-row').click(function() {
	    let feature = _this.featureTableMap[$(this).attr('featureidx')];
	    _this.display.getMap().centerOnFeatures([feature]);
	});
    },
    showFeaturesTable:function(anchor) {
	if(this.featuresTableDialog)
	    this.featuresTableDialog.remove();
	let html =  HU.div([ATTR_ID,this.domId('downloadfeatures'),ATTR_CLASS,CLASS_CLICKABLE],'Download Table');
	html+=HU.div([ATTR_ID,this.domId('featurestable')]);
	html = HU.div([ATTR_STYLE,'margin:10px;'], html);
	this.featuresTableDialog =
	    HU.makeDialog({content:html,title:this.name,header:true,draggable:true,
			   my:'left top',
			   at:'left bottom',
			   anchor:anchor});
	
	this.updateFeaturesTable();
	this.jq('downloadfeatures').button().click(()=>{
	    this.downloadFeaturesTable();
	});
    },
    getHelp:function(url,label) {
	if(!url.startsWith('#')) url = '/userguide/imdv/' + url;
	return HU.href(Ramadda.getUrl(url),HU.getIconImage(icon_help) +' ' +(label??'Help'),['target','_help']);
    },
    getCentroid: function() {
	if(this.features && this.features.length) {
	    return  this.features[0].geometry.getCentroid(true);
	}
	if(this.extraFeatures && this.extraFeatures.length) {
	    return  this.extraFeatures[0].geometry.getCentroid(true);
	}

	return null;
    },
    makeGroupRoute: function() {
	let doSequence = this.display.jq('routedosequence').is(':checked');
	let pts = [];
	this.applyChildren(child=>{
	    if(!child.isVisible()) return;
	    let centroid  = child.getCentroid();
	    if(!centroid) return;
	    var lonlat = this.getMap().transformProjPoint(centroid)
	    pts.push(lonlat);
	});

	if(pts.length==0) {
	    alert('No points to make route from');
	    return;
	}
	this.display.handleNewRoute(null,pts,{
	    doSequence:doSequence});
    },
    applyTemplate:function(template,attrs) {
	if(!attrs || !template) return null;
	Object.keys(attrs).forEach(key=>{
	    let _key = key.toLowerCase();
	    template = template.replace('{' + _key+'}',attrs[key]);
	    template = template.replace('{' + key+'}',attrs[key]);		
	});
	return template;
    },
    getFeatureText:function(attrs) {
	let template =this.getProperty('textTemplate');
	if(template) {
	    return this.applyTemplate(template,attrs);
	}
	
	if(!attrs) return null;
	let html = '';
	Object.keys(attrs).forEach(key=>{
	    if(!attrs[key]) return;
	    let v = String(attrs[key]);
	    if(v.length>100) v = v.substring(0,99)+'...';
	    html+=HU.b(key)+': '+ v+'<br>';
	});
	return html;

    },

    getFeatureName:function(attrs) {
	let template =this.getProperty('nameTemplate');
	if(template) {
	    return this.applyTemplate(template,attrs);
	}
	
	if(!attrs) return null;
	let name = attrs.name;
	if(!name) {
	    Object.keys(attrs).every(key=>{
		let _key = key.toLowerCase();
		if(_key.indexOf('name')>0) {
		    name = attrs[key];
		    if(name) {
			return false;
		    }
		}
		return true;
	    });
	}
	return name;
    },


    getPropertiesComponent: function(content) {
	if(this.isGroup()) {
	    let makeMapHelp = HU.leftRightTable('',
						this.getHelp('mapfiles.html#drawing_a_map'));
	    let html = makeMapHelp;
	    html += HU.div([ATTR_ID,this.domId('makegeojson')],'Make Map File');
	    html+=SPACE;
	    html+= HU.checkbox(this.domId('mergepolygons'),[ATTR_ID,this.domId('mergepolygons')],false,'Merge Polygons');

	    html+='<p>'
	    html += HU.div([ATTR_ID,this.domId('makecsv')],'Make CSV File');	    
	    html+='<p>'
	    html += HU.div([ATTR_ID,this.domId('createroute')],'Create Route');	    
	    content.push({header:'Make Map',contents:html});
	}


	if(!this.canDoMapStyle()) return;
	let attrs = this.getExampleMapLayer()?.features[0].attributes ?? {};
	let featureInfo = this.featureInfo = this.getFeatureInfoList();
	let keys  = Object.keys(featureInfo);
	let numeric = featureInfo.filter(info=>{return info.isNumeric();});
	let enums = featureInfo.filter(info=>{return info.isEnumeration();});
	let colorBy = '';
	colorBy+=HU.leftRightTable(HU.checkbox(this.domId('fillcolors'),[ATTR_ID,this.domId('fillcolors')],
					       this.attrs.fillColors,'Fill Colors'),
				   this.getHelp('mapfiles.html#mapstylerules'));

	numeric = featureInfo;
	if(numeric.length) {
	    let numericProperties=Utils.mergeLists([['','Select']],numeric.map(info=>{return {value:info.property,label:info.getLabel()};}));
	    let mapComp = (obj,prefix) =>{
		let comp = '';
		comp += HU.div([ATTR_CLASS,'formgroupheader'], 'Map value to ' + prefix +' color')+ HU.formTable();
		comp += HU.formEntry('Property:', HU.select('',[ATTR_ID,this.domId(prefix+'colorby_property')],numericProperties,obj.property) +HU.space(2)+ HU.b('Range: ') + HU.input('',obj.min??'', [ATTR_ID,this.domId(prefix+'colorby_min'),'size','6',ATTR_TITLE,'min value']) +' -- '+    HU.input('',obj.max??'', [ATTR_ID,this.domId(prefix+'colorby_max'),'size','6',ATTR_TITLE,'max value']));
		comp += HU.hidden('',obj.colorTable||'blues',[ATTR_ID,this.domId(prefix+'colorby_colortable')]);
		comp+=HU.formEntry('Color table:', HU.div([ATTR_ID,this.domId(prefix+'colorby_colortable_label')])+
				   Utils.getColorTablePopup(null,null,'Select',true,'prefix',prefix));
		comp+=HU.close(TAG_TABLE);
		return comp;
	    };
	    colorBy+=mapComp(this.attrs.fillColorBy ??{},'fill');
	    colorBy+=mapComp(this.attrs.strokeColorBy ??{},'stroke');	    
	}

	let properties=Utils.mergeLists([['','Select']],featureInfo.map(info=>{
	    return {value:info.property,label:info.getLabel()};}));
	let ex = '';
	let helpLines = [];
	featureInfo.forEach(info=>{
	    helpLines.push(info.id);
	    let seen ={};
	    let list =[];
	    let label = HU.b(this.makeLabel(info.property,true));
	    let line = ''
	    if(info.isNumeric()) {
		line =  info.min +' - ' + info.max;
	    } else if(info.isEnumeration()) {
		line =  Utils.join(info.getSamplesValues(),', ');
	    } else {
		line =  Utils.join(info.getSamplesValues(),', ');
	    }
	    ex+=label+': ' + line +'<br>';
	});
	let c = OpenLayers.Filter.Comparison;
	let operators = [c.EQUAL_TO,c.NOT_EQUAL_TO,c.LESS_THAN,c.GREATER_THAN,c.LESS_THAN_OR_EQUAL_TO,c.GREATER_THAN_OR_EQUAL_TO,[c.BETWEEN,'between'],[c.LIKE,'like'],[c.IS_NULL,'is null'],['use','Use']];
	let rulesTable = HU.formTable();
	let sample = 'Samples&#013;';
	for(a in attrs) {
	    let v = attrs[a]?String(attrs[a]):'';
	    v = v.replace(/"/g,'').replace(/\n/g,' ');
	    sample+=a+'=' + v+'&#013;';
	}
	rulesTable+=HU.tr([],HU.tds([ATTR_STYLE,'font-weight:bold;'],['Property','Operator','Value',ATTR_STYLE]));
	let rules = this.getMapStyleRules(true);
	let styleTitle = 'e.g.:&#013;fillColor:red&#013;fillOpacity:0.5&#013;strokeColor:blue&#013;strokeWidth:1&#013;strokeDashstyle:solid|dot|dash|dashdot|longdash|longdashdot';
	for(let index=0;index<20;index++) {
	    let rule = index<rules.length?rules[index]:{};
	    let value = rule.value??'';
	    let info = this.featureInfoMap[rule.property];
	    let title = sample;
	    let valueInput;
	    if(info) {
		if(info.isNumeric())
		    title=info.min +' - ' + info.max;
		else if(info.samples.length)
		    title = Utils.join(info.getSamplesLabels(), ', ');
	    }
	    if(info?.isEnumeration()) {
		valueInput = HU.select('',[ATTR_ID,'mapvalue_' + index],info.getSamplesForMenu(),value,20); 
		
	    } else {
		valueInput = HU.input('',value,[ATTR_ID,'mapvalue_' + index,'size','15']);
	    }
	    let propSelect =HU.select('',[ATTR_ID,'mapproperty_' + index,'mapproperty_index',index],properties,rule.property);
	    let opSelect =HU.select('',[ATTR_ID,'maptype_' + index],operators,rule.type);	    
	    valueInput =HU.span([ATTR_ID,'mapvaluewrapper_' + index],valueInput);
	    let s = Utils.stringDefined(rule.style)?rule.style:'';
	    let styleInput = HU.textarea('',s,[ATTR_ID,'mapstyle_' + index,'rows','3','cols','30',ATTR_TITLE,styleTitle]);
	    rulesTable+=HU.tr(['valign','top'],HU.tds([],[propSelect,opSelect,valueInput,styleInput]));
	}
	rulesTable += '</table>';
	let table = HU.b('Style Rules')+HU.div([ATTR_CLASS,'imdv-properties-section'], rulesTable);
	content.push({header:'Style Rules', contents:colorBy+table});


	let mapPointsRange = HU.leftRightTable(HU.b('Visiblity limit: ') + HU.select('',[ID,'mappoints_range'],this.display.levels,this.getMapPointsRange()??'',null,true) + ' '+
					       HU.span([ATTR_CLASS,'imdv-currentlevellabel'], '(current level: ' + this.display.getCurrentLevel()+')'),
					       this.getHelp('mapfiles.html#map_labels'));

	let mapPoints = HU.textarea('',this.getMapLabelsTemplate()??'',[ATTR_ID,'mappoints_template','rows','6','cols','40',ATTR_TITLE,'Map points template, e.g., ${code}']);

	let propsHelp =this.display.makeSideHelp(helpLines,'mappoints_template',{prefix:'${',suffix:'}'});
	mapPoints = HU.hbox([mapPoints,HU.space(2),'Add property:' + propsHelp]);


	let styleGroups =this.getStyleGroups();
	let styleGroupsUI = HU.leftRightTable('',
					      this.getHelp('mapfiles.html#stylegroups'));
	styleGroupsUI+=HU.openTag(TAG_TABLE,[ATTR_WIDTH,'100%']);
	styleGroupsUI+=HU.tr([],HU.tds([ATTR_STYLE,'font-weight:bold;'],
				       ['Group','Fill','Opacity','Stroke',ATTR_WIDTH,'Pattern','Features']));
	for(let i=0;i<20;i++) {
	    let group = styleGroups[i];
	    let prefix = 'mapstylegroups_' + i;
	    styleGroupsUI+=HU.tr([],HU.tds([],[
		HU.input('',group?.label??'',[ATTR_ID,prefix+'_label','size','10']),
		HU.input('',group?.style.fillColor??'',[ATTR_CLASS,'ramadda-imdv-color',ATTR_ID,prefix+'_fillcolor','size','6']),
		HU.input('',group?.style.fillOpacity??'',[ATTR_TITLE,'0-1',ATTR_ID,prefix+'_fillopacity','size','2']),		
		HU.input('',group?.style.strokeColor??'',[ATTR_CLASS,'ramadda-imdv-color',ATTR_ID,prefix+'_strokecolor','size','6']),
		HU.input('',group?.style.strokeWidth??'',[ATTR_ID,prefix+'_strokewidth','size','6']),
		this.display.getFillPatternSelect(prefix+'_fillpattern',group?.style.fillPattern??''),
		Utils.join(group?.indices??[],',')]));
	}
	styleGroupsUI += HU.closeTag(TAG_TABLE);
	styleGroupsUI = HU.div([ATTR_STYLE,HU.css('max-height','300px','overflow-y','auto')], styleGroupsUI);

	//Don't add style groups if it is a group, just map glyphs
	if(!this.isGroup()) {
	    content.push({header:'Style Groups',contents:styleGroupsUI});
	}


	let input = (id,label,dflt) =>{
	    return SPACE2 + HU.b(label+': ')+
		HU.input('', this.attrs[id]??'', ['placeholder',dflt,ATTR_ID,this.domId(id),ATTR_SIZE,'5']);
	}
	let space =  HU.div([ATTR_STYLE,'margin-top:5px;']);
	let extra = '';
	extra+=input('labels_maxlength','Max Length','100');
	extra+=input('labels_maxlinelength','Max Line Length',15);
	extra+=space;
	extra+= HU.checkbox(this.domId('declutter_labels'),
			    [ATTR_ID,this.domId('declutter_labels')],
			    this.getDeclutterLabels(),'Declutter Labels');
	extra+=space;
	extra+=input('declutter_padding','Padding',2);				
	extra+=input('declutter_pixelsperline','Pixels/Line',10);
	extra+=input('declutter_pixelspercharacter','Pixels/Character',4);
	let labelsHtml =mapPointsRange+ 
	    HU.b('Label Template:')+ '<br>' +    
	    mapPoints +
	    extra;
	    
	content.push({header:'Labels',
		      contents:labelsHtml});

	if(this.isMap()) {
	    let subset = HU.b('Feature Subset')+'<br>';
	    subset += '<table>';
	    subset+=HU.formEntry('Skip:',
 				 HU.input('',this.attrs.subsetSkip??'0',
					  [ATTR_ID,this.domId('subsetSkip'),'size','6'])+
				 ' ' +'Prunes features');
	    subset+=HU.formEntry('',
				 HU.checkbox(this.domId('subsetReverse'),
					     [ATTR_ID,this.domId('subsetReverse')],
					     this.attrs.subsetReverse,'Reverse features'));
	    subset+=HU.formEntry('',
				 HU.checkbox(this.domId('subsetSimplify'),
					     [ATTR_ID,this.domId('subsetSimplify')],
					     this.attrs.subsetSimplify,'Simplify geometry' +
					     ' ' +'(for now this sets feature.components.length=1)'));
	    subset += '</table>';	    
	    content.push({header:'Subset',
			  contents:subset});

	}

	ex = HU.div([ATTR_STYLE,HU.css('max-height','400px','overflow-y','auto')], ex);
	content.push({header:'Sample Values',contents:ex});

	let features= this.getMapFeatures();
	if(features && features.length>0) {
	    let limit=2000;
	    let table = '';
	    table+='Total features: ' + features.length;
	    if(limit<features.length) table+=' Showing: ' + limit;
	    table+=SPACE4;
	    table+=HU.div([ATTR_ID,this.domId('dialog_features_makemap')],'Make Map');
	    table+='<br>';
	    table+=HU.div([ATTR_ID,this.domId('dialog_features_top')]);
	    table+='<table>\n';
	    let selectId  = this.domId('features_select_all');
	    let allId  = this.domId('features_visible_all');
	    let selectCbx = HU.checkbox(selectId,[ATTR_ID,selectId],true,'Select');
	    let allCbx = HU.checkbox(allId,[ATTR_ID,allId],true,'Visible');
	    table+='<tr>' + HU.tds([ATTR_STYLE,'padding-right:20px;font-weight:bold;'],[
		allCbx,
		'length miles/mile&sup2;/acres']) +'</tr>';
		 
	    this.indexToFeature={};
	    features.forEach((feature,idx)=>{
		this.indexToFeature[idx] = feature;
//		if(idx>10) return
		if(idx>limit) return;
		let distance = this.display.getDistances(feature.geometry,GLYPH_POLYGON,false,true,true);
		let name=this.getFeatureName(feature.attributes);
		if(!name) {
		    name = 'Polygon ' + (idx+1)
		}
		let row = HU.open('tr',
				  ['feature-index',idx,
				   'feature-name',name,
				   'data-corpus',feature.isVisible?'visible':'hidden',
				   ATTR_CLASS,'dialog-feature','data-feature',idx]);

		let id1=HU.getUniqueId('cbx');
		let id2=HU.getUniqueId('cbx');		
//		row+=HU.td(HU.checkbox(id1,[ATTR_ID,id1,ATTR_CLASS,'feature-select','feature-index',idx],true));
		name = HU.span([ATTR_CLASS,'ramadda-clickable feature-name','feature-index',idx,
				ATTR_TITLE,'Click to center',ATTR_STYLE,'margin-right:10px;margin-left:10px;'], name);
		row+=HU.td(HU.checkbox(id2,[ATTR_ID,id2,ATTR_CLASS,'feature-visible','feature-index',idx],
				       !feature.forceHidden && feature.isVisible)+name);
		row+='<td>';
		if(distance) {
		    row+=Utils.join([Utils.formatNumberComma(distance.feet/5280),
				     Utils.formatNumberComma(distance.sqmiles),
				     Utils.formatNumberComma(distance.acres)],'/');
		}
		row+='</td>';

		row+='</tr>\n';
		table+=row;
	    });
	    table+='</table>';
	    table=HU.div([ATTR_STYLE,HU.css('max-height','400px','overflow-y','auto')], table);
	    content.push({header:'Features',contents:table});
	}



    },
    getStyleGroups: function() {
	if(!this.attrs.styleGroups) {
	    this.attrs.styleGroups = [];
	}
	return this.attrs.styleGroups??[];
    },

    
    numre : /^[\d,\.]+$/,
    cleanupFeatureValue:function(v) {
	if(v===null) return null;
	if(Utils.isDefined(v.value)) {
	    v = v.value;
	}
	let sv = String(v);
	//	if(sv.indexOf('[object')>=0) {console.log('X',v,(typeof v));} else console.log(sv);
	if(sv.trim()=="") return "";
	if(sv.match(this.numre)) {
	    sv = sv.replace(/,/g,'').replace(/^0+/,"");
	}
	return sv;
    },
    getFeatureValue:function(feature,property) {
	if(!feature.attributes) return null;
	let value = feature.attributes[property];
	if(!Utils.isDefined(value)) return null;
	return  this.cleanupFeatureValue(value);
    },
    hasMapFeatures: function() {
	if(!this.isMap() || !this?.getExampleMapLayer()?.features || this.getExampleMapLayer()?.features.length==0) return false;
	return true;
    },
    canDoMapStyle: function() {
	let features = this.getExampleFeatures();
	if(!features || features.length==0) return false;
	if(!features[0].attributes ||   Object.keys(features[0].attributes).length==0) {
	    return false;
	}
	return true;
    },

    getMapStyleRules(justMine) {
	let debug = false;
	if(debug)
	    console.log('getMapStyleRules:' + this.getName());
	let rules =[];
	if(this.attrs.mapStyleRules && this.attrs.mapStyleRules.length>0) {
	    rules = Utils.mergeLists(this.attrs.mapStyleRules);
	}
	if(justMine) {
	    return rules;
	}
	if(this.getParentGlyph()) {
	    if(debug)
		console.log('\tasking parent');
	    rules = Utils.mergeLists(rules,this.getParentGlyph().getMapStyleRules());
	}
	return rules;
    },
    getExampleFeatures: function() {
	return this.getExampleMapLayer()?.features;
    },

    getMapFeatures: function() {
	if(this.mapLayer) {
	    return this.mapLayer.features;
	}
	let children = 	this.getChildren();
	if(!children) {
	    return null;
	}
	let features = null;
	for(let i=0;i<children.length;i++) {
	    let childFeatures = children[i].getMapFeatures();
	    if(childFeatures) features = Utils.mergeLists(features??[],childFeatures);
	}
	return features;
    },

    getExampleMapLayer: function() {
	if(this.mapLayer) return this.mapLayer;
	let children = 	this.getChildren();
	if(!children) return null;
	for(let i=0;i<children.length;i++) {
	    let layer = children[i].getExampleMapLayer();
	    if(layer) return  layer;
	}
	return null;
    },

    getFeatureInfoList:function() {
	if(this.featureInfo) return this.featureInfo;
	let features= this.getMapFeatures();
	if(!features || features.length==0) return [];
	let attrs = features[0].attributes;
	let keys =   Object.keys(attrs);
	let _this = this;
	let first = [];		
	let middle=[];
	let last = [];
	keys.forEach(key=>{
	    let info = new FeatureInfo(this,key);
	    let _c = info.property.toLowerCase();
	    if(_c.indexOf('objectid')>=0) {
		last.push(info);
	    } else if(_c.indexOf('name')>=0) {
		first.push(info);
	    } else {
		middle.push(info);
	    }
	});


	let featureInfo =  Utils.mergeLists(first,middle,last);
	let featureInfoMap = {};

	features.forEach((f,fidx)=>{
	    featureInfo.forEach(info=>{
		info.initValues(f);
	    });
	});


	featureInfo.forEach(info=>{
	    info.finishInit();
	    featureInfoMap[info.property] = info;
	    featureInfoMap[info.id] = info;	    
	});
	this.featureInfoMap =featureInfoMap;	    
	if(!this.isGroup()) {
	    this.featureInfo =featureInfo;
	}

	return featureInfo;
    },
    getFeatureInfo:function(property) {
	this.getFeatureInfoList();
	if(this.featureInfoMap) return this.featureInfoMap[property];
	return null;
    },
    makeLabel:function(l,makeSpan) {
	let info = this.getFeatureInfo(l);
	if(info) {
	    return info.getLabel(makeSpan);
	}
	let id = Utils.makeId(l);
	let label = l;
	if(id=='shapestlength') {
	    label =  'Shape Length';
	} else 	if(this.getProperty(id+'.feature.label')) {
	    label =  this.getProperty(id+'.feature.label');
	} else {
	    label =  this.display.makeLabel(l);
	}
	if(makeSpan) label = HU.span([ATTR_TITLE,'aka:' +id], label);
	return label;
    },

    setProperty:function(key,value) {
	let newLine = key+'='+value;
	if(this.attrs.properties) {
	    let tmp = '';
	    let hadMatch =false;
	    Utils.split(this.attrs.properties,'\n',true,true).forEach(line=>{
		if(line.match('^ *' +key+' *=')) {
		    hadMatch=true;
		    line = newLine;
		}
		tmp+=line+'\n';
	    });
	    if(!hadMatch) tmp+=newLine+'\n';
	    this.attrs.properties = tmp;
	} else {
	    this.attrs.properties = newLine+'\n';
	}
	this.parsedProperties=null;
	this.display.featureChanged(true);	    
    },
    getProperty:function(key,dflt,checkParent) {
	let debug = false;
	if(debug)
	    console.log("KEY:" + key);
	//Check the IMDV display
	let v = this.display.getMapProperty(key);
	if(Utils.isDefined(v))return v;
	if(this.attrs.properties) {
	    if(!this.parsedProperties) {
		this.parsedProperties = Utils.parseMap(this.attrs.properties,"\n","=")??{};
	    }

	    let v = this.parsedProperties[key];
	    if(debug) console.log("V:" + v);
	    if(debug) console.log("PROPS:",this.parsedProperties);	    
	    if(v) {
		return Utils.getProperty(v);
	    }
	}
	if(checkParent && this.getParentGlyph()) {
	    return this.getParentGlyph().getProperty(key,dflt,true);
	}
	return this.display.getMapProperty(key,dflt);
    },
    getTopHeader:function() {
	if(!this.topHeaderId) {
	    this.topHeaderId = HU.getUniqueId('topheader');
	    this.display.appendHeader(HU.div([ATTR_CLASS,'imdv-legend-top',ATTR_STYLE,HU.css('display','inline-block'),ATTR_ID,this.topHeaderId]));
	}
	return jqid(this.topHeaderId);
    },
    makeFeatureFilters:function() {
	let _this = this;
	let contents = {
	    first:'',
	    sliders:'',
	    enums:'',
	    strings:'',
	    top:[]
	}

	let showTop;
	let add=(info,type,line)=>{
	    if(showTop)   contents.top.push(line);
	    else if(info.getProperty('filter.first')) contents.first+=line;
	    else contents[type]+=line;
	};
	let filters = this.attrs.featureFilters = this.attrs.featureFilters ??{};
	this.filterInfo = {};
	this.getFeatureInfoList().forEach(info=>{
	    if(!info.showFilter()) {
		return;
	    }
	    //true=> check the  glyph
	    showTop = info.getProperty('filter.top',false,true);
	    this.filterInfo[info.property] = info;
	    this.filterInfo[info.getId()] = info;	    
	    if(!filters[info.property]) filters[info.property]= {};
	    let filter = filters[info.property];

	    if(!Utils.isDefined(filter.min) || isNaN(filter.min)) filter.min = info.min;
	    if(!Utils.isDefined(filter.max) || isNaN(filter.max)) filter.max = info.max;	    
	    filter.property =  info.property;
	    let id = info.getId();
	    let label = HU.span([ATTR_TITLE,info.property],HU.b(info.getLabel()));
	    if(info.isString())  {
		filter.type="string";
		let attrs =['filter-property',info.property,ATTR_ID,this.domId('string_'+ id),'size',20];
		attrs.push('placeholder',this.getProperty(info.property.toLowerCase()+'.filterPlaceholder',''));
		let widget;
		let rows = this.getProperty(info.id+'.filter.rows');
		if(Utils.stringDefined(rows)) {
		    attrs.push('rows',rows);
		    let buttonAttrs = ['textareaid',this.domId('string_'+id),ATTR_CLASS,CLASS_FILTER_STRINGS];
		    widget =     HU.div(buttonAttrs,'Search')+
			HU.textarea("",filter.stringValue??"",attrs);
		} else {
		    attrs.push(ATTR_CLASS,CLASS_FILTER_STRING);
		    widget =     HU.input("",filter.stringValue??"",attrs);
		}
		let string=label+":<br>" +widget + '<br>';
		add(info,'strings',string);
		return
	    } 
	    if(info.isEnumeration())  {
		filter.type="enum";

		if(info.samples.length>1) {
		    let sorted;
		    if(this.getProperty('filter.sortOnCount',false)) {
			sorted = info.samples.sort((a,b)=>{
			    let cnt1 = info.seen[a.value];
			    let cnt2 = info.seen[b.value];			    
			    return cnt2-cnt1;
			});
			sorted = info.samples;
		    } else {
			sorted = info.samples.sort((a,b)=>{
			    return a.value.localeCompare(b.value);
			});
		    }
		    let options = sorted.map(sample=>{
			let label = sample.label +' (' + info.seen[sample.value]+')';
			if(sample.value=='')
			    label = '&lt;blank&gt;' +' (' + info.seen[sample.value]+')';
			return {value:sample.value,label:label}
		    });

		    let size = info.filterSize();
		    let line=label+":<br>" +
			HU.select("",[ATTR_STYLE,'width:90%;','filter-property',info.property,ATTR_CLASS,'imdv-filter-enum',ATTR_ID,this.domId('enum_'+ id),'multiple',null,'size',size??Math.min(info.samples.length,showTop?3:5)],options,filter.enumValues,50)+"<br>";
		    add(info,'enums',line);
		}
		return;
	    }

	    if((info.isNumeric() || info.isInt()) && (info.min<info.max)) {
		let min = info.getProperty('filter.min',info.min);
		let max = info.getProperty('filter.max',info.max);		
		filter.minValue = min;
		filter.maxValue = max;
		if(isNaN(filter.min)||filter.min<min) filter.min = min;
		if(isNaN(filter.max) || filter.max>max) filter.max = max;
		filter.type="range";
		let line =
		    HU.leftRightTable(HU.div([ATTR_ID,this.domId('slider_min_'+ id),
					      ATTR_CLASS,CLASS_FILTER_SLIDER_LABEL],Utils.formatNumber(filter.min??min)),
				      HU.div([ATTR_ID,this.domId('slider_max_'+ id),
					      ATTR_CLASS,CLASS_FILTER_SLIDER_LABEL],Utils.formatNumber(filter.max??max)));
		if(showTop) line = HU.div([ATTR_STYLE,HU.css(ATTR_WIDTH,'120px')], line);
		let slider =  HU.div(['slider-min',min,'slider-max',max,'slider-isint',info.isInt(),
				      'slider-value-min',filter.min??info.min,'slider-value-max',filter.max??info.max,
				      'filter-property',info.property,'feature-id',info.id,
				      ATTR_CLASS,CLASS_FILTER_SLIDER,
				      ATTR_STYLE,HU.css("display","inline-block","width","100%")],"");
		if(info.getProperty('filter.animate',false)) {
		    line+=HU.table([ATTR_WIDTH,'100%'],
				   HU.tr([],
					 HU.td([ATTR_WIDTH,'18px'],HU.span(['feature-id',info.id,
									 ATTR_CLASS,HU.classes(CLASS_FILTER_PLAY,CLASS_CLICKABLE),
									 ATTR_TITLE,'Play'],HU.getIconImage(icon_play))) +
					 HU.td([],slider)));
		} else {
		    line+=slider;
		}

		label = HU.b(label)+':';
		if(showTop)
		    line = HU.hbox([label+HU.space(1),line]);
		else 
		    line =  label+'<br>' +line;
		add(info,'sliders',line);
	    }
	});


	if(contents.sliders!='')
	    contents.sliders = HU.div([ATTR_STYLE,HU.css('margin-left','10px','margin-right','20px')],contents.sliders);
	if(contents.first!='')
	    contents.first = HU.div([ATTR_STYLE,HU.css('margin-left','10px','margin-right','20px')],contents.first);	    

	if(this.topHeaderId) {
	    jqid(this.topHeaderId).html('');
	}	
	if(this.getProperty('showInHeader',false)) {
	    if(contents.top.length==0) contents.top.push('');
	}
	if(contents.top.length) {
	    let label =  this.getLabel({addIcon:this.getProperty('showIconInHeader',false),forLegend:true})[0];
	    let top = HU.div([ATTR_STYLE,HU.css('font-weight','bold','text-align','center')], label) +HU.hbox(contents.top.map(c=>{return HU.div([ATTR_STYLE,'margin-right:15px;'], c);}));
	    this.getTopHeader().html(top);
	}


	let widgets = contents.first+contents.enums+contents.sliders+contents.strings;

	if(Utils.stringDefined(widgets) ||contents.top.length) {
	    let update = () =>{
		this.display.featureHasBeenChanged = true;
		this.applyMapStyle(true);
		if($("#"+this.zoomonchangeid).is(':checked')) {
		    this.panMapTo();
		}
		this.updateFeaturesTable();
	    };

	    let clearAll = HU.span([ATTR_STYLE,'margin-right:5px;',
				    ATTR_CLASS,HU.classes(CLASS_CLICKABLE,'imdv-legend-clearall'),
				    ATTR_TITLE,'Clear Filters'],HU.getIconImage('fas fa-eraser',null,LEGEND_IMAGE_ATTRS));

	    this.zoomonchangeid = HU.getUniqueId("andzoom");

	    let maxHeight=this.getProperty('filters.height');
	    widgets = HU.div([ATTR_STYLE,
			      HU.css('padding-bottom','5px',
				     'max-height',maxHeight??'200px',
				     'overflow-y','auto')], widgets);
	    let filtersHeader ='';
	    if(this.getProperty('filter.zoomonchange.show',true)) {
		filtersHeader = HU.checkbox(this.zoomonchangeid,
					    [ATTR_TITLE,'Zoom on change',ATTR_ID,this.zoomonchangeid],
					    this.getZoomOnChange(),
					    HU.span([ATTR_TITLE,'Zoom on change',ATTR_STYLE,'margin-left:12px;'], HU.getIconImage('fas fa-binoculars',[],LEGEND_IMAGE_ATTRS)));
	    }
	    let filtersCount = HU.span([ATTR_ID,this.domId('filters_count')],Utils.isDefined(this.visibleFeatures)?'#'+this.visibleFeatures:'');
	    filtersHeader = HU.leftRightTable(filtersHeader, clearAll);

	    if(this.getProperty('filter.toggle.show',true)) {
		let toggle = HU.toggleBlockNew('Filters ' + filtersCount,filtersHeader + widgets,this.getFiltersVisible(),{separate:true,headerStyle:'display:inline-block;',callback:null});
		this.jq(ID_MAPFILTERS).html(HU.div([ATTR_STYLE,'margin-right:5px;'],toggle.header+toggle.body));
		HU.initToggleBlock(this.jq(ID_MAPFILTERS),(id,visible)=>{this.setFiltersVisible(visible);});
	    } else  {
		filtersHeader+=filtersCount;
		this.jq(ID_MAPFILTERS).html(HU.div([ATTR_STYLE,'margin-right:5px;'],filtersHeader  + 
						   widgets));
		this.setFiltersVisible(true);		    
	    }


	    jqid(this.zoomonchangeid).change(function() {
		_this.setZoomOnChange($(this).is(':checked'));
	    });

	    this.findFilter('.imdv-legend-clearall').click(()=>{
		this.display.featureChanged();
		this.attrs.featureFilters = {};
		this.applyMapStyle();
		this.updateFeaturesTable();
		if($("#"+this.zoomonchangeid).is(':checked')) {
		    this.panMapTo();
		}
	    });
	    this.findFilter(CLASS_FILTER_STRINGS).button().click(function(event) {
		let text = jqid($(this).attr('textareaid'));
		let key = text.attr('filter-property');
		let filter = filters[key]??{};
		filter.type='string';
		filter.stringValue = (text.val()??"").trim();
		filter.stringValues = Utils.split(filter.stringValue,'\n',true,true);
		filter.property = key;
		update();
	    });
    

	    this.findFilter(CLASS_FILTER_STRING).keypress(function(event) {
		let keycode = (event.keyCode ? event.keyCode : event.which);
                if (keycode == 13) {
		    let key = $(this).attr('filter-property');
		    let filter = filters[key]??{};
		    filter.type='string';
		    filter.stringValue = ($(this).val()??"").trim();
		    filter.property = key;
		    update();
		}
	    });
	    this.findFilter('.imdv-filter-enum').change(function(event) {
		let key = $(this).attr('filter-property');
		let filter = filters[key]??{};
		filter.property = key;
		filter.type='enum';
		filter.enumValues=$(this).val();
		update();
	    });

	    let sliderMap = {};
	    
	    
	    this.findFilter(CLASS_FILTER_SLIDER).each(function() {
		let theFeatureId = $(this).attr('feature-id');
		let featureInfo = _this.getFeatureInfo(theFeatureId);
		let onSlide = function( event, ui, force) {
		    let id = featureInfo.property;
		    let filter = filters[id]??{};
		    if(ui.animValues) {
			filter.min = ui.animValues[0];
			filter.max = ui.animValues[1];			
		    } else {
			if(ui.handleIndex==0)
			    filter.min = ui.value;
			else
			    filter.max = ui.value;
		    }

		    filter.property=id;
		    _this.jq('slider_min_'+ featureInfo.getId()).html(Utils.formatNumber(filter.min));
		    _this.jq('slider_max_'+ featureInfo.getId()).html(Utils.formatNumber(filter.max));			    
		    if(force ||_this.getProperty('filter.live') ||  _this.getProperty(featureInfo.getId()+'.filter.live')) {
			update();
			return
		    }
		    if(!_this.sliderThrottle) 
			_this.sliderThrottle=Utils.throttle(()=>{
			    update();
			},500);
		    _this.sliderThrottle();
		};
		let min = +$(this).attr('slider-min');
		let max = +$(this).attr('slider-max');
		let isInt = $(this).attr('slider-isint')=="true";
		let step = 1;
		let range = max-min;
		if(!isInt) {
		    step = range/100;
		} else {
		    if(range>10)
			step = Math.max(1,Math.floor(range/100));		    
		}
		step = featureInfo.getStep(step);
		sliderMap[$(this).attr('feature-id')] = {
		    slider:   $(this),
		    slide:onSlide,
		    min:min,
		    max:max,
		    step:step
		}
		//Round the step
		//		if(step>10) step=parseInt(step);
		let args = {
		    range:true,
		    min: parseFloat(min),
		    max: parseFloat(max),
		    step:step,
		    values:[parseFloat($(this).attr('slider-value-min')),
			    parseFloat($(this).attr('slider-value-max'))],
		    slide: onSlide};
		$(this).slider(args);		
	    });

	    this.findFilter(CLASS_FILTER_PLAY).click(function() {
		let playing = $(this).attr('playing');
		let info = _this.filterInfo[$(this).attr('feature-id')];
		if(!info) return;
		let animation = _this.animationInfo[info.id];
		if(!animation) {
		    _this.animationInfo[info.id] = animation  = {};
		}
		let sliderInfo = sliderMap[info.id];
		if(!sliderInfo) return;
		let slider = sliderInfo.slider;
		if(Utils.isDefined(playing) && playing==='true') {
		    $(this).html(HU.getIconImage(icon_play));
		    $(this).attr('playing',false);
		    if(animation.timeout) {
			clearTimeout(animation.timeout);
			animation.timeout = null;
		    }
		} else {
		    $(this).html(HU.getIconImage(icon_stop));
		    $(this).attr('playing',true);
		    let step = (_values) =>{
			let values = _values?? slider.slider('values');
			if(values[1]>=sliderInfo.max) {
			    $(this).html(HU.getIconImage(icon_play));
			    $(this).attr('playing',false);			    
			    return;
			}
			values = [values[0],values[1]];
			let stepSize = parseFloat(info.getProperty('filter.animate.step',sliderInfo.step*2));
			values[1]=Math.min(sliderInfo.max,values[1]+stepSize);
			slider.slider('values',values);
			sliderInfo.slide({},{animValues:values},true);
			animation.timeout = setTimeout(step,info.getProperty('filter.animate.sleep',1000));
		    };
		    let values = slider.slider('values');
		    //If at the end then set to the start
		    if(values[1]>=sliderInfo.max) {
			values[1] = values[0];
			step(values);
		    } else {
			step();
		    }
		}

	    });

	}
    },
    handleMapLoaded: function(map,layer) {
	//Check if there are any KML ground overlays
	//TODO: limit the number we add?
	if(layer?.protocol?.format?.groundOverlays) {
	    let format = layer.protocol.format;
	    let text=(node,tag)=>{
		let child = format.getElementsByTagNameNS(node,'*',tag);
		if(!child.length) return null;
		return child[0].innerHTML;
	    };
	    this.imageLayers=[];
	    let cnt=0;
	    format.groundOverlays.forEach(go=>{
		let icons = format.getElementsByTagNameNS(go,'*','Icon');
		let ll = format.getElementsByTagNameNS(go,'*','LatLonBox');
		if(!icons.length || !ll.length) return;
		ll =ll[0];
		let name = text(go,'name');
		let url = text(icons[0],'href');
		if(!url) return;
		url = url.replace(/&amp;/g,'&');
		let north = text(ll,'north');
		let south = text(ll,'south');
		let east = text(ll,'east');
		let west = text(ll,'west');			    
		let obj = {
		    id:'groundoverlay_'+(cnt++),
		    url:url,
		    name:name,
		    north:north,west:west,south:south,east:east
		}
		this.imageLayers.push(obj);
		//We might have a bunch of overlays so don't add them if there are lots
		this.isImageLayerVisible(obj,cnt<=3);
	    });
	}

	this.mapLoaded = true;
	this.makeFeatureFilters();
	this.applyMapStyle();

	if(this.mapLayer) {
	    //Not now
	    //
	    //	    this.addBuffer(this.mapLayer.features);
	}
    },
    addBuffer:function(features) {
	if(!features) return;
	if(!MapUtils.loadTurf(()=>{this.addBuffer(features);})) {
	    return;
	}
	let polygons = [];
	features.forEach((f,idx)=>{
	    if(idx>50) return;
	    let points = [];
	    let obj;
	    let geom = f.geometry;
	    if(false && geom.CLASS_NAME=='OpenLayers.Geometry.LineString') {
//		console.dir(geom);
		geom.components.forEach(point=>{
		    let p = this.getMap().transformProjPoint(point);
		    points.push([p.x,p.y]);
		});
		obj = turf.multiPoint(points);
	    } else {
		let centroid = geom.getCentroid();
		let p = this.getMap().transformProjPoint(centroid);
		obj = turf.point([p.x,p.y]);
	    }
	    if(obj) {
//		console.dir(obj)
		let buffered = turf.buffer(obj, 10, {units: 'meters'});
		polygons.push(buffered);
	    }
	});
	if(polygons.length>0) {
	    let collection = turf.featureCollection(polygons);
	    console.log(collection);
	    this.display.createGeoJsonLayer('Buffer',collection,null,{color:'red'});
	} else {
	    console.log('Could not find features to buffer');
	}
    },
    applyMacros:function(template, attributes, macros) {
	if(!macros) macros =  Utils.tokenizeMacros(template);
	let infos = this.getFeatureInfoList();
	if(attributes) {
	    let attrs={};
	    infos.forEach(info=>{
		let attr=info.property;
		let value;
		if (typeof attributes[attr] == 'object' || typeof attributes[attr] == 'Object') {
                    let o = attributes[attr];
		    if(o)
			value = "" + o["value"];
		    else
			value = "";
		} else {
                    value = "" + attributes[attr];
		}
		value = info.format(value);
		let _attr = attr.toLowerCase();
		attrs[attr] = attrs[_attr] = value;			
	    });
	    template = macros.apply(attrs);
	}
	if(template.indexOf('${default}')>=0) {
	    let columns = [];
	    let labelMap = {};
	    let infoMap = {};
	    infos.forEach(info=>{
		infoMap[info.property] = info;
		if(info.showPopup()) {
		    columns.push(info.property);
		    labelMap[info.property] = info.getLabel();
		}
	    });
	    let formatter = (attr,value)=>{
		let info = infoMap[attr];
		if(info) {
		    value = info.format(value);
		}
		return value;
	    };
	    let labelGetter = attr=>{
		return labelMap[attr];
	    }
	    template = template.replace('${default}',MapUtils.makeDefaultFeatureText(attributes,columns,
										     formatter,labelGetter));
	}
	return template;
    },

    initColorTableDots:function(obj, dialog) {
	let _this  = this;
	let dots = dialog.find('.display-colortable-dot-item');
	dots.css({cursor:'pointer',title:'Click to show legend'});
	dots.addClass(CLASS_CLICKABLE);
	let select = jqid(_this.domId('enum_'+ Utils.makeId(obj.property)));
	select.find('option').each(function() {
	    if($(this).prop('selected')) {
		let value = $(this).prop(ATTR_TITLE);
		let dot = dialog.find('.display-colortable-dot-item[label="' +value+'"]');
		dot.addClass('display-colortable-dot-item-selected');
	    }
	});

	dots.click(function(event) {
	    let meta = event.metaKey || event.ctrlKey;
	    let label = $(this).attr('label');
	    let selected = $(this).hasClass('display-colortable-dot-item-selected');
	    let option = select.find('option[value="' +label+'"]');
	    if(!meta) {
		select.find('option').prop('selected',null);
		dots.removeClass('display-colortable-dot-item-selected');
	    }				
	    if(!selected) {
		$(this).addClass('display-colortable-dot-item-selected');
		option.prop('selected','selected');
	    } else {
		$(this).removeClass('display-colortable-dot-item-selected');
		option.prop('selected',null);
	    }
	    select.trigger('change');
	});
    },
    

    addFillImage:function(features) {
	features.forEach((feature,idx)=>{
	    if(!Utils.stringDefined(feature?.attributes.fillimage)) return;
	    let points =this.getFeaturePoints(feature);
	    if(!points || points.length!=5) return;
	    let tmp = [];
	    points.forEach(p=>{
		let pt = MapUtils.createPoint(p.x,p.y);
		pt = this.getMap().transformProjPoint(pt);
		tmp.push(pt.y,pt.x);
	    });
	    points = tmp;
	    let style = {strokeColor:'transparent',imageUrl:feature.attributes.fillimage};
	    let mapGlyph = new MapGlyph(this.display,GLYPH_IMAGE,{type:GLYPH_IMAGE},null,style,
					true,{geometryType:'OpenLayers.Geometry.LineString',points:points});
	    this.addChildGlyph(mapGlyph);
	    mapGlyph.isEphemeral = true;
	    mapGlyph.checkImage(feature,true);
	});
    },
    getMapFeaturesToGrid: function() {
	if(!this.mapLayer || !this.mapLoaded) {
	    return null;
	}
	let features= this.mapLayer.features;
	return features;
    },

    applyMapStyle:function(skipLegendUI) {
	let debug = false;
	if(debug)   console.log("applyMapStyle:" + this.getName());
    	this.applyChildren(child=>{child.applyMapStyle(skipLegendUI);});
	let _this = this;
	let features = this.getMapFeatures();
	if(!features) {
	    return;
	}
	if(!this.originalFeatures) this.originalFeatures = features;
	else features = this.originalFeatures;

	if(!this.mapLayer) return;
	let changedFeaturesList = false;
	if(this.attrs.subsetSimplify) {
	    this.haveChangedGeometry=true;
//	    console.log('prune geometry');
	    this.mapLayer.removeFeatures(features);
	    this.originalFeatures.forEach(feature=>{
		if(!feature.geometry.originalComponents) {
		    feature.geometry.originalComponents = [...feature.geometry.components];
		}
		feature.geometry.components.length=1;
	    });
	    this.mapLayer.addFeatures(features);	    
	} else if(this.haveChangedGeometry) {
//	    console.log('reset geometry');
	    this.haveChangedGeometry = false;
	    this.mapLayer.removeFeatures(features);
	    features.forEach(feature=>{
		if(feature.geometry.originalComponents) {
		    feature.geometry.components = [...feature.geometry.originalComponents];
		}
	    });
	    this.mapLayer.addFeatures(features);	    	    
	}

	if(Utils.isNumber(this.attrs.subsetSkip) && this.attrs.subsetSkip>0) {
	    let tmp = [];
	    let cnt = 0;
	    features.forEach((feature,idx)=>{
		cnt--;
		if(cnt<0) {
		    tmp.push(feature);
		    cnt = this.attrs.subsetSkip;
		}
	    });
	    changedFeaturesList = true;
	    this.mapLayer.removeFeatures(this.originalFeatures);
	    this.mapLayer.addFeatures(tmp);	    
	    features = this.mapLayer.features;
	} 

	if(this.attrs.subsetReverse) {
	    let tmp = [];
	    features.forEach(feature=>{
		tmp.unshift(feature);
	    });
	    changedFeaturesList = true;
	    this.mapLayer.removeFeatures(features);
	    this.mapLayer.addFeatures(tmp);	    
	    features = tmp;
	}

	if(!changedFeaturesList && this.originalFeatures.length!=features.length) {
	    this.mapLayer.removeFeatures(this.mapLayer.features);
	    this.mapLayer.addFeatures(this.originalFeatures);	    
	    features = this.originalFeatures;
	}


	if(!skipLegendUI && this.canDoMapStyle() && !this.isGroup()) {
	    this.makeFeatureFilters();
	}

	//Check for fillimage
	if(features.length>0 && features[0].attributes?.fillimage) {
	    this.addFillImage(features);
	}
	let style = this.style;
	
	if(Utils.isDefined(style.externalGraphic_cleared)) {
	    if(Utils.isTrue(style.externalGraphic_cleared)) {
		features.forEach(f=>{
		    if(f.style)
			f.style.externalGraphic = null;
		});
	    }
	    delete style['externalGraphic_cleared'];	    
	}
	let rules = this.getMapStyleRules();
//	if(debug) console.dir("\tmapStyleRules",rules);
	let useRules = [];
	if(rules) {
	    rules = rules.filter(rule=>{
		if(rule.type=='use') {
		    useRules.push(rule);
		    return false;
		}
		return Utils.stringDefined(rule.property);
	    });
	}
	if(features) {
	    features.forEach((feature,idx)=>{
		feature.featureIndex = idx;
	    });
	}

	if(this.mapLabels) {
	    this.display.removeFeatures(this.mapLabels);
	    this.mapLabels = null;
	}

	//Apply the base style here
	let fillProperty = this.getProperty('map.property.fillColor');
	let fillOpacityProperty = this.getProperty('map.property.fillOpacity');
	let strokeProperty = this.getProperty('map.property.strokeColor');
	let labelProperty = this.getProperty('map.property.label');	


//	if(debug)   console.dir(style);
	if(this.mapLayer)
	    this.mapLayer.style = style;

	if(features) {
	    features.forEach((f,idx)=>{
		let featureStyle = Utils.clone(style);
		if(f.attributes) {
		    if(fillProperty && Utils.stringDefined(f.attributes[fillProperty])) 
			featureStyle.fillColor=f.attributes[fillProperty];
		    if(fillOpacityProperty && Utils.stringDefined(f.attributes[fillOpacityProperty]))  
			featureStyle.fillOpacity=f.attributes[fillOpacityProperty];
		    if(labelProperty && Utils.stringDefined(f.attributes[labelProperty]))  {
			let label = f.attributes[labelProperty];
			if(true || label.indexOf('disproportionate')>=0) {
			    if(label.length>20) {
				let tmp = Utils.splitList(label.split(' '),4);
				label = '';
				tmp.forEach(l=>{
				    label+=Utils.join(l,' ')+'\n'
				});
			    }
			    //			    label = "hello there\nhow are you\nI am fine"
			    featureStyle = Utils.clone(featureStyle,{
				strokeColor:'transparent',
				textBackgroundFillColor:featureStyle.fillColor,
				textBackgroundPadding:2,
				textBackgroundShape:'rectangle',				
				labelXOffset:4,
				labelYOffset:-8,
				labelAlign:'lt',
				fontSize:'6pt',
				label:label});
//			    featureStyle.fillColor = 'transparent'
			}
		    }
		}
		if(debug && idx<3)   console.dir("\tfeature style:",featureStyle.fillColor);
		ImdvUtils.applyFeatureStyle(f, featureStyle);
		f.originalStyle = Utils.clone(style);			    
	    });
	}


	//Check for any rule based styles
	let attrs = features.length>0?features[0].attributes:{};
	let keys  = Object.keys(attrs);
	if(rules && rules.length>0) {
	    this.mapLayer.style = null;
	    let seen = {};
	    let uniqueRules = rules.filter(rule=>{
		let key = rule.property+'__'+rule.value;
		if(seen[key]) return false;
		seen[key] = true;
		return true;
	    });
	    if(debug) console.dir("\tadding styleMap unique rules",uniqueRules);
	    this.mapLayer.styleMap = this.display.getMap().getVectorLayerStyleMap(this.mapLayer, style,uniqueRules);
	    features.forEach((f,idx)=>{
		f.fidx=idx;
		f.style=null;
	    });
	} 

	let applyColors = (obj,attr,stringList,debug)=>{
	    if(!obj || !Utils.stringDefined(obj?.property))  return;
	    if(features.length==0) return;
	    //make a copy because we can change it later
	    //Maybe not since the state doesn't get set
	    //	    obj  =$.extend({},obj);
	    if(debug)
		console.log('applyColors','#features:',features.length,attr,obj.max);
	    let strings  =[]
	    let prop =obj.property;
	    let min =Number.MAX_VALUE;
	    let max =Number.MIN_VALUE;
	    let ct =Utils.getColorTable(obj.colorTable,true);
	    let alpha_ct = ct;
	    if(this.getProperty('colortable.alpha')) {
		alpha_ct =  this.display.addAlpha(ct,+this.getProperty('colortable.alpha'));
	    }
	    let anyNumber =  false;
	    features.forEach((f,idx)=>{
		let value = this.getFeatureValue(f,prop);
		if(isNaN(parseFloat(value))) {
		    if(!strings.includes(value)) {
			strings.push(value);
		    }
		} else {
		    anyNumber =  true;
		    min = Math.min(min,value);
		    max = Math.max(max,value);		    
		}
	    });

	    if(!anyNumber) {
		if(debug)
		    console.log('\tno numbers - is enumeration');
		obj.min =min = 0;
		obj.max = max= strings.length-1;
		obj.isEnumeration = true;
		obj.stringValues=[];
	    } else {
		if(debug)
		    console.log('\thas numbers - not enumeration');
		obj.isEnumeration = false;
		obj.stringValues=null;
		if(!Utils.isDefined(obj.min))
		    obj.min = min;
		if(!Utils.isDefined(obj.max))
		    obj.max = max;		
	    }
	    strings = strings.sort((a,b)=>{
		return a.localeCompare(b);
	    });

	    if(obj.stringValues) {
		strings.forEach((s,idx)=>{
		    let color = idx<ct.length?ct[idx]:ct[idx-1];
		    obj.stringValues.push({value:s,color:color});
		});
	    }

	    //If there was no numbers then we pass back the strings
	    if(!anyNumber) {
		stringList.push(...strings);
	    }
	    let range = obj.max-obj.min;
	    if(debug) console.log('applyColors min:' + obj.min +' max:' + obj.max);
	    features.forEach((f,idx)=>{
		let value = this.getFeatureValue(f,prop);
		if(!Utils.isDefined(value)) {
		    return;
		}
		let index;
		if(obj.isEnumeration) {
		    index = (strings.indexOf(value)%ct.length);
		} else {
		    value = +value;
		    let percent = (value-obj.min)/range;
		    index = Math.max(0,Math.min(ct.length-1,Math.round(percent*ct.length)));
		}
		if(!f.style)
		    f.style = $.extend({},style);
		f.style[attr]=alpha_ct[index];
		if(f.originalStyle) f.originalStyle[attr]=ct[index];		
		if(debug && idx<3) {
		    console.log('\t'+attr+'='+f.style[attr]);
//		    console.dir(f.style);
		}
	    });
	};


	this.fillStrings = [];
	this.strokeStrings = [];		
	applyColors(this.attrs.fillColorBy,'fillColor',this.fillStrings);
	applyColors(this.attrs.strokeColorBy,'strokeColor',this.strokeStrings);	

	if(useRules.length>0) {
	    if(debug) console.log("\tuseRules:" + useRules?.length);
	    useRules.forEach(rule=>{
		let styles = [];
		let styleMap = {};
		Utils.split(rule.style,'\n',true,true).forEach(s=>{
		    let toks = [];
		    let index = s.indexOf(':');
		    if(index>=0) {
			toks.push(s.substring(0,index).trim());
			toks.push(s.substring(index+1).trim());			
		    }
		    if(toks.length!=2) return;
		    styleMap[toks[0].trim()] = toks[1].trim();
		    styles.push(toks[0].trim());
		});

		features.forEach((f,idx)=>{
		    if(!f.style) {
			f.style = $.extend({},style);
		    }
		    if(!f.originalStyle) {
			f.originalStyle = $.extend({},f.style);
		    }
		    let value=this.getFeatureValue(f,rule.property);
		    if(!value) return;
		    styles.forEach(style=>{
			let v = styleMap[style];
			v = v.replace("${value}",value);
			if(v.startsWith('js:')) {
			    v = v.substring(3);
			    try {
				v = eval(v);
			    } catch(err) {
				console.error('Error evaluating style rule:' + v);
			    }
			}
			f.style[style] = v;
			f.originalStyle[style] = v;			
		    });
		});
	    });
	}	    
	

	//Add the map labels at the end after we call checkVisible
	let needToAddMapLabels = false;
	if(Utils.stringDefined(this.getMapLabelsTemplate())) {
	    let maxLength = parseInt(this.attrs.labels_maxlength??1000);
	    let maxLineLength = parseInt(this.attrs.labels_maxlinelength??1000);
	    needToAddMapLabels = true;
	    this.mapLabels = [];
	    let markerStyle = 	$.extend({},this.style);
	    markerStyle.pointRadius=0;
	    markerStyle.externalGraphic = null;
	    let template = this.getMapLabelsTemplate().replace(/\\n/g,'\n');
	    let macros = Utils.tokenizeMacros(template);
	    features.forEach((feature,idx)=>{
		let pt = feature.geometry.getCentroid(true); 
		let labelStyle = $.extend({},markerStyle);
		let label = this.applyMacros(template, feature.attributes,macros);
		if(label.length>maxLength) {
		    label = label.substring(0,maxLength)+'...';
		}
		if(maxLineLength>0) {
		    let tmp ='';
		    let cnt = 0;
		    let lastChar = '';
		    for(let i=0;i<label.length;i++ ) {
			let nextChar = label[i];
			if(cnt++>maxLineLength) {
			    if(lastChar!=' ' && nextChar!=' ') tmp+='-';
			    tmp+='\n';
			    cnt=0;
			}
			lastChar = nextChar;
			tmp+=nextChar;
		    }
		    label = tmp.trim();
		}
		labelStyle.label = label;
		let mapLabel = MapUtils.createVector(pt,null,labelStyle);
		mapLabel.point = pt;
		feature.mapLabel  = mapLabel;
		this.mapLabels.push(mapLabel);
	    });
	}

	this.visibleFeatures = 0;
	this.applyFeatureFilters(features);


	if(this.attrs.fillColors) {
	    //	let ct = Utils.getColorTable('googlecharts',true);
	    let ct = Utils.getColorTable('d3_schemeCategory20',true);	
	    let cidx=0;
	    features.forEach((f,idx)=>{
		f.style = f.style??{};
		cidx++;
		if(cidx>=ct.length) cidx=0;
		if(f.originalStyle) f.originalStyle.fillColor=ct[cidx];
		f.style.fillColor=ct[cidx]
	    });
	}


	let indexToGroup = {
	};
	this.getStyleGroups().forEach(group=>{
	    group.indices.forEach(index=>{
		indexToGroup[index] = group;
	    });
	});
	features.forEach((f,idx)=>{
	    let group = indexToGroup[idx];
	    if(group) {
		f.style = $.extend({},f.style);
		$.extend(f.style,group.style)
		if(!f.originalStyle)f.originalStyle={};
		$.extend(f.originalStyle,group.style)
	    }
	});

	this.mapLayer.features.forEach(f=>{
	    if(f.style && f.style.fillPattern && !Utils.stringDefined(f.style.fillColor)) {
		f.style.fillColor='transparent'
	    }
	});
	this.checkVisible();
	if(needToAddMapLabels) {
	    this.display.addFeatures(this.mapLabels);
	}	    
	ImdvUtils.scheduleRedraw(this.mapLayer);
    },
    applyFeatureFilters:function(features) {
	let debug = false;
//	debug = true;
	let redraw = false;
	if(!features)  {
	    features=this.mapLayer?.features;
	    redraw = true;
	}
	if(!features) return;
	let featureFilters = this.attrs.featureFilters ??{};
	let rangeFilters = [];
	let stringFilters =[];
	let enumFilters =[];	
	for(a in featureFilters) {
	    let filter= featureFilters[a];
	    if(!filter.property) {
		continue;
	    }
	    let info =this.getFeatureInfo(filter.property);
	    if(!info) {
		continue;
	    }
	    if(info && !info.showFilter()) continue;
	    if(filter.type=="string") {
		if(Utils.stringDefined(filter.stringValue)) stringFilters.push(filter);
	    } else if(filter.type=="enum") {
		if(filter.enumValues && filter.enumValues.length>0) enumFilters.push(filter);
	    } else {
		if(Utils.isDefined(filter.min) || Utils.isDefined(filter.max)) {
		    if(filter.min!=filter.minValue || filter.max!=filter.maxValue) {
			rangeFilters.push(filter);
		    }
		}
	    }
	}


	let redrawFeatures = false;
	let max =-1;
	let text = this.getProperty('showTextSearch',null,true)?this.getProperty('searchtext',null,true):null;
//	debug = true;
	if(!Utils.stringDefined(text)) { text=null;}
	else text = text.toLowerCase();
	features.forEach((f,idx)=>{
	    let visible = true;
	    if(debug && idx<5) console.log("feature check filter:");
	    rangeFilters.every(filter=>{
		let value=this.getFeatureValue(f,filter.property);
		if(Utils.isDefined(value)) {
		    max = Math.max(max,value);
		    visible = value>=filter.min && value<=filter.max;
		    if(debug && idx<5) console.log("\trange:",filter,value,visible);
		}
		return visible;
	    });
	    if(visible) {
		stringFilters.every(filter=>{
		    let value=this.getFeatureValue(f,filter.property)??'';
		    if(Utils.isDefined(value)) {
			value = String(value);
			let _value= value.toLowerCase();
			if(filter.stringValues) {
			    visible=false;
			    filter.stringValues.every(v=>{
				if(v=='*' || value.indexOf(v)>=0 || _value.indexOf(v)>=0) {
				    visible=true;
				    return false;
				}
				return true;
			    });
			} else {
			    visible = filter.stringValue=='*' || value.indexOf(filter.stringValue)>=0|| _value.indexOf(filter.stringValue)>=0
			}
			if(debug && idx<5) console.log("\tstring:",filter,value,visible);
		    }
		    return visible;
		});
	    }
	    if(visible && text) {
		if(f.attributes) {
		    let numStrings = 0;
		    let numMatched = 0;
		    let matched  = false;
		    Object.keys(f.attributes).every(key=>{
			let value = f.attributes[key];
			if(value  && typeof value == 'string') {
			    numStrings++;
			    matched = value.toLowerCase().indexOf(text)>=0;
			    if(matched) return false;
			}
			return true;
		    })
		    if(numStrings && !matched) {
			if(debug && idx<5) console.log("\ttext:",text);
			visible=false;
		    }
		}
	    }


	    if(visible) {
		enumFilters.every(filter=>{
		    let value=this.getFeatureValue(f,filter.property)??'';
		    visible =filter.enumValues.includes(value);
		    if(debug && idx<5) console.log("\tenum",filter,value);
		    return visible;
		});
	    }		
	    
	    if(visible) this.visibleFeatures++;
	    f.isVisible  = visible;
	    f.isFiltered=!visible;
	    MapUtils.setFeatureVisible(f,visible && !f.forceHidden);
	    if(f.mapLabel) {
		redrawFeatures = true;
		f.mapLabel.isFiltered=!visible;
		MapUtils.setFeatureVisible(f.mapLabel,visible);
	    }
	});

	this.jq('filters_count').html('#' + this.visibleFeatures);
	if(redraw) {
	    ImdvUtils.scheduleRedraw(this.mapLayer);
	}

	if(redrawFeatures) {
	    this.display.redraw();
	}
    },
    
    checkRings:function(points) {
	if(!this.features[0]){
	    console.log("range rings has no features");
	    return
	}

	let style = $.extend({},this.features[0].style);
	style.strokeColor='transparent';
	this.features[0].style = style;

	let pt = this.features[0].geometry.getCentroid();
	let center = this.display.getMap().transformProjPoint(pt)

	if(this.extraFeatures) this.display.removeFeatures(this.extraFeatures);
	let ringStyle = {};
	if(this.attrs.rangeRingStyle) {
	    //0,fillColor:red,strokeColor:blue
	    Utils.split(this.attrs.rangeRingStyle,'\n',true,true).forEach(line=>{
		let toks = line.split(',');
		ringStyle[toks[0]] = {};
		for(let i=1;i<toks.length;i++) {
		    let toks2 = toks[i].split(':');
		    ringStyle[toks[0]][toks2[0]] = toks2[1];
		}
	    });
	}
	let labels = [];
	if(Utils.stringDefined(this.attrs.rangeRingLabels))
	    labels = Utils.split(this.attrs.rangeRingLabels);
	this.setExtraFeatures(this.display.makeRangeRings(center,this.getRadii(),this.style,this.attrs.rangeRingAngle,ringStyle,labels));
    },
    setExtraFeatures:function(features) {
	this.extraFeatures = features;
	if(this.extraFeatures) {
	    this.extraFeatures.forEach(f=>{
		f.mapGlyph=this;
		MapUtils.setFeatureVisible(f,this.isVisible());
	    });
	    this.display.addFeatures(this.extraFeatures);
	}		
    },
    applyStyle:function(style,skipChangeNotification,isForDataIcon) {
	if(style && style.label && style.label.indexOf('${name}')>=0) {
	    this.attrs.labelTemplate = style.label;
	    style.label = style.label.replace('${name}',this.getName());
	}  else {
	    this.attrs.labelTemplate = null;
	}

	if(style) {
	    this.style = style;
	}
	//check for the data icon state
	if(this.isDataIconCapable() && !isForDataIcon) {
	    this.resetDataIconOriginal();
	}

	this.applyMapStyle();
	if(this.getMapServerLayer()) {
	    if(Utils.isDefined(this.style.opacity)) {
		this.getMapServerLayer().opacity = +this.style.opacity;
		this.getMapServerLayer().setVisibility(false);
		this.getMapServerLayer().setVisibility(true);
		ImdvUtils.scheduleRedraw(this.getMapServerLayer());
	    }
	}




	let tmpStyle= this.getStyle(true);
	this.features.forEach(feature=>{
	    if(feature.style && !feature.fixedStyle) {
		$.extend(feature.style,tmpStyle);
	    }
	});	    
	if(this.isFixed()) {
	    this.addFixed();
	}
	if(this.isRings()){
	    this.checkRings();
	}

	if(!skipChangeNotification)
	    this.display.featureChanged(true);
    },
    
    vertexDragged:function(feature,vertex,pixel) {
	this.display.checkSelected(this);
    },
    move:function(dx,dy) {
	let pts = this.attrs.originalPoints;
	if(pts) {
	    //Run through the points, txfm to proj, move, txfm to latlon
	    for(let i=0;i<pts.length;i+=2) {
		let pt = MapUtils.createPoint(pts[i+1], pts[i]);
		pt = this.getMap().transformLLPoint(pt);
		pt.x+=dx; pt.y+=dy;
		pt = this.getMap().transformProjPoint(pt);
		pts[i] = pt.y;
		pts[i+1] = pt.x;
	    }
	}
	if(this.getUseEntryLocation()) {
	    this.setUseEntryLocation(false);
	}
	if(this.extraFeatures){
	    this.extraFeatures.forEach(feature=>{
		feature.geometry.move(dx,dy);
		feature.layer.drawFeature(feature);
	    });
	}

	this.features.forEach(feature=>{
	    feature.geometry.move(dx,dy);
	    feature.layer.drawFeature(feature);
	});
	if(this.image) {
	    this.image.extent.left+=dx;
	    this.image.extent.right+=dx;	    
	    this.image.extent.top+=dy;
	    this.image.extent.bottom+=dy;
	    this.image.moveTo(this.image.extent,true,true);
	}

	if(this.getParentGlyph()?.isMultiEntry()) {
	    this.overrideLocation = this.getPoints({});
	}

	this.display.checkSelected(this);
    },
    removeImage:function() {
	if(this.image) {
	    this.display.getMap().removeLayer(this.image);
	    this.image=null;
	}
    },
    getMap:function() {
	return this.display.getMap();
    },
    setRotation:function(angle) {
	this.style.rotation =angle;
	if(!this.image) return;
	if(this.image && this.image.imageHook) {
	    this.image.imageHook();
	}
	let feature = this.features[0];
	if(!feature) return
	let points =this.getFeaturePoints(feature);
	if(!points) {
	    console.log("MapGlyph.setRotation: no points");
	    return;
	}
	let ext = this.image.extent;
	let c  =ext.getCenterPixel();
	[[ext.left,ext.top],[ext.right,ext.top],[ext.right,ext.bottom],[ext.left,ext.bottom],[ext.left,ext.top]].forEach((tuple,idx)=>{
	    let x = tuple[0];
	    let y = tuple[1];		
	    let r = Utils.rotate(c.x, c.y, x, y, this.style.rotation,true);
	    points[idx].x=r.x;
	    points[idx].y=r.y;	    
	});
	this.display.redraw(this);
    },
    getFeaturePoints:function(feature) {
	if(!feature || !feature.geometry) return null;
	let components = feature.geometry.components;
	if(components[0]&&components[0].components) return components[0].components;
	return components;
    },
    checkImage:function(feature,applyRotationFromFeature) {
	if(this.image) {
	    if(Utils.isDefined(this.image.opacity)) {
		this.style.imageOpacity=this.image.opacity;
	    }
	}
	if(!this.style.imageUrl) {
//	    console.log('MapGlyph.checkImage: no image url');
	    return;
	}
	feature = feature??this.features[0];
	if(!feature) {
//	    console.log('MapGlyph.checkImage: no feature');
	    return

	}
	let points =this.getFeaturePoints(feature);
	if(!points) {
	    console.log('MapGlyph.checkImage: no points');
	    return
	}
	let bounds = MapUtils.createBoundsFromPoints(points);
	let rotation = Utils.getRotation(points);
	let c  =bounds.getCenterPixel();	
	let rotatedPoints=points.map(p=>{
	    return Utils.rotate(c.x, c.y, p.x,p.y, rotation.angle);
	});
	if(applyRotationFromFeature) this.style.rotation = rotation.angle-180
	bounds= MapUtils.createBoundsFromPoints(rotatedPoints);
	if(this.image) {
	    this.image.extent = bounds;
	    this.image.moveTo(bounds,true,true);
	} else {
	    bounds = this.getMap().transformProjBounds(bounds);
	    this.image=  this.getMap().addImageLayer(this.getName(),this.getName(),"",this.style.imageUrl,true,  bounds.top,bounds.left,bounds.bottom,bounds.right);
	    this.initImageLayer(this.image);
	    if(Utils.isDefined(this.style.imageOpacity)) {
		this.image.setOpacity(this.style.imageOpacity);
	    }
	}
	this.setRotation(this.style.rotation);
    },
    getImageTransform:function() {
	let transform = '';
	if(Utils.stringDefined(this.style.transform)) 
	    transform = this.style.transform;
	if(Utils.isDefined(this.style.rotation) && this.style.rotation!=0)
	    transform += ' rotate(' + this.style.rotation +'deg)';
	if(!Utils.stringDefined(transform))  transform=null;
	return transform;
    },

    initImageLayer:function(image) {
	this.image = image;
	image.imageHook = (image)=> {
	    let transform=this.getImageTransform();
	    let childNodes = this.image.div.childNodes;
	    for(let i = 0, len = childNodes.length; i < len; ++i) {
                let element = childNodes[i].firstChild || childNodes[i];
                let lastChild = childNodes[i].lastChild;
                if (lastChild && lastChild.nodeName.toLowerCase() === "iframe") {
		    element = lastChild.parentNode;
                }
		if(element.style)
		    element.style.transform=transform;
		element.style['clip-path']=  this.style.clippath;
		if(this.style.imagecss) {
		    Utils.split(this.style.imagecss,'\n',true,true).forEach(line=>{
			let toks = Utils.split(line,'=',true,true);
//			console.log(toks[0]+':'+ toks[1]);
			element.style[toks[0]] = toks[1];
		    });
		}

		element.style.filter = this.getStyleFromTree('imagefilter');
		//                    OpenLayers.Util.modifyDOMElement(element, null, null, null, null, null, null, null);
	    }
	}
    },	
    getDisplayAttrs: function() {
	return this.attrs.displayAttrs;
    },
    applyDisplayAttrs: function(attrs) {
	if(this.displayInfo && this.displayInfo.display) {
	    this.displayInfo.display.deleteDisplay();
	    this.displayInfo.display = null;
	    jqid(this.displayInfo.divId).remove();
	    jqid(this.displayInfo.bottomDivId).remove();			
	}
	this.addData(attrs,false);
    },
    isVisible: function() {
	return this.attrs.visible??true;
    },
    getDeclutterLabels:function() {
	if(Utils.isDefined(this.attrs.declutter_labels))
	    return this.attrs.declutter_labels;
	return this.getProperty('declutter.labels',true);
    },
    setShowMarkerWhenNotVisible:function(v) {
	this.attrs.showMarkerWhenNotVisible = v;
	return this;
    },
    getZoomOnChange:function() {
	return this.attrs.zoomOnChange;
    },
    setZoomOnChange:function(v) {
	this.attrs.zoomOnChange = v;
	return this;
    },
    getMapPointsRange:function() {
	return this.attrs.mapPointsRange;
    },
    setMapPointsRange:function(v) {
	this.attrs.mapPointsRange  = v;
	return this;
    },    
    getMapLabelsTemplate:function() {
	return this.attrs.mapLabelsTemplate;
    },
    setMapLabelsTemplate:function(v) {
	this.attrs.mapLabelsTemplate = v;
	return this;
    },	   

    getShowMarkerWhenNotVisible:function() {
	return this.attrs.showMarkerWhenNotVisible;
    },
    getVisibleLevelRange:function(skipParent) {
	let r =this.attrs.visibleLevelRange;
	if(!skipParent && (!r || !Utils.isDefined(r.min)) && this.getParentGlyph()) {
	    return this.getParentGlyph().getVisibleLevelRange();
	}
	return this.attrs.visibleLevelRange;
    },

    setVisible:function(visible,callCheck,highlighted,skipChildren) {
	if(this.isZoom()) {
	    this.panMapTo(true);
	    return;
	}
	this.highlighted = highlighted;
	if(!visible) {
	    if(this.stepMarker) {
		this.display.removeFeatures([this.stepMarker]);
	    }
	}

	this.attrs.visible = visible;
	this.checkInMapLabel();
	if(!skipChildren) {
    	    this.applyChildren(child=>{child.setVisible(visible, callCheck);});
	}

	Utils.forEach(this.extraFeatures,f=>{MapUtils.setFeatureVisible(f,visible);});

	if(this.canHaveChildren()) {
	    if(!visible) this.attrs[PROP_LAYERS_ANIMATION_ON]=false;
	    this.checkLayersAnimationButton();
	}


	if(callCheck) {
	    this.checkVisible();
	}


	this.checkMapLayer();

	let legend = this.getLegendDiv();
	legend.removeClass(CLASS_LEGEND_LABEL_INVISIBLE);
	legend.removeClass(CLASS_LEGEND_LABEL_HIGHLIGHT);
	if(this.getVisible()) {
	    if(this.highlighted) {
		legend.addClass(CLASS_LEGEND_LABEL_HIGHLIGHT);
	    } 
	} else {
	    legend.addClass(CLASS_LEGEND_LABEL_INVISIBLE);
	}

	if(this.topHeaderId) {
	    if(this.getVisible()) {
		jqid(this.topHeaderId).removeClass(CLASS_LEGEND_LABEL_INVISIBLE);
	    } else {
		jqid(this.topHeaderId).addClass(CLASS_LEGEND_LABEL_INVISIBLE);
	    }
	}
	this.checkDataIconMenu();	
    },
    getVisible:function() {
	if(!Utils.isDefined(this.attrs.visible)) this.attrs.visible = true;
	return this.attrs.visible;
    },
    setVisibleLevelRange:function(min,max) {
	let range = this.getVisibleLevelRange();
	let oldMin = range?.min;
	let oldMax = range?.max;	
	if(min===oldMin && max===oldMax) return;
	if(min=="") min = null;
	if(max=="") max = null;	
	this.attrs.visibleLevelRange = {min:min,max:max};
	this.checkVisible();
    },    

    checkVisible: function() {
	let showMarker = this.getShowMarkerWhenNotVisible();
	let range = this.getVisibleLevelRange()??{};
	let displayRange = this.display.getMapProperty('visibleLevelRange');
	if(!range || (displayRange && !Utils.stringDefined(range.min) && !Utils.stringDefined(range.max))) {
	    range = displayRange;
	    showMarker  = this.display.getMapProperty('showMarkerWhenNotVisible');
	}


	let level = this.display.getCurrentLevel();
	let min = Utils.stringDefined(range.min)?+range.min:-1;
	let max = Utils.stringDefined(range.max)?+range.max:10000;
	let visible=  this.getVisible() && (level>=min && level<=max);
	if(this.getVisible() && showMarker && !visible && !this.showMarkerMarker) {
	    let featuresToUse = this.features;
	    if(!featuresToUse || featuresToUse.length==0) {
		featuresToUse = this.mapLayer?.features
	    }		

	    let bounds = this.display.getMap().getFeaturesBounds(featuresToUse,true);
	    if(bounds) {
		let center = MapUtils.getCenter(bounds);
		this.showMarkerMarker = this.display.getMap().createMarker("", center, this.getIcon(), "",
									   null,null,16,null,null,{});
		this.display.addFeatures([this.showMarkerMarker]);
		this.showMarkerMarker.mapGlyph = this;
	    }
	}


	if(this.features) {
	    this.features.forEach(f=>{
		MapUtils.setFeatureVisible(f, visible);
	    });
	}


	if(this.showMarkerMarker) {
	    if(!this.getVisible() || visible) {
		this.display.removeFeatures([this.showMarkerMarker]);
		this.showMarkerMarker = null;
	    }
	}

	if(this.isFixed()) {
	    if(visible)
		jqid(this.getFixedId()).show();
	    else
		jqid(this.getFixedId()).hide();
	}

	if(this.getMapLayer() && !this.imageLayers) {
	    this.getMapLayer().setVisibility(visible);
	}
	
	if(this.imageLayers) {
	    this.imageLayers.forEach(obj=>{
		let imageVisible = visible && this.isImageLayerVisible(obj);
		if(obj.layer)
		    obj.layer.setVisibility(imageVisible);
	    })
	}


	if(this.getMapServerLayer()) {
	    this.getMapServerLayer().setVisibility(visible);
	}	

	if(this.selectDots && this.selectDots.length>0) {
	    this.selectDots.forEach(dot=>{
		MapUtils.setFeatureVisible(dot,visible);
	    });
	    ImdvUtils.scheduleRedraw(this.display.selectionLayer);
	}


	if(this.image) {
	    this.image.setVisibility(visible);
	}	
	if(this.isData()) { 
	    this.checkDataDisplayVisibility();
	}




	this.checkDeclutter(this.mapLabels,visible,true);
	let features = this.getMapFeaturesToGrid();
	if(features && visible) {
	    this.checkDeclutter(features,visible,false);
	    ImdvUtils.scheduleRedraw(this.mapLayer);
	}


    	this.applyChildren(child=>{child.checkVisible();});
	ImdvUtils.scheduleRedraw(this.display.myLayer);
	if(visible && this.isMultiEntry() && !this.haveAddedEntries) {
	    setTimeout(()=>{
		this.addEntries();
	    },1);
	}
	return visible;
    },    
    checkDeclutter:function(features, visible,isLabels) {
	if(!features || !this.mapLoaded) return;
	if(!visible) {
	    features.forEach(feature=>{MapUtils.setFeatureVisible(feature,false);});
	    return;
	} 
	let featuresToGrid = [];
	//If the label wasn't filtered then turn them all on
	features.forEach(feature=>{
	    if(!feature.isFiltered && !feature.forceHidden) {
		featuresToGrid.push(feature);
		MapUtils.setFeatureVisible(feature,true);
	    }
	});
	if(Utils.stringDefined(this.getMapPointsRange())) {
	    let level = this.display.getCurrentLevel();
	    if(level<parseInt(this.getMapPointsRange())) {
		visible=false;
		features.forEach(feature=>{MapUtils.setFeatureVisible(feature,false);});
	    }
	    return;
	} 
	if(isLabels) {
	    if(!this.getDeclutterLabels()){
		return;
	    }
	} else {
	    if(!this.getProperty('declutter.features',false)) {
		return;
	    }
	}
	let t1 = new Date();
	MapUtils.declutter(this.getMap(), featuresToGrid,this.getDeclutterArgs());
	//	Utils.displayTimes("gridding #" + features.length,[t1,new Date()],true);
    },
    getDeclutterArgs:function() {
	let args ={};
	args.fontSize = this.style.fontSize??'12px';
	if(Utils.stringDefined(this.attrs.declutter_padding))
	    args.padding = +this.attrs.declutter_padding;
	if(this.attrs.declutter_granularity)
	    args.granularity = +this.attrs.declutter_granularity;
	if(this.attrs.declutter_pixelsperline)
	    args.pixelsPerLine = +this.attrs.declutter_pixelsperline;
	if(this.attrs.declutter_pixelspercharacter)
	    args.pixelsPerCharacter = +this.attrs.declutter_pixelspercharacter;
	return args;
    },
    setImageLayerVisible:function(obj,visible) {
	this.isImageLayerVisible(obj,true,visible);
	if(obj.layer) obj.layer.setVisibility(visible);
    },
    isImageLayerVisible:function(obj,create,visible) {
	if(!this.attrs.imageLayerState) {
	    this.attrs.imageLayerState = {};
	}
	let state=this.attrs.imageLayerState[obj.id];
	if(!state) {
	    state = this.attrs.imageLayerState[obj.id] = {
		visible:true
	    }
	}
	if(Utils.isDefined(visible)) state.visible=visible;
	if(obj.id=='main') {
	    if(this.getMapLayer()) this.getMapLayer().setVisibility(visible);
	    return
	}
	if(state.visible && create)  {
	    obj.layer =this.getMap().addImageLayer(obj.name,obj.name,'',obj.url,true,
						   obj.north,obj.west,obj.south,obj.east);
	    
	    if(Utils.isDefined(this.style.imageOpacity))
		obj.layer.setOpacity(this.style.imageOpacity);
	    this.display.makeLegend();
	}
	return state.visible;
    },
    isShape:function() {
	if(this.getType()==GLYPH_LABEL) {
	    if(!Utils.stringDefined(this.style.externalGraphic)) return true;
	    if(this.style.externalGraphic && this.style.externalGraphic.endsWith("blank.gif")) return true;
	    if(this.style.pointRadius==0) return true;
	}
	return GLYPH_TYPES_SHAPES.includes(this.getType());
    },
    isData:function() {
	return this.type == GLYPH_DATA;
    },
    isFixed:function() {
	return this.type == GLYPH_FIXED;
    },    
    addFixed: function() {
	let style = this.style;
	let line = "solid";
	if(style.strokeDashstyle) {
	    if(['dot','dashdot'].includes(style.strokeDashstyle)) {
		line = "dotted";
	    } else  if(style.strokeDashstyle.indexOf("dash")>=0) {
		line = "dashed";
	    }
	}
	let css = HU.css('padding','5px');
	let color = Utils.stringDefined(style.borderColor)?style.borderColor:"#ccc";
	css+= HU.css('border' , style.borderWidth+"px" + " " + line+ " " +color);
	if(Utils.stringDefined(style.fillColor)) {
	    css+=HU.css("background",style.fillColor);
	}
	css+=HU.css('color',style.fontColor);
	if(Utils.stringDefined(style.fontSize)) {
	    css+=HU.css('font-size',style.fontSize);
	}

	['right','left','bottom','top'].forEach(d=>{
	    if(Utils.stringDefined(style[d])) css+=HU.css(d,HU.getDimension(style[d]));
	});
	let id = this.getFixedId();
	jqid(id).remove();
	let text = this.style.text??"";
	let html = HU.div([ATTR_ID,id,ATTR_CLASS,"ramadda-imdv-fixed",ATTR_STYLE,css],"");
	this.display.jq(ID_MAP_CONTAINER).append(html);
	let toggleLabel = null;
	if(text.startsWith("toggle:")) {
	    text = text.trim();
	    let regexp = /toggle:(.*)\n/;
	    let match = text.match(regexp);
	    if(match) {
		toggleLabel=match[1];
		text = text.replace(regexp,"").trim();
	    }
	} 

	let initFixed = () =>{
	    let _this=this;
	    let height  = jqid(id).height();
	    jqid(id).draggable({
		containment:this.display.domId(ID_MAP),
		start: function (event, ui) {
                    $(this).css({
			height:(height+10)+'px',
                        right: "auto",
                        top: "auto"
                    });
		},
		stop:function() {
		    let div= $(this);
		    let top = div.position().top;
		    let left = div.position().left;		    
		    let bottom = top+div.height();
		    let right = left+div.width();		    
		    let pw = div.parent().width();
		    let ph = div.parent().height();		    
		    let pos =  _this.style;
		    ['top','bottom','left','right'].forEach(p=>{
			pos[p]='';
		    });
		    let set = (which,v) =>{
			v =  Math.max(0,(parseInt(v)))+'px';
			pos[which] =v;
//			div.css(pos,v);
		    }
		    if(top<ph-bottom) set('top',top);
		    else set('bottom',(ph-bottom));
		    if(left<pw-right) set('left',left);
		    else set('right',pw-right);
		},
		revert: false
	    });
	}
	if(text.startsWith("<wiki>")) {
	    this.display.wikify(text,null,wiki=>{
		if(toggleLabel)
		    wiki = HU.toggleBlock(toggleLabel+SPACE2, wiki,false);
		wiki = HU.div([ATTR_STYLE,'max-height:300px;overflow-y:auto;'],wiki);
		jqid(id).html(wiki);
		initFixed();
	    });
	} else {
	    text = this.convertText(text);
	    text = text.replace(/\n/g,"<br>");
	    if(toggleLabel)
		text = HU.toggleBlock(toggleLabel+SPACE2, text,false);
	    jqid(id).html(text);
	    initFixed();
	}
    },

    addData:function(displayAttrs,andZoom) {
	displayAttrs = displayAttrs??{};
	displayAttrs.doInitCenter = andZoom??false;
	this.attrs.displayAttrs = displayAttrs;
	let entryId = this.getEntryId();
	let pointDataUrl = displayAttrs.pointDataUrl ||Ramadda.getUrl("/entry/data?max=50000&entryid=" + entryId);
	let pointData = new PointData(this.attrs.name,  null,null,
				      pointDataUrl,
				      {entryId:entryId});
	
	let divId   = HU.getUniqueId("display_");
	let outerDivId   = HU.getUniqueId("outerdisplay_");	
	let bottomDivId   = HU.getUniqueId("displaybottom_");	    
	let headerDiv = HU.div([ATTR_ID,outerDivId],HU.div([ID,divId]));
	this.display.jq(ID_HEADER1).append(headerDiv);
	this.display.jq(ID_BOTTOM).append(HU.div([ID,bottomDivId]));	    
	let attrs = {"externalMap":this.display.getMap(),
		     "externalDisplay":this,
		     "isContained":true,
		     "showRecordSelection":true,
		     "showInnerContents":false,
		     "entryIcon":this.attrs.icon,
		     ATTR_TITLE:this.attrs.name,
		     "max":"5000",
		     "thisEntryType":this.attrs.entryType,
		     "entryId":entryId,
		     "divid":divId,
		     "acceptRequestChangeEvent":false,
		     "pointDataCacheOK":false,
		     "bottomDiv":bottomDivId,			 
		     "data":pointData,
		     "fileUrl":Ramadda.getUrl("/entry/get?entryid=" + entryId+"&fileinline=true")};
	$.extend(attrs,displayAttrs);
	attrs = $.extend({},attrs);
	attrs.name=this.getName();
	let display = this.display.getDisplayManager().createDisplay("map",attrs);
	//	this.attrs.name = display.getLogLabel();
	//Not sure why we do this since we can't integrate charts with map record selection
	//	display.setProperty("showRecordSelection",false);

	display.errorMessageHandler = (display,msg) =>{
	    this.display.setErrorMessage(msg,5000);
	};
	this.displayInfo =   {
	    display:display,
	    outerDivId:outerDivId,
	    divId:divId,
	    bottomDivId: bottomDivId
	};
	this.checkDataDisplayVisibility();
    },
    externalDisplayReady:function(display) {
	this.display.checkGlyphLayers();
    },
    checkDataDisplayVisibility:function() {
	if(!this.displayInfo) return;
	let visible = this.isVisible();
	if(this.displayInfo.display) {
	    this.displayInfo.display.setVisible(visible);
	}
	//For now don't toggle the class because if there isn't any thing shown we have a grey bar
	let div = jqid(this.displayInfo.divId);
	let outerDiv = jqid(this.displayInfo.outerDivId);	
	if(!this.getProperty('showDisplayHeader',true)) {
	    visible=false;
	}
	if(visible) {
	    outerDiv.show();
//	    outerDiv.removeClass(CLASS_LEGEND_LABEL_INVISIBLE);
//	    outerDiv.find('input').prop('disabled',false);
	}    else {
	    outerDiv.hide();
//	    outerDiv.addClass(CLASS_LEGEND_LABEL_INVISIBLE);
//	    outerDiv.find('input').prop('disabled',true);
	}
    },
    getDecoration:function(small) {
	let type = this.getType();
	let style = this.style??{};
	let css= ['display','inline-block'];
	let dim = small?'10px':'25px';
	css.push(ATTR_WIDTH,small?'10px':'50px');
	let line = "solid";
	if(style.strokeWidth>0) {
	    if(style.strokeDashstyle) {
		if(['dot','dashdot'].includes(style.strokeDashstyle)) {
		    line = "dotted";
		} else  if(style.strokeDashstyle.indexOf("dash")>=0) {
		    line = "dashed";
		}
	    }
	    css.push('border',(small?Math.min(+style.strokeWidth,1):style.strokeWidth)+"px " + line +" " + style.strokeColor);
	}

	if(style.imageUrl) {
	    if(!small) 
		return HU.toggleBlock(style.imageUrl, HU.image(style.imageUrl,["width","200px"]));
	} else if(type==GLYPH_LABEL) {
	    if(!small)
		return style.label.replace(/\n/g,"<br>");
	} else if(type==GLYPH_MARKER) {
	    if(!small)
		return HU.image(style.externalGraphic,[ATTR_WIDTH,'16px']);
	} else if(type==GLYPH_BOX) {
	    if(Utils.stringDefined(style.fillColor)) {
		css.push('background',style.fillColor);
	    }
	    css.push('height',dim);
	    return HU.div([ATTR_STYLE,HU.css(css)]);
	} else if(type==GLYPH_HEXAGON) {
	    css=[];
	    if(Utils.stringDefined(style.fillColor)) {
		css.push('background',style.fillColor);
	    }
	    if(Utils.stringDefined(style.strokeColor)) {
		css.push('color',style.strokeColor);
	    }		
	    css.push('font-size',small?'16px':'32px','vertical-align','center');
	    return HU.span([ATTR_STYLE,HU.css(css)],"&#x2B22;");
	} else if(type==GLYPH_CIRCLE || type==GLYPH_POINT) {
	    if(Utils.stringDefined(style.fillColor)) {
		css.push('background',style.fillColor);
	    }
	    if(type==GLYPH_POINT) {
		css.push('margin-top','10px','height','10px',ATTR_WIDTH,'10px');
	    } else {
		css.push('height',dim);
		css.push(ATTR_WIDTH,dim);
	    }		    
	    return HU.div([ATTR_CLASS,'ramadda-dot', ATTR_STYLE,HU.css(css)]);
	} else if(type==GLYPH_LINE ||
		  type==GLYPH_POLYLINE ||
		  type==GLYPH_POLYGON ||
		  type==GLYPH_FREEHAND_CLOSED ||
		  type==GLYPH_MAP
		  || type==GLYPH_ROUTE
		  ||  type==GLYPH_FREEHAND) {
	    if(this.isClosed()) {
		if(type==GLYPH_FREEHAND_CLOSED)
		    css.push('border-radius','10px');
		css.push('height','10px');
		//		css.push('margin-top','10px','margin-bottom','10px');
		css.push('background',style.fillColor);
	    } else {
		css.push('margin-bottom','4px','border-bottom', style.borderWidth+"px" + " " + line+ " " +style.strokeColor);
	    }
	    return HU.div([ATTR_STYLE,HU.css(css)]);
	}
	return HU.div([ATTR_STYLE,HU.css('display','inline-block','border','1px solid transparent',ATTR_WIDTH,small?'10px':'50px')]);
    },
    isClosed: function() {
	return GLYPH_TYPES_CLOSED.includes(this.type);
    },
    isOpenLine:function() {
	return GLYPH_TYPES_LINES_OPEN.includes(this.type);
    },
    isStraightLine:function() {
	return GLYPH_TYPES_LINES_STRAIGHT.includes(this.type);
    },
    addEntries: function(andZoom) {
	if(!this.checkVisible()) return;
	if(this.haveAddedEntries) return;
	this.haveAddedEntries = true;
	let entryId = this.getEntryId();
        let entry =  new Entry({
            id: entryId,
        });
        let callback = (entries)=>{
	    this.clearChildren();
	    this.children = [];
	    this.entries = entries;
	    entries = this.getMultiEntries();
	    let someNotLocated = false;
	    entries.forEach((e,idx)=>{
		if(!e.hasLocation()) {
		    console.log("multi entry has no location:" + e.getName());
		    someNotLocated = true;
		    return;
		}
		let overrideLocation;
		if(this.attrs.childrenLocations) {
		    overrideLocation = this.attrs.childrenLocations[e.getId()];
		}
		let latLon;

		if(overrideLocation) {
		    latLon = {latitude:overrideLocation[0],longitude:overrideLocation[1]};
		} else {
		    latLon = {latitude:e.getLatitude(),longitude:e.getLongitude()};
		}
		let pt = MapUtils.createPoint(latLon.longitude,latLon.latitude);
		pt = this.display.getMap().transformLLPoint(pt);
		let style = Utils.clone({},this.style);
		style.externalGraphic = e.getIconUrl();
		if(Utils.stringDefined(this.style.childIcon)) {
		    style.externalGraphic = this.style.childIcon;
		}
		style.strokeWidth=1;
		style.strokeColor="transparent";
		style.fontSize='12px';
		if(style.showLabels) {
		    let label  =e.getName();
		    let toks = Utils.split(label," ",true,true);
		    if(toks.length>1) {
			label = "";
			Utils.splitList(toks,3).forEach(l=>{
			    label += Utils.join(l," ");
			    label+="\n";
			})
			label = label.trim();
		    }
		    style.label=label;
		} else {
		    style.label=null;
		}
		
		let attrs = {name:e.getName(),
			     mapglyphs:e.mapglyphs,
			     entryId:e.getId(),
			     icon:style.externalGraphic
			    };
		let points =[latLon.latitude,latLon.longitude];
		let mapGlyph = this.display.createMapMarker(GLYPH_ENTRY,attrs, style,points,false);
		mapGlyph.overrideLocation = overrideLocation;
		mapGlyph.isEphemeral = true;
		this.addChildGlyph(mapGlyph);
		if(this.getShowDataIcons()) {
		    mapGlyph.makeDataIcon(true);
		}
	    });
	    //call getBounds  so they are cached
	    this.getBounds();
	    this.display.makeLegend();
	    this.checkVisible();
	    if(andZoom) {
		this.panMapTo();
	    }
	    this.showMultiEntries();
	};
	let order = 'orderby=' + this.getProperty('orderby','name');
	order+='&ascending=' + this.getProperty('ascending','true');
	entry.getChildrenEntries(callback,order);
    },
    isSelected:function() {
	return this.selected;
    },
    getSelected:function(selected) {
	if(this.isSelected()) {
	    selected.push(this);
	}
	this.applyChildren(child=>{child.getSelected(selected);});
    },

    select:function(maxPoints,dontRedraw) {
	if(!Utils.isDefined(maxPoints)) maxPoints = 20;
	if(this.isSelected()) {
	    return;
	}
	this.findInLegend(CLASS_LEGEND_LABEL).css('font-weight','bold');
	this.selected = true;
	this.selectDots = [];
	let pointCount = 0;
	let mapLayer = this.getMapLayer();
	if(mapLayer && mapLayer.features) {
	    let style={
		strokeColor:'#000',
		strokeWidth:2,
		fillColor:'transparent',
		pointRadius:5
	    };

	    mapLayer.features.forEach(f=>{
		f.originalStyle = f.style;
		f.style = style;
	    });
	    ImdvUtils.scheduleRedraw(this.mapLayer);
	}	    


	let image = this.getImage();
	if(image) {
	    let ext = image.extent;
	    let c  =ext.getCenterPixel();
	    [[ext.left,ext.top],[ext.right,ext.top],[ext.left,ext.bottom],[ext.right,ext.bottom]].forEach(tuple=>{
		let x = tuple[0];
		let y = tuple[1];		
		//Rotate the dots
		if(this.style.rotation) {
		    let r = Utils.rotate(c.x, c.y, x, y, this.style.rotation,true);
		    x = r.x; y=r.y;
		}
                let pt = MapUtils.createPoint(x,y);
		let dot = MapUtils.createVector(pt,null,this.display.DOT_STYLE);	
		this.selectDots.push(dot);
	    });
	} else {
	    pointCount+=this.display.selectFeatures(this,this.getFeatures(),maxPoints);
	}
	this.display.selectionLayer.addFeatures(this.selectDots,{silent:true});
	this.applyChildren(child=>{pointCount+=child.select(maxPoints, dontRedraw);});
	return pointCount;
    },
    unselect:function() {
	this.findInLegend(CLASS_LEGEND_LABEL).css('font-weight','normal');
	this.applyChildren(child=>{child.unselect();});
	if(!this.isSelected()) {
	    return;
	}	    
	this.selected = false;
	if(this.selectDots) {
	    this.display.selectionLayer.removeFeatures(this.selectDots);
	    this.selectDots= null;
	}

	if(this.mapLayer && this.mapLayer.features) {
	    this.applyMapStyle(true);
	}

    },
    
    doRemove:function() {
	if(this.dataIconContainer) {
	    jqid(this.dataIconContainer).remove();
	    this.dataIconContainer=null;
	}

	if(this.stepMarker) {
	    this.display.removeFeatures([this.stepMarker]);
	}

	if(this.isFixed()) {
	    jqid(this.getFixedId()).remove();
	}
	if(this.mapLabels) {
	    this.display.removeFeatures(this.mapLabels);
	}
	if(this.features) {
	    this.display.removeFeatures(this.features);
	}
	if(this.extraFeatures) {
	    this.display.removeFeatures(this.extraFeatures);
	}
	if(this.showMarkerMarker) {
	    this.display.removeFeatures([this.showMarkerMarker]);
	    this.showMarkerMarker = null;
	}
	if(this.selectDots) {
	    this.display.selectionLayer.removeFeatures(this.selectDots);
	    this.selectDots = null;
	}

	if(this.getMapLayer()) {
	    this.display.getMap().removeLayer(this.getMapLayer());
	    this.image =null;
	    this.setMapLayer(null);
	}

	if(this.getImage()) {
	    this.display.getMap().removeLayer(this.getImage());
	    this.image =null;
	}


	if(this.imageLayers) {
	    this.imageLayers.forEach(obj=>{
		if(obj.layer)
		    this.display.getMap().removeLayer(obj.layer);
	    })
	    this.imageLayers = [];
	}

	if(this.getMapServerLayer()) {
	    this.display.getMap().removeLayer(this.getMapServerLayer());
	    this.setMapServerLayer(null);
	}
	if(this.displayInfo) {
	    jqid(this.displayInfo.divId).remove();
	    jqid(this.displayInfo.bottomDivId).remove();			
	    if(this.displayInfo.display) {
		this.displayInfo.display.deleteDisplay();
	    }
	}

	this.setParentGlyph(null);
	this.clearChildren();
    }
}

function FeatureInfo(mapGlyph,key) {
    $.extend(this,{
	mapGlyph:mapGlyph,
	property:key,
	id:Utils.makeId(key),
	min:NaN,
	max:NaN,
	type:'',
	seen:{},
	samples:[],
    });
}

FeatureInfo.prototype= {
    getId:function() {
	return this.id;
    },
    getProperty:function(prop,dflt,checkGlyph) {
	if(checkGlyph) dflt=this.mapGlyph.getProperty(prop,dflt);
	let v =   this.mapGlyph.getProperty(this.id+'.' + prop,dflt);
	return v;
    },
    show: function() {
	return  this.getProperty('show',this.mapGlyph.getProperty('feature.show',true));
    },
    showFilter: function() {
	let dflt = this.mapGlyph.getProperty('filter.show',this.show());
	let show =   this.getProperty('filter.show',dflt);
	return show;
    },
    filterSize: function() {
	let dflt = this.mapGlyph.getProperty('filter.size');
	return   this.getProperty('filter.size',dflt);
    },    
    showTable: function() {
	return this.getProperty('table.show',this.mapGlyph.getProperty('table.show',this.show()));
    },
    showPopup: function() {
	return this.getProperty('popup.show',this.mapGlyph.getProperty('popup.show',this.show()));
    },				
    isColorTableSelect: function() {
	return this.getProperty('colortable.select',this.mapGlyph.getProperty('colortable.select',false));
    },
    getType:function() {
	return this.getProperty('type',this.type);
    },
    getLabel:function(addSpan) {
	let label  =this.getProperty('label');
	if(!Utils.stringDefined(label)) label  =this.mapGlyph.display.makeLabel(this.property);
	if(addSpan) label = HU.span([ATTR_TITLE,this.property],label);
	return label;
    },
    getValueLabel:function(v) {
	let label = this.getProperty('label.' +v?.toLowerCase(), null);
	if(!label) label = Utils.makeLabel(v);
	return label;
    },
    format:function(value) {
	if(this.isNumeric()) {
	    let decimals = this.getProperty('format.decimals',-1,true);
	    if(decimals>=0&&!isNaN(value)) {
		value = Utils.trimDecimals(value,decimals);
	    }
	}
	return value;
    },
    isNumeric:function(){return this.isInt() || this.getType()=='numeric';},
    isInt:function() {return this.getType()=='int';},
    isString:function() {return this.getType()=='string';},
    isEnumeration:function() {return this.getType()=='enumeration'||this.getType()=='enum';},
    getStep:function(dflt) {
	let s = this.getProperty('step');
	if(Utils.isDefined(s)) return parseFloat(s);
	return dflt;
    },
    getSamplesLabels:function() {
	return this.samples.map(sample=>{return sample.label;});
    },
    getSamplesForMenu:function() {
	return this.samples;
    },
    getSamplesValues:function() {
	return this.samples.map(sample=>{
	    let cnt = this.seen[sample.value];
	    return sample.value +' ('+ cnt+')';
	});
    },
    initValues:function(f) {
	let value= this.mapGlyph.getFeatureValue(f,this.property);
	if(!Utils.isDefined(value)) return;
	let isEnumeration = this.isEnumeration();
	if(isNaN(value) || this.samples.length>0 || isEnumeration) {
	    if(this.samples.length<100) {
		this.type='enumeration';
		if(!this.seen[value]) {
		    this.seen[value] = 0;
		    this.samples.push(value);
		}
		this.seen[value]++;
	    } else {
		this.type='string';
	    }
	} else if(!isNaN(value)) {
	    if(this.type != 'numeric')
		this.type='int';
	    if(Math.round(value)!=value) {
		this.type = 'numeric';
	    }
	    this.min = isNaN(this.min)?value:Math.min(this.min,value);
	    this.max = isNaN(this.max)?value:Math.max(this.max,value);			
	}
    },

    finishInit:function() {
	if(this.samples.length) {
	    let getLabel = (item)=>{
		return this.getValueLabel(item);
	    }
	    
	    if(this.mapGlyph.getProperty('filter.showRawValues',false)) {
		getLabel = item=>{return item;}
	    }
	    let items = this.samples.map((item,idx)=>{
		return {value:item,label:getLabel(item)};
	    });
	    this.samples =  items.sort((a,b)=>{
		return a.label.localeCompare(b.label);
	    });
	}
    }
    
    
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


const DISPLAY_GRAPH = "graph";
const DISPLAY_TREE = "tree";
const DISPLAY_TIMELINE = "timeline";
const DISPLAY_HOURS = "hours";
const DISPLAY_BLANK = "blank";
const DISPLAY_FILTER = "filter";
const DISPLAY_HOOK = "hook";
const DISPLAY_PRE = "pre";
const DISPLAY_HTMLTABLE = "htmltable";
const DISPLAY_RECORDS = "records";
const DISPLAY_TSNE = "tsne";
const DISPLAY_HEATMAP = "heatmap";
const DISPLAY_WAFFLE = "waffle";
const DISPLAY_CROSSTAB = "crosstab";
const DISPLAY_CORRELATION = "correlation";
const DISPLAY_RANKING = "ranking";
const DISPLAY_STATS = "stats";
const DISPLAY_COOCCURENCE = "cooccurence";
const DISPLAY_BOXTABLE = "boxtable";
const DISPLAY_DATATABLE = "datatable";
const DISPLAY_PERCENTCHANGE = "percentchange";
const DISPLAY_SPARKLINE = "sparkline";
const DISPLAY_POINTIMAGE = "pointimage";
const DISPLAY_CANVAS = "canvas";
const DISPLAY_FIELDTABLE = "fieldtable";
const DISPLAY_SELECTEDRECORDS = "selectedrecords";
const DISPLAY_DATEGRID = "dategrid";
const DISPLAY_STRIPES = "stripes";

addGlobalDisplayType({
    type: DISPLAY_RANKING,
    label: "Ranking",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Show fields ordered by values","ranking.png")                            
});

addGlobalDisplayType({
    type: DISPLAY_STRIPES,
    label: "Stripes",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Show color stripes","stripes.png")                            
});


addGlobalDisplayType({
    type: DISPLAY_CORRELATION,
    label: "Correlation",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip('Correlation','correlation.png')                            
});
addGlobalDisplayType({
    type: DISPLAY_CROSSTAB,
    label: "Crosstab",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Cross Tabulation","crosstab.png")                                
});

addGlobalDisplayType({
    type: DISPLAY_STATS,
    label: "Stats Table",
    requiresData: false,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Statistical Summary","stats.png"),
});
addGlobalDisplayType({
    type: DISPLAY_RECORDS,
    label: "Records",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Displays records as text","records.png")
});
addGlobalDisplayType({
    type: DISPLAY_TSNE,
    label: "TSNE",
    requiresData: true,
    forUser: false,
    category: CATEGORY_MISC
});
addGlobalDisplayType({
    type: DISPLAY_HEATMAP,
    label: "Heatmap",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Table showing colored fields","heatmap.png"),    
});
addGlobalDisplayType({
    type: DISPLAY_WAFFLE,
    label: "Waffle",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip('Waffle Chart','waffle.png')
});
addGlobalDisplayType({
    type: DISPLAY_GRAPH,
    label: "Graph",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Display a force-directed graph","graph.png")
});

addGlobalDisplayType({
    type: DISPLAY_PERCENTCHANGE,
    label: "Percent Change",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Percent Change","percentchange.png","Show percent change over a given time in a text template")    
});

addGlobalDisplayType({
    type: DISPLAY_SPARKLINE,
    label: "Sparkline",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Embed little sparkline plots in text","sparkline.png"),    
});

addGlobalDisplayType({
    type: DISPLAY_CANVAS,
    label: "Canvas",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Draw records into a canvas","canvas.png"),        
});

addGlobalDisplayType({
    type: DISPLAY_POINTIMAGE,
    label: "Point Image",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Embed 2D images into text","pointimage.png"),            
});
addGlobalDisplayType({
    type: DISPLAY_FIELDTABLE,
    label: "Field Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip('Field Table',"fieldtable.png"),
});
addGlobalDisplayType({
    type: DISPLAY_SELECTEDRECORDS,
    label: "Selected Records",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Display selected records in a table")
});
addGlobalDisplayType({
    type: DISPLAY_TREE,
    forUser: true,
    label: "Tree",
    requiresData: false,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('Tree','tree.png')                                    
});

addGlobalDisplayType({
    type: DISPLAY_TIMELINE,
    label: "Timeline",
    requiresData: true,
    forUser: true,
    category:  CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Timeline showing text and images","timeline.png")
});
addGlobalDisplayType({
    type: DISPLAY_HOURS,
    label: "Hours",
    requiresData: true,
    forUser: true,
    category:  CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Hourly timeline","timeline.png","Show data by the day and hour")    
});
addGlobalDisplayType({
    type: DISPLAY_BLANK,
    label: "Blank",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows no data",null,"Useful for just showing filters, etc")                                                
});
addGlobalDisplayType({
    type: DISPLAY_FILTER,
    label: "Filter",
    requiresData: false,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just provides data filtering")
});


addGlobalDisplayType({
    type: DISPLAY_HOOK,
    label: "Hook",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Add your own Javascript",null,"Integrate your own Javascript")                                                
});
addGlobalDisplayType({
    type: DISPLAY_PRE,
    label: "Preformat",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Shows records in an HTML PRE tag",null,"Useful for looking at the data")                                                
});
addGlobalDisplayType({
    type: DISPLAY_HTMLTABLE,
    label: "HTML Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Shows records in an HTML table",null,"Useful for looking at the data")                                                    
});
addGlobalDisplayType({
    type: DISPLAY_COOCCURENCE,
    label: "Cooccurence",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Cooccurence Table","cooccurrence.png","Tabular plot showing number of records that share values from two fields"),    

});
addGlobalDisplayType({
    type: DISPLAY_BOXTABLE,
    label: "Box Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Box Table","boxtable.png","Shows number of records that share the same category field value"),    
});
addGlobalDisplayType({
    type: DISPLAY_DATATABLE,
    label: "Data Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Data Table",["datatable1.png","datatable2.png"],"Selectable record grouping. Can be colored or show pie charts"),        
});
addGlobalDisplayType({
    type: DISPLAY_DATEGRID,
    label: "Date Grid",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Date Grid",["dategrid.png"],"Show records grouped by category and date"),        
});

function RamaddaGraphDisplay(displayManager, id, properties) {
    const ID_GRAPH = "graph";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_GRAPH, properties);
    if(!window["ForceGraph"]) {
	Utils.importJS("https://unpkg.com/force-graph");
    }
    let myProps = [
	{label:'Graph'},
	{p:'sourceField',ex:''},
	{p:'targetField',ex:''},
	{p:'labelField'},
	{p:'nodeBackground',ex:'#ccc'},
	{p:'drawCircle',ex:'true'},
	{p:'nodeWidth',d:'10'},
	{p:'linkColor',d:'#ccc'},
	{p:'linkDash',ex:'5'},
	{p:'linkWidth',d:'1'},
	{p:'arrowLength',ex:'6'},
	{p:'arrowColor',ex:'green'},
	{p:'directionalParticles',ex:'2'}
    ]


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	callbackWaiting:false,
        updateUI: function() {
            if(!window["ForceGraph"]) {
		if(!this.callbackWaiting) {
		    this.callbackWaiting = true;
                    setTimeout(()=>{
			this.callbackWaiting = false;
			this.updateUI()
		    },100);
		}
                return;
            }
	    let graphData = null;
	    let html = HU.div([ATTR_ID, this.domId(ID_GRAPH)]);
	    this.setContents(html);
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let seenNodes = {};
	    let nodes = [];
	    let links = [];
	    let valueFields   = this.getFieldsByIds(null, this.getProperty("valueFields","",true));
	    let labelField = this.getFieldById(null, this.getLabelField());
	    if(!labelField) {
		let strings = this.getFieldsByType(null, "string");
		if(strings.length>0) labelField = strings[0];
	    }
	    let sourceField = this.getFieldById(null, this.getProperty("sourceField","source"));
	    let targetField = this.getFieldById(null, this.getProperty("targetField","target"));
	    let textTemplate = this.getProperty("tooltip","${default}");
	    if(valueFields.length>0) {
		let seenValue = {};
		records.map((r,index)=>{
		    let label  = labelField?r.getValue(labelField.getIndex()):index;
		    let tooltip =  this.getRecordHtml(r, null, textTemplate);
		    nodes.push({id:index,label:label,tooltip:tooltip});
		    valueFields.map(f=>{
			let value = r.getValue(f.getIndex());
			if(!seenValue[value+"_" + f.getId()]) {
			    seenValue[value+"_" + f.getId()] = true;
			    nodes.push({id:value, isValue:true});
			}
			links.push({source:value, target: index});
		    });
		});
	    } else if(sourceField!=null && targetField!=null) {
		records.map(r=>{
		    let source = r.getValue(sourceField.getIndex());
		    let target = r.getValue(targetField.getIndex());
		    let label  = labelField?r.getValue(labelField.getIndex()):index;
		    if(!seenNodes[source]) {
			seenNodes[source] = true;
			nodes.push({id:source,label:label,tooltip:source});
		    }
		    if(!seenNodes[target]) {
			seenNodes[target] = true;
			nodes.push({id:target,label:label,tooltip:target});
		    }
		    links.push({source:source, target: target});
		});
	    } else {
		this.setDisplayMessage("No source/target fields specified");
		return;
	    }
	    graphData = {
		nodes: nodes,
		links: links
	    };

	    const nodeBackground = this.getNodeBackground('rgba(255, 255, 255, 0.8)');
	    const linkColor = this.getLinkColor();
	    const drawCircle = this.getDrawCircle();
	    const linkWidth = +this.getLinkWidth();
	    const linkDash = +this.getLinkDash(-1);
	    const drawText = this.getProperty("drawText",true);
	    const nodeWidth = this.getNodeWidth(10);
	    const elem = document.getElementById(this.domId(ID_GRAPH));
	    const graph = ForceGraph()(elem).graphData(graphData);
	    graph.nodeCanvasObject((node, ctx, globalScale) => {
		let label = node.label;
		if(!label) label = node.id;
		const fontSize = 12/globalScale;
		ctx.font = fontSize +"px Sans-Serif";
		let textWidth = ctx.measureText(label).width;
		if(!drawText)
		    textWidth=nodeWidth;
		if(node.isValue) {
		    let bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2+2); 
		    ctx.lineWidth = 1;
		    ctx.strokeStyle = "#000";
		    ctx.fillStyle = "#fff";
		    ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
		    ctx.strokeRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
		} else  {
		    let dim = [textWidth, fontSize].map(n => n + fontSize * 0.2+2); 
		    ctx.fillStyle = nodeBackground;
		    ctx.strokeStyle = "#000";
		    if(drawCircle) {
			ctx.beginPath();
			ctx.arc(node.x, node.y, dim[0]/2, 0, 2 * Math.PI);
			ctx.fill(); 
		    } else {
			ctx.lineWidth = 1;
			ctx.fillRect(node.x - dim[0] / 2, node.y - dim[1] / 2, ...dim);
			ctx.strokeRect(node.x - dim[0] / 2, node.y - dim[1] / 2, ...dim);
		    }
		}
		if(drawText) {
		    ctx.textAlign = 'center';
		    ctx.textBaseline = 'middle';
		    ctx.fillStyle = "black";
		    ctx.fillText(label, node.x, node.y);
		}
	    });

	    if(this.getWidth())
		graph.width(this.getWidth());
	    if(this.getHeight())
		graph.height(this.getHeight());
	    graph.nodeLabel(node => node.tooltip?node.tooltip:null)
	    graph.linkWidth(+this.getLinkWidth());
	    graph.linkColor(this.getLinkColor());
	    if(this.getArrowColor()) {
		graph.linkDirectionalArrowColor(this.getArrowColor());
	    }
	    if(this.getArrowLength()) {
		graph.linkDirectionalArrowLength(+this.getArrowLength());
		graph.linkDirectionalArrowRelPos(+this.getProperty("arrowPosition",0.9));
	    }

	    if(this.getProperty("directionalParticles")) {
		graph.linkDirectionalParticles(+this.getProperty("directionalParticles"));
	    }
	}
    })
}


function RamaddaTreeDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_TREE, properties);
    let myProps = [
	{label:'Tree'},
	{p:'maxDepth',ex:'3'},
	{p:'showDetails',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	countToRecord: {},
        needsData: function() {
            return true;
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
	    let roots=null;
	    try {
		roots = this.makeTree(records);
	    } catch(error) {
                this.handleError("An error has occurred:" + error, error);
		return;
	    }

	    let html = "";
	    let baseId = this.domId("node");
	    let cnt=0;
	    let depth = 0;
	    let maxDepth = +this.getProperty("maxDepth",10);
	    let template = this.getProperty("recordTemplate","${default}");
	    let showDetails = this.getProperty("showDetails",true);
	    let _this =this;
	    let func = function(node) {
		cnt++;
		if(node.record) {
		    _this.countToRecord[cnt] = node.record;
		}
		depth++;
		let on = node.children.length>0 && depth<=maxDepth;
		let details = null;
		if(showDetails && node.record) {
		    details = _this.getRecordHtml(node.record,null, template);
		    if(details == "") details = null;
		}
		let image = "";
		if(node.children.length>0 || details) {
		    image = HU.image(on?icon_downdart:icon_rightdart,[ATTR_ID,baseId+"_toggle_image" + cnt]) + " ";
		}
		html+=HU.div([ATTR_CLASS,"display-tree-toggle",ATTR_ID,baseId+"_toggle" + cnt,"toggle-state",on,"block-count",cnt], image +  node.label);
		html+=HU.open(DIV,[ATTR_ID, baseId+"_block"+cnt,ATTR_CLASS,"display-tree-block",ATTR_STYLE,HU.css('display', (on?"block":"none"))]);
		if(details && details!="") {
		    if(node.children.length>0) {
			html+= HU.div([ATTR_CLASS,"display-tree-toggle-details",ATTR_ID,baseId+"_toggle_details" + cnt,"toggle-state",false,"block-count",cnt], HU.image(icon_rightdart,[ATTR_ID,baseId+"_toggle_details_image" + cnt]) + " Details");
			html+=HU.div([ATTR_ID, baseId+"_block_details"+cnt,ATTR_CLASS,"display-tree-block",ATTR_STYLE,HU.css('display','none')],details);
		    } else {
			html+=details;
		    }
		}
		
		if(node.children.length>0) {
		    node.children.map(func);
		}
		depth--;
		html+=HU.close(DIV);
	    }
	    //	    console.log("roots:" + roots.length);
	    roots.map(func);
	    this.myRecords = [];
            this.displayHtml(html);
	    this.find(".display-tree-toggle").click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		let cnt = $(this).attr("block-count");
		let block = $("#"+ baseId+"_block"+cnt);
		let img = $("#"+ baseId+"_toggle_image"+cnt);
		$(this).attr("toggle-state",state);
		if(state)  {
		    block.css("display","block");
		    img.attr("src",icon_downdart);
		} else {
		    block.css("display","none");
		    img.attr("src",icon_rightdart);
		}
		let record = _this.countToRecord[cnt];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    this.find(".display-tree-toggle-details").click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		let cnt = $(this).attr("block-count");
		let block = $("#"+ baseId+"_block_details"+cnt);
		let img = $("#"+ baseId+"_toggle_details_image"+cnt);
		$(this).attr("toggle-state",state);
		if(state)  {
		    block.css("display","block");
		    img.attr("src",icon_downdart);
		} else {
		    block.css("display","none");
		    img.attr("src",icon_rightdart);
		}
	    });
        },
    });
}




function RamaddaTimelineDisplay(displayManager, id, properties) {
    const ID_TIMELINE = "timeline";
    if(!properties.height) properties.height=400;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TIMELINE, properties);
    let myProps = [
	{label:'Timeline'},
	{p:'titleField',ex:''},
	{p:'titleLength',ex:'100'},	
	{p:'imageField',ex:''},
	{p:'urlField',ex:''},
	{p:'textTemplate',ex:''},
	{p:'startDateField',ex:''},
	{p:'endDateField',ex:''},
	{p:'startAtSlide',ex:'0'},
	{p:'startAtEnd',ex:'true'},
	{p:'scaleFactor',ex:'10'},
	{p:'initialZoom',ex:'10'},	
	{p:'timelinePosition',ex:'top|bottom',d:'top'},
	{p:'navHeight',ex:'150'},
	{p:'backgroundColor',ex:'#ccc'},
	{p:'groupField',ex:''},
	{p:'urlField',ex:''},
	{p:'timeTo',d:'day',ex:'year|day|hour|second',canCache:true},
	//	{p:'justTimeline',ex:"true"},
	{p:'hideBanner',ex:"true"},
    ];

    let js = 'https://cdn.knightlab.com/libs/timeline3/latest/js/timeline.js';
    js = RamaddaUtil.getCdnUrl("/lib/timeline3/timeline.js");
    Utils.importJS(js);
    let css = 'https://cdn.knightlab.com/libs/timeline3/latest/css/themes/timeline.theme.contrast.css';
    //Don't use our own since this breaks the fonts
    //css =  RamaddaUtil.getCdnUrl("/lib/timeline3/timeline.css");
    $(HU.tag('link',['rel','stylesheet','href', css,'type','text/css'] )).appendTo("head");
    
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	loadCnt:0,
	timelineLoaded: false,
        checkLayout: function() {
	    //Update the ui when the tab this is in is activated
	    this.updateUI();
	},
	updateUI: function() {
	    if(!this.timelineLoaded) {
		try {
		    let tmp =  TL.Timeline;
		    this.timelineLoaded = true;
		} catch(err) {
		    if(this.loadCnt++<100) {
			setTimeout(()=>this.updateUI(),100);
			return;
		    }
		}
	    }
	    if(!this.timelineLoaded) {
		this.setDisplayMessage("Could not load timeline");
		return;
	    }
            let records = this.filterData();
	    if(records==null) return;
	    let timelineId = this.domId(ID_TIMELINE);
	    let html = HU.div([ATTR_ID,timelineId]);
	    this.setContents(html);
	    this.timelineReady = false;
	    let opts = {
		timenav_position: this.getTimelinePosition(),
		//		debug:true,
		start_at_end: this.getPropertyStartAtEnd(false),
		start_at_slide: this.getPropertyStartAtSlide(0),
		timenav_height: this.getPropertyNavHeight(200),
		height:300,
		menubar_height:300,
		gotoCallback: (slide)=>{
		    if(this.timelineReady) {
			let record = records[slide];
			if(record) {
			    this.propagateEventRecordSelection({record: record});
			}
		    }
		}
            };
	    if(this.getPropertyBackgroundColor())
		opts.default_bg_color = this.getPropertyBackgroundColor();
	    if(this.getPropertyScaleFactor(0))
		opts.scale_factor = this.getPropertyScaleFactor();
	    if(this.getPropertyInitialZoom(0))
		opts.scale_factor = this.getPropertyInitialZoom();

	    let json = {};
	    let events = [];
	    json.events = events;
	    let titleField = this.getFieldById(null,this.getPropertyTitleField());
	    if(titleField==null) {
		titleField = this.getFieldById(null, ATTR_TITLE);
	    }
	    if(titleField==null) {
		titleField = this.getFieldById(null, "name");
	    }
	    let titleLength = this.getTitleLength();

	    let startDateField = this.getFieldById(null,this.getPropertyStartDateField());
	    if(!startDateField) startDateField = this.getFieldByType(null,"date");
	    let endDateField = this.getFieldById(null,this.getPropertyEndDateField());
	    let imageField = this.getFieldById(null,this.getPropertyImageField());
	    let groupField = this.getFieldById(null,this.getPropertyGroupField());
	    let urlField = this.getFieldById(null,this.getPropertyUrlField());
	    let textTemplate = this.getPropertyTextTemplate("${default}");
	    let timeTo = this.getTimeTo();
	    let showYears = this.getProperty("showYears",false);
	    this.recordToIndex = {};
	    this.idToRecord = {};
	    for(let i=0;i<records.length;i++) {
		let record = records[i]; 
		this.idToRecord[record.getId()] = record;
		this.recordToIndex[record.getId()] = i;
		let tuple = record.getData();
		let event = {
		};	
		let headline = titleField? tuple[titleField.getIndex()]:" record:" + (i+1);
		if(titleLength && headline.length>titleLength)
		    headline = headline.substring(0,titleLength)+"...";
		let debug = false;
		let text =  this.getRecordHtml(record, null, textTemplate,debug);
		if(urlField) {
		    let url  = record.getValue(urlField.getIndex());
		    headline = HU.href(url,headline);
		}

		event.unique_id = record.getId();
		event.text = {
		    headline: headline,
		    text:text
		};
		if(groupField) {
		    let value = record.getValue(groupField.getIndex());
		    if(value && groupField.isFieldMultiEnumeration()) {
			value = String(value).replace(/,.*/g,'');
		    }
		    event.group = value;
		}

		if(imageField) {
		    event.media = {
			url:record.getValue(imageField.getIndex())
		    };
		    if(urlField) {
			event.media.link = record.getValue(urlField.getIndex());
			event.media.link_target = "_timelinemedia";
		    }
		}
		let startDate =this.getDate(startDateField? tuple[startDateField.getIndex()]: record.getTime());
		if (showYears) {
		    event.start_date = {
			year: startDate.year
		    }
		} else {
		    event.start_date  = startDate;
		    if(endDateField) {
			event.end_date = tuple[endDateField.getIndex()];
		    }
		}
		//		console.log(JSON.stringify(event));
		events.push(event);
	    }
	    //	    console.log(JSON.stringify(json,null,2));
	    if($("#" + timelineId).length==0) {
		//		console.info("No timeline div:" + timelineId);
		return;
	    }

	    this.timeline = new TL.Timeline(timelineId,json,opts);
	    if(this.getPropertyHideBanner(false)) {
		this.jq(ID_TIMELINE).find(".tl-storyslider").css("display","none");
		this.jq(ID_TIMELINE).find(".tl-menubar").css("display","none");		
	    } 
	    this.jq(ID_TIMELINE).find(".tl-text").css("padding","0px");
	    this.jq(ID_TIMELINE).find(".tl-slide-content").css("padding","0px 0px");
	    //	    this.jq(ID_TIMELINE).find(".tl-slide-content").css("width","100%");
	    this.jq(ID_TIMELINE).find(".tl-slidenav-description").css("display","none");
	    this.timelineReady = true;
	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    this.timeline.goTo(index);
	},
	getDate: function(time) {
	    if(!time)  {
		time = new Date();
		return   {year: time.getUTCFullYear()};
	    }
	    let dt =  {year: time.getUTCFullYear()};
	    let timeTo = this.getTimeTo();
	    if(timeTo!="year") {
		dt.month = time.getUTCMonth()+1;
		if(timeTo!="month") {
		    dt.day = time.getUTCDate();
		    if(timeTo!="day") {
			dt.hour = time.getHours();
			dt.minute = time.getMinutes();
			if(timeTo!="hour") {
			    dt.second = time.getSeconds();
			}
		    }
		}
	    }
	    return dt;
	}
    });
}

function RamaddaHoursDisplay(displayManager, id, properties) {
    const ID_TIMELINE = "timeline";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HOURS, properties);
    const BOX_COLOR = "lightblue";
    const MULTI_ID = "multiid";
    
    let myProps = [
	{label:'Hours'},
	{p:'dateField',ex:''},
	{p:'boxWidth',ex:''},
	{p:'boxColor',ex:'blue'},	
	{p:'rowBackground',ex:''},
	{p:'dayLabelStyle',ex:''},
	{p:'fillHours',ex:'false'},			
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
            let records = this.filterData();
	    if(records==null) return;
	    let _this =this;
	    let html = "";
	    let dateField = this.getFieldById(null,this.getPropertyDateField());
	    let days = [];
	    let dayToHours = {};
	    let dateFormat = this.getProperty("dateFormat","mdy");
	    this.recordToIndex = {};
	    let timeZoneOffset = +this.getProperty("timeZoneOffset",0);
	    records.forEach((record,idx)=>{
		this.recordToIndex[record.getId()] = idx;
		let dttm0 =dateField? recordtuple[dateField.getIndex()]: record.getTime();
		let dttm = dttm0;
		let newHours = dttm.getUTCHours()+timeZoneOffset;
		dttm = new Date(Date.UTC(dttm.getUTCFullYear(),dttm.getUTCMonth(),dttm.getUTCDate(),newHours));
		let hour = +dttm.getUTCHours();
		let dayDate = new Date(Date.UTC(dttm.getUTCFullYear(),dttm.getUTCMonth(),dttm.getUTCDate()));
		let dayInfo = dayToHours[dayDate];

		if(!dayInfo) {
		    dayInfo = dayToHours[dayDate] = {
			dttm:dttm,
			hours:[],
			minutesCount:{},
			hourToRecords:{},
			minHour: hour,
			maxHour:hour
		    };
		    days.push(dayDate);
		}
		dayInfo.minHour = Math.min(dayInfo.minHour,hour);
		dayInfo.maxHour = Math.max(dayInfo.maxHour,hour);		
		let minutes = dttm0.getMinutes();
		let key  = hour+"_"+minutes;
		if(!dayInfo.minutesCount[key]) dayInfo.minutesCount[key] = 0;
		dayInfo.minutesCount[key]++;
		if(!dayInfo.hourToRecords[hour]) {
		    dayInfo.hours.push(hour);
		    dayInfo.hourToRecords[hour] = [];
		}
		dayInfo.hourToRecords[hour].push(record);
	    });
	    Utils.sortDates(days);
	    html = HU.open("div",[ATTR_STYLE,"position:relative;"]) + HU.open(TAG_TABLE,["width","100%"]);
	    let boxWidth = this.getPropertyBoxWidth(10);
	    let boxColor = this.getPropertyBoxColor(BOX_COLOR);
	    let extra = "";
	    days.forEach(day=>{
		let dayInfo = dayToHours[day];
		if(this.getPropertyFillHours(true)) {
		    for(let i=dayInfo.minHour;i<dayInfo.maxHour;i++) {
			if(!dayInfo.hourToRecords[i]) {
			    dayInfo.hours.push(i);
			    dayInfo.hourToRecords[i] = [];
			}
		    }
		}
		let dayLabel = Utils.formatDateWithFormat(day,dateFormat,true);
		html +=  HU.tr([ATTR_STYLE,"border-bottom:1px solid #ccc;"],HU.tds([],["",HU.div([ATTR_CLASS,"display-hours-label"], dayLabel),"#"]));
		let multiCount = 0;
		Utils.sortNumbers(dayInfo.hours).forEach(hour=>{
		    let row = "<tr style='border-top:1px solid #ccc;'>";
		    //		    if(hour!=9) return
		    let hourLabel  = HU.div([ATTR_STYLE,this.getPropertyDayLabelStyle("")], Utils.formatHour(hour));
		    row += HU.td([WIDTH,"10","align","right"],hourLabel);
		    row += HU.open(TAG_TD,[ATTR_STYLE,HU.css('background','#efefef'),WIDTH,"100%"]);
		    row += HU.open("div",[ATTR_STYLE, HU.css(HEIGHT,"100%",POSITION,"relative",WIDTH,"100%",BACKGROUND,this.getPropertyRowBackground("#eee"))]);
		    row += "&nbsp;";
		    let displayed = {};
		    let didOne= false;
		    dayInfo.hourToRecords[hour].forEach(record=>{
			let dttm =dateField? record.getValue(dateField.getIndex()): record.getTime();
			let minutes = dttm.getMinutes();
			//pad a bit on the left
			let left =  Math.round(minutes/61.0*100)+"%";
			let key = hour+"_"+minutes;
			if(dayInfo.minutesCount[key]>1) {
			    if(!displayed[minutes])  {
				let multiId = this.domId("multi"+ (multiCount++));
				displayed[minutes] = {
				    multiid:multiId,
				    contents:""};
				row+= HU.div([ATTR_ID,multiId, ATTR_TITLE,"Click to view multiples","dttm",dayInfo.dttm.getTime(), "hour",hour,"minute",minutes, ATTR_STYLE, HU.css('top','0px','left',left),ATTR_CLASS,'display-hours-box-multi'],dayInfo.minutesCount[key]);
			    }
			    displayed[minutes].contents +=
				HU.div([MULTI_ID,displayed[minutes].multiid,RECORD_ID, record.getId(), RECORD_INDEX,_this.recordToIndex[record.getId()],
					ATTR_TITLE,"",ATTR_STYLE,
					HU.css(WIDTH,boxWidth+"px",BACKGROUND,boxColor),
					ATTR_CLASS,'display-hours-box'],"");
			} else {
			    let css = HU.css("position","absolute","top","0px",WIDTH,boxWidth+"px",'background',boxColor,'left',left);
			    row+= HU.div([RECORD_ID, record.getId(), RECORD_INDEX,_this.recordToIndex[record.getId()],
					  ATTR_TITLE,"",ATTR_STYLE, css,ATTR_CLASS,'display-hours-box']);
			}
			didOne=true;
		    });
		    for(minute in displayed) {
			let id = dayInfo.dttm.getTime()+"_" + hour +"_"+minute;
			extra+=HU.div([ATTR_ID,this.domId(id), ATTR_CLASS,"display-hours-box-extra"],displayed[minute].contents);
		    }
		    row+="</div></td>";
		    row+=HU.td([],dayInfo.hourToRecords[hour].length);
		    row +="</tr>"
 		    if(didOne) html+=row;
		});
	    });
	    html+="</table>";
	    html+=extra;
	    html+="&nbsp;</div>";
	    this.setContents(html);
	    this.multis = this.find(".display-hours-box-multi");
	    this.multis.click(function() {
		let id = $(this).attr("dttm")+"_" + $(this).attr("hour") +"_"+$(this).attr("minute");
		let div = _this.jq(id);
		if($(this).attr("showing")=="true") {
		    div.hide();
		    $(this).css("border","1px solid #ccc");
		    $(this).attr("showing",false);
		    return;
		}
		$(this).css("border","1px solid " + HIGHLIGHT_COLOR);
		$(this).attr("showing",true);
		div.show();
		div.position({
                    of: $(this),
                    my: "left top",
                    at: "left bottom+2",
                    collision: "none none"
		});
	    });
	    this.boxes = this.find(".display-hours-box");
	    this.boxes.click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		_this.boxes.css("background",BOX_COLOR);
		if(state)  {
		    $(this).css("background",HIGHLIGHT_COLOR);
		}
		let record = records[+$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    this.makeTooltips(this.boxes,records,null,null,false);
	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let select = ".display-hours-box[" + RECORD_ID +"='" + args.record.getId()+"']";
	    let box = this.find(select);
	    if(box.length) {
		this.boxes.css("background",BOX_COLOR);
		this.multis.css("background","#efefef");		
		let multiId = 	box.attr(MULTI_ID);
		if(multiId) {
		    let multi = this.find("#" + multiId);
		    if(multi.length>0) {
			box = multi;
			box.css("background",HIGHLIGHT_COLOR);
		    }
		}
		
		box.css("background",HIGHLIGHT_COLOR);
		HU.scrollVisible(this.getContents(), box);
	    }
	},
    });
}





function RamaddaBlankDisplay(displayManager, id, properties,type) {
    if(!properties.width) properties.width='100%';
    properties.showMenu = false;
    properties.showTitle = false;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, type??DISPLAY_BLANK, properties);
    defineDisplay(type!=null?this:addRamaddaDisplay(this), SUPER, [], {
        needsData: function() {
            return true;
        },
	//Overwrite the display message to put in in the header suffix
	setDisplayMessage:function(msg) {
	    if(this.dataLoadFailed) {
		return;
	    }

	    if(!Utils.stringDefined(msg)) {
		this.jq(ID_HEADER2_SUFFIX).html("").hide();
		return;
	    }
	    let header = this.jq(ID_HEADER2_SUFFIX);
	    if(header.length==0)
		header = this.jq(ID_HEADER2);
	    header.show();
	    header.html(HU.span([ATTR_CLASS,'display-output-message-tight'],msg));
	},
	setNoDataMessage:function(message) {
	    if(Utils.stringDefined(message)) {
		this.jq(ID_HEADER2_SUFFIX).show();
		this.jq(ID_HEADER2_SUFFIX).html(HU.span([ATTR_CLASS,'display-output-message-tight'],message));
	    }
	},
	clearDisplayMessage:function() {
	    this.jq(ID_HEADER2_SUFFIX).hide();
	},

	updateUI: function() {
	    let records = this.filterData();
	    this.setContents("");
	    if(!records) return;
	    let colorBy = this.getColorByInfo(records);
	    if(colorBy.index>=0) {
		records.forEach(record=>{
		    color =  colorBy.getColor(record.getData()[colorBy.index], record);
		});
		colorBy.displayColorTable();
	    }
	}});
}


function RamaddaFilterDisplay(displayManager, id, properties) {
    properties.hideFilterWidget=false;
    let SUPER =  new RamaddaBlankDisplay(displayManager, id,  properties,DISPLAY_FILTER);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
    });
}




function RamaddaHookDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HOOK, properties);
    if(properties.hook) {
	this.hook = new window[properties.hook];
    }
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        needsData: function() {
            return true;
        },
	call:function(what,data) {
	    if(!this.hook) return false;
	    if(!this.hook[what])  {
		return false;
	    }
	    this.hook[what](this,data);
	    return true;
	},
	updateUI: function() {
	    if(!this.hook) {
		this.setContents('No hook defined');
		return;
	    }
	    let records = this.filterData();
	    if(!records) return;
            let fields = this.getSelectedFields([]);
	    let allFields = this.getFields();
	    this.clearDisplayMessage();
	    if(!this.call('updateUI',{allFields:allFields,fields:fields,records:records})) {
		this.setContents('No updateUI defined in hook');
	    }
	}});
}


function RamaddaPreDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_PRE, properties);
    let myProps = [
	{label:'Pre'},
	{p:'numRecords',ex:'100',d:1000},
	{p:'includeGeo',ex:'true',d:true},	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) {
		this.setContents("Loading data...");		
		return;
	    }
            let pointData = this.dataCollection.getList()[0];
            let fields = pointData.getRecordFields();
	    let numRecords = this.getNumRecords();
	    let includeGeo = this.getIncludeGeo();
	    let html ="Number of records:" + records.length+"<pre>";
	    fields.forEach((f,idx)=>{
		if(idx>0) html+=", ";
		html+=f.getId() +"[" + f.getType()+"]";
	    });
	    if(includeGeo) html+=", latitude, longitude";
	    html+="\n";
	    records.every((r,idx)=>{
		if(numRecords>-1 && idx>numRecords) return false;
		let d = r.getData();
		d = d.map(d=>{
		    if(d.getTime) return this.formatDate(d);
		    return d;
		});
		html+="#" + idx+": ";
		html+=d.join(", ");
		if(includeGeo) {
		    html+=", " + r.getLatitude() +"," + r.getLongitude();
		}
		html+="\n";
		return true;
	    });
	    html+="</pre>"
	    this.setContents(html);
	}});
}



function RamaddaHtmltableDisplay(displayManager, id, properties,type) {
    const ID_TABLE  = "table";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, type??DISPLAY_HTMLTABLE, properties);
    let myProps = [
	{label:'Html Table'},
	{p:'numRecords',ex:'5000',d:5000,tt:'Number of records to show'},
	{p:'scrollY',ex:'300px'},				
	{p:'includeGeo',ex:'true',d:false},
	{p:'includeDate',ex:'true',d:false},
	{p:'includeRowIndex',ex:'true',d:false},	
	{p:'includeFieldDescription'},
	{p:'includeUnits',d:true},
	{p:'fancy',ex:'true',d:true},
	{p:'maxCellHeight',ex:'200px', tt:'Max cell height',d:'200px'},	
	{p:'maxLength',ex:'500',d:-1, tt:'If string is gt maxLength then scroll it'},
	{p:'maxColumns'},
	{p:'colorCells',ex:'field1,field2'},
	{p:'iconField'},
	{p:'linkField'},
	{p:'categoryField'},
	{p:'colorRowBy'},
	{p:'colorFullRow',d:true,tt:'If doing color row by do we color the full row or just the start'},	
	{p:'showColorFooter',d:true},
	{p:'colorHeaderLabel',tt:'Label for the color header'},
	{p:'colorHeaderTemplate',tt:'Template to show in row color header'},
	{p:'colorHeaderStyle',tt:'CSS for color header. defaults to rotated text'},	
        {p:'showBar',ex:'true',tt:'Default show bar'},
        {p:'highlightFilterText',ex:'true',tt:'Highlight any filter text'},	
        {p:'&lt;field&gt;.nowrap',ex:'true',tt:"Don't wrap the column"},
        {p:'&lt;field&gt;.width',ex:'30%',tt:"Column width"},
        {p:'&lt;field&gt;.template',ex:'foo:${value}',tt:"Record template"},		
        {p:'&lt;field&gt;.showBar',ex:'true',tt:'Show bar'},
        {p:'&lt;field&gt;.barMin',ex:'0',tt:'Min value'},
        {p:'&lt;field&gt;.barMax',ex:'100',tt:'Max value'},
	

	{p:'showSummary',ex:'true'},
	{p:'showSummaryTotal',ex:'true'},
	{p:'showSummaryAverage',ex:'true'},
	{p:'showSummaryMinMax',ex:'true'},
	{p:'showGrandSummary',ex:'true'},		

	{p:'barLabelInside',ex:'false'},
        {p:'barStyle',ex:'background:red;',tt:'Bar style'},			
	{p:'tableStyle',d:'border-left:var(--basic-border);border-right:var(--basic-border)'},
	{p:'tableHeaderStyle'},
 	{p:'tableCellStyle'},	
	{p:'showAddRow',ex:'true'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	displayData: function() {
	    this.updateUI();
	},
	makeColumn:function(record,field,attrs,v) {
	    return HU.td(attrs,v);
	},
	handleColumn:function(fields,aggByField,field,record,v,tdAttrs,matchers) {
	    if(!this.columnTemplates) {
		this.columnTemplates = {};
		fields.forEach((f,idx)=>{
		    let template = this.getProperty(f.getId()+"_template");
		    if(template) templates[f.getId()] = template;
		});
	    }
	    let template = this.columnTemplates[field.getId()];
	    if(template) {
		return this.getRecordHtml(record,null, template);
	    }
	    if(!aggByField) {
		let attrs=[...tdAttrs];
		attrs.push('field-id',field.getId(),'record-id',record.getId(),'record-index',record.rowIndex);
		if(matchers) {
		    let sv = String(v);
		    matchers.forEach(h=>{
			sv  = h.highlight(sv,field.getId());
		    });
		    v = sv;
		}

		return this.makeColumn(record,field,attrs,v);
	    }
	    if(field.getId() != aggByField.getId()) {
		return this.makeColumn(record,field,tdAttrs,v);
	    }
	    if(!record.isAggregate) {
		let spacer = "&nbsp;&nbsp;&nbsp;&nbsp;";
		return HU.td(tdAttrs,HU.row([["width","1%",ATTR_STYLE,"padding:2px;"], spacer],[[ATTR_STYLE,"padding:0px;"],v]));
	    }
	    let span = HU.span([ATTR_ID,aggId+"_toggle","toggleopen","false", ATTR_CLASS,"ramadda-clickable"],
			       HU.span([ATTR_ID,aggId+"_toggleimage"],HU.getIconImage("fas fa-chevron-right"))+"&nbsp;" + v);
	    tdAttrs = Utils.mergeLists(tdAttrs,["nowrap",null]);
	    return HU.td(tdAttrs,span);
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) {
		this.setDisplayMessage("Loading data...");		
		return;
	    }
	    //	    console.time('HtmlTable.update');
	    this.updateHtmlTable(records);
	    //	    console.timeEnd('HtmlTable.update');
	},
	updateHtmlTable: function(records) {
	    let fancy  = this.getFancy();
            let pointData = this.getPointData();
            let fields = pointData.getRecordFields();
            let selectedFields = this.getSelectedFields();
	    let urlField = this.getFieldById(null,this.getProperty("urlField"));
	    let iconField = this.getFieldById(null,this.getIconField());
	    let categoryField = this.getFieldById(null,this.getProperty('categoryField'));

	    fields= (selectedFields && selectedFields.length>0)?selectedFields:fields;
	    let anyGroups = fields.filter(f=>{
		if(f==null) return true;
		return f.getGroup()!=null;
	    }).length>0;

	    let groupCnt={};
	    if(anyGroups) {
		let groups = [];
		let group = null;
		for(let i=0;i<fields.length;i++) {
		    let field = fields[i];
		    if(field==null) continue;
		    group = field.getGroup();
		    if(group==null) {
			groups.push(field);
			continue;
		    }
		    groups.push(field);
		    groupCnt[group]=1;
		    for(let j=i+1;j<fields.length;j++) {
			if(fields[j]==null) continue;
			if(fields[j].getGroup()==field.getGroup()) {
			    groupCnt[group]++;
			    groups.push(fields[j]);
			    fields[j]=null;
			}
		    }
		}
		fields=groups;
	    }

	    let aggByField = this.getFieldById(null,this.getProperty("aggregateBy"));
	    if(aggByField) {
		//		aggByField.label = this.getProperty("aggregateName",this.getFieldLabel(aggByField));
		let csvUtil = new CsvUtil();
		let tmp = new PointData("", fields, records);
		let converted = csvUtil.process(this, tmp,"aggregate(includeRows=true, groupBy=" + aggByField.getId()+");");
		records = converted.getRecords();
		fields = converted.getRecordFields();
	    }

	    
	    let colorRowBy;
	    let colorFullRow = this.getColorFullRow();
	    let colorHeaderStyle =
		this.getColorHeaderStyle('font-weight:bold;margin-right:10px;margin-top:10px;margin-bottom:10px;writing-mode: vertical-lr; -ms-writing-mode: tb-rl; transform: rotate(180deg);font-size:80%;');

	    if(Utils.stringDefined(this.getProperty('colorRowBy'))) {
		colorRowBy=[];
		this.getProperty('colorRowBy').split(',').forEach(c=>{
		    let tmp =   this.getFieldById(null, c);
		    if(tmp) {
			let template = this.getProperty(c+'.colorHeaderTemplate',this.getProperty('colorHeaderTemplate'));
			let label = this.getProperty(c+'.colorHeaderLabel',this.getProperty('colorHeaderLabel'));
			colorRowBy.push({
			    template:template,
			    label:label,
			    colorBy:new ColorByInfo(this, null, records, null,null,null, null, tmp),
			});
		    }});
	    }


	    let colorByMap = {};
	    let cbs = [];
	    this.getColorCells("").split(",").forEach(c=>{
		let f = this.getFieldById(null,c);
		if(f) {
		    colorByMap[c] = new ColorByInfo(this, null, records, null,c+".colorByMap",null, c, f);
		    cbs.push(colorByMap[c]);
		}
	    });
	    
	    let numRecords = this.getNumRecords();
	    let includeIdx = this.getIncludeRowIndex();
	    let includeGeo = this.getIncludeGeo();
	    let includeDate = this.getIncludeDate();	    
	    let includeUnits = this.getIncludeUnits();	    
	    let html='';
	    //Only do the hover when we aren't coloring the rows
	    if(!colorRowBy) {
		html+=HU.cssTag('.display-htmltable-row:hover {background:var(--highlight-background) !important;');
	    }

	    if(this.getProperty('tableCellStyle')) {
		html+=HU.cssTag('.display-htmltable-td {' +
				this.getProperty('tableCellStyle')+'}');
	    }

	    html+=HU.open(TAG_DIV,[ATTR_ID,this.domId(ID_TABLE+'_wrapper')]);
	    html +=HU.openTag(TAG_TABLE,[ATTR_CLASS,"ramadda-table stripe", 'width','100%',ATTR_ID,this.domId(ID_TABLE),ATTR_STYLE,this.getTableStyle()]);
	    html+='\n';
	    let maxColumns = this.getMaxColumns(-1);
	    let headerAttrs = [ATTR_STYLE,"white-space:nowrap;background:#efefef;padding:5px; font-weight:bold;"];
	    headerAttrs = [];
	    html+="<thead>\n";
	    if(anyGroups) {
		let attrs = [ATTR_STYLE,HU.css("background","#fff","width","100%")];
		html+="<tr style='background:transparent;' valign=top>\n"
		let group = null;
		let seen = {};
		fields.forEach((f,idx)=>{
		    if(f.getGroup()) {
			if(group!=f.getGroup()) {
			    group = f.getGroup();
			    if(!seen[group]) {
				seen[group] =true;
				html+=HU.th([ATTR_CLASS,"display-table-group-header-th", ATTR_STYLE,HU.css("border-bottom","0px solid transparent", "background","transparent"), "colspan",groupCnt[group]],HU.div([ATTR_CLASS,"display-table-group-header"], group))+"\n";
			    }
			}
			return;
		    }
		    html+=HU.th([ATTR_STYLE,HU.css("border-bottom","0px solid transparent", "background","transparent")],HU.div(attrs,"&nbsp;"))+"\n";
		});
		html+="</tr>\n";
	    } 

	    let header1="<tr  valign=top>\n"
	    let header2="<tr  valign=top>\n"	    
	    if(includeDate) {
		header1+=HU.th([],HU.div(headerAttrs,"Date"));
		header2+=HU.th([],HU.div(headerAttrs,"Date"));
	    } else {
		fields = fields.filter(f=>{
		    return !f.isRecordDate();
		});
	    }

	    //Add the place holder for the colored rows
	    if(colorRowBy && !colorFullRow) {
		colorRowBy.forEach(c=>{
		    header1+=HU.th([ATTR_STYLE,'max-width:16px;width:16px;'],HU.div([],c.label));
		    header2+=HU.th([ATTR_STYLE,'max-width:16px;width:16px;'],HU.div([],c.label));		    
		});
	    }


	    if(includeIdx) {
		header1+=HU.th(HU.div([],""));
		header2+=HU.th(HU.div([],""));
	    }

	    let headerStyle = this.getTableHeaderStyle("")+"text-align:center;";
	    let fieldMap = {}
	    let sortFields = this.getProperty("sortFields");
	    let sortAscending = this.getSortAscending();
	    if(sortFields) {
		let tmp = {};
		sortFields.split(",").forEach(f=>{tmp[f]=true;});
		sortFields= tmp;
	    }
	    fields.forEach((f,idx)=>{
		if(maxColumns>0 && idx>=maxColumns) return;
		fieldMap[f.getId()] = f;
		let sort = sortFields && sortFields[f.getId()];
		let title = f.getDescription();
		if(title) title+="&#10;";
		title=title??"";
		title+="Click to sort";
		let attrs = [ATTR_TITLE,title,ATTR_CLASS,"ramadda-clickable display-table-header", "field-id",f.getId(),ATTR_STYLE,headerStyle];
		let width = this.getProperty(f.getId()+".width");
		if(width) attrs.push("width",width);

		if(sort) {
		    attrs.push("sorted");
		    attrs.push("true");
		}

		if(fancy) {
		    let label = this.getFieldLabel(f);
		    if(sort) label = HU.getIconImage(sortAscending?"fas fa-arrow-down":"fas fa-arrow-up",null, [ATTR_STYLE,HU.css('font-size','8pt !important')]) +" " + label;
		    let desc = includeUnits?f.getUnitLabel(this):f.getLabel(this);
		    header1+=HU.th(attrs,HU.div(headerAttrs,desc));
		    header2+=HU.th(attrs,HU.div(headerAttrs,f.getDescription()??""));
		}
		else {
		    header1+=HU.th(attrs,HU.div(headerAttrs,f.getId() +"[" + f.getType()+"]"));
		    header2+=HU.th(attrs,HU.div(headerAttrs,f.getId() +"[" + f.getDescription()??""+"]"));
		}
		
	    });

	    if(includeGeo) header1+=HU.th([],HU.div(headerAttrs,"latitude")) + HU.th([],HU.div(headerAttrs,"longitude"));
	    if(includeGeo) header2+=HU.th([],HU.div(headerAttrs,"")) + HU.th([],HU.div(headerAttrs,""));	    
	    header1+="</tr>\n";
	    header2+="</tr>\n";	    
	    html+=header1;
	    if(this.getIncludeFieldDescription()) {
		html+=header2;
	    }
	    html+='</thead>';
	    html+=HU.open('tbody',[ATTR_STYLE,HU.css('max-height','200px','overflow-y','auto')]);
	    this.recordMap = {};
	    this.fieldMap = {};
	    fields.forEach(f=>{this.fieldMap[f.getId()] = f;})
 	    let aggId = "";
	    let aggIds = [];


	    let colAttrs = {
	    }
	    fields.forEach((f,idx)=>{
		let attrs = colAttrs[f.getId()] = []
		let width = this.getProperty(f.getId()+".width");
		if(width) attrs.push("width",width);
		if(this.getProperty(f.getId()+".nowrap",false))
		    attrs.push("nowrap","true");
	    });

	    let maxLength = this.getMaxLength();
	    let maxHeight = this.getMaxCellHeight();
	    let category;
	    let fieldProps = {};
	    fields.forEach(f=>{
		if(f.isFieldNumeric()) {
		    let showBar = this.getProperty("showBar",false);
		    fieldProps[f.getId()] = {
			isNumeric:true,
			showBar: this.getProperty(f.getId()+".showBar",showBar),
			barMin: this.getProperty(f.getId()+".barMin",0),
			barMax: this.getProperty(f.getId()+".barMax",100),
			barStyle: this.getProperty(f.getId()+".barStyle",this.getProperty("barStyle",'')),
			barLabelInside: this.getProperty(f.getId()+".barLabelInside",this.getProperty("barLabelInside")),
			barLength:this.getProperty('barLength','100px')
		    }
		}
	    });

	    let summary=[];
	    let columns;
	    let recordCnt = 0;
	    let addColumn = (td,v,field)=>{
		if(recordCnt==1) {
		    summary.push({field:field,total:0,cnt:0,min:NaN,max:NaN});
		}
		columns.push(td);
		if(!isNaN(v)) {
		    let s = summary[columns.length-1];
		    s.total+=v;
		    s.cnt++;
		    s.min = isNaN(s.min)?v:Math.min(s.min,v);
		    s.max = isNaN(s.max)?v:Math.max(s.max,v);		    
		} 
	    }
	    let cellCnt = 0;
	    let even=false;
	    let matchers = this.getHighlightFilterText()?this.getFilterTextMatchers():null;
	    records.every((record,recordIdx)=>{
		if(numRecords>-1 && recordIdx>numRecords) return false;
		even=!even;
		recordCnt++;
		let d = record.getData();
		d = d.map(v=>{
		    if(!v) return v;
		    if(v.getTime) return this.formatDate(v);
		    return v;
		});

		//		if(recordIdx>40) return true;
		let prefix = "";
		if(record.isAggregate) {
		    aggId = HU.getUniqueId("agg_")
		    aggIds.push(aggId);
		}

		let clazz =  "display-htmltable-row";
		columns = [];
		//Add the place holder for the colored rows
		if(colorRowBy && !colorFullRow) {
		    colorRowBy.forEach(c=>{
			let color =  c.colorBy.getColorFromRecord(record);
			let label = '';
			if(c.template) {
			    let template = c.template.replace(/{fieldname}/g,c.colorBy.getField().getLabel());
			    template = template.replace(/{field/g,'{'+c.colorBy.getField().getId());
			    label = this.getRecordHtml(record, null, template);
			    label = HU.div([ATTR_STYLE,colorHeaderStyle], label);
			}
			addColumn(HU.td([ATTR_CLASS,'display-td display-htmltable-td',ATTR_STYLE,'width:24px;max-width:24px;border-right:1px solid #444;background:' + color+';width:24px;'],label));
		    });
		}

		if(includeIdx) {
		    addColumn(HU.td(['width','5px'],HU.div([],"#" +(recordIdx+1))));
		}
		if(includeDate) {
		    addColumn(HU.td([],this.formatDate(record.getDate())));
		}
		this.recordMap[record.rowIndex] = record;
		this.recordMap[record.getId()] = record;
		fields.forEach((f,idx)=>{
		    if(maxColumns>0 && idx>=maxColumns) return;
		    cellCnt++;
		    let value = d[f.getIndex()];
		    let svalue = String(value);
		    let sv =  this.formatFieldValue(f,record,svalue);
		    if(maxLength>0 && sv.length>maxLength && f.isString()) {
			if(!record.isAggregate) {
			    sv = HU.div([ATTR_STYLE,maxHeight?HU.css('max-height',maxHeight,'overflow-y','auto'):''],sv);
			}
		    } else if(maxHeight) {
			sv = HU.div([ATTR_STYLE,HU.css('max-height',maxHeight,'overflow-y','auto')],sv);
		    }
		    if(f.getType()=="image") {
			let url = record.getValue(f.getIndex());
			sv = HU.image(url,['loading','lazy',ATTR_STYLE,HU.css("width","150px;")]);
		    }

		    if(idx==0 && iconField) {
			let icon = record.getValue(iconField.getIndex());
			sv = HU.image(icon,[ATTR_STYLE,HU.css("max-width","50px;")]) +"&nbsp;" +sv;
		    }
		    if(urlField && idx==0) {
			let url = record.getValue(urlField.getIndex());
			if(sv && Utils.stringDefined(url)) {
			    if(sv) sv = svalue.trim();
			    sv = HU.href(url,sv,['target','_other']);
			}
		    }

		    let colorBy = colorByMap[f.getId()];
		    let color = null;
		    let foreground="#000";
		    let tdAttrs = [];
		    let props = fieldProps[f.getId()]??{};
		    if(props.isNumeric)
			tdAttrs = ["align","right"];
		    tdAttrs.push(ATTR_CLASS,"display-td display-htmltable-td");		    
		    let attrs = colAttrs[f.getId()];
		    if(attrs) tdAttrs = Utils.mergeLists(tdAttrs,attrs);
		    if(svalue.trim().length==0)
			tdAttrs.push('nullvalue','true');

		    if(colorBy) {
			let color =  colorBy.getColorFromRecord(record);
			let fg =  Utils.getForegroundColor(color);
			addColumn(HU.td(Utils.mergeLists(tdAttrs, [ATTR_STYLE,HU.css('background', color,'color',fg+" !important")]),sv),null,f);
		    } else if(props.showBar) {
			let percent = 1-(value-props.barMin)/(props.barMax-props.barMin);
			percent = (percent*100)+"%";
			let contents = "";
			sv = Utils.formatNumberComma(value)+"%";
			if(props.barLabelInside) {
			    contents = HU.div([ATTR_STYLE,HU.css("padding-left","2px")],sv);
			    sv = "";
			}
			let bar = HU.div([ATTR_CLASS,"ramadda-bar-inner", ATTR_STYLE,HU.css("right",percent)+props.barStyle],contents);
			let width = props.barLength;
			let outer = HU.div([ATTR_CLASS,"ramadda-bar-outer", ATTR_STYLE,
					    (width?HU.css("width",HU.getDimension(width)):"")+
					    HU.css("min-width","100px")+(props.barLabelInside?HU.css("height","1.5em"):"")],bar);
			if(props.barLabelInside) {
			    addColumn(HU.td([],outer),null,f);
			} else {
			    addColumn(HU.td([],HU.row([["align","right"],sv],outer)),null,f);
			}
		    } else if(props.isNumeric) {
			let td = this.handleColumn(fields,aggByField,f,record,this.formatNumber(value,f.getId()), tdAttrs);
			addColumn(td,value,f);
		    } else {
			addColumn(this.handleColumn(fields,aggByField,f,record,sv,tdAttrs,matchers),null,f);
		    }
		    prefix="";
		});



		if(includeGeo) {
		    columns.push(HU.td([],record.getLatitude()),HU.td([],record.getLongitude()));
		}

		if(categoryField) {
		    let c = categoryField.getValue(record);
		    if(c!=category && c!='') {
			//add in the extra columns so datatables doesn't choke
			category=c;
			let extra = '';
			for(let j=0;j<columns.length-1;j++)
			    extra+=HU.td([ATTR_STYLE,'display:none;',ATTR_CLASS,'display-htmltable-category-cell',],'');
			let row = HU.tr([ATTR_CLASS,'display-htmltable-category-row'], HU.td([ATTR_CLASS,'display-htmltable-category-cell','colspan',columns.length],HU.div([ATTR_CLASS,'display-htmltable-category'],c))+extra);
			html+=row;
		    }
		}		

		let rowStyle = '';
		if(colorRowBy && colorRowBy.length && colorFullRow) {
		    let color =  colorRowBy[0].colorBy.getColorFromRecord(record);
		    if(color)rowStyle+=HU.css('background',color);
		}
		if(record.isAggregate)
		    html+=HU.openTag(TAG_TR,[ATTR_STYLE,rowStyle,'aggregateRow',aggId,ATTR_STYLE,HU.css("font-weight","550"),
					     ATTR_TITLE,'','valign','top',ATTR_CLASS,clazz, RECORD_ID,record.getId()]);
		else if (aggByField)
		    html+=HU.openTag(TAG_TR,[ATTR_STYLE,'display:none;', "aggregateId", aggId,
					     ATTR_TITLE,'','valign','top',ATTR_CLASS,clazz, RECORD_ID,record.getId()]);
		else
		    html+=HU.openTag(TAG_TR,[ATTR_STYLE,rowStyle,"aggregateId", aggId,
					     ATTR_TITLE,'','valign','top',ATTR_CLASS,clazz +' display-htmltable-row-' +(even?'even':'odd'), RECORD_ID,record.getId()]);
		
		if(colorRowBy && colorRowBy.length && colorFullRow) {
		    let color =  colorRowBy[0].colorBy.getColorFromRecord(record);
		    if(color)rowStyle+=HU.css('background',color);
		}



		html+=Utils.join(columns,'');
		html+="</tr>\n";
		return true;
	    });

	    html+=HU.close('tbody');
	    html+=HU.open('tfoot');
	    html+=HU.open(TAG_TR);
	    let total = NaN;
	    if(summary && (this.getShowSummaryTotal() || this.getShowSummaryAverage()  ||
			   this.getShowSummaryMinMax())) {
		total=0;
		summary.forEach(s=>{
		    html+="<td align=right style='padding:0px;'>";
		    let ok  = (main,what)=>{
			if(s.field) {
			    if(s.field.isFieldString()) return false;
			    return this.getProperty(s.field.getId()+'.'+what,main);
			}
			return main;
		    }

		    if(s.cnt) {
			let v = [];
			if(ok(this.getShowSummaryTotal(),'showSummaryTotal')) {
			    v.push('Total: '+s.total);
			}
			if(ok(this.getShowSummaryAverage(),'showSummaryAverage')) {
			    let avg = s.total/s.cnt;
			    avg = Utils.formatNumberComma(avg,2);
			    v.push('Avg: '+ avg);
			}
			if(ok(this.getShowSummaryMinMax(),'showSummaryMinMax')) {
			    v.push('Min: '+s.min);
			    v.push('Max: '+s.max);
			}
			html+=HU.div([ATTR_STYLE,'text-align:right;'],Utils.join(v,'<br>'));
			total+=s.total;
		    }
		    html+="</td>";
		});
	    }
	    html+=HU.close(TAG_TR);
	    html+=HU.close('tfoot');
	    html+=HU.close(TAG_TABLE);
	    html+=HU.close(TAG_DIV);
	    if(!isNaN(total) && this.getShowGrandSummary()) {
		html+='Total: ' + total;
	    }
	    if(this.getShowAddRow()) {
		html+=HU.div([ATTR_ID,this.domId("addrow"),ATTR_CLASS,"ramadda-clickable"], HU.getIconImage("fas fa-plus"));
	    }	
	    if(cellCnt==0) {
		this.setContents('');
		this.setDisplayMessage('No data available');
		return;
	    }
	    this.setContents(html);
	    aggIds.forEach(id=>{
		$("#"+ id+"_toggle").click(function() {
		    let open = $(this).attr("toggleopen")=="true";
		    $(this).attr("toggleopen",!open);
		    let row = _this.jq(ID_TABLE).find(HU.attrSelect("aggregateRow", id));
		    if(open) {
			row.find(".display-td").css("font-weight","plain").css("border-bottom","0px");
			row.css("font-weight","plain").css("border-bottom","0px");

			_this.jq(ID_TABLE).find(HU.attrSelect("aggregateId", id)).hide();
 			$(this).find("#" + id+"_toggleimage").html(HU.getIconImage("fas fa-chevron-right"));
		    } else {
			row.find(".display-td").css("font-weight","bold").css("border-bottom","1px solid #888");
			_this.jq(ID_TABLE).find(HU.attrSelect("aggregateId", id)).show();
			$(this).find("#" + id+"_toggleimage").html(HU.getIconImage("fas fa-chevron-down"));
		    }
		});
	    });
	    let dom = this.jq(ID_COLORTABLE);
	    let colorBarCnt = 0;
	    dom.html('');
	    cbs.forEach((cb,idx)=>{
		idx = (colorBarCnt++);
		let id = this.domId(ID_COLORTABLE+idx);
		dom.append(HU.div([ATTR_ID,id]));
		cb.displayColorTable(null,true,ID_COLORTABLE+idx);
	    });
	    if(colorRowBy && this.getShowColorFooter()) {
		colorRowBy.forEach((cb,idx)=>{
		    if(idx>0)
			dom.append(HU.div([ATTR_STYLE,'border-bottom:1px solid #ccc']));
		    idx = (colorBarCnt++);
		    let id = this.domId(ID_COLORTABLE+idx);
		    dom.append(HU.div([ATTR_ID,id]));
		    cb.colorBy.displayColorTable(null,true,ID_COLORTABLE+idx);
		});
	    }

	    let headers =  this.find(".display-table-header");
	    headers.click(function() {
		let field = fieldMap[$(this).attr("field-id")];
		if($(this).attr("sorted")==="true") {
		    _this.setProperty("sortAscending",!_this.getSortAscending());
		} 
		_this.setProperty("sortFields", field.getId());
		_this.sortByFieldChanged(field.getId());
	    });


	    let _this = this;
	    let tooltipClick = this.getProperty("tooltipClick");
	    let rows = this.jq(ID_TABLE).find(".display-htmltable-row");
	    this.makeTooltips(rows,records);
	    rows.click(function() {
		let record = _this.recordMap[$(this).attr(RECORD_ID)];
		if(!record) return;
		_this.propagateEventRecordSelection({record:record});
	    });
	    let scrollHeight=this.getScrollY("400px");
	    let opts = {
                ordering: false,
		scrollY:scrollHeight,
		paging:this.getProperty('tablePaging')
	    };

	    //	    console.log('HtmlTable: #cells:' +cellCnt);
	    let wrapper = this.jq(ID_TABLE+'_wrapper');
	    if(!opts.paging && cellCnt>3000) {
		wrapper.css('max-height',scrollHeight).css('height',scrollHeight).css('overflow-y','auto').css('display','flex');
		wrapper.find('th').css('top','0').css('position','sticky').css('z-index','900');
		this.jq(ID_TABLE).css('height','200px').css('overflow-y','auto').css('border-collapse','collapse');
	    } else {
		HU.formatTable("#" + this.domId(ID_TABLE), opts);
	    }

	    if(this.getShowAddRow()) {
		this.jq("addrow").click(()=>{
		    let records = this.getPointData().getRecords();
		    let newRow = records[records.length-1].clone();
		    records.push(newRow);
		    this.updateUI();
		    this.getPointData().propagateEventDataChanged(this);
		});
	    }
	    let handleChange = dom=>{
		let val;
		if(dom.attr('inputtype')=="checkbox") {
		    val = dom.is(':checked');
		} else {
		    val = dom.val();
		}
		
		let fieldId = dom.attr("fieldid");
		let recordIndex = dom.attr(RECORD_INDEX); 
		let row = _this.recordMap[recordIndex];
		let field = _this.fieldMap[fieldId];		
		row.data[field.getIndex()] = val;
		_this.getPointData().propagateEventDataChanged(_this);
	    }
	    this.jq(ID_DISPLAY_CONTENTS).find(".display-editable").change(function() {
		handleChange($(this));
	    });
	    this.jq(ID_DISPLAY_CONTENTS).find(".display-editable").keypress(function(event) {
                if (event.which == 13) {
		    handleChange($(this));
		}
	    });
	    //	    console.timeEnd('start2');	    
	    //	    console.timeEnd('start');

	}});
}

function RamaddaPolltableDisplay(displayManager, id, properties) {
    const ID_VOTE_STATS = 'votesstats';
    const ID_SHOW_VOTES = 'showvotes';
    const ID_TOGGLE_CELLS = 'togglecells';	    	    



    const SUPER =  new RamaddaHtmltableDisplay(displayManager, id, properties,'polltable');
    let myProps = [
	{label:'Poll Table'},
	{p:'pollFields',tt:'Fields to poll on'}
    ]


    const TOGGLED_CSS='3em';

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	isPollField(field) {
	    if(!this.pollFields)
		this.pollFields = this.getPollFields('').split(',');
	    return this.pollFields.includes(field);
	},
	makeColumn:function(record,field,attrs,v) {
	    if(!this.isPollField(field.getId())) {
		return SUPER.makeColumn.call(this,record,field,attrs,v);
	    }
	    v = HU.div([ATTR_STYLE,HU.css('overflow-y','auto','max-height',this.cellsToggled?TOGGLED_CSS:'500px'),ATTR_CLASS,'display-polltable-field','data-record-id',record.getId()],v);
	    return HU.td(attrs,v);
	},
	measureCont:function(yes,no) {
	    if(no>0 && yes>0 && yes+no>10 ) {
		let diff= Math.abs(yes-no);
		let p = diff/(yes+no);
		//		console.log(yes,no," DIFF:" + diff,p,1-p);
		return 1-p;
	    }
	    return 0;
	},
	getRecords: function() {
	    let records = SUPER.getRecords.call(this);
	    if(!records) return null;
	    this.applyVotesToData(records);
	    return records;
	},
	applyVotesToData:function(records) {
    	    if(!this.votingData) {
		return;
	    } 
	    let recordToVotes = {};
	    Object.keys(this.votingData).forEach(key=>{
		[recordIndex,field] = key.split('--');
		if(!recordToVotes[recordIndex]) {
		    recordToVotes[recordIndex] = [];
		}
		recordToVotes[recordIndex].push(this.votingData[key]);
	    });
	    let upvotes,downvotes,controversial; 
	    records.forEach((record) =>{
		if(!upvotes) {
		    record.getFields().forEach(f=>{
			if(f.getId()=='upvotes') upvotes = f;
			else if(f.getId()=='downvotes') downvotes = f;
			else if(f.getId()=='controversial') controversial = f;			    
		    });
		}
		let rowIndex = record.getRowIndex();
		if(recordToVotes[rowIndex]) {
		    let yes = 0;
		    let no = 0;
		    let maxCont=0;
		    recordToVotes[rowIndex].forEach(vote=>{
			yes+=vote.yes;
			no+=vote.no;			    
			let cont = this.measureCont(vote.yes,vote.no);
			maxCont = Math.max(maxCont,cont);
		    });

		    if(upvotes)
			record.setValue(upvotes.getIndex(),yes);
		    if(downvotes)
			record.setValue(downvotes.getIndex(),no);
		    record.setValue(controversial.getIndex(),maxCont);
		}
	    });
	},
	updateUI: function() {
	    if(!this.votingData) {
		let url = ramaddaBaseUrl + "/entry/vote?entryid=" + this.getProperty("entryId", "");
		$.getJSON(url, (data) =>{
		    this.votingData = data;
		    this.updateUI();
		});
	    }
	    let _this = this;
            SUPER.updateUI.call(this);
	    if(!Utils.isDefined(this.cellsToggled)) {
		this.cellsToggled = false;
	    }
	    let buttons = HU.buttons([HU.div([ATTR_STYLE,'min-width:130px;',ATTR_ID,this.domId(ID_TOGGLE_CELLS)],this.cellsToggled?'Expand Cells':'Toggle Cells'),
				      HU.div([ATTR_STYLE,'min-width:130px;',ATTR_ID,this.domId(ID_SHOW_VOTES)],'Show Votes'),
				      HU.span([ATTR_ID,this.domId(ID_VOTE_STATS),ATTR_STYLE,'display:inline-block;min-width:300px'],''),				      
				     ],'');				      
	    this.jq(ID_HEADER0).html(buttons);
	    let pollFields = this.getContents().find('.display-polltable-field');
	    this.jq(ID_TOGGLE_CELLS).button().click(()=>{
		if(_this.cellsToggled) {
		    _this.jq(ID_TOGGLE_CELLS).html('Toggle Cells');
		    pollFields.css('max-height','500px');
		} else {
		    pollFields.css('max-height',TOGGLED_CSS);
		    _this.jq(ID_TOGGLE_CELLS).html('Expand Cells');
		}
		this.cellsToggled = !this.cellsToggled
		pollFields.attr('toggled',this.cellsToggled);
	    });
	    pollFields.click(function() {
		let toggled = $(this).attr('toggled')??'false';
		let items = $(this).closest(TAG_TR).find('.display-polltable-field');
		if(toggled==='false') {
		    items.css('max-height',TOGGLED_CSS);
		    items.attr('toggled',true);
		} else {
		    items.css('max-height','500px');
		    items.attr('toggled',false);
		}
	    });

	    this.jq(ID_SHOW_VOTES).button().click(()=>{
		this.showingVotes=!this.showingVotes;
		this.applyShowVotes();
	    });
	    let entry  =this.getProperty('entryId');
	    this.applyShowVotes();
	    this.addVotes();

	},
	addVotes:function() {
	    let _this = this;
            this.jq(ID_DISPLAY_CONTENTS).find('.display-polltable-block').remove();
            this.jq(ID_DISPLAY_CONTENTS).find('.display-polltable-padding').remove();	    
            this.jq(ID_DISPLAY_CONTENTS).find(TAG_TD).each(function() {
		if(!$(this).attr('field-id'))return;
		let field =$(this).attr('field-id');
		if(!_this.isPollField(field)) {
		    return
		}

		let c = $(this).html().trim();
		if(c=='' || $(this).attr('nullvalue')==='true') return
		let record =$(this).attr('record-index');		
		$(this).append(HU.div([ATTR_STYLE,'height:2em',ATTR_CLASS,'display-polltable-padding']));
		let contents = HU.leftRightTable(HU.div(['field-id',field,'record-index',record,'vote','yes',ATTR_CLASS,'vote ramadda-clickable',
							 ATTR_TITLE,'Up vote'],HU.getIconImage('fa-regular fa-thumbs-up')),
						 HU.div(['field-id',field,'record-index',record,'vote','no',ATTR_CLASS,'vote ramadda-clickable',
							 ATTR_TITLE,'Down vote'],HU.getIconImage('fa-regular fa-thumbs-down')));
		$(this).append(HU.div(['field-id',field,'record-index',record,ATTR_CLASS,'display-polltable-block',ATTR_STYLE,'border-top:1px solid #ccc;position:absolute;right:0px;left:10px;bottom:0px;'],contents));
	    });

            this.jq(ID_DISPLAY_CONTENTS).find('.vote').click(function() {
		let thumb= $(this);
		let vote =$(this).attr('vote');
		if(!Utils.isDefined(vote)) {
		    return;
		}
		let field =$(this).attr('field-id');
		let record =$(this).attr('record-index');		
		let id = _this.getProperty("entryId", "");
		let url = ramaddaBaseUrl + "/entry/vote?xreturnvotes=true&entryid=" + id;
		let key = record+'--'+field;
		url = HU.url(url,['key',key,'vote',vote]);
		$.getJSON(url, function(data) {
		    if(data.error) {
			console.log('An error occurred:' + data.error);
		    } 
		    if(!_this.canEdit()) {
			thumb.attr('vote',null);
			thumb.html('--');
		    }
		    if(_this.votingData) {
			let obj = _this.votingData[key];
			if(!obj) {
			    _this.votingData[key] = obj ={no:0,yes:0};
			}
			if(vote=='yes') obj.yes++;
			else obj.no++;
		    }
		}).fail(function(data) {
		    alert('An error occurred');
		});
	    });
	    

	},
	applyShowVotes:function () {
	    let _this = this;
	    let padding = this.jq(ID_DISPLAY_CONTENTS).find('.display-polltable-padding');
	    if(!this.showingVotes) {
		padding.css('height','2em');
		this.jq(ID_SHOW_VOTES).html('Show Votes');
		this.addVotes();
		this.jq(ID_VOTE_STATS).html('');
		return;
	    }
	    //	    this.jq(ID_VOTE_STATS).show();
	    //	    padding.css('height','4em');
	    this.jq(ID_SHOW_VOTES).html('Hide Votes');
	    let id = this.getProperty("entryId", "");
	    let url = ramaddaBaseUrl + "/entry/vote?entryid=" + id;
	    $.getJSON(url, function(data) {
		this.votingData = data;
		let blocks = _this.jq(ID_DISPLAY_CONTENTS).find('.display-polltable-block');
		let statsYes;
		let statsNo;		
		Object.keys(data).forEach(key=>{
		    let d = data[key]
		    if(Utils.isDefined(d.yes)) {
			if(!statsYes)
			    statsYes={min:d.yes,max:d.yes,total:0}
			statsYes.min = Math.min(statsYes.min, d.yes);
			statsYes.max = Math.max(statsYes.max, d.yes);			
			statsYes.total+=d.yes;
		    }
		    if(Utils.isDefined(d.no)) {
			if(!statsNo)
			    statsNo={min:d.no,max:d.no,total:0}
			statsNo.min = Math.min(statsNo.min, d.no);
			statsNo.max = Math.max(statsNo.max, d.no);			
			statsNo.total+=d.no;
		    }		    
		});
		let stats = '';
		if(statsYes) {
		    stats +='Total yes votes: ' + statsYes.total;
		    statsYes.range = statsYes.max-statsYes.min;
		}
		if(statsNo) {
		    stats +=HU.space(2)+'Total no votes: ' + statsNo.total;
		    statsNo.range = statsNo.max-statsNo.min;
		}
		stats+=HU.space(2)+'('+HU.span([ATTR_STYLE,'font-weight:bold;color:#D85F48'],'* controversial')+')';
		_this.jq(ID_VOTE_STATS).html(stats)
		let ct = Utils.getColorTable('plotly_reds',true);
		let getContColor = (yes,no,cont) =>{
		    let c;
		    if(cont>0.5) {
			let idx=Math.min(ct.length-1,Math.max(0,parseInt(cont*ct.length)))
			c=ct[idx];
		    }
		    return c;
		}
		blocks.each(function() {
		    let field =$(this).attr('field-id');
		    let record =$(this).attr('record-index');		
		    let key = record+'--'+field;
		    let voteObj = data[key];
		    let yes = 0, no = 0;
		    if(voteObj) {
			yes = voteObj.yes??yes;
			no = voteObj.no??no;				
		    } 
		    let percentYes = 0;
		    let percentNo=0;
		    if(statsYes) {
			if(statsYes.total>0)
			    percentYes = parseInt(100*(yes/statsYes.total));
			else
			    percentYes = 100
		    }
		    if(statsNo) {
			if(statsNo.total>0)
			    percentNo = parseInt(100*(no/statsNo.total));
			else
			    percentNo = 100
		    }		    
		    let label = HU.open(TAG_TABLE,['cellpadding','0', 'cellspacing','0', 'border','0','width','100%']);
		    let style = 'padding:0px !important;padding-right:4px !important;font-size:9pt;';
		    let cont = _this.measureCont(yes,no);
		    let c = getContColor(yes,no,cont);
		    if(c) {
			style+=HU.css('color',c,'font-weight','bold');
		    }
		    let icon = i=>{
			let attrs=[];
			if(c) attrs.push(ATTR_STYLE,HU.css('color',c));
			return HU.getIconImage(i,[],attrs);
		    }
		    let line = (vote,percent,i)=>{
			let title = c?'Controversial':'';
			label += HU.tr([ATTR_TITLE,title],HU.td(['width','5px',ATTR_STYLE,style,'align','right'], icon(i))+
				       HU.td([ATTR_STYLE,style], vote+' (' + percent+'%) ' +(c?'*':'')));
		    }
		    line(yes,percentYes,'fa-regular fa-thumbs-up');
		    line(no,percentNo,'fa-regular fa-thumbs-down');		    
		    label+='</table>'
		    $(this).html(label);
		});
	    }).fail(function(data) {
		alert('An error occurred');
	    });

	}
	

    });
}




function RamaddaTsneDisplay(displayManager, id, properties) {
    const ID_CANVAS = "tsnecanvas";
    const ID_DETAILS = "tsnedetails";
    const ID_RUN = "tsnerun";
    const ID_RESET = "tsnereset";
    const ID_STEP = "tsnestep";
    const ID_SEARCH = "tsnesearch";
    $.extend(this, {
        colorTable: "red_white_blue",
        colorByMin: "-1",
        colorByMax: "1",
        height: "500px;"
    });

    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TSNE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        nameToIndex: {},
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        updateUI: async function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            await Utils.importJS(RamaddaUtil.getCdnUrl("/lib/tsne.js"));
            //Height is the height of the overall display including the menu bar
            let height = this.getProperty("height",400);
            if (String(height).endsWith("px")) height = String(height).replace("px", "");
            height = parseInt(height);
            //            height-=30;
            let details = HU.div([ATTR_STYLE, HU.css('height', height + 'px','max-height', height + "px"), ATTR_CLASS, "display-tnse-details", ATTR_ID, this.domId(ID_DETAILS)], "");
            let canvas = HU.div([ATTR_CLASS, "display-tnse-canvas-outer", ATTR_STYLE, HU.css('height', height + 'px')], HU.div([ATTR_CLASS, "display-tnse-canvas", ID, this.domId(ID_CANVAS)], ""));
            let buttons = HU.div([ATTR_ID, this.domId(ID_RUN), ATTR_CLASS, "ramadda-button", "what", "run"], "Stop") + SPACE +
                HU.div([ATTR_ID, this.domId(ID_STEP), ATTR_CLASS, "ramadda-button", "what", "step"], "Step") + SPACE +
                HU.div([ATTR_ID, this.domId(ID_RESET), ATTR_CLASS, "ramadda-button", "what", "reset"], "Reset") + SPACE +
                HU.input("", "", [ATTR_ID, this.domId(ID_SEARCH), "placeholder", "search"]);

            buttons = HU.div([ATTR_CLASS, "display-tnse-toolbar"], buttons);
            this.jq(ID_TOP_LEFT).append(buttons);
            this.setContents(HU.table([WIDTH,'100%'], HU.tr(['valign','top'], HU.td(['width','80%'], canvas) + HU.td(['width','20%'], details))));
            this.search = this.jq(ID_SEARCH);
            this.search.keyup(e => {
                let v = this.search.val().trim();
                this.canvas.find(".display-tnse-mark").removeClass("display-tnse-highlight");
                if (v == "") return;
                v = v.toLowerCase();
                for (name in this.nameToIndex) {
                    if (name.toLowerCase().startsWith(v)) {
                        this.jq("element-" + this.nameToIndex[name]).addClass("display-tnse-highlight");
                    }
                }
            });
            this.details = this.jq(ID_DETAILS);
            this.reset = this.jq(ID_RESET);
            this.step = this.jq(ID_STEP);
            this.step.button().click(() => {
                this.running = false;
                this.run.html(this.running ? "Stop" : "Run");
                this.takeStep();
            });
            this.reset.button().click(() => {
                this.start();
            });
            this.run = this.jq(ID_RUN);
            this.run.button().click(() => {
                this.running = !this.running;
                if (this.running) this.takeStep();
                this.run.html(this.running ? "Stop" : "Run");
            });
            this.canvas = this.jq(ID_CANVAS);
            this.running = true;
            this.start();
        },
        start: function() {
            this.canvas.html("");
            this.haveStepped = false;
            this.dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            if (!this.fields) {
                this.fields = this.getSelectedFields([]);
                if (this.fields.length == 0) this.fields = allFields;
                let strings = this.getFieldsByType(this.fields, "string");
                if (strings.length > 0)
                    this.textField = strings[0];
            }
            let data = [];
            for (let rowIdx = 1; rowIdx < this.dataList.length; rowIdx++) {
                let tuple = this.getDataValues(this.dataList[rowIdx]);
                let nums = [];
                for (let i = 0; i < this.fields.length; i++) {
                    if (this.fields[i].isNumeric()){
                        let v = tuple[this.fields[i].getIndex()];
                        if(isNaN(v)) v = 0;
                        nums.push(v);
                    }
                }
                data.push(nums);
            }

            let opt = {}
            opt.epsilon = 10; // epsilon is learning rate
            opt.perplexity = 30; // how many neighbors each point influences
            opt.dim = 2; // dimensionality of the embedding (2 = default)
            this.tsne = new tsnejs.tSNE(opt);
            this.tsne.initDataRaw(data);
            this.takeStep();
        },
        takeStep: function() {
            let numSteps = 10;
            for (let step = 0; step < numSteps; step++) {
                this.tsne.step();
            }

            let pts = this.tsne.getSolution();
            let minx, miny, maxx, maxy;
            for (let i = 0; i < pts.length; i++) {
                if (i == 0) {
                    maxx = minx = pts[i][0];
                    maxy = miny = pts[i][1];
                } else {
                    maxx = Math.max(maxx, pts[i][0]);
                    minx = Math.min(minx, pts[i][0]);
                    maxy = Math.max(maxy, pts[i][1]);
                    miny = Math.min(miny, pts[i][1]);
                }
            }
            let sleep = 250;
            for (let i = 0; i < pts.length; i++) {
                let x = pts[i][0];
                let y = pts[i][1];
                let px = 100 * (x - minx) / (maxx - minx);
                let py = 100 * (y - miny) / (maxy - miny);
                if (!this.haveStepped) {
                    let title = "";
                    if (this.textField) {
                        let tuple = this.getDataValues(this.dataList[i]);
                        title = tuple[this.textField.getIndex()];
                    }
                    if (title.length > 10) {
                        title.length = 10;
                    }
                    this.nameToIndex[title] = i;
                    this.canvas.append(HU.div([ATTR_TITLE, title, "index", i, ATTR_ID, this.domId("element-" + i),
					       ATTR_CLASS, "display-tnse-mark", ATTR_STYLE, HU.css('left', px + '%', 'top',py +'%')], title));
                } else {
                    this.jq("element-" + i).animate({
                        left: px + "%",
                        top: py + "%"
                    }, sleep, "linear");
                }
	    }
            let _this = this;
            if (!this.haveStepped) {
                this.canvas.find(".display-tnse-mark").click(function(e) {
                    let index = parseInt($(this).attr("index"));
                    if (index < 0 || index >= _this.dataList.length) return;
                    let tuple = _this.getDataValues(_this.dataList[index]);
                    let details = HU.open(TAG_TABLE,[ATTR_CLASS,'formtable',WIDTH,'100%']);
                    for (let i = 0; i < _this.fields.length; i++) {
                        let field = _this.fields[i];
                        details += HU.tr([],HU.td(['align','right', ATTR_CLASS,'formlabel'], this.getFieldLabel(field) + ':') + HU.td([],tuple[field.getIndex()]));
                    }
                    details += HU.close(TABLE);
                    _this.details.html(details);
                });
            }
            if (!this.haveStepped) {
                //                this.haveStepped = true;
                //                this.takeStep();
                //                return;
            }
            this.haveStepped = true;
            if (this.running)
                setTimeout(() => this.takeStep(), sleep);
        },
    });
}


function RamaddaHeatmapDisplay(displayManager, id, properties) {
    $.extend(this, {
        colorTable: "red_white_blue",
    });
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HEATMAP, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        "map-display": false,
        needsData: function() {
            return true;
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            let tmp = HU.formTable();
            let colorTable = this.getColorTableName();
            let ct = HU.open('select',[ATTR_ID,this.domId("colortable")]);
            for (table in Utils.ColorTable) {
                if (table == colorTable)
                    ct += HU.tag('option',['selected',null], table);
                else
                    ct += HU.tag('option',[], table);
            }
            ct += HU.close('select');
            tmp += HU.formEntry("Color Table:", ct);
            tmp += HU.formEntry("Color By Range:", HU.input("", this.colorByMin, ["size", "7", ATTR_ID, this.domId("colorbymin")]) + " - " +
				HU.input("", this.colorByMax, ["size", "7", ATTR_ID, this.domId("colorbymax")]));
            tmp += HU.close(TABLE);
            menuItems.push(tmp);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function() {
                _this.colorByMin = _this.jq("colorbymin").val();
                _this.colorByMax = _this.jq("colorbymax").val();
                _this.updateUI();

            };
            let func2 = function() {
                _this.colorTable = _this.jq("colortable").val();
                _this.updateUI();

            };
            this.jq("colorbymin").blur(updateFunc);
            this.jq("colorbymax").blur(updateFunc);
            this.jq("colortable").change(func2);
        },

        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        getContentsStyle: function() {
            let height = this.getProperty("height", -1);
            if (height > 0) {
                return " height:" + height + "px; " + " max-height:" + height + "px; overflow-y: auto;";
            }
            return "";
        },
        updateUI: function(pointData) {
            let _this = this;
            if (!haveGoogleChartsLoaded()) {
                let func = function() {
                    _this.updateUI();
                }
                this.setDisplayMessage(this.getLoadingMessage());
                setTimeout(func, 1000);
                return;
            }

            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let dataList = this.getStandardData(null, {
                includeIndex: true
            });
            let header = this.getDataValues(dataList[0]);
            let showIndex = this.getProperty("showIndex", true);
            let showValue = this.getProperty("showValue", true);
            let textColor = this.getProperty("textColor", "black");

            let cellHeight = this.getProperty("cellHeight", null);
            let extraTdStyle = "";
            if (this.getProperty("showBorder")) {
                extraTdStyle = HU.css("border-bottom","1px #666 solid");
            }

            let extraCellStyle = "";
            if (cellHeight)
                extraCellStyle += HU.css("height", cellHeight + "px","max-height", cellHeight + "px","min-height", cellHeight + "px");

            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);

            if (fields.length == 0) fields = allFields;
            let html = "";
            let colors = null;
            let colorByMin = null;
            let colorByMax = null;
            if (Utils.stringDefined(this.getProperty("colorByMins"))) {
                colorByMin = [];
                let c = this.getProperty("colorByMins").split(",");
                for (let i = 0; i < c.length; i++) {
                    colorByMin.push(parseFloat(c[i]));
                }
            }
            if (Utils.stringDefined(this.getProperty("colorByMaxes"))) {
                colorByMax = [];
                let c = this.getProperty("colorByMaxes").split(",");
                for (let i = 0; i < c.length; i++) {
                    colorByMax.push(parseFloat(c[i]));
                }
            }

            if (Utils.stringDefined(this.getProperty("colorTables"))) {
                let c = this.getProperty("colorTables").split(",");
                colors = [];
                for (let i = 0; i < c.length; i++) {
                    let name = c[i];
                    if (name == "none") {
                        colors.push(null);
                        continue;
                    }
                    let ct = Utils.getColorTable(name, true);
                    //                        console.log("ct:" + name +" " +(ct!=null));
                    colors.push(ct);
                }
            } else {
                colors = [this.getColorTable(true)];
            }
            let mins = null;
            let maxs = null;
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let row = this.getDataValues(dataList[rowIdx]);
                if (mins == null) {
                    mins = [];
                    maxs = [];
                    for (let colIdx = 1; colIdx < row.length; colIdx++) {
                        mins.push(Number.MAX_VALUE);
                        maxs.push(Number.MIN_VALUE);
                    }
                }

                for (let colIdx = 0; colIdx < fields.length; colIdx++) {
                    let field = fields[colIdx];
                    //Add one to the field index to account for the main time index
                    let index = field.getIndex() + 1;
                    if (!field || !field.isFieldNumeric() || field.isFieldGeo()) continue;

                    let value = row[index];
                    if (value == Number.POSITIVE_INFINITY || isNaN(value) || !Utils.isNumber(value) || !Utils.isDefined(value) || value == null) {
                        continue;
                    }
                    mins[colIdx] = Math.min(mins[colIdx], value);
                    maxs[colIdx] = Math.max(maxs[colIdx], value);
                }
            }

            html += HU.open(TABLE, ["border", "0", ATTR_CLASS, "display-heatmap"]);
            html += HU.open(TR,[VALIGN,'bottom']);
            if (showIndex) {
                html += HU.td([ALIGN,'center'], HU.div([ATTR_CLASS, "display-heatmap-heading-top"], header[0]));
            }
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let field = fields[fieldIdx];
                if ((!field.isFieldNumeric() || field.isFieldGeo())) continue;
                html += HU.td([ALIGN,'center'], HU.div([ATTR_CLASS, "display-heatmap-heading-top"], this.getFieldLabel(field)));
            }
            html += HU.close(TR);

            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let row = this.getDataValues(dataList[rowIdx]);
                let index = row[0];
                //check if its a date
                if (index.f) {
                    index = index.f;
                }
                let rowLabel = index;
                html += HU.open(TAG_TR,['valign','center']);
                if (showIndex) {
                    html += HU.td([ATTR_CLASS, "display-heatmap-heading-side", ATTR_STYLE, extraCellStyle + extraTdStyle], rowLabel);
                }
                let colCnt = 0;
                for (let colIdx = 0; colIdx < fields.length; colIdx++) {
                    let field = fields[colIdx];
                    //Add one to the field index to account for the main time index
                    let index = field.getIndex() + 1;
                    if (!field || !field.isFieldNumeric() || field.isFieldGeo()) continue;
                    let style = "";
                    let value = row[index];
                    let min = mins[colIdx];
                    let max = maxs[colIdx];
                    if (colorByMin && colCnt < colorByMin.length)
                        min = colorByMin[colCnt];
                    if (colorByMax && colCnt < colorByMax.length)
                        max = colorByMax[colCnt];

                    let ok = min != max && !(value == Number.POSITIVE_INFINITY || isNaN(value) || !Utils.isNumber(value) || !Utils.isDefined(value) || value == null);
                    let title = header[0] + ": " + rowLabel + " - " + this.getFieldLabel(field) + ": " + value;
                    if (ok && colors != null) {
                        let ct = colors[Math.min(colCnt, colors.length - 1)];
                        if (ct) {
                            let percent = (value - min) / (max - min);
                            let ctIndex = parseInt(percent * ct.length);
                            if (ctIndex >= ct.length) ctIndex = ct.length - 1;
                            else if (ctIndex < 0) ctIndex = 0;
                            style = "background-color:" + ct[ctIndex] + ";";
                        }
                    }
                    let number;
                    if (!ok) {
                        number = "-";
                    } else {
                        number = Utils.formatNumber(value)
                    }
                    if (!showValue) number = ""; 
                    html += HU.td(["valign", "center", "align", "right", ATTR_STYLE, style + extraCellStyle + extraTdStyle,
				   ATTR_CLASS, "display-heatmap-cell"], HU.div([ATTR_TITLE, title, ATTR_STYLE, extraCellStyle + HU.css('color',textColor)], number));
                    colCnt++;
                }
                html += HU.close(TR);
            }
            html += HU.close(TABLE);
            this.setContents(html);
            this.initTooltip();

        },
    });
}




function RamaddaRankingDisplay(displayManager, id, properties) {
    const ID_TABLE = "rankingtable";
    $.extend(this, {
	height: "500px",
        sortAscending:false,
    });
    if(properties.sortAscending) this.sortAscending = "true" == properties.sortAscending;
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RANKING, properties);
    let myProps = [
	{label:'Ranking'},
	{p:'sortField',ex:''},
	{p:'nameFields',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            let records = this.records =  this.filterData();
            if (records == null) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    this.idToRecord = {};
	    records.forEach(record=>{
		this.idToRecord[record.getId()] = record;
	    });

            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);
            if (fields.length == 0) fields = allFields;
            let numericFields = this.getFieldsByType(fields, "numeric");
            let sortField = this.getFieldById(numericFields, this.getProperty("sortField","",true));
            if (numericFields.length == 0) {
                this.setContents("No fields specified");
                return;
            }
            if (!sortField) {
                sortField = numericFields[0];
            }
            if (!sortField) {
                this.setDisplayMessage("No fields specified");
                return;
            }

            let stringFields = this.getFieldsByIds(allFields, this.getProperty("nameFields","",true));
            if(stringFields.length==0) {
		let tmp = this.getFieldById(allFields, this.getProperty("nameField","",true));
		if(tmp) stringFields.push(tmp);
	    }
            if(stringFields.length==0) {
                let stringField = this.getFieldByType(allFields, "string");
		if(stringField) stringFields.push(stringField);
	    }
            let menu = HU.open("select",[ATTR_CLASS,'ramadda-pulldown',ATTR_ID, this.domId("sortfields")]);
            for (let i = 0; i < numericFields.length; i++) {
                let field = numericFields[i];
                let extra = "";
                if (field.getId() == sortField.getId()) extra = " selected ";
                menu += HU.tag('option',['value', field.getId(), extra,null], this.getFieldLabel(field));
            }
            menu += HU.close('select');
	    let top ="";
	    top += HU.span([ATTR_ID,this.domId("sort")], HU.getIconImage(this.sortAscending?"fa-sort-up":"fa-sort-down", [ATTR_STYLE,HU.css('cursor','pointer'),ATTR_TITLE,"Change sort order"]));
            if (this.getProperty("showRankingMenu", true)) {
                top+= " " + HU.div([ATTR_STYLE,HU.css('display','inline-block'), ATTR_CLASS,"display-filterby"],menu);
            }
	    this.jq(ID_TOP_LEFT).html(top);
	    this.jq("sort").click(()=>{
		this.sortAscending= !this.sortAscending;
		if(this.sortAscending) 
		    this.jq("sort").html(HU.getIconImage("fa-sort-up", [ATTR_STYLE,HU.css('cursor','pointer')]));
		else
		    this.jq("sort").html(HU.getIconImage("fa-sort-down", [ATTR_STYLE,HU.css('cursor','pointer')]));
		this.updateUI();
	    });
            let html = "";
            html += HU.open(DIV, [ATTR_STYLE, HU.css('max-height','100%','overflow-y','auto')]);
            html += HU.open(TABLE, [ATTR_ID, this.domId(ID_TABLE)]);
            let tmp = records;
	    let includeNaN = this.getProperty("includeNaN",false);
	    if(!includeNaN) {
		let tmp2 = [];
		tmp.map(r=>{
		    let v = sortField.getValue(r);
		    if(!isNaN(v)) tmp2.push(r);
		});
		tmp = tmp2;
	    }
            let cnt = 0;
	    let highlight = this.getFilterHighlight();
	    let sorter = (a,b)=>{
		let r1 = a;
		let r2 = b;
		let h1 = r1.isHighlight(this);
		let h2 = r2.isHighlight(this);
		if(highlight) {
		    if(h1 && !h2) return 1;
		    if(!h1 && h2) return -1;
		}
                let t1 = this.getDataValues(a);
                let t2 = this.getDataValues(b);
                let v1 = t1[sortField.getIndex()];
                let v2 = t2[sortField.getIndex()];
                if (v1 < v2) return -1;
                if (v1 > v2) return 1;
                return 0;
	    };
            tmp.sort((a, b) => {
		let v = sorter(a,b);
		if(v==0) return 0;
		if(this.sortAscending) return v;
		return  -v;
            });


            for (let rowIdx = 0; rowIdx < tmp.length; rowIdx++) {
                let record = tmp[rowIdx];
                let tuple = this.getDataValues(record);
                let label = "";
                stringFields.map(f=>{
		    label += f.getValue(record)+" ";
		});
                label = label.trim();
		value = sortField.getValue(record);
                if (isNaN(value) || value === null) {
		    if(!includeNaN) continue;
		    value = "NA";
		} else {
		    value = this.formatNumber(value);
		}
		html += HU.tr([VALIGN,'top',ATTR_CLASS,'display-ranking-row','what',record.getId()],
			      HU.td([],'#' + (rowIdx + 1)) + HU.td([],SPACE + label) +HU.td([ALIGN,'right'], SPACE +
											    value));
            }
            html += HU.close(TABLE);
            html += HU.close(DIV);
            this.setContents(html);
            let _this = this;
            this.jq(ID_TABLE).find(".display-ranking-row").click(function(e) {
		let record = _this.idToRecord[$(this).attr("what")];
		_this.propagateEventRecordSelection({record:record});
            });
	    HU.initSelect(this.jq("sortfields"));
            this.jq("sortfields").change(function() {
                _this.setProperty("sortField", $(this).val());
                _this.updateUI();
            });
        },
    });
}


function RamaddaWaffleDisplay(displayManager, id, properties) {
    const ID_TABLE = "rankingtable";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_WAFFLE, properties);
    let myProps = [
	{label:'Waffle'},
	{p:'labelField',ex:''},
	{p:'boxSize',d:'15px'},
	{p:'showFieldLabel',d:true},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            let records = this.records =  this.filterData();
            if (records == null) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);
	    let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    if(!labelField) {
		let strings = this.getFieldsByType(null, "string");
		if(strings.length>0) labelField = strings[0];
	    }
	    let html = '';
	    let showFieldLabel = this.getShowFieldLabel();
	    let colors =  Utils.split(this.getColors('#F7931F,#4CC1EF,#C13018,#A6C68E,#89A7DE'),',',true,true);
	    fields.forEach((field,idx)=>{
		if(idx>0) html+='<p>';
		if(showFieldLabel)
		    html+=HU.b(field.getLabel())+'<br>';
		records.forEach((r,idx)=>{
		    let label  = labelField?r.getValue(labelField.getIndex()):index;
		    let percent  = parseInt(field.getValue(r)*100);
		    let box = "<table cellpadding=0 cellspacing=0 style='border:1px solid #ccc;border-collapse: collapse;'>";
		    
		    let percentCnt = 0;
		    let size= HU.getDimension(this.getBoxSize());
		    let color = colors[idx%colors.length];
		    for(let row=0;row<10;row++) {
			box+='<tr>';
			for(let col=0;col<10;col++) {
			    percentCnt++;
			    let style = 'width:'+ size+';height:'+ size+';border-width:1px;border-left-width:0px;';
			    let boxPercent = 100-percentCnt;
			    if(boxPercent<percent) style+=HU.css('background', color);
			    box+=HU.td(HU.td([ATTR_STYLE,style],''));
			}
			box+='</tr>';
		    }
		    box+='</table>';
		    html+=HU.div([ATTR_STYLE,HU.css('display','inline-block','margin-right','20px')],
				 HU.b(label+ ' ' +percent+'%') +'<br>' +box);
		});

	    });
            this.setContents(html);
	}
    });
}



function RamaddaCrosstabDisplay(displayManager, id, properties) {
    const ID_TABLE = "crosstab";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CROSSTAB, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let allFields = this.dataCollection.getList()[0].getRecordFields();
	    let enums = [];
	    allFields.map(field=>{
		let label = this.getFieldLabel(field);
		if(label.length>30) label = label.substring(0,29);
		enums.push([field.getId(),label]);
	    });
	    let select = HU.span([ATTR_CLASS,"display-filterby"],
				 "Display: " + HU.select("",[ATTR_STYLE,"", ID,this.domId("crosstabselect")],enums,
							 this.getProperty("column", "", true)));


            this.setContents(select+HU.div([ATTR_ID,this.domId(ID_TABLE)]));
	    let _this = this;
	    this.jq("crosstabselect").change(function() {
		_this.setProperty("column", $(this).val());
		_this.makeTable();
	    });
	    this.makeTable();
	},
	makeTable: function() {
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
	    let col =  this.getFieldById(null, this.getProperty("column", "", true));
	    let rows =  this.getFieldsByIds(null, this.getProperty("rows", null, true));
	    if(!col) col  = allFields[0];
	    if(rows.length==0) rows  = allFields;

            let html = HU.open(TABLE, ["border", "1px", "bordercolor", "#ccc",
				       ATTR_CLASS, "display-crosstab", "cellspacing", "1", "cellpadding", "2"]);
	    let total = dataList.length-1;
	    let cnt =0;
	    rows.map((row)=>{
		if(row.getId()==col.getId()) return;
		cnt++;
		let colValues = [];
		let rowValues = [];
		let count ={};
		let rowcount ={};
		let colcount ={};
		for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
		    let tuple = this.getDataValues(dataList[rowIdx]);
		    let colValue = (""+tuple[col.getIndex()]).trim();
		    let rowValue = (""+tuple[row.getIndex()]).trim();
		    let key = colValue+"--" + rowValue;
		    if(colValues.indexOf(colValue)<0) colValues.push(colValue);
		    if(rowValues.indexOf(rowValue)<0) rowValues.push(rowValue);
		    if (!(rowValue in rowcount)) {
			rowcount[rowValue] = 0;
		    }
		    rowcount[rowValue]++;
		    if (!(key in count)) {
			count[key] = 0;
		    }
		    count[key]++;
		}
		colValues.sort();
		rowValues.sort();
		if(cnt==1)
		    html+=HU.tr([],HU.td()+ HU.td([ALIGN,'center',
						   ATTR_CLASS,'display-crosstab-header','colspan',colValues.length], col.getLabel()) +HU.td([],SPACE));
		html+=HU.open(TR,[VALIGN,'bottom',ATTR_CLASS,'display-crosstab-header-row'],
			      HU.td([ATTR_CLASS,'display-crosstab-header'],row.getLabel()));
		for(let j=0;j<colValues.length;j++) {
		    let colValue = colValues[j];
		    html+=HU.td([],(colValue==""?"&lt;blank&gt;":colValue));
		}
		html+=HU.td([],HU.b('Total'));
		html+=HU.close(TR);
		for(let i=0;i<rowValues.length;i++) {
		    let rowValue = rowValues[i];
		    html+=HU.open(TR);
		    html+=HU.td([], (rowValue==""?"&lt;blank&gt;":rowValue));
		    for(let j=0;j<colValues.length;j++) {
			let colValue = colValues[j];
			let key = colValue+"--" + rowValue;
			if(Utils.isDefined(count[key])) {
			    let perc = Math.round(count[key]/total*100) +"%";
			    html+=HU.td([ALIGN,'right'], count[key] +"&nbsp;(" + perc+")");
			} else {
			    html+=HU.td([],SPACE);
			}
		    }
		    let perc = Math.round(rowcount[rowValue]/total*100) +"%";
		    html+=HU.td([ALIGN,'right'], rowcount[rowValue] +SPACE +'(' + perc+')');
		    html+=HU.close(TR);
		}
	    });
            html += HU.close(TABLE);
	    this.jq(ID_TABLE).html(html);
        },
    });
}




function RamaddaCorrelationDisplay(displayManager, id, properties) {
    const ID_SLIDER_LOW = "sliderlow";
    const ID_SLIDER_LOW_MIN = "sliderlowmin";
    const ID_SLIDER_LOW_MAX = "sliderlowmax"
    const ID_SLIDER_HIGH = "sliderhigh";
    const ID_SLIDER_HIGH_MIN = "sliderhighmin";
    const ID_SLIDER_HIGH_MAX = "sliderhighmax"    
    const ID_TABLE = "table";
    const ID_LASTROW = "lastrow";
    $.extend(this, {
        colorTable: "red_white_blue",
        colorByMin: "-1",
        colorByMax: "1",
    });

    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CORRELATION, properties);
    let myProps = [
	{label:'Correlation'},
	{p:'showSelectSlider',ex:'false',d:true},
	{p:'showDownload',ex:true,d:false},
	{p:'range.low.min',ex:'-1'},
	{p:'range.low.max',ex:'0'},
	{p:'range.high.min',ex:'0'},
	{p:'range.high.max',ex:'1'},
	{p:'short',ex:'true',tt:'Abbreviated display'},
	{p:'includeGeo',ex:'true',ex:true},	
	{p:'showValue',ex:'false',tt:'Show the values'},
	{p:'stringsOk',ex:'true',tt:'Show string values'},	
	{p:'useId ',ex:' true',tt:'Use field id instead of label'},
	{p:'useIdTop',ex:'true',tt:'Use field id for top header'},
	{p:'useIdSide ',ex:'true',tt:'Use field id for side header'},
	{p:'labelStyle',ex:'',tt:'CSS style for labels'},
	{p:'sideHeadingStyle'}

    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        "map-display": false,
        needsData: function() {
            return true;
        },


        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            let tmp = HU.formTable();
            let colorTable = this.getColorTableName();
            let ct = HU.open('select',[ATTR_ID,this.domId("colortable")]);
            for (table in Utils.ColorTables) {
                if (table == colorTable)
                    ct += HU.tag('option',['selected',null],table);
                else
                    ct += HU.tag('option',[], table);
            }
            ct += HU.close('select');
            tmp += HU.formEntry("Color Bar:", ct);
            tmp += HU.formEntry("Color By Range:", HU.input("", this.colorByMin, ["size", "7", ATTR_ID, this.domId("colorbymin")]) + " - " +
				HU.input("", this.colorByMax, ["size", "7", ATTR_ID, this.domId("colorbymax")]));
            tmp += HU.close(TABLE);
            menuItems.push(tmp);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function() {
                _this.colorByMin = _this.jq("colorbymin").val();
                _this.colorByMax = _this.jq("colorbymax").val();
                _this.updateUI();

            };
            let func2 = function() {
                _this.colorTable = _this.jq("colortable").val();
                _this.updateUI();

            };
            this.jq("colorbymin").blur(updateFunc);
            this.jq("colorbymax").blur(updateFunc);
            this.jq("colortable").change(func2);
        },

        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    let _this  = this;
	    let html = "";
	    if(this.getProperty("showDownload",false)) {
		html+=HU.div([ATTR_ID,this.domId('download')],'Download Correlation Table');
	    }
	    this.range = {
		low:{
		    min:this.getProperty("range.low.min",-1),
		    max:this.getProperty("range.low.max",0)
		},
		high: {
		    min:this.getProperty("range.high.min",0),
		    max:this.getProperty("range.high.max",1)
		}
	    }
	    if(this.getShowSelectSlider()) {
		let lowSlider = HU.div([ATTR_STYLE,HU.css('display','inline-block')],HU.div([],"Negative Correlation") +  
				       HU.div([ATTR_ID,this.gid(ID_SLIDER_LOW_MIN),ATTR_STYLE,HU.css(WIDTH,'50px','display','inline-block','text-align','right','margin-right','15px')],this.range.low.min) +
				       HU.div([ATTR_STYLE,HU.css(HEIGHT,'20px','display','inline-block',WIDTH,'200px','background',this.getProperty('lowSliderBackground','#FD9596')), ID,this.gid(ID_SLIDER_LOW)]) +
				       HU.div([ATTR_ID,this.gid(ID_SLIDER_LOW_MAX),ATTR_STYLE,HU.css('text-align','left','width','50px','display','inline-block','margin-left','15px')],this.range.low.max));
		let highSlider = HU.div(["display","inline-block;"], HU.div([],"Positive Correlation") +
					HU.div([ATTR_ID,this.gid(ID_SLIDER_HIGH_MIN),ATTR_STYLE,HU.css('width','50px','display','inline-block','text-align','right', 'margin-right','15px')],this.range.high.min) +
					HU.div([ATTR_STYLE,HU.css(HEIGHT,'20px','display','inline-block','width','200px','background',this.getProperty('highSliderBackground','#64A982')), ID,this.gid(ID_SLIDER_HIGH)]) +
					HU.div([ATTR_ID,this.gid(ID_SLIDER_HIGH_MAX),ATTR_STYLE,HU.css('text-align','left','width','50px','display','inline-block','margin-left','15px')],this.range.high.max));


		html +=HU.center(HU.hrow(lowSlider, highSlider));
	    }
	    html +=HU.div([ATTR_ID,this.domId(ID_TABLE)]);
            this.setContents(html);
	    this.jq('download').button().click(()=>{
		let c='';
		this.csv.forEach(row=>{
		    c+=Utils.join(row,',');
		    c+='\n';
		});
		Utils.makeDownloadFile(this.getProperty('downloadFile','correlation.csv'),c);
	    });
	    this.makeTable();
	    if(this.getShowSelectSlider()) {
		this.jq(ID_SLIDER_LOW).slider({
		    range: true,
		    min: 0,
		    max: 100,
		    values:[(this.range.low.min+1)*100,(this.range.low.max+1)*100],
		    slide: function( event, ui ) {
			let v1 = -1+ui.values[0]/100;
			let v2 = -1+ui.values[1]/100;
			let s1 = v1==-1?-1:number_format(v1,3);
			let s2 = v2==0?0:number_format(v2,3);
			_this.jq(ID_SLIDER_LOW_MIN).html(s1);
			_this.jq(ID_SLIDER_LOW_MAX).html(s2);
		    },
		    stop: function(event,ui) {
			_this.range.low.min =   -1+2*ui.values[0]/100;
			_this.range.low.max  = -1+2*ui.values[1]/100;
			_this.makeTable();
		    }
		});
		this.jq(ID_SLIDER_HIGH).slider({
		    range: true,
		    min: 0,
		    max: 100,
		    values:[this.range.high.min*100,this.range.high.max*100],
		    slide: function( event, ui ) {
			let v1 = ui.values[0]/100;
			let v2 = ui.values[1]/100;
			_this.jq(ID_SLIDER_HIGH_MIN).html(v1==0?0:number_format(v1,3));
			_this.jq(ID_SLIDER_HIGH_MAX).html(v2==1?1:number_format(v2,3));

		    },
		    stop: function(event,ui) {
			_this.range.high.min =  ui.values[0]/100;
			_this.range.high.max  = ui.values[1]/100;
			_this.makeTable();
		    }
		});


		
	    }
            this.initTooltip();
            this.displayManager.propagateEventRecordSelection(this,
							      this.dataCollection.getList()[0], {
								  index: 0
							      });
        },
	getCellLabel(row,col) {
	    return   this.getProperty('label.' + row.getId() +'.' +
				      col.getId());
	},
	makeTable: function() {
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);
            if (fields.length == 0) fields = allFields;
	    let stringsOk = this.getStringsOk();
	    fields = fields.filter(field=>{
		if (field.isFieldGeo()) {
		    if(!this.getIncludeGeo()) {
			return false;
		    }
		}
		if(!stringsOk && !field.isFieldNumeric())  return false;
		return true;
	    });
            let fieldCnt = fields.length;
	    let html = "";
	    if(fields.length>8) {
		html+=HU.openTag("div",[ATTR_STYLE,HU.css('font-size','75%')]);
	    }
	    this.csv =[];
            html += HU.open(TABLE, ["cellspacing","0","cellpadding", "0", "border", "0",
				    ATTR_CLASS, "display-correlation", "width", "100%"]);
            let col1Width = 10 + "%";
            let width = 90 / fieldCnt + "%";
            html += HU.open(TR,["valign","bottom"]) + HU.td([ATTR_CLASS,"display-heading","width", col1Width],SPACE);

            let short = this.getProperty("short", false);
            let showValue = this.getProperty("showValue", !short);
            let useId = this.getProperty("useId", false);
            let useIdTop = this.getProperty("useIdTop", useId);
            let useIdSide = this.getProperty("useIdSide", useId);
	    let labelStyle = this.getProperty("labelStyle","");
	    let row;
	    this.csv.push(row=[]);
	    fields.forEach(field=>{
                let label = useIdTop ? field.getId() : this.getFieldLabel(field);
		row.push(label);
                if (short) label = "";
		label = label.replace(/\/ +/g,"/").replace(/ +\//g,"/");
		label = HU.div([ATTR_CLASS,'display-correlation-header',ATTR_STYLE,labelStyle], label);

                html += HU.td(["colfield", field.getId(), "align","center","width",width],
			      HU.div([ATTR_CLASS, "display-correlation-heading display-correlation-heading-top"], label));
            });
            html += HU.close(TR);
	    if(!this.getProperty("colorTable"))
		this.setProperty("colorTable","red_white_green");
	    let colors =  this.getColorTable(true);
            colorByMin = parseFloat(this.colorByMin);
            colorByMax = parseFloat(this.colorByMax);
	    if(colors) colors =  this.addAlpha(colors,0.5);

	    let sideHeadingStyle=this.getSideHeadingStyle('');
	    let stringMap = {};
	    fields.forEach(field=>{
		if(!field.isNumeric()) {
		    stringMap[field.getId()] = {
			count:0,
			seen:{}
		    };
		}
	    });
	    let getValue = (field,value) =>{
		if(!field.isNumeric()) {
		    let map =  stringMap[field.getId()];
		    if(!Utils.isDefined(map.seen[value])) {
			map.seen[value]  = map.count++;
		    }
		    return  map.seen[value];
		}
		return value;
	    }


            for (let fieldIdx1 = 0; fieldIdx1 < fields.length; fieldIdx1++) {
		this.csv.push(row=[]);
                let field1 = fields[fieldIdx1];
                let label = useIdSide ? field1.getId() : this.getFieldLabel(field1);
		row.push(label);
		label.replace(/ /g, SPACE);
		label = HU.div([ATTR_CLASS,'display-correlation-header',ATTR_STYLE,labelStyle], label);
                html += HU.open(TR, ["valign","center"]);
		html += HU.td(["rowfield",field1.getId(),ATTR_CLASS, "display-correlation-heading"],  HU.div([ATTR_STYLE,sideHeadingStyle,
													      ATTR_CLASS, "display-correlation-heading-side"], label));
                let rowName = this.getFieldLabel(field1);
                for (let fieldIdx2 = 0; fieldIdx2 < fields.length; fieldIdx2++) {
                    let field2 = fields[fieldIdx2];
                    let colName = this.getFieldLabel(field2);
                    let t1 = 0;
                    let t2 = 0;
                    let cnt = 0;
                    for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                        let tuple = this.getDataValues(dataList[rowIdx]);
                        let v1 = getValue(field1,tuple[field1.getIndex()]);
                        let v2 = getValue(field2,tuple[field2.getIndex()]);
			if(isNaN(v1) || isNaN(v2)) {
			    continue;
			}
                        t1 += v1;
                        t2 += v2;
                        cnt++;
                    }
                    let avg1 = t1 / cnt;
                    let avg2 = t2 / cnt;
                    let sum1 = 0;
                    let sum2 = 0;
                    let sum3 = 0;
                    for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                        let tuple = this.getDataValues(dataList[rowIdx]);
                        let v1 = getValue(field1,tuple[field1.getIndex()]);
                        let v2 = getValue(field2,tuple[field2.getIndex()]);			
			if(isNaN(v1) || isNaN(v2)) continue;
                        sum1 += (v1 - avg1) * (v2 - avg2);
                        sum2 += (v1 - avg1) * (v1 - avg1);
                        sum3 += (v2 - avg2) * (v2 - avg2);
                    }
                    r = sum1 / Math.sqrt(sum2 * sum3);
		    let ok = r<0?
			(r>=this.range.low.min && r<=this.range.low.max):
			(r>=this.range.high.min && r<=this.range.high.max);
                    let style = "";
    		    
		    
		    if (ok && colors != null) {
			if(fieldIdx1!=fieldIdx2) {
                            let percent = (r - colorByMin) / (colorByMax - colorByMin);
                            let index = parseInt(percent * colors.length);
                            if (index >= colors.length) index = colors.length - 1;
                            else if (index < 0) index = 0;
                            style = HU.css("background-color", colors[index]);
			} else {
                            style = HU.css("background-color", "#eee");
			    let svg = "<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'><rect width='10' height='10' fill='#fff'/><path d='M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2' stroke='#ddd' stroke-width='1'/></svg>";
			    style = HU.css('background-image',
					   'url(\'data:image/svg+xml;base64,' +btoa(svg) +'\')','background-repeat','repeat');
			}
                    }
                    let value = r.toFixed(3);
                    let label = value;
		    row.push(value);
		    if(fieldIdx1==fieldIdx2) label = SPACE;
                    if (!showValue || short) label = SPACE;
		    let align = "right";
		    let cellLabel =  this.getCellLabel(field1, field2);
		    if(cellLabel) {
			label = HU.span([ATTR_CLASS,'display-correlation-celllabel'],cellLabel);
			align="left";
		    }

		    let cellContents = "";
		    if(ok) {
			cellContents = HU.div([ATTR_CLASS, "display-correlation-element", ATTR_TITLE, "&rho;(" + rowName + "," + colName + ") = " + value], label);
		    }
                    html += HU.td(["colfield", field2.getId(), "rowfield",field1.getId(), ATTR_CLASS,"display-correlation-cell","align", align, ATTR_STYLE,style], cellContents);
                }
                html += HU.close(TR);
            }
            html += HU.tr([],HU.td([]) + HU.td(['colspan',(fieldCnt + 1)], HU.div([ATTR_ID, this.domId(ID_LASTROW)], "")));
            html += HU.close(TABLE);
	    this.jq(ID_TABLE).html(html);
	    let _this = this;
	    let selectedRow;
	    let selectedCol;
	    this.jq(ID_TABLE).find(TAG_TD).click(function(event) {
		let rowField = _this.getFieldById(null, $(this).attr("rowfield"));
		let colField = _this.getFieldById(null, $(this).attr("colfield"));
		if(event.shiftKey && _this.canEdit()) {
		    let label = prompt("Label:",  _this.getCellLabel(rowField, colField));
		    if(label) {
			let msg = 'label.' +rowField.getId() +'.' + colField.getId()+'=\"' + label +'\"';
			console.log('Copied to clipboard:');
			console.log(msg);
			Utils.copyToClipboard(msg);
		    }
		}

		let tds = _this.jq(ID_TABLE).find(TAG_TD);
		if(rowField) {
		    tds.removeClass("display-correlation-row-cell-highlight");
		    if(rowField != selectedRow) {
			selectedRow = rowField;
			_this.jq(ID_TABLE).find(".display-correlation-cell[rowfield='" + rowField.getId()+"']").addClass("display-correlation-row-cell-highlight");
		    }  else {
			selectedRow = null;
		    }

		}
		if(colField) {
		    tds.removeClass("display-correlation-col-cell-highlight");
		    if(colField != selectedCol) {
			selectedCol = colField;
			_this.jq(ID_TABLE).find(".display-correlation-cell[colfield='" + colField.getId()+"']").addClass("display-correlation-col-cell-highlight");
		    }  else {
			selectedCol = null;
		    }



		}

	    });
	    this.displayColorTable(colors, ID_LASTROW, colorByMin, colorByMax);
	}
    });
}








function RamaddaRecordsDisplay(displayManager, id, properties, type) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RECORDS, properties);
    let myProps = [
	{label:'Records'},
	{p:'maxHeight',ex:'400px'},
	{p:'showCards',ex:'true',d:true}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {

        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        defaultSelectedToAll: function() {
            return true;
        },
        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        updateUI: function(reload) {
            SUPER.updateUI.call(this,reload);
            let records = this.filterData();
            if (!records) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    this.records = records;
	    let _this = this;
            let fields = this.getSelectedFields(this.getData().getRecordFields());
            let html = "";
	    let showCards = this.getShowCards();
	    if(showCards) html+=HU.open("div",[ATTR_CLASS,"display-records-grid"]);
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
		let div = "";
                let tuple = this.getDataValues(records[rowIdx]);
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    let v = tuple[field.getIndex()];
		    if(v.getTime) v = this.formatDate(v);
                    div += HU.b(this.getFieldLabel(field)) + ": " + v + "<br>" +"\n";
                }
                let box = HU.div([ATTR_CLASS,showCards?"":"display-records-record",RECORD_INDEX,rowIdx,RECORD_ID, records[rowIdx].getId()], div);

		if(showCards) box =HU.div([ATTR_CLASS,"display-records-grid-box"],box);
		html+=box;
            }
	    if(showCards) html+=HU.close("div");
            let height = this.getProperty("maxHeight", "400px");
            if (!height.endsWith("px")) {
                height = height + "px";
            }
            this.setContents(HU.div([ATTR_STYLE, HU.css('max-height', height,'overflow-y','auto')], html));
	    this.find(".display-records-record").click(function() {
		let record = _this.records[$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		}

	    });
        },
        handleEventRecordSelection: function(source, args) {
            //                this.lastHtml = args.html;
            //                this.setContents(args.html);
        }
    });
}


function RamaddaStatsDisplay(displayManager, id, properties, type) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type || DISPLAY_STATS, properties);
    if (!type)
        addRamaddaDisplay(this);
    let myProps = [
	{label:'Summary Statistics'},
	{p:'showDefault',ex:'false'},
	{p:'showMin',ex:'false',canCache:true},
	{p:'showMax',ex:'false',canCache:true},
	{p:'showRange',d:false,ex:'true',canCache:true},
        {p:'showAverage',ex:'false',canCache:true},
        {p:'showStd',ex:'false',canCache:true},
        {p:'showPercentile',ex:'false',canCache:true},
        {p:'showCount',ex:'false',canCache:true},
        {p:'showTotal',ex:'false',canCache:true},
        {p:'showPercentile',ex:'false',canCache:true},
        {p:'showMissing',ex:'false',canCache:true},
        {p:'showUnique',ex:'false',canCache:true},
        {p:'showType',ex:'false',canCache:true},
        {p:'showText',ex:'false',canCache:true},
	{p:'showFieldType',d:true},
	{p:'showTableHeader',d:true},	
	{p:"sortStatsBy",ex:'min|max|total|average'},
	{p:"sortStatsAscending",ex:'false'},
	{p:'doValueSelection',ex:'false'},
	{p:"fieldHeaderLabel",ex:''},
	{p:"statsTableWidth",ex:'100%'},

    ];

    defineDisplay(this, SUPER, myProps, {
        "map-display": false,
        needsData: function() {
            return true;
            //                return this.getProperty("loadData", false) || this.getCreatedInteractively();
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        getDefaultSelectedFields: function(fields, dfltList) {
            if (dfltList != null && dfltList.length > 0) {
                return dfltList;
            }
            //get the numeric fields
            let l = [];
	    fields.forEach(field=>{
                if (!this.getShowText() && !field.isNumeric()) return;
                if (field.isFieldGeo()) {
                    return;
                }
                l.push(field);
	    });
            return l;
        },

        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        defaultSelectedToAll: function() {
            return true;
        },
        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        updateUI: function(args) {
            SUPER.updateUI.call(this,args);
            let records = this.filterData();
            if (!records) {
		return;
	    }
            let fields = this.getSelectedFields([]);
            let stats = [];
            let justOne = false;
	    fields.forEach((field,idx)=>{
                stats.push({
		    field:field,
                    isNumber: false,
                    count: 0,
                    min: NaN,
                    uniqueMap: {},
                    unique: 0,
                    std: 0,
                    max: NaN,
                    total: 0,
                    numMissing: 0,
                    numNotMissing: 0,
                    type: field.getType(),
                    values: []
                });
            });
	    records.forEach(record=>{
                stats.forEach(stat=>{
		    let field = stat.field;
                    let v = field.getValue(record);
                    if (v) {
                        if (!Utils.isDefined(stat.uniqueMap[v])) {
                            stat.uniqueMap[v] = 1;
                            stat.unique++;
                        } else {
                            stat.uniqueMap[v]++;
                        }
                    }
                    stat.isNumber = field.isNumeric();
                    stat.count++;
                    if (v == null || isNaN(v)) {
                        stat.numMissing++;
                    } else {
                        stat.numNotMissing++;
                    }
                    if (!isNaN(v) && (v!==null) && (typeof v == 'number')) {
                        let label = this.getFieldLabel(field).toLowerCase();
                        if (label.indexOf("latitude") >= 0 || label.indexOf("longitude") >= 0) {
			    return;
                        }
                        stat.total += v;
                        stat.max = Utils.max(stat.max, v);
                        stat.min = Utils.min(stat.min, v);
                        stat.values.push(v);
                    }
		});
	    });

	    
	    let dflt = this.getProperty("showDefault",true);

	    if (this.getShowUnique(dflt)) {
                stats.forEach(stat=>{
		    let field = stat.field;
                    stat.uniqueMax = 0;
                    stat.uniqueValue = "";
                    for (let v in stat.uniqueMap) {
                        let count = stat.uniqueMap[v];
                        if (count > stat.uniqueMax) {
                            stat.uniqueMax = count;
                            stat.uniqueValue = v;
                        }
                    }
                });
	    }

            if (this.getShowStd(dflt)) {
                stats.forEach(stat=>{
                    let values = stat.values;
                    if (values.length > 0) {
                        let average = stat.total / values.length;
                        let stdTotal = 0;
                        for (let i = 0; i < values.length; i++) {
                            let diff = values[i] - average;
                            stdTotal += diff * diff;
                        }
                        let mean = stdTotal / values.length;
                        stat.std = Math.sqrt(mean);
                    }
                });
            }

            let border = (justOne ? "0" : "1");
	    let attrs = [ATTR_ID,this.getDomId("statstable"), ATTR_CLASS, "row-border stripe  display-stats"];
	    let tableWidth = this.getStatsTableWidth();
	    if(tableWidth) {
		attrs.push("width");
		attrs.push(tableWidth);
	    }
	    let showTableHeader = this.getShowTableHeader();
            let html = HU.open(TAG_TABLE, attrs);
	    html+=HU.open(TAG_THEAD);
            if (!justOne) {
                header = [this.getFieldHeaderLabel("")];
                if (this.getShowCount(dflt)) 
                    header.push("Count");
                if (this.getShowMin(dflt)) 
                    header.push("Min");
                if (this.getShowPercentile(dflt)) 
                    header.push("25%","50%","75%");
                if (this.getShowMax(dflt)) 
                    header.push("Max");
                if (this.getShowRange()) 
                    header.push("Range");		
                if (this.getShowTotal(dflt)) 
                    header.push("Total");
                if (this.getShowAverage(dflt)) 
                    header.push("Average");
                if (this.getShowStd(dflt)) 
                    header.push("Std");
                if (this.getShowUnique(dflt)) 
                    header.push("# Unique","Top","Freq.");
                if (this.getShowMissing(dflt)) 
                    header.push("Not&nbsp;Missing","Missing")

                if(showTableHeader)
		    html += HU.tr(["valign", "bottom"], HU.ths([ATTR_CLASS, "display-stats-header", "align", "center"], header));
            }
	    html+=HU.close(THEAD);
	    html+=HU.open(TBODY);
            let cats = [];
            let catMap = {};
	    let doValueSelection = this.getDoValueSelection(false);
            stats.forEach(stat=>{
                stat.average = stat.numNotMissing == 0 ? NaN : (stat.total / stat.numNotMissing);
	    });

	    let sortBy = this.getSortStatsBy();
	    let sortAscending = this.getSortStatsAscending(true);
	    if(sortBy) {
		let sortFunc =(a,b)=>{
		    let result  =0
		    if(sortBy == "total")
			result= a.total-b.total;
		    else if(sortBy == "min")
			result= a.min-b.min;
		    else if(sortBy == "max")
			result= a.max-b.max;
		    else if(sortBy == "average")
			result= a.average-b.average;
		    if(result==0) return result;
		    if(sortAscending) return result;
		    return -result;
		    
		};
		stats.sort(sortFunc);
	    }

            stats.forEach(stat=>{
		let field = stat.field;
                let right = "";
                let total = SPACE;
                let _label = this.getFieldLabel(field).toLowerCase();
                let avg = stat.numNotMissing == 0 ? "NA" : this.formatNumber(stat.total / stat.numNotMissing);
                //Some guess work about when to show a total
                if (_label.indexOf("%") < 0 && _label.indexOf("percent") < 0 && _label.indexOf("median") < 0) {
                    total = this.formatNumber(stat.total);
                }
                if (justOne) {
                    right = HU.tds(["xalign", "right"], [this.formatNumber(stat.min)]);
		    return;
                }
                let values = [];
		let addValue=(v,label) =>{
		    if(label && !showTableHeader)
			v = HU.b(label)+': '+ v;
		    values.push(HU.div(['style','white-space:nowrap;'],v));
		}


                if (!stat.isNumber && this.getShowText(dflt)) {
                    if (this.getShowCount(dflt))
                        addValue(stat.count,'Count');
                    if (this.getShowMin(dflt))
                        values.push("-");
                    if (this.getShowPercentile(dflt)) 
                        values.push("-","-","-");
                    if (this.getShowMax(dflt))
                        values.push("-");
                    if (this.getShowRange())
                        values.push("-");		    
                    values.push("-");
                    if (this.getShowAverage(dflt)) 
                        values.push("-");
                    if (this.getShowStd(dflt)) 
                        values.push("-");
                    if (this.getShowUnique(dflt)) {
                        values.push(stat.unique,stat.uniqueValue,stat.uniqueMax);
		    }
                    if (this.getShowMissing(dflt)) 
                        values.push(stat.numNotMissing,stat.numMissing);
                } else {
                    if (this.getShowCount(dflt)) 
                        addValue(stat.count,'Count');
                    if (this.getShowMin(dflt)) 
			addValue(this.formatNumber(stat.min),"Min");
                    if (this.getShowPercentile(dflt)) {
                        let range = stat.max - stat.min;
			let tmp =p=> {
                            let s = this.formatNumber(stat.min + range * p);
			    if(doValueSelection) {
				s = HU.span([ATTR_CLASS,"display-stats-value","data-type", "percentile","data-value", p],s);
			    }
                            addValue(s,'Percentile '+p);
			}
			let percs = [.25,.5,.75];
			percs.map(v=>tmp(v));
                    }
                    if (this.getShowMax(dflt)) 
                        addValue(this.formatNumber(stat.max),'Max');
                    if (this.getShowRange()) 
                        addValue(this.formatNumber(stat.max-stat.min),'Range');		    
                    if (this.getShowTotal(dflt)) 
                        addValue(total,'Total');
                    if (this.getShowAverage(dflt)) 
                        addValue(avg,'Average');
                    if (this.getShowStd(dflt)) 
                        addValue(this.formatNumber(stat.std),'Std. Dev.');
                    if (this.getShowUnique(dflt)) {
                        addValue(stat.unique,'Unique');
                        if (Utils.isNumber(stat.uniqueValue)) {
                            addValue(this.formatNumber(stat.uniqueValue),'Unique');
                        } else {
                            addValue(stat.uniqueValue,'Unique');
                        }
                        addValue(stat.uniqueMax,'Unique max');
                    }
                    if (this.getShowMissing(dflt)) {
                        addValue(stat.numNotMissing,'Not missing');
			addValue(stat.numMissing,'Missing');
		    }
                }
                right = HU.tds(["align", "right"], values);
                let align = (justOne ? "right" : "left");
                let label = this.getFieldLabel(field);
                let toks = label.split("!!");
                let tooltip = "";
                tooltip += field.getId();
                if (field.description && field.description != "") {
                    tooltip += "\n" + field.description + "\n";
                }
                label = toks[toks.length - 1];
                if (Utils.stringDefined(field.unit)) 
                    label = label + " [" + field.unit + "]";
                if (justOne) 
                    label += ":";
                label = label.replace(/ /g, SPACE)
		let type =field.getTypeLabel() +SPACE;	
		if(!this.getShowFieldType())
		    type='';
		if(!showTableHeader) label=label+":";
                let row = HU.tr(['valign','top'], HU.td(["nowrap","true","align", align], type + HU.b(HU.span([ATTR_TITLE, tooltip], label))) + right);
                html += row;
            });
            html += HU.close(TAG_TBODY, TAG_TABLE);
            this.setContents(html);
	    //the aaSorting turns off the inital sorting
            if(showTableHeader)
		HU.formatTable("#" +this.getDomId("statstable"),{ordering:true,"aaSorting": []});	    
            this.initTooltip();

	    if(doValueSelection) {
		let values = this.find(".display-stats-value");
		values.each(function() {
		    let type  = $(this).attr("data-type");
		    let value  = $(this).attr("data-value");
		    let links = SPACE + HU.getIconImage("fa-less-than",[ATTR_TITLE,"Filter other displays",
									ATTR_CLASS,"display-stats-value-link","data-type",type,"data-value",value],
							[ATTR_STYLE,HU.css('font-size','8pt')]);

		    $(this).append(links);
		});
		values = this.find(".display-stats-value-link");
		values.each(function() {
		});
	    }

	    /*???
            //always propagate the event when loaded
	    let record = records[0];
	    this.displayManager.propagateEventRecordSelection(this,
	    record, {
	    index: 0
	    });
	    */
        },
    });
}



function RamaddaCooccurenceDisplay(displayManager, id, properties) {
    const ID_TABLE = "table";
    const ID_HEADER = "coocheader";
    const ID_SORTBY = "sortby";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_COOCCURENCE, properties);
    let myProps = [
	{label:'Cooccurence'},
	{p:'sourceField',ex:''},
	{p:'targetField',ex:''},
	{p:'colorBy',ex:''},
	{p:'directed',ex:'false'},
	{p:'missingBackground',ex:'#eee'},
	{p:'showSortBy',ex:'false'},
	{p:'sortBy',ex:'weight'},
	{p:'minWeight',ex:''},
	{p:'topSpace',ex:'50px'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },

	getHeader2:function() {
	    let html = SUPER.getHeader2.call(this);
	    let weightField = this.getFieldById(null, this.getProperty("colorBy","weight"));
	    if(weightField && this.getProperty("showSortBy",true)) {
		let enums = [["name","Name"],["weight","Weight"]];
		html +=  HU.div([ATTR_STYLE,HU.css('display','inline-block')], "Sort by: " + HU.select("",[ATTR_ID,this.domId(ID_SORTBY)],enums,this.getProperty("sortBy","")))+SPACE2;
		
	    }
	    return html;

	}, 
	initHeader2:function() {
	    let _this = this;
	    this.jq(ID_SORTBY).change(function() {
		_this.setProperty("sortBy",$(this).val());
		_this.updateUI();
	    });
	},
        updateUI: function() {
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let html = HU.div([ATTR_ID, this.domId(ID_HEADER)]) +
		HU.div([ATTR_ID, this.domId(ID_TABLE)]);
	    this.setContents(html);


	    let sourceField = this.getFieldById(null, this.getProperty("sourceField","source"));
	    let targetField = this.getFieldById(null, this.getProperty("targetField","target"));
	    let weightField = this.getFieldById(null, this.getProperty("colorBy","weight"));

	    if(sourceField==null || targetField==null) {
		this.setDisplayMessage("No source/target fields specified");
		return;
	    }
	    let colors = this.getColorTable();
	    if(!colors) colors = Utils.getColorTable("blues",true);
	    let colorBy = this.getColorByInfo(records,null,null,colors);
	    let names = {};
	    let nameList = [];
	    let sources = [];
	    let targets = [];
	    let links={};
	    let maxWeight = 0;
	    let sortBy  = this.getProperty("sortBy","name");
	    let directed = this.getProperty("directed",true);
	    let missing = -999999;

	    records.map(r=>{
		let source = r.getValue(sourceField.getIndex());
		let target = r.getValue(targetField.getIndex());
		let weight = missing;
		if(weightField) {
		    weight = r.getValue(weightField.getIndex());
		    maxWeight = Math.max(maxWeight, weight);
		}
		sources.push({name:source,weight:weight});
		targets.push({name:target,weight:weight});
		if(!directed) {
		    sources.push({name:target,weight:weight});
		    targets.push({name:source,weight:weight});
		    
		}
		links[source+"--" + target] = weight;
	    });
	    maxWeight = this.getProperty("maxWeight", maxWeight);
	    let sortFunc =(a,b)=>{
		if(sortBy == "name" || sortBy=="") {
		    return a.name.localeCompare(b.name);
		} else {
		    return b.weight-a.weight;
		}} 
	    sources.sort(sortFunc);
	    targets.sort(sortFunc);
	    let minWeight = this.getProperty("minWeight",missing);
	    let seen = {}
	    let tmp =[];
	    let pruneFunc = t=>{
		if(minWeight!=missing) {
		    if(t.weight==missing || t.weight<minWeight) return;
		}
		if(!seen[t.name]) {
		    seen[t.name]=true;
		    tmp.push(t.name);
		}
	    }
	    sources.map(pruneFunc);
	    sources=tmp;
	    seen = {}
	    tmp =[];
	    targets.map(pruneFunc);
	    targets = tmp;

	    let table = HU.div([ATTR_STYLE,HU.css('margin-top',this.getProperty("topSpace","100px"))]) +
		HU.open(TABLE,[ATTR_STYLE,HU.css('height','100%'), ATTR_CLASS,'display-cooc-table', 'order',0]);
	    table += HU.open(TR,['valign','bottom']) + HU.td(['border','none']);
	    targets.map(target=>{
		target = target.replace(/ /g,SPACE).replace(/-/g,SPACE);
		table += HU.td([ATTR_STYLE,HU.css('border','none'), "width","6"],HU.div([ATTR_CLASS,"display-cooc-colheader"], target));
	    });

	    let missingBackground  = this.getProperty("missingBackground","#eee");
	    sources.map(source=>{
		let label =  source.replace(/ /g,SPACE);
		table += HU.open(TR,['valign','bottom']) +HU.td([ATTR_STYLE,HU.css('border','none'), 'align','right'], HU.div([ATTR_CLASS,"display-cooc-rowheader"], label));
		targets.map(target=>{
		    let weight = links[source+"--" + target];
		    if(!directed && !Utils.isDefined(weight))
			weight = links[target+"--" + source];
		    let style="";
		    if(weight) {
			if(weight == missing || maxWeight == 0) 
			    style = HU.css('background','#ccc');
			else {
			    if(colorBy.index>=0) {
				color =  colorBy.getColor(weight);
				style = HU.css('background',color);
			    }
			    //			    let percent = weight/maxWeight;
			    //			    let index = parseInt(percent*colors.length);
			    // 			    if(index>=colors.length) index=colors.length-1;
			    //			    style = "background:" + colors[index]+";";
			}
		    }  else {
			style = HU.css('background', missingBackground);
		    }
		    table+=HU.td([ATTR_TITLE,source+" -> " + target+(weight>0?" " + weight:""), "width","3"],HU.div([ATTR_CLASS,"display-cooc-cell",ATTR_STYLE,style+HU.css('height','100%')],SPACE));
		});
		table+= HU.close(TR);
	    });

	    table+=HU.close(TR,TABLE);
	    table+=HU.div([ATTR_STYLE,HU.css('margin','5px')]);
	    this.jq(ID_TABLE).html(table);
	    colorBy.displayColorTable();

	}
    })
}



function RamaddaBoxtableDisplay(displayManager, id, properties) {
    const ID_HEADER = "coocheader";
    const ID_SORTBY = "sortby";
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_BOXTABLE, properties);
    let myProps = [
	{label:'Color Boxes'},
	{p:'categoryField',ex:''},
	{p:'colorBy',ex:''},
	{p:'tableWidth',ex:'300'},
	{p:'labelTemplate'},
	{p:'labelStyle'},
	{p:'imageField'},
	{p:'imageWidth',d:'30px'},
	{p:'labelColumnWidth',ex:'300px'}	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },

        updateUI: function() {
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let categoryField = this.getFieldById(null, this.getProperty("categoryField","category"));
	    if(categoryField==null) {
		this.setDisplayMessage("No category field field specified");
		return;
	    }

	    let imageWidth = this.getImageWidth('30px');
	    let imageField = this.getFieldById(null,this.getImageField());
	    let labelTemplate = this.getLabelTemplate();
	    let labelStyle = this.getLabelStyle('');
	    let colors = this.getColorTable();
	    if(!colors) colors = Utils.getColorTable("blues",true);
	    let colorBy = this.getColorByInfo(records,null,null,colors);
	    let catMap =  {};
	    let cats = [];
	    records.forEach(r=>{
		let category = r.getValue(categoryField.getIndex());
		let value = colorBy.index>=0?r.getValue(colorBy.index):0;
		let list = catMap[category] && catMap[category].list;
		if(!list) {
		    list = [];
		    catMap[category] = {list:list, max:0};
		    cats.push(category);
		}
		catMap[category].max = Math.max(catMap[category].max,value);
		list.push(r);
	    });
	    let html = HU.open(TABLE,[ATTR_CLASS,'display-colorboxes-table','cellpadding',5]);
	    let labelColumnWidth=this.getLabelColumnWidth();
	    let tableWidth=this.getProperty("tableWidth",300);
	    cats.sort((a,b)=>{
		return catMap[b].max - catMap[a].max;
	    });

	    cats.forEach(cat=>{
		let length = catMap[cat].list.length;
		let label = HU.span(["field-id",categoryField.getId(),
				     "field-value",cat], cat);
		let tdAttrs = ['align','right',ATTR_CLASS,'display-colorboxes-header'];
		if(labelColumnWidth)
		    tdAttrs.push(WIDTH,labelColumnWidth);
		let row = HU.open(TR,['valign','center'],HU.td(tdAttrs,label+ " ("+length+")"));
		row+=	  HU.open(TD);


		if(colorBy.index) {
		    catMap[cat].list.sort((a,b)=>{
			return b.getData()[colorBy.index]-a.getData()[colorBy.index];
		    });
		}
		catMap[cat].list.forEach((record,idx)=>{
		    let color = "#ccc";
		    if(colorBy.index) {
			color =  colorBy.getColor(record.getData()[colorBy.index], record) || color;
		    }
		    let style = '';
		    let contents = '';
		    let clazz='';
		    if(imageField) {
			let url = imageField.getValue(record);
			contents  = HU.div([ATTR_STYLE,'text-align:center;'],HU.image(url,['width',imageWidth]));
			clazz ='display-colorboxes-image';
		    } else {
			style = HU.css('background', color);
			clazz ='display-colorboxes-box';
		    }
		    if(labelTemplate) {
			let label = this.applyRecordTemplate(record, null,null,labelTemplate);
			contents +=HU.div([ATTR_CLASS,'display-colorboxes-label',ATTR_STYLE,labelStyle],label);
		    }
		    row +=HU.div([ATTR_TITLE,"",RECORD_ID, record.getId(), ATTR_CLASS,'ramadda-clickable ' + clazz,ATTR_STYLE,style],contents);
		});
		row+=HU.close(TD,TR);
		html+=row;
	    });

	    html +=HU.close(TABLE);
            this.displayHtml(html);
	    colorBy.displayColorTable(500);
	    if(!this.getProperty("tooltip"))
		this.setProperty("tooltip","${default}");
	    this.makeTooltips(this.find(".display-colorboxes-box,.display-colorboxes-image"),records);
	    this.addFieldClickHandler(null, records);
	}
    })
}



function RamaddaPercentchangeDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_PERCENTCHANGE, properties);
    let myProps = [
	{label:'Percent Change'},
	{p:'template',ex:'${date1} ${date2} ${value1} ${value2} ${percent} ${per_hour} ${per_day} ${per_week} ${per_month} ${per_year}'},
	{p:'fieldLabel',ex:''},
	{p:'sortFields',ex:'false'},
	{p:'highlightPercent',ex:'50'},
	{p:'highlightPercentPositive',ex:'50'},
	{p:'highlightPercentNegative',ex:'-50'},
	{p:'highlightColor',ex:''},
	{p:'highlightColorPositive',ex:''},
	{p:'highlightColorNegative',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
            let allFields = this.getData().getRecordFields();
            let fields = this.getSelectedFields(allFields);
	    fields = this.getFieldsByType(fields, "numeric");
	    let  record1 = records[0];
	    let  record2 = records[records.length-1];
	    let template = this.getProperty("template",null);
	    let headerTemplate = this.getProperty("headerTemplate","");
	    let footerTemplate = this.getProperty("footerTemplate","");
	    let date1 = record1.getDate();
	    let date2 = record2.getDate();
	    let label1 ="Start Value";
	    let label2 ="End Value";
	    let hours = 1;
	    let days = 1;
	    let years = 1;
	    let months = 1;
	    if(date1)
		label1 = this.formatDate(date1);
	    if(date2)
		label2 = this.formatDate(date2);
	    if(date1 && date2) {
		let diff = date2.getTime() - date1.getTime();
		days = diff/1000/60/60/24;
		hours = days*24;
		years = days/365;
		months = years*12;
	    }
            let html =  "";
	    if(template) {
		html= headerTemplate;
	    } else {
		html += HU.open(TABLE, [ATTR_CLASS, "stripe nowrap ramadda-table", ID, this.domId("percentchange")]);
		html += HU.open(THEAD, []);
		html += HU.tr([], HU.th([ATTR_STYLE,HU.css('text-align','center')], this.getProperty("fieldLabel", "Field")) + HU.th([ATTR_STYLE,HU.css('text-align','center')], label1) + HU.th([ATTR_STYLE,HU.css('text-align','center')], label2)
			      + HU.th([ATTR_STYLE,HU.css('text-align','center')], "Percent Change"));
		html += HU.close(THEAD);
		html += HU.open(TBODY, []);
	    }
	    let tuples= [];
	    fields.map(f=>{
		let val1 = 0;
		for(let i=0;i<records.length;i++) {
		    let val = records[i].getValue(f.getIndex());
		    if(!isNaN(val)) {
			val1 = val;
			break;
		    }
		}
		
		let val2 = 0;
		for(let i=records.length-1;i>=0;i--) {
		    let val = records[i].getValue(f.getIndex());
		    if(!isNaN(val)) {
			val2 = val;
			break;
		    }
		}

		let percent = parseInt(1000*(val2-val1)/val1)/10;
		//		val1 = record1.getValue(f.getIndex());
		//		val2 = record2.getValue(f.getIndex());
		tuples.push({field:f,val1:val1,val2:val2,percent:percent});
	    });

	    if(this.getProperty("sortFields",true)) {
		tuples.sort((a,b)=>{
		    return -(a.percent-b.percent);
		})
	    }
	    let highlightPercent = this.getProperty("highlightPercent",NaN);
	    let highlightPercentPositive = this.getProperty("highlightPercentPositive",highlightPercent);
	    let highlightPercentNegative = this.getProperty("highlightPercentNegative",-highlightPercent);
	    let highlightColor = this.getProperty("highlightColor","#ccc"||"#FFFEEC");
	    let posColor = this.getProperty("highlightColorPositive",highlightColor);
	    let negColor = this.getProperty("highlightColorNegative",highlightColor);
	    tuples.map(t=>{
		if(template) {
		    let h = template.replace("${field}", this.getFieldLabel(t.field)).replace("${value1}",this.formatNumber(t.val1)).replace("${value2}",this.formatNumber(t.val2)).replace("${percent}",this.formatNumber(t.percent)).replace("${date1}",label1).replace("${date2}",label2).replace("${difference}", this.formatNumber(t.val2-t.val1));
		    
		    h = h.replace(/\${per_hour}/g,this.formatNumber(t.percent/hours));
		    h = h.replace(/\${per_day}/g,this.formatNumber(t.percent/days));
		    h = h.replace(/\${per_week}/g,this.formatNumber(t.percent/(days/7)));
		    h = h.replace(/\${per_month}/g,this.formatNumber(t.percent/months));
		    h = h.replace(/\${per_year}/g,this.formatNumber(t.percent/years));
		    html+=h;
		} else {
		    let style = "";
		    if(!isNaN(highlightPercentPositive))
			if(t.percent>highlightPercentPositive)
			    style += HU.css('background', posColor);
		    if(!isNaN(highlightPercentNegative))
			if(t.percent<highlightPercentNegative)
			    style += HU.css('background', negColor);
		    
		    html += HU.tr([ATTR_STYLE,style], HU.td([], this.getFieldLabel(t.field)) + 
				  HU.td(["align","right"], this.formatNumber(t.val1)) +
				  HU.td(["align","right"], this.formatNumber(t.val2))
				  + HU.td(["align","right"], t.percent+"%"));
		}
	    });

	    if(template) {
		html+= footerTemplate;
	    } else {
		html += HU.close(TBODY);
		html += HU.close(TABLE);
	    }
	    this.setContents(html); 
            HU.formatTable("#" + this.domId("percentchange"), {ordering:false
							       //scrollY: this.getProperty("tableSummaryHeight", tableHeight)
							      });
	},
    })
}



function RamaddaDatatableDisplay(displayManager, id, properties) {
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_DATATABLE, properties);
    const ID_COLORTABLE = 'datatable_colortable'
    const ID_PIECOLORS = 'datatable_piecolors'    
    let myProps = [
	{label:'Data Table'},
	{p:'columnSelector',ex:'date_day|date_hour|date_dow|date_month|date_year'},
	{p:'selectors',ex:'date_day,date_hour,date_dow,date_month,date_year,date_fieldid'},
	{p:'columnSelector',ex:'date_day|date_hour|date_dow|date_month'},
	{p:'rowSelector',ex:'date_day|date_hour|date_dow|date_month'},
	{p:'checkedIcon',ex:'fa-checked'},
	{p:'checkedTooltipHeader',ex:'${numberChecked}'},
	{p:'dataCheckers',ex:'match|notmatch|lessthan|greaterthan|equals|notequals(field=field,value=value,label=label,enabled=false) '}, 
	{p:'showColumnSelector',ex:'false'},
	{p:'showRowSelector',ex:'false'},
	{p:'showValues',ex:'false'},
	{p:'showColors',ex:'true',d:false},
	{p:'showPieColors',ex:'true',d:false},	
	{p:'showRowTotals',ex:'false'},
	{p:'showColumnTotals',ex:'false'},
	{p:'slantHeader',ex:'true'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        updateUI: function() {
            this.setDisplayMessage(this.getLoadingMessage());
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let colors = this.getColorTable(true);
	    if (!colors) colors = Utils.ColorTables.cats.colors;
	    let checkers = this.getTheDataFilters(this.getProperty("dataCheckers"));
	    let cells = {};
	    let countFields= this.getFieldsByIds(null, this.getProperty("countFields"));

	    let selectors;
	    let fieldMap = {};
	    if(this.getProperty("selectors")) {
		selectors = [];
		let labels = {"date_day":"Day","date_dow":"Day of Week","date_hour":"Hour","date_month":"Month","date_year":"Year"};
		this.getProperty("selectors").split(",").map(s=>{
		    let label = labels[s];
		    if(!label) {
			let field = this.getFieldById(null,s);
			if(field) {
			    label = this.getFieldLabel(field);
			    fieldMap[s] = field;
			}
		    }
		    if(label) 
			selectors.push([s,label]);
		});
	    } else {
		selectors  =   [["date_day","Day"],["date_dow","Day of Week"],["date_hour","Hour"],["date_month","Month"],["date_year","Year"]];
	    }

	    let columnSelector = this.getProperty("columnSelector",selectors[0][0]);
	    let rowSelector = this.getProperty("rowSelector",selectors[1][0]);
	    let getValues =(s=>{
		let values = [];
		if(s =="date_dow") {
		    Utils.dayNamesShortShort.map((d,i)=>{
			values.push({id:i,label:d});
		    });
		}  else if(s =="date_hour") {
		    let tmp =["12&nbsp;AM","1","2","3","4","5","6","7","8","9","10","11",
			      "12&nbsp;PM","1","2","3","4","5","6","7","8","9","10","11"];
		    for(let i=0;i<24;i++)
			values.push({id:i,label:tmp[i]});
		}  else if(s =="date_day") {
		    for(let day=1;day<=31;day++)
			values.push({id:day,label:String(day)});
		}  else if(s =="date_month") {
		    Utils.monthNames.map((m,i)=>{
			values.push({id:i,label:m});
		    });
		}  else if(s =="date_year") {
		    let years =[];
		    let seen = {};
		    records.map(r=>{
			let year = r.getDate().getUTCFullYear();
			if(!seen[year]) {
			    years.push(year);
			    seen[year] = true;
			}
		    });
		    years.sort();
		    years.map((y,i)=>{
			values.push({id:y,label:String(y)});
		    });
		} else {
		    let field = fieldMap[s];
		    if(field) {
			let seen = {};
			let isNumber = false;
			this.getColumnValues(records, field).values.map(d=>{
			    isNumber = Utils.isNumber(d);
			    if(!Utils.isDefined(seen[d])) {
				seen[d] = true;
				values.push({id:d,label:String(d)});
			    }
			});
			values.sort((a,b) =>{
			    if(isNumber) {
				return a.id-b.id;
			    }
			    return a.label.localeCompare(b.label);
			});
		    }
		}
		return values;
	    });
	    let columns =getValues(columnSelector);
	    let rows =getValues(rowSelector);
	    let getId =((s,r,l)=>{
		if(s =="date_dow")  {
		    return l[r.getDate().getDay()].id;
		} else if(s =="date_hour") {
		    return l[r.getDate().getUTCHours()].id;
		} else if(s =="date_day") {
		    return  l[r.getDate().getUTCDate()-1].id;
		} else if(s =="date_month") {
		    return  l[r.getDate().getUTCMonth()].id;
		} else if(s =="date_year") {
		    return r.getDate().getUTCFullYear();
		} else {
		    let field = fieldMap[s];
		    if(field) {
			return r.getValue(field.getIndex());
		    }
		}
		return "null";
	    });

	    let uniqueValues = {};
	    records.map((r,i)=>{
		let row =getId(rowSelector,r,rows);
		let column =getId(columnSelector,r,columns);
		let key = row+"-" +column;
		let cell = cells[key];
		if(!cell) {
		    cell = cells[key]={
			checked:[],
			row:row,
			column:column,
			count:0,
			records:[],
			countFields:{}
		    };
		    countFields.forEach(f=>{
			cell.countFields[f.getId()] = {
			    values:[],
			    counts:{}
			};
		    });
		}

		if(checkers && checkers.length>0) {
		    if(this.checkDataFilters(checkers, r)) {
			cell.checked.push(r);
		    }
		}

		countFields.forEach(f=>{
		    //f=>in_or_out
		    let v = r.getValue(f.getIndex());
		    //v=incoming or outgoing
		    let cf = cell.countFields[f.getId()];
		    if(!cf.counts[v]) {
			cf.counts[v] = 0;
			uniqueValues[v] = true;
			cf.values.push(v);
		    }
		    cf.counts[v]++;
		});
		cell.count++;
		cell.records.push(r);
	    });


	    let min = 0;
	    let max  = 0;
	    let cnt = 0;
	    for(a in cells) {
		let cell = cells[a];
		min = cnt==0?cell.count:Math.min(cell.count,min);
		max = cnt==0?cell.count:Math.max(cell.count,max);
		cnt++;
		//		console.log("cell: "+ cell.row +" " + cell.column +" #:" + cell.count);
		countFields.forEach(f=>{
		    let cf = cell.countFields[f.getId()];
		    cf.values.sort();
		    cf.values.forEach(v=>{
			//			console.log("\t" + v +" = " + cf.counts[v] +" " + cell.row +" " + cell.column);
		    });
		    
		});
	    }


	    let showValues = this.getProperty("showValues", true);
	    let showColors = this.getShowColors();
	    let showPieColors = this.getShowPieColors();
	    let cellCount = columns.length;
	    let maxRowValue = 0;
	    let maxColumnValue = 0;
	    let columnTotals = {};
	    let rowTotals = {};
	    rows.map(row=>{
		let rowTotal = 0;
		columns.map(column=>{
		    let key = row.id +"-" +column.id;
		    if(cells[key]) {
			rowTotal+=cells[key].count;
		    }
		});
		rowTotals[row.id] = rowTotal;
		maxRowValue = Math.max(maxRowValue, rowTotal);
	    });
	    columns.map(column=>{
		let columnTotal = 0;
		rows.map(row=>{
		    let key = row.id +"-" +column.id;
		    if(cells[key]) {
			columnTotal+=cells[key].count;
		    }
		});
		columnTotals[column.id] = columnTotal;
		maxColumnValue = Math.max(maxColumnValue, columnTotal);
	    });

	    let showRowTotals = this.getProperty("showRowTotals",true);
	    let showColumnTotals = this.getProperty("showColumnTotals",true);
	    let width = Math.round(100/cellCount);
	    let table = "";
	    table+=HU.open(TAG_TR,['valign','bottom']) + HU.td([],"");
	    let needToRotate = this.getProperty("slantHeader",false);
	    let topSpace = 0;
	    columns.map(column=>{
		let label = column.label;
		if(label.length>15) {
		    needToRotate = true;
		    topSpace = Math.max(topSpace,Math.round(label.length*3));
		    topSpace = 80;
		}
	    });
	    
	    columns.map(column=>{
		let label = column.label;
		if(needToRotate) {
		    if(label.length>20) {
			label = label.substring(0,20)+"...";
		    }
		    label = label.replace(/ /g,SPACE).replace("-",SPACE);
		    label = HU.div(["tootltip",column.label,ATTR_CLASS,"display-datatable-header-slant"],label);
		}		    
		table+=HU.td([ATTR_CLASS,'display-datatable-header','align','center'],label);
	    });
	    table+=HU.close(TR);

	    rows.map(row=>{
		let name = HU.div([],row.label.replace(/ /g,SPACE));
		table+=HU.open(TR) + HU.td([ATTR_CLASS,"display-datatable-name","align","right", "width","100"],name);
		columns.map(column=>{
		    let key = row.id+"-" +column.id;		    
		    let inner = "";
		    let style = "";
		    let marker = "";
		    let cell = cells[key];
		    let extra1 = "";
		    let extra2 = "";
		    if(cell) {
			if(showValues) 
			    inner = HU.div([ATTR_CLASS,"display-datatable-value"],cell.count);
			extra2 = HU.div(["data-key",key,ATTR_CLASS,"display-datatable-counts"]);
			if(cell.checked.length) {
			    extra1= HU.getIconImage(this.getProperty("checkedIcon","fa-check"),[ATTR_TITLE,"","data-key",key,
												ATTR_CLASS,"display-datatable-checked"]);
			}
			if(showColors) {
                            let percent = (cell.count - min) / (max - min);
                            let ctIndex = parseInt(percent * colors.length);
                            if (ctIndex >= colors.length) ctIndex = colors.length - 1;
                            else if (ctIndex < 0) ctIndex = 0;
                            style = HU.css('background-color', colors[ctIndex]);
			}
		    }
		    let cellHtml = extra1 +extra2+inner;
		    table += HU.td([ATTR_CLASS,'display-datatable-cell','align','right', ATTR_STYLE,style,'width',width +'%'], cellHtml);
		});
		if(showRowTotals) {
		    let total = rowTotals[row.id];
		    let dim = Math.round(total/maxRowValue*100);
		    let bar = HU.div([ATTR_CLASS, "display-datatable-summary-row",ATTR_STYLE,HU.css('width', dim+'px')],total);
		    table += HU.td([WIDTH,100,"valign","top"],bar);
		}
		table += HU.close(TR);
	    });
	    if(showColumnTotals) {
		table+=HU.open(TR,['valign','top']) + HU.td();
		columns.map(column=>{
		    let total = columnTotals[column.id];
		    let dim = Math.round(total/maxColumnValue*100);
		    let bar = HU.div([ATTR_CLASS, "display-datatable-summary-column",ATTR_STYLE,HU.css('height', dim+'px')],total);
		    table += HU.td([],bar);

		});
	    }
	    table+=HU.close(TR);
	    table+=HU.open(TR,[],HU.td());
	    table+=HU.td(['colspan',cellCount,ATTR_CLASS,'display-datatable-footer','align','center',ATTR_ID,this.domId(ID_COLORTABLE)]);
	    table+=HU.close(TD);
	    table+=HU.open(TR,[],HU.td());
	    table+=HU.td(['colspan',cellCount,ATTR_CLASS,'display-datatable-footer','align','center',ATTR_ID,this.domId(ID_PIECOLORS)]);
	    

	    table+=HU.close(TR,TABLE);

	    if(topSpace>0) {
		table  = HU.div([ATTR_STYLE,HU.css('margin-top', topSpace+'px')], table);
	    }

	    let html ="";	
	    let headerRow = HU.open(TR);
	    if(this.getProperty("showRowSelector",true)) {
		headerRow+=  HU.td([ATTR_CLASS,"display-datatable-selector","width","align","center"],HU.select("",[ATTR_ID,this.domId("rowSelector")],
														selectors,
														rowSelector,15));
	    }
	    if(this.getProperty("showColumnSelector",true)) {
		headerRow+=  HU.td(["colspan",columns.length, ATTR_CLASS,"display-datatable-selector","width","90%","align","center"],  HU.select("",[ATTR_ID,this.domId("columnSelector")],
																		  selectors,
																		  columnSelector));
	    }

	    let mainTable = HU.open(TABLE,[ATTR_STYLE,HU.css('font-size', this.getProperty("fontSize",'8pt')),ATTR_CLASS,'display-colorboxes-table', 'cellpadding',0,'cellspacing',0,  WIDTH,'100%']);
	    mainTable+=HU.tr([],headerRow);
	    mainTable+=table;
	    //	    html+=header;
	    html+=mainTable;

	    this.setContents(html);


	    let _this = this;
	    this.jq("rowSelector").change(function() {
		_this.setProperty("rowSelector",$(this).val());
		_this.updateUI();
	    });	    
	    this.jq("columnSelector").change(function() {
		_this.setProperty("columnSelector",$(this).val());
		_this.updateUI();
	    });

	    let pieWidth=this.getProperty("pieWidth", 30);

	    let colorMap = {};
	    Object.keys(uniqueValues).forEach((key,idx)=>{
		colorMap[key] = colors[idx%colors.length];
	    });



	    let xcnt = 0;
	    this.find(".display-datatable-counts").each(function() {
		//		xcnt++;	if(xcnt<3|| xcnt>3) return;
		let key = $(this).attr("data-key");	
		let cell = cells[key];
		countFields.forEach((f,idx)=>{
		    let html = HU.center(HU.b(_this.getFieldLabel(f)));
		    let cf = cell.countFields[f.getId()];
		    let data=[];
		    cf.values.forEach(v=>{
			data.push([v,cf.counts[v]]);
			html+= v +":" + cf.counts[v]+SPACE + '<br>';
		    });
		    let id = _this.domId(cell.row+"-"+cell.column+"-" + f.getId());
		    $(this).append(HU.div([ATTR_CLASS,"display-datatable-piechart",ATTR_ID,id,ATTR_TITLE,"", ATTR_STYLE,HU.css(WIDTH, pieWidth+'px',HEIGHT, pieWidth+'px')]));
		    //drawPieChart(display, dom,width,height,array,min,max,colorBy,attrs) {
		    drawPieChart(_this, "#"+id,pieWidth,pieWidth,data,null,null,null,{colorMap:colorMap});
		    $("#" + id).tooltip({
			content: function() {
			    return html;
			}
		    });
		});
	    });
	    

	    this.find(".display-datatable-checked").tooltip({
		content: function() {
		    let key = $(this).attr("data-key");	
		    let cell = cells[key];
		    let checked = cell.checked;
		    if(checked.length) {
			let tooltip = _this.getProperty("tooltip","${default}");
			if(tooltip =="") return null;
			let tt = _this.getProperty("checkedTooltipHeader",HU.b('#Items: ${numberChecked}') +HU.close(BR));
			tt = tt.replace("${numberChecked}", checked.length);
			checked.map(r=>{
			    if(tt!="") tt += HU.open(DIV,[ATTR_CLASS,'ramadda-hline']);
			    tt+= _this.getRecordHtml(r,null,tooltip);
			});
			return HU.div([ATTR_CLASS, "display-datatable-tooltip"],tt);
		    }
		    return null;

		},
	    });
	    if(showColors) {
		this.displayColorTable(colors, ID_COLORTABLE, min,max,{});
	    }
	    if(showPieColors) {
		let stringValues = Object.keys(colorMap).map(key=>{
		    return {value:key,color:colorMap[key]};
		});
		this.jq(ID_PIECOLORS).html('pie colors');
		this.displayColorTable(colors, ID_PIECOLORS, min,max,{stringValues:stringValues});
	    }

	},
    })
}


function RamaddaSparklineDisplay(displayManager, id, properties) {
    const ID_INNER = "inner";
    if(!properties.groupBy)
	properties.displayInline = true;
    if(!Utils.isDefined(properties.showDisplayTop))
	properties.showDisplayTop = false;
    if(!Utils.isDefined(properties.showDisplayBottom))
	properties.showDisplayBottom = false;

    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_SPARKLINE, properties);
    let myProps = [...RamaddaDisplayUtils.sparklineProps];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	//Overwrite so we just have undecorated text
        getLoadingMessage: function(msg) {
	    return "Loading...";
	},
	updateUI: function() {
	    let w = this.getPropertySparklineWidth(60);
	    let h = this.getPropertySparklineHeight(20);
	    let records = this.filteredRecords = this.filterData();
	    if(!records) return;



	    let field = this.getFieldById(null, this.getProperty("field"));
	    if(field==null) {
		this.setDisplayMessage("No field specified");
		return;
	    }
	    let t1 = new Date();

	    let showDate = this.getPropertyShowDate();
	    let id = this.domId(ID_INNER);
	    let colorBy = this.getColorByInfo(records);
	    let groupByField = this.getFieldById(null,this.getProperty("groupBy"));
	    let groups = groupByField?RecordUtil.groupBy(records, this, null, groupByField):null;
	    let col = this.getColumnValues(records, field);
	    let min = col.min;
	    let max = col.max;
	    if(this.getProperty("useAllRecords")) {
		let col2 = this.getColumnValues(this.getRecords(), field);
		min  = col2.min;
		max = col2.max;
	    }

	    if(groups) {
		let labelPosition = this.getProperty("labelPosition","bottom");
		html = HU.div([ATTR_ID,this.domId(ID_INNER)]);
		this.setContents(html); 
		groups.values.forEach((value,idx)=>{
		    let grecords = groups.map[value];
		    let gid = id+"_"+ +idx;
		    let c = HU.div([ATTR_CLASS,"display-sparkline-sparkline",ATTR_ID,gid,ATTR_STYLE,HU.css('width', w+'px','height', h+  'px')]);
		    let label = HU.div([ATTR_CLASS,"display-sparkline-header"], value);
		    if(labelPosition == "top")
			c = label + HU.tag(BR) + c;
		    else if(labelPosition == "bottom")
			c =  c + HU.tag(BR) + label;
		    $("#"+id).append(HU.div([ATTR_STYLE,HU.css('display','inline-block','margin','4px')],c));
		    let gcol = this.getColumnValues(grecords, field);
		    drawSparkline(this, "#"+gid,w,h,gcol.values,grecords,min,max,colorBy);
		});		
	    } else {
		html = HU.div([ATTR_CLASS,"display-sparkline-sparkline",ATTR_ID,this.domId(ID_INNER),ATTR_STYLE,HU.css('width', w+'px','height', h+'px')]);
		if(showDate) {
		    html = HU.div([ATTR_CLASS,"display-sparkline-date"],this.formatDate(records[0].getTime())) + html+
			HU.div([ATTR_CLASS,"display-sparkline-date"],this.formatDate(records[records.length-1].getTime()))
		}
		let left = this.getProperty("showMin")? HU.div([ATTR_CLASS,"display-sparkline-value",ATTR_STYLE, this.getPropertyLabelStyle("")],this.formatNumber(col.values[0])):"";
		let right = this.getProperty("showMax",true)? HU.div([ATTR_CLASS,"display-sparkline-value",ATTR_STYLE, this.getPropertyLabelStyle("")],this.formatNumber(col.values[col.values.length-1])):"";
		if(left!=""  || right!="")
		    html = HU.leftCenterRight(left,html,right,"1%","99%","1%",null,"padding:2px 2px;");
		this.setContents(html); 
		drawSparkline(this, "#"+id,w,h,col.values,records,min,max,colorBy);
	    }
	    let t2 = new Date();
	    //	    Utils.displayTimes("sparkline",[t1,t2],true);

	}
    });
}


function RamaddaPointimageDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width="200";
    properties.displayInline = true;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_POINTIMAGE, properties);
    let myProps = [
	{label:'Point Image'},
	{p:'cellShape',ex:'rect|circle'},
	{p:'cellSize',ex:'4'},
	{p:'cellFilled',ex:'false'},
	{p:'cellColor',ex:'false'},
	{p:'doHeatmap',ex:'true'},
	{p:'padding',ex:'5'},
	{p:'borderColor',ex:'#ccc'},
	{p:'showTooltips',ex:'false'},
	{p:'colorBy',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER,myProps, {
        needsData: function() {
            return true;
        },
        getLoadingMessage: function(msg) {
	    return "Loading...";
	},
	findClosest: function(records, e) {
	    let closest = null;
	    let minDistace = 0;
	    let cnt = 0;
	    let seen = {};
	    //	    console.log("find closest");
	    records.map((r,i) =>{
		let coords = r[this.getId()+"_coordinates"]
		let dx = coords.x-e.offsetX;
		let dy = coords.y-e.offsetY;
		let d = Math.sqrt(dx*dx+dy*dy);
		//		if(!seen[r.getValue(0)]) {
		//		    console.log("\t" +r.getValue(0) +" cx:" + coords.x +" cy:" + coords.y+" ex:" + e.offsetX +" ey:" + e.offsetY +" dx:" +dx +" dy:" +dy +" d:" + d);
		//		    seen[r.getValue(0)]  =true;
		//		}
		if(i==0) {
		    closest = r;
		    minDistance=d;
		} else {
		    if(d<minDistance) {
			minDistance = d;
			closest=r;
			//			console.log("\tclosest:" + minDistance +" " + r.getValue(0));
		    }
		}
	    });
	    return closest;
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    if(this.getProperty("borderColor")) {
		$("#"+this.getProperty(PROP_DIVID)).css("border","1px solid " + this.getProperty("borderColor"));
	    }
	    let bounds ={};
	    RecordUtil.getPoints(records, bounds);
	    let ratio = (bounds.east-bounds.west)/(bounds.north-bounds.south);
	    let style = this.getProperty("padding")?HU.css('padding',+this.getProperty("padding")+"px") : "";
	    let html = HU.div([ATTR_ID,this.domId("inner"),ATTR_STYLE,style]);
	    this.setContents(html); 
	    let pad = 10;
	    let w = Math.round(this.jq("inner").width());
	    let h = Math.round(w/ratio);
            let divid = this.getProperty(PROP_DIVID);
	    //	    $("#"+ divid).css("height",h+pad);
	    html = HU.div([ATTR_ID,this.domId("inner"),ATTR_STYLE,HU.css('width', w +'height', h+'px') + style]);
	    html = HU.div([ATTR_ID,this.domId("inner")]);
	    //this.getContents().css("height",h+pad);
	    this.setContents(html); 
	    let colorBy = this.getColorByInfo(records);
	    bounds = RecordUtil.expandBounds(bounds,0.1);
	    let args =$.extend({colorBy:colorBy, w:w, h:h,cell3D:this.getProperty("cell3D"),bounds:bounds},
			       this.getDefaultGridByArgs());

	    //The default gridby args sets operator=count
	    args.operator = this.getProperty('hm.operator',this.getProperty('hmOperator','max')),
	    args.doHeatmap=true;
	    let fields = this.getFields();
	    let img = Gfx.gridData(this.getId(),fields, records,args);
	    this.jq("inner").html(HU.image(img,[ATTR_TITLE,"",ATTR_ID,this.domId("image")]));
	    this.jq("inner").append(HU.div([ATTR_ID,this.domId("tooltip"),ATTR_STYLE,HU.css('z-index:','2000','display','none','position','absolute','background','#fff','border','1px solid #ccc','padding','0px')]));
	    let _this = this;
	    if(this.getProperty("showTooltips",true)) {
		this.jq("image").mouseout(function( event ) {
		    _this.jq("tooltip").hide();
		});
		this.jq("image").mousemove(function( event ) {
		    let closest = _this.findClosest(records,event);
		    if(closest) {
			let html =  HU.div([ATTR_STYLE,HU.css('max-height','400px','overflow-y','auto')], _this.getRecordHtml(closest));
			_this.jq("tooltip").html(html);
			_this.jq("tooltip").show();
		    }
		});
	    }
	    this.jq("image").click(e=> {
		_this.mouseEvent = event;
		let closest = this.findClosest(records,e);
		if(closest)
		    this.propagateEventRecordSelection({record: closest});
	    });

	}
    });
}


function RamaddaCanvasDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CANVAS, properties);
    let myProps = [
	{label:'Canvas'},
	{p:'canvasStyle',d:"",ex:"",tt:'Canvas CSS style'},
	{p:'titleTemplate',tt:'Template to show as title'},
	{p:'topTitleTemplate',tt:'Template to show as top title'},	
	{p:'urlField',tt:'Url Field'},
	{p:'iconField',tt:'Icon Field'},
	{p:'highlightStyle',tt:'Highlight Style'},
	{p:'unHighlightStyle',tt:'Unhighlight Style'},	
    ];


    myProps.push(...RamaddaDisplayUtils.getCanvasProps());


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let _this = this;
	    let records = this.filterData();
	    let fields = this.getFields();
	    if(!records) return;
	    if(records.length==0) {
		this.setDisplayMessage(this.getNoDataMessage());
		return;
	    }
	    let style = this.getCanvasStyle("");
	    let highlightStyle = this.getHighlightStyle("");
	    let unHighlightStyle = this.getUnHighlightStyle("");
	    let columns = this.getProperty("columns");
	    let html = "";
	    let canvasWidth = this.getPropertyCanvasWidth();
	    let canvasHeight = this.getPropertyCanvasHeight();
	    let titleTemplate= this.getPropertyTitleTemplate();
	    let topTitleTemplate= this.getPropertyTopTitleTemplate();
	    let urlField = this.getFieldById(null,this.getPropertyUrlField());
	    let iconField = this.getFieldById(null,this.getPropertyIconField());	    
	    let doingHighlight = this.getFilterHighlight();
	    records.forEach((record,idx)=>{
		let highlight =  record.isHighlight(this);
		let cid = this.domId("canvas_" + idx);
		let canvasClass = "display-canvas-canvas";
		let canvasStyle = style;
		if(doingHighlight) {
		    if(highlight) {
			canvasClass+= " display-canvas-canvas-highlight ";
			canvasStyle+= " " + highlightStyle;
		    } else {
			canvasClass+= " display-canvas-canvas-unhighlight ";
			canvasStyle+= " " + unHighlightStyle;
		    }
		}

		let c = HU.tag("canvas",[ATTR_CLASS,canvasClass, ATTR_STYLE,canvasStyle, 	
					 WIDTH,canvasWidth,HEIGHT,canvasHeight,ATTR_ID,cid]);
		let icon = iconField? HU.image(record.getValue(iconField.getIndex()))+"&nbsp;":"";
		let topTitle  = topTitleTemplate?
		    HU.div([ATTR_CLASS,"display-canvas-title"],
			   icon+this.getRecordHtml(record, null, topTitleTemplate)):icon;
		let title  = titleTemplate?
		    HU.div([ATTR_CLASS,"display-canvas-title"], 
			   this.getRecordHtml(record, null, titleTemplate)):"";	
		let div =  HU.div([ATTR_TITLE,"",ATTR_CLASS,"display-canvas-block", RECORD_INDEX,idx,RECORD_ID, record.getId()], topTitle+c+title);
		if(urlField) {
		    let url = record.getValue(urlField.getIndex());
		    if(Utils.stringDefined(url))
			div = HU.href(url,div);
		}
		html+=div;
	    });
	    this.setContents(html);
	    let glyphs=RamaddaDisplayUtils.getGlyphs(this,fields,records,canvasWidth,canvasHeight);
	    let opts = {};
	    let originX = 0;
	    let originY=this.getPropertyCanvasOrigin()=="center"?canvasHeight/2:canvasHeight;
	    records.forEach((record,idx)=>{
		let cid = this.domId("canvas_" + idx);
		let canvas = document.getElementById(cid);
		let ctx = canvas.getContext("2d");
		glyphs.forEach(glyph=>{
		    glyph.draw(opts, canvas, ctx, originX,originY,{record:record});
		});
	    });
	    let blocks = this.find(".display-canvas-block");
	    this.makeTooltips(blocks,records,null,"${default}");
	    
	    if(this.getShowColorTable()) {
		glyphs.every(glyph=>{
		    let colorBy = glyph.getColorByInfo();
		    if(colorBy) {
			colorBy.displayColorTable();
			//		    return false;
		    }
		    return true;
		});
	    }




	}
    });
}


function RamaddaFieldtableDisplay(displayManager, id, properties) {
    const ID_TABLE = "fieldtable";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_FIELDTABLE, properties);
    let myProps = [
	{label:'Field Table'},
	{p:'field',ex:''},
	{p:'labelField',ex:'field'},
	{p:'columnWidth',ex:'150'},
	{p:'tableHeight',ex:'300'},
	{p:'markerShape',ex:'circle|rect|triangle|bar|arrow|dart|bar'},
	{p:'markerSize',ex:'16'},
	{p:'markerFill',ex:'#64CDCC'},
	{p:'markerStroke',ex:'#000'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
	    if(fields.length==0) 
		fields = this.getFieldsByType(null, "numeric");
	    let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    if(!labelField) labelField = this.getFieldsByType(null, "string")[0];
	    let html = HU.open(TABLE,[ATTR_CLASS, "", "border",0,ATTR_ID,this.domId(ID_TABLE)]);
	    html += HU.open(THEAD);
	    let width = this.getProperty("columnWidth",150)
	    html += HU.open(TR,[]);
	    html+=HU.td(["width",width],
			HU.div([ATTR_CLASS,"display-fieldtable-header"],labelField?this.getFieldLabel(labelField):""));
	    let columns = {};
	    fields.forEach(f=>{
		columns[f.getId()] = this.getColumnValues(records, f);
	    });

	    fields.forEach(f=>{
		html+=HU.th(["width",width],HU.div([ATTR_CLASS,"display-fieldtable-header"],this.getFieldLabel(f)));
	    });
	    html += HU.close(TR,THEAD);
	    html += HU.open(TBODY);


	    let shape = this.getProperty("markerShape","bar");
	    let canvasInfo = [];
	    let colorBys = {};
	    let cnt = 0;
	    let cw = this.getProperty("markerSize",16);

	    fields.forEach(f=>{
		colorBys[f.getId()] = this.getColorByInfo(records,f);
	    });

	    records.forEach((r,idx)=>{
		let label  = labelField?r.getValue(labelField.getIndex()):"#"+(idx+1);
		let hdrAttrs = [ATTR_CLASS,"display-fieldtable-rowheader"];
		if(labelField) {
		    hdrAttrs.push("field-id");
		    hdrAttrs.push(labelField.getId());
		    hdrAttrs.push("field-value");
		    hdrAttrs.push(r.getValue(labelField.getIndex()));
		}
		html += HU.open(TR,["valign","center",RECORD_INDEX,idx,RECORD_ID, r.getId(),ATTR_CLASS,"display-fieldtable-row"]);
		html+=HU.td([ATTR_STYLE,HU.css('vertical-align','center'),'align','right'],HU.div(hdrAttrs,label));
		fields.forEach(f=>{
		    let v = r.getValue(f.getIndex());
		    let c = columns[f.getId()];
		    let contents = "";
		    if(isNaN(v) || c.min == c.max) return;
		    let perc = 100*(v-c.min)/(c.max-c.min);
		    let cid = this.domId("cid" + (cnt++));
		    let cinfo = {
			id: cid,
			v: v,
			percent: perc,
			field:f,
			record:r,
			colorBy: colorBys[f.getId()]
		    };
		    canvasInfo.push(cinfo);
		    let canvasWidth = cw;
		    let left =  perc+"%";
		    if(shape == "bar") {
			canvasWidth = perc*width;
			left = 0;
		    }
		    let cstyle = HU.css('position','absolute','top','0%','left',left,'margin-top','-' + (cw/2)+'px');
		    let inner = HU.tag("canvas",[ATTR_TITLE,"Value:" + v +"   Range:" + c.min +" - " + c.max,ATTR_STYLE,cstyle, 
						 "width",canvasWidth,"height",cw,ATTR_ID,cid]);
		    contents +=HU.div([ATTR_STYLE,HU.css('position','absolute','left','0px','right', cw+'px')],
				      inner);
		    html+=HU.td(["data-order", v, ATTR_STYLE,HU.css('vertical-align','middle'),ALIGN,"right",ATTR_TITLE, "Range:" + c.min +" - " + c.max],HU.div([ATTR_STYLE,"position:relative;width:"+width+"px;" + "height:1px;margin-left:10px; margin-right:10px;border:1px solid #ccc;"],contents));
		    
		});
		html += HU.close(TR);
	    });

	    html += HU.close(TBODY);
	    html += HU.open(TFOOT);
	    html+=HU.open(TR);
	    html+=HU.td([],"");
	    fields.forEach((f,idx)=>{
		html+=HU.td([],HU.div([ATTR_STYLE,HU.css('max-width', width+'px','overflow-x','auto'),ATTR_ID, this.domId("footer-" + idx)],""));
	    });
	    html+=HU.close(TR);
	    html += HU.close(TFOOT);

	    html+=HU.close(TABLE);
	    this.setContents(html); 
	    let opts = {
		ordering:true
	    };
	    if(this.getProperty("tableHeight")) {
		opts.scrollY = this.getProperty("tableHeight");
	    }
	    if(this.getProperty("showColorTable")) {
		fields.forEach((f,idx)=>{
		    let colorBy = colorBys[f.getId()];
		    if(colorBy.index<0) return;
		    let domId = "footer-" + idx;
		    colorBy.displayColorTable(null,false,domId);
		});
	    }


            HU.formatTable("#" + this.domId(ID_TABLE), opts);
	    let rows = this.find(".display-fieldtable-row");
	    this.addFieldClickHandler(null, records,true);
	    let markerFill = this.getProperty("markerFill","#64CDCC");
	    let markerStroke = this.getProperty("markerStroke","#000");
	    canvasInfo.forEach(c=>{
		let canvas = document.getElementById(c.id);
		let ctx = canvas.getContext("2d");
		ctx.strokeStyle =markerStroke;
		ctx.fillStyle=c.colorBy.getColorFromRecord(c.record, markerFill);
		if(shape=="circle") {
		    ctx.beginPath();
		    ctx.arc(cw/2, cw/2, cw/2, 0, 2 * Math.PI);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="rect") {
		    ctx.fillRect(0,0,cw,cw);
		    ctx.strokeRect(0,0,cw,cw);
		} else if(shape=="bar") {
		    ctx.fillRect(0,0,c.percent/100*width,cw);
		    ctx.strokeRect(0,0,c.percent/100*width,cw);
		} else if(shape=="line") {
		    ctx.fillRect(cw/2-2,0,4,cw);
		} else if(shape=="triangle") {
		    ctx.beginPath();
		    ctx.moveTo(cw/2,0);
		    ctx.lineTo(cw,cw);
		    ctx.lineTo(0,cw);
		    ctx.lineTo(cw/2,0);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="dart") {
		    ctx.beginPath();
		    ctx.moveTo(1,0);
		    ctx.lineTo(cw-1,0);
		    ctx.lineTo(cw/2,cw/2);
		    ctx.lineTo(1,0);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="arrow") {
		    ctx.beginPath();
		    ctx.moveTo(0,0);
		    ctx.lineTo(cw/2,cw/2);
		    ctx.lineTo(cw-1,0);
		    ctx.stroke();

		}
		
	    });

	}
    });
}


function RamaddaSelectedrecordsDisplay(displayManager, id, properties) {
    const ID_RECORDS = "selectedrecords";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_SELECTEDRECORDS, properties);
    let myProps = [
	{label:'Selected Records'},
	{p:'labelField',ex:'field'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    if(!this.recordList) {
		this.recordList=[];
	    }
	    if(this.recordList.length==0) {
		this.setContents('');
		return;
	    }
	    let records = this.recordList;
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
	    if(fields==null) return;
	    if(fields.length==0) 
		fields = this.getFields();
	    if(fields==null) return;
	    let notFields = this.getFieldsByIds(null,this.getProperty("notFields"));
	    if(notFields) {
		let not = {};
		notFields.forEach(f=>{not[f.getId()]=true;});
		fields=fields.filter(f=>{
		    return !not[f.getId()];
		});

	    }
	    let labelField = this.getFieldById(null, this.getLabelField());
	    let html ='';
	    html+=HU.div([ATTR_ID,this.domId('download')],"Download Data");
	    html+=HU.openTag(TAG_TABLE,[ATTR_CLASS,"ramadda-table stripe row-border", 'xwidth','100%',ATTR_ID,this.domId(ID_RECORDS)]);
	    this.idToRecord = {};
	    this.csv =[];
	    if(labelField) {
		let row = [];
		this.csv.push(row);
		html+=HU.open('thead');
		row.push("Field");
		html+=HU.th(['align','center'],'Field');

		records.forEach(record=>{
		    this.idToRecord[record.getId()] = record;
		    let v = labelField.getValue(record);
		    row.push(v);
		    let div = HU.div([ATTR_CLASS,'ramadda-clickable display-selectedrecords-header',
				      ATTR_TITLE,'Click to remove','data-record-id',record.getId()],
				     v);
		    html+=HU.th(['align','center'],div);
		});
		html+=HU.close('thead');
	    }
	    html+=HU.open('tbody');
	    fields.forEach((f,idx)=>{
		if(labelField && labelField.getId()==f.getId()) return;
		html+=HU.open(TAG_TR);
		let row = [];
		this.csv.push(row);
		records.forEach((record,idx) =>{
		    if(idx==0) {
			row.push(f.getLabel());
			html+=HU.td(['width','20%'], HU.b(f.getLabel()));
		    }
		    let attrs=[];
		    let v = f.getValue(record);
		    row.push(v);
		    if(!isNaN(v)) attrs.push('align','right');
		    else if(String(v)==="NaN") {
			v="--";
			attrs.push('align','right');			
		    }			
		    html+=HU.td(attrs,v);
		});
		html+=HU.close(TAG_TR);		
	    });
	    html += HU.close(TBODY,TABLE);
	    this.setContents(html); 
	    this.jq('download').button().click(()=>{
		let c='';
		this.csv.forEach(row=>{
		    c+=Utils.join(row,',');
		    c+='\n';
		});
		Utils.makeDownloadFile(this.getProperty('downloadFile','data.csv'),c);
	    });


	    let opts ={};
	    if(this.getProperty("tableHeight")) {
		opts.scrollY = this.getProperty("tableHeight");
	    }
	    let _this = this;
	    let initTable = ()=>{
		//Look for headers. There are doubles because of DataTables
		let headers =_this.getContents().find('.display-selectedrecords-header');
		headers.click(function() {
		    //For some reason the div is the parent
		    let div = $(this).parent();		    
		    //A bit of a hack. For some reason the element can't access the record-id attribute
		    //So we parse it out from the html
		    let recordId = div.attr('data-record-id');
		    if(!recordId) {
			let match  = div.html().match(/data-record-id="(.*)"/);
			if(match) {
			    recordId = match[1];
			}
		    }
		    if(!recordId) return;
		    let record = _this.idToRecord[recordId];
		    if(!record) return;
		    if(_this.seenRecords)
			delete _this.seenRecords[record.getId()];
	 	    _this.recordList= Utils.removeItem(_this.recordList,record);
		    _this.updateUI();
		});
	    };
            HU.formatTable("#" + this.domId(ID_RECORDS), opts,initTable);
	},

        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    if(!this.seenRecords)
		this.seenRecords={};
	    if(!this.recordList) 
		this.recordList=[];
	    if(this.seenRecords[args.record.getId()]) return;
	    this.seenRecords[args.record.getId()]=true;
	    this.recordList.push(args.record);
	    this.updateUI();
	}
	
    });
}



function RamaddaDotstackDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, "dotstack", properties);
    let myProps = [
	{label:'Dot Stack'},
	{p:'categoryField',ex:'field'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let idToIndex = {};
	    records.forEach((r,idx)=>{
		idToIndex[r.getId()] = idx;
	    });
	    let hor = this.getProperty("orientation","horizontal") == "horizontal";
	    let categoryField = this.getFieldById(null, this.getProperty("categoryField"));
	    let html = "";
	    let groups = RecordUtil.groupBy(records, this, null, categoryField);
	    let colorBy = this.getColorByInfo(records);
	    let w = this.getProperty("boxWidth",4);
	    let cols = this.getProperty("boxColumns",10);
	    let xcnt = 0;
	    groups.values.sort((a,b)=>{
		return groups.map[b].length-groups.map[a].length;
	    });

	    groups.values.forEach((value,idx)=>{
		let rows = [];
		let row = [];
		rows.push(row);
		let grecords = groups.map[value];
		let col=0;
		grecords.forEach(r=>{
		    if(row.length>cols) {
			row=[];
			rows.push(row);
		    }
		    let c = colorBy.getColorFromRecord(r,"blue");
		    let box = HU.div(
			[ATTR_TITLE,"", RECORD_ID, r.getId(),RECORD_INDEX,idToIndex[r.getId()],ATTR_CLASS, "display-dotstack-dot",ATTR_STYLE,HU.css('width', w+'px','height', w +'px','background', c)],"");
		    row.push(box);
		});
		html += HU.open(DIV,[ATTR_CLASS,"display-dotstack-block"]);
		html+=HU.div([],this.getProperty("labelTemplate","${count}").replace("${count}", grecords.length));
		html += HU.open(TABLE);
		for(let i=rows.length-1;i>=0;i--) {
		    html += HU.tr([],HU.tds([],rows[i]));
		}
		html += HU.close(TABLE);
		html +=value;
		html += HU.close(DIV);
	    });
	    this.setContents(html); 
	    let dots = this.find(".display-dotstack-dot");
	    this.addFieldClickHandler(dots,records,false);
	    this.makeTooltips(dots,records,null,"${default}");
	    if(this.getProperty("tableHeight")) {
		opts.scrollY = this.getProperty("tableHeight");
	    }
	    if(this.getProperty("showColorTable")) {
		colorBy.displayColorTable(null,false,domId);
	    }
	}
    });
}


function RamaddaDotbarDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, "dotbar", properties);
    $.extend(this, SUPER);
    addRamaddaDisplay(this);
    let myProps = [
	{label:'Dot Bar'},
	{p:'keyField'},
	{p:'dotSize',d:16}
    ];
    this.defineSizeByProperties();
    defineDisplay(this, SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let keyField = this.getFieldById(null,this.getPropertyKeyField());
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
 	    if(fields.length==0) {
		fields = this.getPointData().getRecordFields();
	    }
	    let dotSize = this.getPropertyDotSize();
	    let sizeBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records);
	    let size = dotSize;
	    let cols = {};
	    let html = HU.open(TABLE,['width','100%']);
	    let t1 = new Date();
	    let selectedRecord;
	    let maxHeight = dotSize;
	    if(sizeBy.field)
		maxHeight=2*sizeBy.getMaxSize();
	    fields.forEach((f,idx)=>{
		if(!f.isFieldNumeric()) return;


		let cb = new  ColorByInfo(this,  fields, records, null,null, null, null,f);
		let cid = this.domId("dots"+idx);
		let column = this.getColumnValues(records, f);
		html += HU.open(TR, [VALIGN,'center']);
		html += HU.td([WIDTH,'10%', ALIGN,'right'],  HU.div([ATTR_STYLE,HU.css('margin-right','8px')], this.getFieldLabel(f).replace(/ /g,SPACE)));
		html += HU.td([ALIGN,'right',WIDTH,'5%'],HU.div([ATTR_STYLE, 'margin-right:10px;'],this.formatNumber(column.min)));
		html +=HU.open(TD);
		html+= HU.open(DIV,[ATTR_STYLE, HU.css(HEIGHT,HU.getDimension(maxHeight), WIDTH,'100%','position','relative','margin-top','4px')]);
		html+=HU.div([ATTR_STYLE,HU.css('position','absolute','left','0px','right','0px','top','50%','border-top','1px solid #ccc')]);
		html+=SPACE;
		records.forEach((r,idx2)=>{
		    let v = r.getValue(f.getIndex());
		    let c = cb.getColor(v,r);
		    let darkC = Utils.pSBC(-0.25,c);
		    if(column.min == column.max) return;
		    let perc = (v-column.min)/(column.max-column.min);
		    let clazz = 'display-dotbar-dot';
		    let selected = false;
		    let style = "";
		    if(keyField && this.selectedKey) {
			if(this.selectedKey == r.getValue(keyField.getIndex())) {
			    selected = true;
			}
		    } else if(idx2==this.selectedIndex) {
			selected = true;
		    }
		    let dotBorder = "2px solid " + darkC;
		    if(this.selectedIndex>=0) {
			if(!selected) {
			    dotBorder = "1px solid " + darkC;
			    c = "rgba(200,200,200,0.2)";
			} else {
			    dotBorder = "1px solid #000";
			}
		    }
		    if(selected) {
			selectedRecord = r;
			clazz += " display-dotbar-dot-select";
		    } else {
			if(this.getFilterHighlight()) {
			    if(!r.isHighlight(this)) {
				style = HU.css('z-index','10','border','1px solid #aaa');
			    }
			}
		    }
		    perc *=100;
		    let size = dotSize;
		    if(sizeBy.field) {
			size  = 2*sizeBy.getSize(r.getData(), dotSize);
			if(size<0) return;
			style+=HU.css(HEIGHT,HU.getDimension(size),WIDTH,HU.getDimension(size));
		    }
		    let top = maxHeight/2-size/2;
		    html +=  HU.span([RECORD_INDEX,idx2,RECORD_ID, r.getId(),ATTR_CLASS,clazz,ATTR_STYLE,HU.css('border',dotBorder, "background",c,"position",'absolute','top',HU.getDimension(top),'left', perc+'%')+style, RECORD_INDEX,idx2, ATTR_TITLE,""]); 
		});

		html += HU.close(DIV,TD);
		html += HU.td([WIDTH, (dotSize*2)]);
		html += HU.td([ALIGN,"right", WIDTH,"5%"],HU.div([ATTR_STYLE,HU.css('margin-left','10px')],this.formatNumber(column.max)));
		html+=HU.close(TR);
	    });
	    let t2 = new Date();
	    html+=HU.close(TABLE);
	    this.setContents(html); 
	    let t3 = new Date();
	    let dots = this.find(".display-dotbar-dot");
	    let t4 = new Date();
	    let _this = this;
	    dots.mouseleave(function() {
		dots.removeClass("display-dotbar-dot-highlight");
	    });
	    dots.mouseover(function() {
		let idx = $(this).attr(RECORD_INDEX);
		dots.removeClass("display-dotbar-dot-highlight");
		_this.find("[" + RECORD_INDEX+"=\"" + idx+"\"]").addClass( "display-dotbar-dot-highlight");
	    });
	    dots.click(function() {
		let idx = $(this).attr(RECORD_INDEX);
		let record = records[idx];
		if(!record) return;
		dots.removeClass("display-dotbar-dot-select");
		if(_this.selectedIndex ==  idx) {
		    _this.selectedIndex =  -1;
		    _this.updateUI();
		    return;
		}
		_this.selectedIndex =  idx;
		if(keyField)
		    _this.selectedKey = record.getValue(keyField.getIndex());
		_this.find("[" + RECORD_INDEX+"=\"" + idx+"\"]").addClass( "display-dotbar-dot-select");
		_this.hadClick = true;
		_this.propagateEventRecordSelection({record: record});
		_this.updateUI();
	    });	    //Do this later so other displays get this after they apply their data filter change
	    if(selectedRecord){
		setTimeout(()=>{
		    this.propagateEventRecordSelection({record: selectedRecord});
		},10);
	    }
	    this.makeTooltips(dots,records,null);
	    let t5 = new Date();
	    //	    Utils.displayTimes("t",[t1,t2,t3,t4,t5]);

	}
    });
}




function RamaddaDategridDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_DATEGRID, properties);
    $.extend(this, SUPER);
    addRamaddaDisplay(this);
    let myProps = [
	{label:'Date Box'},
	{p:'groupField'},
	{p:'boxSize',d:16},
	{p:'showStats',ex:'true',d:true,tt:'show starts per row'},
	{p:'showTotal',ex:'true',d:true,tt:'show the totals'},
	{p:'showMin',ex:'true',d:true,tt:'show min'},
	{p:'showMax',ex:'true',d:true,tt:'show max'},
	{p:'showAverage',ex:'true',d:false,tt:'show average'},				
	{p:'leftWidth',tt:'width of left column',d:'100px'},
	{p:'rightWidth',tt:'width of right column',d:'100px'},
 	{p:'leftLabel',tt:'Label for the left column'},
 	{p:'rightLabel',tt:'Label for the left column',d:'Total/Min/Max'},	
	{p:'dateHeaderStyle',tt:'Style to use for the date header'},
	{p:'dateStride',d:-1,tt:'The stride in hours to display the date label'},	
	{p:'numLabels',d:8,tt:'Hour many date labels to show if no dateStride given'},	
	{p:'boxStyle',tt:'Style to use for color boxes'},
	{p:'leftStyle',tt:'Style to use for left column'},
	{p:'rightStyle',tt:'Style to use for right column'},			

    ];
    this.defineSizeByProperties();
    defineDisplay(this, SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let groupField = this.getFieldById(null,this.getPropertyGroupField());
	    let size = this.getBoxSize();
	    let cats =[];
	    let colorBy = this.getColorByInfo(records);
	    let minDate= null, maxDate=null;
	    records.forEach(r=>{
		if(!minDate) {
		    minDate = maxDate = r.getDate();
		} else {
		    let d = r.getDate();
		    minDate = d.getTime()<minDate.getTime()?d:minDate;
		    maxDate = d.getTime()>maxDate.getTime()?d:maxDate;		    
		}
		let v = r.getValue(groupField.getIndex());
		let cat = cats[v];
		if(cat == null) {
		    cat = {
			records:[]
		    };
		    cats[v] = cat;
		}
		cat.records.push(r);
	    });
	    if(!this.dateFormat)
		this.dateFormat =  this.getProperty("dateFormat", "ddd mm/dd");
	    let showStats = this.getShowStats();
	    let leftWidth = HU.getDimension(this.getLeftWidth());
	    let rightWidth = HU.getDimension(this.getRightWidth());	    
	    let html = "";
	    let width = 400;
	    let dateRange = maxDate.getTime()-minDate.getTime();

	    let scaleX = d=>{
		return  (d.getTime()-minDate.getTime())/dateRange;
	    };
	    let height = "1.5em";
	    html="<div class=display-dategrid-table><table width=100% border=0 cellpadding=0 cellspacing=0>";

	    html+="<tr><td width='" + leftWidth+"'>" + HU.div([ATTR_CLASS,"display-dategrid-header"],this.getLeftLabel(this.getFieldLabel(groupField))) +"</td>";
	    let dateHeaderStyle = this.getDateHeaderStyle("background:#eee;border-bottom:1px solid #888;");
	    let boxStyle = this.getBoxStyle("");
	    let leftStyle = this.getLeftStyle("");
	    let rightStyle = this.getRightStyle("");	    	    
	    let dateHeader = HU.open("div",[ATTR_CLASS,'display-dategrid-dateheader',ATTR_STYLE,dateHeaderStyle]) + SPACE;
	    let date  = minDate;
	    let dateStride = this.getDateStride(-1);
	    let dateDelta;
	    if(dateStride>0) {
		dateDelta = dateStride*1000*60*60;
	    } else {
		let hours = Math.round((maxDate.getTime()- minDate.getTime())/1000/60/60);
		let numLabels = this.getNumLabels();
		let hoursPerLabel =Math.round(hours/numLabels);
		dateDelta = hoursPerLabel*1000*60*60;
	    }
	    let rem =  minDate.getTime()%dateDelta;
	    date = new Date(minDate.getTime()-rem+dateDelta);

	    while(date.getTime()<=maxDate.getTime()) {
		let perc = (100*scaleX(date))+"%";
		let style = HU.css("left",perc,"top","0%","transform","translate(-50%, 0%)");
		dateHeader+=HU.div([ATTR_CLASS,"display-dategrid-header display-dategrid-date",ATTR_STYLE,style],this.formatDate(date))+"\n";

		date = new Date(date.getTime() +dateDelta);
	    }
	    dateHeader +="</div>";

	    html+=HU.td([],dateHeader);
	    if(showStats) {
		let dflt = [];
		if(this.getShowTotal()) dflt.push("Total");
		if(this.getShowMin()) dflt.push("Min");
		if(this.getShowMax()) dflt.push("Max");
		if(this.getShowAverage()) dflt.push("Avg");
		html+="<td width='" + rightWidth + "'>" + HU.div([ATTR_CLASS,"display-dategrid-header display-dategrid-stats"], this.getRightLabel(Utils.join(dflt,"/"))) +"</td>";
	    }
	    html +="</tr>"
	    Object.keys(cats).sort(v=>{
		let cat = cats[v];
		let row = HU.open("div",[ATTR_CLASS,"display-dategrid-row", ATTR_STYLE,HU.css('height',height)]);
		let sorted = cat.records.sort((a,b)=>{
		    return a.getTime()-b.getTime();
		});
		let total = 0;
		let min=NaN;
		let max=NaN;
		
		for(let i=0;i<sorted.length;i++) {
		    let r = sorted[i];
		    let perc = scaleX(r.getDate());
		    let next = sorted[i+1];
		    let boxWidth="10p";
		    let right = perc+0.05;
		    if(next) {
			let nperc = scaleX(next.getDate());
			let diff = nperc - perc;
			right = (1-nperc);
		    }
		    perc = 100*perc+"%";
		    right = 100*right+"%";
		    let color =  colorBy.getColorFromRecord(r);
		    let cv = r.getValue(colorBy.index);
		    if(!isNaN(cv)) {
			total+=cv;
			min = Utils.min(min,cv);
			max = Utils.max(max,cv);			
		    }
		    row+=HU.div(["foo","bar", RECORD_ID,r.getId(),ATTR_CLASS,"display-dategrid-box",ATTR_TITLE,cv,ATTR_STYLE,HU.css("left",perc,"right",right, "height",height,"background",color)+boxStyle],"&nbsp;");
		}
		row+="</div>\n";
		html+="<tr><td width='"+ leftWidth+"'>" +HU.div([ATTR_STYLE,leftStyle,ATTR_CLASS,"display-dategrid-rowlabel"], v)+"</td><td>" + row +"</td>"
		if(showStats) {
		    let stats = [];
		    if(this.getShowTotal())
			stats.push(this.formatNumber(total));
		    if(this.getShowMin())
			stats.push(this.formatNumber(min,null));
		    if(this.getShowMax())
			stats.push(this.formatNumber(max));


		    if(this.getShowAverage())
			stats.push(this.formatNumber(total/sorted.length));		    		    		    
		    html+=HU.td(["nowrap","true"],HU.div([ATTR_STYLE, rightStyle,ATTR_CLASS,"display-dategrid-stats"],Utils.join(stats,SPACE)));
		}
		html+="</tr>";
	    });
	    html += "</table></div>";
	    this.setContents(html); 
	    this.boxes = this.find(".display-dategrid-box");
	    this.addFieldClickHandler(this.boxes, records,false);
	    this.makeTooltips(this.boxes,records,null);
	    this.recordMap = this.makeIdToRecords(records);
	    this.records = records;
	    colorBy.displayColorTable();
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    if(!this.boxes) {
		return;
	    }
	    let matched = [];
	    let record = this.recordMap[args.record.getId()];
	    if(record) {
		matched.push(record);
	    } else {
		matched = this.findMatchingDates(args.record.getDate(), this.filteredRecords);
	    }
	    if(matched.length==0) {
		console.log("none");
		return;
	    }
	    this.boxes.removeClass("display-dategrid-box-highlight");
	    let boxMap ={};
	    this.boxes.each(function() {
		boxMap[$(this).attr(RECORD_ID)] = $(this);
	    });
	    matched.forEach(record=>{
		let box =  boxMap[record.getId()];
		if(box) box.addClass("display-dategrid-box-highlight");
	    });


	}
    });
}



function RamaddaStripesDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_STRIPES, properties);
    let myProps = [
	{label:'Stripes'},
	{p:'colorBy',ex:'',tt:'Field id to color by'},
	{p:'stripeHeight',d:'100px'},
	{p:'stripeWidth',d:3,tt:'Make sure this is a whole number'},
	{p:'showLabel',d:false,ex:'true'},
	{p:'showLegend',d:false,ex:'true'},
	{p:'showColorTable',d:false,ex:'true'}	,
	{p:'showColorTableBottom',d:false,ex:'true'},
	{p:'groupBy',tt:'Field id to group by'},
	{p:'showSparkline',ex:'true'},
    ];
    myProps.push(...RamaddaDisplayUtils.sparklineProps);

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        checkLayout: function() {
	    //This gets called when the display is in a tab
	    //If we are showing sparklings then redraw
	    if(this.getShowSparkline()) {
		this.updateUI();
	    }
	},
        updateUI: function() {
	    let allRecords = this.filterData();
	    if(!allRecords) return;
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
	    if(fields.length==0) {
                this.handleError("No field specified");
		return;
	    }

	    let groupField = this.getFieldById(null,  this.getGroupBy());
	    let groupedRecords={};
	    if(groupField) {
		allRecords.forEach((record,idx)=>{
		    let value = groupField.getValue(record);
		    if(!groupedRecords[value]) {
			groupedRecords[value] = [];
		    }
		    groupedRecords[value].push(record);
		});
	    } else {
		groupedRecords['all'] = allRecords;
	    }
	    let allFields = this.getFields();
	    let stripeHeight=this.getStripeHeight();
	    let recordMap={};
	    allRecords.forEach(record=>{
		recordMap[record.getId()]  =record;
	    });
	    let html = '<center><div style="display:inline-block;">';
	    let colorBys = [];
	    let stripeWidth=this.getStripeWidth();
	    let groups = Object.keys(groupedRecords);

	    let makeLegend = ()=>{
		let left =this.formatDate(allRecords[0].getDate());
		if(this.getShowLabel()) {
		    left  = HU.div([ATTR_STYLE,'margin-left:2em;'], left);
		}
		let center = HU.div([ATTR_STYLE,'text-align:center;'],this.formatDate(allRecords[parseInt(allRecords.length/2)].getDate()));
		html+=HU.leftCenterRight(left,
					 center,
					 this.formatDate(allRecords[allRecords.length-1].getDate()),
					 '20%','60%','20%');

	    };
	    if(this.getShowLegend()) {
		makeLegend();
	    }
	    let blocks = [];
	    let labelWidth='2em';
	    groups.forEach((key,groupIdx)=>{
		if(groupField) {
		    html+=key;
		}
		let records =groupedRecords[key];
		fields.forEach((field,fidx)=>{
		    let uid = HU.getUniqueId('table_');
		    html+=HU.open(TAG_TABLE,[ATTR_ID,uid,ATTR_STYLE,HU.css('position','relative')]);
		    blocks.push({domId:uid,records:records,field:field});
		    let isLast = (groupIdx==groups.length-1 && fidx==fields.length-1);
		    let isFirst = (groupIdx==0 && fidx==0);
		    let colorBy = new  ColorByInfo(this,allFields, records, '',null,null,null,field);
		    colorBys.push(colorBy);
		    if(fields.length>1)
			html+='<tr style="border-bottom:1px solid #efefef;">';
		    else html+='<tr>';
		    if(this.getShowLabel()) {
			html+=HU.td(['width',labelWidth,
				     ATTR_CLASS,'display-stripes-stripe-label',
				     ATTR_STYLE,'max-width:2em;width:2em'],
				    HU.div(['width',labelWidth,ATTR_STYLE,
					    HU.css('max-width',labelWidth,'width',labelWidth,'max-height',HU.getDimension(stripeHeight)),ATTR_CLASS,'display-stripes-vertical-label'],field.getLabel()));
		    }
		    records.forEach((record,idx)=>{
			let color =  colorBy.getColorFromRecord(record);
			let data = field.getValue(record);
			let date  = record.getDate();
			let title =field.getLabel()+': '+data;
			if(date) title = this.formatDate(date) +' - ' + title;
			let contents = '';
			let attrs = [RECORD_ID,record.getId(),
				     ATTR_CLASS,'display-stripes-stripe',
				     ATTR_STYLE,HU.css('height',HU.getDimension(stripeHeight),'background',color),
				     ATTR_TITLE,title,'width',stripeWidth];
			html+=HU.td(attrs,contents);
		    });
		    html+=HU.close(TAG_TR,TAG_TABLE);
		    if((isLast &&this.getShowColorTableBottom()) || this.getShowColorTable()) {
			html+=HU.div([ATTR_ID,this.domId('colortable_'  + fidx),ATTR_STYLE,
				      HU.css('width',(stripeWidth*records.length)+'px','margin-bottom','5px','height','1em')],'');
		    }
		});
	    });
	    if(this.getShowLegend()) {
		makeLegend();
	    }
	    html+='</div></center>';
	    this.setContents(html); 
	    colorBys.forEach((colorBy,fidx)=>{
		colorBy.displayColorTable(null,null,'colortable_'+fidx);
	    });
	    if(this.getShowSparkline()) {
		blocks.forEach(block=>{
		    let table = $('#'+ block.domId);
		    let labelColumn = table.find('.display-stripes-stripe-label');
		    let w = table.width();
		    let h = table.height();		
		    if(labelColumn.length>0) {
			w -=labelColumn.width();
		    }
		    let divId = HU.getUniqueId('div_');
		    table.append(HU.div([ATTR_ID,divId,ATTR_STYLE,HU.css('position','absolute',
									 'pointer-events','none',
									 'margin-left',this.getShowLabel()?labelWidth:'0px',
									 'left','0px',
									 'top','0px',
									 'width',w+'px',
									 'height',h+'px')],''));

		    let column = this.getColumnValues(block.records, block.field);
		    let minMaxColumn = this.getColumnValues(this.getSparklineUseAllRecords()?allRecords:block.records, block.field);		    
		    let m = 5;
		    drawSparkline(this,"#"+ divId,w,h,
				  column.values,block.records,
				  minMaxColumn.min,minMaxColumn.max,null,
				  {margin:{top:m,bottom:m}});
		});
	    }

	    let _this = this;
	    let stripes =   this.getContents().find('.display-stripes-stripe');
	    this.makeTooltips(stripes,allRecords);
	    stripes.click(function() {
		let record = recordMap[$(this).attr('record-id')];
		_this.propagateEventRecordSelection({record: record});
	    });

	},
    });
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


const DISPLAY_PLOTLY_RADAR = "radar";
const DISPLAY_PLOTLY_WINDROSE = "windrose";
const DISPLAY_PLOTLY_DENSITY = "density";
const DISPLAY_PLOTLY_DOTPLOT = "dotplot";
const DISPLAY_PLOTLY_SPLOM = "splom";
const DISPLAY_PLOTLY_PROFILE = "profile";
const DISPLAY_PLOTLY_3DSCATTER = "3dscatter";
const DISPLAY_PLOTLY_3DMESH = "3dmesh";
const DISPLAY_PLOTLY_TREEMAP = "ptreemap";
const DISPLAY_PLOTLY_TERNARY = "ternary";
const DISPLAY_PLOTLY_SUNBURST= "sunburst";
const DISPLAY_PLOTLY_TEXTCOUNT = "textcount";
const DISPLAY_PLOTLY_COMBOCHART = "combochart";
const DISPLAY_PLOTLY_PARCOORDS = "parcoords";

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_RADAR,
    label: "Radar",
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('Radar Plot','radar.png')
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_WINDROSE,
    label: "Wind Rose",
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('Wind Rose Plot','windrose.png')
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_SUNBURST,
    label: "Sunburst",
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('Sunburst Plot','sunburst.png')                            
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_DENSITY,
    label: "Density",
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('Density Plot','density.png',null)                                    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_COMBOCHART,
    label: "Combo Chart",
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip('Combo Chart','combochart.png','Display line and bar chart')
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_PARCOORDS,
    label: "Parallel Coords",
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('Parallel Coordinates','parallel.png',null)
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_DOTPLOT,
    label: "Dot Plot",
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip('Dot Plot', 'dotplot.png')
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_SPLOM,
    label: "Splom",
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('Splom','splom.png')    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_3DSCATTER,
    label: "3D Scatter",
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('3D Scatter','3dscatter.png')    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_PROFILE,
    label: "Profile",
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip('Profile','profile.png')                    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_3DMESH,
    label: "3D Mesh",
    requiresData: false,
    forUser: false,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip('3D Mesh','3dmesh.png')
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_TEXTCOUNT,
    label: "Text Count",
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip('Text Count','textcount.png',
				'Given a text field show the number of <br>times certain word patterns occur')
});

//Ternary doesn't work
//addGlobalDisplayType({type: DISPLAY_PLOTLY_TERNARY, label:"Ternary",requiresData:true,forUser:true,category:CATEGORY_RADIAL_ETC});
//Treempap doesn't work
//addGlobalDisplayType({type: DISPLAY_PLOTLY_PTREEMAP, label:"Tree Map",requiresData:true,forUser:true,category:CATEGORY_RADIAL_ETC});


var ID_PLOT= "plot";
var ID_PLOTY = "plotly";


function RamaddaPlotlyDisplay(displayManager, id, type, properties) {
    let SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    //Dynamically load plotly
    let myProps = [
	{label:'Plotly Properties'},
	{p:'plotTitle'},
	{p:'font'},
	{p:'fontSize',d:12},
	{p:'fontColor',d:'#000'}];

    defineDisplay(this, SUPER, myProps, {
//    RamaddaUtil.inherit(this, SUPER);
//    RamaddaUtil.defineMembers(this, {
	getRequirement:function() {
	    return "Plotly";
	},
        needsData: function() {
            return true;
        },
	showFieldsInDialog: function() {
	    return true;
	},
	updateUI:function(args) {
	    if(!window.Plotly) {
		let url = RamaddaUtil.getCdnUrl("/lib/plotly/plotly-2.24.1.min.js");
		let callback = this.loadingJS?null:   ()=>{
//		    Utils.loadScript('/repository/lib/d3/d3.js');
		    this.updateUI(args);
		};
		Utils.loadScript(url,callback); 
		return;
	    }
	    this.updateUIInner(args);
	},
	updateUIInner:function(args) {
	},
        setDimensions: function(layout, widthDelta,ext) {
	    ext = ext??{};
            //                var width  = parseInt(this.getProperty("width","400").replace("px","").replace("%",""));
            var height = parseInt(this.getProperty("height", "400").replace("px", "").replace("%", ""));
            //                layout.width = width-widthDelta;
            layout.height = height;
	    if(!layout.margin) layout.margin={};
	    [["l","marginLeft"],["r","marginRight"],["t","marginTop"],["b","marginBottom"]].map(t=>{
		let key = t[1];
		if(Utils.isDefined(this.getProperty(key)))
		    layout.margin[t[0]]  = this.getProperty(key);
		else if(Utils.isDefined(ext[key])) 
		    layout.margin[t[0]]  = ext[key];
	    });
        },
        pointDataLoaded: function(pointData, url, reload) {
            SUPER.pointDataLoaded.call(this, pointData, url, reload);
	    /*
              if (this.dataCollection)
              this.displayManager.propagateEventRecordSelection(this,
              this.dataCollection.getList()[0], {
              index: 0
              });
	    */

        },
        displayData: function() {
            this.updateUI();
        },
        pageHasLoaded: function() {
            SUPER.pageHasLoaded.call(this);
            this.updateUI();
        },

        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        makeAxis: function(title, tickangle) {
            return {
                title: title,
                titlefont: {
                    size: 20
                },
                tickangle: tickangle,
                tickfont: {
                    size: 15
                },
                tickcolor: 'rgba(0,0,0,0)',
                ticklen: 5,
                showline: true,
                showgrid: true
            };
        },
        getDisplayStyle: function() {
            return "";
        },
        makePlot: function(data, layout) {
            this.clearHtml();
	    let html = 
		HtmlUtils.div([ATTR_ID,this.getDomId(ID_HEADER)],"") +
		HtmlUtils.div([ATTR_ID, this.getDomId(ID_PLOT), ATTR_STYLE, "width:100%;"+this.getDisplayStyle()], "") +
		HtmlUtils.div([ATTR_ID,this.getDomId(ID_FOOTER)],"");
	    this.setContents(html);
	    //do the plot creation a bit later so the width of the ID_PLOT div gets set OK
	    setTimeout(()=>{
		let plot = Plotly.newPlot(this.getDomId(ID_PLOT), data, layout,{displayModeBar: false});
		let myPlot = document.getElementById(this.getDomId(ID_PLOT));
		if(myPlot) {
		    this.initPlot(plot, myPlot);
		}
	    },1);
        },
	makeLayout:function(layout) {
            let myLayout = {
                title: this.getPlotTitle(''),
		font: {
		    family: this.getFont(),
		    size: this.getFontSize(),
		    color: this.getFontColor()
		}
	    };
	    if(layout) return $.extend(layout,myLayout);


	    return myLayout;
	},
        handleClickEvent: function(data) {
	    if(data.points && data.points.length>0) {
		let record = data.points[0].record;
		if(!record) {
		    let index = data.points[0].pointIndex;
		    record = this.indexToRecord[index];
		}
		if(record) {
		    this.propagateEventRecordSelection({record: record});
		}
	    }
	},
        initPlot: function(plot, myPlot) {
	    let _this = this;
            myPlot.on('plotly_click', function(data) {
		_this.handleClickEvent(data);
            });

	}
    });
}



function RamaddaRadialDisplay(displayManager, id, type, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, type, properties));
    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'barpolar';
        },
        updateUIInner: function() {
            var records = this.filterData();
            if (!records) {
                return;
            }
            var fields = this.getSelectedFields(this.getData().getRecordFields());
	    var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
	    var theta;
	    var thetaType;
	    if(this.getProperty("useDates")) {
		var tmp = this.getDateValues(records);
		theta=[];
		var dateFormat = this.getProperty("dateFormat", "yyyyMMdd");
		thetaType = "category";
		tmp.map(d=>{
		    theta.push(Utils.formatDateWithFormat(d,dateFormat));
		});
	    } else {
		var thetaField = this.getFieldById(null, this.getProperty("thetaField"));
		if (thetaField) {
		    theta = this.getColumnValues(records, thetaField).values;
		}
	    }
            var values = [];
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            var plotData = [];
            for (var i = 0; i < numericFields.length; i++) {
                var field = numericFields[i];
                var column = this.getColumnValues(records, field);
		if(!theta) {
		    theta = [];
		    var cnt = 0;
		    for(var cnt=0;cnt<column.values.length;cnt++)
			theta.push(cnt*360/column.values.length);
		}
                min = Math.min(min, column.min);
                max = Math.max(max, column.max);
		var values = column.values;
                plotData.push({
                    type: this.getPlotType(),
                    r: values,
                    theta: theta,
                    fill: 'toself',
                    name: field.getLabel(),
                });
            }

            layout = {
                polar: {
                    angularaxis: {
			type:"category"
		    },
                    radialaxis: {
                        visible: true,
                        range: [min, max]
                    }
                },
            }
	    if(thetaType) {
		layout.polar.angularaxis  ={
		    type:thetaType
		};
	    }
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}

function RamaddaRadarDisplay(displayManager, id, properties) {
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaRadialDisplay(displayManager, id, DISPLAY_PLOTLY_RADAR, properties));

    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'scatterpolar';
        },
    });
    addRamaddaDisplay(this);
}

function RamaddaWindroseDisplay(displayManager, id, properties) {
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaRadialDisplay(displayManager, id, DISPLAY_PLOTLY_WINDROSE, properties));
    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'barpolar';
        },
    });
    addRamaddaDisplay(this);
}




function RamaddaDensityDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "600px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_DENSITY, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUIInner: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length < 2) {
                this.displayError("No numeric fields specified");
                return;
            }

            var x = this.getColumnValues(records, numericFields[0]);
            var y = this.getColumnValues(records, numericFields[1]);
            var markers = {
                x: x.values,
                y: y.values,
                mode: 'markers',
                name: "",
                marker: {
                    color: this.getProperty("pointColor", 'rgb(102,0,0)'),
                    size: parseInt(this.getProperty("markerSize", "4")),
                    opacity: 0.4
                },
                type: 'scatter'
            };
            var density = {
                x: x.values,
                y: y.values,
                name: 'density',
                ncontours: 20,
                colorscale: 'Hot',
                reversescale: true,
                type: 'histogram2dcontour'
            };
            var plotData = [];
            if (this.getProperty("showDensity", true))
                plotData.push(density);
            if (this.getProperty("showPoints", true))
                plotData.push(markers);
            var layout = {
                showlegend: true,
                autosize: true,
                margin: {
                    t: 50
                },
                hovermode: 'closest',
                bargap: 0,
                xaxis: {
                    domain: [x.min, x.max],
                    showline: this.getProperty("showLines", true),
                    showgrid: this.getProperty("showLines", true),
                    title: fields[0].getLabel()
                },
                yaxis: {
                    domain: [y.min, y.max],
                    showline: this.getProperty("showLines", true),
                    showgrid: this.getProperty("showLines", true),
                    title: fields[1].getLabel()
                },
            };
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });


}


function RamaddaPlotly3DDisplay(displayManager, id, type, properties) {
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, type, properties);
    let myProps = [
	{label:'3D Plot'},
	{p:'markerSize',d:6},
	{p:'axisLineColor',d:'rgb(255,255,255)'},
	{p:'xaxisBackground',d:'rgb(200, 200, 230)'},
	{p:'yaxisBackground',d:'#ccc'},	
	{p:'zaxisBackground',d:'rgb(230, 230,200)'},
	{p:'chartBackground', d:'rgb(255,255,255,0)'}
    ];
    defineDisplay(this, SUPER, myProps, {
        initPlot: function(plot, myPlot) {
	    SUPER.initPlot.call(this, plot, myPlot);
            myPlot.on('plotly_click', function() {
                //                        alert('You clicked this Plotly chart!');
            });
        },

        getDisplayStyle: function() {
            return "border: 1px #ccc solid;";
        },
        get3DType: function() {
            //                'mesh3d'
            return 'scatter3d';
        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) return;
            let allFields = this.getSelectedFields(this.getData().getRecordFields());
            let fields = this.getFieldsByType(allFields, "numeric");
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length < 3) {
                this.displayError("Don't have 3 numeric fields specified");
                return;
            }
	    this.records = records;
	    this.xField = fields[0];	    
	    this.yField = fields[1];
	    this.zField = fields[2];	    
            let x = this.getColumnValues(records, this.xField);
            let y = this.getColumnValues(records, this.yField);
            let z = this.getColumnValues(records, this.zField);
	    let marker =  {
                size: +this.getMarkerSize(),
		color:'#fff',
                opacity: 0.8,
                line: {
		    color: 'blue',
                    width: 2
                },
            };

            let colorBy = this.getColorByInfo(records);
	    if(colorBy.isEnabled()) {
		let dataColumn = this.getColumnValues(records, colorBy.getField());
		//Map the values into a standard 0...1 range
		marker.line.color = Utils.normalize(dataColumn.values);		    
		let scale = [];
		let colors = colorBy.getColors();
		colors.forEach((c,idx)=>{
		    scale.push([idx/colors.length,c]);
		});
		scale.push([1,scale[scale.length-1][1]]);
		marker.line.colorscale=scale;
		marker.colorscale=scale;
	    }

            this.trace1 = {
		name:colorBy.isEnabled()?colorBy.getField().getLabel():"",
                x: x.values,
                y: y.values,
                z: z.values,
                mode: 'markers',
		marker:marker,
                type: this.get3DType()
            };

	    let gridColor = this.getAxisLineColor();
            let layout = {
                scene: {
                    xaxis: {
                        backgroundcolor: this.getXaxisBackground(),
                        gridcolor: gridColor,
                        showbackground: true,
                        zerolinecolor: gridColor,
                        title: this.xField.getLabel(),
                    },
                    yaxis: {
                        backgroundcolor: this.getYaxisBackground(),
                        gridcolor: gridColor,
                        showbackground: true,
                        zerolinecolor: gridColor,
                        title: this.yField.getLabel(),
                    },
                    zaxis: {
                        backgroundcolor: this.getZaxisBackground(),
                        gridcolor: gridColor,
                        showbackground: true,
                        zerolinecolor: gridColor,
                        title: this.zField.getLabel(),
                    }
                },
                margin: {
                    l: 0,
                    r: 0,
                    b:0,
                    t:0,
                    pad: 4
                },
		legend: {
		    yanchor:"top", y:1,   xanchor: 'center', x: 0.5, orientation: 'h' 
		},
		paper_bgcolor: this.getChartBackground()
            };
            this.setDimensions(layout, 2);
	    layout.showLegend=false;
            let trace2 = {
		name:'Selected',
		showLegend:false,
                mode: 'markers',
                type: this.get3DType(),
                x: [],
                y: [],
                z: [],
		marker:{
                    size: this.getMarkerSize()+6,
		    color:'red',
                    opacity: 0.8,
                    line: {
			color: 'red',
			width: 2
                    },
		},
            };


            let plotData = [this.trace1,trace2];
	    this.makePlot(plotData, layout);
	    if(colorBy.isEnabled()) {
		colorBy.displayColorTable();
	    }

        },
        initPlot: function(plot, myPlot) {
	    SUPER.initPlot.call(this, plot, myPlot);
	    myPlot.on('plotly_click', (data)=>{
		if(data.points && data.points.length) {
		    let record = this.records[data.points[0].pointNumber];
		    if(record) {
			this.propagateEventRecordSelection({record: record});
		    }
		}
	    });
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    let record = args.record;
	    if(!record) return;
            let x = this.xField.getValue(record);
            let y = this.yField.getValue(record);
            let z = this.zField.getValue(record);	    	    
	    let update = {'x': [[x]], 'y': [[y]],'z':[[z]]};
	    Plotly.update(this.domId(ID_PLOT), update, {}, [1]);
	}
    });
}


function Ramadda3dmeshDisplay(displayManager, id, properties) {
    let SUPER;
    $.extend(this, {
        width: "100%",
        height: "100%",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotly3DDisplay(displayManager, id, DISPLAY_PLOTLY_3DMESH, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        get3DType: function() {
            return 'mesh3d';
        },
    });
}



function Ramadda3dscatterDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "100%",
        height: "100%",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotly3DDisplay(displayManager, id, DISPLAY_PLOTLY_3DSCATTER, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        get3DType: function() {
            return 'scatter3d';
        },
    });
}



function RamaddaSunburstDisplay(displayManager, id, properties) {
    $.extend(this, {
        width: "500",
        height: "500",
    });
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_SUNBURST, properties);
    let myProps = [
	{label:'Sunburst Display'},
	{p:'parentField',ex:''},
	{p:'labelField',ex:''},
	{p:'idField',ex:''},
	{p:'valueField',ex:''},
	{p:'nodeFields',ex:''},
	{p:'treeRoot',ex:'some label'},
	{p:'doTopColors',ex:'true'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDisplayStyle: function() {
            return "";
        },
        updateUIInner: function() {
            var records = this.filterData();
            if (!records) return;
            var parentField = this.getFieldById(null, this.getProperty("parentField"));
	    var valueField = this.getFieldById(null, this.getProperty("valueField"));
	    var labelField = this.getFieldById(null, this.getProperty("labelField"));
	    let roots=null;
	    try {
		roots = this.makeTree();
	    } catch(error) {
                this.setContents(this.getMessage(error.toString()));
		return;
	    }

	    let ids = [];
	    let labels = [];
	    let parentNodes= [];

	    let parents = [];
	    let values=[];
	    //descend and calculate values
	    let calcValue = function(node) {
		if(node.children.length==0) {
		    if(node.record) {
			var value = node.record.getValue(valueField.getIndex());
			node.value = value;
			return value;
		    }
		    return 0;
		}
		let sum = 0;
		node.children.map(child=>{
		    sum += calcValue(child);
		});
		node.value = sum;
		if(node.record){
		    node.record.setValue(valueField.getIndex(),sum);
		}
		return sum;
	    }
	    if(valueField) {
		roots.map(calcValue);
	    }
	    this.myRecords = [];
	    let recordList =  this.myRecords;
	    let makeList = function(node) {
		recordList.push(node.record);
		if(valueField)
		    values.push(node.value);
		parentNodes.push(node.parent);
		ids.push(node.id);
		labels.push(node.label);
		parents.push(node.parent==null?"":node.parent.id);
		node.children.map(makeList);
	    }
	    roots.map(makeList);
            var colors = this.getColorTable(true);
	    let doTopColors= this.getProperty("doTopColors",true);
	    if(!colors) {
		var colorMap = Utils.parseMap(this.getProperty("colorMap"));
		if(colorMap) {
		    colors = [];
		    let dfltIdx =0;
		    let dflt = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
		    ids.map((id,idx)=>{
			if(doTopColors && parentNodes[idx]!=null)  return;
			let color = colorMap[id];
			if(!color) {
			    color = colorMap[labels[idx]];
			}
			if(!color) {
			    if(dfltIdx>=dflt.length) dfltIdx = 0;
			    color = dflt[dfltIdx];
			    dfltIdx++;
			}
			colors.push(color);
		    });
		}
	    }

	    var data = [{
		type: "sunburst",
		ids:ids,
		labels: labels,
		parents: parents,
		outsidetextfont: {size: 20, color: "#377eb8"},
		leaf: {opacity: 0.4},
		marker: {
		    line: {width: 1}
		},
		branchvalues: 'total'
	    }];
	    if(valueField) {
		data[0].values = values;
	    }
	    var layout = {
		margin: {l: 0, r: 0, b: 0, t: 0},
		width: +this.getProperty("width"),
		height: +this.getProperty("height"),
	    };
	    if(colors) {
		if(!doTopColors) {
		    data[0].marker.colors = colors;
		} else {
		    layout.sunburstcolorway= colors;
		    layout.extendsunburstcolors= true;
		    layout.extendsunburstcolorway= true;
		}
	    }

	    this.makePlot(data, layout);
        },
        initPlot: function(plot, myPlot) {
	    SUPER.initPlot.call(this, plot, myPlot);
	    myPlot.on('plotly_sunburstclick', d=>{this.handleSunburstClickEvent(d)});
	},
        handleSunburstClickEvent: function(data) {
	    if(!data.points || data.points.length<=0) {
		return;
	    }
	    var pointNumber = data.points[0].pointNumber;
	    var record = this.myRecords[pointNumber];
	    //	    console.log(pointNumber +" " + record);
	    if(record) {
		this.propagateEventRecordSelection({record: record});
	    }
	},

    });
}



function RamaddaTernaryDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TERNARY, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUIInner: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var stringField = this.getFieldByType(fields, "string");
            var fields = this.getFieldsByType(fields, "numeric");
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length < 3) {
                this.displayError("Don't have 3 numeric fields specified");
                return;
            }

            var rawData = [];
            var a = this.getColumnValues(records, fields[0]);
            var b = this.getColumnValues(records, fields[1]);
            var c = this.getColumnValues(records, fields[2]);
            for (var i = 0; i < a.length; i++) {
                rawData.push({
                    a: 100 * a[i] / a.max,
                    b: 100 * b[i] / b.max,
                    c: 100 * c[i] / c.max,

                    label: stringField ? stringField.getLabel() : "Point " + (i + 1)
                });
            }
            var xrawData = [{
                a: 75,
                b: 25,
                c: 0,
                label: 'point 1'
            }, {
                a: 70,
                b: 10,
                c: 20,
                label: 'point 2'
            }, {
                a: 75,
                b: 20,
                c: 5,
                label: 'point 3'
            }, {
                a: 5,
                b: 60,
                c: 35,
                label: 'point 4'
            }, {
                a: 10,
                b: 80,
                c: 10,
                label: 'point 5'
            }, {
                a: 10,
                b: 90,
                c: 0,
                label: 'point 6'
            }, {
                a: 20,
                b: 70,
                c: 10,
                label: 'point 7'
            }, {
                a: 10,
                b: 20,
                c: 70,
                label: 'point 8'
            }, {
                a: 15,
                b: 5,
                c: 80,
                label: 'point 9'
            }, {
                a: 10,
                b: 10,
                c: 80,
                label: 'point 10'
            }, {
                a: 20,
                b: 10,
                c: 70,
                label: 'point 11'
            }, ];


            var plotData = [{
                type: 'scatterternary',
                mode: 'markers',
                a: rawData.map(function(d) {
                    return d.a;
                }),
                b: rawData.map(function(d) {
                    return d.b;
                }),
                c: rawData.map(function(d) {
                    return d.c;
                }),
                text: rawData.map(function(d) {
                    return d.label;
                }),
                marker: {
                    symbol: 100,
                    color: '#DB7365',
                    size: 14,
                    line: {
                        width: 2
                    }
                },
            }];
            var layout = {
                ternary: {
                    sum: 100,
                    aaxis: this.makeAxis(fields[0].getLabel(), 0),
                    baxis: this.makeAxis(fields[1].getLabel(), 45),
                    caxis: this.makeAxis(fields[2].getLabel(), -45),
                    bgcolor: '#fff1e0'
                },
                annotations: [{
                    showarrow: false,
                    text: this.getProperty("chartTitle", ""),
                    x: 1.0,
                    y: 1.3,
                    font: {
                        size: 15
                    }
                }],
                paper_bgcolor: '#fff1e0',
            };


            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}


function RamaddaDotplotDisplay(displayManager, id, properties) {

    $.extend(this, {
        width: "600px",
        height: "400px",
    });


    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_DOTPLOT, properties);
    let myProps = [
	{label:'Dotplot Display'},
	{p:'fields',ex:''},
	{p:'labelField',ex:''},
	{p:'lineColor',d:'rgba(156, 165, 196, 1.0)'},
	{p:'symbol',d:'circle',ex:'circle|circle-open|circle-dot|circle-open-dot|square|square-open|square-dot|square-open-dot|diamond|diamond-open|diamond-dot|diamond-open-dot|cross|cross-open|cross-dot|cross-open-dot|x|x-open|x-dot|x-open-dot|triangle-up|triangle-up-open|triangle-up-dot|triangle-up-open-dot|triangle-down|triangle-down-open|triangle-down-dot|triangle-down-open-dot|triangle-left|triangle-left-open|triangle-left-dot|triangle-left-open-dot|triangle-right|triangle-right-open|triangle-right-dot|triangle-right-open-dot|triangle-ne|triangle-ne-open|triangle-ne-dot|triangle-ne-open-dot|triangle-se|triangle-se-open|triangle-se-dot|triangle-se-open-dot|triangle-sw|triangle-sw-open|triangle-sw-dot|triangle-sw-open-dot|triangle-nw|triangle-nw-open|triangle-nw-dot|triangle-nw-open-dot|pentagon|pentagon-open|pentagon-dot|pentagon-open-dot|hexagon|hexagon-open|hexagon-dot|hexagon-open-dot|hexagon2|hexagon2-open|hexagon2-dot|hexagon2-open-dot|octagon|octagon-open|octagon-dot|octagon-open-dot|star|star-open|star-dot|star-open-dot|hexagram|hexagram-open|hexagram-dot|hexagram-open-dot|star-triangle-up|star-triangle-up-open|star-triangle-up-dot|star-triangle-up-open-dot|star-triangle-down|star-triangle-down-open|star-triangle-down-dot|star-triangle-down-open-dot|star-square|star-square-open|star-square-dot|star-square-open-dot|star-diamond|star-diamond-open|star-diamond-dot|star-diamond-open-dot|diamond-tall|diamond-tall-open|diamond-tall-dot|diamond-tall-open-dot|diamond-wide|diamond-wide-open|diamond-wide-dot|diamond-wide-open-dot|hourglass|hourglass-open|bowtie|bowtie-open|circle-cross|circle-cross-open|circle-x|circle-x-open|square-cross|square-cross-open|square-x|square-x-open|diamond-cross|diamond-cross-open|diamond-x|diamond-x-open|cross-thin|cross-thin-open|x-thin|x-thin-open|asterisk|asterisk-open|hash|hash-open|hash-dot|hash-open-dot|y-up|y-up-open|y-down|y-down-open|y-left|y-left-open|y-right|y-right-open|line-ew|line-ew-open|line-ns|line-ns-open|line-ne|line-ne-open|line-nw|line-nw-open|arrow-up|arrow-up-open|arrow-down|arrow-down-open|arrow-left|arrow-left-open|arrow-right|arrow-right-open|arrow-bar-up|arrow-bar-up-open|arrow-bar-down|arrow-bar-down-open|arrow-bar-left|arrow-bar-left-open|arrow-bar-right|arrow-bar-right-open|arrow|arrow-open|arrow-wide|arrow-wide-open'},
	{p:'dotSize',d:16},
	{p:'&lt;field&gt;.dotSize',ex:16},	
        {p:"yAxisTitle"},
	{p:"yAxisType",ex:'log'},
	{p:"yAxisShowLine",d:true},
	{p:"yAxisShowGrid",d:false},
	{p:"xAxisTitle"},
	{p:"xAxisType",ex:'log'},
	{p:"xAxisShowGrid",d:false},
	{p:"xAxisShowLine",d:true},
	{p:"marginLeft",d:140},
	{p:"marginRight",d:40},
	{p:"marginBottom",d:50},
	{p:"marginTop",d:20},
	{p:"chartFill"},
	{p:"chartAreaFill"},
	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDisplayStyle: function() {
            return "";
        },

        updateUIInner: function() {
//https://codepen.io/etpinard/pen/LLZGZV
	    /*
	    let sym = Plotly.PlotSchema.get().traces.scatter.attributes.marker.symbol.values.filter(s => typeof s === 'string' && !s.match(/^[0-9]+$/))
	    let list='';
	    sym.forEach(s=>{list+=s+','});
	    console.log(list);
	    */



            let records = this.filterData();
            if (!records) return;
            var pointData = this.getData();
            if (pointData == null) return;
            let allFields = pointData.getRecordFields();
            let stringField = this.getFieldById(allFields,this.getLabelField());
            if (!stringField) {
		stringField = this.getFieldByType(allFields, "string");
	    }

            if (!stringField) {
                stringField = allFields[0];
            }

	    let fields   = this.getFieldsByIds(null, this.getPropertyFields("",true));
            if (fields.length == 0) {
		fields = this.getFieldsByType(allFields, "numeric");
	    }
            if (fields.length == 0) {
		fields = this.getFieldsByType(allFields, "date");
	    }
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }

            let labels = null;
            let labelName = "";
            if (stringField) {
                labels = this.getColumnValues(records, stringField).values;
                labelName = stringField.getLabel();
            }
            var colors = this.getColorTable(true);
            if (!colors)
                colors = ['rgba(156, 165, 196, 0.95)', 'rgba(204,204,204,0.95)', 'rgba(255,255,255,0.85)', 'rgba(150,150,150,0.95)']
            var plotData = [];
            var colorBy = this.getColorByInfo(records);
	    var  didColorBy = false;
            for (i in fields) {
                let field = fields[i];
                let size = this.getDotSize(this.getProperty(field.getId()+'.dotSize'));
                let symbol = this.getSymbol(this.getProperty(field.getId()+'.symbol'));
                let lineColor = this.getLineColor(this.getProperty(field.getId()+'.lineColor'));
                let color = this.getProperty(field.getId()+'.color');
		if(!color)color= i >= colors.length ? colors[0] : colors[i];
                let values = this.getColumnValues(records, field).values;
		let tooltips = null;
		let hoverTemplate=null;
		let template = this.getTooltip(null);
		if(template) {
		    let ttf = this.getTooltipFields();
		    if(!ttf)
			ttf = this.getFields();
		    hoverTemplate = '%{text}<extra></extra>';
		    tooltips = records.map((record,idx)=>{
			let html = '';
			ttf.forEach(field=>{
			    html+='<b>' + field.getLabel()+': </b>' +
				field.getValue(record)+'<br>';
			});
			return  html;
		    });
		}
                if (colorBy.index >= 0) {
		    color = [];
		    records.map(record=>{
			var value = record.getData()[colorBy.index];
			didColorBy = true;
			color.push(colorBy.getColor(value, record));
                    })
		}
                if (!labels) {
                    labels = [];
                    for (var j = 0; j < values.length; j++) {
                        labels.push("Point " + (j + 1));
                    }
                }

                plotData.push({
                    type: 'scatter',
                    x: values,
                    y: labels,
                    mode: 'markers',
                    name: field.getLabel(),
		    text:tooltips,
		    hovertemplate: hoverTemplate,
                    marker: {
                        color: color,
                        line: {
                            color: lineColor,
                            width: 1,
                        },
                        symbol: symbol,
                        size: size
                    }
                });
            }
	    

            let layout = this.makeLayout({
                yaxis: {
                    title: this.getYAxisTitle(labelName),
		    type:this.getYAxisType(),
                    showline: this.getYAxisShowLine(),
                    showgrid: this.getYAxisShowGrid(),
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)',
                        }
                    },
                },
                xaxis: {
                    title: this.getXAxisTitle(fields[i].getLabel()),
		    type:this.getXAxisType(),
                    showgrid: this.getXAxisShowGrid(false),
                    showline: this.getXAxisShowLine(true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
                },
                margin: {
                    l: this.getMarginLeft(),
                    r: this.getMarginRight(40),
                    b: this.getMarginBottom(),
                    t: this.getMarginTop(),
                },
                legend: {
                    font: {
                        size: 10,
                    },
                    yanchor: 'middle',
                    xanchor: 'right'
                },
                paper_bgcolor: this.getChartFill(this.getProperty("chart.fill",'rgb(254, 247, 234)')),
                plot_bgcolor: this.getChartAreaFill(this.getProperty("chartArea.fill", 'rgb(254, 247, 234)')),
                hovermode: 'closest'
            });
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
	    if(didColorBy) {
		colorBy.displayColorTable();
	    }

        },
    });
}


function RamaddaProfileDisplay(displayManager, id, properties) {
//    if(!properties.width) properties.width="400px";
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_PROFILE, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    this.defineProperties([
	{label:'Profile Properties'},
	{p:'indexField',d:null,ex:''},
	{p:'fields',d:null,ex:''},
	{p:'profileMode',d:'lines',ex:'lines|markers|lines+markers'},
	{p:'yAxisTitle',d:'Pressure- Digiquartz',ex:''},
	{p:'yAxisShowLine',d:'true',ex:'false'},
	{p:'yAxisShowGrid',d:'true',ex:'false'},
	{p:'xAxisTitle',d:'',ex:''},
	{p:'xAxisShowGrid',d:'true',ex:'false'},
	{p:'xAxisShowLine',d:'true',ex:'false'},
	{p:'yAxisReverse',d:false,ex:'true'},
	{p:'setRangeFromAllValues',ex:true},
	{p:'marginLeft',d:'60',ex:'60'},
	{p:'marginRight',d:'100',ex:'100'},
	{p:'marginBottom',d:'50',ex:'50'},
	{p:'marginTop',d:'100',ex:'100'},
	{p:'showLegend',d:'true',ex:'false'},
	{p:'legendYAnchor',d:null,ex:'top|middle|bottom'},
	{p:'legendXAnchor',d:null,ex:'right|center|left'},
	{p:'chart.fill',d:'rgb(254, 247, 234)',ex:'color'},
	{p:'chartArea.fill',d:'rgb(254, 247, 234)',ex:'color'},
	{p:'xAxis2Title',d:'Conductivity',ex:''},
	{p:'lineColor',d:'blue'},
	{p:'lineWidth',d:1},
	{p:'markerLineColor',d:'rgba(0,0,0,0.2)'},
	{p:'markerLineWidth',d:1},
	{p:'markerSize',d:16},
	{p:'symbol',d:'circle',ex:'circle|square|diamond|cross|x|triangle-up|triangle-down|pentagon|hexagon|hexagram|star|hash'},
	{p:'yAxisReverse',ex:true},
        {p:'yAxisTitle'},
	{p:'yAxisShowLine', ex:true},
	{p:'yAxisShowGrid', ex:true},
        {p:'xAxisTitle'},
        {p:'xAxisShowGrid', ex:true},
        {p:'xAxisShowLine', ex:true},
    ]);

    RamaddaUtil.defineMembers(this, {
        getDisplayStyle: function() {
            return "";
        },
	showFieldsInDialog: function() {
	    return true;
	},
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) return;
//	    this.writePropertyDef = "";
	    let indexField = this.getFieldById(null,this.getIndexField());
	    if(indexField==null) {
                this.setContents(this.getMessage("No indexField specified"));
		return;
	    }
            let fields = this.getSelectedFields(this.getData().getRecordFields());


            if (fields.length == 0) {
		let tmp = this.getFieldsByType(null, "numeric");
		if(tmp.length>0) fields.push(tmp[0]);
	    }

            if (fields.length == 0) {
                this.setContents(this.getMessage("No fields found"));
		return;
	    }
            let index = this.getColumnValues(records, indexField).values;
            let data = [];
	    let range;
	    if(this.getSetRangeFromAllValues()) {
		let allRecords = this.getData().getRecords();
		let min,max;
		allRecords.forEach((r,idx)=>{
		    let v = fields[0].getValue(r);
		    if(idx==0 || v<min) min=v;
		    if(idx==0 || v>max) max=v;		    
		});
		range=[min,max]
	    }

  
	    let minX=NaN;
	    let maxX= NaN;
            fields.forEach((field,idx)=>{
		let values= this.getColumnValues(records, field);
		minX = Utils.min(values.min,minX)
		maxX = Utils.max(values.max,maxX);	
		let x = values.values;
		if(fields.length==1) {
		    let oldIndex = this.indexToRecord;
		    this.indexToRecord={};
		    let nindex=[];
		    let nx=[];
		    x.forEach((v,idx)=>{
			if(!isNaN(v)) {
			    this.indexToRecord[nindex.length] = oldIndex[idx];
			    nindex.push(index[idx]);
			    nx.push(v);
			}
		    });
		    index=nindex;
		    x =nx;
		}

		let colors=null;
		let colorTable = this.getProperty(field.getId()+'.colorTable',  this.getProperty('colorTable'));
		if(colorTable) {
                    let ct = Utils.ColorTables[colorTable];
		    if(ct) {
			let colorByInfo = new  ColorByInfo(this, fields, records, null,null,ct.colors, null, field);
			colors =[];
			records.forEach(r=>{
			    let c = colorByInfo.getColorFromRecord(r);
			    colors.push(c);
			});
		    }			
		}

		let trace =   {
		    y: index,
		    x: x,
		    type: 'scatter',
		    mode: this.getProfileMode(),
                    name: field.getUnitLabel(),
		    line: {
                        color: this.getProperty("lineColor"+(idx+1)),
                        width: this.getLineWidth(),
		    },
                    marker: {
			color:colors,
                        line: {
                            color: this.getMarkerLineColor(),
                            width: this.getMarkerLineWidth(),
                        },
                        symbol: this.getProperty('symbol'+ (idx+1),this.getSymbol()),
                        size: this.getMarkerSize()
                    }
		};
		if(idx>0)
		    trace.xaxis="x2";
		data.push(trace);
	    });



	    let labelName = indexField.getLabel();
            let layout = {
                yaxis: {
		    autorange: this.getYAxisReverse()?"reversed":null,
                    title: this.getYAxisTitle(labelName),
                    showline: this.getYAxisShowLine(true),
                    showgrid: this.getYAxisShowGrid(true),
                },
                xaxis: {
		    range: range,
                    title: this.getXAxisTitle(fields[0].getUnitLabel()),
                    showgrid: this.getXAxisShowGrid(true),
                    showline: this.getXAxisShowLine(true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
		},
                margin: {
                    l: +this.getMarginLeft(60),
                    r: +this.getMarginRight(100),
                    b: +this.getMarginBottom(50),
                    t: +this.getMarginTop(100),
                },
                legend: {
                    font: {
                        size: 10,
                    },
                    yanchor: this.getLegendYAnchor(),
                    xanchor: this.getLegendXAnchor(),
                },
                showlegend: this.getShowLegend(true),
		paper_bgcolor: this.getProperty("chart.fill", 'transparent'),		
//                plot_bgcolor: this.getProperty("chartArea.fill", 'rgb(254, 247, 234)'),
                plot_bgcolor: this.getProperty("chartArea.fill", '#fff'),				
                hovermode: 'closest'
            };
	    if(fields.length>1) {
                layout.xaxis2 =  {
		    overlaying: 'x', 
		    side: 'top',
                    title: this.getProperty("xAxis2Title", fields[1].getLabel()),
                    showgrid: this.getProperty("xAxisShowGrid", true),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
                };
	    }

	    if(this.annotations) {
		let shapes= layout.shapes = [];
		this.annotations.forEach(v=>{
		    shapes.push({
			type: 'line',
			x0: minX,
			x1: maxX,      
			y0: v,      
			y1: v,     
			line: {
			    color: 'red',
			    width: 2,
			    dash: 'solid', 
			}
		    });
		});
	    }

            this.setDimensions(layout, 2);
            this.makePlot(data, layout);
	    if(this.writePropertyDef)
		console.log(this.writePropertyDef);
	    this.writePropertyDef=null;
        },
	addAnnotation: function (v) {
	    this.annotations = [v];
	    this.updateUI(true);
	},
	clearAnnotations: function () {
	    this.annotations=null;
	    this.updateUI(true);
	}	
    });
}



function RamaddaSplomDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "600px",
        height: "600px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_SPLOM, properties));

    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        setDimensions: function(layout, widthDelta) {
            var width = parseInt(this.getProperty("width", "400").replace("px", "").replace("%", ""));
            var height = parseInt(this.getProperty("height", "400").replace("px", "").replace("%", ""));
            layout.width = width - widthDelta;
            layout.height = height;
        },
        makeAxis: function() {
            return {
                showline: false,
                zeroline: false,
                gridcolor: this.getProperty("gridColor", "white"),
                ticklen: 2,
                tickfont: {
                    size: this.getProperty("tickFontSize", 12)
                },
                titlefont: {
                    size: this.getProperty("titleFontSize", 12)
                }
            }
        },
        updateUIInner: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            if (fields.length == 0) {
                fields = this.getData().getRecordFields();
            }
            var labels;
            if (this.getProperty("labels"))
                labels = this.getProperty("labels").split(",");

            var dataObj = {
                type: 'splom',
                dimensions: [],
                marker: {
                    size: parseInt(this.getProperty("markerSize", 5)),
                    line: {
                        color: this.getProperty("lineColor", 'white'),
                        width: 0.5
                    }
                }
            };


            var colorByField = this.getFieldById(fields, this.getProperty("colorBy"));
            var colorBy = this.getProperty("colorBy");
            if (colorBy) {
                var colorByField = this.getFieldById(fields, colorBy);
                if (colorByField) {
                    var obj = this.getColumnValues(records, colorByField);
                    var colors = this.getColorTable();
                    if (!colors) colors = Utils.getColorTable("blue_white_red");
                    var colorscale = [];
                    var min = parseFloat(this.getProperty("colorByMin", obj.min));
                    var max = parseFloat(this.getProperty("colorByMax", obj.max));
                    if (Utils.isDefined(colors.min)) {
                        var clippedColors = [];
                        for (var i = 0; i < colors.colors.length; i++) {
                            var percent = i / colors.colors.length;
                            var value = colors.min + (colors.max - colors.min) * percent;
                            if (value >= min && value <= max)
                                clippedColors.push(colors.colors[i]);
                        }
                        colors = clippedColors;
                    }
                    if (colors.colors) colors = colors.colors;
                    var range = max - min;
                    var colorValues = [];
                    for (var i = 0; i < obj.values.length; i++) {
                        var value = obj.values[i];
                        var percent = (value - min) / range;
                        colorValues.push(percent);
                    }
                    for (var i = 0; i < colors.length; i++) {
                        var value = i / colors.length;
                        var next = (i + 1) / colors.length;
                        colorscale.push([value, colors[i]]);
                        colorscale.push([next, colors[i]]);
                    }
                    dataObj.marker.color = colorValues;
                    dataObj.marker.colorscale = colorscale;
                }

                this.displayColorTable(colors, ID_DISPLAY_BOTTOM, min, max);
            }

            var stringField = this.getFieldByType(fields, "string");
            if (stringField) {
                var l = this.getColumnValues(records, stringField).values;
                dataObj.text = [];
                for (var i = 0; i < l.length; i++)
                    dataObj.text.push(stringField.getLabel() + ": " + l[i]);
            }

            var plotData = [dataObj];
            var layout = {
                autosize: false,
                hovermode: 'closest',
                dragmode: 'select',
                plot_bgcolor: this.getProperty("bgColor", 'rgba(240,240,240, 0.95)'),
                margin: {
                    l: this.getProperty("marginLeft", 140),
                    r: this.getProperty("marginRight", 40),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 20),
                },
            }

            var cnt = 0;
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (!field.isFieldNumeric()) continue;
                var values = this.getColumnValues(records, field).values;
                var label;
                if (labels && i < labels.length)
                    label = labels[i];
                else
                    label = field.getUnitLabel();
                dataObj.dimensions.push({
                    label: label,
                    values: values
                });
                var key = "axis" + (cnt == 0 ? "" : "" + (cnt + 1));
                layout["x" + key] = this.makeAxis();
                layout["y" + key] = this.makeAxis();
                cnt++;
            }
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}



function RamaddaPTreemapDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TREEMAP, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUIInner: function() {
            var records = this.filterData();
            if (!records) return;
            var selectedFields = this.getSelectedFields(this.getData().getRecordFields());
            var field = this.getFieldByType(selectedFields, "numeric");
            if (!field) {
                this.displayError("No numeric field specified");
                return;
            }
            var values = this.getColumnValues(records, field).values;
            // declaring arrays
            var shapes = [];
            var annotations = [];
            var counter = 0;

            // For Hover Text
            var x_trace = [];
            var y_trace = [];
            var text = [];

            //colors
            var colors = this.getColorTable();
            if (colors.colors) colors = colors.colors;

            // Generate Rectangles using Treemap-Squared
            var rectangles = Treemap.generate(values, 100, 100);

            for (var i in rectangles) {
                var shape = {
                    type: 'rect',
                    x0: rectangles[i][0],
                    y0: rectangles[i][1],
                    x1: rectangles[i][2],
                    y1: rectangles[i][3],
                    line: {
                        width: 2
                    },
                    fillcolor: colors[counter]
                };
                shapes.push(shape);
                var annotation = {
                    x: (rectangles[i][0] + rectangles[i][2]) / 2,
                    y: (rectangles[i][1] + rectangles[i][3]) / 2,
                    text: String(values[counter]),
                    showarrow: false
                };
                annotations.push(annotation);

                // For Hover Text
                x_trace.push((rectangles[i][0] + rectangles[i][2]) / 2);
                y_trace.push((rectangles[i][1] + rectangles[i][3]) / 2);
                text.push(String(values[counter]));

                // Incrementing Counter
                counter++;
            }

            // Generating Trace for Hover Text
            var trace0 = {
                x: x_trace,
                y: y_trace,
                text: text,
                mode: 'text',
                type: 'scatter'
            };

            var layout = {
                height: 700,
                width: 700,
                shapes: shapes,
                hovermode: 'closest',
                annotations: annotations,
                xaxis: {
                    showgrid: false,
                    zeroline: false
                },
                yaxis: {
                    showgrid: false,
                    zeroline: false
                }
            };

            var data = {
                data: [trace0]
            };
            this.setDimensions(layout, 2);
            this.makePlot([trace0], layout);
        },
    });





}
function TextcountDisplay(displayManager, id, properties) {
    let SUPER  =  new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TEXTCOUNT, properties);
    let myProps = [
	{label:'Text Count Display'},
	{p:'patterns',ex:'foo,bar'},
	{p:'labels',ex:'Foo,Bar'},
	{p:'textField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDialogContents: function(tabTitles, tabContents) {
	    let html = HtmlUtils.div([ATTR_ID,this.getDomId("dialog_set_pattern")],"Change patterns") + "<br>" +
		HtmlUtils.textarea("",Utils.join(this.patternList||[],"\n"),[ATTR_ID, this.getDomId("dialog_patterns"),"rows","10"]);

	    
            tabTitles.push("Patterns");
            tabContents.push(html);
            SUPER.getDisplayDialogContents.call(this, tabTitles, tabContents);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
	    let _this = this;
            this.jq("dialog_set_pattern").button().click(function() {
		_this.patterns = _this.jq("dialog_patterns").val().trim().replace(/\n/g,",");
		_this.updateUI();
            });

        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) return;
	    let patterns = this.getProperty("patterns");
	    if(patterns == null) {
		this.setContents(this.getMessage("No patterns specified"));
		return;
	    }
	    this.patternList = patterns.split(",");
	    let labels = this.getProperty("labels");
	    if(labels) {
		labels = labels.split(",");
	    }

	    this.textField = this.getFieldById(null, this.getProperty("textField"));
	    if(!this.textField) {
		this.textField = this.getFieldByType(null, "string");
	    }
	    if(!this.textField) {
		this.setContents(this.getMessage("No text field in data"));
		return;
	    }

	    let count = [];
	    let matchers = [];
	    this.patternList.map(p=>{
		count.push(0);
		matchers.push(new TextMatcher(p));
	    });

            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var record = records[rowIdx];
                var row = record.getData();
		var value = record.getValue(this.textField.getIndex());
		matchers.map((m,index)=>{
		    if(m.matches(value)) {
			count[index]++;
		    }
		});
	    }

	    let data = [{
		type: 'bar',
		x: count,
		y: labels?labels:this.patternList,
		orientation: 'h',
	    }];
	    let layout = {
		margin: {
		    l: 100,
		    r: 50,
		    b: 50,
		    t: 10,
		    padding:4
		},
	    };
	    if(Utils.isDefined(this.properties.height)) {
		layout.height = +this.properties.height;
	    }

            this.makePlot(data, layout);
        },
        handleClickEvent: function(data) {
	    if(!data.points || data.points.length<=0) {
		return;
	    }
	    let pointNumber = data.points[0].pointNumber;
	    let pattern = this.patternList[pointNumber];
	    let args = {
		fieldId: this.textField.getId(),
		value: pattern
	    };

	    this.propagateEvent(DisplayEvent.filterChanged, args);
	},

    });
}



function CombochartDisplay(displayManager, id, properties) {
    let SUPER  =  new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_COMBOCHART, properties);
    let myProps = [
	{label:'Combo Chart'},
	{p:'fields',ex:''},
 	{p:'&lt;field&gt;.axisSide',ex:'right|left'},
	{p:'&lt;field&gt;.axisTitle',ex:''},
	{p:'&lt;field&gt;.chartType',ex:'scatter|bar'},
	{p:'chartType',ex:'scatter|bar'},
	{p:'&lt;field&gt;.chartColor',ex:''},
	{p:'chartType',ex:''},
	{p:'xAxisTitle',ex:''},
	{p:'xAxisShowGrid',ex:''},
	{p:'xAxisShowLine',ex:''},
	{p:'legendBackground',ex:''},
	{p:'legendBorder',ex:''},
	{p:'chartBackground',ex:'#ccc'},
	{p:'plotBackground',ex:''},
	{p:'marginLeft',ex:''},
	{p:'marginRight',ex:''},
	{p:'marginBottom',ex:''},
	{p:'marginTop',ex:''},
	{p:'chartPad',ex:''},
    ];	
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUIInner: function() {
            let records = this.filterData();
            if (!records) return;
	    var layout = {
                xaxis: {
                    title: this.getProperty("xAxisTitle", "Time"),
                    showgrid: this.getProperty("xAxisShowGrid", false),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)',
		  
		},
                legend: {
                    font: {
                        size: 10,
                    },
		    bgcolor: this.getProperty("legendBackground",'rgba(255,255,255,0)'),
		    bordercolor: this.getProperty("legendBorder",'rgba(255,255,255,0)'),
		    x: 0,
		    y: 1.0,

                },
		margin: {
                    l: this.getProperty("marginLeft", 50),
                    r: this.getProperty("marginRight", 50),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 0),
		    pad: this.getProperty("chartPad", 4),
		},
		paper_bgcolor: this.getProperty("chartBackground", 'rgb(255,255,255,0)'),
		plot_bgcolor: this.getProperty("plottBackground", 'rgb(255,255,255,0)'),
	    };
	    let fields   = this.getFieldsByIds(null, this.getPropertyFields("",true));
	    var data = [];
	    var domain = [];
	    records.map((r,idx)=>{
		domain.push(r.getTime());
	    });
	    let right =  true;
	    fields.map((field,idx)=>{
		let values = this.getColumnValues(records, field).values;
		var trace = {
		    x: domain,
		    y: values,
		    name: field.getLabel(),
		    type: this.getProperty(field.getId()+".chartType",this.getProperty("chartType",'scatter')),
		    marker: {color: this.getProperty(field.getId()+".chartColor",this.getProperty("chartColor"))},
		};
		if(idx>0) {
		    trace.yaxis = "y" + (idx+1);
		}
		data.push(trace);
		var yAxisId = idx>0?"yaxis"+(idx+1):"yaxis";
		var axis = {
		    title: this.getProperty(field.getId()+".axisTitle" ,field.getLabel()), 
		    titlefont: {color: 'rgb(0,0,0)'},
		    tickfont: {color: 'rgb(0,0,0,)'},
		    side: this.getProperty(field.getId()+".axisSide",
					   this.getProperty("axisSide", right?'right':'left'))
		};
		if(idx>0)
		    axis.overlaying='y';
		layout[yAxisId] = axis;
		right = !right;
	    });
            this.setDimensions(layout);
            this.makePlot(data, layout);
	}
    });
}





function RamaddaParcoordsDisplay(displayManager, id, properties) {
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_PARCOORDS, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUIInner: function() {
            var records = this.filterData();
            if (!records) return;
	    let fields   = this.getFieldsByIds(null, this.getPropertyFields(""));
            if (fields.length == 0) {
                this.displayError("No fields specified");
                return;
            }
	    let dimensions =[];
	    let maxLabelLength = this.getProperty("maxLabelLength",200/fields.length);
	    fields.map(f=>{
		let col = this.getColumnValues(records, f)
		let values = col.values;
		let ticktext = null;
		let tickvals = null;
		if(f.isString()) {
		    let tmpValues = [];
		    let seen = {};
		    ticktext =[];
		    tickvals =[];
		    let cnt = 1;
		    values.map(v=>{
			if(!seen[v]) {
			    seen[v] = cnt++;
			    ticktext.push(v);
			    tickvals.push(seen[v]);
			}
			tmpValues.push(seen[v]);
		    });
		    values = tmpValues;
		}

		let label = this.getProperty(f.getId()+".label",f.getLabel());
		if(label.length>maxLabelLength)
		    label = label.substring(0,maxLabelLength-1)+"...";
		let dim  = {
		    label:label,
		    values:values
		};
		if(this.getProperty(f.getId()+".constraintrange")) {
		    dim.constraintrange = this.getProperty(f.getId()+".constraintrange").split(",");
		}
		if(this.getProperty(f.getId()+".tickvals")) {
		    dim.tickvals = this.getProperty(f.getId()+".tickvals").split(",");
		}
		if(this.getProperty(f.getId()+".ticktext")) {
		    dim.ticktext = this.getProperty(f.getId()+".ticktext").split(",");
		} else {
		    dim.ticktext = ticktext;
		    dim.tickvals = tickvals;		    
		}
		dimensions.push(dim);
	    });

	    let color = this.getProperty("color", 'blue');
	    let colorByField = this.getFieldById(null, this.getProperty("colorBy"));
	    let line = {};
	    let ct = null;
	    let ctMin=0,ctMax=0;
            if (colorByField) {
		let colorValues =   this.getColumnValues(records, colorByField);
		ctMin = colorValues.min;
		ctMax = colorValues.max;
		line.color  = colorValues.values;
		ct = this.getColorTable(true,null,null);
		if(ct) {
		    let colors = [];
		    let step   = 1/(ct.length-1);
		    ct.map((c,idx)=>{
			let v = idx*step;
			colors.push([v,c]);
		    });
		    line.colorscale = colors;
		}
	    }

	    var trace = {
		type: 'parcoords',
		line: line,
		dimensions:dimensions,
	    };

	    var data = [trace]	    
	    let layout  = {
		margin: {
		    l:175,
		    t:50,
		    b:25
		}
	    };
	    this.setDimensions(layout, 2);
	    
            this.makePlot(data, layout);
	    if(ct)
		this.displayColorTable(ct, ID_COLORTABLE,ctMin,ctMax);

        },
    });
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


const DISPLAY_THREE_GLOBE = "three_globe";
addGlobalDisplayType({
    type: DISPLAY_THREE_GLOBE,
    forUser: true,
    label: "3D Globe",
    requiresData: true,
    category: CATEGORY_MAPS,
    tooltip: makeDisplayTooltip('3D Globe','3dglobe.png','Create interactive 3D globes'),        
});

const DISPLAY_THREE_GRID = "three_grid";
addGlobalDisplayType({
    type: DISPLAY_THREE_GRID,
    forUser: false,
    label: "3D Grid",
    requiresData: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip('3D Grid',null,'In development'),        
});

var ramaddaLoadedThree=false;
var ramaddaLoadedThreeGlobe=false;

function RamaddaThree_Base(displayManager, id, type,properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    let myProps = [];
    defineDisplay(this, SUPER, myProps, {
	parseInt:function(v,dflt) {
	    if(typeof v == "number") return v;
	    if(!v) return  dflt;
	    if(v.match("rgb")) v = Utils.rgbToHex(v);
	    if(v.startsWith("#")) v = v.substring(1);
	    if(!v.startsWith("0x")) v = '0x' + v;
	    return parseInt(Number(v), 10);
	},
	getScene() {
	    return this.scene;
	},
	getControls() {
	    return this.controls;
	},
    });

}


function RamaddaThree_globeDisplay(displayManager, id, properties) {
    const ID_CONTAINER = "container";
    const ID_GLOBE = "globe";
    const ID_POPUP = "popup";
    const ID_POSITION_BUTTON = "positionbutton";
    const ID_ROTATE_BUTTON = "rotatebutton";            
    if(!properties.width && properties.globeWidth) {
	properties.width = properties.globeWidth;
    }

    let positions = {
"Base":{
position: {x:6.048899205465489e-21,y:1.832130202344028e-20,z:250},
up: {x:1.546799663044268e-22,y:1,z:-7.328520809376114e-23}
},
"North America":{
position: {x:-185.0051316412852,y:166.36750886777244,z:-24.391663730099083},
up: {x:0.6540380289233074,y:0.7458336330441189,z:0.12635841302550785}
},
"South America":{
position: {x:-220.53665870332205,y:-71.90185405284046,z:93.24004264123046},
up: {x:-0.2051500901346411,y:0.9474654144116881,z:0.24540319682399764}
},
"Europe":{
position: {x:76.01040670390248,y:193.37167151814756,z:139.03170403539133},
up: {x:-0.286288586763548,y:0.6309644429890481,z:-0.7210566668247681}
},
"Asia":{
position: {x:215.9418144948879,y:118.22041784669743,z:-43.50937320632211},
up: {x:-0.4872587496088534,y:0.8718613869731202,z:-0.04936226124191964}
},
"Africa":{
position: {x:82.50264441171257,y:6.133419606337622,z:235.91459223415376},
up: {x:-0.005217856566188513,y:0.9996943480371796,z:-0.024165770738191875}
},
"Australia":{
position: {x:166.64046097372514,y:-104.10022198889281,z:-154.57716696953614},
up: {x:0.32825699830271454,y:0.9086541300046129,z:-0.25806009976525474}
},
"Pacific":{
position: {x:-50.02109926067879,y:70.1629622786457,z:-293.1352563989274},
up: {x:0.578136747554258,y:0.8103545388010297,z:0.09530699120186392}
},
"North Atlantic":{
position: {x:-137.7219663374266,y:134.93931772927482,z:159.1352899859414},
up: {x:0.3485760134063413,y:0.8418048847668705,z:-0.4121399020482765}
},
	"South Pole":{
	    position: {x:0,y:-249.99925472592855,z:-0.6104395794518828},
	    up: {x:0.9999999999999998,y:0,z:0}
	}, 
	"North Pole":{
	    position: {x:12.435991378990524,y:249.68975620440986,z:0.6097253513751638},
	    up: {x:-0.9987620026286266,y:0.049743817204226284,z:0.00012147100820090829}
	},
    }


    let myProps = [
        {label:'3D Globe Attributes'},
	{p:"globeWidth",d:800},
	{p:"globeHeight",d:400},
	{p:"globeStyle",d:'',tt:'css for globe'},	
	{p:"baseImage",d:"earth-blue-marble.jpg",ex:"earth-blue-marble.jpg|earth-day.jpg|earth-dark.jpg|world-boundaries.png|caida.jpg|white.png|lightblue.png|black.png"},
	{p:"globeBackgroundImage",ex:"night-sky.png|white.png|lightblue.png|black.png"},
	{p:'backgroundColor',d:'#CAE1FF',ex:'#ffffff'},
	{p:"initialPosition",ex:"North America|South America|Europe|Asia|Africa|Australia|South Pole|North Pole"},
	{p:"initialZoom",ex:"1",tt:'lower number more zoomed'},
	{p:'linked',ex:true,tt:"Link location with other globes"},
	{p:'linkGroup',ex:'some_name',tt:"Globe groups to link with"},
	{p:'mapColor',d:'blue'},	
	{p:'showGraticules',ex:true},
	{p:'showAtmosphere',d:true,ex:'false'},
	{p:'atmosphereColor',d:'#fff',ex:'red'},	    	    
	{p:'atmosphereAltitude',d:0.25,ex:0.5},
	{p:'ambientLight',d:'ffffff',ex:'ffffff'},
	{p:'ambientIntensity',d:1,ex:'1'},
	{p:'directionalIntensity',d:1},		
	{p:'directionalLight1',ex:'ffffff'},
	{p:'directionalIntensity1',ex:'0.5'},
	{p:'directionalPosition1',ex:'0,1,0'},
	{p:'directionalLight2',ex:'ffffff'},
	{p:'directionalIntensity2',ex:'0.5'},		
	{p:'directionalPosition2',ex:'0,1,0'},

	{p:'initialAltitude',d:250,ex:500},
	{p:'color',d:'blue',ex:'red'},
	{p:'showPoints',d:true,ex:'false'},
	{p:'showSpheres',ex:true},			
	{p:'pointRadius',d:1,ex:'1',canCache:true},
	{p:'pointResolution',d:12},
	{p:'heightField',tt:'field to map height to'},
	{p:'heightMin',d:0,tt:'min height range that heightField value percent is mapped to'},
	{p:'heightMax',d:0.5},
	{p:'radiusField',tt:'field to map radius to'},
	{p:'radiusMin',d:1},
	{p:'radiusMax',d:5},
	{p:'labelFields',tt:'fields for the label'},
	{p:'labelColor',d:'red',ex:'red'},
	{p:'labelSize',d:0.5},
	{p:'labelDotRadius',d:0.1},
	{p:'labelResolution',d:3},
	{p:'labelIncludeDot',d:true},		
	{p:'labelAltitude',d:0.01},		
	{p:'imageField',tt:'Field id image overlay'},
	{p:'latField1',tt:'Field id for segments'},
	{p:'lonField1',tt:'Field id for segments'},
	{p:'latField2',tt:'Field id for segments'},
	{p:'lonField2',tt:'Field id for segments'},
	{p:'lineWidth',d:0.1},
	{p:'lineAltitude',d:0.05},	
	{p:'showEndPoints',d:true},	
	{p:'polygonField',tt:'field that holds polygons'},

	{p:'geojson',tt:'base layer map or used for chloropleth display',ex:'us_states.geojson|us_counties.geojson|countries.geojson|entryid|url'},
	{p:'polygonNameField',tt:'Field to match with the name field in the geojson map, e.g., state'},
	{p:'polygonAltitude',d:0.01},

	{p:'autoRotate',ex:'true'},

	{p:'selectedDiv',ex:'div id to show selected record'},
	{p:'doPopup',d:true,ex:'',tt:''},
	{p:'centerOnFilterChange',d:true,ex:false,tt:'Center map when the data filters change'},	
    ];


    const SUPER = new RamaddaThree_Base(displayManager, id, DISPLAY_THREE_GLOBE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        initDisplay:  function() {
            SUPER.initDisplay.call(this);
        },
	dataFilterChanged: function(args) {
	    SUPER.dataFilterChanged.call(this,args);
	    if(!this.getCenterOnFilterChange()) return;
	    if(!this.filteredRecords) return;
	    if(this.filteredRecords.length==0) return;
	    this.viewRecords(this.filteredRecords);
	},
	viewRecords:function(records) {
	    let bounds = RecordUtil.getBounds(records);
	    let lat = bounds.south+(bounds.north-bounds.south)/2;
	    let lng = bounds.west+(bounds.east-bounds.west)/2;
	    if(!isNaN(lat) && !isNaN(lng)) {
		this.globe.pointOfView({lat: lat,
					lng: lng,
					alt:10000});
	    }

	},

        updateUI: async function() {
	    
	    if(!window["THREE"]) {
		if(!ramaddaLoadedThree) {
                    ramaddaLoadedThree = true;
//		    Utils.importJS(ramaddaBaseHtdocs+"/lib/three/three.min.js");
		    Utils.importJS("//unpkg.com/three@0.160");		    
		}
		setTimeout(()=>{this.updateUI()},100);
		return
	    }	    

	    if(!window["Globe"]) {
		if(!ramaddaLoadedThreeGlobe) {
                    ramaddaLoadedThreeGlobe = true;
		    Utils.importJS("//unpkg.com/globe.gl");
		}
		setTimeout(()=>{this.updateUI()},100);
		return
	    }	    

            SUPER.updateUI.call(this);
	    this.jq(ID_POPUP).hide();
	    let records =this.filterData();
	    if(!records) return;
	    this.filteredRecords = records;

	    if(!this.globe) {
		this.createGlobe();
	    }


	    if(this.imageField && records.length>0) {
		let url = this.imageField.getValue(records[0]);
		this.globe.globeImageUrl(url);
	    }


            let colorBy = this.getColorByInfo(records);
	    let dfltColor = this.getColor();
	    let pointData = [];

	    let heightField = this.getFieldById(null, this.getHeightField());
	    let heights;
	    if(heightField) {
		heights = this.getColumnValues(records, heightField);
	    }
	    let heightMin = this.getHeightMin();
	    let heightMax = this.getHeightMax();	    
	    let getHeight=record=>{
		if(!heights) return 0;
		let v = heightField.getValue(record);
		let percent = (v-heights.min)/(heights.max-heights.min);
		let height = heightMin+percent*(heightMax-heightMin);
		return height;
	    }


	    let radiusField = this.getFieldById(null, this.getProperty("radiusField"));
	    let radiuss;
	    if(radiusField) {
		radiuss = this.getColumnValues(records, radiusField);
	    }
	    let radiusMin = this.getRadiusMin();
	    let radiusMax = this.getRadiusMax();	    
	    let getRadius=record=>{
		if(!radiuss || !record) return this.getPointRadius();
		let v = radiusField.getValue(record);
		let percent = (v-radiuss.min)/(radiuss.max-radiuss.min);
		let radius = radiusMin+percent*(radiusMax-radiusMin);
		return radius;
	    }


	    let labels = this.getProperty("labelFields");
	    if(labels=="{colorby}") labels=this.getProperty('colorBy');
	    let labelFields = this.getFieldsByIds(null, labels);
	    if(labelFields && labelFields.length) {
		let labelSize = +this.getLabelSize(1.0);
		let labelData = [];
		let labelColor = this.getLabelColor();
		records.forEach((record,idx)=>{
		    let label = "";
		    labelFields.forEach((f,idx) =>{
			if(idx>0) label+=" ";
			let s = String(f.getValue(record));
			if(s=='NaN') s  = '--';
			label+=s;
		    });
		    let d = {
			record:record,
			label: label,
			lat:record.getLatitude(),
			lng:record.getLongitude(),
			color:labelColor
		    };
		    d.labelSize=labelSize;
		    labelData.push(d);
		});
		this.globe.labelsData(labelData)
		    .labelLat(d => d.lat)
		    .labelLng(d => d.lng)
		    .labelAltitude(this.getLabelAltitude())
		    .labelText(d => d.label)
		    .labelColor(d => d.color)
		    .labelIncludeDot(this.getLabelIncludeDot())
		    .labelDotRadius(this.getLabelDotRadius())
		    .labelSize('labelSize')		
		    .labelResolution(this.getLabelResolution());
	    }


	    let polygonField = this.getFieldById(null, this.getProperty("polygonField"));
	    let latField1 = this.getFieldById(null, this.getProperty("latField1"));
	    let lonField1 = this.getFieldById(null, this.getProperty("lonField1"));
	    let latField2 = this.getFieldById(null, this.getProperty("latField2"));
	    let lonField2 = this.getFieldById(null, this.getProperty("lonField2"));	    	    
	    if(latField1 && lonField1  && latField2 && lonField2) { 
		let arcsData = [];
		let showEndPoints = this.getShowEndPoints();
		records.forEach((record,idx)=>{
		    let color=colorBy.getColorFromRecord(record, dfltColor);
		    arcsData.push({
			startLat:latField1.getValue(record),
			startLng:lonField1.getValue(record),
			endLat:latField2.getValue(record),
			endLng:lonField2.getValue(record),			
			color:color,
			record:record
		    });

		    if(showEndPoints) {
			pointData.push({
			    height:0,
			    lat:latField1.getValue(record),
			    lng:lonField1.getValue(record),
			    color:color,
			    radius:this.getPointRadius(),
			    record:record,
			});
			pointData.push({
			    height:0,
			    lat:latField2.getValue(record),
			    lng:lonField2.getValue(record),
			    color:color,
			    radius:this.getPointRadius(),
			    record:record,
			});
		    }
		});

		this.globe.arcsData(arcsData)
		    .arcStroke(+this.getLineWidth())
		    .arcAltitude(this.getLineAltitude())
		    .arcColor('color')
//		    .arcDashLength(() => Math.random())
		    .arcDashGap(0);
	    } else if(polygonField) {
		let polygonColorTable = this.getColorTable(true, "polygonColorTable",null);
		let delimiter;
		let first = !this.didit;
		if(!this.didit) {
		    this.didit = true;
		}
		let latlon = this.getProperty("latlon",true);
		let pathData = [];
		let pData = [];
		let cidx=0;
		records.forEach((record,idx)=>{
		    let color = dfltColor;
		    if(polygonColorTable) {
			if(cidx>=polygonColorTable.length) cidx=0;
			color=polygonColorTable[cidx++];
		    }

//		    if(idx>=5) return;
		    let poly = [];
		    let polyObj = {
			points:poly,
			record:record,
			color:color,
		    };
		    pathData.push(polyObj);
		    let s = polygonField.getValue(record);
		    if(!delimiter) {
			[";",","].forEach(d=>{
			    if(s.indexOf(d)>=0) delimiter = d;
			});
		    }
		    let toks  = s.split(delimiter);
		    let p = [];
		    for(let pIdx=0;pIdx<toks.length;pIdx+=2) {
			let lat = parseFloat(toks[pIdx]);
			let lon = parseFloat(toks[pIdx+1]);
			if(!latlon) {
			    let tmp =lat;
			    lat=lon;
			    lon=tmp;
			}
			poly.push([lat,lon,1]);
			if(pIdx==0 || pIdx==toks.length-2) {
			    let pt = {
				lat:lat,
				lng:lon,
				color:color,
				height:getHeight(record),
				radius:this.getPointRadius(),
				record:record,
			    };
			    pointData.push(pt);
			}
		    }
		});
		this.globe.pathsData(pathData)
		    .pathPoints((d) => {return d.points;})		
		    .pathColor((d) => {return [d.color,d.color]})		
		    .pathDashLength(0.01)
		    .pathDashGap(0.0)
		    .pathPointAlt((d) => {return 0.0;}) ;
	    } else {
		records.forEach((record,idx)=>{
		    let pt = {
			lat:record.getLatitude(),
			lng:record.getLongitude(),		    
			color:colorBy.getColorFromRecord(record, dfltColor),
			height:getHeight(record),
			radius:getRadius(record),
			record:record,
		    };
		    pointData.push(pt);
		});

	    }

	    let haveLatLong=false;
	    pointData.every(pt=>{
		if(Utils.isDefined(pt.lat)) {
		    haveLatLong = true;
		    return false;
		}
		return true;
	    });


	    if(haveLatLong && pointData.length>0) {
		if(this.getShowSpheres()) {
		    this.globe.customLayerData(pointData)
			.customThreeObject(d => new THREE.Mesh(
			    new THREE.SphereBufferGeometry(d.radius),
			    new THREE.MeshLambertMaterial({ color: d.color })
			))
			.customThreeObjectUpdate((obj, d) => {
			    Object.assign(obj.position, this.globe.getCoords(d.lat, d.lng, d.height+0.01));
			});
		} else if(this.getShowPoints()) {
		  this.globe.pointsData(pointData)
			.pointAltitude('height')
			.pointColor('color')
			.pointRadius('radius')
			.pointResolution(this.getPointResolution());
		} else {
//		    console.log("Not showing spheres or points");
		}
	    }

	    if(this.getProperty("geojson")) {
		let nameField = this.getFieldById(null, this.getPolygonNameField());
		if(nameField) {
		    this.addGeojsonLayer(records);
		}
	    }


	    if(colorBy.isEnabled()) {
		colorBy.displayColorTable();
	    }
	    if(!this.getInitialPosition()) {
		this.viewRecords(records);
	    }
	    this.callHook("updateUI");

        },
	getScene() {
	    return this.globe.scene();
	},
	getControls() {
	    return this.globe.controls();
	},
	setPosition:function(pos) {
	    if((typeof pos=="string") && pos.trim().startsWith("{")) {
		pos = this.parsePosition(pos);
	    }
	    let scope = this.getControls();
	    if(pos.target)
		scope.target.copy(pos.target);
	    if(pos.position)
		scope.object.position.copy(pos.position);
	    if(pos.up)
		scope.object.up.copy(pos.up);
	    if(pos.zoom)
		scope.object.zoom = pos.zoom;
	    scope.object.updateProjectionMatrix();
//	    _eye.subVectors( scope.object.position, scope.target );
	    scope.object.lookAt( scope.target );
	},
	getDataObjects: function(recordMap) {
	    let dataObjects = [];
	    let f= (object,idx)=>{
		if(object.__data && object.__data.record) {
		    if(recordMap) {
			let id = object.__data.record.getId();
			if(!recordMap[id]) recordMap[id]=[];
			recordMap[id].push(object);
		    }
		    dataObjects.push(object);
		}
		if(object.children && object.children.length) {
		    object.children.forEach(f);
		}
	    }
	    this.getScene().children.forEach(f);
	    return dataObjects;
	},

	listScene: function() {
	    this.getScene().children.forEach(obj=>{
		console.log(obj.type);
		console.dir(obj);
	    });
	},
	addLights:function() {
	    if(this.addedLight) return;
	    this.addedLight = true;

	    //turn off any directionallight
	    this.getScene().children.filter(obj=>{
		return obj.type=="DirectionalLight" || obj.type=="AmbientLight";
	    }).forEach(obj=>{
//		console.log("removing " + obj.type);
		this.getScene().remove(obj);
	    });

	    let ambientLight = this.getAmbientLight();
	    if(ambientLight && ambientLight!="none") {
//		console.log("adding ambient light:" + ambientLight);
		this.getScene().add(new THREE.AmbientLight(this.parseInt(ambientLight), this.getAmbientIntensity()));
	    }
	    
	    for(let i=1;i<10;i++) {
		let light = this.getProperty("directionalLight"+ i);
		if(!Utils.isDefined(light) || light=="none") {
		    continue;
		}
//		console.log("adding directional light:" + light);
		let dl = new THREE.DirectionalLight(this.parseInt(light),
						    this.getProperty("directionalIntensity"+ i,
								     this.getDirectionalIntensity()));
		let pos = this.getProperty("directionalPosition" + i,"0,1,0").split(",");
		dl.position.set(+pos[0],+pos[1],+pos[2]);
		this.getScene().add(dl);
	    }
	},
	createGlobe:function() {
	    this.imageField = this.getFieldById(null, this.getImageField());
	    let _this = this;
	    let popup = HU.div([CLASS,"display-three-globe-popup",ID,this.domId(ID_POPUP),STYLE,HU.css("display","none","position","absolute","left","60%","top","0px")],"");
	    let pos = HU.div([TITLE,"Select Position", CLASS,"ramadda-clickable", ID,this.domId(ID_POSITION_BUTTON),STYLE,HU.css("position","absolute","left","10px","top","10px","z-index","1000")],HU.getIconImage("fa-globe"));
	    let rotate = HU.div([TITLE,"Toggle rotate", CLASS,"ramadda-clickable", ID,this.domId(ID_ROTATE_BUTTON),STYLE,HU.css("position","absolute","left","10px","top","30px","z-index","1000")],HU.getIconImage("fa-rotate"));	    
	    let w  = parseInt(this.getGlobeWidth());
	    let h = parseInt(this.getGlobeHeight());

	    let globe = HU.div([STYLE,HU.css("position","relative")],
			       pos +
			       rotate+
			       popup +
			       HU.div([ATTR_STYLE,HU.css('width',(w+2)+'px')+this.getGlobeStyle(''),ID, this.domId(ID_GLOBE)]));
	    let html = HU.center(globe);
	    html  = globe;
	    this.setContents(html);
	    this.jq(ID_POPUP).click(()=>{
		this.jq(ID_POPUP).hide();
	    });
		

	    this.jq(ID_ROTATE_BUTTON).click(()=>{
		let scope = this.getControls();
		scope.autoRotate = !scope.autoRotate;
	    });

	    this.jq(ID_POSITION_BUTTON).click(()=>{
		let html = "";
		for(a in positions) {
		    html+=HU.div([CLASS,"ramadda-clickable","place",a],a);
		}
		html=HU.div([STYLE,HU.css("margin","5px")],html);
		let dialog = HU.makeDialog({content:html,anchor:this.jq(ID_POSITION_BUTTON)});
		dialog.find(".ramadda-clickable").click(function() {
		    _this.setPosition(positions[$(this).attr("place")]);
		    dialog.remove();
		});
	    });
	    //Initial example code from https://github.com/vasturiano/three-globe

	    let domGlobe = document.getElementById(this.domId(ID_GLOBE));
	    this.globe = Globe()(domGlobe);	    	    
	    if(Utils.isDefined(this.getInitialZoom())) {
		this.globe.pointOfView({ lat: 0, lng: 0, altitude:  this.getInitialZoom()});
	    }
	    this.globe.onGlobeReady(()=>this.addLights());
	    this.globe.width(w);
	    this.globe.height(h);
	    this.globe.showGraticules(this.getShowGraticules())
		.showAtmosphere(this.getShowAtmosphere())
		.atmosphereColor(this.getAtmosphereColor())	    	    
		.atmosphereAltitude(this.getAtmosphereAltitude());

	    let baseImage = this.getImageUrl(this.getBaseImage());
	    if(baseImage) {
		this.globe.globeImageUrl(baseImage);
	    }
	    let bgImage = this.getImageUrl(this.getGlobeBackgroundImage());
	    if(bgImage) {
		this.globe.backgroundImageUrl(bgImage);
	    }

	    let bg = this.getBackgroundColor();
	    if(bg) {
		this.globe.backgroundColor(bg);
	    }

	    try {
		let canvas = this.jq(ID_GLOBE).find('canvas');
		canvas.attr('tabindex','1');
		canvas.mouseover(()=>{
		    this.mouseOver = true;
		});
		canvas.mouseout(()=>{
		    this.mouseOver = false;
		});		

		domGlobe.addEventListener('keydown', (e) => {
		    if(e.code=="KeyD") {
			//debug
			this.listScene();
			return
		    }

		    if(e.code=="KeyP") {
			let name = prompt("Name:");
			if(!name) return;
			let attrs = ["x","y","z"];
			let  pos =  "{position: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.position[a]);
			    pos+="},\nup: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.up[a]);
			pos+="}}";
			let state = '"'+name+'":' + pos;
			console.log(state);
			Utils.copyToClipboard(pos.replace(/\n/g,""));
		    }

		    if(e.code=="KeyR") {
			let pos = positions[this.getInitialPosition() || "North America"] || this.getInitialPosition();
			if(pos) {
			    this.setPosition(pos);
			}
		    }
		});
	    } catch(err) {
		console.error("Error creating trackball control:" + err);
		console.log("ctor:");console.log(THREE.TrackballControls);
		console.error(err.stack);
	    }

	    let handleMouseEvent=this.handleMouseEvent = object=>{
		this.jq(ID_POPUP).hide();
		let record = object.record;
		if(!record) return;
		this.propagateEventRecordSelection({record: record})
		this.showRecord(record);
	    };


	    if(this.getProperty("geojson")) {
		let nameField = this.getFieldById(null, this.getPolygonNameField());
		if(!nameField) {
		    this.addGeojsonLayer();
		}
	    }

	    this.globe.onPointClick(handleMouseEvent);
	    this.globe.onArcClick(handleMouseEvent);
	    this.globe.onPathClick(handleMouseEvent);
	    this.globe.onLabelClick(handleMouseEvent);
	    this.globe.onGlobeClick(()=>{this.jq(ID_POPUP).hide();});
	    let linked  = this.getLinked();
	    let linkGroup  = this.getLinkGroup();
	    this.globe.onZoom(()=>{
		//Only propagate zoom if its from the user
		if(!this.mouseOver) return;
		if(this.zooming) return;
		let globeDisplays = 
		    Utils.displaysList.filter(d=>{
			if(!d.getId) {
			    console.dir(d);
			    return false;
			}
			if(d.getId() == this.getId()) return false;
			if(d.type!=DISPLAY_THREE_GLOBE) return false;
			if(!d.getLinked()) return false;
			if(!d.globe) return false;
			if(d.getLinkGroup() && this.getLinkGroup() && d.getLinkGroup()!=this.getLinkGroup()) return false;
			if(d.zooming) return false;
			return true;
		    });
		this.zooming = true;
		globeDisplays.forEach(d=>{
		    let pos =  this.getControls().object.position;
		    d.zooming = true;
		    d.getControls().object.position.set(pos.x,pos.y,pos.z);		    
		    d.zooming = false;
		});
		this.zooming = false;
	    });


	    if(this.getInitialPosition()) {
		let posArg = this.getInitialPosition();
		let pos = positions[posArg];
		if(!pos && posArg.startsWith("{")) {
		    pos = this.parsePosition(posArg);
		}

		if(!pos) {
		    console.error("Unknown initial position:" + this.getInitialPosition());
		    return;
		}
		this.setPosition(pos);
	    }

	    if(this.getAutoRotate()) {
		this.getControls().autoRotate = true;
//		console.dir(this.getControls())
	    }

	    this.callHook("createGlobe");
	},

	parsePosition: function(pos) {
	    if(pos && (typeof pos=="string") && pos.startsWith("{")) {
		//A hack to wrap keys with quotes
		pos = pos.replace("position","\"position\"").replace("up","\"up\"").replace(/x/g,"\"x\"").replace(/y/g,"\"y\"").replace(/z/g,"\"z\"");
		try {
		    return JSON.parse(pos);
		} catch(err) {
		    console.err("Error parsing position:" + err+"\n" + pos);
		}
	    }
	    return null;
	},
	showRecord: function(record) {
	    if(this.getDoPopup()) {
		let html = this.getRecordHtml(record,null,this.getProperty("tooltip"));
		this.jq(ID_POPUP).html(html);
		this.jq(ID_POPUP).show(1000);
		return;
	    }
	    if(this.getSelectedDiv()) {
		let html = this.getRecordHtml(record,null,this.getProperty("tooltip"));
		$("#" + this.getSelectedDiv()).html(html);
	    }
	},

	addGeojsonLayer:function(records) {
	    let nameField = this.getFieldById(null, this.getPolygonNameField());
            let colorBy = null;
	    if(records) colorBy = this.getColorByInfo(records);
	    let url = this.getMapUrl(this.getProperty("geojson"));
	    let strokeColor= this.getMapColor();
	    $.getJSON(url, json=>{
		//		    console.log(json.features.length);
		//		    json.features.forEach(f=>{console.log(f.properties.NAME);});
		let aliases = {
		    "united states of america":"united states" ,
		    "czechia":"czech republic",
		    'swaziland':'eswatini',
		    'south korea':'korea (rep.)',
		    'north korea':'korea (dem. people s rep.)',
		    'eq. guinea':'guinea',
		    'gambia':'gambia the',
		    'congo':'congo (rep.)',
		    'democratic republic of the congo':'congo (dem. rep.)',
		    'ivory coast':'cote d\'ivoire'
		}
		let nameMap = {};
		if(nameField) {
		    records.forEach(record=>{
			let name = nameField.getValue(record);
//			console.log("name:" +name);
			nameMap[name] = record;
			nameMap[name.toLowerCase()] = record;
			nameMap[name.toUpperCase()] = record;			    			    
		    });
		}
		let logCnt = 0;
		json.features.forEach(f=>{
		    if(!f.properties) {
			if(logCnt++<50)
			    console.error("No properties in feature");
			return;
		    }
		    let seen = {};
		    let names = [f.properties.SOVEREIGNT, f.properties.name, f.properties.NAME, f.properties.ADMIN].filter(name=>{
			if(seen[name])return false;
			seen[name] = true;
			return name});
		    if(names.length==0) {
			if(logCnt++<50)
			    console.log("Could not find name in feature:" +JSON.stringify(f.properties));
			return;
		    }
		    let record = null;
		    names.every(name=>{
			record=nameMap[name];
			if(record) return false;
			return true;
		    });

		    if(!record) {
			names.every(name=>{
			    let alias = aliases[name.toLowerCase()];
			    if(!alias) return true;
 			    record = nameMap[alias];
			    if(record) return false;
			    return true;
			});
		    }

		    if(!record) {
//			this.handleLog("Could not find record for feature:" +names);
			return;
		    }
		    f.record=record;
		    if(colorBy && colorBy.isEnabled()) {
			f.color = colorBy.getColorFromRecord(record, null);
		    }
		});

		let alt = this.getPolygonAltitude();
		this.globe.polygonsData(json.features)
		    .polygonStrokeColor(()=>strokeColor)
		    .polygonCapColor((f)=>f.color || "transparent")
		    .polygonSideColor((f)=>f.color||"transparent")		    
		    .polygonAltitude(alt);


		if(nameField) {
		    let tooltip = this.getProperty("tooltip");
		    if(Utils.stringDefined(tooltip)) {
			this.globe.polygonLabel(f=>{
			    if(!f.record) return null;
			    let html =  this.getRecordHtml(f.record,null,this.getProperty("tooltip"));
			    html = HU.div([CLASS,"display-three-globe-popup",ATTR_STYLE,this.getProperty('popupStyle','')], html);
			    return html;
			});
		    }

		    this.globe.onPolygonHover(
			hoverD => {
			    this.globe
				.polygonAltitude(d => d === hoverD ? 0.08 : alt)
			})
			    .polygonsTransitionDuration(300);
		    //				.polygonCapColor(d => d === hoverD ? 'steelblue' : d.color)
		}

	    }).fail(err=>{
		console.error("failed to load json:" + url);
	    });
	    if(nameField) {
		this.globe.onPolygonClick(this.handleMouseEvent);
	    }
	},
	getImageUrl:function(image) {
	    if(!image) return null;
	    if(!image.startsWith("http") && !image.startsWith("/")) image = ramaddaBaseHtdocs+"/images/maps/" + image;
	    return image;
	},
	getMapUrl:function(url) {
	    if(!url) return null;
	    if(!url.startsWith("http") && !url.startsWith("/")) {
		//entry id e.g., 41d9b105-d61b-4fc1-8198-8e75c49b1a24
		if(url.trim().match(/.*[0-9a-z]+-[0-9a-z]+-[0-9a-z]+-[0-9a-z]+-[0-9a-z]+.*/)) {

		    url = ramaddaBaseUrl +'/entry/get?entryid=' + url;
		} else {
		    url = ramaddaBaseHtdocs+"/resources/" + url;
		}
	    }
	    return url;
	},	
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    let record = args.record;
	    this.globe.pointOfView({lat: record.getLatitude(),lng:record.getLongitude(),alt:10000});
	    let coords = this.globe.getCoords(args.record.getLatitude(),args.record.getLongitude());
	    if(this.selectedObjects) {
		this.selectedObjects.forEach(object=>{
		    if(!object.material) return;
		    object.material.color.setHex(object.__oldcolor);
		});
	    }
	    let map = {};
	    this.getDataObjects(map);
	    let objects = map[args.record.getId()];
	    this.selectedObjects = objects;
	    if(!objects) return;
	    objects.forEach(object=>{
		if(!object.material) return
		object.__oldcolor =  object.material.color.getHex();
		object.material.color.setRGB(1,0,0);
	    });

	}
    });
}


function RamaddaThree_gridDisplay(displayManager, id, properties) {
    const ID_CONTAINER = "container";
    const ID_GRID = "grid";
    const ID_POPUP = "popup";
    const ID_POSITION_BUTTON = "positionbutton";        
    const CAMERA_ANGLE = 45;
    let myProps = [
        {label:'3D Grid Attributes'},
	{p:"gridWidth",d:400},
	{p:"gridHeight",d:400},
	{p:'backgroundColor',d:'#CAE1FF',ex:'#ffffff'},
	{p:'canvasBorder',d:'1px solid #ccc'},
	{p:'shape',d:"box",ex:'box|cylinder'},
	{p:'heightField',tt:'field to scale height by'},
	{p:'heightScale',d:10,tt:'scale factor'},	
	{p:'doPopup',d:true,ex:'',tt:''},
	{p:'doImages',ex:true},
    ];
    const SUPER = new RamaddaThree_Base(displayManager, id, DISPLAY_THREE_GRID, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        initDisplay:  function() {
            SUPER.initDisplay.call(this);
        },
	dataFilterChanged: function(args) {
	    SUPER.dataFilterChanged.call(this,args);
	},
        updateUI: async function() {
            if(!ramaddaLoadedThree) {
                ramaddaLoadedThree = true;
		await Utils.importJS(ramaddaBaseHtdocs+"/lib/three/three.min.js");
		await Utils.importJS(ramaddaBaseHtdocs+"/lib/three/controls/OrbitControls.js");
            }
	    if(!window["THREE"]) {
		setTimeout(()=>{this.updateUI()},100);
		return
	    }	    
	    if(!THREE.OrbitControls) {
		setTimeout(()=>{this.updateUI()},100);
		return
	    }

            SUPER.updateUI.call(this);
	    this.jq(ID_POPUP).hide();
	    if(!this.shapes) {
		this.createScene();
	    }

	    this.shapes.forEach(shape=>{
		this.scene.remove(shape);
	    });

	    let records =this.filterData();
	    if(!records) return;
	    this.filteredRecords = records;

//	    records = [...records,...records,...records,...records,...records]
//	    records = [...records,...records,...records,...records,...records]	    



	    let sqrt = Math.ceil(Math.sqrt(records.length));
	    let cubeWidth = 1;
	    let cubeSpace = cubeWidth/2;	    
	    let rectWidth = sqrt*(cubeWidth+cubeSpace);
	    let topRadius = cubeWidth;
	    let bottomRadius = cubeWidth;	    

	    if(!this.initCamera) {
		this.initCamera = true;
		let h = (rectWidth/2)/Math.tan(Utils.toRadians(CAMERA_ANGLE/2));
		this.camera.position.set(0,0,h*2);
//		this.addChecker(rectWidth);
	    }
	    let initX = ((cubeWidth+cubeSpace)*-sqrt/2);
	    let initY = -initX;
	    let x = initX;
	    let y= initY;
	    let colCnt = 0;

            let colorBy = this.getColorByInfo(records);
	    let colorBys = [];
	    if(this.colorByFields) {
		let fields = this.getFields();
		this.colorByFields.forEach(field=>{
//		    function ColorByInfo(display, fields, records, prop,colorByMapProp, defaultColorTable, propPrefix, theField, props,lastColorBy) {
		    let cb = new ColorByInfo(this,fields,records,null,null,null,null,field);
		    colorBys.push(cb);
		})
	    }
	    let bounds = RecordUtil.getBounds(records);

	    let heightBy;
	    let heightScale = this.getHeightScale();
	    if(this.getProperty("heightField")) {
		heightBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records,"heightField");
	    }

	    if(colorBys.length==0) colorBys=[colorBy];
	    colorBys=[colorBy];	    
	    let doImages = this.getDoImages();
	    let imageFields = this.getFieldsByType(null,"image");
	    const loader = new THREE.TextureLoader();
	    let shape  = this.getShape();
	    shapeWidth = 0.5;
	    let doGeo = false;
	    records.forEach((record,idx)=>{	
		if(x>-initX) {
		    y-=(cubeWidth+cubeSpace);
		    x  = initX;
		}

		if(doGeo) {
		    let percentX = (record.getLongitude()-bounds.west)/bounds.getWidth();
		    x = initX+percentX*rectWidth;
		    let percentY = (record.getLatitude()-bounds.south)/bounds.getHeight();
		    y = (initY+percentY*rectWidth/this.aspectRatio)-rectWidth/this.aspectRatio
		}
		
		if(doImages) {
		    let geometry = new THREE.BoxGeometry(cubeWidth,cubeWidth,cubeWidth);
		    const materials = [];
		    imageFields.forEach(f=>{
			let image = f.getValue(record);
//			image = "https://ramadda.org/repository/metadata/view/Screenshot_2021-10-19_at_13-51-39_Point_Data_Collection.png?element=1&entryid=90e2c8e8-7e24-4f6b-9f0c-134fbd690999&metadata_id=b34d307a-7e7c-4a62-8c1e-1e1cd5637b2b";
//			image = 'https://localhost:8430/repository/images/logo.png';
			if(Utils.stringDefined(image)) {
			    materials.push(new THREE.MeshBasicMaterial({map: loader.load(image)}));
			}
		    });
		    let cube = new THREE.Mesh(geometry, materials);
		    cube.position.x = x;
		    cube.position.y = y;		
		    this.scene.add(cube);
		    this.shapes.push(cube); 
		} else {
		    let materials = [];
/*
		    for(let i=0;i<colorBys.length;i++) {
			let color = colorBys[i].getColorFromRecord(record, null);
			let material = new THREE.MeshLambertMaterial( { color: this.parseInt(color,0xff0000) } );
			materials.push(this.parseInt(color,0xff0000));
		    }
*/
		    let color = colorBy.getColorFromRecord(record, null);
		    let material = new THREE.MeshLambertMaterial( { color: this.parseInt(color,0xff0000) } );
		    let height = cubeWidth;
		    if(heightBy) {
			let percent;
			let func = perc =>{percent = perc;}
			let h = heightBy.getSize(record.getData(),0,func);
			if(!isNaN(percent))
			    height = height+percent*height*heightScale;
		    }

		    let geometry;
		    if(shape=="box") {
			geometry = new THREE.BoxGeometry(shapeWidth,shapeWidth,height);
		    } else {
			geometry = new THREE.CylinderGeometry(topRadius,bottomRadius,height,32);
		    }
		    let cube = new THREE.Mesh(geometry, material);
		    if(shape=="box") {
		    } else {
			cube.rotation.x = Utils.toRadians(90);
		    }
//		    cube.position.set(x,y,0);
		    cube.position.x=x;
		    cube.position.y = y;		
		    cube.position.z = height/2;
		    this.scene.add(cube);
		    cube.__record = record;
		    this.shapes.push(cube);
		}
		x+=cubeWidth+cubeSpace;
	    });
	    /*
	    var geometry = new THREE.CylinderBufferGeometry( 0, 10, 30, 4, 1 );
	    var material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
	    for ( var i = 0; i < 500; i ++ ) {
		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.x = ( Math.random() - 0.5 ) * 1000;
		mesh.position.y = ( Math.random() - 0.5 ) * 1000;
		mesh.position.z = ( Math.random() - 0.5 ) * 1000;
		mesh.updateMatrix();
		mesh.matrixAutoUpdate = false;
		this.scene.add( mesh );
	    }
	    */

	    if(colorBy.isEnabled()) {
		colorBy.displayColorTable();
	    }
	    this.callHook("updateUI");
        },
	addChecker:function(width) {
	    const planeSize = width*1.1;
	    const loader = new THREE.TextureLoader();
	    const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
	    texture.wrapS = THREE.RepeatWrapping;
	    texture.wrapT = THREE.RepeatWrapping;
	    texture.magFilter = THREE.NearestFilter;
	    const repeats = planeSize / 2;
	    texture.repeat.set(repeats, repeats);
	    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
	    const planeMat = new THREE.MeshPhongMaterial({
		map: texture,
		side: THREE.DoubleSide,
	    });
	    const mesh = new THREE.Mesh(planeGeo, planeMat);
//	    mesh.rotation.x = Math.PI * -.5;
	    this.scene.add(mesh);
	},

	createScene: function() {
	    let popup = HU.div([CLASS,"display-three-globe-popup",ID,this.domId(ID_POPUP),STYLE,HU.css("display","none","position","absolute","left","60%","top","0px")],"");
	    let grid = HU.div([STYLE,HU.css("position","relative")],
			      popup +
			      HU.div([STYLE,HU.css("min-width","200px","min-height","200px"), ID, this.domId(ID_GRID)]));
	    let html = HU.center(grid);
	    this.setContents(html);
	    this.scene = new THREE.Scene();
	    //fov,aspect ratio, near plane, far plane
	    let w = this.getGridWidth();
	    let h  = this.getGridHeight();
	    this.aspectRatio = w/h;
	    const AMOUNT = 6;
	    const WIDTH = ( w / AMOUNT ) * window.devicePixelRatio;
	    const HEIGHT = ( h / AMOUNT ) * window.devicePixelRatio;

	    this.camera = new THREE.PerspectiveCamera(CAMERA_ANGLE,w/h,0.1,1000);
	    this.camera = new THREE.OrthographicCamera( -100,100,100,-100, 0.1, 1000 );
	    this.camera.position.set(0,0,100);

	    var axes = new THREE.AxisHelper(1000);            this.scene.add(axes);

	    this.renderer = new THREE.WebGLRenderer({antialias:true,alpha: true});
	    this.renderer.setClearColor(this.getBackgroundColor());
	    this.renderer.setSize(w,h);
	    this.controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
	    this.controls.minDistance = 0;
	    this.controls.maxDistance = 1000;
	    this.controls.target.set( 0, 0, 5 );
	    this.controls.update();
	    this.jq(ID_GRID).append(this.renderer.domElement);
	    
	    let addLight=(v,x,y,z,i) =>{
		i=0.01;
		if(!Utils.isDefined(i)) i=1;
//		var light = new THREE.PointLight(this.parseInt(v),i);
		let light = new THREE.DirectionalLight(this.parseInt(v));
		light.position.set(x,y,z);
		this.getScene().add(light);
	    }
	    addLight(0xffffff,-1,1,1);
//	    addLight(0xffffff,1,1,1);
//	    addLight(0xffffff,-1,-1,1);
//	    addLight(0xffffff,1,-1,1);	    
	    var light = new THREE.AmbientLight( 0xffffff,0.5);
	    this.scene.add( light );
	    light = new THREE.HemisphereLight( 0xffffff,0xffffbb,1.0);
//	    this.scene.add( light );	    


	    let _this = this;
	    let canvas = this.jq(ID_GRID).find('canvas');
	    canvas.attr('tabindex','1');
	    canvas.css("border",this.getCanvasBorder());
	    this.renderer.domElement.addEventListener('keydown', (e) => {
		    if(e.code=="KeyP") {
			let name = prompt("Name:");
			if(!name) return;
			let attrs = ["x","y","z"];
			let  pos =  "{position: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.position[a]);
			    pos+="},\nup: {";
			attrs.forEach((a,idx)=>pos+=(idx>0?",":"") + a+":" + this.getControls().object.up[a]);
			pos+="}}";
			let state = '"'+name+'":' + pos;
			Utils.copyToClipboard(pos.replace(/\n/g,""));
		    }

		    if(e.code=="KeyR") {
			_this.controls.reset();
//			let pos = positions[this.getInitialPosition() || "North America"];
//			if(pos) {			    this.setPosition(pos);			}
		    }
		});



	    let cnt = 0;
	    let handleMouseEvent=event=>{
		this.jq(ID_POPUP).hide();
		event.preventDefault();
		if(!event.shiftKey || event.which != 1)  return;
		let r = new THREE.Raycaster();
		let mouse = {
		    x: ( event.offsetX / w) * 2 - 1,
		    y : - ( event.offsetY / h) * 2 + 1
		};
		r.setFromCamera( mouse, this.camera ); 
		let intersects = r.intersectObjects(this.shapes,true);
		if(intersects.length==0) {
		    console.log("nothing found");
		    return;
		}
		let minDistance = NaN;
		let minObject = null;
		intersects.forEach(o=>{
		    if(minObject==null || minDistance>o.distance) {
			minObject = o.object;
			minDistance = o.distance;
		    }
		});
//		console.dir(minObject);
		let getRecord = o=>{
		    if(o.__record) return o.__record;
		    if(o.parent) return getRecord(o.parent);
		    return null;
		};
		let record = getRecord(minObject);
		if(!record) {
		    console.log("Could not find record");
		    return;
		}
		this.propagateEventRecordSelection({record: record})
		if(this.getDoPopup()) {
		    let html = this.getRecordHtml(record);
		    this.jq(ID_POPUP).html(html);
		    this.jq(ID_POPUP).show(1000);
		    return;
		}
		if(this.getSelectedDiv()) {
		    let html = this.getRecordHtml(record);
		    $("#" + this.getSelectedDiv()).html(html);
		}
	    };
	    this.renderer.domElement.addEventListener( 'mouseup', handleMouseEvent, false );
	    _this.renderer.render( _this.scene, _this.camera );
	    this.shapes = [];
	    if(!this.animating) {
		this.animating = true;
		function animate() {
		    requestAnimationFrame( animate );
		    _this.controls.update();
		    _this.shapes.forEach((shape,idx)=>{
//			shape.rotation.x+=0.01
//			shape.rotation.y+=0.01
//			if(idx==0) console.log(shape.rotation.x);
		    });
		    _this.renderer.render( _this.scene, _this.camera );
		}
		animate();
	    }

	}	    
    });
}
/**
   Copyright (c) 2008-2025 Geode Systems LLC
   SPDX-License-Identifier: Apache-2.0
*/


function RamaddaXlsDisplay(displayManager, id, properties) {

    var COORD_X = "xaxis";
    var COORD_Y = "yaxis";
    var COORD_GROUP = "group";


    var ID_SEARCH = "search";
    var ID_SEARCH_PREFIX = "table";
    var ID_SEARCH_EXTRA = "searchextra";
    var ID_SEARCH_HEADER = "searchheader";
    var ID_RESULTS = "results";
    var ID_DOWNLOADURL = "downloadurl";
    var ID_CONTENTS = "tablecontents";
    var ID_SEARCH_DIV = "searchdiv";
    var ID_SEARCH_FORM = "searchform";
    var ID_SEARCH_TEXT = "searchtext";
    var ID_TABLE_HOLDER = "tableholder";
    var ID_TABLE = "table";
    var ID_CHARTTOOLBAR = "charttoolbar";
    var ID_CHART = "chart";

    RamaddaUtil.inherit(this, new RamaddaDisplay(displayManager, id, "xls", properties));
    addRamaddaDisplay(this);


    this.url = properties.url;
    this.tableProps = {
        fixedRowsTop: 0,
        fixedColumnsLeft: 0,
        rowHeaders: true,
        colHeaders: true,
        headers: null,
        skipRows: 0,
        skipColumns: 0,
    };
    if (properties != null) {
        $.extend(this.tableProps, properties);
    }


    RamaddaUtil.defineMembers(this, {
        initDisplay: function() {
            this.createUI();
            this.setDisplayTitle("Table Data");
            var body =
                HtmlUtils.div([ATTR_ID, this.getDomId(ID_SEARCH_HEADER)]) +
                HtmlUtils.div([ATTR_ID, this.getDomId(ID_TABLE_HOLDER)]) +
                HtmlUtils.div([ATTR_ID, this.getDomId(ID_CHARTTOOLBAR)]) +
                HtmlUtils.div([ATTR_ID, this.getDomId(ID_CHART)]);
            this.setContents(body);
            this.loadTableData(this.url);
        },
    });


    RamaddaUtil.defineMembers(this, {
        currentSheet: 0,
        currentData: null,
        columnLabels: null,
        startRow: 0,
        groupIndex: -1,
        xAxisIndex: -1,
        yAxisIndex: -1,
        header: null,
        cellSelected: function(row, col) {
            this.startRow = row;
            if (this.jq("params-xaxis-select").attr("checked")) {
                this.xAxisIndex = col;
            } else if (this.jq("params-group-select").attr("checked")) {
                this.groupIndex = col;
            } else {
                this.yAxisIndex = col;
            }
            var label = "";
            var p1 = "";
            var p2 = "";

            this.setAxisLabel(COORD_X, this.getHeading(this.xAxisIndex, true));
            this.setAxisLabel(COORD_GROUP, this.getHeading(this.groupIndex, true));
            this.setAxisLabel(COORD_Y, this.getHeading(this.yAxisIndex, true));
        },
        getAxisLabelId: function(root) {
            return "params-" + root + "-label"
        },
        setAxisLabel: function(fieldId, lbl) {
            fieldId = this.getAxisLabelId(fieldId);
            var id = HtmlUtils.getUniqueId();
            if (lbl.length > 25) {
                lbl = lbl.substring(0, 25) + "...";
            }
            if (lbl.trim() != "") {
                lbl = HtmlUtils.span([ATTR_ID, id, ATTR_CLASS, "ramadda-tag-box"], "&nbsp;&nbsp;" + lbl + "&nbsp;&nbsp;");
            }
            this.jq(fieldId).html(lbl);
        },
        loadSheet: function(sheetIdx) {

            var all = $("[id^=" + this.getDomId("sheet_") + "]");
            var sel = $("#" + this.getDomId("sheet_") + sheetIdx);

            all.css('font-weight', 'normal');
            sel.css('font-weight', 'bold');

            all.css('border', '1px #ccc solid');
            sel.css('border', '1px #666 solid');

            this.currentSheet = sheetIdx;
            var sheet = this.sheets[sheetIdx];
	    let rows;
            if (sheet) {
                rows = sheet.rows.slice(0);
                if (rows.length > 0) {
                    this.header = rows[0];
                }
            }

	    if(!rows) {
		this.displayHtml(this.getMessage("No data"));
		return;
	    }
            var html = "";
            var _this = this;
            var args = {
                contextMenu: true,
                stretchH: 'all',
                colHeaders: true,
                rowHeaders: true,
                minSpareRows: 1,
                afterSelection: function() {
                    if (arguments.length > 2) {
                        for (var i = 0; i < arguments.length; i++) {
                            //                                console.log("a[" + i +"]=" + arguments[i]);
                        }
                        var row = arguments[0];
                        var col = arguments[1];
                        _this.cellSelected(row, col);
                    }
                },
            };
            $.extend(args, this.tableProps);
            if (this.tableProps.useFirstRowAsHeader) {
                var headers = rows[0];
                args.colHeaders = headers;
                rows = rows.splice(1);
            }
            for (var i = 0; i < this.tableProps.skipRows; i++) {
                rows = rows.splice(1);
            }

            if (rows.length == 0) {
                this.displayMessage("No data found");
                this.jq(ID_RESULTS).html("");
                return;
            }

            this.jq(ID_RESULTS).html("Found: " + rows.length);
            args.data = rows;
            this.currentData = rows;

            if (this.tableProps.headers != null) {
                args.colHeaders = this.tableProps.headers;
            }

            if (this.getProperty("showTable", true)) {
                this.jq(ID_TABLE).handsontable(args);
            }

        },
        getDataForSheet: function(sheetIdx, args) {
            var sheet = this.sheets[sheetIdx];
            var rows = sheet.rows.slice(0);
            if (rows.length > 0) {
                this.header = rows[0];
            }

            if (this.tableProps.useFirstRowAsHeader) {
                var headers = rows[0];
                if (args) {
                    args.colHeaders = headers;
                }
                rows = rows.splice(1);
            }
            for (var i = 0; i < this.tableProps.skipRows; i++) {
                rows = rows.splice(1);
            }
            return rows;
        },

        makeChart: function(chartType, props) {
            if (typeof google == 'undefined') {
                this.jq(ID_CHART).html("No google chart available");
                return;
            }

            if (props == null) props = {};
            var xAxisIndex = Utils.getDefined(props.xAxisIndex, this.xAxisIndex);
            var groupIndex = Utils.getDefined(props.groupIndex, this.groupIndex);
            var yAxisIndex = Utils.getDefined(props.yAxisIndex, this.yAxisIndex);

            //                console.log("y:" + yAxisIndex +" props:" + props.yAxisIndex);

            if (yAxisIndex < 0) {
                alert("You must select a y-axis field.\n\nSelect the desired axis with the radio button.\n\nClick the column in the table to chart.");
                return;
            }

            var sheetIdx = this.currentSheet;
            if (!(typeof props.sheet == "undefined")) {
                sheetIdx = props.sheet;
            }

            var rows = this.getDataForSheet(sheetIdx);
            if (rows == null) {
                this.jq(ID_CHART).html("There is no data");
                return;
            }


            //remove the first header row
            var rows = rows.slice(1);

            for (var i = 0; i < this.startRow - 1; i++) {
                rows = rows.slice(1);
            }

            var subset = [];
            console.log("x:" + xAxisIndex + " " + " y:" + yAxisIndex + " group:" + groupIndex);
            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var row = [];
                var idx = 0;
                if (xAxisIndex >= 0) {
                    row.push(rows[rowIdx][xAxisIndex]);
                } else {
                    row.push(rowIdx);
                }
                if (yAxisIndex >= 0) {
                    row.push(rows[rowIdx][yAxisIndex]);
                }
                subset.push(row);
                if (rowIdx < 2)
                    console.log("row:" + row);
            }
            rows = subset;

            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var cols = rows[rowIdx];


                for (var colIdx = 0; colIdx < cols.length; colIdx++) {
                    var value = cols[colIdx] + "";
                    cols[colIdx] = parseFloat(value.trim());
                }
            }


            var lbl1 = this.getHeading(xAxisIndex, true);
            var lbl2 = this.getHeading(yAxisIndex, true);
            var lbl3 = this.getHeading(groupIndex, true);
            this.columnLabels = [lbl1, lbl2];


            var labels = this.columnLabels != null ? this.columnLabels : ["Field 1", "Field 2"];
            rows.splice(0, 0, labels);
            /*
            for(var rowIdx=0;rowIdx<rows.length;rowIdx++) {
                var cols = rows[rowIdx];
                var s = "";
                for(var colIdx=0;colIdx<cols.length;colIdx++) {
                    if(colIdx>0)
                        s += ", ";
                    s += "'" +cols[colIdx]+"'" + " (" + (typeof cols[colIdx]) +")";
                }
                console.log(s);
                if(rowIdx>5) break;
            }
            */

            var dataTable = google.visualization.arrayToDataTable(rows);
            var chartOptions = {};
            var width = "95%";
            $.extend(chartOptions, {
                legend: {
                    position: 'top'
                },
            });

            if (this.header != null) {
                if (xAxisIndex >= 0) {
                    chartOptions.hAxis = {
                        title: this.header[xAxisIndex]
                    };
                }
                if (yAxisIndex >= 0) {
                    chartOptions.vAxis = {
                        title: this.header[yAxisIndex]
                    };
                }
            }

            var chartDivId = HtmlUtils.getUniqueId();
            var divAttrs = [ATTR_ID, chartDivId];
            if (chartType == "scatterplot") {
                divAttrs.push(ATTR_STYLE);
                divAttrs.push("width: 450px; height: 450px;");
            }
            this.jq(ID_CHART).append(HtmlUtils.div(divAttrs));

            if (chartType == "barchart") {
                chartOptions.chartArea = {
                    left: 75,
                    top: 10,
                    height: "60%",
                    width: width
                };
                chartOptions.orientation = "horizontal";
                this.chart = new google.visualization.BarChart(document.getElementById(chartDivId));
            } else if (chartType == "table") {
                this.chart = new google.visualization.Table(document.getElementById(chartDivId));
            } else if (chartType == "motion") {
                this.chart = new google.visualization.MotionChart(document.getElementById(chartDivId));
            } else if (chartType == "scatterplot") {
                chartOptions.chartArea = {
                    left: 50,
                    top: 30,
                    height: 400,
                    width: 400
                };
                chartOptions.legend = 'none';
                chartOptions.axisTitlesPosition = "in";
                this.chart = new google.visualization.ScatterChart(document.getElementById(chartDivId));
            } else {
                $.extend(chartOptions, {
                    lineWidth: 1
                });
                chartOptions.chartArea = {
                    left: 75,
                    top: 10,
                    height: "60%",
                    width: width
                };
                this.chart = new google.visualization.LineChart(document.getElementById(chartDivId));
            }
            if (this.chart != null) {
                this.chart.draw(dataTable, chartOptions);
            }
        },

        addNewChartListener: function(makeChartId, chartType) {
            var _this = this;
            $("#" + makeChartId + "-" + chartType).button().click(function(event) {
                console.log("make chart:" + chartType);
                _this.makeChart(chartType);
            });
        },

        makeSheetButton: function(id, index) {
            var _this = this;
            $("#" + id).button().click(function(event) {
                _this.loadSheet(index);
            });
        },
        clear: function() {
            this.jq(ID_CHART).html("");
            this.startRow = 0;
            this.groupIndex = -1;
            this.xAxisIndex = -1;
            this.yAxisIndex = -1;
            this.setAxisLabel(COORD_GROUP, "");
            this.setAxisLabel(COORD_X, "");
            this.setAxisLabel(COORD_Y, "");
        },
        getHeading: function(index, doField) {
            if (index < 0) return "";
            if (this.header != null && index >= 0 && index < this.header.length) {
                var v = this.header[index];
                v = v.trim();
                if (v.length > 0) return v;
            }
            if (doField)
                return "Field " + (index + 1);
            return "";
        },
        showTableData: function(data) {
            var _this = this;

            this.data = data;
            this.sheets = this.data.sheets;
            this.columns = data.columns;



            var buttons = "";
            for (var sheetIdx = 0; sheetIdx < this.sheets.length; sheetIdx++) {
                var id = this.getDomId("sheet_" + sheetIdx);
                buttons += HtmlUtils.div([ATTR_ID, id, ATTR_CLASS, "ramadda-xls-button-sheet"],
                    this.sheets[sheetIdx].name);

                buttons += "\n";
            }

            var weight = "12";

            var tableHtml = "<table width=100% style=\"max-width:1000px;\" > ";
            if (this.sheets.length > 1) {
                weight = "10";
            }

            tableHtml += "<tr valign=top>";

            if (this.sheets.length > 1) {
                //                    tableHtml += HtmlUtils.openTag([ATTR_CLASS,"col-md-2"]);
                tableHtml += HtmlUtils.td(["width", "140"], HtmlUtils.div([ATTR_CLASS, "ramadda-xls-buttons"], buttons));
                weight = "10";
            }


            var makeChartId = HtmlUtils.getUniqueId();

            var tableWidth = this.getProperty("tableWidth", "");
            var tableHeight = this.getProperty("tableHeight", "500px");

            var style = "";
            if (tableWidth != "") {
                style += " width:" + tableWidth + ";";
            }
            style += " height: " + tableHeight + ";";
            style += " overflow: auto;";
            tableHtml += HtmlUtils.td([], HtmlUtils.div([ATTR_ID, this.getDomId(ID_TABLE), ATTR_CLASS, "ramadda-xls-table", ATTR_STYLE, style]));


            tableHtml += "</tr>";
            tableHtml += "</table>";

            var chartToolbar = "";
            var chartTypes = ["barchart", "linechart", "scatterplot"];
            for (var i = 0; i < chartTypes.length; i++) {
                chartToolbar += HtmlUtils.div([ATTR_ID, makeChartId + "-" + chartTypes[i], ATTR_CLASS, "ramadda-xls-button"], "Make " + chartTypes[i]);
                chartToolbar += "&nbsp;";
            }

            chartToolbar += "&nbsp;";
            chartToolbar += HtmlUtils.div([ATTR_ID, this.getDomId("removechart"), ATTR_CLASS, "ramadda-xls-button"], "Clear Charts");


            chartToolbar += "<p>";
            chartToolbar += "<form>Fields: ";
            chartToolbar += "<input type=radio checked name=\"param\" id=\"" + this.getDomId("params-yaxis-select") + "\"> y-axis:&nbsp;" +
                HtmlUtils.div([ATTR_ID, this.getDomId("params-yaxis-label"), ATTR_STYLE, "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "&nbsp;&nbsp;&nbsp;";
            chartToolbar += "<input type=radio  name=\"param\" id=\"" + this.getDomId("params-xaxis-select") + "\"> x-axis:&nbsp;" +
                HtmlUtils.div([ATTR_ID, this.getDomId("params-xaxis-label"), ATTR_STYLE, "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "&nbsp;&nbsp;&nbsp;";
            chartToolbar += "<input type=radio  name=\"param\" id=\"" + this.getDomId("params-group-select") + "\"> group:&nbsp;" +
                HtmlUtils.div([ATTR_ID, this.getDomId("params-group-label"), ATTR_STYLE, "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "</form>";

            if (this.getProperty("showSearch", true)) {
                var results = HtmlUtils.div([ATTR_STYLE, "display:inline-block;", ATTR_ID, this.getDomId(ID_RESULTS)], "");
                var download = HtmlUtils.div([ATTR_STYLE, "display:inline-block;", ATTR_ID, this.getDomId(ID_DOWNLOADURL)]);
                var searchDiv = HtmlUtils.div([ATTR_ID, this.getDomId(ID_SEARCH_DIV), ATTR_CLASS, "ramadda-xls-search-form"]);


                var search = "";
                search += HtmlUtils.openTag("form", ["action", "#", ATTR_ID, this.getDomId(ID_SEARCH_FORM)]);
                search += HtmlUtils.image(icon_tree_closed, [ATTR_ID, this.getDomId(ID_SEARCH + "_open")]);
                search += "\n";
                search += HtmlUtils.input(ID_SEARCH_TEXT, this.jq(ID_SEARCH_TEXT).val(), ["size", "60", ATTR_ID, this.getDomId(ID_SEARCH_TEXT), "placeholder", "Search"]);
                search += "<input type=submit name='' style='display:none;'>";

                search += HtmlUtils.openTag("div", [ATTR_ID, this.getDomId(ID_SEARCH_EXTRA), ATTR_CLASS, "ramadda-xls-search-extra"], "");
                if (this.columns) {
                    var extra = HtmlUtils.openTag("table", [ATTR_CLASS, "formtable"]);
                    for (var i = 0; i < this.columns.length; i++) {
                        var col = this.columns[i];
                        var id = ID_SEARCH_PREFIX + "_" + col.name;
                        var widget = HtmlUtils.input(id, this.jq(id).val(), [ATTR_ID, this.getDomId(id), "placeholder", "Search"]);
                        extra += HtmlUtils.formEntry(col.name.replace("_", " ") + ":", widget);
                    }
                    extra += HtmlUtils.closeTag("table");
                    search += extra;
                }


                if (this.searchFields) {
                    var extra = HtmlUtils.openTag("table", [ATTR_CLASS, "formtable"]);
                    for (var i = 0; i < this.searchFields.length; i++) {
                        var col = this.searchFields[i];
                        var id = ID_SEARCH_PREFIX + "_" + col.name;
                        var widget = HtmlUtils.input(id, this.jq(id).val(), [ATTR_ID, this.getDomId(id), "placeholder", "Search"]);
                        extra += HtmlUtils.formEntry(col.label + ":", widget);
                    }
                    extra += HtmlUtils.closeTag("table");
                    search += extra;
                }




                search += "\n";
                search += HtmlUtils.closeTag("div");
                search += "\n";
                search += HtmlUtils.closeTag("form");

                this.jq(ID_SEARCH_HEADER).html(HtmlUtils.leftRight(searchDiv, results + " " + download));

                this.jq(ID_SEARCH_DIV).html(search);

                if (!this.extraOpen) {
                    this.jq(ID_SEARCH_EXTRA).hide();
                }


                this.jq(ID_SEARCH + "_open").button().click(function(event) {
                    _this.jq(ID_SEARCH_EXTRA).toggle();
                    _this.extraOpen = !_this.extraOpen;
                    if (_this.extraOpen) {
                        _this.jq(ID_SEARCH + "_open").attr("src", icon_tree_open);
                    } else {
                        _this.jq(ID_SEARCH + "_open").attr("src", icon_tree_closed);
                    }
                });

            }


            if (this.getProperty("showTable", true)) {
                this.jq(ID_TABLE_HOLDER).html(tableHtml);
                chartToolbar += "<br>";
                if (this.getProperty("showChart", true)) {
                    this.jq(ID_CHARTTOOLBAR).html(chartToolbar);
                }
            }

            if (this.getProperty("showSearch", true)) {
                this.jq(ID_SEARCH_FORM).submit(function(event) {
                    event.preventDefault();
                    _this.loadTableData(_this.url, "Searching...");
                });
                this.jq(ID_SEARCH_TEXT).focus();
                this.jq(ID_SEARCH_TEXT).select();
            }


            for (var i = 0; i < chartTypes.length; i++) {
                this.addNewChartListener(makeChartId, chartTypes[i]);
            }
            this.jq("removechart").button().click(function(event) {
                _this.clear();
            });

            for (var sheetIdx = 0; sheetIdx < this.sheets.length; sheetIdx++) {
                var id = this.getDomId("sheet_" + sheetIdx);
                this.makeSheetButton(id, sheetIdx);
            }
            var sheetIdx = 0;
            var rx = /sheet=([^&]+)/g;
            var arr = rx.exec(window.location.search);
            if (arr) {
                sheetIdx = arr[1];
            }
            this.loadSheet(sheetIdx);


            if (this.defaultCharts) {
                for (var i = 0; i < this.defaultCharts.length; i++) {
                    var dflt = this.defaultCharts[i];
                    this.makeChart(dflt.type, dflt);
                }
            }
            this.setAxisLabel("params-yaxis-label", this.getHeading(this.yAxisIndex, true));

            this.displayDownloadUrl();

        },
        displayMessage: function(msg, icon) {
            if (!icon) {
                icon = icon_information;
            }
            var html = HtmlUtils.hbox([HtmlUtils.image(icon, ["align", "left"]),
                HtmlUtils.inset(msg, 10, 10, 5, 10)]);
            html = HtmlUtils.div([ATTR_CLASS, "note"], html);
            this.jq(ID_TABLE_HOLDER).html(html);
        },
        displayDownloadUrl: function() {
            var url = this.lastUrl;
            if (url == null) {
                this.jq(ID_DOWNLOADURL).html("");
                return
            }
            url = url.replace("xls_json", "media_tabular_extractsheet");
            url += "&execute=true";
            let img = HU.span([ATTR_TITLE,'Download'],HU.getIconImage("fa-download"));
            this.jq(ID_DOWNLOADURL).html(HtmlUtils.href(url, img));
        },
        loadTableData: function(url, message) {
            this.url = url;
            if (!message) message = this.getLoadingMessage();
            this.displayMessage(message, icon_progress);
            var _this = this;

            var text = this.jq(ID_SEARCH_TEXT).val();
            if (text && text != "") {
                url = url + "&table.text=" + encodeURIComponent(text);
            }
            if (this.columns) {
                for (var i = 0; i < this.columns.length; i++) {
                    var col = this.columns[i];
                    var id = ID_SEARCH_PREFIX + "_" + col.name;
                    var text = this.jq(id).val();
                    if (text) {
                        url = url + "&table." + col.name + "=" + encodeURIComponent(text);
                    }
                }
            }

            if (this.searchFields) {
                for (var i = 0; i < this.searchFields.length; i++) {
                    var col = this.searchFields[i];
                    var id = ID_SEARCH_PREFIX + "_" + col.name;
                    var text = this.jq(id).val();
                    if (text) {
                        url = url + "&table." + col.name + "=" + encodeURIComponent(text);
                    }
                }
            }

            this.lastUrl = url;

	    let  load = async function() {
		if(!this.loadedJS) {
		    await Utils.importJS(ramaddaBaseHtdocs + "/lib/jquery.handsontable.full.min.js");
		    await Utils.importCSS(ramaddaBaseHtdocs + "/lib/jquery.handsontable.full.min.css");
		    this.loadedJS = true;
		}
		var jqxhr = $.getJSON(url, function(data) {
                    if (GuiUtils.isJsonError(data)) {
                        _this.displayMessage("Error: " + data.error);
                        return;
                    }
		    try {
			_this.showTableData(data);

		    } catch(exc) {
                        _this.displayMessage("Error: " + exc);
			this.handleError("Error:" + exc, exc);
		    }
                })
                .fail(function(jqxhr, textStatus, error) {
                    var err = textStatus + ", " + error;
                    _this.displayMessage("An error occurred: " + error);
                    console.log("JSON error:" + err);
                });
	    }
	    load();
	}
    });

}
