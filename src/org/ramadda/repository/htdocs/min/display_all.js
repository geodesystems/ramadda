/**
   Copyright 2008-2019 Geode Systems LLC
*/

function AreaWidget(display) {
    const ID_CONTAINS = "mapcontains";
    const ID_NORTH = "north";
    const ID_SOUTH = "south";
    const ID_EAST = "east";
    const ID_WEST = "west";
    const ID_SETTINGS = "mapsettings";
    const ID_AREA_LINK = "arealink";
    const ID_MAP_SHOW = "showmap";
    const ID_MAP_POPUP_WRAPPER = "mappopupwrapper";    
    const ID_MAP_POPUP = "mappopup";    
    const ID_CLEAR = "mapclear";    
    const ID_SET_LOCATION="mapsetlocation";


    $.extend(this, {
	areaContains:false,
        display: display,
        initHtml: function() {
	    this.display.jq(ID_SETTINGS).click(()=>{
		this.showSettings();
	    });
	    this.display.jq(ID_MAP_SHOW).click(()=>{
		this.showMap();
	    });

	    let params = {};
	    this.map =  new RepositoryMap(this.display.domId(ID_MAP_POPUP), params);
	    this.map.setSelection(this.display.getId(),true,1);
	},
        showSettings: function() {
	    let _this = this;
	    let html = "";
	    html+= HU.div([CLASS,"ramadda-clickable",TITLE, "Use my location",ID,this.display.domId(ID_SET_LOCATION)],
			  HU.getIconImage("fas fa-compass") + SPACE + "Use my location");
            html += HU.div([CLASS,"ramadda-clickable",TITLE, "Clear form",ID,this.display.domId(ID_CLEAR)],
			  HU.getIconImage("fas fa-eraser") + SPACE + "Clear form");
	    html+= HU.div([TITLE, "Search mode: checked - contains, unchecked - overlaps"],
			  HtmlUtils.checkbox("",[ID, this.display.getDomId(ID_CONTAINS)], this.areaContains) +HU.tag("label",[CLASS,"ramadda-clickable","for",this.display.getDomId(ID_CONTAINS)], SPACE + "Contains"));
	    html = HU.div([STYLE,"margin:5px;"], html);
	    this.settingsDialog = HU.makeDialog({content:html,anchor:this.display.jq(ID_SETTINGS),draggable:false,header:true});
	    this.display.jq(ID_CONTAINS).change(function(e) {
		_this.areaContains = $(this).is(':checked');
	    });
	    this.display.jq(ID_SET_LOCATION).click(()=>{
		this.settingsDialog.remove();
		this.useMyLocation();
	    });
	    this.display.jq(ID_CLEAR).click(()=>{
		this.settingsDialog.remove();
		this.areaClear();
	    });	    
	},
        getHtml: function() {
            let callback = this.display.getGet();
            let settings = HU.div([TITLE,"Settings",CLASS,"ramadda-clickable",ID,this.display.domId(ID_SETTINGS)],HU.getIconImage("fas fa-cog"));
	    let showMap = HU.div([CLASS,"ramadda-clickable",ID,this.display.domId(ID_MAP_SHOW),TITLE,"Show map selector"], HtmlUtils.getIconImage("fas fa-globe"));

	    let input = (id,place,title)=>{
		return HtmlUtils.input(id, "", ["placeholder", place, ATTR_CLASS, "input display-area-input", "size", "5", ATTR_ID,
						this.display.getDomId(id), ATTR_TITLE, title]);
	    };
            let areaForm = HtmlUtils.openTag(TAG_TABLE, [ATTR_CLASS, "display-area"]);
            areaForm += HtmlUtils.tr([],
				     HtmlUtils.td(["align", "center"],
						  HtmlUtils.leftCenterRight("",
									    input(ID_NORTH, " N","North"),showMap, "20%", "60%", "20%")));

            areaForm += HtmlUtils.tr([], HtmlUtils.td([],
						      input(ID_WEST, " W", "West") +
						      input(ID_EAST, " E", "East")));

            areaForm += HtmlUtils.tr([],
				     HtmlUtils.td(["align", "center"],
						  HtmlUtils.leftCenterRight("", input(ID_SOUTH,  " S", "South"), settings, "20%", "60%", "20%")));


            areaForm += HtmlUtils.closeTag(TAG_TABLE);
            areaForm += HU.div([ID,this.display.domId(ID_MAP_POPUP_WRAPPER),STYLE,HU.css("display","none")],SPACE+"Shift-drag: select region. Cmd-drag: move region" +
				HU.div([ID,this.display.domId(ID_MAP_POPUP),STYLE,HU.css("width","400px","height","300px")]));
            return areaForm;
        },
	showMap: function() {
	    let anchor = this.display.jq(ID_MAP_SHOW);
	    this.dialog = HU.makeDialog({contentId:this.display.domId(ID_MAP_POPUP_WRAPPER),anchor:anchor,draggable:true,header:true});
	    this.map.selectionPopupInit();
	    this.map.getMap().updateSize();
	},
        areaClear: function() {
            $("#" + this.display.getDomId(ID_NORTH)).val("");
            $("#" + this.display.getDomId(ID_WEST)).val("");
            $("#" + this.display.getDomId(ID_SOUTH)).val("");
            $("#" + this.display.getDomId(ID_EAST)).val("");
            this.display.areaClear();
        },
        useMyLocation: function() {
            if (navigator.geolocation) {
                let _this = this;
                navigator.geolocation.getCurrentPosition(function(position) {
                    _this.setUseMyLocation(position);
                });
            } else {}
        },
        setUseMyLocation: function(position) {
            let lat = position.coords.latitude;
            let lon = position.coords.longitude;
            let offset = 5.0;
            if (this.display.myLocationOffset)
                offset = parseFloat(this.display.myLocationOffset);

            $("#" + this.display.getDomId(ID_NORTH)).val(lat + offset);
            $("#" + this.display.getDomId(ID_WEST)).val(lon - offset);
            $("#" + this.display.getDomId(ID_SOUTH)).val(lat - offset);
            $("#" + this.display.getDomId(ID_EAST)).val(lon + offset);
            if (this.display.submitSearchForm)
                this.display.submitSearchForm();
        },
        areaLinkClick: function() {
            this.linkArea = !this.linkArea;
            let image = root + (this.linkArea ? "/icons/link.png" : "/icons/link_break.png");
            $("#" + this.display.getDomId(ID_AREA_LINK)).attr("src", image);
            if (this.linkArea && this.lastBounds) {
                let b = this.lastBounds;
                $("#" + this.display.getDomId(ID_NORTH)).val(MapUtils.formatLocationValue(b.top));
                $("#" + this.display.getDomId(ID_WEST)).val(MapUtils.formatLocationValue(b.left));
                $("#" + this.display.getDomId(ID_SOUTH)).val(MapUtils.formatLocationValue(b.bottom));
                $("#" + this.display.getDomId(ID_EAST)).val(MapUtils.formatLocationValue(b.right));
            }
        },
        linkArea: false,
        lastBounds: null,
        handleEventMapBoundsChanged: function(source, args) {
            bounds = args.bounds;
            this.lastBounds = bounds;
            if (!args.force && !this.linkArea) return;
            $("#" + this.display.getDomId(ID_NORTH)).val(MapUtils.formatLocationValue(bounds.top));
            $("#" + this.display.getDomId(ID_WEST)).val(MapUtils.formatLocationValue(bounds.left));
            $("#" + this.display.getDomId(ID_SOUTH)).val(MapUtils.formatLocationValue(bounds.bottom));
            $("#" + this.display.getDomId(ID_EAST)).val(MapUtils.formatLocationValue(bounds.right));
        },
        setSearchSettings: function(settings) {
            settings.setAreaContains(this.areaContains);
            settings.setBounds(this.display.getFieldValue(this.display.getDomId(ID_NORTH), null),
			       this.display.getFieldValue(this.display.getDomId(ID_WEST), null),
			       this.display.getFieldValue(this.display.getDomId(ID_SOUTH), null),
			       this.display.getFieldValue(this.display.getDomId(ID_EAST), null));
        },
    });
}



function DateRangeWidget(display, what) {
    const ID_DATE_START = "date_start";
    const ID_DATE_END = "date_end";
    let startLabel, endLabel;
    this.what = what;
    if(what == "createdate") {
	startLabel = "Create start";
	endLabel = "Create end";	
    }

    this.baseId = Utils.getUniqueId("");
    RamaddaUtil.inherit(this, {
        display: display,
        initHtml: function() {
            $("#" + this.baseId +ID_DATE_START).datepicker();
            $("#" + this.baseId +ID_DATE_END).datepicker();	    
        },
        setSearchSettings: function(settings) {
            let start = $("#"+ this.baseId +ID_DATE_START).val();
            let end =  $("#"+ this.baseId +ID_DATE_END).val();
	    if(this.what=="createdate")
		settings.setCreateDateRange(start, end);
	    else
		settings.setDateRange(start, end);
        },
        getHtml: function() {
            let html = HtmlUtils.input(this.baseId +ID_DATE_START, "", [CLASS, "display-date-input", "placeholder", " " +(startLabel||"Start date"), ATTR_ID,
									this.baseId +ID_DATE_START, "size", "10"
							  ]) + " - " +
                HtmlUtils.input(this.baseId +ID_DATE_END, "", [CLASS, "display-date-input", "placeholder",  " " +(startLabel||"Start date"), ATTR_ID,
							       this.baseId +ID_DATE_END, "size", "10"
						 ]);
            return html;
        }
    });
}



function DisplayAnimation(display, enabled,attrs) {
    let dflt = {
    };
    attrs = attrs||{};
    $.extend(dflt,attrs);
    const ID_RUN = "animrun";
    const ID_NEXT = "animnext";
    const ID_PREV= "animprev";
    const ID_BEGIN= "animbegin";
    const ID_END= "animend";
    const ID_SLIDER = "slider";
    const ID_TICKS = "ticks";
    const ID_TOOLTIP = "tooltip";    
    const ID_SHOWALL = "showall";
    const ID_WINDOW = "window";
    const ID_STEP = "step";        
    const ID_SETTINGS = "settings";
    const ID_FASTER = "faster";
    const ID_SLOWER = "slower";
    const ID_RESET = "reset";    
    const ID_ANIMATION_LABEL = "animationlabel";
    const MODE_FRAME = "frame";
    const MODE_SLIDING = "sliding";
    $.extend(this,{
	display:display,
	enabled: enabled,
	targetDiv:attrs.targetDiv,
	baseDomId:attrs.baseDomId,
	labelSize:display.getProperty("animationLabelSize","12pt"),
	labelStyle:display.getProperty("animationLabelStyle",""),
        running: false,
        inAnimation: false,
        begin: null,
        end: null,
        dateMin: null,
        dateMax: null,
        dateRange: 0,
        dateFormat: display.getProperty("animationDateFormat", display.getProperty("dateFormat", "yyyymmdd")),
        mode: display.getProperty("animationMode", "cumulative"),
        startAtBeginning: display.getProperty("animationStartAtBeginning", true),	
        startAtEnd: display.getProperty("animationStartAtEnd", false),
        speed: parseInt(display.getProperty("animationSpeed", 500)),
        dwell: parseInt(display.getProperty("animationDwell", 1000)),	
	getEnabled: function() {
	    return this.enabled;
	},
        toggleAnimation: function() {
	    this.running = !this.running;
	    if(this.btnRun)
		this.btnRun.html(HtmlUtils.getIconImage(this.running ? "fa-stop" : "fa-play"));
	    if (this.running)
		this.startAnimation();
	},
        getDomId: function(id) {
	    return this.domId(id);
	},
        domId: function(id) {
	    return this.display.getDomId(id+(this.baseDomId?this.baseDomId:""));
	},
	jq: function(id) {
	    return this.display.jq(id+(this.baseDomId?this.baseDomId:""));
	},
	init: function(dateMin, dateMax, records) {
	    let debug = false;
	    if(debug)
		console.log("animation.init:" +dateMin +" " + dateMax +" " +(records?"#records:" + records.length: "no records") );
	    let _this = this;
	    this.records = records;
	    this.dateMin = dateMin;
	    this.dateMax = dateMax;
	    this.begin = this.dateMin;
	    this.end = this.dateMax;
	    if(!this.dateMin) return;
	    this.dates=[];
	    let seen = {};
	    records.every(r=>{
		if(!seen[r.getDate()]) {
		    seen[r.getDate()] = true;
		    this.dates.push(r.getDate());
		}
		return true;
	    });
	    this.dates.sort(function(a,b) {
		return a.getTime() - b.getTime();
	    });
	    
            this.dateRange = this.dateMax.getTime() - this.dateMin.getTime();
	    this.steps= parseFloat(this.display.getProperty("animationSteps", 60));
	    this.setWindow();
	    this.frameIndex = 0;
	    if(!this.display.getProperty("animationStartShowAll",false)) { 
		this.resetRange();
	    }
	    let sliderValues = this.mode != MODE_FRAME?[this.begin.getTime(),this.end.getTime()]:[this.begin.getTime()];
	    let tooltipFunc = {
		    mouseleave: function(e) {
			if(_this.tooltip)
			    _this.tooltip.hide();
		    },
		    mousemove: function(e) {
			if(!_this.tooltip) return;
			if(e.offsetX>=0) {
			    let parentWidth = _this.tooltip.parent().width();
			    let parentLeft = _this.tooltip.parent().offset().left; 
			    let percent = (e.pageX-parentLeft)/parentWidth;
			    let dttm = new Date(_this.dateMin.getTime() + percent*_this.dateRange);
			    dttm = _this.formatAnimationDate(dttm,_this.tooltipDateFormat);
			    if(!_this.makeSlider) {
				dttm+="<br>+/-:zoom";
			    }
			    _this.tooltip.html(dttm);
			    _this.tooltip.show();
			    _this.tooltip.position({
				of: e.target,
				my: "left top",
				at: "left+" + e.offsetX +" bottom",
				collision: "fit fit"
			    });
			}
		    }};

	    if(this.makeSlider) {
		let slider = this.jq(ID_SLIDER).slider({
		    range: _this.mode != MODE_FRAME,
		    min: _this.dateMin.getTime(),
		    max: _this.dateMax.getTime(),
		    values: sliderValues,
		    slide: function( event, ui ) {
			_this.stopAnimation();
			_this.setSliderValues(ui.values);
			_this.updateLabels();
		    },
		    stop: function(event,ui) {
			_this.stopAnimation();
			_this.setSliderValues(ui.values);
			_this.dateRangeChanged(true);
		    }
		});
		this.jq(ID_SLIDER).on(tooltipFunc);
	    } else {
		this.jq(ID_TICKS).on(tooltipFunc);
	    }

	    this.updateTicks();
	    if(debug)console.log("animation.init-3");
	    this.updateLabels();
	    if(debug)console.log("animation.init-done");
	},
	resetRange: function() {
	    if(this.startAtEnd) {
		this.begin = this.dateMax;
		this.end = this.dateMax;
		if (this.mode == MODE_FRAME) {
		    this.frameIndex = this.dates.length-1;
		}		    
	    } else   if(this.startAtBeginning) {
		this.begin = this.dateMin;
		this.end = new Date(this.begin.getTime()+this.window);
	    }
	    if (this.mode == MODE_FRAME) {
		this.end = this.begin;
	    }
	},
	setWindow: function() {
	    let window = this.display.getProperty("animationWindow");
	    let step = this.display.getProperty("animationStep", window);
	    if (window) {
		this.window = this.getMillis(window);
	    } else if(this.steps>0){
		this.window = this.dateRange / this.steps;
	    }
	    if (step) {
		this.step = this.getMillis(step);
	    } else {
		this.step = this.window;
	    }
	},
	timeMap: {
	    century: 1000 * 60 * 60 * 24 * 365 * 100,
	    centuries: 1000 * 60 * 60 * 24 * 365 * 100,	    
	    decade: 1000 * 60 * 60 * 24 * 365 * 10,
	    halfdecade: 1000 * 60 * 60 * 24 * 365 * 5,
	    year: 1000 * 60 * 60 * 24 * 365 * 1,
	    month: 1000 * 60 * 60 * 24 * 31,
	    week: 1000 * 60 * 60 * 24 * 7,
	    day: 1000 * 60 * 60 * 24 * 1,		    
	    hour: 1000 * 60 * 60,
	    hour: 1000 * 60,
	    second: 1000		    
	},
	getMillis:function(window) {
	    window =window.trim();
	    let cnt = 1;
	    let unit = "day";
	    let toks = window.match("^([0-9]+)(.*)");
	    if(toks) {
		cnt = +toks[1];
		unit  = toks[2].trim();
	    } else {
		toks = window.match("(^[0-9]+)$");
		if(toks) {
		    unit = "minute";
		    cnt = +toks[1];
		} else {
		    unit = window;
		}
	    }
	    let scale = 1;
	    unit = unit.toLowerCase().trim();
	    if(this.timeMap[unit]) {
		scale = this.timeMap[unit];
	    } else {
		if(unit.endsWith("s"))
		    unit = unit.substring(0, unit.length-1);
		if(this.timeMap[unit]) {
		    scale = this.timeMap[unit];
		} else {
		    console.log("Unknown unit:" + unit);
		}
	    }
	    return  cnt*scale;
	},
	getIndex: function() {
	    return this.frameIndex;
	},
	getBeginTime: function() {
	    return this.begin;
	},
	handleEventAnimationChanged(args) {
	    this.begin = args.begin;
	    this.end = args.end;
	    this.stopAnimation();
	    this.applyAnimation();
	},
	setSliderValues: function(v) {
	    let debug = false;
	    if(debug)
		console.log(this.display.type+" animation.setSliderValues");
	    if(this.mode != MODE_FRAME) {
		this.begin = new Date(v[0]);
		this.end = new Date(v[1]);
	    } else {
		let sliderDate = new Date(v[0]);
		let closest = this.dates[0];
		let dist = 0;
		let closestIdx=0;
		this.dates.forEach((d,idx)=>{
		    if(Math.abs(d.getTime()-sliderDate.getTime()) < Math.abs(closest.getTime()-sliderDate.getTime())) {
			closest = d;
			closestIdx = idx;
		    }
		});
		this.begin = this.end = closest;
		this.frameIndex = closestIdx;
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    let element = $("#" + this.display.getId()+"-"+args.record.getId());
	    if(this.ticks)
		this.ticks.removeClass("display-animation-tick-highlight");
	    if(args.highlight) {
		element.addClass("display-animation-tick-highlight");
	    } else {
		element.removeClass("display-animation-tick-highlight");
	    }
	},
	makeControls:function() {
	    this.tickHeight = this.display.getProperty("animationHeight","15px");
	    this.makeSlider = this.display.getProperty("animationMakeSlider",true);
            let buttons =  "";
	    let showButtons  = this.display.getProperty("animationShowButtons",true);
	    let showSlider = display.getProperty("animationShowSlider",true);
	    if(showButtons) {
		let short = display.getProperty("animationWidgetShort",false);
		buttons +=   HtmlUtils.span([ID, this.getDomId(ID_SETTINGS),TITLE,"Settings"], HtmlUtils.getIconImage("fas fa-cog")); 
		if(!short)
		    buttons +=   HtmlUtils.span([ID, this.getDomId(ID_BEGIN),TITLE,"Go to beginning"], HtmlUtils.getIconImage("fa-fast-backward")); 
		buttons += HtmlUtils.span([ID, this.getDomId(ID_PREV), TITLE,"Previous"], HtmlUtils.getIconImage("fa-step-backward")); 
		if(!short)
		    buttons +=HtmlUtils.span([ID, this.getDomId(ID_RUN),  TITLE,"Run/Stop"], HtmlUtils.getIconImage("fa-play")); 
		buttons +=HtmlUtils.span([ID, this.getDomId(ID_NEXT), TITLE,"Next"], HtmlUtils.getIconImage("fa-step-forward"));
		if(!short)
		    buttons +=HtmlUtils.span([ID, this.getDomId(ID_END), TITLE,"Go to end"], HtmlUtils.getIconImage("fa-fast-forward"));
	    }

	    if(showButtons) {
		buttons+=HtmlUtils.span([ID, this.getDomId(ID_ANIMATION_LABEL), CLASS, "display-animation-label",STYLE,this.labelStyle+HU.css("font-size",this.labelSize)]);
	    } else {
		buttons+=HtmlUtils.div([ID, this.getDomId(ID_ANIMATION_LABEL), CLASS, "display-animation-label",STYLE,this.labelStyle+HU.css("text-align","center","font-size",this.labelSize)]);
	    }
            buttons = HtmlUtils.div([ CLASS,"display-animation-buttons"], buttons);
	    if(showSlider) {
		let style= HU.css("height",this.tickHeight) +display.getProperty("animationSliderStyle","");
		let tooltip  = HU.div([ID,this.getDomId(ID_TOOLTIP),CLASS,"display-animation-tooltip"],"");
		let tickContainerStyle = HU.css("height",this.tickHeight);
		if(!this.makeSlider) {
		    tickContainerStyle += HU.css("background","efefef","border","1px solid #aaa");
		}
		if(!this.makeSlider) {
		    style+=HU.css("cursor","move");
		}
		buttons +=   HtmlUtils.div([CLASS,"display-animation-slider",STYLE,style,ID,this.getDomId(ID_SLIDER)],
					   tooltip + HtmlUtils.div([STYLE, tickContainerStyle,CLASS,"display-animation-ticks","tabindex","0",ID,this.getDomId(ID_TICKS)]));
	    }
	    this.html = HtmlUtils.div([STYLE,this.display.getProperty("animationStyle")], buttons);
	    if(this.display.getProperty("animationShow",true)) {
		if(this.targetDiv) this.targetDiv.append(this.html);
		else this.jq(ID_TOP_LEFT).append(this.html);
	    }
	    if(!this.makeSlider) {
		let _this = this;
		this.jq(ID_TICKS).mouseenter(function(event) {
		    $(this).focus();
		});
		this.lastKeyTime = 0;
		let ticks = this.jq(ID_TICKS);
		ticks.mousedown(function(e) {
		    _this.mouseIsDown = true;
		    let parentOffset = $(this).parent().offset(); 
		    _this.mouseX = e.pageX - parentOffset.left;
		});

		ticks.mousemove(function(e) {
		    if(!_this.mouseIsDown) return;
		    var parentOffset = $(this).parent().offset(); 
		    var relX = e.pageX - parentOffset.left;
		    let range = _this.dateMax.getTime() - _this.dateMin.getTime();
		    let width = $(this).width();
		    let dx = (_this.mouseX-relX);
		    var parentOffset = $(this).parent().offset(); 
		    _this.mouseX = e.pageX - parentOffset.left;
		    if(dx==0) return;
		    let dt = range*dx/width 
		    if(!_this.originaDateMin) {
			_this.originaDateMin = _this.dateMin;
			_this.originaDateMax = _this.dateMax;		
		    }
		    _this.dateMin = new Date(_this.dateMin.getTime()+dt);
		    _this.dateMax = new Date(_this.dateMax.getTime()+dt);			
		    let t1 = new Date();
		    _this.updateTicks();
		    let t2 = new Date();
//		    Utils.displayTimes("update ticks",[t1,t2],true);
		    _this.updateLabels();

		});
		ticks.mouseup(function(e) {
		    _this.mouseIsDown = false;
		});
		ticks.keypress(function(event) {
		    let now = new Date();
		    let diff = now.getTime()-_this.lastKeyTime;
		    _this.lastKeyTime = now.getTime();
		    if(event.which==43)
			_this.zoom(true);
		    else if(event.which==45)
			_this.zoom(false);		    
		    else if(event.which==61)
			_this.zoomReset();

		});

		this.jq(ID_TICKS).bind('xwheel', function(e){		    
		    $(this).focus();
		    if(e.originalEvent.deltaY<0) {
			let range = _this.dateMax.getTime() - _this.dateMin.getTime();
			let newRange = range*0.9;
			let diff = range-newRange;
			_this.dateMin = new Date(_this.dateMin.getTime()+diff);
			_this.dateMax = new Date(_this.dateMax.getTime()-diff);			
			_this.updateTicks();
			_this.updateLabels();
		    } else if(e.originalEvent.deltaY>0) {
			//zoom out 
		    } else {
		    }
		    e.stopPropagation();
		    e.stopImmediatePropagation();
		    e.preventDefault();
		});

	    }

	    if(this.display.getProperty("animationTooltipShow",false)) {
		this.tooltip = this.jq(ID_TOOLTIP);
		this.tooltipDateFormat = this.display.getProperty("animationTooltipDateFormat");
	    }


	    let _this  =this;
            this.jq(ID_SETTINGS).button().click(function(){
		let window = _this.display.getProperty("animationWindow");
		let step = _this.display.getProperty("animationStep", window);		
		let clazz = "ramadda-hoverable ramadda-clickable";
		let html = HU.div([ID,_this.domId(ID_FASTER),TITLE, "Faster", CLASS,clazz], "Faster") +	
	    HU.div([ID,_this.domId(ID_SLOWER),TITLE, "Slower", CLASS,clazz], "Slower")		+
		    HU.div([ID,_this.domId(ID_RESET),TITLE, "Reset", CLASS,clazz], "Reset") +
		    HU.div([ID,_this.domId(ID_SHOWALL),TITLE, "Show all", CLASS,clazz], "Show all");
		if(window) {
		    html+=HU.div([TITLE, "Window, e.g., 1 week, 2 months, 3 days, 2 weeks, etc"], "Window:<br>" +SPACE2 + HU.input("",window,[ID,_this.domId(ID_WINDOW),"size","10"]));
		    html+=HU.div([TITLE, "Step, e.g., 1 week, 2 months, 3 days, 2 weeks, etc"], "Step:<br>" +SPACE2+ HU.input("",step,[ID,_this.domId(ID_STEP),"size","10"]));
		}
		html=HU.div([STYLE,HU.css("margin","4px")], html);
		_this.dialog = HU.makeDialog({content:html,anchor:$(this),draggable:false,header:false});

		let key = (e)=>{
		    if(Utils.isReturnKey(e)) {
			_this.dialog.hide();
			_this.display.setProperty("animationWindow",_this.jq(ID_WINDOW).val());
			_this.display.setProperty("animationStep",_this.jq(ID_STEP).val());			
			_this.setWindow();
			_this.resetRange();
			_this.dateRangeChanged();
		    }
		};
		_this.jq(ID_WINDOW).keyup(key);
		_this.jq(ID_STEP).keyup(key);
		_this.jq(ID_FASTER).click(()=>{
		    _this.dialog.hide();
		    _this.speed = _this.speed*0.75;
		});
		_this.jq(ID_SLOWER).click(()=>{
		    _this.dialog.hide();
		    _this.speed = _this.speed*1.5;
		});

		_this.jq(ID_RESET).click(()=>{
		    _this.dialog.hide();
		    _this.speed =  parseInt(_this.display.getProperty("animationSpeed", 500));
		    _this.resetRange();
		    _this.inAnimation = false;
		    _this.stopAnimation();
		    _this.dateRangeChanged();
		});		
		_this.jq(ID_SHOWALL).click(()=>{
		    _this.dialog.hide();
		    _this.begin = _this.dateMin;
		    _this.end = _this.dateMax;
		    _this.inAnimation = false;
		    _this.stopAnimation();
		    _this.dateRangeChanged();
		});		

	    });
            this.btnRun = this.jq(ID_RUN);
            this.btnPrev = this.jq(ID_PREV);
            this.btnNext = this.jq(ID_NEXT);
            this.btnBegin = this.jq(ID_BEGIN);
            this.btnEnd = this.jq(ID_END);
            this.label = this.jq(ID_ANIMATION_LABEL);
            this.btnRun.button().click(() => {
                this.toggleAnimation();
            });
            this.btnBegin.button().click(() => {
		let diff = this.getDiff();
		let fullRange = this.fullRange();
		this.begin = this.dateMin;
		if (this.mode == MODE_SLIDING) {
		    this.end = new Date(this.begin.getTime()+(fullRange?this.window:diff));
		} else if (this.mode == MODE_FRAME) {
		    this.frameIndex = 0;
		    this.begin = this.end = this.deltaFrame(0);
		} else {
		    this.end = new Date(this.dateMin.getTime()+this.window);
		}
		this.stopAnimation();
		this.dateRangeChanged();
            });
            this.btnEnd.button().click(() => {
		let diff = this.getDiff();
		let fullRange = this.fullRange();
		this.end = this.dateMax;
		if (this.mode == MODE_SLIDING) {
		    this.begin = new Date(this.end.getTime()-(fullRange?this.window:diff));
		} else if (this.mode == MODE_FRAME) {
		    this.frameIndex = this.dates.length+1;
		    this.begin = this.end = this.deltaFrame(0);
		} else {
		    this.end =this.dateMax;
		}
		this.stopAnimation();
		this.dateRangeChanged();
            });
            this.btnPrev.button().click(() => {
		this.stopAnimation();
		this.doPrev();
            });
            this.btnNext.button().click(() => {
		this.stopAnimation();
		this.doNext();
            });

        },
	fullRange: function() {
	    return this.atBegin() && this.atEnd();
	},
	atEnd: function() {
	    return this.end.getTime()>=this.dateMax.getTime();
	},
	atBegin: function() {
	    return this.begin.getTime()<=this.dateMin.getTime();
	},	
	getDiff: function() {
	    return  this.end.getTime()-this.begin.getTime();
	},
	doPrev: function()  {
	    let diff = this.getDiff()||this.window;
	    diff = this.window||this.getDiff();
	    if (this.mode == MODE_SLIDING) {
		this.begin = new Date(this.begin.getTime()-diff);
		if(this.begin.getTime()<this.dateMin.getTime())
		    this.begin = this.dateMin;
		this.end = new Date(this.begin.getTime()+diff);
	    } else if (this.mode == MODE_FRAME) {
		this.begin = this.end = this.deltaFrame(-1);
	    } else {
		this.end = new Date(this.end.getTime()-this.window);
		if(this.end.getTime()<=this.begin.getTime()) {
		    this.end = new Date(this.begin.getTime()+this.window);
		}
	    }
	    this.dateRangeChanged();
	},
	doNext: function() {
	    let debug = false;
	    let wasAtEnd = this.atEnd();
	    if(debug) console.log("animation.doNext:" + this.mode +" atEnd=" + wasAtEnd);
	    if (this.mode == MODE_SLIDING) {
		let window = this.window||this.getDiff();
		this.begin = new Date(this.begin.getTime()+this.step);
		this.end = new Date(this.end.getTime()+this.step);
		//this.end.getTime()+this.window);		
		if(this.atEnd()) {
		    this.end = this.dateMax;
		    this.begin = new Date(this.end.getTime()-window);
		    this.inAnimation = false;
		    this.stopAnimation();
		}
	    } else if (this.mode == MODE_FRAME) {
		this.begin = this.end = this.deltaFrame(1);
		if(this.running) {
		    if(wasAtEnd) {
			if(this.display.getProperty("animationLoop",true)) {
			    setTimeout(()=>{
				this.begin = this.end = this.dateMin;
				this.frameIndex=0;
				this.updateUI();
			    },this.dwell);
			    return;
			} else {
			    this.stopAnimation();
			}
		    }
		}
	    } else {
		this.end = new Date(this.end.getTime()+this.window);
		if(this.atEnd()) {
		    this.end = this.dateMax;
		    this.inAnimation = false;
		    this.stopAnimation();
		}
	    }
	    this.dateRangeChanged();
	},
	deltaFrame: function(delta) {
	    this.frameIndex+=delta;
	    if(!this.dates) return;
	    if(this.frameIndex>= this.dates.length)
		this.frameIndex = this.dates.length-1;
	    else if(this.frameIndex<0)
		this.frameIndex = 0;
	    return this.dates[this.frameIndex];
	},
	startAnimation: function() {
            if (!this.dateMax) return;
	    if (!this.inAnimation) {
                this.inAnimation = true;
                this.label.html("");
		if (this.mode == MODE_FRAME) {
		    this.frameIndex =0;
		    this.begin = this.end = this.deltaFrame(0);
		    this.display.animationStart();
		    this.doNext();
		    return;
		}
                if(this.fullRange()) {
		    this.end = new Date(this.begin.getTime()+this.window);
		}
		this.display.animationStart();
            }
	    this.doNext();
        },
	stopAnimation:function() {
	    if(this.btnRun)
		this.btnRun.html(HtmlUtils.getIconImage("fa-play"));
            this.running = false;
	},
	setDateRange: function(begin,end) {
	    this.begin = begin;
	    this.end = end;
	    this.stopAnimation();
	    this.updateUI();
	},
	dateRangeChanged: function(skipSlider) {
	    this.applyAnimation(skipSlider);
	    this.display.getDisplayManager().notifyEvent("handleEventAnimationChanged", this.display, {
		begin:this.begin,
		end: this.end
	    });
	},
	applyAnimation: function(skipSlider) {
	    this.display.animationApply(this);
	    this.updateUI();
	},
	setRecordListHighlight: function(recordList) {
	    this.recordListHighlight = recordList;
	    this.updateTicks();
	},
	zoomReset: function() {
	    if(this.originaDateMin) {
		this.dateMax = this.originaDateMax;		
		this.dateMin = this.originaDateMin;
		this.updateTicks();
		this.updateLabels();
	    }
	},
	zoom: function(zoomin) {
	    let range = this.dateMax.getTime() - this.dateMin.getTime();
	    let newRange = range*(zoomin?0.9:1.1);
	    let diff = range-newRange;
	    if(!this.originaDateMin) {
		this.originaDateMin = this.dateMin;
		this.originaDateMax = this.dateMax;		
	    }
	    this.dateMin = new Date(this.dateMin.getTime()+diff);
	    this.dateMax = new Date(this.dateMax.getTime()-diff);			
	    this.updateTicks();
	    this.updateLabels();
	},
	updateTicks: function() {
	    let debug = false;
	    this.tickCount = 0;
	    if(!this.records || !this.display.getProperty("animationShowTicks",true)) return;
	    this.highlightRecords = {};
	    if(this.recordListHighlight) {
		this.recordListHighlight.forEach(r=>{
		    this.highlightRecords[r.getId()] = true;
		});
	    }
	    if(debug)console.log("animation.init making ticks: #records=" + records.length +" date:" + this.dateMin + " " + this.dateMax);
	    let tickStyle = this.display.getProperty("animationTickStyle","");
	    let ticks = "";
	    let min = this.dateMin.getTime();
	    let max = this.dateMax.getTime();
	    let p = 0;
	    let seenDate={};
	    let t1 = new Date();
	    for(let i=0;i<this.records.length;i++) {
		let record = this.records[i];
		let date = record.getDate().getTime();
		if(seenDate[date]) continue;
		seenDate[date] = true;
		if(debug)console.log("\ttick:" + record.getDate());
		if(date<min) continue;
		if(date>max) continue;
		this.tickCount++;
		let perc = (date-min)/(max-min)*100;
		let tt = this.formatAnimationDate(record.getDate());
		let clazz = "display-animation-tick";
		if(this.highlightRecords[record.getId()]) {
		    clazz+=" display-animation-tick-highlight-base ";
		}
		ticks+=HtmlUtils.div([TITLE,"",ID,this.display.getId()+"-"+record.getId(), CLASS,clazz,STYLE,HU.css("height",this.tickHeight,'left', perc+'%')+tickStyle,TITLE,tt,RECORD_ID,record.getId()],"");
	    }
	    let t2 = new Date();
	    this.jq(ID_TICKS).html(ticks);
	    let t3 = new Date();
	    if(debug)console.log("animation.init done making ticks");
	    let propagateHighlight = display.getProperty("animationHighlightRecord",false);
	    let propagateSelect = display.getProperty("animationSelectRecord",true);
	    this.ticks = this.jq(ID_TICKS).find(".display-animation-tick");
	    let _this = this;
	    this.display.makeTooltips(this.ticks, this.records,(open,record) =>{
		if(_this.display.animationLastRecordSelectTime) {
		    let now = new Date();
		    //If we recently selected a recordwith a click then don't do the highlight record from the mouse overs
		    //for a couple more seconds
		    if(now.getTime()-_this.display.animationLastRecordSelectTime.getTime()<1500) {
			return false;
		    }
		}
		if(record && propagateHighlight) {
		    if(propagateSelect) {
			_this.display.propagateEventRecordSelection({select:false,record: null});
		    }
		    this.display.handleEventRecordHighlight(this, {highlight: open,record:record, skipAnimation:true});
		}
		return true;
	    },null,propagateHighlight);
	    if(propagateSelect) {
		this.display.makeRecordSelect(this.ticks,this.display.makeIdToRecords(this.records),record=>{
		    _this.display.animationLastRecordSelectTime = new Date();
		});
	    }

	    let t4 = new Date();
//	    Utils.displayTimes("",[t1,t2,t3,t4],true);
	},
	updateUI: function(skipSlider) {
	    if(!skipSlider) {
		if(this.makeSlider) {
		    this.jq(ID_SLIDER).slider('values',0,this.begin.getTime());
		    this.jq(ID_SLIDER).slider('values',1,this.end.getTime());
		}
	    }
	    this.updateLabels();
            let windowEnd = this.end.getTime();
            if (windowEnd <= this.dateMax.getTime()) {
                if (this.running) {
                    setTimeout(() => {
			if(!this.running) return;
			this.doNext();
		    }, this.speed);
                }
            } else {
                this.running = false;
                this.inAnimation = false;
		if(this.btnRun)
                    this.btnRun.html(HtmlUtils.getIconImage("fa-play"));
            }
	},
	makeLabel: function(label) {
	    return HU.span([STYLE,HU.css("font-size",this.labelSize)+this.labelStyle],label);
	},

	updateLabels: function() {
	    if(this.label) {
		if(!this.makeSlider) {
		    this.label.html(HU.leftCenterRight(this.makeLabel(this.formatAnimationDate(this.dateMin)),this.makeLabel("# " +this.tickCount), this.makeLabel(this.formatAnimationDate(this.dateMax))));
		} else {
		    if (this.mode == MODE_FRAME && this.begin == this.end) {
			this.label.html(this.makeLabel(this.formatAnimationDate(this.begin)));
		    } else {
			this.label.html(this.makeLabel(this.formatAnimationDate(this.begin) + " - " + this.formatAnimationDate(this.end)));
		    }
		}
	    }
	},
        formatAnimationDate: function(date,format,debug) {
	    let timeZoneOffset =this.display.getProperty("timeZoneOffset");
	    let timeZone =this.display.getProperty("timeZone");	    
	    if(timeZoneOffset) {
		if(debug) console.log("date before:" + date.toUTCString());
		date = Utils.createDate(date, -timeZoneOffset);
		if(debug) console.log("date after:" + date.toUTCString());
	    }
	    let fmt =  Utils.formatDateWithFormat(date,format||this.dateFormat,true);
	    if(timeZone) return fmt +" " + timeZone;
	    return fmt;
        },

    });
}


function ColorByInfo(display, fields, records, prop,colorByMapProp, defaultColorTable, propPrefix, theField, props) {
    this.properties = props || {};
    if(!prop) prop = "colorBy";
    if ( !propPrefix ) {
	propPrefix = ["colorBy",""];
    } else if( !Array.isArray(propPrefix) ) {
	propPrefix = [propPrefix];
    }
    $.extend(this, {
	display:display,
	fieldProp: prop,
	fieldValue:display.getProperty(prop),
	propPrefix: propPrefix,
    });

    let colorByAttr = this.getProperty(prop||"colorBy", null);
    if(theField==null) {
	if(prop.getId) {
	    theField = prop;
	} else {
	    theField = display.getFieldById(null, colorByAttr);
	}
    }

    if(theField) {
	this.field = theField;
	propPrefix = [theField.getId()+".",""];
	colorByAttr =theField.getId();
	this.propPrefix.unshift(theField.getId()+".colorBy");
	this.propPrefix.push("colorBy");
    }

    $.extend(this, {
	display:display,
        id: colorByAttr,
	fields:fields,
        field: theField,
	colorThresholdField:display.getFieldById(null, display.getProperty("colorThresholdField")),
	aboveColor: display.getProperty("colorThresholdAbove","red"),
	belowColor:display.getProperty("colorThresholdAbove","blue"),
	excludeZero:this.getProperty(PROP_EXCLUDE_ZERO, false),
	overrideRange: this.getProperty("overrideColorRange",false),
	inverse: this.getProperty("Inverse",false),
	origRange:null,
	origMinValue:0,
	origMaxValue:0,
        minValue: 0,
        maxValue: 0,
	toMinValue: 0,
        toMaxValue: 100,
        isString: false,
        stringMap: null,
	colorByMap: {},
	colorByValues:[],
	colorByMinPerc: this.getProperty("MinPercentile", -1),
	colorByMaxPerc: this.getProperty("MaxPercentile", -1),
	colorByOffset: 0,
        pctFields:null,
	compareFields: display.getFieldsByIds(null, this.getProperty("CompareFields", "")),
    });
    if(this.fieldValue == "year") {
	let seen= {};
	this.dates = [];
	records.forEach(r=>{
	    let year = r.getDate().getUTCFullYear();
	    if(!seen[year]) {
		seen[year] = true;
		this.dates.push(year);
	    }
	});
	this.dates.sort();
	this.setRange(this.dates[0],this.dates[this.dates.length-1]);
    }


    this.convertAlpha = this.getProperty("convertColorAlpha",false);
    if(this.convertAlpha) {
	if(!Utils.isDefined(this.getProperty("alphaSourceMin"))) {
	    var min = 0, max=0;
	    records.forEach((record,idx)=>{
		var tuple = record.getData();
		if(this.compareFields.length>0) {
		    this.compareFields.map((f,idx2)=>{
			var v = tuple[f.getIndex()];
			if(isNaN(v)) return;
			min = idx==0 && idx2==0?v:Math.min(min,v);
			max = idx==0 && idx2==0?v:Math.max(max,v);
		    });
		} else if (this.index=0) {
		    var v = tuple[this.index];
		    if(isNaN(v)) return;
		    min = idx==0?v:Math.min(min,v);
		    max = idx==0?v:Math.max(max,v);
		}
	    });
	    this.alphaSourceMin = min;
	    this.alphaSourceMax = max;
	} else {
	    this.alphaSourceMin = +this.getProperty("alphaSourceMin",40);
	    this.alphaSourceMax = +this.getProperty("alphaSourceMax",80);
	}
	this.alphaTargetMin = +this.getProperty("alphaTargetMin",0); 
	this.alphaTargetMax = +this.getProperty("alphaTargetMax",1); 
    }

    this.convertIntensity = this.getProperty("convertColorIntensity",false);
    if(this.convertIntensity) {
	if(!Utils.isDefined(this.getProperty("intensitySourceMin"))) {
	    var min = 0, max=0;
	    records.forEach((record,idx)=>{
		var tuple = record.getData();
		if(this.compareFields.length>0) {
		    this.compareFields.map((f,idx2)=>{
			var v = tuple[f.getIndex()];
			if(isNaN(v)) return;
			min = idx==0 && idx2==0?v:Math.min(min,v);
			max = idx==0 && idx2==0?v:Math.max(max,v);
		    });
		} else if (this.index=0) {
		    var v = tuple[this.index];
		    if(isNaN(v)) return;
		    min = idx==0?v:Math.min(min,v);
		    max = idx==0?v:Math.max(max,v);
		}
	    });
	    this.intensitySourceMin = min;
	    this.intensitySourceMax = max;
	} else {
	    this.intensitySourceMin = +this.getProperty("intensitySourceMin",80);
	    this.intensitySourceMax = +this.getProperty("intensitySourceMax",40);
	}
	this.intensityTargetMin = +this.getProperty("intensityTargetMin",1); 
	this.intensityTargetMax = +this.getProperty("intensityTargetMax",0); 
    }

    if (this.display.percentFields != null) {
        this.pctFields = this.display.percentFields.split(",");
    }

    let colors = defaultColorTable || this.display.getColorTable(true,[colorByAttr +".colorTable","colorTable"]);
    if(!colors && colorByAttr) {
	let c = this.display.getProperty(colorByAttr +".colors");
	if(c) colors = c.split(",");
    }
    
//    if(!colors && this.hasField()) {
//	colors = this.display.getColorTable(true,"colorTable");
//    }

    if(!colors) {
	var c = this.getProperty(colorByAttr +".colors");
	if(c)
	    colors = c.split(",");
    }


    if(!colors)
	colors = this.display.getColorTable(true);
    this.colors = colors;

    if(this.hasField() && !colors) {
//	this.index = -1;
//	return;
    }



    if (!this.colors && this.display.colors && this.display.colors.length > 0) {
        this.colors = source.colors;
        if (this.colors.length == 1 && Utils.ColorTables[this.colors[0]]) {
            this.colors = Utils.ColorTables[this.colors[0]].colors;
        }
    }

    if (this.colors == null) {
        this.colors = Utils.ColorTables.grayscale.colors;
    }


    if(!this.field) {
	for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            if (field.getId() == this.id || ("#" + (i + 1)) == this.id) {
		this.field = field;
            }
	}
    }

    if(!this.field) {
	if(this.id == "hour")
	    this.timeField="hour";
	else if(this.id == "day")
	    this.timeField="day";	
    }


    if(this.field && this.field.isString()) this.isString = true;
    this.index = this.field != null ? this.field.getIndex() : -1;
    this.stringMap = this.display.getColorByMap(colorByMapProp);
    if(this.index>=0 || this.timeField) {
	let min = NaN;
	let max = NaN;
	records.forEach((record,idx)=>{
            let tuple = record.getData();
	    let v;
            if(this.timeField) {
		if(this.timeField=="hour")
		    v = record.getTime().getHours();
		else
		    v = record.getTime().getTime();
	    } else {
		v = tuple[this.index];		
	    }
            if (this.isString) {
		if (!Utils.isDefined(this.colorByMap[v])) {
		    var index = this.colorByValues.length;
                    this.colorByValues.push(v);
                    var color  = index>=this.colors.length?this.colors[this.colors.length-1]:this.colors[index];
		    this.colorByMap[v] = color;
                    this.setRange(1,  this.colorByValues.length, true);
		}
		return;
	    }
            if (this.excludeZero && v === 0) {
		return;
            }
	    min = Utils.min(min,v);
	    max = Utils.max(max,v);
	});
//	console.log("minmax:" + min +" " + max);
	this.minValue =min;
	this.maxValue =max;	
	this.origRange = [min,max];
    }

    if (this.display.showPercent) {
        this.setRange(0, 100,true);
    }

    var steps = this.getProperty("Steps");

    if(steps) {
	this.steps = steps.split(",");
    }



    this.colorByLog = this.getProperty("Log", false);
    this.colorByLog10 = this.getProperty("Log10", false);
    this.colorByLog2 = this.getProperty("Log2", false);
    if(this.colorByLog) {
	this.colorByFunc = Math.log;
    }   else if(this.colorByLog10) {
	this.colorByFunc = Math.log10;
    }   else if(this.colorByLog2) {
	this.colorByFunc = Math.log2;
    }

    this.setRange(this.getProperty("Min", this.minValue),
		  this.getProperty("Max", this.maxValue), true);

    this.range = this.maxValue - this.minValue;
    this.toMinValue = this.getProperty("ToMin", this.toMinValue);
    this.toMaxValue = this.getProperty("ToMax", this.toMaxValue);
    this.enabled = this.timeField!=null || (this.getProperty("doColorBy",true) && this.index>=0);
}


ColorByInfo.prototype = {
    getProperty: function(prop, dflt, debug) {
	if(this.properties[prop]) return this.properties[prop];
	if(this.debug) console.log("getProperty:" + prop);
	for(let i=0;i<this.propPrefix.length;i++) {
	    this.display.debugGetProperty = debug;
	    if(this.debug) console.log("\t" + this.propPrefix[i]+prop);
	    let v = this.display.getProperty(this.propPrefix[i]+prop);
	    this.display.debugGetProperty = false;
	    if(Utils.isDefined(v)) return v;
	}
	return dflt;
    },
    isEnabled: function() {
	return this.enabled;
    },
    displayColorTable: function(width,force, domId) {
	if(!this.getProperty("showColorTable",true)) return;
	if(this.compareFields.length>0) {
	    var legend = "";
	    this.compareFields.map((f,idx)=>{
		legend += HtmlUtils.div([STYLE,HU.css('display','inline-block','width','15px','height','15px','background', this.colors[idx])]) +" " +
		    f.getLabel() +" ";
	    });
	    let dom = this.display.jq(domId || ID_COLORTABLE);
	    dom.html(HtmlUtils.div([STYLE,HU.css('text-align','center','margin-top','5px')], legend));
	}
	if(!force && this.index<0) return;
	if(this.stringMap) {
	    var colors = [];
	    this.colorByValues= [];
	    for (var i in this.stringMap) {
		this.colorByValues.push(i);
		colors.push(this.stringMap[i]);
	    }
	    this.display.displayColorTable(colors, domId || ID_COLORTABLE, this.origMinValue, this.origMaxValue, {
		colorByInfo:this,
		width:width,
		stringValues: this.colorByValues});
	} else {
	    var colors = this.colors;
	    if(this.getProperty("clipColorTable",true) && this.colorByValues.length) {
		var tmp = [];
		for(var i=0;i<this.colorByValues.length && i<colors.length;i++) 
		    tmp.push(this.colors[i]);
		colors = tmp;
	    }
	    this.display.displayColorTable(colors, domId || ID_COLORTABLE, this.origMinValue, this.origMaxValue, {
		colorByInfo:this,
		width:width,
		stringValues: this.colorByValues
	    });
	}
    },
    resetRange: function() {
	if(this.origRange) {
	    this.setRange(this.origRange[0],this.origRange[1]);
	}
    },
    setRange: function(minValue,maxValue, force) {
//	console.log(" setRange: min:" + minValue + " max:" + maxValue);
	if(!force && this.overrideRange) return;
	this.origMinValue = minValue;
	this.origMaxValue = maxValue;
	if (this.colorByFunc) {
	    if (minValue < 0) {
		this.colorByOffset =  -minValue;
	    } else if(minValue == 0) {
		this.colorByOffset =  1;
	    }
//	    if(minValue>0)
		minValue = this.colorByFunc(minValue + this.colorByOffset);
//	    if(maxValue>0)
		maxValue = this.colorByFunc(maxValue + this.colorByOffset);
	}
	this.minValue = minValue;
	this.maxValue = maxValue;
	this.range = maxValue - minValue;
	if(!this.origRange) {
	    this.origRange = [minValue, maxValue];
	}
//	console.log("min/max:" + this.minValue +" " + this.maxValue);
    },
    getValuePercent: function(v) {
	let perc =   (v - this.minValue) / this.range;
	if(this.inverse) perc = 1-perc;
	return perc;
    },
    scaleToValue: function(v) {
	let perc = this.getValuePercent(v);
	return this.toMinValue + (perc*(this.toMaxValue-this.toMinValue));
    },
    getColorFromRecord: function(record, dflt) {
	if(this.display.getFilterHighlight() && !record.isHighlight(this.display)) {
	    return this.display.getProperty("unhighlightColor","#eee");
	}

	if(this.colorThresholdField && this.display.selectedRecord) {
	    let v=this.display.selectedRecord.getValue(this.colorThresholdField.getIndex());
	    let v2=record.getValue(this.colorThresholdField.getIndex());
	    if(v2>v) return this.aboveColor;
	    else return this.belowColor;
	}

	if (this.index >= 0) {
	    let value = record.getData()[this.index];
	    return  this.getColor(value, record);
	} else if(this.timeField) {
	    let value;
	    if(this.timeField=="hour") {
		value = record.getTime().getHours();
	    }  else {
		value = record.getTime().getTime();
	    }
//	    console.log(value);
	    return  this.getColor(value, record);
	} 
	if(this.fieldValue == "year") {
	    let value = record.getDate().getUTCFullYear();
	    return this.getColor(value, record);
	}
	return dflt;
    },
    hasField: function() {
	return this.index>=0;
    },
    getColor: function(value, pointRecord) {
	if(this.display.getFilterHighlight() && pointRecord && !pointRecord.isHighlight(this.display)) {
	    return this.display.getUnhighlightColor();
	}

	var percent = 0.5;
        if (this.showPercent) {
            var total = 0;
            var data = pointRecord.getData();
            for (var j = 0; j < data.length; j++) {
                var ok = this.fields[j].isNumeric() && !this.fields[j].isFieldGeo();
                if (ok && this.pctFields != null) {
                    ok = this.pctFields.indexOf(this.fields[j].getId()) >= 0 ||
                        this.pctFields.indexOf("#" + (j + 1)) >= 0;
                }
                if (ok) {
                    total += data[j];
                }
            }
            if (total != 0) {
                percent =  value / total * 100;
                percent = (percent - this.minValue) / (this.maxValue - this.minValue);
            }
        } else {
            var v = value;
	    if(this.stringMap) {
		var color = this.stringMap[value];
		if(!Utils.isDefined(color)) {
		    return this.stringMap["default"];
		}
		return color;
	    }
            if (this.isString) {
                color = this.colorByMap[v];
		if(color) return color;
            }
	    let tmp = v;
            v += this.colorByOffset;
            if (this.colorByFunc && v>0) {
                v = this.colorByFunc(v);
            }
            percent = this.range?(v - this.minValue) / this.range:0.5;
//	    if(tmp>3 && tmp<6)
//		console.log("ov:" + tmp  +" v:" + v + " perc:" + percent);
        }



	var index=0;
	if(this.steps) {
	    for(;index<this.steps.length;index++) {
		if(v<=this.steps[index]) {
		    break;
		}
	    }
	} else {
	    index = parseInt(percent * this.colors.length);
	}
//	console.log("v:" + v +" index:" + index +" colors:" + this.colors);
        if (index >= this.colors.length) index = this.colors.length - 1;
        else if (index < 0) index = 0;
	if(this.stringMap) {
	    var color = this.stringMap[value];
	    if(!Utils.isDefined(color)) {
		return this.stringMap["default"];
	    }
	    return color;
	} else {
	    return this.colors[index];
	}
	return null;
    },
    convertColor: function(color, colorByValue) {
	color = this.convertColorIntensity(color, colorByValue);
	color = this.convertColorAlpha(color, colorByValue);
	return color;
    },
    convertColorIntensity: function(color, colorByValue) {
	if(!this.convertIntensity) return color;
	percent = (colorByValue-this.intensitySourceMin)/(this.intensitySourceMax-this.intensitySourceMin);
	intensity=this.intensityTargetMin+percent*(this.intensityTargetMax-this.intensityTargetMin);
	var result =  Utils.pSBC(intensity,color);
	//		    console.log(color +" " + result +" intensity:" + intensity +" min:" + this.intensityTargetM
	return result || color;
    },
    convertColorAlpha: function(color, colorByValue) {
	if(!this.convertAlpha) return color;
	percent = (colorByValue-this.alphaSourceMin)/(this.alphaSourceMax-this.alphaSourceMin);
	alpha=this.alphaTargetMin+percent*(this.alphaTargetMax-this.alphaTargetMin);
	var result =  Utils.addAlphaToColor(color, alpha);
	return result || color;
    }
}

function drawSparkLine(display, dom,w,h,data, records,min,max,colorBy,attrs, margin) {
    if(!attrs) attrs = {};
    if(!margin)
	margin = { top: 0, right: 0, bottom: 0, left: 0 };
    const INNER_WIDTH  = w - margin.left - margin.right;
    const INNER_HEIGHT = h - margin.top - margin.bottom;
    const BAR_WIDTH  = w / data.length;
    const x    = d3.scaleLinear().domain([0, data.length]).range([0, INNER_WIDTH]);
    const y    = d3.scaleLinear().domain([min, max]).range([INNER_HEIGHT, 0]);
    const recty    = d3.scaleLinear().domain([min, max]).range([0,INNER_HEIGHT]);

    var tt = d3.select("body").append("div")	
	.attr(CLASS, "sparkline-tooltip")				
	.style("opacity", 0);

    const svg = d3.select(dom).append('svg')
	  .attr('width', w)
	  .attr('height', h)
	  .append('g')
	  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
    const line = d3.line()
	  .x((d, i) => x(i))
	  .y(d => y(d));

    let lineColor = attrs.lineColor||display.getProperty("sparklineLineColor","#000");
    let barColor = attrs.barColor ||display.getProperty("sparklineBarColor","MediumSeaGreen");	    
    let circleColor = attrs.circleColor ||display.getProperty("sparklineCircleColor","#000");
    let circleRadius = attrs.circleRadius ||display.getProperty("sparklineCircleRadius",1);
    let lineWidth = attrs.lineWidth ||display.getProperty("sparklineLineWidth",1);
    let defaultShowEndPoints = true;
    let getColor = (d,i,dflt)=>{
	return colorBy?colorBy.getColorFromRecord(records[i], dflt):dflt;
    };
    let showBars = attrs.showBars|| display.getProperty("sparklineShowBars",false);

    

    svg.append('line')
	.attr('x1',0)
	.attr('y1', 0)
	.attr('x2', 0)
	.attr('y2', h)    
	.attr("stroke-width", 1)
    	.attr("stroke", '#ccc');

    svg.append('line')
	.attr('x1',0)
	.attr('y1', h)
	.attr('x2', w)
	.attr('y2', h)    
	.attr("stroke-width", 1)
    	.attr("stroke", '#ccc');
    



    let getNum = n=>{
	if(isNaN(n)) return 0;
	return n;
    };

    if(showBars) {
	defaultShowEndPoints = false;
	svg.selectAll('.bar').data(data)
	    .enter()
	    .append('rect')
	    .attr('class', 'bar')
	    .attr('x', (d, i) => getNum(x(i)))
	    .attr('y', d => getNum(y(d)))
	    .attr('width', BAR_WIDTH)
	    .attr('height', d => getNum(h-y(d)))
	    .attr('fill', (d,i)=>getColor(d,i,barColor))
	    .style("cursor", "pointer")
    }


    if(attrs.showLines|| display.getProperty("sparklineShowLines",true)) {
	svg.selectAll('line').data(data).enter().append("line")
	    .attr('x1', (d,i)=>{return x(i)})
	    .attr('y1', (d,i)=>{return y(d)})
	    .attr('x2', (d,i)=>{return x(i+1)})
	    .attr('y2', (d,i)=>{return y(i<data.length-1?data[i+1]:data[i])})
	    .attr("stroke-width", lineWidth)
            .attr("stroke", (d,i)=>{
		if(isNaN(d)) return "rgba(0,0,0,0)";
		return getColor(d,i,lineColor)
	    })
	    .style("cursor", "pointer");
    }


    if(attrs.showCircles || display.getProperty("sparklineShowCircles",false)) {
	svg.selectAll('circle').data(data).enter().append("circle")
	    .attr('r', (d,i)=>{return isNaN(d)?0:circleRadius})
	    .attr('cx', (d,i)=>{return getNum(x(i))})
	    .attr('cy', (d,i)=>{return getNum(y(d))})
	    .attr('fill', (d,i)=>getColor(d,i,circleColor))
	    .style("cursor", "pointer");
    }



    if(attrs.showEndpoints || display.getProperty("sparklineShowEndPoints",defaultShowEndPoints)) {
	let fidx=0;
	while(isNaN(data[fidx]) && fidx<data.length) fidx++;
	let lidx=data.length-1;
	while(isNaN(data[lidx]) && lidx>=0) lidx--;	
	svg.append('circle')
	    .attr('r', attrs.endPointRadius|| display.getProperty("sparklineEndPointRadius",2))
	    .attr('cx', x(fidx))
	    .attr('cy', y(data[fidx]))
	    .attr('fill', attrs.endPoint1Color || display.getProperty("sparklineEndPoint1Color") || getColor(data[0],0,display.getProperty("sparklineEndPoint1Color",'steelblue')));
	svg.append('circle')
	    .attr('r', attrs.endPointRadius|| display.getProperty("sparklineEndPointRadius",2))
	    .attr('cx', x(lidx))
	    .attr('cy', y(data[lidx]))
	    .attr('fill', attrs.endPoint2Color || display.getProperty("sparklineEndPoint2Color")|| getColor(data[data.length-1],data.length-1,display.getProperty("sparklineEndPoint2Color",'tomato')));
    }
    let _display = display;
    let doTooltip = display.getProperty("sparklineDoTooltip", true)  || attrs.doTooltip;
    svg.on("click", function() {
	var coords = d3.mouse(this);
	if(records) {
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(record)
		_display.propagateEventRecordSelection({select:true,record: record});
	}
    });



    if(doTooltip) {
	svg.on("mouseover", function() {
	    if(!records) return;
	    var coords = d3.mouse(this);
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(!record) return;
	    let html = _display.getRecordHtml(record);
	    let ele = $(dom);
	    let offset = ele.offset().top + ele.height();
	    let left = ele.offset().left;
	    tt.transition().duration(200).style("opacity", .9);		
	    tt.html(html)
		.style("left", left + "px")		
		.style("top", offset + "px");	
	})
	    .on("mouseout", function(d) {		
		tt.transition()		
		    .duration(500)		
		    .style("opacity", 0);
	    });
    }
}



function drawDots(display, dom,w,h,data, range, colorBy,attrs, margin) {
    attrs = attrs ||  {};
    margin = margin || { top: 0, right: 0, bottom: 0, left: 0 };
    const INNER_WIDTH  = w - margin.left - margin.right;
    const INNER_HEIGHT = h - margin.top - margin.bottom;
    const x    = d3.scaleLinear().domain([range.minx, range.maxx]).range([0, INNER_WIDTH]);
    const y    = d3.scaleLinear().domain([range.miny, range.maxy]).range([INNER_HEIGHT, 0]);
    var tt = d3.select("body").append("div").attr(CLASS, "sparkline-tooltip").style("opacity", 0);
    const svg = d3.select(dom).append('svg')
	  .attr('width', w)
	  .attr('height', h)
	  .append('g')
//	  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    let circleColor = attrs.circleColor ||display.getProperty("sparklineCircleColor","#000");
    let circleRadius = attrs.circleRadius ||display.getProperty("sparklineCircleRadius",1);
    let getColor = (d,i,dflt)=>{
	return "#000"
//	return colorBy?colorBy.getColorFromRecord(records[i], dflt):dflt;
    };
    console.log(JSON.stringify(range));

    let getNum = n=>{
	if(isNaN(n)) return 0;
	return n;
    };

    
    let recordMap = {};
    
    svg.selectAll('circle').data(data).enter().append("circle")
	.attr('r', (d,i)=>{return circleRadius})
	.attr('cx', (d,i)=>{return getNum(x(d.x))})
	.attr('cy', (d,i)=>{return getNum(y(d.y))})
	.attr('fill', (d,i)=>{return getColor(d,i,circleColor)})
	.attr(RECORD_ID, (d,i)=>{
	    return "XX";
	    recordMap[d.record.getId()] =d.record;
	    return d.record.getId()})
	.style("cursor", "pointer");

    let _display = display;
    let doTooltip = display.getProperty("sparklineDoTooltip", true)  || attrs.doTooltip;
    svg.on("click", function() {
	var coords = d3.mouse(this);
	if(records) {
	    let record = records[Math.round(x.invert(coords[0]))]
	    if(record)
		_display.propagateEventRecordSelection({select:true,record: record});
	}
    });


    if(doTooltip) {
	svg.on("mouseover", function() {
	    d3.select(this).attr("r", 10).style("fill", "red");
	    let ele = $(dom);
	    ele.attr('r', 20);
	    console.log("mouse over:" + d3.select(this).attr(RECORD_ID));
	    return
	    let record = recordMap[ele.attr(RECORD_ID)];
	    console.log(ele.attr(RECORD_ID) +" " + record);
	    var coords = d3.mouse(this);
	    if(!record) return;
	    let html = _display.getRecordHtml(record);
	    let offset = ele.offset().top + ele.height();
	    let left = ele.offset().left;
	    tt.transition().duration(200).style("opacity", .9);		
	    tt.html(html)
		.style("left", left + "px")		
		.style("top", offset + "px");	
	})
	    .on("mouseout", function(d) {		
		tt.transition()		
		    .duration(500)		
		    .style("opacity", 0);
	    });
    }
}




function drawPieChart(display, dom,width,height,array,min,max,colorBy,attrs) {
    if(!attrs) attrs = {};
    let margin = Utils.isDefined(attrs.margin)?attrs.margin:4;
    let colors = attrs.pieColors||Utils.ColorTables.cats.colors;

    var radius = Math.min(width, height) / 2 - margin
    var svg = d3.select(dom)
	.append("svg")
	.attr("width", width)
	.attr("height", height)
	.append("g")
	.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    var data = {};
    array.forEach(tuple=>{
	data[tuple[0]] = tuple[1];
    })

    // set the color scale
    var color = d3.scaleOrdinal()
	.domain(data)
	.range(colors)

    // Compute the position of each group on the pie:
    var pie = d3.pie()
	.value(function(d) {return d.value; })
    var data_ready = pie(d3.entries(data))

    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svg
	.selectAll('whatever')
	.data(data_ready)
	.enter()
	.append('path')
	.attr('d', d3.arc()
	      .innerRadius(0)
	      .outerRadius(radius)
	     )
	.attr('fill', function(d){ return(color(d.data.key)) })
	.attr("stroke", "black")
	.style("stroke-width", "1px")
	.style("opacity", 0.7)
}





function SizeBy(display,records) {
    this.display = display;
    if(!records) records = display.filterData();
    let pointData = this.display.getPointData();
    let fields = pointData.getRecordFields();
    $.extend(this, {
        id: this.display.getProperty("sizeBy"),
        minValue: 0,
        maxValue: 0,
        field: null,
        index: -1,
        isString: false,
        stringMap: {},
    });


    let sizeByMap = this.display.getProperty("sizeByMap");
    if (sizeByMap) {
        let toks = sizeByMap.split(",");
        for (let i = 0; i < toks.length; i++) {
            let toks2 = toks[i].split(":");
            if (toks2.length > 1) {
                this.stringMap[toks2[0]] = toks2[1];
            }
        }
    }

    for (let i = 0; i < fields.length; i++) {
        let field = fields[i];
        if (field.getId() == this.id || ("#" + (i + 1)) == this.id) {
            this.field = field;
	    if (field.isString()) this.isString = true;
        }
    }

    this.index = this.field != null ? this.field.getIndex() : -1;
    if (!this.isString && this.field) {
	let col = this.display.getColumnValues(records, this.field);
	this.minValue = col.min;
	this.maxValue =  col.max;
	if(Utils.isDefined(this.display.getProperty("sizeByMin"))) {
	    this.minValue = +this.display.getProperty("sizeByMin",0)
	}
	if(Utils.isDefined(this.display.getProperty("sizeByMax"))) {
	    this.maxValue = +this.display.getProperty("sizeByMax",0)
	}
    }

    if(this.display.getProperty("sizeBySteps")) {
	this.steps = [];
	this.display.getProperty("sizeBySteps").split(",").forEach(tuple=>{
	    let [value,size] = tuple.split(":");
	    this.steps.push({value:+value,size:+size});
	});
    }
    this.radiusMin = parseFloat(this.display.getProperty("sizeByRadiusMin", -1));
    this.radiusMax = parseFloat(this.display.getProperty("sizeByRadiusMax", -1));
    this.offset = 0;
    this.sizeByLog = this.display.getProperty("sizeByLog", false);
    this.origMinValue =   this.minValue;
    this.origMaxValue =   this.maxValue; 

    this.maxValue = Math.max(this.minValue,this.maxValue);
    if (this.sizeByLog) {
	this.func = Math.log;
        if (this.minValue < 1) {
            this.offset = 1 - this.minValue;
        }
        this.minValue = this.func(this.minValue + this.offset);
        this.maxValue = this.func(this.maxValue + this.offset);
    }
}

SizeBy.prototype = {
    getMaxSize:function() {
	return this.getSizeFromValue(this.origMaxValue);
    },
    getSize: function(values, dflt, func) {
        if (this.index <= 0) {
	    return dflt;
	}
        let value = values[this.index];
	let size = this.getSizeFromValue(value,func);
//	console.log("G: " + value +  " s:" + size);
	return size;
    },

    getSizeFromValue: function(value,func, debug) {	
	if(this.steps) {
	    if(value<=this.steps[0].value) return this.steps[0].size;
	    for(let i=1;i<this.steps.length;i++) {
		if(value>this.steps[i-1].value && value<=this.steps[i].value ) return this.steps[i].size;
	    }
	    return this.steps[this.steps.length-1].size;
	}
        if (this.isString) {
	    let size;
            if (Utils.isDefined(this.stringMap[value])) {
                let v = parseInt(this.stringMap[value]);
                size = v;
            } else if (Utils.isDefined(this.stringMap["*"])) {
                let v = parseInt(this.stringMap["*"]);
                size = v;
            } 
	    if(isNaN(size)) size =  this.radiusMin;
	    if(func) func(NaN,size);
	    return size;
        } else {
            let denom = this.maxValue - this.minValue;
            let v = value + this.offset;
            if (this.func) v = this.func(v);
            let percent = (denom == 0 ? NaN : (v - this.minValue) / denom);
	    let size;
            if (this.radiusMax >= 0 && this.radiusMin >= 0) {
                size =  Math.round(this.radiusMin + percent * (this.radiusMax - this.radiusMin));
            } else {
                size = 6 + parseInt(15 * percent);
            }
	    if(debug) console.log("value:" + value +" v:" + v +" size:" + size);
	    if(isNaN(size)) size =  this.radiusMin;
	    if(func) func(percent, size);
	    return size;
        }
    },
    getLegend: function(cnt,bg,vert) {
	let html = "";
	if(this.index<0) return "";
	if(this.steps) {
	    this.steps.forEach(step=>{
		let dim = step.size*2+"px";
		let v = step.value;
		html += HU.div([CLASS,"display-size-legend-item"], HU.center(HU.div([STYLE,HU.css("height", dim,"width",dim,
												  "background-color",bg||"#bbb",
												  "border-radius","50%"
												 )])) + v);

		if(vert) html+="<br>";
	    });
	} else {
	    for(let i=0;i<=cnt;i++) {
		let v = this.origMinValue+ i/cnt*(this.origMaxValue-this.origMinValue);
		let size  =this.getSizeFromValue(v,null,false);
		if(isNaN(size) || size==0) continue;
		v = this.display.formatNumber(v);
		let dim = size*2+"px";
		html += HU.div([CLASS,"display-size-legend-item"], HU.center(HU.div([STYLE,HU.css("height", dim,"width",dim,
												  "background-color",bg||"#bbb",
												  "border-radius","50%"
												 )])) + v);

		if(vert) html+="<br>";
	    }
	}
	return HU.div([CLASS,"display-size-legend"], html);
    }

}




function Annotations(display,records) {
    this.display = display;
    if(!records) records = this.display.filterData();
    let pointData = this.display.getPointData();
    let fields = pointData.getRecordFields();
    this.labelField = this.display.getFieldById(null,this.display.getProperty("annotationLabelField"));
    this.fields = this.display.getFieldsByIds(null,this.display.getProperty("annotationFields"));
    let prop = this.display.getProperty("annotations");
    if(prop) this.fields = [];
    this.map = {}
    let add = (record,index,annotation)=>{
	annotation.record = record;
	if(!this.map[index])
	    this.map[index] = [];
	this.map[index].push(annotation);
	if(!this.map[record.getId()])
	    this.map[record.getId()] = [];
	this.map[record.getId()].push(annotation);	
    }
    if(prop) {
	this.annotations=[];
	this.legend = "";
	let labelCnt = 0;
	let toks = prop.split(";");
	this.hasRange = false;
	for(let i=0;i<toks.length;i++) {
	    let toks2 = toks[i].split(",");
	    //index,label,description,url
	    if(toks2.length<2) continue;
	    let index = toks2[0].trim();
	    let label = toks2[1];
	    if(label.trim() == "") {
		labelCnt++;
		label  =""+labelCnt;
	    }
	    let desc = toks2.length<2?"":toks2[2];
	    let url = toks2.length<3?null:toks2[3];
	    let isDate = false;
	    let annotation = {label: label,description: desc,toString:function() {return this.label+" " + this.description;}   };
	    this.annotations.push(annotation);
	    if(index.match(/^[0-9]+$/)) {
		index = parseFloat(index);
	    } else {
		let index2 = null;
		if(index.indexOf(":")>=0) {
		    index2 = index.split(":")[1];
		    index = index.split(":")[0];
		}
		
		if(index=="today") {
		    index = new Date();
		} else {
		    index = Utils.parseDate(index,false);
		}
		if(index2) {
		    this.hasRange = true;
 		    if(index2=="today") {
			index2 = Utils.formatDateYYYYMMDD(new Date());
		    } else {
			index2 = Utils.parseDate(index2,false);

		    }
		    annotation.index2 = index2.getTime();
		}
		isDate = true;
	    }
	    annotation.index = isDate?index.getTime():index;
	    let legendLabel = desc;
	    if(url!=null) {
		legendLabel = HU.href(url, legendLabel,["target","_annotation"]);
	    }
	    this.legend+= HU.b(label)+":" + legendLabel+" ";
	}
	for(let aidx=0;aidx<this.annotations.length;aidx++) {
	    let annotation = this.annotations[aidx];
	    let minIndex = null;
	    let minRecord = null;
	    let minDistance = null;
	    for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
		let ele = records[rowIdx];
		let record = ele.record?ele.record:ele;
		let row = this.display.getDataValues(records[rowIdx]);
		let index = row[0];
		if(index.v) index=  index.v;
		if(record) index = record.getTime();
		let distance =  Number.MAX_VALUE;
		if(annotation.index2) {
		    //range
 		    if(index>=annotation.index && index<=annotation.index2) {
			distance = 0;
		    } else {
			distance = Math.min(Math.abs(annotation.index-index),Math.abs(annotation.index2-index));
		    }
		    if(distance==0) {
			add(record,rowIdx,annotation);
		    }
		} else {
		    distance = Math.abs(annotation.index-index);
		}
		if(minIndex == null) {
		    minIndex = rowIdx;
		    minDistance = distance;
		    minRecord = record;
		} else {
		    if(distance<minDistance) {
			minIndex = rowIdx;
			minDistance = distance;
			minRecord = record;
		    }
		}
	    }
	    if(minIndex!=null) {
		add(minRecord,minIndex,annotation);

	    }
	}
    }
}

Annotations.prototype = {
    isEnabled: function() {
	return this.annotations!=null;
    },
    getAnnotations: function() {
	return this.annotations;
    },

    getAnnotationsFor: function(rowIdx) {
	return this.map[rowIdx];
    },
    getAnnotationFromDate: function(date) {
	let distance =  Number.MAX_VALUE;
	let minAnnotation = null;
	let minDistance = null;
	let time = date.getTime();
	for(let aidx=0;aidx<this.annotations.length;aidx++) {
	    let annotation = this.annotations[aidx];
	    if(annotation.index2) {
 		if(time>=annotation.index && time<=annotation.index2) {
		    return annotation;
		}
	    } else {
		distance = Math.abs(annotation.index-time);
		if(minAnnotation == null) {
		    minAnnotation = annotation;
		    minDistance = distance;
		} else {
		    if(distance<minDistance) {
			minAnnotation = annotation;
			minDistance = distance;
		    }
		}
	    }
	}
	return minAnnotation;
    },
    getLegend: function() {
	return this.legend;
    },
    getShowLegend: function() {
	return 	this.display.getProperty("showAnnotationsLegend");
    },
    hasFields: function() {
	return this.fields && this.fields.length>0;
    },
    getFields: function() {
	return this.fields;
    }
    

}



var Gfx = {
    gridData: function(gridId,fields, records,args) {
	if(!args) args = {};
	if(isNaN(args.cellSize) || args.cellSize == null)
	    args.cellSize = args.cellSizeX;

	if(isNaN(args.cellSizeX) || args.cellSizeX == null)
	    args.cellSizeX= args.cellSize;
	if(isNaN(args.cellSizeY) || args.cellSizeY == null)
	    args.cellSizeY= args.cellSizeX;
	let opts = {
	    shape:"circle",
	    color:"blue",
	    w:800,
	    h:400,
	    scale:1,
	    cellSize:2,
	    cellSizeX:2,
	    cellSizeY:2,
	    operator:"average"
	}
	$.extend(opts,args);
	//	console.log(JSON.stringify(opts,null,2));
	let id = HtmlUtils.getUniqueId();
	opts.scale=+opts.scale;
	let scale = opts.scale;
//	scale=1;
	opts.w*=opts.scale;
	opts.h*=opts.scale;
	$(document.body).append('<canvas style="display:none;" id="' + id +'" width="' + opts.w+'" height="' + opts.h +'"></canvas>');
	let canvas = document.getElementById(id);
	var ctx = canvas.getContext("2d");
	//	ctx.strokeStyle= "#000";
//	ctx.fillStyle= "rgba(255,0,0,0.25)";	
//	ctx.fillRect(0,0,canvas.width,canvas.height);

	let cnt = 0;
	let earthWidth = args.bounds.east-args.bounds.west;
	let earthHeight= args.bounds.north-args.bounds.south;
	ctx.font = opts.cellFont || "8pt Arial;"
	var gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
	gradient.addColorStop(0,'white');
	gradient.addColorStop(1,'red');

	let scaleX = (lat,lon)=>{
	    return Math.floor(opts.w*(lon-args.bounds.west)/earthWidth);
	};
	let scaleY;
	if(opts.display && opts.display.map) {
	    //Get the global bounds so we can map down to the image
	    var n1 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,85));
	    var s1 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,-85));
	    var n2 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,opts.bounds.north));
	    var s2 = opts.display.map.transformLLPoint(MapUtils.createLonLat(opts.bounds.east,opts.bounds.south));
//	    console.log("n1:" + n1 +" s2:" + s1 +" n2:" + n2 +" s2:" + s2 +" bounds:" + JSON.stringify(opts.bounds));
	    scaleY = (lat,lon)=> {
		var pt = opts.display.map.transformLLPoint(MapUtils.createLonLat(lon,lat));
		var dy = n2.lat-pt.lat;
		var perc = dy/(n2.lat-s2.lat)
		return Math.floor(perc*opts.h);
	    };
	} else {
	    scaleY= (lat,lon)=> {
		return Math.floor(opts.h*(args.bounds.north-lat)/earthHeight);		
	    }
	}
	ctx.lineStyle = "#000";
	if(opts.doHeatmap) {
	    let cols = Math.floor(opts.w/opts.cellSizeX);
	    let rows = Math.floor(opts.h/opts.cellSizeY);
	    let points = [];
	    records.forEach((record,idx)=>{
		let lat = record.getLatitude();
		let lon = record.getLongitude();
		let x = scaleX(lat,lon);
		let y = scaleY(lat,lon);
//		console.log("x:" + x +" " + y +" lat:" + lat +" " + lon);
		record[gridId+"_coordinates"] = {x:x,y:y};
		let colorValue = 0;
		if(opts.colorBy && opts.colorBy.index>=0) {
		    colorValue = record.getValue(opts.colorBy.index);
		}
		let lengthValue = 0;
		if(opts.lengthBy && opts.lengthBy.index>=0) {
		    lengthValue = record.getValue(opts.lengthBy.index);
		}		
		x =Math.floor(x/opts.cellSizeX);
		y =Math.floor(y/opts.cellSizeY);
		if(x<0) x=0;
		if(y<0) y=0;
		if(x>=cols) x=cols-1;
		if(y>=rows) y=rows-1;
		points.push({x:x,y:y,colorValue:colorValue,r:record});
//		console.log(x+" " + y +" " + colorValue);
	    });


	    let grid = Gfx.gridPoints(rows,cols,points,args);
	    opts.cellSizeX = +opts.cellSizeX;
	    opts.cellSizeY = +opts.cellSizeY;
	    this.applyFilter(opts,grid);
	    //get the new min/max from the filtered grid
	    let mm = this.getMinMaxGrid(grid,v=>v.v);
	    if(opts.colorBy) {
		if(!Utils.isDefined(opts.display.getProperty("colorByMin")))  {
		    opts.colorBy.setRange(mm.min,mm.max);
		}  
		opts.colorBy.index=0;
	    }

	    let countThreshold = opts.display.getProperty("hmCountThreshold",opts.operator=="count"?1:0);
	    let glyph = new Glyph(opts.display,
				  scale,
				  fields,
				  records,
				  {type:"rect",
				   canvasWidth:canvas.width,
				   canvasHeight: canvas.height,
				   colorByInfo:opts.colorBy,
				   width: opts.cellSizeX,
				   height: opts.cellSizeY,
				   stroke:false,
				   pos:"c",
				   dx:opts.cellSizeX/2,
				   dy:opts.cellSizeY/2,				   
				  },
				  "");
	    opts.shape = "rect";
	    for(var rowIdx=0;rowIdx<rows;rowIdx++)  {
		let row = grid[rowIdx];
		for(var colIdx=0;colIdx<cols;colIdx++)  {
		    let cell = row[colIdx];
		    let v = cell.v;
		    if(isNaN(v)) continue;
		    let x = colIdx*opts.cellSizeX;
		    let y = rowIdx*opts.cellSizeY;
		    if(cell.count>=countThreshold)
			glyph.draw(opts, canvas, ctx, x,y,{
			    colorValue:cell.v,
			    col:colIdx,row:rowIdx,cell:cell, grid:grid});
		}
	    }
	} else {
	    records.sort((a,b)=>{return b.getLatitude()-a.getLatitude()});
	    let glyphs=[];
	    let cnt = 1;
	    while(cnt<11) {
		let attr = opts.display.getProperty("glyph" + (cnt++));
		if(!attr)
		    continue;
		glyphs.push(new Glyph(opts.display,scale, fields,records,{
		    canvasWidth:canvas.width,
		    canvasHeight: canvas.height
		},attr));
	    }
	    glyphs.forEach(glyph=>{
		records.map((record,idx)=>{
		    let lat = record.getLatitude();
		    let lon = record.getLongitude();
		    let x = scaleX(lat,lon);
		    let y = scaleY(lat,lon);
		    record[gridId+"_coordinates"] = {x:x,y:y};
		    let colorValue = opts.colorBy? record.getData()[opts.colorBy.index]:null;
		    let lengthValue = opts.lengthBy? record.getData()[opts.lengthBy.index]:null;
		    glyph.draw(opts, canvas, ctx, x,y,{colorValue:colorValue, lengthValue:lengthValue,record:record});
		});
	    });
	}

	let alpha = opts.display.getProperty("colorTableAlpha",-1);
	//add in the color table alpha
	if(alpha>0) {
	    var image = ctx.getImageData(0, 0, opts.w, opts.h);
	    var imageData = image.data,
		length = imageData.length;
	    for(var i=3; i < length; i+=4){  
		if(imageData[i]) {
		    imageData[i] = alpha*255;
		}
	    }
	    image.data = imageData;
	    ctx.putImageData(image, 0, 0);
	}

	let img =  canvas.toDataURL("image/png");
	canvas.parentNode.removeChild(canvas);
	return img;
    },
    gridPoints: function(rows,cols,points,args) {
	let debug = displayDebug.gridPoints;
	let values = [];
	for(var rowIdx=0;rowIdx<rows;rowIdx++)  {
	    let row = [];
	    values.push(row);
	    for(var colIdx=0;colIdx<cols;colIdx++)  {
		row.push({v:NaN,count:0,total:0,min:NaN,max:NaN,t:""});
	    }
	}

	points.forEach((p,idx)=>{
	    let cell = values[p.y][p.x];
	    cell.min = cell.count==0?p.colorValue:Math.min(cell.min,p.colorValue);
	    cell.max = cell.count==0?p.colorValue:Math.max(cell.max,p.colorValue);
	    cell.count++;
	    cell.total += p.colorValue;
	});


	let minValue = NaN;
	let maxValue = NaN;
	let maxCount=0;
	let minCount=0;

	for(var rowIdx=0;rowIdx<rows;rowIdx++)  {
	    for(var colIdx=0;colIdx<cols;colIdx++)  {
		let cell = values[rowIdx][colIdx];
		if(cell.count==0) continue;
		let v;
		if(args.operator=="count")
		    v = cell.count;
		else if(args.operator=="min")
		    v =  cell.min;
		else if(args.operator=="max")
		    v =  cell.max;
		else if(args.operator=="total")
		    v =  cell.total;
		else
		    v =  cell.total/cell.count;
		cell.v = v;
		if(!isNaN(v)) {
		    minValue = isNaN(minValue)?v:Math.min(minValue,v);
		    maxValue = isNaN(maxValue)?v:Math.max(maxValue,v);
		}
		maxCount = Math.max(maxCount, cell.count);
		minCount = minCount==0?cell.count:Math.min(minCount, cell.count);
	    }
	}	
	if(debug)
	    console.log("operator:" + args.operator +" values:" + minValue +" - " + maxValue +" counts:" + minCount +" - " + maxCount);
	values.minValue = minValue;
	values.maxValue = maxValue;
	values.minCount = minCount;
	values.maxCount = maxCount;
	return values;
    },


    
    //This gets the value at row/col if its defined. else 0
    //    sum+=this.getGridValue(src,rowIdx,colIdx,t[0],t[1],t[2],cnt); 
    getGridValue:function(src,row,col,mult,total,goodones) {
	if(row>=0 && row<src.length && col>=0 && col<src[row].length) {
	    if(isNaN(src[row][col])) return 0;
	    total[0]+=mult;
	    goodones[0]++;
	    return src[row][col]*mult;
	}
	return 0;
    },
    applyKernel: function(src, kernel) {
	let result = this.cloneGrid(src,null,0);
	for(var rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = result[rowIdx];
	    for(var colIdx=0;colIdx<row.length;colIdx++)  {
		//		if(isNaN(row[colIdx])) continue;
		if(isNaN(row[colIdx])) row[colIdx] = 0;
		let total =[0];
		let goodones =[0];
		let sum = 0;
		kernel.every(t=>{
		    sum+=this.getGridValue(src,rowIdx+t[0],colIdx+t[1],t[2],total,goodones); 
		    return true;
		});
		if(goodones[0]>0)
		    row[colIdx] = sum/total[0];
		else
		    row[colIdx] = NaN;
	    }
	}
	return result;
    },
    blurGrid: function(type, src) {
	let kernels = {
	    average5: [
		[0,1,0],
		[1,1,1],
		[0,1,0],
	    ],
	    average9: [
		[1,1,1],
		[1,1,1],
		[1,1,1],
	    ],
	    average25:[
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
		[1,1,1,1,1],
	    ],
	    average49:[
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
		[1,1,1,1,1,1,1],
	    ],
	    gauss9:[
		[0.077847,0.123317,0.077847],
		[0.123317,0.195346,0.123317],
		[0.077847,0.123317,0.077847]
	    ],
	    gauss25:[
		[0.003765,0.015019,0.023792,0.015019,0.003765],
		[0.015019,0.059912,0.094907,0.059912,0.015019],
		[0.023792,0.094907,0.150342,0.094907,0.023792],
		[0.015019,0.059912,0.094907,0.059912,0.015019],
		[0.003765,0.015019,0.023792,0.015019,0.003765],
	    ],
	    gauss49: [
		[0.00000067 ,0.00002292 ,0.00019117 ,0.00038771 ,0.00019117 ,0.00002292 ,0.00000067],
		[0.00002292 ,0.00078633 ,0.00655965 ,0.01330373 ,0.00655965 ,0.00078633 ,0.00002292],
		[0.00019117 ,0.00655965 ,0.05472157 ,0.11098164 ,0.05472157 ,0.00655965 ,0.00019117],
		[0.00038771 ,0.01330373 ,0.11098164 ,0.22508352 ,0.11098164 ,0.01330373 ,0.00038771],
		[0.00019117 ,0.00655965 ,0.05472157 ,0.11098164 ,0.05472157 ,0.00655965 ,0.00019117],
		[0.00002292 ,0.00078633 ,0.00655965 ,0.01330373 ,0.00655965 ,0.00078633 ,0.00002292],
		[0.00000067 ,0.00002292 ,0.00019117 ,0.00038771 ,0.00019117 ,0.00002292 ,0.00000067]
	    ]
	}
	let a = kernels[type];
	if(!a) {
	    if(type.startsWith("average"))
		a=kernels.average5;
	    else if(type.startsWith("gauss"))
		a=kernels.gauss9;
	}
	if(!a) return src;
	return this.applyKernel(src, this.makeKernel(a));
    },
    makeKernel: function(kernel) {
	let a = [];
	let mid = (kernel.length-1)/2;
	for(let rowIdx=0;rowIdx<kernel.length;rowIdx++) {
	    let row = kernel[rowIdx];
	    let rowOffset = rowIdx-mid;
	    for(let colIdx=0;colIdx<row.length;colIdx++) {
		let colOffset = colIdx-mid;
		a.push([rowOffset,colOffset,kernel[rowIdx][colIdx]]);
	    }
	}
	return a;
    },
    printGrid: function(grid) {
	console.log("grid:");
	for(var rowIdx=0;rowIdx<grid.length;rowIdx++)  {
	    let row = grid[rowIdx];
	    let h = "";
	    for(var colIdx=0;colIdx<row.length;colIdx++)  {
		if(Utils.isDefined(row[colIdx].v))
		    h+=row[colIdx].v+",";
		else
		    h+=row[colIdx]+",";
	    }
	    console.log(h);
	}
    },
    applyFilter(opts, grid) {
	if(!opts.filter || opts.filter=="" || opts.filter=="none") {
	    return;
	}

	let copy = this.cloneGrid(grid,v=>v.v);
	let filtered = copy;
	let filterPasses = opts.display.getProperty("hmFilterPasses",1);
	for(var i=0;i<filterPasses;i++) {
	    filtered = this.blurGrid(opts.filter,filtered);
	}
	let filterThreshold = opts.display.getProperty("hmFilterThreshold",-999);
	for(var rowIdx=0;rowIdx<grid.length;rowIdx++)  {
	    let row = grid[rowIdx];
	    for(var colIdx=0;colIdx<row.length;colIdx++)  {
		let cell = row[colIdx];
		let filterValue = filtered[rowIdx][colIdx];
		if(filterThreshold!=-999) {
		    if(filterValue<filterThreshold)
			filterValue = cell.v;
		}
		cell.v = filterValue;
	    }
	}
    },
    getMinMaxGrid: function(src,valueGetter) {
	let min = NaN;
	let max = NaN;
	for(var rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = src[rowIdx];
	    for(var colIdx=0;colIdx<row.length;colIdx++)  {
		let v = row[colIdx]
		if(valueGetter) v = valueGetter(v,rowIdx,colIdx);
		if(isNaN(v)) continue;
		min = isNaN(min)?v:Math.min(min,v);
		max = isNaN(max)?v:Math.max(max,v);
	    }
	}
	return {min:min,max:max};
    },



    cloneGrid: function(src,valueGetter,dflt) {
	let dest = [];
	let hasDflt = Utils.isDefined(dflt);
	for(var rowIdx=0;rowIdx<src.length;rowIdx++)  {
	    let row = src[rowIdx];
	    let nrow=[];
	    dest.push(nrow);
	    for(var colIdx=0;colIdx<row.length;colIdx++)  {
		let v = row[colIdx]
		if(valueGetter) v = valueGetter(v,rowIdx,colIdx);
		if(hasDflt)
		    nrow.push(dflt);
		else
		    nrow.push(v);
	    }
	}
	return dest;
    },
    convertGeoToPixel:function(lat, lon,bounds,mapWidth,mapHeight) {
	var mapLonLeft = bounds.west;
	var mapLonRight = bounds.east;
	var mapLonDelta = mapLonRight - mapLonLeft;
	var mapLatBottom = bounds.south;
	var mapLatBottomDegree = mapLatBottom * Math.PI / 180;
	var x = (lon - mapLonLeft) * (mapWidth / mapLonDelta);
	var lat = lat * Math.PI / 180;
	var worldMapWidth = ((mapWidth / mapLonDelta) * 360) / (2 * Math.PI);
	var mapOffsetY = (worldMapWidth / 2 * Math.log((1 + Math.sin(mapLatBottomDegree)) / (1 - Math.sin(mapLatBottomDegree))));
	var y = mapHeight - ((worldMapWidth / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat)))) - mapOffsetY);
	return [x, y];
    },
}


function Glyph(display, scale, fields, records, args, attrs) {
    args = args||{};
    $.extend(this,{
	display: display,
	type:"label",
	dx:0,
	dy:0,
	label:"",
	baseHeight:0,
	baseWidth:0,
	width:8,
	fill:true,
	stroke:true,
    });
    $.extend(this,args);
    attrs.split(",").forEach(attr=>{
	let toks = attr.split(":");
	let name = toks[0];
	let value="";
	for(let i=1;i<toks.length;i++) {
	    if(i>1) value+=":";
	    value+=toks[i];
	}
	value = value.replace(/_nl_/g,"\n").replace(/_colon_/g,":").replace(/_comma_/g,",");
	if(value=="true") value=true;
	else if(value=="false") value=false;
	this[name] = value;
//	console.log("attr:" + name+"=" + value);
    });

    if(this.labelBy) {
	this.labelField=display.getFieldById(fields,this.labelBy);
	if(!this.labelField) {
	    console.log("Could not find label field: " + this.labelBy);
	}
    }

    if(this.type=="image") {
	this.imageField=display.getFieldById(fields,this.imageField);
	this.myImage= new Image();
    }
    this.scale = scale;
    if(this.height==null) {
	if(this.type == "3dbar")
	    this.height=20;
	else
	    this.height=8;
    }
    if(this.pos==null) {
	if(this.type == "3dbar")
	    this.color = "blue";
	else if(this.type == "rect") {
	    this.pos = "c";
	}
	else
	    this.pos = "nw";
    }	
    
    this.width = (+this.width);
    this.height = (+this.height);
    if(this.dx=="canvasWidth") this.dx=this.canvasWidth;
    else if(this.dx=="-canvasWidth") this.dx=-this.canvasWidth;
    else if(this.dx=="canvasWidth2") this.dx=this.canvasWidth/2;
    else if(this.dx=="-canvasWidth2") this.dx=-this.canvasWidth/2;    
    else if(this.dx=="width") this.dx=this.width;
    else if(this.dx=="-width") this.dx=-this.width;
    else if(this.dx=="width2") this.dx=this.width/2;
    else if(this.dx=="-width2") this.dx=-this.width/2;
    if(this.dy=="canvasHeight") this.dy=this.canvasHeight;
    else if(this.dy=="-canvasHeight") this.dy=-this.canvasHeight;
    else if(this.dy=="canvasHeight2") this.dy=this.canvasHeight/2;
    else if(this.dy=="-canvasHeight2") this.dy=-this.canvasHeight/2;    
    else if(this.dy=="height") this.dy=this.height;
    else if(this.dy=="-height") this.dy=-this.height;
    else if(this.dy=="height2") this.dy=this.height/2;
    else if(this.dy=="-height2") this.dy=-this.height/2;

    this.baseWidth = +this.baseWidth;
    this.width = (+this.width)*scale;
    this.height = (+this.height)*scale;
    this.dx = (+this.dx)*scale;
    this.dy = (+this.dy)*scale;
    if(this.sizeBy) {
	this.sizeByField=display.getFieldById(fields,this.sizeBy);
	if(!this.sizeByField) {
	    console.log("Could not find sizeBy field:" + this.sizeBy);
	} else  {
	    let props = {
		Min:this.sizeByMin,
		Max:this.sizeByMax,
	    };
	    this.sizeByInfo =  new ColorByInfo(display, fields, records, this.sizeBy,this.sizeBy, null, this.sizeBy,this.sizeByField,props);
	}
    }
    if(!this.colorByInfo && this.colorBy) {
	this.colorByField=display.getFieldById(fields,this.colorBy);
	let ct = this.colorTable?display.getColorTableInner(true, this.colorTable):null;
	if(!this.colorByField) {
	    console.log("Could not find colorBy field:" + this.colorBy);
	} else {
	    let props = {
		Min:this.colorByMin,
		Max:this.colorByMax,
	    };	    
	    this.colorByInfo =  new ColorByInfo(display, fields, records, this.colorBy,this.colorBy+".colorByMap", ct, this.colorBy,this.colorByField, props);
	}
    }


}







Glyph.prototype = {
    draw: function(opts, canvas, ctx, x,y,args) {
	let color =   null;
	if(this.colorByInfo) {
	    if(this.colorByField) {
		let v = args.record.getValue(this.colorByField.getIndex());
		color=  this.colorByInfo.getColor(v);
	    } else if(args.colorValue) {
		color=  this.colorByInfo.getColor(args.colorValue);
	    }
	}
	let lengthPercent = 1.0;
	if(this.sizeByInfo) {
	    let v = args.record.getValue(this.sizeByField.getIndex());
	    lengthPercent = this.sizeByInfo.getValuePercent(v);
	}

	if(args.alphaByCount && args.cell && args.grid) {
	    if(args.grid.maxCount!=args.grid.minCount) {
		let countPerc = (args.cell.count-args.grid.minCount)/(args.grid.maxCount-args.grid.minCount);
		color = Utils.addAlphaToColor(c,countPerc);
	    }
	}
	ctx.fillStyle =color || this.fillStyle || this.color || "blue";
	ctx.strokeStyle =this.strokeStyle || this.color || "#000";
	ctx.lineWidth=this.lineWidth||1;
	if(this.type=="label" || this.label) {
	    let label = this.labelField?args.record.getValue(this.labelField.getIndex()):this.label;
	    if(label===null) {
		console.log("No label value");
		return;
	    }
	    if(typeof label=="number") {
		if(this.valueScale) {
		    label = label* +this.valueScale;
		}

		if(this.decimals)
		    label = number_format(label,+this.decimals);
	    }
	    if(this.template) {
		label = this.template.replace("${value}",label);
	    }
	    ctx.font = this.font || "12pt arial"
	    ctx.fillStyle = ctx.strokeStyle =    color || this.color|| "#000";
	    let text = String(label);
	    if(args.record) {
		args.record.fields.forEach(f=>{
		    text = text.replace("\${" + f.getId()+"}",args.record.getValue(f.getIndex()));
		});
	    }
	    text = text.split("\n");
	    let h = 0;
	    let hgap = 3;
	    let maxw = 0;
	    text.forEach((t,idx)=>{
		let dim = ctx.measureText(t);
		if(idx>0) h+=hgap;
		maxw=Math.max(maxw,dim.width);
		h +=dim.actualBoundingBoxAscent+dim.actualBoundingBoxDescent;
	    });
	    let pt = Utils.translatePoint(x, y, maxw,  h, this.pos,{dx:this.dx,dy:this.dy});
	    text.forEach(t=>{
		let dim = ctx.measureText(t);
//		console.log(pt.x +" " + pt.y +" " + t);
		ctx.fillText(t,pt.x,pt.y);
		pt.y += dim.actualBoundingBoxAscent + dim.actualBoundingBoxDescent + hgap;
	    });
	} else 	if(this.type == "circle") {
	    /*
	    ctx.beginPath();
	    ctx.moveTo(0,y);
	    ctx.lineTo(100,y);
	    ctx.stroke();
	    ctx.moveTo(x,0);
	    ctx.lineTo(x,100);
	    ctx.stroke();
	    */
	    ctx.beginPath();
	    let w = this.width*lengthPercent+ this.baseWidth;
//	    this.dx=0; 
//	    this.dy=-50;
//	    this.pos="n"; 
	    let pt = Utils.translatePoint(x, y, w,  w, this.pos,{dx:this.dx,dy:this.dy});
	    let cx = pt.x+w/2;
	    let cy = pt.y+w/2;
	    ctx.arc(cx,cy, w/2, 0, 2 * Math.PI);
//	    console.log(pt.x +" " + pt.y +" " + cx +" " + cy  +" " + this.width);
	    if(this.fill)  {
		ctx.fill();
	    }
	    if(this.stroke) 
		ctx.stroke();
	} else if(this.type=="rect") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    if(this.fill)  
		ctx.fillRect(pt.x,pt.y, this.width, this.height);
	    if(this.stroke) 
		ctx.strokeRect(pt.x,pt.y, this.width, this.height);
	} else if(this.type=="image") {
	    if(this.imageField) {
		let img = args.record.getValue(this.imageField.getIndex());
		let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
		let i = new Image();
		i.src = img;
		setTimeout(()=>{
		    ctx.drawImage(i,pt.x,pt.y,40,40);
		},1000);
//		ctx.drawImage(this.myImage,pt.x,pt.y);
//		ctx.drawImage(this.myImage,0,0);
	    }
	} else 	if(this.type == "gauge") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    ctx.fillStyle =  this.fillColor || "#F7F7F7";
	    ctx.beginPath();
	    let cx= pt.x+this.width/2;
	    let cy = pt.y+this.height;
	    ctx.arc(cx,cy, this.width/2,  1 * Math.PI,0);
	    ctx.fill();
	    ctx.strokeStyle =   "#000";
	    ctx.stroke();
	    ctx.beginPath();
//	    ctx.moveTo(cx-this.width/2,cy);
//	    ctx.lineTo(cx+this.width/2,cy);
//	    ctx.stroke();

	    ctx.beginPath();
	    let length = this.width/2*0.75;
            let degrees = (180*lengthPercent);
	    let ex = cx-this.width*0.4;
	    let ey = cy;
	    let ep = Utils.rotate(cx,cy,ex,ey,degrees);
	    ctx.strokeStyle =  this.color || "#000";
	    ctx.lineWidth=this.lineWidth||2;
	    ctx.moveTo(cx,cy);
	    ctx.lineTo(ep.x,ep.y);
	    ctx.stroke();
	    ctx.lineWidth=1;
	    this.showLabel = true;
	    if(this.showLabel && this.sizeByInfo) {
		ctx.fillStyle="#000";
		let label = String(this.sizeByInfo.minValue);
		ctx.font = this.font || "9pt arial"
		let dim = ctx.measureText(label);
		ctx.fillText(label,cx-this.width/2-dim.width-2,cy);
		ctx.fillText(this.sizeByInfo.maxValue,cx+this.width/2+2,cy);
	    }
	} else if(this.type=="3dbar") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    let height = lengthPercent*(this.height) + parseFloat(this.baseHeight);
	    ctx.fillStyle =   color || this.color;
	    ctx.strokeStyle = this.strokeStyle||"#000";
	    this.draw3DRect(canvas,ctx,pt.x, 
			    canvas.height-pt.y-this.height,
			    +this.width,height,+this.width);
	    
	} else if(this.type=="axis") {
	    let pt = Utils.translatePoint(x, y, this.width,  this.height, this.pos,{dx:this.dx,dy:this.dy});
	    let height = lengthPercent*(this.height) + parseFloat(this.baseHeight);
	    ctx.strokeStyle = this.strokeStyle||"#000";
	    ctx.beginPath();
	    ctx.moveTo(pt.x,pt.y);
	    ctx.lineTo(pt.x,pt.y+this.height);
	    ctx.lineTo(pt.x+this.width,pt.y+this.height);
	    ctx.stroke();
//	    this.draw3DRect(canvas,ctx,x+this.dx, canvas.height-y-this.dy,+this.width,height,+this.width);	    
	} else if(this.type == "vector") {
	    if(!this.sizeByInfo) {
		console.log("make Vector: no sizeByInfo");
		return;
	    }
	    let v = args.record.getValue(this.sizeByField.getIndex());
	    lengthPercent = this.sizeByInfo.getValuePercent(v);
	    let length = opts.cellSizeH;
	    if(opts.lengthBy && opts.lengthBy.index>=0) {
		length = opts.lengthBy.scaleToValue(v);
	    }
	    let x2=x+length;
	    let y2=y;
	    let arrowLength = opts.display.getProperty("arrowLength",-1);
	    /*
	      if(opts.angleBy && opts.angleBy.index>=0) {
	      let perc = opts.angleBy.getValuePercent(v);
	      let degrees = (360*perc);
	      let rads = degrees * (Math.PI/360);
	      x2 = length*Math.cos(rads)-0* Math.sin(rads);
	      y2 = 0*Math.cos(rads)-length* Math.sin(rads);
	      x2+=x;
	      y2+=y;
	      }
	    */
	    if(opts.colorBy && opts.colorBy.index>=0) {
                let perc = opts.colorBy.getValuePercent(v);
                let degrees = (180*perc)+90;
		degrees = degrees*(Math.PI / 360)
                x2 = length*Math.cos(degrees)-0* Math.sin(degrees);
		y2 = 0*Math.cos(degrees)-length* Math.sin(degrees);
                x2+=x;
                y2+=y;
            }
	    //Draw the circle if no arrow
	    if(arrowLength<=0) {
		ctx.save();
		ctx.fillStyle="#000";
		ctx.beginPath();
		ctx.arc(x,y, 1, 0, 2 * Math.PI);
		ctx.fill();
		ctx.restore();
	    }
	    ctx.beginPath();
	    ctx.moveTo(x,y);
	    ctx.lineTo(x2,y2);
	    ctx.lineWidth=opts.display.getProperty("lineWidth",1);
	    ctx.stroke();
	    if(arrowLength>0) {
		ctx.beginPath();
		this.drawArrow(ctx, x,y,x2,y2,arrowLength);
		ctx.stroke();
	    }
	} else if(this.type=="tile"){
	    let crx = x+opts.cellSizeX/2;
	    let cry = y+opts.cellSizeY/2;
 	    if((args.row%2)==0)  {
		crx = crx+opts.cellSizeX/2;
		cry = cry-opts.cellSizeY/2;
	    }
	    let sizex = opts.cellSizeX/2;
	    let sizey = opts.cellSizeY/2;
	    ctx.beginPath();
	    let quarter = Math.PI/2;
	    ctx.moveTo(crx + sizex * Math.cos(quarter), cry + sizey * Math.sin(quarter));
	    for (let side=0; side < 7; side++) {
		ctx.lineTo(crx + sizex * Math.cos(quarter+side * 2 * Math.PI / 6), cry + sizey * Math.sin(quarter+side * 2 * Math.PI / 6));
	    }
	    ctx.strokeStyle = "#000";
	    //	    ctx.fill();
	    ctx.stroke();
	} else {
	    console.log("Unknwon cell shape:" + this.type);
	}
    },
    draw3DRect:function(canvas,ctx,x,y,width, height, depth) {
	// Dimetric projection functions
	var dimetricTx = function(x,y,z) { return x + z/2; };
	var dimetricTy = function(x,y,z) { return y + z/4; };
	
	// Isometric projection functions
	var isometricTx = function(x,y,z) { return (x -z) * Math.cos(Math.PI/6); };
	var isometricTy = function(x,y,z) { return y + (x+z) * Math.sin(Math.PI/6); };
	
	var drawPoly = (function(ctx,tx,ty) {
	    return function() {
		var args = Array.prototype.slice.call(arguments, 0);
		// Begin the path
		ctx.beginPath();
		// Move to the first point
		var p = args.pop();
		if(p) {
		    ctx.moveTo(tx.apply(undefined, p), ty.apply(undefined, p));
		}
		// Draw to the next point
		while((p = args.pop()) !== undefined) {
		    ctx.lineTo(tx.apply(undefined, p), ty.apply(undefined, p));
		}
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
	    };
	})(ctx, dimetricTx, dimetricTy);
	
	// Set some context
	ctx.save();
	ctx.scale(1,-1);
	ctx.translate(0,-canvas.height);
	ctx.save();
	
	// Move our graph
	ctx.translate(x,y);  
	// Draw the "container"
	//back
	let  baseColor = ctx.fillStyle;
	//		drawPoly([0,0,depth],[0,height,depth],[width,height,depth],[width,0,depth]);
	//left
	//		drawPoly([0,0,0],[0,0,depth],[0,height,depth],[0,height,0]);
	//right
	ctx.fillStyle =    Utils.pSBC(-0.5,baseColor);
	drawPoly([width,0,0],[width,0,depth],[width,height,depth],[width,height,0]);
	ctx.fillStyle =    baseColor;
	//front
	drawPoly([0,0,0],[0,height,0],[width,height,0],[width,0,0]);
	//top		
	ctx.fillStyle =    Utils.pSBC(0.5,baseColor);
	drawPoly([0,height,0],[0,height,depth],[width,height,depth],[width,height,0]);
	ctx.fillStyle =    baseColor;
	ctx.restore();
	ctx.restore();
    },

    drawArrow:function(context, fromx, fromy, tox, toy,headlen) {
	let dx = tox - fromx;
	let dy = toy - fromy;
	let angle = Math.atan2(dy, dx);
	context.moveTo(fromx, fromy);
	context.lineTo(tox, toy);
	context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
	context.moveTo(tox, toy);
	context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
    },

}
/**
   Copyright 2008-2020 Geode Systems LLC
*/



var xcnt=0;

const displayDebug = {
    getProperty:false,
    handleEventPropertyChanged:false,
    getSelectedFields:false,
    filterData:false,
    getStandardData:false,
    makeDataTable:false,
    checkSearchBar:false,
    handleNoData:false,
    pointDataLoaded:false,
    displayMapUpdateUI:false,
    displayMapCreateMap:false,
    displayMapAddPoints:false,
    loadPointJson:false,
    groupBy:false,
    gridPoints:false,

}


const CATEGORY_CHARTS = "Basic Charts";
const CATEGORY_TABLE = "Tables";
const CATEGORY_MISC = "Misc Charts";
const CATEGORY_MAPS = "Maps";
const CATEGORY_IMAGES = "Images";
const CATEGORY_RADIAL_ETC = "Trees, etc";
const CATEGORY_TEXT = "Text";
const CATEGORY_ENTRIES = "Entries";
const CATEGORY_CONTROLS = "Controls";
const DISPLAY_CATEGORIES = [CATEGORY_CHARTS,CATEGORY_TABLE,CATEGORY_MAPS,CATEGORY_IMAGES,CATEGORY_MISC,CATEGORY_TEXT,CATEGORY_RADIAL_ETC,CATEGORY_CONTROLS,CATEGORY_ENTRIES];



//Ids of DOM components
const ID_BOTTOM = "bottom";
const ID_COLORTABLE = "colortable";
const ID_LEGEND = "legend";
const ID_FIELDS = "fields";
const ID_HEADER = "header";
const ID_HEADER1 = "header1";
const ID_HEADER2 = "header2";
const ID_HEADER2_PREFIX = "header2prefix";
const ID_HEADER2_PREPREFIX = "header2preprefix";
const ID_HEADER2_PREPREPREFIX = "header2prepreprefix";
const ID_HEADER2_SUFFIX = "header2suffix";
const ID_FILTERBAR = "filterbar";
const ID_TITLE = ATTR_TITLE;
const ID_TITLE_EDIT = "title_edit";
const ID_LEFT = "left";
const ID_RIGHT = "right";
const ID_TITLE_FIELD="titlefield";
const ID_TOP = "top";
const ID_TOP_RIGHT = "topright";
const ID_TOP_LEFT = "topleft";
const ID_DETAILS = "details";
const ID_DISPLAY_CONTENTS = "contents";
const ID_DISPLAY_TOP = "top";
const ID_DISPLAY_BOTTOM = "bottom";
const ID_GROUP_CONTENTS = "group_contents";
const ID_DETAILS_MAIN = "detailsmain";
const ID_GROUPBY_FIELDS= "groupdbyfields";
const ID_TOOLBAR = "toolbar";
const ID_TOOLBAR_INNER = "toolbarinner";
const ID_LIST = "list";
const ID_DISPLAY_MESSAGE = "displaymessage";
const ID_DIALOG = "dialog";
const ID_DIALOG_TABS = "dialog_tabs";
const ID_FOOTER = "footer";
const ID_FOOTER_LEFT = "footer_left";
const ID_FOOTER_RIGHT = "footer_right";
const ID_MENU_BUTTON = "menu_button";
const ID_MENU_OUTER = "menu_outer";
const ID_MENU_INNER = "menu_inner";
const ID_DISPLAY_PROGRESS = "display_progress";
const ID_REPOSITORY = "repository";
const ID_REQUEST_PROPERTIES = "request_properties";
const ID_PAGE_COUNT = "pagecount";
const ID_PAGE_PREV = "pageprev";
const ID_PAGE_NEXT = "pagenext";
const ID_FILTER_HIGHLIGHT = "filterhighlight";
const ID_FILTER_DATE = "filterdate";
const ID_FILTER_COUNT = "filtercount";
const ID_ENTRIES_MENU = "entries_menu";
const ID_ENTRIES_PREV = "entries_prev";
const ID_ENTRIES_NEXT = "entries_next";
const PROP_DISPLAY_FILTER = "displayFilter";
const PROP_EXCLUDE_ZERO = "excludeZero";
const PROP_EXCLUDE_NAN = "excludeUndefined";
const PROP_DIVID = "divid";
const PROP_FIELDS = "fields";
const PROP_LAYOUT_HERE = "layoutHere";
const PROP_HEIGHT = "height";
const PROP_WIDTH = "width";
const PROP_FILTER_VALUE = "fitlerValue";

const RECORD_INDEX = "recordindex";
const RECORD_ID = "recordid";
const TEXT_HIGHLIGHT_COLOR = "yellow";
const HIGHLIGHT_COLOR = "red";

let globalDisplayCount = 0;
function addGlobalDisplayProperty(name, value) {
    if (window.globalDisplayProperties == null) {
        window.globalDisplayProperties = {};
    }
    if(value==="true") value = true;
    else if(value==="false") value=false;
    window.globalDisplayProperties[name] = value;
}


function addGlobalDisplayType(type, front) {
    if (window.globalDisplayTypes == null) {
        window.globalDisplayTypes = [];
	window.globalDisplayTypesMap = {};
    }

    if(type.type) {
	window.globalDisplayTypesMap[type.type] = type;
    }

    if(front) {
	window.globalDisplayTypes.unshift(type);
    } else {
	window.globalDisplayTypes.push(type);
    }
}


function makeDisplayTooltip(header,imgs,text) {
    let h =  "";
    if(header!=null) h +=HU.b(header);
    if(imgs) {
        if(!Array.isArray(imgs)) {
	    imgs  = [imgs];
	}
	let imgHtml = imgs.reduce((acc,img)=>{
	    if(!img.startsWith("/")) {
		img = ramaddaBaseUrl +"/help/display/" + img;
	    }
	    return acc+"<td><img src="+ img +" width=250px></td>";
	},"<table><tr valign=top>");
	imgHtml+="</tr></table>";
	if(h!="") h+="<br>";
	h+=imgHtml;
    }
    if(text) h+="<br>"+text;
    h  = h.replace(/"/g,"&quot;");
    return h;
}

function getGlobalDisplayProperty(name) {
    if (window.globalDisplayProperties == null) {
        return null;
    }
    return window.globalDisplayProperties[name];
}


function addRamaddaDisplay(display) {
    Utils.addDisplay(display);
    display.displayCount=globalDisplayCount++;
    return display;
}

async function ramaddaDisplaySetSelectedEntry(entryId, displays) {
    await getGlobalRamadda().getEntry(entryId, e => {
	displays = displays||Utils.displaysList;
	if(displays) {
		displays.forEach(d=>{
		    if(d.setEntry) d.setEntry(e);
		});
	}
    });
}


function ramaddaDisplayCheckLayout() {
    Utils.displaysList.forEach(d=>{
        if (d.checkLayout) {
	    let t1= new Date();
//	    console.log("before:" + d.type);
            d.checkLayout();
	    let t2= new Date();
//	    Utils.displayTimes("after:" + d.type,[t1,t2],true);
        }
    });
}


function getRamaddaDisplay(id) {
    let display =  Utils.displaysMap[id];
    if(display) return display;
    //Lazily set up the display map as when they are first created they don't have their getId() function defined yet
    Utils.displaysList.forEach(display=>{
	if(display.getId) {
	    Utils.displaysMap[display.getId()] = display;
	}
	if (display.displayId) {
            Utils.displaysMap[display.displayId] = display;
	}
    });
    return Utils.displaysMap[id];
}

function removeRamaddaDisplay(id) {
    var display = getRamaddaDisplay(id);
    if (display) {
        display.removeDisplay();
    }
}

function displayGetFunctionValue(v) {
    if(v.getTime) {
	return v.getTime();
    }
    if(isNaN(v)) {
	if((typeof v) == "string")return v;
	return 0;
    }
    return v;
}

function ramaddaDisplayStepAnimation() {
    Utils.displaysList.forEach(d=>{
	if(d.getProperty && d.getAnimation)  {
	    if(d.getProperty("doAnimation")) {
		d.getAnimation().doNext();
	    }
	}
    });
}



function displayDefineMembers(display, props, members) {
    RamaddaUtil.defineMembers(display, members);
    if(props && display.defineProperties) display.defineProperties(props);
    return display;
}


function defineDisplay(display, SUPER, props, members) {
    RamaddaUtil.inherit(display, SUPER);
    displayDefineMembers(display, props, members);
    if(members.ctor) {
	display.ctor();
    }
    return display;
}



addGlobalDisplayType({
    type: "group",
    label: "Group",
    requiresData: false,
    forUser: true,
    category: "Basic Charts",
    tooltip: makeDisplayTooltip("Create a collection of displays",null,"This allows you to layout displays and share common attributes"),
    helpUrl:true

},true);






/**
   Base class for all displays oriented things
*/
function DisplayThing(argId, argProperties) {
    
    if (argProperties == null) {
        argProperties = {};
    }


    //check for booleans as strings
    for (var i in argProperties) {
        if (typeof argProperties[i] == "string") {
            if (argProperties[i] == "true") argProperties[i] = true;
            else if (argProperties[i] == "false") argProperties[i] = false;
        }
    }


    //Now look for the structured foo.bar=value
    for (var key in argProperties) {
        var toks = key.split(".");
        if (toks.length <= 1) {
            continue;
        }
	//var map = argProperties;
	// Don't this for now as it screws up doing something like colorTable.field=...
	let map = {};
        //graph.axis.foo=bar
        var v = argProperties[key];
        if (v == "true") v = true;
        else if (v == "false") v = false;
        for (var i = 0; i < toks.length; i++) {
            var tok = toks[i];
            if (i == toks.length - 1) {
                map[tok] = v;
                break;
            }
            var nextMap = map[tok];
            if (nextMap == null) {
                map[tok] = {};
                map = map[tok];
            } else {
                map = nextMap;
            }
        }
    }

    this.ignoreGlobals = argProperties.ignoreGlobals;

    this.displayId = null;

    displayDefineMembers(this,null, {
        objectId: argId,
        properties: argProperties,
        displayParent: null,
        getId: function() {
            return this.objectId;
        },
        setId: function(id) {
            this.objectId = id;
        },
        removeDisplay: function() {
	    if(this.dialogElement)  this.dialogElement.remove();
        },
	setEntry: function(entry) {
	},
	handleEntryMenu: async function(entryId) {
            await getGlobalRamadda().getEntry(entryId, e => {
		this.setEntry(e);
	    });

	},
	getEntriesMenu: function(argProperties) {
	    if(argProperties && argProperties.entryCollection) {
		var entries  = argProperties.entryCollection.split(",");
		this.changeEntries = [];
		let enums = [];
		entries.forEach(t=>{
		    var toks = t.split(":");
		    this.changeEntries.push(toks[0]);
		    enums.push([toks[0],toks[1]]);
		});
		var prev = HU.span([CLASS,"display-changeentries-button", TITLE,"Previous entry", ID, this.getDomId(ID_ENTRIES_PREV), TITLE,"Previous"], HU.getIconImage("fa-chevron-left"));
 		var next = HU.span([CLASS, "display-changeentries-button", TITLE,"Next entry", ID, this.getDomId(ID_ENTRIES_NEXT), TITLE,"Next"], HU.getIconImage("fa-chevron-right")); 
		var label = argProperties.changeEntriesLabel||"";
		if(label!="") label = label+"<br>";
		return  HU.center(label + prev +" " + HU.select("",[ATTR_ID, this.getDomId(ID_ENTRIES_MENU)],enums) +" " + next);
	    }
	    return "";
	},
        initializeEntriesMenu: function() {
	    this.jq(ID_ENTRIES_PREV).click(e=>{
		var index = this.jq(ID_ENTRIES_MENU)[0].selectedIndex;
		if(index<=0) return;
		var entry  =this.changeEntries[index-1];
		this.jq(ID_ENTRIES_MENU).val(entry);
		this.handleEntryMenu(entry);
	    });
	    this.jq(ID_ENTRIES_NEXT).click(e=>{
		var index = this.jq(ID_ENTRIES_MENU)[0].selectedIndex;
		if(index>=this.changeEntries.length-1) {
		    return;
		}
		var entry  =this.changeEntries[index+1];
		this.jq(ID_ENTRIES_MENU).val(entry);
		this.handleEntryMenu(entry);
	    });
	    this.jq(ID_ENTRIES_MENU).change(e=>{
		var entry = this.jq(ID_ENTRIES_MENU).val();
		this.handleEntryMenu(entry);
	    });
	},


        popup: function(srcId, popupId, srcObj, popup) {
            popup = popup || $("#"+popupId);
            var src = srcObj || $("#"+srcId);
            var myalign = 'left top';
            var atalign = 'left bottom';
            popup.show();
	    //	    console.log(srcObj +" " + srcId + " " + "pop:" + popup.length +" src:" + src.length);
            popup.position({
                of: src,
                my: myalign,
                at: atalign,
                collision: "none none"
            });
            //Do it again to fix a bug on safari
            popup.position({
                of: src,
                my: myalign,
                at: atalign,
                collision: "none none"
            });
            popup.draggable();
            popup.show();	    
        },

	initDialog: function() {
	},
        showDialog: function(text, from, initDialog) {
	    if(!this.dialogElement) {
		$(document.body).append(HU.div([ATTR_CLASS, "display-dialog",ID,this.getDomId(ID_DIALOG)]));
		this.dialogElement = this.jq(ID_DIALOG);
	    }
	    this.dialogElement.html(this.makeDialog(text));
            this.popup(from || this.getDomId(ID_MENU_BUTTON), null,null, this.dialogElement);
	    if(initDialog) initDialog();
            else this.initDialog();
        },
        getShowMenu: function() {
            if (Utils.isDefined(this.showMenu)) {
		return this.showMenu;
	    }
	    var dflt = false;
            if (this.displayParent != null) {
		dflt = this.displayParent.getProperty("showChildMenu",dflt);
	    }
	    var v = this.getProperty(PROP_SHOW_MENU, dflt);
	    return v;
        },
        getShowTitle: function() {
            if (this.getProperty("showTitle")) {
		return this.getProperty("showTitle");
	    }
	    var dflt = false;
            if (this.displayParent != null) {
		dflt = this.displayParent.getProperty("showChildTitle",dflt);
	    }
	    return this.getProperty("showTitle", dflt);
        },

        getTimeZone: function() {
            return this.getProperty("timeZone");
        },
        formatDate: function(date, args, useToStringIfNeeded) {
	    if(!date || !date.getTime) return "";
            try {
                return this.formatDateInner(date, args, useToStringIfNeeded);
            } catch (e) {
                console.log("Error formatting date:" + e);
                if (!date.getTime && date.v) date = date.v;
                return "" + date;
            }
        },
	dateFormat:null,
        formatDateInner: function(date, args,useToStringIfNeeded) {
	    if(!this.dateFormat)
		this.dateFormat =  this.getProperty("dateFormat", this.getProperty("dateFormat2"));
	    if(!this.dateFormat && useToStringIfNeeded) {
		return String(date);
	    }
            //Check for date object from charts
            if (!date.getTime && date.v) date = date.v;
	    if(this.dateFormat) {
		let dttm = Utils.formatDateWithFormat(date,this.dateFormat,true);
		if(dttm) {
		    return String(dttm);
		}
	    }
            if (!date.toLocaleDateString) {
                return String(date);
            }
            var suffix;
            if (args && !Utils.isDefined(args.suffix))
                suffix = args.suffix;
            else
                suffix = this.getProperty("dateSuffix");
            var timeZone = this.getTimeZone();
            if (!suffix && timeZone) suffix = timeZone;
	    return Utils.formatDate(date, args?args.options:null, {
                timeZone: timeZone,
                suffix: suffix
	    });
        },
        getUniqueId: function(base) {
            return HU.getUniqueId(base);
        },
        handleError: function(code, message) {
            GuiUtils.handleError("An error has occurred:" + message, true, true);
        },
        toString: function() {
            return "DisplayThing:" + this.getId();
        },
        domId: function(suffix) {
	    return this.getDomId(suffix);
	},
        getDomId: function(suffix) {
            return this.getId() + "_" + suffix;
        },
	gid: function(suffix) {
            return this.getId() + "_" + suffix;
        },
	find: function(selector) {
	    return this.getContents().find(selector);
	},
	getContents: function() {
	    return this.jq(ID_DISPLAY_CONTENTS);
	},	
        jq: function(componentId) {
            return $("#" + this.getDomId(componentId));
        },
	selectboxit: function(selector, args) {
	    let opts = {
		showEffect: "fadeIn",
		showEffectSpeed: 400,
		hideEffect: "fadeOut",
		hideEffectSpeed: 400,
	    };
	    if(args) $.extend(opts,args);
            selector.selectBoxIt(opts);
	},
        writeHtml: function(idSuffix, html) {
            $("#" + this.getDomId(idSuffix)).html(html);
        },
	getTemplateProps: function(fields) {
	    return {
		iconField: this.getFieldById(fields, this.getProperty("iconField")),
		iconSize: parseFloat(this.getProperty("iconSize",16)),
		iconMap: this.getIconMap(),
		colorBy:this.getProperty("colorBy"),
		colorByMap: this.getColorByMap()
	    }
	},
	macroHook: function(token,value) {
	    return null;
	},
	applyRecordTemplate: function(record, row, fields, template, props,macros, debug) {
	    fields = this.getFields(fields);
	    if(!props) {
		props = this.getTemplateProps(fields);
	    }
	    if(!macros) macros = Utils.tokenizeMacros(template,{hook:(token,value)=>{return this.macroHook(record, token,value)},dateFormat:this.getProperty("dateFormat")});
	    let attrs = {};
	    if(props.iconMap && props.iconField) {
		var value = row[props.iconField.getIndex()];
		var icon = props.iconMap[value];
		if(icon) {
		    attrs[props.iconField.getId() +"_icon"] =  HU.image(icon,["width",props.iconSize]);
		}
	    }

	    let makeImage = (f, value) =>{
		let tokenAttrs  = macros.getAttributes(f.getId()+"_image");
		let imageAttrs = [];
		let width = tokenAttrs?tokenAttrs["width"]:null;
		if(width) {
		    imageAttrs.push("width");
		    imageAttrs.push(width);
		} else if(this.getProperty("imageWidth")) {
		    imageAttrs.push("width");
		    imageAttrs.push(this.getProperty("imageWidth")); 
		} else  {
		    imageAttrs.push("width");
		    imageAttrs.push("300");
		}
		imageAttrs.push("style");
		imageAttrs.push("vertical-align:top");
		return HU.image(value, imageAttrs);
	    };



	    let idToField = {}
	    fields.forEach(f=>idToField[f.getId()] = f);
	    //Look for a list
	    macros.tokens.forEach(t=>{
		if(!t.attrs) return;
		if(t.attrs["type"]=="list" && t.attrs["fields"]) {
		    let html = "<table class=display-table>";
		    t.attrs.fields.split(",").forEach(fieldName=>{
			let f = idToField[fieldName];
			let value = row[f.getIndex()];
			if(f.getType()=="image") {
			    value = makeImage(f,value);
			} else  if(f.getType()=="url") {
			    if(value!="") 
				value =  HU.href(value,value);
			}
			html+="<tr><td align=right><b>" +f.getLabel()+"</b>:</td><td>  " + value+"</td></tr>";
		    });
		    html +="</table>";
		    attrs[t.tag] = html;
		}
	    });


	    for (var col = 0; col < fields.length; col++) {
		var f = fields[col];
		var value = row[f.getIndex()];
		if(debug) console.log("macro:" + col +" field:" + f.getId() +" type:" +f.getType() + " value:" + value);
		if(props.iconMap) {
		    var icon = props.iconMap[f.getId()+"."+value];
		    if(icon) {
			s = s.replace("${" + f.getId() +"_icon}", HU.image(icon,["size",props.iconSize]));
		    }
		}
		if(f.getType()=="image") {
		    if(value && value.trim().length>1) {
			let tokenAttrs  = macros.getAttributes(f.getId()+"_image");
			let imageAttrs = [];
			let width = tokenAttrs?tokenAttrs["width"]:null;
			if(width) {
			    imageAttrs.push("width");
			    imageAttrs.push(width);
			} else if(this.getProperty("imageWidth")) {
			    imageAttrs.push("width");
			    imageAttrs.push(this.getProperty("imageWidth")); 
			} else  {
			    imageAttrs.push("width");
			    imageAttrs.push("100%");
			}
			imageAttrs.push("style");
			imageAttrs.push("vertical-align:top");
			var img =  HU.image(value, imageAttrs);

			attrs[f.getId() +"_image"] =  img;
			attrs[f.getId() +"_url"] =  value;
		    } else {
			attrs[f.getId() +"_url"] =  ramaddaBaseUrl+"/icons/blank.gif";
			attrs[f.getId() +"_image"] =  "";
		    }
		} else if(f.getType()=="movie") {
		    if(value && value.trim().length>0) {
			var movieAttrs = [];
			if(this.getProperty("movieWidth")) {
			    movieAttrs.push("width");
			    movieAttrs.push(this.getProperty("movieWidth"));
			}
			var movie =  HU.movie(value,movieAttrs);
			attrs[f.getId() +"_movie"] =  movie;
			attrs[f.getId() +"_url"] =  value;
		    }
		} else if(f.getType()=="url") {
		    if(value && value.trim().length>1) {
			attrs[f.getId() +"_href"] =  HU.href(value,value);
			attrs[f.getId()]=  value;
			console.log("URL");
		    } else {
			attrs[f.getId() +"_href"] =  "";
			attrs[f.getId()] =  "";
		    }
		    continue;
		} else if(f.isDate) {

		    if(value) {
			attrs[f.getId()]= value;
		    }
		    continue;
		}
		var color;
		if(props.colorByMap) {
		    if(props.colorBy && props.colorBy == f.getId()) {
			color = props.colorByMap[value];
		    } else {
			color = props.colorByMap[f.getId()+"."+value];				    
		    }
		}
		if(color) {
		    attrs[f.getId()+"_color"] =  color;
		}
		attrs[f.getId()]=  value;
		if(f.isNumeric()) {
		    //TODO: nuke this
		    attrs[f.getId() +"_format"] = Utils.formatNumberComma(value);
		}
	    }
	    this.addMacroAttributes(macros,row,attrs);
	    return macros.apply(attrs,debug);
	},
	addMacroAttributes:function(macros,row,attrs) {
	},
	getFields: function(fields) {
            if (!fields) {
                var pointData = this.getData();
                if (pointData == null) {
		    return null;
		}
                fields = pointData.getRecordFields();
	    }
	    return fields;
	},
	getRecordUrlHtml: function(attrs, field, record) {
	    let value = record.getValue(field.getIndex());
	    let label = attrs[field.getId()+".label"] || attrs["url.label"] ||attrs["label"] || "Link";
	    return  HU.href(value,label,["target","_link"]);
	},

        getRecordHtml: function(record, fields, template, debug) {
	    fields = this.getFields(fields);
	    if(!fields) return "";
	    let linkField = this.getFieldById(null,this.getProperty("linkField"));
	    let titleField = this.getFieldById(null,this.getProperty("titleField"));
	    let titleTemplate = this.getProperty("titleTemplate");	    
	    let descField = this.getFieldById(null,this.getProperty("descriptionField"));
	    let link  = linkField?record.getValue(linkField.getIndex()):null;
	    let showDate = this.getProperty("showDate", true);
	    let showImage = this.getProperty("showImage", true);
	    let showMovie = this.getProperty("showMovie", true);	    
            let showGeo = false;
            let showElevation = this.getProperty("showElevation",false);
            if (Utils.isDefined(this.showGeo)) {
                showGeo = ("" + this.showGeo) == "true";
            }
	    if(!template)
		template = this.getProperty("recordTemplate");
	    if(template) {
		if(!template.startsWith("${default") && template!="${fields}") {
		    return this.applyRecordTemplate(record,this.getDataValues(record), fields, template, null, null,debug);
		}
	    }
	    if(template=="${fields}") {
		fields = this.getFieldsByIds(null,this.getProperty("tooltipFields",this.getPropertyFields()));
	    }

	    let templateProps = {};
	    let itemsPerColumn=this.getProperty("itemsPerColumn",50);

	    let attrs={};
	    if(template) {
		attrs = Utils.tokenizeMacros(template,{hook:(token,value)=>{return this.macroHook(record, token,value)},dateFormat:this.getProperty("dateFormat")}).getAttributes("default")||{};
	    }
	    itemsPerColumn = attrs["itemsPerColumn"] || itemsPerColumn;
	    let values = "";
	    if(titleField || titleTemplate) {
		let title="";
		if(titleTemplate) {
		    if(!titleTemplate.startsWith("${default")) {
			title = this.getRecordHtml(record, fields, titleTemplate, debug);
		    }
		} else {
		    title = record.getValue(titleField.getIndex());
		    if(title.getTime)
			title = this.formatDate(title);
		    title = HU.center(HU.h3(title));
		}
		if(link)
		    title = HU.href(link,title);
		values+=title;
		link = null;
	    }

	    if(descField) {
		let desc = record.getValue(descField.getIndex());
		values+=desc;
	    }

	    let tooltipNots = {};
	    this.getProperty("tooltipNotFields","").split(",").forEach(f=>{
		tooltipNots[f] = true;
	    });

	    let rows = [];
	    let hadDate = false;
	    let labelColAttrs = [];
	    if(this.getProperty("labelColumnAttrs")) {
		labelColAttrs = this.getProperty("labelColumnAttrs").split(",");
	    } else {
		labelColAttrs = ["align","right"];
	    }
	    let labelWidth = this.getProperty("labelWidth");

            for (var doDerived = 0; doDerived < 2; doDerived++) {
                for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
		    if(tooltipNots[field.getId()]) continue;
		    if(attrs[field.getId()+".hide"]) {
			continue;
		    }
		    if(field==titleField || field==descField) continue;
                    if (doDerived == 0 && !field.derived) continue;
                    else if (doDerived == 1 && field.derived) continue;
                    if (!field.getForDisplay()) {
			continue;
		    }
		    if(field.isRecordDate()) {
			if(!showDate) {
			    continue;
			}
			hadDate = true;
		    }
                    if (!showGeo) {
                        if (field.isFieldGeo()) {
                            continue;
                        }
                    }
                    let value = record.getValue(field.getIndex());
		    let fieldValue = value;
                    if (typeof value == "number") {
			value = this.formatNumber(value, field.getId());
		    } 
                    if (field.isFieldDate()) {
			value = this.formatDate(value);
		    }
		    if(field.getType() == "image" && value!="") {
			if(!showImage) continue;
			let imageAttrs = [];
			if(this.getProperty("imageWidth")) {
			    imageAttrs.push("width");
			    imageAttrs.push(this.getProperty("imageWidth")); 
			} else  {
			    imageAttrs.push("width");
			    imageAttrs.push("200");
			}
			imageAttrs.push("align");
			imageAttrs.push("top");
			value = HU.image(value,imageAttrs);
		    }
		    if(field.getType() == "movie" && value!="") {
			if(!showMovie) continue;
			var movieAttrs = [];
			movieAttrs.push("width");
			movieAttrs.push("200");
			value = HU.movie(value,movieAttrs);
		    }		    
		    if(field.getType() == "url") {
			value = this.getRecordUrlHtml(attrs, field, record);
		    }
		    let labelValue = field.getLabel();
		    value = value + field.getUnitSuffix();
		    let tt = labelValue+"=" + value;
		    if(value.length>100) {
			value  = HU.div([STYLE,HU.css("max-height","100px","overflow-y","auto")],value);
		    }
		    let label = this.formatRecordLabel(labelValue)+":";
		    if(labelWidth) {
			label = HU.div([STYLE,HU.css("max-width" ,HU.getDimension(labelWidth),"overflow-x","auto")], label); 
		    } 
		    label  = HU.div([TITLE,tt],label);
                    let row = HU.open(TR,['valign','top']);
		    row += HU.td(labelColAttrs,HU.b(label));
		    row += HU.td(["field-id",field.getId(),"field-value",fieldValue, "align","left"], HU.div([STYLE,HU.css('margin-left','5px')], value));
		    row += HU.close(TR);
		    rows.push(row);
                }
            }
	    if(!hadDate && showDate) {
		if(record.hasDate()) {
                    let row = HU.open(TR,['valign','top']);
		    let label = this.formatRecordLabel("Date");
		    row += HU.td([],HU.b(label+":"));
		    row += HU.td(["align","left"], HU.div([STYLE,HU.css('margin-left','5px')],
							  this.formatDate(record.getDate())));
		    row += HU.close(TR);
		    rows.push(row);
		}
	    }
            if (showElevation && record.hasElevation()) {
                rows.push(HU.tr([],HU.td([ALIGN,'right'],HU.b('Elevation:')) +
			       HU.td([ALIGN,'left'], number_format(record.getElevation(), 4, '.', ''))));
            }
	    let rowCnt = 0;
	    values += "<table><tr valign=top>";
	    let		lists   = Utils.splitList(rows,itemsPerColumn);
	    let tdStyle =lists.length>1?"margin-right:5px;":"";
	    lists.forEach(list=>{
		values += "<td><div style='" + tdStyle+"'><table>" + Utils.join(list,"") +"</table></div></td>";
	    });
            values += "</tr><table>";
	    if(this.getProperty("recordHtmlStyle")){
		values = HU.div([CLASS,"ramadda-shadow-box display-tooltip", STYLE,this.getProperty("recordHtmlStyle")], values);
	    }
            return values;
        },
        formatRecordLabel: function(label) {
            label = label.replace(/!!/g, " -- ");
	    label = label.replace(/ /g,"&nbsp;");
            return label;
        },
        getFormValue: function(what, dflt) {
            var fromForm = $("#" + this.getDomId(what)).val();
            if (fromForm != null) {
                if (fromForm.length > 0) {
                    this.setProperty(what, fromForm);
                }
                if (fromForm == "none") {
                    this.setProperty(what, null);
                }
                return fromForm;
            }
            return this.getProperty(what, dflt);
        },

        getName: function() {
            return this.getFormValue("name", this.getId());
        },
        getEventSource: function() {
            return this.getFormValue("eventSource", "");
        },
        setDisplayParent: function(parent) {
            this.displayParent = parent;
        },
        getDisplayParent: function() {
            if (this.displayParent == null) {
                this.displayParent = this.getLayoutManager();
            }
            return this.displayParent;
        },
        removeProperty: function(key) {
            this.properties[key] = null;
        },
        setProperty: function(key, value) {
	    //            this[key] = value;
            this.properties[key] = value;
        },
        getSelfProperty: function(key, dflt) {
            if (this[key] != null) {
                return this[key];
            }
            return this.getProperty(key, dflt);
        },
        initTooltip: function() {
            //don't do this for now                $( document ).tooltip();
        },
        formatNumber: function(number, propPrefix) {
	    if(!this.getProperty([propPrefix+".doFormatNumber","doFormatNumber"],true)) {
		return number;
	    }
	    if(isNaN(number)) {
		return "--";
	    }
	    let f = this.formatNumberInner(number, propPrefix);
	    let fmt = this.getProperty([propPrefix+".numberTemplate","numberTemplate"]);
	    if(fmt) f = fmt.replace("${number}", f);
	    f = String(f);
	    if(f.endsWith(".")) f = f.substring(0,f.length-1);
	    return f;
	},
        formatNumberInner: function(number,propPrefix) {
	    number = +number;
	    let scale = this.getProperty([propPrefix+".formatNumberScale","formatNumberScale"]);
            if (Utils.isDefined(scale))
		number = number*scale;
	    let decimals = this.getProperty([propPrefix+".formatNumberDecimals","formatNumberDecimals"]);
            if (Utils.isDefined(decimals)) {
		return number_format(number, decimals);
	    }
            if (this.getProperty([propPrefix+".formatNumberComma","formatNumberComma"], false)) {
		return Utils.formatNumberComma(number);

	    }
            return Utils.formatNumber(number);

        },
        propertyDefined: function(key) {
            return Utils.isDefined(this.getProperty(key));
        },
        setPropertyOn: function(object, myProperty, objectProperty, dflt) {
            var prop = this.getProperty(myProperty, dflt);
            if (Utils.isDefined(prop) && prop != null) {
                object[objectProperty] = prop;
            }
        },
        getDisplayProp: function(source, prop, dflt) {
            if (Utils.isDefined(this[prop])) {
                return this[prop];
            }
            let prop2 = "map-" + prop;
            if (Utils.isDefined(source[prop2])) {
                return source[prop2];
            }
	    if(source.getProperty) {
		return source.getProperty(prop, dflt);
	    }
	    return null;
        },
        getPropertyFromUrl: function(key, dflt) {
	    let fromUrl = HU.getUrlArgument("display"+ this.displayCount+"." + key);
	    if(fromUrl) return fromUrl;
	    return this.getProperty(key,dflt);
	},
	getPropertyFields: function(dflt) {
	    return this.getPropertyFromUrl(PROP_FIELDS,dflt);
	},
        getProperty: function(key, dflt, skipThis, skipParent) {
	    if(this.debugGetProperty)
		console.log("\tgetProperty:" + key);
	    let value =  this.getPropertyInner(key,null,skipThis, skipParent);
	    if(this.debugGetProperty)
		console.log("\tgot:" + value);
	    if(this.writePropertyDef!=null) {
		if(!this.seenWriteProperty) this.seenWriteProperty = {};
		if(!this.seenWriteProperty[key]) {
		    let f = (v)=>{
			return v?"'" + v+"'":"null";
		    };
		    this.writePropertyDef+="{p:'" + key +"',d:" + f(dflt)+",wikiValue:" + f(value||dflt)+"},\n"
		    this.seenWriteProperty[key] = true;
		}
	    }
	    if(!Utils.isDefined(value)) {
		if(this.debugGetProperty)
		    console.log("\treturning dflt:" + dflt);
		return dflt;
	    }
	    if(this.debugGetProperty)
		console.log("\treturning value:" + value);
	    return value;
	},
        getPropertyInner: function(keys, dflt,skipThis, skipParent) {	    
	    let debug = displayDebug.getProperty;
	    debug = this.debugGetProperty;
	    if(!Array.isArray(keys)) keys = [keys];
	    for(let i=0;i<keys.length;i++) {
		let key = keys[i];
		if(debug) console.log("getProperty:" + key +" dflt:" + dflt);
		if(this.dynamicProperties) {
		    if(Utils.isDefined(this.dynamicProperties[key])) {
			return this.dynamicProperties[key];
		    }
		}
		var value = this.properties[key];
		if (value != null) {
		    if(debug) console.log("\tgot property from this.properties:" + value);
                    return value;
		}
	    }
	    if(!skipParent) {
		for(let i=0;i<keys.length;i++) {
		    let key = keys[i];
		    var fromParent=null;
		    if (this.displayParent != null) {
			fromParent =  this.displayParent.getPropertyInner("inherit."+key, skipThis);
		    }
		    if (!fromParent && this.getDisplayManager) {
			fromParent=  this.getDisplayManager().getPropertyInner("inherit."+key);
		    }
		    if(fromParent) {
			if(debug) console.log("\tgetProperty-3");
			return fromParent;
		    }
		}
	    }
	    if(!this.ignoreGlobals) {
		if(!skipParent) {
		    if (this.displayParent != null) {
			if(debug) console.log("\tgetProperty calling parent");
			return this.displayParent.getPropertyInner(keys, skipThis);
		    }
		    if (this.getDisplayManager) {
			if(debug) console.log("\tgetProperty-5");
			return   this.getDisplayManager().getPropertyInner(keys);
		    }
		}
		for(let i=0;i<keys.length;i++) {
		    let key = keys[i];
		    value = getGlobalDisplayProperty(key);
		    if (Utils.isDefined(value)) {
			if(debug) console.log("\tgetProperty-6:" + value);
			return value;
		    }
		}
	    }
	    if(debug) console.log("\tgetProperty-6 dflt:" + dflt);
            return dflt;
        },
    });
}




/**
   Base class for all displays 
*/
function RamaddaDisplay(argDisplayManager, argId, argType, argProperties) {
    const SUPER  = new DisplayThing(argId, argProperties);
    RamaddaUtil.inherit(this, SUPER);


    if(window.globalDisplayTypesMap) {
	this.typeDef = window.globalDisplayTypesMap[argType];
    }

    this._wikiTags  = [];
    
    this.defineProperties = function(props) {
	let tagList = [];
	props.forEach(prop=>{
	    tagList.push(prop);
	    if(!prop.p) {
		return;
	    }
	    if(prop.p.indexOf("&")<0) {
		if(!Utils.isDefined(prop.doGetter) || prop.doGetter) {
		    let getFunc = (dflt,debug)=>{
			if(!Utils.isDefined(dflt)) dflt = prop.d;
			return this.getProperty(prop.p,dflt);
		    };
		    let funcName =  'getProperty' + prop.p.substring(0, 1).toUpperCase() + prop.p.substring(1);
		    if(!this[funcName])
			this[funcName] = getFunc;
		    funcName =  'get' + prop.p.substring(0, 1).toUpperCase() + prop.p.substring(1);
		    if(!this[funcName])
			this[funcName] = getFunc;
		}
	    }
	    prop.wikiValue = prop.wikiValue||prop.w;
	});
	this._wikiTags  = Utils.mergeLists(tagList,this._wikiTags);
    }

    let myProps = [
	{label:'Display'},
	{p:'fields',doGetter:false,ex:'comma separated list of field ids or indices - e.g. #1,#2,#4-#7,etc or *'},
	{p:'notFields',ex:'regexp',tt:'regexp to not include fields'},		
	{p:"showMenu",ex:true},	      
	{p:"showTitle",ex:true},
	{p:"showEntryIcon",ex:true},
	{p:"layoutHere",ex:true},
	{p:"width",doGetter:false,ex:"100%"},
	{p:"height",doGetter:false,ex:"400"},
	{p:"tooltip",doGetter:false,ex:"${default}"},
	{p:"tooltipPositionMy",ex:"left top"},
	{p:"tooltipPositionAt",ex:"left bottom+2"},		
	{p:"recordTemplate",doGetter:false,ex:"${default}",tt:"Template for popups etc. Can be ${default attrs} or '${field} .. ${fieldn}...'"},
	{p:"titleTemplate",doGetter:false,ex:"${field1}",tt:"Template for title in ${default} template display"},	
	{p:"itemsPerColumn",ex:10,tt:'How many items to show in each column in a tooltip'},
	{p:"labelColumnAttrs",ex:"align,right",tt:"Attributes of the label column in the record templates"},
	{p:"labelWidth",ex:"10",tt:"Width of labels the record templates"},	
	{p:"displayStyle",ex:"css styles",tt:"Specify styles for display"},
	{p:"title",ex:""},
	{p:"titleBackground",ex:"color"},
	{p:"linkField",ex:""},
	{p:"titleField",ex:""},
	{p:"descriptionField",ex:""},
	{p:"textColor",ex:"color"},
	{p:"backgroundImage",ex:"",tt:"Image url to display in background"},
	{p:"background",ex:"color"},
	{p:"showProgress",ex:true},
	{p:"doEntries",ex:true,tt:"Make the children entries be data"},
	{p:"addAttributes",ex:true,tt:"Include the extra attributes of the children"},
	{p:"sortFields",tt:"Comma separated list of fields to sort the data on"},
	{p:"sortAscending",ex:"true|false"},
	{p:"showSortDirection",ex:true},		
	{p:"sortByFields",ex:"",tt:"Show sort by fields in a menu"},
	{p:"sortHighlight",ex:true,tt:"Sort based on highlight from the filters"},
	{p:"showDisplayFieldsMenu",ex:true},
	{p:"displayFieldsMenuMultiple",ex:true},
	{p:"displayFieldsMenuSide",ex:"left"},
	{label:"Formatting"},
	{p:"dateFormat",ex:"yyyy|yyyymmdd|yyyymmddhh|yyyymmddhhmm|yyyymm|yearmonth|monthdayyear|monthday|mon_day|mdy|hhmm"},
	{p:"dateFormatDaysAgo",ex:true},
	{p:"doFormatNumber",ex:false},
 	{p:"formatNumberDecimals",ex:0},
	{p:"formatNumberScale",ex:100},
	{p:"numberTemplate",ex:"${number}%"},
	{p:"&lt;field_id&gt;.&lt;format&gt;",ex:"..."},
	{label:"Filter Data"},
	{p:"fieldsNumeric",ex:true,tt:"Only get numeric fields"},
	{p:"filterFields",ex:""},
	{p:"filterFieldsToPropagate"},
	{p:"hideFilterWidget",ex:true},
	{p:"filterHighlight",ex:true,tt:"Highlight the records"},
	{p:"showFilterHighlight",ex:false,tt:"show/hide the filter highlight widget"},
	{p:"acceptEventFilter",ex:false},
	{p:"acceptEventDisplayFieldsChange",ex:true},
	{p:'acceptEventDataSelection',ex:true,tt:'accept new data coming from other displays'},
	{p:"acceptEventRecordList",ex:true},
	{p:"propagateEventRecordHighlight",ex:true},
	{p:"acceptEventRecordHighlight",ex:true},		
	{p:"propagateEventRecordList",ex:true},
	{p:"filterSliderImmediate",ex:true,tt:"Apply the change while sliding"},
	{p:"filterLogic",ex:"and|or",tt:"Specify logic to apply filters"},		
	{p:"&lt;field&gt;.filterValue"},
	{p:"&lt;field&gt;.filterValueMin"},
	{p:"&lt;field&gt;.filterValueMax"},
	{p:"&lt;field&gt;.filterValues"},
	{p:"&lt;field&gt;.filterMultiple",ex:true},
	{p:"&lt;field&gt;.filterMultipleSize",ex:5},
	{p:"filterShowCount",ex:false},
	{p:"filterShowTotal",ex:true},		
	{p:"&lt;field&gt;.filterLabel"},
	{p:"&lt;field&gt;.showFilterLabel"},
	{p:"&lt;field&gt;.filterVertical",ex:true},
	{p:"filterVertical",ex:true},				
	{p:"&lt;field&gt;.filterByStyle",ex:"background:white;"},
	{p:"&lt;field&gt;.includeAll",ex:false},
	{p:"&lt;field&gt;.filterSort",ex:false},
	{p:"&lt;field&gt;.filterSortCount",ex:false},		
	{p:"&lt;field&gt;.filterStartsWith",ex:true},
	{p:"&lt;field&gt;.filterDisplay",ex:"menu|tab|button|image"},
	{p:"&lt;field&gt;.filterOps",ex:"<,5000000,label1;>,5000000",tt:"Add menu with fixed filters"},
	{p:"excludeUndefined",ex:true,tt:"Exclude any records with an undefined value"},
	{p:"excludeZero",ex:true,tt:"Exclude any records with a 0 value"},
	{p:"recordSelectFilterFields",tt:"Set the value of other displays filter fields"},
	{p:"selectFields",ex:"prop:label:field1,...fieldN;prop:...."},
	{p:"match value", ex:"dataFilters=\"match(field=field,value=value,label=,enabled=);\"",tt:"Only show records that match"}, 		
	{p:"not match value",ex:"dataFilters=\"notmatch(field=field,value=value,label=,enabled=);\"",tt:"Only show records that dont match"},
	{p:"no missing values",ex:"dataFilters=\"nomissing(field=field,label=,enabled=);\"",tt:"Dont show missing values"},
	{p:"less than",ex:"dataFilters=\"lessthan(field=field,value=value,label=,enabled=);\""},
	{p:"greater than",ex:"dataFilters=\"greaterthan(field=field,value=value,label=,enabled=);\""},
	{p:"equals",ex:"dataFilters=\"equals(field=field,value=value,label=,enabled=);\""},
	{p:"not equals",ex:"dataFilters=\"notequals(field=field,value=value,label=,enabled=);\""},
	{p:"filterLatest",ex:"fields",tt:"Only show the latest records grouped by fields"},		
	{p:"filterDate",ex:"year",tt:"Show a simple pull down menu to select a year to display"},
	{p:"filterDateIncludeAll",ex:true,tt:"Include all years"},
	{p:"startDate",ex:"yyyy,MM,dd,hh,mm,ss",tt:"Filter data on date"},
	{p:"endDate",ex:"yyyy,MM,dd,hh,mm,ss",tt:"Filter data on date"},
	{inlineLabel:"Convert Data"},
	{p:"binDate",ex:"day|month|year",tt:"Bin the dates"},
	{p:"binType",ex:"count|average|total"},
	{p:"groupBy",ex:"field",tt:"Group the data"},
	{p:'convertData', label:"derived data", ex:"derived(field=new_field_id, function=foo*bar);",tt:"Add derived field"},
	{p:'convertData',label:"merge rows",ex:"mergeRows(keyFields=f1\\\\,f2, operator=count|sum|average, valueFields=);",tt:"Merge rows together"},
	{p:'convertData',label:"rotate data", ex:"rotateData(includeFields=true,includeDate=true,flipColumns=true);",tt:"Rotate data"},
	{p:'convertData',label:"percent increase",ex:"addPercentIncrease(replaceValues=false);",tt:"Add percent increase"},
	{p:'convertData',label:"doubling rate",ex:"doublingRate(fields=f1\\\\,f2, keyFields=f3);",tt:"Calculate # days to double"},
	{p:'convertData',label:"unfurl",ex:"unfurl(headerField=field to get header from,uniqueField=e.g. date,valueFields=);",tt:"Unfurl"},
	{p:'convertData',label:"Accumulate data",ex:"accum(fields=);",tt:"Accumulate"},
	{p:'convertData',label:"Add an average field",ex:"mean(fields=);",tt:"Mean"},
	{p:'convertData',label:"Prune where fields are all NaN",ex:"prune(fields=);",tt:"Prune"},		
	{p:'convertData',label:"Scale and offset",ex:"accum(scale=1,offset1=0,offset2=0,unit=,fields=);",tt:"(d + offset1) * scale + offset2"},		
	{label:"Color"},
	{p:"colors",ex:"color1,...,colorN",tt:"Comma separated array of colors"},
	{p:"colorBy",ex:"",tt:"Field id to color by"},
	{p:"colorByFields",ex:"",tt:"Show color by fields in a menu"},
	{p:"colorByLog",ex:"true",tt:"Use a log scale for the color by"},
	{p:"colorByMap",ex:"value1:color1,...,valueN:colorN",tt:"Specify colors for color by text values"},
	{p:"colorByInverse",ex:true,tt:"Inverse the values"},
	{p:"colorTableAlpha",ex:0.5,tt:"Set transparency on color table values"},
	{p:"colorTableInverse",ex:true,tt:"Inverse the color table"},
	{p:"colorTablePruneLeft",ex:"N",tt:"Prune first N colors"},
	{p:"colorTablePruneRight",ex:"N",tt:"Prune last N colors"},
	{p:"colorByMin",ex:"value",tt:"Min scale value"},
	{p:"colorByMax",ex:"value",tt:"Max scale value"},
	{p:"showColorTable",ex:"false",tt:"Display the color table"},
	{p:"showColorTableDots",ex:true},
	{p:"colorTableDotsDecimals",ex:"0"},
	{p:"colorTableSide",ex:"bottom|right|left|top"},
	{p:"showColorTableStride",ex:1,tt:"How many colors should be shown"},
	{p:"colorByAllRecords",ex:true,tt:"use all records for color range"},
	{p:"convertColorIntensity",ex:true},
	{p:"intensitySourceMin",ex:"0"},
	{p:"intensitySourceMax",ex:100},
	{p:"intensityTargetMin",ex:1},
	{p:"intensityTargetMax",ex:0},
	{p:"convertColorAlpha",ex:true},
	{p:"alphaSourceMin",ex:0},
	{p:"alphaSourceMax",ex:100},
	{p:"alphaTargetMin",ex:0},
	{p:"alphaTargetMax",ex:1},
	{label:"Animation"},
	{p:"doAnimation",ex:true},
	{p:"animationHighlightRecord",ex:true},
	{p:"animationHighlightRecordList",ex:true},
	{p:"acceptEventAnimationChange",ex:false},
	{p:"acceptDateRangeChange",ex:true},
	{p:"animationDateFormat",ex:"yyyy"},
	{p:"animationLabelSize",ex:"12pt"},
	{p:"animationStyle"},				
	{p:"animationTooltipShow",ex:"true"},
	{p:"animationTooltipDateFormat",ex:"yyyymmddhhmm"},		
	{p:"animationMode",ex:"sliding|frame|cumulative"},
	{p:"animationWindow",ex:"1 day|2 weeks|3 months|1 year|2 decades|etc"},
	{p:"animationStep",ex:"1 day|2 weeks|3 months|1 year|2 decades|etc"},
	{p:"animationSpeed",ex:500},
	{p:"animationLoop",ex:true},
	{p:"animationDwell",ex:1000},
	{p:'animationStartShowAll',ex:true,tt:'Show full range at start'},
	{p:"animationShowButtons",ex:false},
	{p:"animationShowSlider",ex:false},
	{p:"animationWidgetShort",ex:true}
    ];

    displayDefineMembers(this,myProps, {
        displayReady: Utils.getPageLoaded(),
        type: argType,
        displayManager: argDisplayManager,
        filters: [],
        dataCollection: new DataCollection(),
        selectedCbx: [],
        entries: [],
        wikiAttrs: [TITLE, "showTitle", "showDetails", "minDate", "maxDate"],
	_properties:[],
	getWikiEditorTags: function() {
	    return this._wikiTags;
	},
	getTypeDef: function() {
	    return this.typeDef;
	},
	getTypeLabel: function() {
	    if(!this.typeDef) return null;
	    return this.typeDef.label;
	},
	getTypeHelpUrl: function() {
	    if(!this.typeDef) return null;
	    let helpUrl = this.typeDef.helpUrl;
	    if(!helpUrl) return null;
	    if(helpUrl===true) {
		return "https://ramadda.org/repository/alias/help_" + this.typeDef.type;
	    }
	    return helpUrl;
	},
	defineSizeByProperties: function() {
	    this.defineProperties([
		{inlineLabel:'Size By'},
	    	{p:'sizeBy',ex:'field',tt:'Field to size points by'},
		{p:'sizeByLog',ex:true,tt:'Use log scale for size by'},
		{p:'sizeByMap', ex:'value1:size,...,valueN:size',tt:'Define sizes if sizeBy is text'},
		{p:'sizeByRadiusMin',ex:'2',tt:'Scale size by'},
		{p:'sizeByRadiusMax',ex:'20',tt:'Scale size by'},
		{p:'sizeByLegendSide',ex:'bottom|top|left|right'},,
		{p:'sizeByLegendStyle'},
		{p:'sizeBySteps',ex:'value1:size1,v2:s2,...',tt:'Use steps for sizes'},
	    ]);
	},

        getDisplayManager: function() {
            return this.displayManager;
        },
        getLayoutManager: function() {
            return this.getDisplayManager().getLayoutManager();
        },
        addToDocumentUrl: function(key, value) {
	    HU.addToDocumentUrl("display"+ this.displayCount+"." + key,value);
	},


	getAnimationEnabled: function() {
	    return this.getProperty("doAnimation", false);
	},
	getAnimation: function() {
	    if(!this.animationControl) {
		this.animationControl = new DisplayAnimation(this,this.getAnimationEnabled());
	    }
	    return this.animationControl;
	},
        propagateEvent: function(func, data) {
            var dm = this.getDisplayManager();
            dm[func](this, data);
        },
        displayError: function(msg) {
            this.displayHtml(HU.getErrorDialog(msg));
        },
        clearHtml: function() {
            this.displayHtml("");
        },
        displayHtml: function(html) {
            this.setContents(html);
        },
        notifyEvent: function(func, source, data) {
            if (this[func] == null) {
                return;
            }
            this[func].apply(this, [source, data]);
        },
	getColorTableHorizontal: function() {
	    return this.getProperty("colorTableSide","bottom") == "bottom" || this.getProperty("colorTableSide","bottom") == "top";
	},
        displayColorTable: function(ct, domId, min, max, args) {
	    if(!args) args = {};
	    args.showColorTableDots = this.getProperty("showColorTableDots");
	    args.decimals = this.getProperty("colorTableDotsDecimals",-1);
	    args.showRange = this.getProperty("colorTableShowRange");
	    let labels = this.getProperty("colorTableLabels");
	    args.labels = labels?labels.split(","):null;
	    args.labelStyle=this.getProperty("colorTableLabelStyle","font-size:12pt;");
	    args.horizontal= this.getColorTableHorizontal();
	    args.stride = this.getProperty("showColorTableStride",1);
            Utils.displayColorTable(ct, this.getDomId(domId), min, max, args);
	    if(!args || !args.colorByInfo) return;
	    this.jq(domId).find(".display-colortable-slice").css("cursor","pointer");
	    let _this = this;
	    if(!this.originalColorRange) {
		this.originalColorRange = [min,max];
	    }		
	    this.jq(domId).find(".display-colortable-slice").click(function(e) {
		let val = $(this).attr("data-value");
		let popup = HtmlUtils.getTooltip();
		HtmlUtils.setPopupObject(popup);
		let html = "";
		html += HU.div([CLASS,"ramadda-menu-item","what","setmin"],"Set range min to " + Utils.formatNumber(val));
		html += HU.div([CLASS,"ramadda-menu-item","what","setmax"],"Set range max to " + Utils.formatNumber(val));
		html += HU.div([CLASS,"ramadda-menu-item","what","reset"],"Reset range");
		if(_this.getProperty("colorByLog")) {
		    html += HU.div([CLASS,"ramadda-menu-item","what","togglelog"],"Use linear scale");
		} else {
		    html += HU.div([CLASS,"ramadda-menu-item","what","togglelog"],"Use log scale");
		}
		html += Utils.getColorTablePopup();
		popup.html(html);
		$(popup).find(".ramadda-colortable-select").click(function() {
		    let ct = $(this).attr("colortable");
		    if(ct) {
			console.log("color table:" + ct);
			_this.setProperty("colorTable",ct);
			_this.forceUpdateUI();
		    }		    
		});
		popup.show();
		popup.position({
                    of: $(this),
                    my: 'left top',
                    at: 'left bottom',
                    collision: "none none"
		});
		popup.find(".ramadda-menu-item").click(function() {
		    let what = $(this).attr("what");
		    if(what == "reset") {
			_this.setProperty("colorByMin",_this.getProperty("colorByMinOrig"));
			_this.setProperty("colorByMax",_this.getProperty("colorByMaxOrig"));
			_this.setProperty("overrideColorRange", false);
		    } else if(what == "togglelog") {
			if(!_this.getProperty("colorByLog")) 
			    _this.setProperty("colorByLog",true);
			else
			    _this.setProperty("colorByLog",false);
 		    } else if(what == "setmin") {
			if(!Utils.isDefined(_this.getProperty("colorByMinOrig"))) {
			    _this.setProperty("colorByMinOrig",_this.getProperty("colorByMin"));
			}
			_this.setProperty("colorByMin",val);
			_this.setProperty("overrideColorRange", true);
		    } else {
			if(!Utils.isDefined(_this.getProperty("colorByMaxOrig"))) {
			    _this.setProperty("colorByMaxOrig",_this.getProperty("colorByMax"));
			}
			_this.setProperty("colorByMax",val);
			_this.setProperty("overrideColorRange", true);
		    }
		    _this.forceUpdateUI();
		});
	    });
        },
	getUnhighlightColor: function() {
	    return this.getProperty("unhighlightColor","#eee");
	},
	getColorList:function() {
	    if(this.colorList && this.colorList.length>0) {
		return this.colorList;
	    }
	    if (this.getProperty("colors") && this.getProperty("colors")!="default") {
		var v = this.getProperty("colors");
		if(!Array.isArray(v)) {
		    v = v.split(",");
		}
		this.colorList =  v;
	    }
	    if(!this.colorList || this.colorList.length==0) {
		this.colorList= ['blue', 'red', 'green', 'orange', 'fuchsia', 'aqua',   'navy', 'brown','cadetblue','blueviolet','coral','cornflowerblue','darkcyan','darkgoldenrod','darkorange','darkseagreen'];
	    }
	    return this.colorList;
	},
        getColorTableName: function(names) {
	    if(names && !Array.isArray(names)) names  = [name];
            let ct = null;
            if (names) {
		names.every(name=>{
                    ct = this.getProperty(name);
		    if(ct) return false;
		    return true;
		});
            } else {
		var colorBy = this.getProperty("colorBy");
		if(colorBy) {
                    ct = this.getProperty("colorTable." + colorBy);
		}
		if(!ct) {
                    ct = this.getProperty("colorBar", this.getProperty("colorTable"));
		}
            }
            if (ct == "none") return null;
            return ct;
        },
	getColorTable: function(justColors, name, dflt) {
            let colorTable = this.getColorTableName(name);
            if (!colorTable) {
                colorTable = dflt;
            }
	    return this.getColorTableInner(justColors, colorTable);
	},
	getColorTableInner: function(justColors, colorTable) {
	    let list;
            if (colorTable) {
                let ct = null;
 		if(colorTable.startsWith("colors:")) {
		    list = colorTable.substring("colors:".length).split(",");
                    return this.convertColors(list);
		}
                ct = Utils.ColorTables[colorTable];
                if (ct && justColors) {
		    return this.convertColors(ct.colors);
		}
                if (!ct && name) {
                    return this.convertColors(colorTable.split(","));
                }
                return ct;
            }
            if (this.getProperty("colors") && this.getProperty("colors")!="default") {
                var colors = this.getProperty("colors");
                if ((typeof colors) != "object") colors = colors.split(",");
		return this.convertColors(colors);
            }
            return null;
        },
	addAlpha: function(colors, alpha) {
	    if(!colors) return null;
	    alpha = Utils.isDefined(alpha)?alpha:this.getProperty("colorTableAlpha");
	    if(!alpha) return colors;
	    colors=  Utils.cloneList(colors);
	    var ac = [];
	    colors.forEach((c)=>{
		ac.push(Utils.addAlphaToColor(c,alpha));
	    });
	    return ac;
        },
        convertColors: function(colors) {
	    colors = this.addAlpha(colors);
	    if(this.getProperty("colorTableInverse")) {
		let tmp = [];
		for(let i=colors.length-1;i>=0;i--)
		    tmp.push(colors[i]);
		colors = tmp;
	    }
	    if(this.getProperty("colorTablePruneLeft")) {
		let tmp = [];
		for(let i=+this.getProperty("colorTablePruneLeft");i<colors.length;i++) {
		    tmp.push(colors[i]);
		}
		colors = tmp;
	    }
	    if(this.getProperty("colorTablePruneRight")) {
		let tmp = [];
		let d = +this.getProperty("colorTablePruneRight");
		for(let i=0;i<colors.length-d;i++) {
		    tmp.push(colors[i]);
		}
		colors = tmp;
	    }
	    return colors;
	},

        getColorByColors: function(records, dfltColorTable) {
            var colorBy = this.getProperty("colorBy");
            if (!colorBy) {
                return null;
            }
            var colorByField = this.getFieldById(fields, colorBy);
            if (!colorByField) {
                return null;
            }
            var obj = this.getColumnValues(records, colorByField);
            var colors = this.getColorTable();
            if (!colors) colors = Utils.getColorTable(dfltColorTable || "blue_white_red");
            if (!colors) return null;
            var min = parseFloat(this.getProperty("colorByMin", obj.min));
            var max = parseFloat(this.getProperty("colorByMax", obj.max));
            if (colors.colors) colors = colors.colors;
            var range = max - min;
            var colorValues = [];
            for (var i = 0; i < obj.values.length; i++) {
                var value = obj.values[i];
                var percent = (value - min) / range;
                var index = parseInt(percent * colors.length);
                if (index >= colors.length) index = colors.length - 1;
                else if (index < 0) index = 0;
                colorValues.push(colors[index]);
            }
            return {
                colors: colorValues,
                min: min,
                max: max
            };
        },
	getDefaultGridByArgs: function() {
	    let doHeatmap=this.getProperty("doHeatmap",false);
	    let args =  {
		display:this,
		shape:this.getProperty("cellShape","rect"),
		color: this.getProperty("cellColor","blue"),
		stroke: !this.getProperty("cellFilled",true),
		cellSize: this.getProperty("cellSize",doHeatmap?0:4),
		cellSizeH: this.getProperty("cellSizeH",20),
		cellSizeHBase: this.getProperty("cellSizeHBase",0),
		cell3D:this.getProperty("cell3D",false),
		cellShowText:this.getProperty("cellShowText",false),
		cellLabels:Utils.split(this.getProperty("cellLabels")),
		cellFonts:Utils.split(this.getProperty("cellFonts")),
		cellLabelColors:Utils.split(this.getProperty("cellLabelColor")),
		cellLabelPositions:Utils.split(this.getProperty("cellLabelPositions")),
		cellLabelOffsetsX:Utils.split(this.getProperty("cellLabelOffsetsX")),
		cellLabelOffsetsY:Utils.split(this.getProperty("cellLabelOffsetsY")),
		doHeatmap:doHeatmap,
		operator:this.getProperty("hm.operator","count"),
		filter:this.getProperty("hm.filter")
	    };
	    args.cellSizeX = +this.getProperty("cellSizeX",args.cellSize);
	    args.cellSizeY = +this.getProperty("cellSizeY",args.cellSize);
	    return args;
	},
	getIconMap: function() {
	    var iconMap;
	    var iconMapProp = this.getProperty("iconMap");
	    if (iconMapProp) {
                var toks = iconMapProp.split(",");
		iconMap = {};
                for (var i = 0; i < toks.length; i++) {
		    var toks2 = toks[i].split(":");
		    if (toks2.length > 1) {
                        iconMap[toks2[0]] = toks2[1];
		    }
		}
            }
	    return iconMap;
	},
	getColorByInfo: function(records, prop,colorByMapProp, defaultColorTable,propPrefix) {
            var pointData = this.getData();
            if (pointData == null) return null;
	    if(this.getProperty("colorByAllRecords")) {
		records = pointData.getRecords();
	    }
	    var fields = pointData.getRecordFields();
	    return new ColorByInfo(this, fields, records, prop,colorByMapProp, defaultColorTable, propPrefix);
	},
	getColorByMap: function(prop) {
	    prop = this.getProperty(prop||"colorByMap");
	    this.debugGetProperty=false;
	    return Utils.parseMap(prop);
        },
        toString: function() {
            return  this.type + " - " + this.getId();
        },
        getType: function() {
            return this.type;
        },
        getClass: function(suffix) {
            if (suffix == null) {
                return this.getBaseClass();
            }
            return this.getBaseClass() + "-" + suffix;
        },
        getBaseClass: function() {
            return "display-" + this.getType();
        },
        setDisplayManager: function(cm) {
            this.displayManager = cm;
            this.setDisplayParent(cm.getLayoutManager());
        },
        setContents: function(contents,dontWrap) {
            this.clearDisplayMessage();
            if(!dontWrap)
		contents = HU.div([ATTR_CLASS, "display-contents-inner display-" + this.getType() + "-inner"], contents);
            this.writeHtml(ID_DISPLAY_CONTENTS, contents);
        },
        addEntry: function(entry) {
            this.entries.push(entry);
        },
        clearCachedData: function() {},
        setEntry: function(entry) {
	    if(this.getProperty("shareSelected")) {
		return;
	    }
	    if(!this.getProperty("acceptSetEntry",true)) {
		return;
	    }	    
            this.entries = [];
            this.addEntry(entry);
            this.entry = entry;
            this.entryId = entry.getId();
            this.clearCachedData();
            if (this.properties.theData) {
                this.dataCollection = new DataCollection();
                var attrs = {
                    entryId: this.entryId,
                    lat: this.getProperty("latitude"),
                    lon: this.getProperty("longitude"),
                };
                this.properties.theData = this.data = new PointData(entry.getName(), null, null, this.getRamadda().getRoot() + "/entry/show?entryid=" + entry.getId() + "&output=points.product&product=points.json&max=5000", attrs);
		this.startProgress();
                this.data.loadData(this);
            } else {
		this.callUpdateUI();
	    }
            var title = "";
            if (this.getShowTitle()) {
                this.jq(ID_TITLE).html(entry.getName());
            }
        },
        getTextColor: function(property, dflt) {
            if (property) return this.getProperty(property, this.getProperty("textColor",dflt));
            return this.getProperty("textColor", "#000");
        },
        getTitleHtml: function(title) {
            var titleToShow = "";
            if (this.getShowTitle()) {
                var titleStyle = HU.css("color" , this.getTextColor("titleColor","#000"));
                var bg = this.getProperty("titleBackground");
                if (bg) titleStyle += HU.css('background', bg,'padding','2px','padding-right','6px','padding-left','6px');
                titleToShow = this.getShowTitle() ? this.getDisplayTitle(title) : "";
		let entryId = this.getProperty("entryId") || this.entryId;
                if (entryId) {
                    titleToShow = HU.href(this.getRamadda().getEntryUrl(entryId), titleToShow, [ATTR_CLASS, "display-title",  STYLE, titleStyle]);
		}
		titleToShow =HU.span([ID,this.domId(ID_TITLE)],titleToShow);
            }

	    if(this.getProperty("showEntryIcon")) {
		let icon = this.getProperty("entryIcon");
		if(icon) titleToShow  = HU.image(icon) +" " + titleToShow;
	    }
            return titleToShow;
        },
        handleEventMapClick: function(source, args) {
            if (!this.dataCollection) return;
            var pointData = this.dataCollection.getList();
            for (var i = 0; i < pointData.length; i++) {
                pointData[i].handleEventMapClick(this, source, args.lon, args.lat);
            }
        },

        handleEventMapBoundsChanged: function(source, args) {
	    if(this.getProperty("acceptBoundsChange")) {
		this.filterBounds  = args.bounds;
		this.callUpdateUI();
            }
        },

        handleEventFieldValueSelected: function(source, args) {
            this.setProperty("filterPattern", args.value);
            this.setProperty("patternFilterField", args.field.getId());
            this.callUpdateUI();
        },
        setDateRange: function(min, max, doDay) {
	    this.minDateObj = min;
	    this.maxDateObj = max;
	    this.dateRangeDoDay = doDay;
//	    console.log("setDateRange: " + this.minDateObj +" " + this.maxDateObj);
	},
        handleDateRangeChanged: function(source, prop) {
	    this.setDateRange(prop.minDate, prop.maxDate);
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().setDateRange(prop.minDate, prop.maxDate);
	    }
	    this.haveCalledUpdateUI = false;
	    this.dataFilterChanged();
	},
	displayFieldsChanged:  function(val, fromElsewhere) {
	    this.addToDocumentUrl(PROP_FIELDS,val);
	    this.setProperty(PROP_FIELDS,val);
	    this.callUpdateUI();
    
	    if(this.displayFieldsMenuEnums && fromElsewhere && this.getProperty("showDisplayFieldsMenu")) {
		let selected = [];
		this.jq("displayfields").val(val);
	    }
	},
        handleEventPropertyChanged: function(source, prop) {
	    let debug = displayDebug.handleEventPropertyChanged;
	    if(prop.property == "dateRange") {
		if(this.getProperty("acceptDateRangeChange")) {
		    this.handleDateRangeChanged(source, prop);
		}
		return;
	    }
	    
	    if(prop.property == "displayFields") {
		if(!this.getProperty("acceptEventDisplayFieldsChange",false)) {
		    return;
		}
		this.displayFieldsChanged(prop.value, true);
		return
	    }

	    if(prop.property == "macroValue") {
		if(prop.entryId!= this.entryId) return;
		if(!this.getProperty("acceptRequestChangeEvent",true)) {
		    return;
		}
		let macros = this.getRequestMacros();
		let macro = null;
		macros.every(m=>{
		    if(m.isMacro(prop.id)) {
			macro = m;
			return false;
		    }
		    return true;
		});

		if(!macro) {
		    return;
		}

		if(!this.getProperty("request." + macro.name + ".acceptChangeEvent",true)) {
		    return;
		}

		macro.setValue(prop);



		if(debug)
		    console.log(this.getId() +" event-reloading");
		this.reloadData();
		return;
	    }

	    if (prop.property == PROP_FILTER_VALUE) {
		if(!this.getProperty("acceptEventFilter",true)) {
		    return;
		}
		this.haveCalledUpdateUI = false;
		let properties = prop.properties;
		if(!properties) {
		    properties=[];
		    properties.push(prop);
		}
		this.settingFilterValue = true;
		properties.forEach(prop=> {
		    let widgetId = this.getFilterId(prop.fieldId);
		    if(prop.id && prop.id.endsWith("date1")) {
			widgetId+="_date1";
		    } else 	if(prop.id && prop.id.endsWith("date2")) {
			widgetId+="_date2";
		    }
		    if(prop.fieldId == "_highlight") {
			this.jq(ID_FILTER_HIGHLIGHT).val(prop.value);
			this.setProperty("filterHighlight", prop.value=="highlight");
		    } else 	if(Utils.isDefined(prop.value2)) {
			$("#" +widgetId+"_min").val(prop.value);
			$("#" +widgetId+"_min").attr("data-value", prop.value);
			$("#" +widgetId+"_max").val(prop.value2);
			$("#" +widgetId+"_max").attr("data-value", prop.value2);
		    } else {
			var widget = $("#"+widgetId);
			if(widget.attr("isCheckbox")) {
			    var on = widget.attr("onValue");
			    var off = widget.attr("offValue");
			    widget.prop('checked',prop.value.includes(on));
			} else {
			    widget.val(prop.value);
			}
			widget.attr("data-value",prop.value);
			if(widget.attr("isButton")) {
			    widget.find(".display-filter-button").removeClass("display-filter-button-selected");
			    widget.find("[value='" + prop.value +"']").addClass("display-filter-button-selected");
			}
		    }
		});
		this.settingFilterValue = false;
		this.dataFilterChanged();
		return;
            }
            this.setProperty(prop.property, prop.value);
            this.callUpdateUI();
        },
        handleEventRecordList: function(source, args) {
	    if(this.getAnimationEnabled() && this.getProperty("animationHighlightRecordList")) {
		this.getAnimation().setRecordListHighlight(args.recordList);
	    }
	    if(this.getProperty("acceptEventRecordList",false)) {
		this.recordListOverride = args.recordList;
		this.haveCalledUpdateUI = false;
		this.callUpdateUI();
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    if(this.getAnimation().getEnabled() &&  !args.skipAnimation) {
		this.getAnimation().handleEventRecordHighlight(source, args);
	    }
	},
        handleEventAnimationChanged: function(source, args) {
	    if(!this.getProperty("acceptEventAnimationChange",true)) return;
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().handleEventAnimationChanged(args);
	    }
	},
        propagateEventRecordSelection: function(args) {
	    this.getDisplayManager().notifyEvent("handleEventRecordSelection", this, args);
	    if(this.getProperty("recordSelectFilterFields")) {
		let fields = this.getFieldsByIds(null,this.getProperty("recordSelectFilterFields"));
		if(fields && fields.length>0) {
		    let props = {
			property: PROP_FILTER_VALUE,
			properties:[]
		    };
		    fields.forEach(field=>{
			props.properties.push({
			    id:field.getId(),
			    fieldId: field.getId(),
			    value: args.record.getValue(field.getIndex())
			});
		    })
		    this.propagateEvent("handleEventPropertyChanged", props);
		}
	    }
	},
        handleEventRecordSelection: function(source, args) {
	    this.selectedRecord= args.record;
	    if(this.selectedRecord) {
		if(this.getProperty("colorThresholdField")) {
		    this.haveCalledUpdateUI = false;
		    this.callUpdateUI();
		}
	    }



            if (!source.getEntries) {
                return;
            }
            var entries = source.getEntries();
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                var containsEntry = this.getEntries().indexOf(entry) >= 0;
                if (containsEntry) {
                    this.highlightEntry(entry);
                    break;
                }
            }
        },
        areaClear: function() {
            this.getDisplayManager().notifyEvent("handleEventAreaClear", this);
        },
        handleEventEntryMouseover: function(source, args) {},
        handleEventEntryMouseout: function(source, args) {},
        handleEventEntrySelection: function(source, args) {
            var containsEntry = this.getEntries().indexOf(args.entry) >= 0;
            if (!containsEntry) {
                return;
            }
            if (args.selected) {
                this.jq(ID_TITLE).addClass("display-title-select");
            } else {
                this.jq(ID_TITLE).removeClass("display-title-select");
            }
        },
        highlightEntry: function(entry) {
            this.jq(ID_TITLE).addClass("display-title-select");
        },
        getEntries: function() {
            return this.entries;
        },
        getDisplayEntry: async function(callback) {
            var entries = this.getEntries();
            if (entries != null && entries.length > 0) {
                return Utils.call(callback, entries[0]);
            }
            if (this.entryId) {
                var entry;
                await this.getRamadda().getEntry(this.entryId, e => {
                    entry = e
                    Utils.call(callback, entry);
                });
            } else {
		Utils.call(callback, null);
	    }
        },
        hasEntries: function() {
            return this.entries != null && this.entries.length > 0;
        },
        getWaitImage: function() {
            return HU.image(ramaddaBaseUrl + "/icons/progress.gif");
        },
	useDisplayMessage:function() {
	    return true;
	},
	setDisplayMessage:function(msg) {
	    let contents =  this.jq(ID_DISPLAY_CONTENTS);
	    let minHeight = contents.css("min-height");
	    if(!minHeight || minHeight=="0px") {
		contents.css("min-height","75px");
		contents.attr("display-set-minheight","true");
	    }
	    this.jq(ID_DISPLAY_MESSAGE).html(msg);
	    this.jq(ID_DISPLAY_MESSAGE).show();
	},
	clearDisplayMessage:function() {
	    let contents =  this.jq(ID_DISPLAY_CONTENTS);
	    this.jq(ID_DISPLAY_MESSAGE).hide();
	    if(contents.attr("display-set-minheight")!=null) {
		contents.css("min-height","");
	    }
	},	
        getLoadingMessage: function(msg) {
	    if(this.getAcceptEventDataSelection()) {
		return "";
	    }

	    //Check if we didn't have any data specified
	    if(!msg && !this.getProperty("theData")) {
		msg = "No data specified"
	    }
	    if (!msg) msg = this.getProperty("loadingMessage", "icon_progress Loading data...");
	    if(msg=="") return "";
	    msg = msg.replace("icon_progress",HU.image(icon_progress));
	    if(this.useDisplayMessage()) {
		return SPACE+msg;
	    } 
            return HU.div([STYLE, HU.css("text-align","center")], this.getMessage(SPACE + msg));
        },
	reloadData: function() {
	    this.startProgress();
	    this.haveCalledUpdateUI = false;
	    if(this.getProperty("okToLoadData",true))  {
		let pointData = this.dataCollection.getList()[0];
		pointData.loadData(this,true);
	    }
	},
        getMessage: function(msg) {
            return HU.div([ATTR_CLASS, "display-output-message"], msg);
        },
	getNoDataMessage: function() {
	    return this.getProperty("noDataMessage","No data available");
	},
        getFieldValue: function(id, dflt) {
            var jq = $("#" + id);
            if (jq.length > 0) {
                return jq.val();
            }
            return dflt;
        },
        getFieldValues: function(id, dflt) {
            var jq = $("#" + id);
            if (jq.length > 0) {
		let v = [];
		jq.each(function(){
		    v.push($(this).val());
		});
		return v;
            }
            return dflt;
        },

        getFooter: function() {
            return HU.div([ATTR_ID, this.getDomId(ID_FOOTER), ATTR_CLASS, "display-footer"],
			  HU.leftRight(HU.div([ATTR_ID, this.getDomId(ID_FOOTER_LEFT), ATTR_CLASS, "display-footer-left"], ""),
				       HU.div([ATTR_ID, this.getDomId(ID_FOOTER_RIGHT), ATTR_CLASS, "display-footer-right"], "")));
        },
        shouldSkipField: function(field) {
            if (this.skipFields && !this.skipFieldsList) {
                this.skipFieldsList = this.skipFields.split(",");
            }

            if (this.skipFieldsList) {
                return this.skipFieldsList.indexOf(field.getId()) >= 0;
            }
            return false;
        },
        fieldSelected: function(event) {
            this.userHasSelectedAField = true;
            this.selectedFields = null;
            this.overrideFields = null;
            this.removeProperty(PROP_FIELDS);
            this.fieldSelectionChanged();
            if (event.shiftKey) {
                var fields = this.getSelectedFields();
                this.propagateEvent("handleEventFieldsSelected", fields);
            }
        },
        addFieldsCheckboxes: function(argFields) {
            if (!this.hasData()) {
                return;
            }
            var fixedFields = this.getPropertyFields()
            if (fixedFields != null) {
                if (fixedFields.length == 0) {
                    fixedFields = null;
                }
            }

            var html = "";
            var checkboxClass = this.getId() + "_checkbox";
            var groupByClass = this.getId() + "_groupby";
            var dataList = this.dataCollection.getList();

            if (argFields != null) {
                this.overrideFields = [];
            }
            var seenLabels = {};


            let badFields = {};
            let flags = null;
            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                let pointData = dataList[collectionIdx];
                let fields = this.getFieldsToSelect(pointData);
                if (this.canDoGroupBy()) {
                    let allFields = pointData.getRecordFields();
                    let cnt = 0;
                    for (i = 0; i < allFields.length; i++) {
                        let field = allFields[i];
                        if (field.getType() != "string") continue;
                        if (cnt == 0) {
                            html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Group By");
                            html += HU.open(TAG_DIV, [ATTR_CLASS, "display-fields"]);
                            var on = this.groupBy == null || this.groupBy == "";
                            html += HU.tag(TAG_DIV, [ATTR_TITLE, "none"],
					   HU.radio("none", this.getDomId("groupby"), groupByClass, "none", !on) + " None");
                        }
                        cnt++;
                        var on = this.groupBy == field.getId();
                        var idBase = "groupby_" + collectionIdx + "_" + i;
                        field.radioId = this.getDomId(idBase);
                        html += HU.tag(TAG_DIV, [ATTR_TITLE, field.getId()],
				       HU.radio(field.radioId, this.getDomId("groupby"), groupByClass, field.getId(), on) + " " + field.getUnitLabel() + " (" + field.getId() + ")"
				      );
                    }
                    if (cnt > 0) {
                        html += HU.close(TAG_DIV);
                    }
                }

                if ( /*this.canDoMultiFields() && */ fields.length > 0) {
                    var selected = this.getSelectedFields([]);
                    var selectedIds = [];
                    for (i = 0; i < selected.length; i++) {
                        selectedIds.push(selected[i].getId());
                    }
                    var disabledFields = "";
                    html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Displayed Fields");
                    html += HU.open(TAG_DIV, [ATTR_CLASS, "display-fields"]);
                    for (var tupleIdx = 0; tupleIdx < fields.length; tupleIdx++) {
                        var field = fields[tupleIdx];
                        var idBase = "cbx_" + collectionIdx + "_" + tupleIdx;
                        field.checkboxId = this.getDomId(idBase);
                        var on = false;
                        var hasValues = (flags ? flags[field.getIndex()] : true);
                        //                            console.log(tupleIdx + " field: " + field.getId() + "has values:" + hasValues);
                        if (argFields != null) {
                            //                                console.log("argFields:" + argFields);
                            for (var fIdx = 0; fIdx < argFields.length; fIdx++) {
                                if (argFields[fIdx].getId() == field.getId()) {
                                    on = true;
                                    //                                        console.log("argField:"+ argFields[fIdx].getId()+ " field.id:" + field.getId() +" on:" +on);
                                    this.overrideFields.push(field.getId());
                                    break;
                                }
                            }
                        } else if (selectedIds.length > 0) {
                            on = selectedIds.indexOf(field.getId()) >= 0;
                            //                                console.log("selected ids   on:" + on +" " + field.getId());
                        } else if (fixedFields != null) {
                            on = (fixedFields.indexOf(field.getId()) >= 0);
                            if (!on) {
                                on = (fixedFields.indexOf("#" + (tupleIdx + 1)) >= 0);
                            }
                            //                                console.log("fixed fields  on:" + on +" " + field.getId());
                        } else if (this.overrideFields != null) {
                            on = this.overrideFields.indexOf(field.getId()) >= 0;
                            if (!on) {
                                on = (this.overrideFields.indexOf("#" + (tupleIdx + 1)) >= 0);
                            }
                            //                                console.log("override fields  on:" + on +" " + field.getId());
                        } else {
                            if (this.selectedCbx.indexOf(field.getId()) >= 0) {
                                on = true;
                            } else if (this.selectedCbx.length == 0) {
                                on = (i == 0);
                            }
                            //                                console.log("cbx fields:" + on + " " + field.getId());
                        }
                        var label = field.getUnitLabel();
                        if (seenLabels[label]) {
                            label = label + " " + seenLabels[label];
                            seenLabels[label]++;
                        } else {
                            seenLabels[label] = 1;
                        }

                        if (!hasValues) {
                            disabledFields += HU.div([], label);
                        } else {
                            if (field.derived) {
                                label += " (derived)";
                            }
                            var widget;
                            if (this.canDoMultiFields()) {
                                widget = HU.checkbox(field.checkboxId, [CLASS, checkboxClass], on);
                            } else {
                                widget = HU.radio(field.checkboxId, "field_radio", checkboxClass, "", on);
                            }

                            html += HU.tag(TAG_DIV, [ATTR_TITLE, field.getId()],
					   widget + " " + label
					  );
                        }
                        //                        html+= "<br>";
                    }
                }
                if (disabledFields != "") {
                    html += HU.div([STYLE, HU.css("border-top","1px #888  solid")], "<b>No Data Available</b>" + disabledFields);
                }
                html += HU.close(TAG_DIV);
            }


            this.writeHtml(ID_FIELDS, html);

            this.userHasSelectedAField = false;
            var theDisplay = this;
            //Listen for changes to the checkboxes
            $("." + checkboxClass).click(function(event) {
                theDisplay.fieldSelected(event);
            });

            $("." + groupByClass).change(function(event) {
                theDisplay.groupBy = $(this).val();
                if (theDisplay.displayData) {
                    theDisplay.displayData();
                }
            });
        },
        fieldSelectionChanged: function() {
            var name = "the display";
            this.setDisplayTitle();
            if (this.displayData) {
                this.clearCachedData();
                this.displayData();
            }
        },
        defaultSelectedToAll: function() {
            return true;
        },
        setSelectedFields: function(fields) {
            this.clearCachedData();
            this.selectedFields = fields;
            this.addFieldsCheckboxes(fields);
        },
        getSelectedFields: function(dfltList) {
	    let debug = displayDebug.getSelectedFields;
	    if(debug)
		console.log(this.type +".getSelectedFields");
	    if(this.getBinDate()) {
		var binType = this.getBinType("total");
		var binCount = binType=="count";
		if(binCount) {
		    var fields = [];
		    fields.push(new RecordField({
			id:binType,
			label:this.getProperty("binDateLabel", this.getProperty("binCountLabel","Count")),
			type:"double",
			chartable:true
		    }));		    
		    return fields;
		} 
	    }


            this.debugSelected = debug;
            this.lastSelectedFields = this.getSelectedFieldsInner(dfltList);
	    let notFields = this.getProperty("notFields");
	    if(notFields) {
		let tmp = [];
		this.lastSelectedFields.forEach(f=>{
		    if(f.getId().match(notFields) || f.getLabel().match(notFields)) return;
		    tmp.push(f);
		});
		this.lastSelectedFields = tmp;
	    }


	    if(debug)
		console.log("\tsetting lastSelectedFields:" + this.lastSelectedFields);
            var fixedFields = this.getPropertyFields();

	    //NOT NOW as this nukes the fields property
            //if (fixedFields) fixedFields.length = 0;

            this.setDisplayTitle();
	    if(this.getBinDate()) {
		var binType = this.getProperty("binType","total");
		let fields = [];
		this.lastSelectedFields.forEach(field=>{
		    if(!field.isNumeric()) {
			fields.push(field);
		    } else {
			const prefix = binType;
			if(field.getId().startsWith(prefix)) {
			    fields.push(field);
			} else {
			    fields.push(new RecordField({
				id:prefix +"_"+ field.getId(),
				index:  field.getIndex(),
				label:this.getProperty("binDateLabel", Utils.camelCase(binType) +" of " + field.getLabel()),
				type:"double",
				chartable:field.isChartable()
			    }));
			}
		    }
		});
		this.lastSelectedFields = fields;
	    }
	    //	    console.log("fields:" + this.lastSelectedFields);
	    return this.lastSelectedFields;
        },
        getSelectedFieldsInner: function(dfltList) {
            if (this.debugSelected) {
                console.log("getSelectedFieldsInner dflt:" + (dfltList ? dfltList : "null"));
                console.log("\tlast selected = " + this.lastSelectedFields);
	    }
            if (this.selectedFields) {
                if (this.debugSelected)
                    console.log("\treturning this.selectedFields:" + this.selectedFields);
                return this.selectedFields;
            }
            var df = [];
            var dataList = this.dataCollection.getList();
            //If we have fixed fields then clear them after the first time
            var fixedFields = this.getPropertyFields();
            if (fixedFields && (typeof fixedFields) == "string") {
                fixedFields  = fixedFields.split(",");
	    }
	    if(fixedFields) {
		let tmpFields  = [];
		fixedFields.forEach(tok=>{
		    if(!tok.match("-")) {
			tmpFields.push(tok);
			return;
		    }
		    let pair = tok.split("-");
		    let i1 = parseFloat(pair[0].trim().substring(1));
		    let i2 = parseFloat(pair[1].trim().substring(1));
		    for(let i=i1;i<=i2;i++) tmpFields.push("#" + i);
		    
		});
		fixedFields = tmpFields;
	    }

	    let aliases= {};
	    var tmp = this.getProperty("fieldAliases");
	    if(tmp) {
		tmp.split(",").forEach(tok=>{
		    [name,alias] =   tok.split(":");
		    aliases[alias] = name;
		});
	    }
            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                var pointData = dataList[collectionIdx];
                var fields = this.getFieldsToSelect(pointData);
                if (fixedFields != null && fixedFields.length > 0) {
                    if (this.debugSelected)
                        console.log("\thave fixed fields:" + fixedFields.length);
		    let selected = [];
                    for (var i = 0; i < fixedFields.length; i++) {
                        var sfield = fixedFields[i];
			if(sfield =="*") {
			    selected  =fields;
			    break;
			}
			var field = this.getFieldById(fields, sfield);
                        if(field) {
			    selected.push(field);
			}
                    }
		    if(this.getProperty("fieldsNumeric")) {
			selected = selected.filter(f=>f.isNumeric());
		    }		    
		    df = selected;
		}
	    }

            if (fixedFields != null && fixedFields.length > 0) {
                if (this.debugSelected)
                    console.log("\tfrom fixed:" + df.length);
                return df;
            }

            var fieldsToSelect = null;
            var firstField = null;
            this.selectedCbx = [];
            var cbxExists = false;

            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                var pointData = dataList[collectionIdx];
                fieldsToSelect = this.getFieldsToSelect(pointData);
                for (i = 0; i < fieldsToSelect.length; i++) {
                    var field = fieldsToSelect[i];
                    if (firstField == null && field.isNumeric()) firstField = field;
                    var idBase = "cbx_" + collectionIdx + "_" + i;
                    var cbxId = this.getDomId(idBase);
                    var cbx = $("#" + cbxId);
                    if (cbx.length>0) {
                        cbxExists = true;
                    } else {
                        continue;
                    }
                    if (cbx.is(':checked')) {
                        this.selectedCbx.push(field.getId());
                        df.push(field);
                    }
                }
            }

            if (df.length == 0 && !cbxExists) {
                if (this.lastSelectedFields && this.lastSelectedFields.length > 0) {
                    if (this.debugSelected)
                        console.log("\tlastSelectedFields:" + this.lastSelectedFields);
                    return this.lastSelectedFields;
                }
            }
            if (df.length == 0) {
                df = this.getDefaultSelectedFields(fieldsToSelect, dfltList);
                if (this.debugSelected)
                    console.log("\tusing default selected:" + df);
            }
            return df;
        },
        getDefaultSelectedFields: function(fields, dfltList) {
	    let debug = displayDebug.getDefaultSelectedFields;
	    if(debug)
		console.log("getDefaultSelectedFields");
            if (this.defaultSelectedToAll()) {
		let allFields = this.getFields();
		if(allFields) {
                    var tmp = [];
                    for (i = 0; i < allFields.length; i++) {
			var field = allFields[i];
			if (!field.isFieldGeo()) {
                            tmp.push(field);
			}
                    }
		}
		if(debug)
		    console.log("\treturning allFields:" + tmp);
                return tmp;
            }
            if (dfltList != null) {
		if(debug)
		    console.log("\treturning dfltList:" + dfltList);
                return dfltList;
            }
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (field.isNumeric() && !field.isFieldGeo()) return [field];
            }
            return [];
	},
	sortRecords: function(records, sortFields) {
	    if(!sortFields) {
		let f = this.getProperty("sortFields", "", true);
		if(f=="${fields}") f = this.getProperty("fields", "", true);
		sortFields = this.getFieldsByIds(null, f);
	    }
	    if(sortFields.length>0) {
		records = Utils.cloneList(records);
		var sortAscending = this.getProperty("sortAscending",true);
		let cnt = 0;
		records.sort((a,b)=>{
		    var row1 = this.getDataValues(a);
		    var row2 = this.getDataValues(b);
		    var result = 0;
		    for(var i=0;i<sortFields.length;i++) {
			var sortField = sortFields[i];
			var v1 = row1[sortField.getIndex()];
			var v2 = row2[sortField.getIndex()];
			if(sortField.isNumeric() || sortField.isFieldDate()) {
			    if(v1<v2) result = sortAscending?-1:1;
			    else if(v1>v2) result = sortAscending?1:-1;
			    else result = 0;
			} else {
			    result = String(v1).localeCompare(String(v2));
			    if(!sortAscending) result=-result;
			}
			if(result!=0) break;
		    }
		    return result;
		});
	    }


	    if(this.getProperty("sortHighlight")) {
		records = Utils.cloneList(records);
		records.sort((a,b)=>{
		    let h1 = a.isHighlight(this);
		    let h2 = b.isHighlight(this);
		    if(h1 && !h2)
			return -1;		    
		    if(!h1 && h2)
			return 1;		    
		    return 0;
		});
	    }

	    if(this.getProperty("reverse",false)) {
		records = Utils.cloneList(records);
		let tmp = [];
		for(let i=records.length-1;i>=0;i--)
		    tmp.push(records[i]);
		records = tmp;
	    }

	    return records;
	},
        getFieldById: function(fields, id) {
	    //Support one arg
	    if(fields!=null && id==null) {
		if(typeof fields!="string") return null;
		id = fields;
		fields=null;
	    }
            if (!id) return null;
	    id = String(id).trim();
	    if (!fields) {
                let pointData = this.getData();
                if (pointData == null) return null;
                fields = pointData.getRecordFields();
            }
	    let aliases= {};
	    let tmp = this.getProperty("fieldAliases");
	    if(tmp) {
		tmp.split(",").forEach(tok=>{
		    [name,alias] =   tok.split(":");
		    aliases[alias] = name;
		});
	    }
	    let theField = null;
//	    console.log("Looking for:" + id);
	    id.split("|").every(fieldId=>{
		let alias = aliases[fieldId];
		for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
//		    console.log("\tField:" + field.getId());
                    if (field.getId() == fieldId || fieldId == ("#" + (i+1)) || field.getId()==alias) {
			theField =  field;
//			console.log("\tgot it:" + theField);
			return false;
                    }
		}
		return true;
	    });
            return theField;
        },

        getFieldsByIds: function(fields, ids) {
            var result = [];
            if (!ids) {
		return result;
	    }
            if ((typeof ids) == "string")
                ids = ids.split(",");
            if (!fields) {
                var pointData = this.getData();
                if (pointData == null) {
		    return null;
		}
                fields = pointData.getRecordFields();
            }
            for (var i = 0; i < ids.length; i++) {
                var f = this.getFieldById(fields, ids[i]);
                if (f) result.push(f);
            }
            return result;
        },

        getFieldByType: function(fields, type) {
            fields = this.getFieldsByType(fields, type);
            if (fields.length == 0) return null;
            return fields[0];
        },
        getFieldsByType: function(fields, type) {
            if (!fields) {
                var pointData = this.getData();
                if (pointData == null) return null;
                fields = pointData.getRecordFields();
            }
            var list = [];
            var numeric = (type == "numeric");
            var isString = (type == "string");
            for (a in fields) {
                var field = fields[a];
		if(field.isRecordDate()) continue;
                if (type == null) return field;
                if (numeric) {
                    if (field.isFieldNumeric()) {
                        list.push(field);
                    }
                } else if(isString) {
                    if (field.isFieldString()) {
                        list.push(field);
                    }
                    
                } else if (field.getType() == type) {
                    list.push(field);
                }
            }
            return list;
        },
	getDateValues: function(records) {
	    var dates = [];
	    records.forEach(r=>{
		dates.push(r.getDate());
	    });
	    return dates;
	},
        getColumnValues: function(records, field) {
            var values = [];
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var record = records[rowIdx];
                var row = record.getData();
                var value = row[field.getIndex()];
                values.push(value);
                if (Utils.isNumber(value) && !isNaN(value)) {
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
            return {
                values: values,
                min: min,
                max: max
            };
        },
        requiresGrouping:  function() {
            return false;
        },
	makeTree: function(records) {
	    if(records==null)  {
		let pointData = this.getData();
                if (pointData == null) return null;
                records = pointData.getRecords();
            }
	    let treeTemplate = this.getProperty("treeTemplate");
	    let treeTooltip = this.getProperty("treeTooltip");
	    let roots = [];
	    let idToNode = {};
	    let nodes=[];
	    let idToRoot = {};
	    var labelField = this.getFieldById(null, this.getProperty("labelField"));
	    var nodeFields = this.getFieldsByIds(null, this.getProperty("nodeFields"));
	    let treeRootLabel = this.getProperty("treeRoot");
	    let treeRoot = null;
	    if(treeRootLabel) {
		treeRoot = {id:treeRootLabel,label:treeRootLabel,children:[],parent:null};
		roots.push(treeRoot);
	    }
	    if(nodeFields.length>0) {
		let cnt = 0;
		let valueToNode = {};
		let parentId = "";
		records.forEach(r=>{
		    var label= labelField==null?id:r.getValue(labelField.getIndex());		
		    let parentId = null;
		    let parentNode= null;
		    //		    console.log("record:" + label);

		    nodeFields.forEach(nodeField=>{
			let id = r.getValue(nodeField.getIndex());
			let nodeId = parentId?parentId+"-"+id:id;
			let tmpNode = idToNode[nodeId];
			if(!tmpNode) {
			    tmpNode = {id:nodeId,label:id,children:[],parent:parentNode};
			    idToNode[nodeId] = tmpNode;
			    if(!parentNode) {
				if(treeRoot) {
				    tmpNode.parent = treeRoot;
				    treeRoot.children.push(tmpNode);
				} else {
				    roots.push(tmpNode);
				}
			    }
			    if(parentNode) {
				parentNode.children.push(tmpNode);
			    }
			}
			parentId = nodeId;
			parentNode = tmpNode;
		    });
		    var id= "leaf" + (cnt++);
		    var node = {id:id,label:label,children:[],record:r, parent:parentNode};
		    parentNode.children.push(node);
		    idToNode[id] = node;
		    nodes.push(node);
		});
		return roots;
	    }

	    //{label:..., id:...., record:...,	    children:[]}
            let parentField = this.getFieldById(null, this.getProperty("parentField"));
	    let idField = this.getFieldById(null, this.getProperty("idField"));
	    if(!parentField) {
		throw new Error("No parent field specified");
	    }
	    if(!idField) {
                throw new Error("No id field specified");
	    }
	    records.forEach(r=>{
		var parent = r.getValue(parentField.getIndex());
		var id = r.getValue(idField.getIndex());
		var label= labelField==null?id:r.getValue(labelField.getIndex());		
		var node = {id:id,label:label,children:[],record:r,parentId:parent, parent:null};
		if(treeTemplate) {
		    node.display = this.getRecordHtml(r, null, treeTemplate);
		}
		if(treeTooltip) {
		    node.tooltip = this.getRecordHtml(r, null, treeTooltip);
		}
		idToNode[id] = node;
		nodes.push(node);
		if(parent=="") {
		    //is a root
		    idToRoot[id]=node;
		    if(treeRoot) {
			node.parent = treeRoot;
			node.parentId = treeRoot.id;
			treeRoot.children.push(node);
		    } else {
			roots.push(node);
		    }
		}
	    });
	    nodes.forEach(node=>{
		let parentNode = idToNode[node.parentId];
		if(!parentNode) {
		    if(!idToRoot[node.id]) {
			throw new Error("No parent :" + node.parentId +" for node:" + node.label);
		    }
		    return;
		}
		node.parent= parentNode;
		parentNode.children.push(node);
	    });

	    return roots;
	},
	getSegments: function() {
	    var segments = this.getProperty("timeSegments");
	    if(!segments) return null;
	    var result = [];
	    var segmentList = segments.split(",");
	    segmentList.forEach((tok,segmentIdx)=>{
		var toks = tok.split(";");
		var name = toks[0];
		var start = Utils.parseDate(toks[1],false);
		var end = Utils.parseDate(toks[2],false);
		result.push({name: name, start:start,end:end});
	    });
	    return  result;
	},
	convertPointData: function(pointData) {
	    let originalPointData = pointData;
	    let segments = this.getSegments();
	    if(segments) {
                let dataList = pointData.getRecords();
		let newData  =[];
		let header = [];
		newData.push(header);
		var rowIdx = 0; 
		//timeSegments="Obama;2008-02-01;2016-01-31,Trump;2016-02-01;2020-01-31"
		segments.forEach((segment,segmentIdx)=>{
		    var name = segment.name;
		    header.push(name);
		    var start = segment.start;
		    var end = segment.end;
		    var cnt = 1;
	    	    for (; rowIdx <dataList.length; rowIdx++) {
			var record = dataList[rowIdx];
			if(record.getTime()<start.getTime()) {
			    continue;
			}
			if(record.getTime()>end.getTime()) {
			    break;
			}
			var value = record.getValue(1);
			let row=null;
			if(cnt>=newData.length) {
			    row = [];
			    for(let sidx=0;sidx<segments.length;sidx++) row.push(NaN);
			    newData.push(row);
			} else {
			    row = newData[cnt];
			}
			row[segmentIdx] = value;
			cnt++;
		    }
		});
		pointData = convertToPointData(newData);
		pointData.entryId = originalPointData.entryId;
	    }

	    try {
		pointData = new CsvUtil().process(this, pointData, this.getProperty("convertData"));
	    } catch(exc) {
		this.setErrorMessage(exc);
		//		console.log(exc.trace);
		return null;
	    }


	    return pointData;
	},
	requiresGeoLocation: function() {
	    return false;
	},
	checkDataFilters: function(dataFilters, record) {
	    if(!dataFilters) {return true;}
	    for(let i=0;i<dataFilters.length;i++) {
		if(!dataFilters[i].isRecordOk(record)) return false;
	    }
	    return true;
	},
	getDataFilters: function(v) {
	    return DataUtils.getDataFilters(this, v || this.getProperty("dataFilters"));
	},
	getFilterHighlight: function() {
	    return this.getProperty("filterHighlight",false);
	},
	getFilterTextMatchers: function() {
	    let highlight  = [];
	    if(this.filters) {
		for(var filterIdx=0;filterIdx<this.filters.length;filterIdx++) {
		    let filter = this.filters[filterIdx];
		    if(!filter.field)continue;
		    var widget =$("#" + this.getDomId("filterby_" + filter.field.getId())); 
		    if(!widget.val || widget.val()==null) continue;
		    var value = widget.val()||"";
		    if(value.trim()=="") continue;
		    highlight.push(new TextMatcher(value));
		}
	    }
	    return highlight;
	},


	filterData: function(records, fields, args) {
	    if(this.recordListOverride) return this.recordListOverride;
	    if(!args) args = {};
	    let opts = {
		doGroup:false,
		skipFirst:false,
		applyDateRange: true
	    }
	    $.extend(opts,args);
	    let debug = displayDebug.filterData;
	    if(this.getAnimationEnabled()) {
		if(this.getProperty("animationFilter", true)) {
		    this.setDateRange(this.getAnimation().begin, this.getAnimation().end);
		}
	    }


	    let highlight =  this.getFilterHighlight();
	    let startDate = this.getProperty("startDate");
	    let endDate = this.getProperty("endDate");
	    if(startDate) {
		this.startDateObject = Utils.createDate(startDate,+this.getProperty("timeZoneOffset",0));
		if(debug)
		    console.log(this.type +" start date:" + startDate + " dttm:" + this.startDateObject.toUTCString());
	    } 
	    if(endDate) {
		this.endDateObject = Utils.createDate(endDate,+this.getProperty("timeZoneOffset",0));
		if(debug)
		    console.log(this.type +"end date:" +this.endDateObject.toUTCString());
	    } 

	    let filterDate = this.getProperty("filterDate");
	    if(filterDate) {
		let date = $("#"+ this.getFilterId(ID_FILTER_DATE)).val();
		if(date) {
		    if(date=="all") {
			this.setDateRange(null,null);
		    } else {
			date = new Date(date);
			if(filterDate == "year") {
			    this.setDateRange(new Date(date.getFullYear()+"-01-01"),
					      new Date(date.getFullYear()+"-12-31"));
			} else if(filterDate == "day") {
			    let f = date.getUTCFullYear() + "-" + (date.getUTCMonth() + 1) +"-" + date.getUTCDate();
			    let dttm = new Date(f);
			    this.setDateRange(dttm,dttm, true);
			} else {
			    //TODO month and day
			}
		    }
		}
	    }

            let pointData = this.getData();
            if (!records) {
                if (pointData == null) return null;
                records = pointData.getRecords();
            }
            if (!fields) {
                fields = pointData.getRecordFields();
            }
            if(opts.doGroup || this.requiresGrouping()) {
                records = pointData.extractGroup(this.dataGroup, records);
            }

	    if(debug)   console.log("R-1:" + records.length);
	    if(this.getProperty("filterLatest")) {
		let fields = this.getFieldsByIds(null,this.getProperty("filterLatest"));
		let max = {};
		let keyToRecord = {};
		let tmp = [];
		let keys = [];
		records.forEach(record=>{
		    if(!record.getTime()) return;
		    let key = "";
		    fields.forEach(f=>{
			key+="_" + record.getValue(f.getIndex());
		    });
		    let maxRecord = keyToRecord[key];
		    if(!maxRecord) {
			keyToRecord[key] = record;
			keys.push(key);
		    } else {
			if(record.getDate().getTime()>maxRecord.getDate().getTime()) keyToRecord[key] = record;
		    }
		});


		keys.forEach(key=>{
		    tmp.push(keyToRecord[key]);
		});
		records  =tmp;
	    }


	    records.forEach(r=>{
		r.clearHighlight(this);
	    });

	    if(debug)   console.log("checking dates");
	    records = records.filter((record,idx)=>{
                let date = record.getDate();
		if(!date) return true;
		return this.dateInRange(date,idx<5 && debug);
	    });
	    if(debug)   console.log("filter Fields:" + this.filters.length +" #records:" + records.length);

	    if(this.filters.length) {
		let newData = [];
		let logic = this.getProperty("filterLogic","and");
		this.filters.forEach(f=>f.prepareToFilter());
		records.forEach((record,rowIdx)=>{
		    let allOk = true;
		    let anyOk = false;		    
		    for(let i=0;i<this.filters.length;i++) {
			let filter= this.filters[i];
			if(!filter.isEnabled()) continue;
			let filterOk = filter.isRecordOk(record);
			if(!filterOk) allOk = false;
			else anyOk = true;
		    }
		    let ok = logic=="and"?allOk:anyOk;
		    if(opts.skipFirst && rowIdx==0) {
			ok = true;
		    }
		    if(highlight) {
			newData.push(record);
			record.setHighlight(this, ok);
		    } else {
			record.clearHighlight(this);
			if(ok) {
			    newData.push(record);
			}
		    }
		});

		records = newData;
	    }


	    if(debug)   console.log("R-2:" + records.length);

            var stride = parseInt(this.getProperty("stride", -1));
            if (stride < 0) {
		var maxSize = parseInt(this.getProperty("maxDisplayedPoints", -1));		
		if(maxSize>0 && records.length>0) {
		    stride = 1;
		    while(records.length/stride>maxSize) {
			stride++;
		    }
		}
	    }

            if (stride > 0) {
                var list = [];
                var cnt = 0;
                for (var i = 0; i < records.length; i += (stride + 1)) {
                    list.push(records[i]);
                }
                records = list;
		//		console.log("stride: " + stride +"  size:" + list.length);
		if(debug)   console.log("R-3:" + records.length);
            }


	    if(this.getProperty("binDate")) {
		let what = this.getProperty("binDate");
		let binType = this.getProperty("binType","total");
		let binCount = binType=="count";
		let binned = [];
		let record = records[0];
		let map ={};
		let counts ={};
		this.binRecordToRecords = {};
		let keyToRecord={};
		for (var i = 0; i < records.length; i++) {
		    let record = records[i];
		    var tuple = this.getDataValues(record);
		    var key;
		    var baseDate=null
		    if(what=="month") {
			key = record.getDate().getUTCFullYear() + "-" + (record.getDate().getUTCMonth() + 1);
		    } else if(what=="day") {
			key = record.getDate().getUTCFullYear() + "-" + (record.getDate().getUTCMonth() + 1) +"-" + record.getDate().getUTCDate();
		    } else if(what=="week") {
			var week = +Utils.formatDateWeek(record.getDate());
			key = record.getDate().getUTCFullYear()+"-"+week;
			var d =  (1 + (week - 1) * 7);
			baseDate = new Date(record.getDate().getUTCFullYear(), 0, d);			
		    } else {
			key = record.getDate().getUTCFullYear()+"";
		    }
		    if(!Utils.isDefined(map[key])) {
			counts[key]=1;
			var date = baseDate;
			if(!baseDate) {
			    date = Utils.parseDate(key);
			}
			var data = Utils.cloneList(record.getData());
			if(binCount) {
			    for(k=0;k<data.length;k++) data[k]=1;
			}
			var newRecord = new  PointRecord(fields, record.getLatitude(),record.getLongitude(),
							 record.getElevation(),date,data);

			keyToRecord[key] = newRecord;
			this.binRecordToRecords[newRecord.getId()] = {
			    records:[record],
			}

			map[key] = data;
			binned.push(newRecord);
		    } else {
			let newRecord = keyToRecord[key];
			this.binRecordToRecords[newRecord.getId()].records.push(record);
			counts[key]++;
			var tuple1 = map[key];
			if(binCount) {
			    for(k=0;k<tuple1.length;k++) tuple1[k]++;
			    continue;
			} 
			var tuple2 = record.getData();
			for(var j=0;j<tuple2.length;j++) {
			    var v = tuple2[j];
			    if((typeof v) !="number") continue;
			    if(isNaN(v)) continue;
			    if(isNaN(tuple1[j])) tuple1[j] = v;
			    else tuple1[j] +=v;
			}
		    }
		}
		if(binType == "average") {
		    for(key in counts) {
			var tuple = map[key];
			for(var j=0;j<tuple.length;j++) {
			    var v = tuple[j];
			    if((typeof v) !="number") continue;
			    if(isNaN(v)) continue;
			    tuple[j] = v/counts[key];
			}
		    }
		}

		records = binned;
	    }

	    if(this.requiresGeoLocation()) {
		records = records.filter(r=>{return r.hasLocation();});
	    }
	    let dataFilters = this.getDataFilters();
	    if(dataFilters.length) {
		records = records.filter((r,idx)=> {
		    if(!this.checkDataFilters(dataFilters, r)) return false;
		    return true;
		});
	    }
	    //	    var t2=  new Date();
	    //	    Utils.displayTimes("filterData",[t1,t2]);
	    records = this.sortRecords(records);

	    if(this.getProperty("uniqueField")) {
		let ufield =  this.getFieldById(null, this.getProperty("uniqueField"));
		let umap = {};
		let ulist = [];
		for(var i=records.length-1;i>=0;i--) {
		    var record = records[i];
		    var v = record.getValue(ufield.getIndex());
		    if(!Utils.isDefined(umap[v])) {
			umap[v] = true;
			ulist.push(record);
		    }
		}
		records  = ulist;
	    }

	    this.recordToIndex = {};
	    this.indexToRecord = {};
	    for(var i=0;i<records.length;i++) {
		var record = records[i];
		this.recordToIndex[record.getId()] = i;
		this.indexToRecord[i] = record;
	    }



	    let convertPost = this.getProperty("convertDataPost");
	    if(convertPost) {
		let newPointData = new  PointData("pointdata", pointData.getRecordFields(), records,null,{parent:pointData});
		this.pointData =  new CsvUtil().process(this, newPointData, convertPost);
		records = this.pointData.getRecords();
//		console.log("post:" + this.pointData.getRecordFields());
	    }
	    if(debug)
		console.log("filtered:" + records.length);
	    this.jq(ID_FILTER_COUNT).html("Count: " + records.length);
	    this.filteredRecords = records;
            return records;
        },
	getBinnedRecords: function(record) {
	    if(this.binRecordToRecords)
		return this.binRecordToRecords[record.getId()].records;
	    return record.parentRecords;
	},
        canDoGroupBy: function() {
            return false;
        },
        canDoMultiFields: function() {
            return true;
        },
        useChartableFields: function() {
            return false;
        },
        getFieldsToSelect: function(pointData) {
            if (this.useChartableFields())
                return pointData.getChartableFields(this);
            return pointData.getRecordFields();
        },
        getGet: function() {
            return "getRamaddaDisplay('" + this.getId() + "')";
        },
	assembleWikiText: function(type) {
	    var wiki =  "";
	    if(window.globalDisplayProperties) {
		for(key in window.globalDisplayProperties) {
		    wiki += '{{displayProperty name="' + key +'" value="' + window.globalDisplayProperties[key]+'"}}\n';

		}
	    }
            wiki += this.getWikiText();
            for (var i = 0; i < this.displays.length; i++) {
                var display = this.displays[i];
                if (display.getIsLayoutFixed()) {
                    continue;
                }
                wiki += display.getWikiText();
            }
	    return wiki;
	},
        showWikiText: function(type) {
	    var wiki =  this.assembleWikiText();
	    HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
	    wiki = wiki.replace(/</g,"&lt;").replace(/>/g,"&gt;");
	    wiki = HU.pre([STYLE,HU.css("max-width","500px","max-height","400px","overflow-x","auto","overflow-y","auto")], wiki);
	    this.showDialog(wiki);
	},
        copyWikiText: function(type) {
	    Utils.copyText(this.assembleWikiText());
	    alert("Wiki text has been copied to the clipboard");
	},
        publish: function(type) {
            if (type == null) type = "wikipage";
            var args = [];
            var name = prompt("Name", "");
            if (name == null) return;
            args.push("name");
            args.push(name);

            args.push("type");
            args.push(type);


            var desc = "";
            //                var desc = prompt("Description", "");
            //                if(desc == null) return;

            var wiki = "";
            if (type == "wikipage") {
                wiki += "+section label=\"{{name}}\"\n${extra}\n";
            } else if (type == "blogentry") {
                wiki = "<wiki>\n";
            }
            wiki += desc;
	    wiki += this.assembleWikiText();
            if (type == "wikipage") {
                wiki += "-section\n\n";
            } else if (type == "blogentry") {}
            var from = "";
            var entries = this.getChildEntries();
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                from += entry.getId() + ",";
            }

            if (entries.length > 0) {
                args.push("entries");
                args.push(from);
            }

            if (type == "media_photoalbum") {
                wiki = "";
            }

            args.push("description_encoded");
	    console.log(wiki);
            args.push(window.btoa(wiki));
            var url = HU.getUrl(ramaddaBaseUrl + "/entry/publish", args);
            window.open(url, '_blank');
        },
        getChildEntries: function(includeFixed) {
            var seen = {};
            var allEntries = [];
            for (var i = 0; i < this.displays.length; i++) {
                var display = this.displays[i];
                if (!includeFixed && display.getIsLayoutFixed()) {
                    continue;
                }
                if (display.getEntries) {
                    var entries = display.getEntries();
                    if (entries) {
                        for (var entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                            if (seen[entries[entryIdx].getId()] != null) {
                                continue;
                            }
                            seen[entries[entryIdx].getId()] = true;
                            allEntries.push(entries[entryIdx]);
                        }
                    }
                }
            }
            return allEntries;
        },
        copyDisplayedEntries: function() {
            var allEntries = [];
            for (var i = 0; i < this.displays.length; i++) {
                var display = this.displays[i];
                if (display.getIsLayoutFixed()) {
                    continue;
                }
                if (display.getEntries) {
                    var entries = display.getEntries();
                    if (entries) {
                        for (var entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                            allEntries.push(entries[entryIdx]);
                        }
                    }
                }
            }
            return this.copyEntries(allEntries);
        },
        defineWikiAttributes: function(list) {
            for (var i = 0; i < list.length; i++) {
                if (this.wikiAttrs.indexOf(list[i]) < 0) {
                    this.wikiAttrs.push(list[i]);
                }
            }
        },
        getWikiAttributes: function(attrs) {
            for (var i = 0; i < this.wikiAttrs.length; i++) {
                var v = this[this.wikiAttrs[i]];
                if (Utils.isDefined(v)) {
                    attrs.push(this.wikiAttrs[i]);
                    attrs.push(v);
                }
            }
        },
        getWikiText: function() {
            var attrs = [
			 "layoutHere", "false",
			 "type", this.type,
			 "column", this.getColumn(),
			 "row", this.getRow()
			];
	    if(this.getProperty("entryId")) {
		attrs.push("entry");
		attrs.push(this.getProperty("entryId"));
	    }
            this.getWikiAttributes(attrs);
            var entryId = null;
            if (this.getEntries) {
                var entries = this.getEntries();
                if (entries && entries.length > 0) {
                    entryId = entries[0].getId();
                }
            }
            if (!entryId) {
                entryId = this.entryId;
            }
            if (entryId) {
                attrs.push("entry");
                attrs.push(entryId);
            }
            var wiki = "{{display " + HU.attrs(attrs) + "}}\n\n"

            return wiki;
        },
        copyEntries: function(entries) {
            var allEntries = [];
            var seen = {};
            for (var entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                var entry = entries[entryIdx];
                if (seen[entry.getId()] != null) continue;
                seen[entry.getId()] = entry;
                allEntries.push(entry);
            }
            var from = "";
            for (var i = 0; i < allEntries.length; i++) {
                var entry = allEntries[i];
                from += entry.getId() + ",";
            }


            var url = ramaddaBaseUrl + "/entry/copy?action.force=copy&from=" + from;
            window.open(url, '_blank');

        },
        entryHtmlHasBeenDisplayed: async function(entry) {
            if (entry.getIsGroup() /* && !entry.isRemote*/ ) {
                var theDisplay = this;
                var callback = function(entries) {
                    var html = HU.open(TAG_OL, [ATTR_CLASS, "display-entrylist-list", ATTR_ID, theDisplay.getDomId(ID_LIST)]);
                    html += theDisplay.getEntriesTree(entries);
                    html += HU.close(TAG_OL);
                    theDisplay.jq(ID_GROUP_CONTENTS + entry.getIdForDom()).html(html);
                    theDisplay.addEntrySelect();
                };
                await entry.getChildrenEntries(callback);
            }
        },
        getEntryHtml: function(entry, props) {
            var dfltProps = {
                showHeader: true,
                headerRight: false,
                showDetails: this.getShowDetails()
            };
            $.extend(dfltProps, props);

            props = dfltProps;
            var menu = this.getEntryMenuButton(entry);
            var html = "";
            if (props.showHeader) {
                var left = menu + SPACE + entry.getLink(null, true, ["target","_entries"]);
                if (props.headerRight) html += HU.leftRight(left, props.headerRight);
                else html += left;
                //                    html += "<hr>";
            }
            let divid = HU.getUniqueId("entry_");
            html += HU.div([ID, divid], "");
            let snippet = entry.getSnippet();
	    if(snippet) html+=snippet;
	    /*
            let desc = entry.getDescription();
            if (desc)
                desc = desc.replace(/\n/g, "<br>");
            else
                desc = "";
		html += desc;
	    */


            var metadata = entry.getMetadata();
            if (entry.isImage()) {
                var img = HU.tag(TAG_IMG, ["src", entry.getResourceUrl(), /*ATTR_WIDTH,"100%",*/
					   ATTR_CLASS, "display-entry-image"
					  ]);

                html += HU.href(entry.getResourceUrl(), img,["download",null]) + "<br>";
            } else {
                for (var i = 0; i < metadata.length; i++) {
                    if (metadata[i].type == "content.thumbnail") {
                        var image = metadata[i].value.attr1;

                        var url;
                        if (image.indexOf("http") == 0) {
                            url = image;
                        } else {
                            url = ramaddaBaseUrl + "/metadata/view/" + image + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + metadata[i].id + "&thumbnail=false";
                        }
                        html += HU.image(url, [ATTR_CLASS, "display-entry-thumbnail"]);
                    }
                }
            }
            if (entry.getIsGroup() /* && !entry.isRemote*/ ) {
                html += HU.div([ATTR_ID, this.getDomId(ID_GROUP_CONTENTS + entry.getIdForDom())], "" /*this.getWaitImage()*/ );
            }


            html += HU.formTable();

            if (props.showDetails) {
                if (entry.url) {
                    html += HU.formEntry("URL:", HU.href(entry.url, entry.url));
                }

                if (entry.remoteUrl) {
                    html += HU.formEntry("URL:", HU.href(entry.remoteUrl, entry.remoteUrl));
                }
                if (entry.remoteRepository) {
                    html += HU.formEntry("From:", HU.href(entry.remoteRepository.url, entry.remoteRepository.name));
                }
            }

            var columns = entry.getAttributes();

            if (entry.getFilesize() > 0) {
                html += HU.formEntry("File:", entry.getFilename() + " " +
				     HU.href(entry.getResourceUrl(), HU.image(ramaddaBaseUrl + "/icons/download.png"),["download",null]) + " " +
				     entry.getFormattedFilesize());
            }
            for (var colIdx = 0; colIdx < columns.length; colIdx++) {
                var column = columns[colIdx];
                var columnValue = column.value;
                if (column.getCanShow && !column.getCanShow()) {
                    continue;
                }
                if (Utils.isFalse(column.canshow)) {
                    continue;
                }

                if (column.isUrl && column.isUrl()) {
                    var tmp = "";
                    var toks = columnValue.split("\n");
                    for (var i = 0; i < toks.length; i++) {
                        var url = toks[i].trim();
                        if (url.length == 0) continue;
                        tmp += HU.href(url, url);
                        tmp += "<br>";
                    }
                    columnValue = tmp;
                }
                html += HU.formEntry(column.label + ":", columnValue);
            }

            html += HU.close(TAG_TABLE);
            return html;
        },

        getEntriesTree: function(entries, props) {
            if (!props) props = {};
            let columns = this.getProperty("entryColumns", null);
            if (columns != null) {
                let columnNames = this.getProperty("columnNames", null);
                if (columnNames != null) {
                    columnNames = columnNames.split(",");
                }
                columns = columns.split(",");
                let ids = [];
                let names = [];
                for (let i = 0; i < columns.length; i++) {
                    let toks = columns[i].split(":");
                    let id = null,
                        name = null;
                    if (toks.length > 1) {
                        if (toks[0] == "property") {
                            name = "property";
                            id = columns[i];
                        } else {
                            id = toks[0];
                            name = toks[1];
                        }
                    } else {
                        id = columns[i];
                        name = id;
                    }
                    ids.push(id);
                    names.push(name);
                }
                columns = ids;
                if (columnNames == null) {
                    columnNames = names;
                }
                return this.getEntriesTable(entries, columns, columnNames);
            }

            let suffix = props.suffix;
            let domIdSuffix = "";
            if (!suffix) {
                suffix = "null";
            } else {
                domIdSuffix = suffix;
                suffix = "'" + suffix + "'";
            }

            let handler = getHandler(props.handlerId);
            let showIndex = props.showIndex;
            let html = "";
            let rowClass = "entryrow_" + this.getId();
            let even = true;
            if (this.entriesMap == null)
                this.entriesMap = {};
	    let doWorkbench = this.getProperty("doWorkbench");
            for (let i = 0; i < entries.length; i++) {
                even = !even;
                let entry = entries[i];
                this.entriesMap[entry.getId()] = entry;
                let toolbar = this.makeEntryToolbar(entry, handler, props.handlerId);
                let entryMenuButton = doWorkbench?this.getEntryMenuButton(entry):"";

                let entryName = entry.getDisplayName();
                if (entryName.length > 100) {
                    entryName = entryName.substring(0, 99) + "...";
                }
                let icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
                let link = HU.tag(TAG_A, ["target","_entries",ATTR_HREF, entry.getEntryUrl()], icon + " " + entryName);
                entryName = "";
                let entryIdForDom = entry.getIdForDom() + domIdSuffix;
                let entryId = entry.getId();
                let arrow = HU.image(icon_tree_closed, [ATTR_BORDER, "0",
							"tree-open", "false",
							ATTR_ID,
							this.getDomId(ID_TREE_LINK + entryIdForDom)
						       ]);
                let toggleCall = this.getGet() + ".toggleEntryDetails(event, '" + entryId + "'," + suffix + ",'" + props.handlerId + "');";
                let toggleCall2 = this.getGet() + ".entryHeaderClick(event, '" + entryId + "'," + suffix + "); ";
                let open = HU.onClick(toggleCall, arrow);
                let extra = "";

                if (showIndex) {
                    extra = "#" + (i + 1) + " ";
                }
                if (handler && handler.getEntryPrefix) {
                    extra += handler.getEntryPrefix(props.handlerId, entry);
                }
                let left = HU.div([ATTR_CLASS, "display-entrylist-name"], entryMenuButton + " " + open + " " + extra + link + " " + entryName);

                let details = HU.div([ATTR_ID, this.getDomId(ID_DETAILS + entryIdForDom), ATTR_CLASS, "display-entrylist-details"], 
				     HU.div([ATTR_CLASS, "display-entrylist-details-ancestors", ATTR_ID, this.getDomId(ID_DETAILS_ANCESTORS + entryIdForDom)], "") +
				     HU.div([ATTR_CLASS, "display-entrylist-details-tags", ATTR_ID, this.getDomId(ID_DETAILS_TAGS + entryIdForDom)], "") +
				     HU.div([ATTR_CLASS, "display-entrylist-details-inner", ATTR_ID, this.getDomId(ID_DETAILS_INNER + entryIdForDom)], ""));

                //                    console.log("details:" + details);
                let line;
                if (doWorkbench && this.getProperty("showToolbar", true)) {
                    line = HU.leftCenterRight(left, "", toolbar, "80%", "1%", "19%");
                } else {
                    line = left;
                }
                //                    line = HU.leftRight(left,toolbar,"60%","30%");


                let mainLine = HU.div(["onclick", toggleCall2, ATTR_ID, this.getDomId(ID_DETAILS_MAIN + entryIdForDom), ATTR_CLASS, "display-entrylist-entry-main" + " " + "entry-main-display-entrylist-" + (even ? "even" : "odd"), ATTR_ENTRYID, entryId], line);
                line = HU.div([CLASS, (even ? "ramadda-row-even" : "ramadda-row-odd"), ATTR_ID, this.getDomId("entryinner_" + entryIdForDom)], mainLine + details);
                html += HU.div([ATTR_ID,
				this.getDomId("entry_" + entryIdForDom),
				ATTR_ENTRYID, entryId, ATTR_CLASS, "display-entrylist-entry" + rowClass
			       ], line);
                html += "\n";
            }
            return html;
        },
        addEntrySelect: function() {
            var theDisplay = this;
            var entryRows = $("#" + this.getDomId(ID_DISPLAY_CONTENTS) + "  ." + this.getClass("entry-main"));

            entryRows.unbind();
            entryRows.mouseover(async function(event) {
                //TOOLBAR
                var entryId = $(this).attr(ATTR_ENTRYID);
                var entry;
                await theDisplay.getEntry(entryId, e => {
                    entry = e
                });
                if (!entry) {
                    console.log("no entry:" + entryId);
                    return;
                }
                theDisplay.propagateEvent("handleEventEntryMouseover", {
                    entry: entry
                });


                if (true) return;
                var domEntryId = Utils.cleanId(entryId);
                var toolbarId = theDisplay.getEntryToolbarId(domEntryId);

                var toolbar = $("#" + toolbarId);
                toolbar.show();
                var myalign = 'right top+1';
                var atalign = 'right top';
                var srcId = theDisplay.getDomId(ID_DETAILS_MAIN + domEntryId);
                toolbar.position({
                    of: $("#" + srcId),
                    my: myalign,
                    at: atalign,
                    collision: "none none"
                });

            });
            entryRows.mouseout(async function(event) {
                var entryId = $(this).attr(ATTR_ENTRYID);
                var entry;
                await theDisplay.getEntry(entryId, e => {
                    entry = e
                });
                if (!entry) return;
                theDisplay.propagateEvent("handleEventEntryMouseout", {
                    entry: entry
                });
                var domEntryId = Utils.cleanId(entryId);
                var toolbarId = theDisplay.getEntryToolbarId(entryId);
                var toolbar = $("#" + toolbarId);
                //TOOLBAR                        toolbar.hide();
            });

            if (this.madeList) {
                //                    this.jq(ID_LIST).selectable( "destroy" );
            }
            this.madeList = true;
            if (false) {
                this.jq(ID_LIST).selectable({
                    //                        delay: 0,
                    //                        filter: 'li',
                    cancel: 'a',
                    selected: async function(event, ui) {
                        var entryId = ui.selected.getAttribute(ATTR_ENTRYID);
                        theDisplay.toggleEntryDetails(event, entryId);
                        if (true) return;

                        theDisplay.hideEntryDetails(entryId);
                        var entry;
                        await this.getEntry(entryId, e => {
                            entry = e
                        });
                        if (entry == null) return;

                        var zoom = null;
                        if (event.shiftKey) {
                            zoom = {
                                zoomIn: true
                            };
                        }
                        theDisplay.selectedEntries.push(entry);
                        theDisplay.propagateEvent("handleEventEntrySelection", {
                            entry: entry,
                            selected: true,
                            zoom: zoom
                        });
                        theDisplay.lastSelectedEntry = entry;
                    },
                    unselected: async function(event, ui) {
                        if (true) return;
                        var entryId = ui.unselected.getAttribute(ATTR_ENTRYID);
                        var entry;
                        await this.getEntry(entryId, e => {
                            entry = e
                        });
                        var index = theDisplay.selectedEntries.indexOf(entry);
                        //                            console.log("remove:" +  index + " " + theDisplay.selectedEntries);
                        if (index > -1) {
                            theDisplay.selectedEntries.splice(index, 1);
                            theDisplay.propagateEvent("handleEventEntrySelection", {
                                entry: entry,
                                selected: false
                            });
                        }
                    },

                });
            }

        },
        getEntriesTable: function(entries, columns, columnNames) {
            if (this.entriesMap == null)
                this.entriesMap = {};
            var columnWidths = this.getProperty("columnWidths", null);
            if (columnWidths != null) {
                columnWidths = columnWidths.split(",");
            }
            var html = HU.open(TAG_TABLE, [ATTR_WIDTH, "100%", "cellpadding", "0", "cellspacing", "0"]);
            html += HU.open(TAG_TR, ["valign", "top"]);
            for (var i = 0; i < columnNames.length; i++) {
                html += HU.td([ATTR_ALIGN, "center", ATTR_CLASS, "display-entrytable-header"], columnNames[i]);
            }
            html += HU.close(TAG_TR);

            for (var i = 0; i < entries.length; i++) {
                html += HU.open(TAG_TR, ["valign", "top"]);
                var entry = entries[i];
                this.entriesMap[entry.getId()] = entry;
                for (var j = 0; j < columns.length; j++) {
                    var columnWidth = null;
                    if (columnWidths != null) {
                        columnWidth = columnWidths[j];
                    }
                    var column = columns[j];
                    var value = "";
                    if (column == "name") {
                        value = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], entry.getName());
                    } else if (column.match(".*property:.*")) {
                        var type = column.substring("property:".length);
                        var metadata = entry.getMetadata();
                        value = "";
                        for (var j = 0; j < metadata.length; j++) {
                            var m = metadata[j];
                            if (m.type == type) {
                                if (value != "") {
                                    value += "<br>";
                                }
                                value += m.value.attr1;
                            }
                        }
                    } else if (column == "description") {
                        value = entry.getDescription();
                    } else if (column == "date") {
                        value = entry.ymd;
                        if (value == null) {
                            value = entry.startDate;
                        }

                    } else {
                        value = entry.getAttributeValue(column);
                    }
                    var attrs = [ATTR_CLASS, "display-entrytable-cell"];
                    if (columnWidth != null) {
                        attrs.push(ATTR_WIDTH);
                        attrs.push(columnWidth);
                    }

                    html += HU.td(attrs, value);
                }
                html += HU.close(TAG_TR);
            }
            html += HU.close(TAG_TABLE);
            return html;
        },

        makeEntryToolbar: function(entry, handler, handlerId) {
            var get = this.getGet();
            var toolbarItems = [];
	    var props = "{showMenu:true,showTitle:true}";
            //                 toolbarItems.push(HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl(),"target","_"], 
            //                                                HU.image(ramaddaBaseUrl +"/icons/application-home.png",["border",0,ATTR_TITLE,"View Entry"])));
            if (entry.getType().getId() == "type_wms_layer") {
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".addMapLayer(" + HU.sqt(entry.getId()) + ");"],
					 HU.image(ramaddaBaseUrl + "/icons/map.png", ["border", 0, ATTR_TITLE, "Add Map Layer"])));

            }
            if (entry.getType().getId() == "geo_shapefile" || entry.getType().getId() == "geo_geojson") {
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".addMapLayer(" + HU.sqt(entry.getId()) + ");"],
					 HU.image(ramaddaBaseUrl + "/icons/map.png", ["border", 0, ATTR_TITLE, "Add Map Layer"])));

            }

            var jsonUrl = this.getPointUrl(entry);
            if (jsonUrl != null) {
                jsonUrl = jsonUrl.replace(/\'/g, "_");
                toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
						 HU.sqt("table") + "," + HU.sqt(jsonUrl) + "," + props+");"
						],
					 HU.getIconImage("fa-table", [ATTR_TITLE, "Create Tabular Display"])));

                var x;
                toolbarItems.push(x = HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
 						     HU.sqt("linechart") + "," + HU.sqt(jsonUrl) + "," + props +");"
						    ],
					     HU.getIconImage("fa-chart-line", [ATTR_TITLE, "Create Chart"])));
		//		console.log("X:" + x);
            }
            toolbarItems.push(HU.tag(TAG_A, ["onclick", get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," +
					     HU.sqt("entrydisplay") + "," + HU.sqt(jsonUrl) + "," + props +");"
					    ],
				     HU.getIconImage("fa-file", ["border", 0, ATTR_TITLE, "Show Entry"])));
            if (entry.getFilesize() > 0) {
                toolbarItems.push(HU.tag(TAG_A, [ATTR_HREF, entry.getResourceUrl(),"download",null],
					 HU.image(ramaddaBaseUrl + "/icons/download.png", ["border", 0, ATTR_TITLE, "Download (" + entry.getFormattedFilesize() + ")"])));

            }


            var entryMenuButton = this.getEntryMenuButton(entry);
            var tmp = [];



            if (handler && handler.addToToolbar) {
                handler.addToToolbar(handlerId, entry, toolbarItems);
            }

            for (var i = 0; i < toolbarItems.length; i++) {
                tmp.push(HU.div([ATTR_CLASS, "display-entry-toolbar-item"], toolbarItems[i]));
            }
            toolbarItems = tmp;
            return HU.div([ATTR_CLASS, "display-entry-toolbar", ATTR_ID,
			   this.getEntryToolbarId(entry.getIdForDom())
			  ],
			  HU.join(toolbarItems, ""));
        },
        getEntryToolbarId: function(entryId) {
            var id = entryId.replace(/:/g, "_");
            id = id.replace(/=/g, "_");
            return this.getDomId(ID_TOOLBAR + "_" + id);
        },

        hideEntryDetails: function(entryId) {
            //                var popupId = "#"+ this.getDomId(ID_DETAILS + entryId);
            //                $(popupId).hide();
            //                this.currentPopupEntry = null;
        },
        entryHeaderClick: function(event, entryId, suffix) {
            var target = event.target;
            //A hack to see if this was the div clicked on or a link in the div
            if (target.outerHTML) {
                if (target.outerHTML.indexOf("<div") != 0) {
                    return;
                }
            }
            this.toggleEntryDetails(event, entryId);
        },
        toggleEntryDetails: async function(event, entryId, suffix, handlerId, entry) {
	    if(!entry) {
		await this.getEntry(entryId, e => {
		    this.toggleEntryDetails(event, entryId, suffix, handlerId, e);
		});
		return;
	    }

            //                console.log("toggleEntryDetails:" + entry.getName() +" " + entry.getId());
            if (suffix == null) suffix = "";
            let link = this.jq(ID_TREE_LINK + entry.getIdForDom() + suffix);
            let id = ID_DETAILS + entry.getIdForDom() + suffix;
            let details = this.jq(id);
            if (event && event.shiftKey) {
                let id = Utils.cleanId(entryId);
                let line = this.jq(ID_DETAILS_MAIN + id);
                if (!this.selectedEntriesFromTree) {
                    this.selectedEntriesFromTree = {};
                }
                let selected = line.attr("ramadda-selected") == "true";
                if (selected) {
                    line.removeClass("display-entrylist-entry-main-selected");
                    line.attr("ramadda-selected", "false");
                    this.selectedEntriesFromTree[entry.getId()] = null;
                } else {
                    line.addClass("display-entrylist-entry-main-selected");
                    line.attr("ramadda-selected", "true");
                    this.selectedEntriesFromTree[entry.getId()] = entry;
                }
                this.propagateEvent("handleEventEntrySelection", {
                    "entry": entry,
                    "selected": !selected
                });
                return;
            }


            let open = link.attr("tree-open") == "true";
            if (open) {
                link.attr("src", icon_tree_closed);
            } else {
                link.attr("src", icon_tree_open);
            }
            link.attr("tree-open", open ? "false" : "true");

	    let handleContent = ()=>{
		if (open) {
                    details.hide();
		} else {
                    details.show();
		}
		if (event && event.stopPropagation) {
                    event.stopPropagation();
		}
	    }



            let hereBefore = details.attr("has-content") != null;
            details.attr("has-content", "true");
            if (hereBefore) {
		handleContent();
		return;
            } 
	    let detailsInner = this.jq(ID_DETAILS_INNER + entry.getIdForDom() + suffix);
            if (entry.getIsGroup() /* && !entry.isRemote*/ ) {
                detailsInner.html(HU.image(icon_progress));
                let _this = this;
                let callback = function(entries) {
                    _this.displayChildren(entry, entries, suffix, handlerId);
                };
                let entries = entry.getChildrenEntries(callback);
            } else {
                detailsInner.html(this.getEntryHtml(entry, {
                    showHeader: false
                }));
            }
	    handleContent();


	    let metadata = "";
	    entry.getMetadata().forEach(m=>{
		//Check for exclusions
		if(["content.pagetemplate","content.thumbnail","content.attachment"].includes(m.type)) return;
		if(m.type.startsWith("map")) return;
		if(m.type.startsWith("spatial")) return;		
                let tt = m.type+": " + m.value.attr1;
                let label =String(m.value.attr1);
		if(label.length>20) label = label.substring(0,19) +"...";
		metadata+=HU.div([CLASS,"display-search-tag",TITLE, tt],label);
		
	    });
	    this.jq(ID_DETAILS_TAGS + entry.getIdForDom() + suffix).html(metadata);


	    let ancestorContent = "";
	    let handleAncestor = ancestor=>{
		if(!ancestor) {
		    this.jq(ID_DETAILS_ANCESTORS + entry.getIdForDom() + suffix).html(ancestorContent);
		} else {
		    let href= ancestor.getLink(null, false,["target","_entries"]);
		    if(ancestorContent!="")
			href = href + HU.div([CLASS,"breadcrumb-delimiter"]);
		    ancestorContent = href +  ancestorContent;
		    ancestor.getParentEntry(handleAncestor);
		}
	    };
	    entry.getParentEntry(handleAncestor);



        },
        getSelectedEntriesFromTree: function() {
            var selected = [];
            if (this.selectedEntriesFromTree) {
                for (var id in this.selectedEntriesFromTree) {
                    var entry = this.selectedEntriesFromTree[id];
                    if (entry != null) {
                        selected.push(entry);
                    }
                }
            }
            return selected;
        },
        displayChildren: function(entry, entries, suffix, handlerId) {
            if (!suffix) suffix = "";
            var detailsInner = this.jq(ID_DETAILS_INNER + entry.getIdForDom() + suffix);
            var details = this.getEntryHtml(entry, {
                showHeader: false
            });
            if (entries.length == 0) {
                detailsInner.html(details);
            } else {
                var entriesHtml = "";
                if (this.showDetailsForGroup) {
                    entriesHtml += details;
                }
                entriesHtml += this.getEntriesTree(entries, {
                    handlerId: handlerId
                });
                detailsInner.html(entriesHtml);
                this.addEntrySelect();
            }
        },


        getEntryMenuButton: function(entry) {
            var menuButton = HU.onClick(this.getGet() + ".showEntryMenu(event, '" + entry.getId() + "');",
					HU.image(ramaddaBaseUrl + "/icons/menu.png",
						 [ATTR_CLASS, "display-entry-toolbar-item", ATTR_ID, this.getDomId(ID_MENU_BUTTON + entry.getIdForDom())]));
            return menuButton;
        },
        setRamadda: function(e) {
            this.ramadda = e;
        },
        getRamadda: function() {
            if (this.ramadda != null) {
                return this.ramadda;
            }
            if (this.ramaddaBaseUrl != null) {
                this.ramadda = getRamadda(this.ramaddaBaseUrl);
                return this.ramadda;
            }
            return getGlobalRamadda();
        },
        getEntry: async function(entryId, callback) {
            if (this.entriesMap && this.entriesMap[entryId]) {
                return Utils.call(callback, this.entriesMap[entryId]);
            }
            var ramadda = this.getRamadda();
            var toks = entryId.split(",");
            if (toks.length == 2) {
                entryId = toks[1];
                ramadda = getRamadda(toks[0]);
            }
            var entry = null;
            if (this.entryList != null) {
                await this.entryList.getEntry(entryId, e => entry = e);
            }
            if (entry == null) {
                await ramadda.getEntry(entryId, e => entry = e);
            }

            if (entry == null) {
                await this.getRamadda().getEntry(entryId, e => entry = e);
            }
            return Utils.call(callback, entry);
        },
        addMapLayer: async function(entryId) {
            var entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                console.log("No entry:" + entryId);
                return;
            }
            this.getDisplayManager().addMapLayer(this, entry);
        },
        doit: function() {
            console.log("doit");
        },
        createDisplay: async function(entryId, displayType, jsonUrl, displayProps) {
            var entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                console.log("No entry:" + entryId);
                return null;
            }
            var props = {
                sourceEntry: entry,
                entryId: entry.getId(),
		//                showMenu: false,
		//                showTitle: false,
                showDetails: true,
                title: entry.getName(),
		layoutHere:false,
            };
            if (displayProps) {
		$.extend(props, displayProps);
	    }

            //TODO: figure out when to create data, check for grids, etc
            if (displayType != DISPLAY_ENTRYLIST) {
                if (jsonUrl == null) {
                    jsonUrl = this.getPointUrl(entry);
                }
                var pointDataProps = {
                    entry: entry,
                    entryId: entry.getId()
                };
                props.data = new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
            }
            if (this.lastDisplay != null) {
                props.column = this.lastDisplay.getColumn();
                props.row = this.lastDisplay.getRow();
            } else {
                props.column = this.getProperty("newColumn", this.getColumn());
                props.row = this.getProperty("newRow", this.getRow());
            }
            this.lastDisplay = this.getDisplayManager().createDisplay(displayType, props);
        },
        getPointUrl: function(entry) {
            //check if it has point data
            var service = entry.getService("points.json");
            if (service != null) {
                return service.url;
            }
            service = entry.getService("grid.point.json");
            if (service != null) {
                return service.url;
            }
            return null;
        },
        getEntryMenu: async function(entryId, callback) {
            var entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            if (entry == null) {
                return Utils.call(callback, "null entry");
            }

            var get = this.getGet();
            var menus = [];
            var fileMenuItems = [];
            var viewMenuItems = [];
            var newMenuItems = [];
            viewMenuItems.push(HU.tag(TAG_LI, [], HU.tag(TAG_A, ["href", entry.getEntryUrl(), "target", "_"], "View Entry")));
            if (entry.getFilesize() > 0) {
                fileMenuItems.push(HU.tag(TAG_LI, [], HU.tag(TAG_A, ["download",null, "href", entry.getResourceUrl()], "Download " + entry.getFilename() + " (" + entry.getFormattedFilesize() + ")")));
            }

            if (this.jsonUrl != null) {
                fileMenuItems.push(HU.tag(TAG_LI, [], "Data: " + HU.onClick(get + ".fetchUrl('json');", "JSON") +
					  HU.onClick(get + ".fetchUrl('csv');", "CSV")));
            }

	    var props = "{showMenu:true,showTitle:true}";
            var newMenu = "<a>New</a><ul>";
            newMenu += HU.tag(TAG_LI, [], HU.onClick(get + ".createDisplay('" + entry.getFullId() + "','entrydisplay',null,null," + props+");", "New Entry Display"));
            newMenuItems.push(HU.tag(TAG_LI, [], HU.onClick(get + ".createDisplay('" + entry.getFullId() + "','entrydisplay',null,null," + props+");", "New Entry Display")));

            //check if it has point data
            var pointUrl = this.getPointUrl(entry);
            //            console.log("entry:" + entry.getName() + " url:" + pointUrl);

            if (pointUrl != null) {
                var types = window.globalDisplayTypes;
                var catMap = {};
                if (types) {
                    for (var i = 0; i < types.length; i++) {
                        var type = types[i];

                        if (!type.requiresData || !type.forUser) continue;
                        if (!Utils.isDefined(catMap[type.category])) {
                            catMap[type.category] = "<li> <a>" + type.category + "</a><ul>\n";
                        }
                        pointUrl = pointUrl.replace(/\'/g, "_");
                        var call = get + ".createDisplay(" + HU.sqt(entry.getFullId()) + "," + HU.sqt(type.type) + "," + HU.sqt(pointUrl) + ",null," + props +");";
                        var li = HU.tag(TAG_LI, [], HU.tag(TAG_A, ["onclick", call], type.label));
                        catMap[type.category] += li + "\n";
                        newMenuItems.push(li);
                    }
                }

                for (a in catMap) {
                    newMenu += catMap[a] + "</li></ul>";
                }
            }


            if (fileMenuItems.length > 0)
                menus.push("<a>File</a>" + HU.tag(TAG_UL, [], HU.join(fileMenuItems)));
            if (viewMenuItems.length > 0)
                menus.push("<a>View</a>" + HU.tag(TAG_UL, [], HU.join(viewMenuItems)));
            if (newMenuItems.length > 0)
                menus.push(newMenu);

            var topMenus = "";
            for (var i = 0; i < menus.length; i++) {
                topMenus += HU.tag(TAG_LI, [], menus[i]);
            }

            var menu = HU.tag(TAG_UL, [ATTR_ID, this.getDomId(ID_MENU_INNER + entry.getIdForDom()), ATTR_CLASS, "sf-menu"],
			      topMenus);
            callback(menu);
        },
        showEntryMenu: async function(event, entryId) {
            var menu;
            await this.getEntryMenu(entryId, m => {
                menu = m
            });
            this.writeHtml(ID_MENU_OUTER, menu);
            var srcId = this.getDomId(ID_MENU_BUTTON + Utils.cleanId(entryId));
	    this.dialog = HU.makeDialog({content:menu,anchor:srcId,draggable:false,header:false});
            $("#" + this.getDomId(ID_MENU_INNER + Utils.cleanId(entryId))).superfish({
                speed: 'fast',
                delay: 300
            });
        },
        fetchUrl: function(as, url) {
            if (url == null) {
                url = this.jsonUrl;
            }
            url = this.getDisplayManager().getJsonUrl(url, this);
            if (url == null) return;
            if (as != null && as != "json") {
                url = url.replace("points.json", "points." + as);
            }
            window.open(url, '_blank');
        },
        getMenuItems: function(menuItems) {

        },
        getDisplayMenuSettings: function() {
            var get = "getRamaddaDisplay('" + this.getId() + "')";
            var moveRight = HU.onClick(get + ".moveDisplayRight();", "Right");
            var moveLeft = HU.onClick(get + ".moveDisplayLeft();", "Left");
            var moveTop = HU.onClick(get + ".moveDisplayTop();", "Top");
            var moveUp = HU.onClick(get + ".moveDisplayUp();", "Up");
            var moveDown = HU.onClick(get + ".moveDisplayDown();", "Down");


            var menu = HU.open(TABLE,[CLASS,'formtable']) +
                "<tr><td align=right><b>Move:</b></td><td>" + moveTop + " " + moveUp + " " + moveDown + " " + moveRight + " " + moveLeft + "</td></tr>" +
                "<tr><td align=right><b>Row:</b></td><td> " + HU.input("", this.getProperty("row", ""), ["size", "7", ATTR_ID, this.getDomId("row")]) + " &nbsp;&nbsp;<b>Col:</b> " + HU.input("", this.getProperty("column", ""), ["size", "7", ATTR_ID, this.getDomId("column")]) + "</td></tr>" +
                "<tr><td align=right><b>Width:</b></td><td> " + HU.input("", this.getProperty("width", ""), ["size", "7", ATTR_ID, this.getDomId("width")]) + "  " + "<b>Height:</b> " + HU.input("", this.getProperty("height", ""), ["size", "7", ATTR_ID, this.getDomId("height")]) + "</td></tr>" +
                "</table>";
            var tmp =
                HU.checkbox(this.getDomId("showtitle"), [], this.getProperty("showTitle")) + " Title  " +
                HU.checkbox(this.getDomId("showdetails"), [], this.getProperty("showDetails")) + " Details " +
                "&nbsp;&nbsp;&nbsp;" +
                HU.onClick(get + ".askSetTitle();", "Set Title");
            menu += HU.formTable() + HU.formEntry("Show:", tmp) + HU.close(TABLE);
            return menu;
        },
        loadInitialData: function() {
	    if(!this.getProperty("okToLoadData",true)) return;
            if (!this.needsData() || this.properties.theData == null) {
                return;
            }
            if (this.getProperty("latitude")) {
                this.properties.theData.lat = this.getProperty("latitude");
                this.properties.theData.lon = this.getProperty("longitude", "-105");
            }


            if (this.properties.theData.hasData()) {
                this.addData(this.properties.theData);
                return;
            }
            this.properties.theData.loadData(this);
        },
        getData: function() {
            if (!this.hasData()) {
		//Inline data
		if(this.properties.dataSrc) {
		    this.addData(makeInlineData(this,this.properties.dataSrc));
		} else {
		    return null;
		}
	    }
            var dataList = this.dataCollection.getList();
            return dataList[0];
        },
        hasData: function() {
            if (this.dataCollection == null) return false;
            return this.dataCollection.hasData();
        },
        getCreatedInteractively: function() {
            return this.createdInteractively == true;
        },
        needsData: function() {
            return false;
        },
        askSetTitle: function() {
            var t = this.getTitle(false);
            var v = prompt(TITLE, t);
            if (v != null) {
                this.title = v;
                this.setProperty(ATTR_TITLE, v);
                this.setDisplayTitle(this.title);
            }
        },
        getShowDetails: function() {
            return this.getSelfProperty("showDetails", true);
        },
        setShowDetails: function(v) {
            this.showDetails = v;
            if (this.showDetails) {
                this.jq(ID_DETAILS).show();
            } else {
                this.jq(ID_DETAILS).hide();
            }
        },
        setShowTitle: function(v) {
	    if(v==="true") v = true;
	    else if(v==="false") v = true;	    
            this.setProperty("showTitle", v);
            if (v) {
                this.jq(ID_TITLE).show();
            } else {
                this.jq(ID_TITLE).hide();
            }
        },
        setDisplayProperty: function(key, value) {
            this.setProperty(key, value);
            $("#" + this.getDomId(key)).val(value);
        },
        deltaColumn: function(delta) {
            var column = parseInt(this.getProperty("column", 0));
            column += delta;
            if (column < 0) column = 0;
            this.setDisplayProperty("column", column);
            this.getLayoutManager().layoutChanged(this);
	    this.jq("col").val(column);
        },
        deltaRow: function(delta) {
            var row = parseInt(this.getProperty("row", 0));
	    if(isNaN(row)) row = 0;
            row += delta;
            if (row < 0) row = 0;
            this.setDisplayProperty("row", row);
            this.getLayoutManager().layoutChanged(this);
	    this.jq("row").val(row);
        },
        moveDisplayRight: function() {
            if (this.getLayoutManager().isLayoutColumns()) {
                this.deltaColumn(1);
            } else {
                this.getLayoutManager().moveDisplayDown(this);
            }
        },
        moveDisplayLeft: function() {
            if (this.getLayoutManager().isLayoutColumns()) {
                this.deltaColumn(-1);
            } else {
                this.getLayoutManager().moveDisplayUp(this);
            }
        },
        moveDisplayUp: function() {
            if (this.getLayoutManager().isLayoutRows()) {
                this.deltaRow(-1);
            } else {
                this.getLayoutManager().moveDisplayUp(this);
            }
        },
        moveDisplayDown: function() {
            if (this.getLayoutManager().isLayoutRows()) {
                this.deltaRow(1);
            } else {
                this.getLayoutManager().moveDisplayDown(this);
            }
        },
        moveDisplayTop: function() {
            this.getLayoutManager().moveDisplayTop(this);
        },
        getDialogContents: function(tabTitles, tabContents) {
	    this.getDisplayDialogContents(tabTitles, tabContents);
        },
        getDisplayDialogContents: function(tabTitles, tabContents) {
            var get = this.getGet();
            var menuItems = [];
            this.getMenuItems(menuItems);
            var form = "<form>";

            form += this.getDisplayMenuSettings();
            for (var i = 0; i < menuItems.length; i++) {
                form += HU.div([ATTR_CLASS, "display-menu-item"], menuItems[i]);
            }
            form += "</form>";
            tabTitles.push("Display"); 
            tabContents.push(form);
        },	
        checkLayout: function() {
	},
        displayData: function() {},
        setDisplayReady: function() {
//	    console.log("setDisplayReady");
	    var callUpdate = !this.displayReady;
            this.displayReady = true;
	    if(callUpdate) {
		this.callUpdateUI({force:true});
	    }
        },
        getDisplayReady: function() {
            return this.displayReady;
        },
        pageHasLoaded: function() {
	    if(!this.displayReady) {
		this.setDisplayReady(true);
	    }
        },
	doFinalInitialization:function() {
	},
        initDisplay: function() {
            this.createUI();
	    if(this.getAnimation().getEnabled()) {
		this.getAnimation().makeControls();
            }
            this.checkSearchBar();
	    this.callUpdateUI({force:true});
	    if(this.getProperty("reloadSeconds")) {
		this.runReload();
	    }
        },
	runReload: function() {
	    setTimeout(() =>{
		this.reloadData();
		this.runReload();
	    }, this.getProperty("reloadSeconds")*1000);
	},
        getMainDiv: function() {
	    //Don't check the parent for the targetDiv
	    let divId = this.getProperty("targetDiv",this.getProperty(PROP_DIVID,null,null,true),null,true);
	    return $("#" + divid); 
	},
        getGroupDiv: function() {
	    return $("#" + this.getProperty("groupDiv"));
	},	
        createUI: function() {
	    let divId = this.getProperty("targetDiv",this.getProperty(PROP_DIVID,null,null,true),null,true);
            if (divId != null) {
                var html = this.getHtml();
		let div = $("#" + divId);
		let inline = this.getProperty("displayInline");
		if(inline) {
		    div.css("display","inline-block");
		    div.css("vertical-align","bottom");
		} 
		let width = this.getWidth("100%");
		if(width && width!="-1") {
                    div.css("width",HU.getDimension(width));
		}
		div.html(html);
            } else {
                console.log("error: no div defined for display:" + this.getType());
            }
        },
        /*
          This creates the default layout for a display
          Its a table:
          <td>title id=ID_HEADER</td><td>align-right popup menu</td>
          <td colspan=2><div id=ID_DISPLAY_CONTENTS></div></td>
          the getDisplayContents method by default returns:
          <div id=ID_DISPLAY_CONTENTS></div>
          but can be overwritten by sub classes

          After getHtml is called the DisplayManager will add the html to the DOM then call
          initDisplay
          That needs to call setContents with the html contents of the display
        */
        getHtml: function() {
            let get = this.getGet();
            let button = "";

            if (this.getShowMenu()) {
                button = HU.onClick(get + ".showDialog();",
				    HU.image(ramaddaBaseUrl + "/icons/downdart.png",
					     [ATTR_CLASS, "display-dialog-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)]));
		button+=" ";
            }
	    if(this.getProperty("showProgress",false)) {
		//		button += HU.image(icon_progress,[ID,this.getDomId(ID_DISPLAY_PROGRESS)]);
	    }
            let title = "";
            if (this.getShowTitle()) {
                title = this.getTitle(false).trim();
            }

            let topLeft = "";
            if (button != "" || title != "") {
                let titleDiv = this.getTitleHtml(title);
                if (button == "") {
                    topLeft = titleDiv;
                } else {
                    topLeft = HU.div(["class","display-header"], button + SPACE + titleDiv);
                }
		
            }
            topLeft = HU.div([ID, this.getDomId(ID_TOP_LEFT),CLASS,"display-header-block"], topLeft);

	    let h2Separate = this.getAnimationEnabled();
	    let h1 = 	HU.div([ID,this.getDomId(ID_HEADER1),CLASS,"display-header-block display-header1"], "");
	    let h2 = HU.div([ID,this.getDomId(ID_HEADER2),CLASS,"display-header-block display-header2"], "");
            let topCenter = HU.div([ID, this.getDomId(ID_TOP),CLASS,"display-header-block"], h2Separate?"":h2);
            let topRight = HU.div([ID, this.getDomId(ID_TOP_RIGHT)], "");
	    let top =  this.getProperty("showHeader",true)?HU.leftCenterRight(topLeft, topCenter, topRight, null, null, null,{
                valign: "bottom"
            }):"";
            let header = h1;
	    if(h2Separate) header+=h2;
	    top =  header +  top;	    


	    let colorTable = HU.div([ID,this.getDomId(ID_COLORTABLE)]);
	    let rightInner="";
	    let leftInner="";

	    let bottom = HU.div([ATTR_CLASS, "", ATTR_ID, this.getDomId(ID_BOTTOM)]);
	    let legend = HU.div([ID,this.getDomId(ID_LEGEND)]);

	    let ctSide = this.getProperty("colorTableSide","bottom");
	    if(ctSide=="top") {
		top+=colorTable;
	    } else if(ctSide=="right") {
		rightInner += colorTable;
	    } else if(ctSide=="left") {
		leftInner += colorTable;
	    } else {
		bottom+=colorTable;
	    }
	    bottom+=legend;
	    let left = HU.div([ATTR_ID, this.getDomId(ID_LEFT)],leftInner);
	    let right = HU.div([ATTR_ID, this.getDomId(ID_RIGHT)],rightInner);
	    let sideWidth = "1%";
            let contents = this.getContentsDiv();
	    //display table
            let table =   HU.open('table', [CLASS, 'display-ui-table', 'width','100%','border','0','cellpadding','0','cellspacing','0']);
	    if(this.getProperty('showDisplayTop',true)) {
		table+= HU.tr([],HU.td(['width',sideWidth]) + HU.td(['width','99%'],top) +HU.td(['width',sideWidth]));
	    }
	    table+= HU.tr(["valign","top"],HU.td(['width',sideWidth],left) + HU.td(['width','99%'],contents) +HU.td(['width',sideWidth],right));
	    if(this.getProperty('showDisplayBottom',true)) {
		table+= HU.tr([],HU.td(['width',sideWidth]) + HU.td(['width','99%'],bottom) +HU.td(['width',sideWidth]));
	    }
	    table+=HU.close('table');
	    let message= HU.div([ID,this.domId(ID_DISPLAY_MESSAGE),CLASS,"display-output-message", STYLE,HU.css("display","none","position","absolute","top","10px","left","50%",
									"-webkit-transform","translateX(-50%)","transform","translateX(-50%)")],"message");
            let html =  HU.div([ATTR_CLASS, 'ramadda-popup', STYLE,"display:none;", ATTR_ID, this.getDomId(ID_MENU_OUTER)], '');
            let style = this.getProperty('displayStyle', '');
            html += HU.div([CLASS, 'display-contents', STYLE, HU.css('position','relative') + style],table + message);
            return html;
        },
        getWidthForStyle: function(dflt) {
            var width = this.getProperty("width", -1);
            if (width == -1) return dflt;
	    return HU.getDimension(width);
        },
        getHeightForStyle: function(dflt) {
            let height = this.getProperty("height", -1);
            if (height == -1) return dflt;
            if (new String(height).match("^[0-9]+$")) {
                height = height + "px";
	    }
            return height;
        },
        getContentsStyle: function() {
            let style = "";
            let height = this.getHeightForStyle();
            if (height) {
                style += HU.css(HEIGHT, height);
            }
            let maxheight = this.getProperty("maxHeight");
            if (maxheight) {
                style += HU.css("max-height", HU.getDimension(maxheight),"overflow-y","auto");
            }	    
            return style;
        },
	getContentsClass: function() {
	    return "ramadda-expandable-target display-contents-inner display-" + this.type;
	},
        getContentsDiv: function() {
            let style = this.getContentsStyle();
            style += this.getProperty("contentsStyle", "");
            let image = this.getProperty("backgroundImage");
            if (image) {
                image = HU.getEntryImage(this.entryId, image);
                style += HU.css("background-attachment","auto","background-size","100% auto","background-image","url('" + image + "')");
            }
            let background = this.getProperty("background");
            if (background)
                style += HU.css("background", background);
            let topBottomStyle = "";
	    //            let width = this.getWidthForStyle();
	    //            if (width) {
	    //                topBottomStyle += HU.css("width", width);
	    //            }
            let top = HU.div([STYLE, topBottomStyle, ATTR_ID, this.getDomId(ID_DISPLAY_TOP)], "");
            let bottom = HU.div([STYLE, topBottomStyle, ATTR_ID, this.getDomId(ID_DISPLAY_BOTTOM)], "");
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(expandedHeight)
		style+=HU.css(HEIGHT,expandedHeight);
	    let contentsAttrs =[ATTR_CLASS, this.getContentsClass(), STYLE, style, ATTR_ID, this.getDomId(ID_DISPLAY_CONTENTS)];
	    if(this.getProperty("expandableHeight")) {
		contentsAttrs.push("expandable-height");
		contentsAttrs.push(this.getProperty("expandableHeight"));
	    }
	    let contents =  top + "\n" +HU.div(contentsAttrs, "") + "\n" +bottom;
            return contents;
        },

        //Gets called before the displays are laid out
        prepareToLayout: function() {
            //Force setting the property from the input dom (which is about to go away)
            this.getColumn();
            this.getWidth();
            this.getHeight();
            this.getName();
            this.getEventSource();
        },
        getColumn: function() {
            return this.getFormValue("column", 0);
        },
        getRow: function() {
            return this.getFormValue("row", 0);
        },
        getWidth: function(dflt) {
            return this.getFormValue("width", dflt);
        },
        getHeight: function() {
            return this.getFormValue("height", 0);
        },
        getDisplayTitle: function(title) {
            if (!title) title = this.title != null ? this.title : "";
            var text = title;
            var fields = this.lastSelectedFields;
            if (fields && fields.length > 0)
                text = text.replace("{field}", fields[0].getLabel());
            else
                text = text.replace("{field}", HU.span([ID,this.getDomId(ID_TITLE_FIELD)],"&nbsp;"));
            return text;
        },

        setDisplayTitle: function(title) {
            if (!Utils.stringDefined(title)) {
                title = this.getTitle(false).trim();
            }
            var text = this.getTitleHtml(title);
            if (this.getShowTitle()) {
                this.jq(ID_TITLE).show();
            } else {
                this.jq(ID_TITLE).hide();
            }
            this.writeHtml(ID_TITLE, text);
        },
        getTitle: function(showMenuButton) {
            var prefix = "";
            if (showMenuButton && this.hasEntries()) {
                prefix = this.getEntryMenuButton(this.getEntries()[0]) + " ";
            }
            var title = this.getProperty(ATTR_TITLE);
            if (title != null) {
                return prefix + title;
            }
            if (this.dataCollection == null) {
                return prefix;
            }
            var dataList = this.dataCollection.getList();
            title = "";
            for (var collectionIdx = 0; collectionIdx < dataList.length; collectionIdx++) {
                var pointData = dataList[collectionIdx];
                if (collectionIdx > 0) title += "/";
                title += pointData.getName();
            }

            return prefix + title;
        },
        getIsLayoutFixed: function() {
            return this.getProperty(PROP_LAYOUT_HERE, true);
        },

        makeToolbar: function(props) {
            var toolbar = "";
            var get = this.getGet();
            var addLabel = props.addLabel;
            var images = [];
            var calls = [];
            var labels = [];
            if (!this.getIsLayoutFixed()) {
                calls.push("removeRamaddaDisplay('" + this.getId() + "')");
                images.push("fa-cut");
		labels.push("Delete display");
            }
            calls.push(get + ".copyDisplay();");
	    images.push("fa-copy");
            labels.push("Copy Display");
            if (this.jsonUrl != null) {
                calls.push(get + ".fetchUrl('json');");
                images.push(ramaddaBaseUrl + "/icons/json.png");
                labels.push("Download JSON");

                calls.push(get + ".fetchUrl('csv');");
                images.push(ramaddaBaseUrl + "/icons/csv.png");
                labels.push("Download CSV");
            }
            for (var i = 0; i < calls.length; i++) {
                var inner = HU.getIconImage(images[i], [ATTR_TITLE, labels[i], ATTR_CLASS, "display-dialog-header-icon"]);
                if (addLabel) inner += " " + labels[i] + "<br>";
                toolbar += HU.onClick(calls[i], inner);
            }
            return toolbar;
        },

	getHeader2:function() {
	    return "";
	},
	initHeader2:function() {
	},
	writeHeader:function(header,html) {
	    if(html=="") {
		this.jq(header).css("display","none");
	    } else {
		this.jq(header).css("display","inline-block");
	    }
	    this.jq(header).html(html);
	},

        //This keeps checking the width of the chart element if its zero
        //we do this for displaying in tabs
        checkLayout: function() {
            let d = this.jq(ID_DISPLAY_CONTENTS);
	    let w= d.width();
            if (this.lastWidth != w) {
		this.lastWidth = w;
                this.displayData();
            }
	},


        forceUpdateUI: function() {
	    this.haveCalledUpdateUI = false;
	    this.callUpdateUI();
	},
	callUpdateUI: function(args) {
	    args = args || {};
	    try {
		if(args.force)
		    this.haveCalledUpdateUI = false;
		this.updateUI(args);
	    } catch(err) {
                this.setContents(this.getMessage(err));
		console.log("Error:" + err);
		console.log(err.stack);
	    }
	},
        updateUI: function(args) {
	},
	getFilterId: function(id) {
	    return  this.getDomId("filterby_" + id);
	},
	getRequestMacros: function() {
	    if(!this.requestMacros) {
		this.requestMacros  = this.getRequestMacrosInner();
	    }
	    return this.requestMacros;
	},
	getRequestMacrosInner: function() {
	    let macros =[];
	    let p = this.getProperty("requestFields","");
	    let e1 = this.getProperty("extraFields1","");
	    let e2 = this.getProperty("extraFields2","");
	    let list = Utils.mergeLists(e1.split(","),p.split(","),e2.split(","));
	    if(p!="")
		console.log("requestFields=" + p);
	    list.forEach(macro=>{
		if(macro=="") return;
		macros.push(new RequestMacro(this, macro));
	    });
	    return macros;
	},
	applyRequestProperties: function(props) {
	    if(!props) return;
	    this.requestMacros = null;
	    this.dynamicProperties = props;
	    this.createRequestProperties();
	},
	createRequestProperties: function() {
	    let requestProps = "";
	    let macros = this.getRequestMacros();
	    let macroDateIds = [];
	    macros.forEach(macro=>{
		requestProps+=macro.getWidget(macroDateIds) +"&nbsp;&nbsp;";
		if(macro.isVisible()) {
		    requestProps+=SPACE2;
		}
	    });
	    this.writeHeader(ID_REQUEST_PROPERTIES, requestProps);
	    let macroChange = (macro,value,what)=>{
		if(this.settingMacroValue) return;
		if(macro.triggerReload) {
		    this.macroChanged();
		    this.reloadData();
		}
		if(!macro.name) return;
		this.settingMacroValue = true;
		var args = {
		    entryId:this.entryId,
		    property: "macroValue",
		    id:macro.name,
		    what:what,
		    value: value
		};
		this.propagateEvent("handleEventPropertyChanged", args);
		this.settingMacroValue = false;
	    };

	    let sliderFunc = function() {
		//		macroChangeinputFunc
	    };

	    macroDateIds.forEach(id=>{
		HU.datePickerInit(id);
	    });
	    this.jq(ID_HEADER2).find(".display-request-reload").click(()=>{
		macroChange({triggerReload:true});
	    });
	    macros.every(macro=>{
		$("#" + this.getDomId(macro.getId())+"," +
		  "#" + this.getDomId(macro.getId()+"_min")+ "," +
		  "#" + this.getDomId(macro.getId()+"_max")+ "," +
		  "#" + this.getDomId(macro.getId()+"_from")+ "," +
		  "#" + this.getDomId(macro.getId()+"_to")).keyup(function(e) {
		      var keyCode = e.keyCode || e.which;
		      if (keyCode == 13) {
			  macroChange(macro, $(this).val());
		      }
		  });
		if(macro.type == "bounds") {
		    this.jq(macro.getId()).change(function(e) {
			macroChange(macro,$(this).is(':checked'));
		    });
		}
		if(macro.type=="enumeration") {
		    this.jq(macro.getId()).change(function(e) {
			macroChange(macro, $(this).val());
		    });
		}
		this.jq(macro.getId()+"_min").change(function(e) {
		    //		    macroChange(macro, $(this).val(),"min");
		});
		this.jq(macro.getId()+"_max").change(function(e) {
		    //		    macroChange(macro, $(this).val(),"max");
		});
		this.jq(macro.getId()+"_from").change(function(e) {
		    macroChange(macro, $(this).val(),"from");
		});
		this.jq(macro.getId()+"_to").change(function(e) {
		    macroChange(macro, $(this).val(),"to");
		});		

		return true;
	    });
	},
	makeFilterWidget:function(label, widget, title) {
	    if(!label)
		return HU.div([CLASS,"display-filter-widget"],widget);
	    return HU.div([CLASS,"display-filter-widget"],this.makeFilterLabel(label,title)+(label.trim().length==0?" ":": ") +
			  widget);
	},
	makeFilterLabel: function(label,tt) {
	    let attrs = [CLASS,"display-filter-label"];
	    if(tt)  {
		attrs.push(TITLE);
		attrs.push(tt);
	    }
	    return HU.span(attrs,label);
	},

	stepFilterDateAnimation: function(inputFunc, dir){
	    let select = $("#" +this.getFilterId(ID_FILTER_DATE));
	    let index = select[0].selectedIndex;
	    let length = select.find('option').length;
	    index+=dir;
	    if(index>=length) {
		return;
		index =0;
	    } else if(index<0) {
		return;
		index = length-1;
	    }
	    select[0].selectedIndex = index;
	    inputFunc(select);
	    if(this.filterDatePlayingAnimation) {
		setTimeout(()=>{
		    this.stepFilterDateAnimation(inputFunc,1);
		},this.getProperty("filterDateAnimationSleep",1000));
	    }
	},

	addFilters: function(filters) {
	},
	initializeRangeSlider:function(jq, inputFunc, immediate) {
	    let _this = this;
	    jq.mousedown(function(){
		let id = $(this).attr(ID);
		id = id.replace(/_min$/,"").replace(/_max$/,"");
		let min = $("#" + id+"_min");
		let max = $("#" + id+"_max");
		let range = {
		    min: parseFloat(min.attr("data-min")),
		    max: parseFloat(max.attr("data-max"))};
		let minValue = parseFloat(min.val());
		let maxValue = parseFloat(max.val());
		let html = HU.div([ID,"filter-range",STYLE,HU.css("width","200px")],"");
		let popup = HtmlUtils.getTooltip();
		popup.html(html);
		popup.show();
		popup.position({
		    of: min,
		    my: "left top",
		    at: "left bottom+2",
		    collision: "fit fit"
                });

		if(isNaN(minValue)) minValue = range.min;	
		if(isNaN(maxValue)) maxValue = range.max;
		var step = 1;
		if(parseInt(range.max)!=range.max || parseInt(range.min) != range.min) 
		    step = (range.max-range.min)/100000;
		$( "#filter-range" ).slider({
		    range: true,
		    min: range.min,
		    max: range.max,
		    step: step,
		    values: [minValue, maxValue],
		    slide: function( event, ui ) {
			min.val(ui.values[0]);
			max.val(ui.values[1]);
			min.attr("data-value",min.val());
			max.attr("data-value",max.val());
			if(immediate) {
			    inputFunc(min,max);
			}
		    },
		    stop: function() {
			var popup = HtmlUtils.getTooltip();
			popup.hide();
			_this.checkFilterField(max);
			inputFunc(min,max);
		    }
		});
	    });
	},
	getRecordFilter: function(fieldId) {
	    if(this.filters) {
		for(let i=0;i<this.filters.length;i++) {
		    let filter = this.filters[i];
		    if(filter.field && filter.field.getId() == fieldId) return this.filters[i];
		}
	    }
	    return null;
	},
        checkSearchBar: function() {
	    let debug = displayDebug.checkSearchBar;
	    if(debug) console.log("checkSearchBar");
            let _this = this;

            this.colorByFields = this.getFieldsByIds(null, this.getProperty("colorByFields", "", true));
            this.sizeByFields = this.getFieldsByIds(null, this.getProperty("sizeByFields", "", true));
            this.sortByFields = this.getFieldsByIds(null, this.getProperty("sortByFields", "", true));	    


	    let pointData = this.getData();
            if (pointData == null) return;
            let fields= pointData.getRecordFields();
            let records = pointData.getRecords();
	    records = this.sortRecords(records);
	    let header2="";
	    //	    header2 +=HU.div([ID,this.getDomId("test")],"test");
	    if(this.getProperty("showProgress",false)) {
		header2 += HU.div([ID,this.getDomId(ID_DISPLAY_PROGRESS), STYLE,HU.css("display","inline-block","margin-right","4px","min-width","20px")]);
	    }
	    header2 += HU.div([ID,this.getDomId(ID_HEADER2_PREPREPREFIX),CLASS,"display-header-span"],"");
	    header2 += HU.div([ID,this.getDomId(ID_HEADER2_PREPREFIX),CLASS,"display-header-span"],"");
	    header2 += HU.div([ID,this.getDomId(ID_HEADER2_PREFIX),CLASS,"display-header-span"],"");
	    header2 +=  this.getHeader2();
	    if(this.getProperty("pageRequest",false)) {
		header2 += HU.span([ID,this.getDomId(ID_PAGE_COUNT)]);
	    }
	    header2+=HU.div([ID,this.getDomId(ID_REQUEST_PROPERTIES),CLASS,"display-header-span"],"");
	    if(this.getProperty("legendFields") || this.getProperty("showFieldLegend",false)) {
		let colors = this.getColorList();
		let fields =  this.getFieldsByIds(null, this.getProperty("legendFields", this.getPropertyFields(this.getProperty("sumFields"))));
		let html = "";
		let colorCnt = 0;
		fields.forEach((f)=>{
		    if(colorCnt>=colors.length) colorCnt = 0;
		    let color  = colors[colorCnt];
		    html += HU.div([STYLE,HU.css("display","inline-block","width","8px","height","8px","background",color)]) +" " + f.getLabel() +"&nbsp;&nbsp; ";
		    colorCnt++;
		});
		header2+= html;

	    }

	    if(this.getProperty("showDisplayFieldsMenu",false)) {
		let displayFields =  pointData.getChartableFields();
		if(displayFields.length) {
		    let fields = this.getSelectedFields();
		    let selected =[];
		    fields.forEach(f=>selected.push(f.getId()));
		    let enums = [];
		    displayFields.forEach(field=>{
			if(field.isFieldGeo()) return;
			enums.push([field.getId(),field.getLabel()]);
		    });
		    let attrs = [ID,this.getDomId("displayfields")];
		    if(this.getProperty("displayFieldsMenuMultiple",false)) {
			attrs.push("multiple");
			attrs.push("true");
			attrs.push("size");
			attrs.push("4");
		    }
		    this.displayFieldsMenuEnums = enums;
		    let html =  HU.span([CLASS,"display-filter"],
				       this.makeFilterLabel("Display: ") + HU.select("",attrs,enums,selected))+SPACE;
		    let side = this.getProperty("displayFieldsMenuSide","top");
		    if(side == "left") {
			this.jq(ID_LEFT).append(html);
		    } else {
			//TODO: do the other sides
			header2+=html;
		    }
		}
	    }


	    let selectFields = this.getProperty("selectFields");
	    let selectFieldProps = [];
	    if(selectFields) {
		selectFields.split(";").forEach(t=>{
		    //htmlLayerField:Sparkline Field:field1,field2
		    let [prop,label,fields]  = t.split(":");
		    if(fields==null) {
			fields = label;
			label = Utils.makeLabel(prop);
		    }
		    let selectFields = this.getFieldsByIds(null,fields);
		    let enums = [];
		    selectFields.forEach(field=>{
			if(field.isFieldGeo()) return;
			enums.push([field.getId(),field.getLabel()]);
		    });
		    header2 += HU.span([CLASS,"display-filter"],
				       (label==""?"":this.makeFilterLabel(label+": ")) + 
				       HU.select("",[ID,this.getDomId("fieldselect_" + prop)],enums,this.getProperty(prop,"")))+SPACE;

		    selectFieldProps.push(prop);
		});
	    }


	    if(this.colorByFields.length>0) {
		let enums = [];
		this.colorByFields.forEach(field=>{
		    if(field.isFieldGeo()) return;
		    enums.push([field.getId(),field.getLabel()]);
		});
		header2 += HU.span([CLASS,"display-filter"],
				   this.makeFilterLabel("Color by: ") + HU.select("",[ID,this.getDomId("colorbyselect")],enums,this.getProperty("colorBy","")))+SPACE;
	    }
	    if(this.sortByFields.length>0) {
		let enums = [];
		this.sortByFields.forEach(field=>{
		    if(field.isFieldGeo()) return;
		    enums.push([field.getId(),field.getLabel()]);
		});
		header2 += HU.span([CLASS,"display-filter"],
				   this.makeFilterLabel("Sort by: ") + HU.select("",[ID,this.getDomId("sortbyselect")],enums,this.getProperty("sortFields","")))+SPACE;
	    }

	    if(this.getProperty("showSortDirection")) {
		var sortAscending = this.getProperty("sortAscending",true);
		header2 +=HU.select("",[ID,this.getDomId("sortdirection")],[["up", "Sort Up"],["down","Sort Down"]],
				    sortAscending?"up":"down") + SPACE;
	    }




	    if(this.sizeByFields.length>0) {
		let enums = [];
		this.sizeByFields.forEach(field=>{
		    enums.push([field.getId(),field.getLabel()]);
		});
		header2 += HU.span([CLASS,"display-filter"],
				   this.makeFilterLabel("Size by: ") + HU.select("",[ID,this.getDomId("sizebyselect")],enums,this.getProperty("sizeBy","")))+SPACE;
	    }


	    let  highlight = this.getFilterHighlight();
	    if(this.getProperty("showFilterHighlight")) {
		let enums =[["filter","Filter"],["highlight","Highlight"]];
		header2 += HU.select("",["fieldId","_highlight", ID,this.getDomId(ID_FILTER_HIGHLIGHT)],enums,!highlight?"filter":"highlight") + SPACE2;
	    }


	    let dataFilterIds = [];
	    this.getDataFilters().forEach(f=>{
		if(!f.label) return;
		let cbxid = this.getDomId("datafilterenabled_" + f.id);
		dataFilterIds.push(cbxid);
		header2 +=  HU.checkbox("",[ID,cbxid],f.enabled) +" " +
		    this.makeFilterLabel(f.label +"&nbsp;&nbsp;")
	    });

	    if(this.getProperty("filterDate")) { 
		let type = this.getProperty("filterDate");
		//get dates
		let enums = [];
		if(this.getProperty("filterDateIncludeAll")) {
		    enums.push(["all","All"]);
		}
		let selected = null;
		let seen  = {};
		let dates  = [];
		records.forEach(record=>dates.push(record.getDate()));
		dates.sort(function(a,b) {
		    return a.getTime()-b.getTime();
		});
		dates.forEach(dttm=>{
		    let value = null;
		    if(type == "year") {
			value = dttm.getFullYear();
		    } else if(type== "day") {
			value = Utils.formatDateMonthDayYear(dttm);
		    }
		    if(!seen[value]) {
			selected = String(dttm);
			enums.push([String(dttm), value]);
			seen[value] = true;
		    }
		});

		let label = type=="year"?"Year":type=="month"?"Month":type=="day"?"Day":type;
		let style="";
		if(!this.getProperty("filterDateShow",true))
		    style +="display:none;";
		let selectId = this.getFilterId(ID_FILTER_DATE);
		
		label =  this.makeFilterLabel("Select " + label+": ");
		let prefix="";
		prefix += HU.div([ID,this.getDomId("filterDateStepBackward"),STYLE,HU.css("display","inline-block"),TITLE,"Step Back"],
 				 HU.getIconImage("fa-step-backward",[STYLE,HU.css("cursor","pointer")])) +SPACE1;
		prefix+=HU.div([ID,this.getDomId("filterDatePlay"),STYLE,HU.css("display","inline-block"),TITLE,"Play/Stop Animation"],
			       HU.getIconImage("fa-play",[STYLE,HU.css("cursor","pointer")])) + SPACE1;
		prefix += HU.div([ID,this.getDomId("filterDateStepForward"),STYLE,HU.css("display","inline-block"),TITLE,"Step Forward"],
 				 HU.getIconImage("fa-step-forward",[STYLE,HU.css("cursor","pointer")])) +SPACE1;

		header2 += HU.span([CLASS,"display-filter",STYLE,style],
				   prefix +
				   HU.select("",["fieldId","filterDate", ATTR_ID,selectId],enums,selected))+SPACE;
	    }
	    


            let filterBy = this.getProperty("filterFields","").split(","); 
	    let hideFilterWidget = this.getProperty("hideFilterWidget",false, true);
	    let fieldMap = {};
	    //Have this here so it can be used in the menu change events later. May cause problems if more than  one
	    let displayType = "";
	    this.filters = [];
	    this.addFilters(this.filters);
            if(filterBy.length>0) {
                for(let i=0;i<filterBy.length;i++) {
		    if(filterBy[i]!="") {
			this.filters.push(new RecordFilter(this, filterBy[i]));
		    }
		}
		let searchBar = "";
		let bottom = [""];
		this.filters.forEach(filter=>{
		    let widget = filter.getWidget(fieldMap, bottom,records);
		    widget = HU.span([ID,this.domId("filtercontainer_" + filter.id)], widget);
		    searchBar +=widget;
		});
		style = (hideFilterWidget?"display:none;":"") + this.getProperty("filterByStyle","");
		if(this.getProperty("showFilterTotal",false)) {
		    searchBar+= HU.span([CLASS,"display-filter-label",ID,this.getDomId(ID_FILTER_COUNT)],"");
		}
		let filterBar = searchBar+bottom[0];
		if(filterBar!="") {
		    header2+=HU.span([CLASS,"display-filter",STYLE,style,ID,this.getDomId(ID_FILTERBAR)],searchBar+bottom);
		}
	    }



	    header2+=HU.div([ID,this.getDomId(ID_HEADER2_SUFFIX),CLASS,"display-header-span"],"");
	    this.jq(ID_HEADER2).html(header2);
	    this.initHeader2();
	    this.jq("test").button().click(()=>{
		this.haveCalledUpdateUI = false;
		this.callUpdateUI();
	    });
	    this.createRequestProperties();
 	    let inputFunc = (input, input2, value) =>{
		if(this.ignoreFilterChange) return;
                var id = input.attr(ID);
		if(!id) {
		    console.log("No ID attribute");
		    return;
		}

		let changedFilter;
		let changedFilterId;
		_this.filters.every(filter=>{
		    if(filter.widgetId == id) {
			changedFilter = filter;
			changedFilterId = filter.id;
			return false;
		    }
		    return true;
		});

//		console.log("changed filter:" + changedFilter)
		let dependentFilters =[];
		if(changedFilter) {
		    this.filters.forEach(filter=>{
			if(filter.depends == changedFilter.id) {
			    dependentFilters.push(filter);
			    let widget = $("#" + filter.widgetId);
			    this.ignoreFilterChange = true; 
			    filter.lastValue = widget.val();
			    widget.val(FILTER_ALL);
			    this.ignoreFilterChange = false; 
			}
		    });
		}


		if(!input2) {
		    if(id.endsWith("_min")) {
			input2 = $("#" + id.replace(/_min$/,"_max"));
		    } else if(id.endsWith("_max")) {
			var tmp = input;
			input =$("#" + id.replace(/_max$/,"_min"));
			input2 = tmp;
		    }
		}
		if(input.attr("isCheckbox")) {
		    var on = input.attr("onValue")||true;
		    var off = input.attr("offValue")||false;
		    if (input.is(':checked')) {
			value = on;
			console.log(_this.type +" cbx is checked value:" + value +" on:" + on +" off:" + off);
		    } else {
			value=off;
			console.log(_this.type +" cbx is not checked value:" + value +" on:" + on +" off:" + off);
		    }
		}
		if(!value) {
		    value = input.val();
		} 
		if(!value || value=="") {
		    value = input.attr("data-value");
		}
		if(!value) {
		    value = input.val();
		}
		
		if(value==null) return;
		if(!Array.isArray(value) && input.attr("isButton")) {
		    //			console.log(_this.type +" " +Array.isArray(value));
		    var tmp = [];
		    value.split(",").forEach(v=>{
			tmp.push(v.replace(/_comma_/g,","));
		    });
		    value = tmp;
		}

                var fieldId = input.attr("fieldId");
		_this.checkFilterField(input);
		_this.haveCalledUpdateUI = false;
		if(_this.settingFilterValue) {
		    return;
		}
		_this.settingFilterValue = true;
		this.filteredRecords = null;
		_this.dataFilterChanged();


		let records =[];
		let predecessorChanged = false;
		dependentFilters.forEach(filter=>{
		    if(this.filteredRecords == null )
			this.filteredRecords =  this.filterRecords();
		    let widget = filter.getWidget({}, [],this.filteredRecords);
		    this.jq("filtercontainer_" + filter.id).html(widget);
		    if(filter.initWidget)
			filter.initWidget(inputFunc);
		    if(filter.widgetId) {
			let widget = $("#" + filter.widgetId);
			if(!widget.length) {
			    console.log("Could not find dependent widget:" + filter.id);
			    return;
			}
			if(filter.lastValue) {
			    if(widget[0].options) {
				let values= $.map(widget[0].options,(option)=>{return option.value});
				if(!values.includes(filter.lastValue)) filter.lastValue = FILTER_ALL;
			    }
			    widget.val(filter.lastValue);
			}
			widget.change(function() {
			    inputFunc($(this));
			});
		    }
		    return true;
		});



		this.addToDocumentUrl(fieldId+".filterValue",value);
		var args = {
		    property: PROP_FILTER_VALUE,
		    id:id,
		    fieldId: fieldId,
		    value: value
		};
		if(input2) {
		    args.value2 = input2.val();
		}
		_this.propagateEvent("handleEventPropertyChanged", args);
		_this.settingFilterValue = false;
            };

	    dataFilterIds.forEach(id=>{
		$("#" + id).click(function(e){
		    inputFunc($(this));
		});
	    });

	    
	    this.filters.forEach(f=>{
		if(f.initWidget)
		    f.initWidget(inputFunc);
	    });

	    this.jq(ID_FILTERBAR).find(".display-filter-items").each(function(){
		let parent = $(this);
		$(this).find(".display-filter-item").click(function(event){
		    var isAll = $(this).hasClass("display-filter-item-all");
		    var selectClazz = "display-filter-item-" + displayType +"-selected"
		    var wasSelected = $(this).hasClass(selectClazz);
		    var fieldId = $(this).attr("fieldId");
		    var multiples = _this.getProperty(fieldId +".filterMultiple",false);
		    if(!event.metaKey || isAll || !multiples) {
			parent.find(".display-filter-item").removeClass(selectClazz);
		    } else {
			parent.find(".display-filter-item-all").removeClass(selectClazz);
		    }
		    if(wasSelected  && event.metaKey) {
			$(this).removeClass(selectClazz);
		    } else {
			$(this).addClass(selectClazz);
		    }
		    var values = [];
		    parent.find("." + selectClazz).each(function() {
			values.push($(this).attr("data-value").replace(/,/g,"_comma_"));
		    });
		    if(values.length==0) {
			parent.find(".display-filter-item-all").addClass(selectClazz);
			values.push(FILTER_ALL);
		    }
		    var value =  Utils.join(values,",");
		    parent.attr("data-value", value);
		    $("#"+parent.attr(ID) +"_label").html(values.includes(FILTER_ALL)?SPACE:value);
		    inputFunc(parent,null, values);
		});

	    });
	    this.jq(ID_FILTERBAR).find(".display-filter-input").keyup(function(e) {
		var keyCode = e.keyCode || e.which;
		if (keyCode == 13) {return;}
		HtmlUtils.hidePopupObject();
		var input = $(this);
		var val = $(this).val().trim();
		if(val=="") return;
                var fieldId = $(this).attr("fieldId");
		var field = fieldMap[fieldId].field;
		var values = fieldMap[fieldId].values;
		var items=[];
		var regexp=null;
		try {
		    val = val.replace(/\./g,"\\.");
		    regexp = new RegExp("(" + val+")",'i');
		} catch(ignore) {
		    //todo
		}
		for(var i=0;i<values.length;i++) {
		    var text= values[i].toString();
		    var match  = regexp?text.match(regexp):text.indexOf(val)>=0;
		    if(match) {
			items.push([match[1], values[i]]);
		    }
		    if(items.length>30) break;
		}
		if(items.length>0) {
		    var html = "";
		    var itemCnt = 0;
		    items.forEach(item=>{
			var match = item[0];
			item =  item[1];
			if(item.length>50) return;
			var label = item.replace(regexp,"<span style='background:" + TEXT_HIGHLIGHT_COLOR +";'>" + match +"</span>");
			item = item.replace(/\'/g,"\'");
			html+=HU.div([CLASS,"display-filter-popup-item","item",item],label)+"\n";
			itemCnt++;
		    });	
		    if(itemCnt>0) {
			let popup =HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
			popup.html(HU.div([CLASS, "ramadda-popup-inner ramadda-snippet-popup"], html));
			popup.show();
			popup.position({
			    of: $(this),
			    my: "left top",
			    at: "left bottom",
			});
			$(".display-filter-popup-item").click(function(){
			    HtmlUtils.hidePopupObject();
			    input.val($(this).attr("item"));
			    inputFunc(input);
			});
		    }
		}

	    });



	    this.initializeRangeSlider(this.jq(ID_FILTERBAR).find(".display-filter-range"), inputFunc, this.getProperty("filterSliderImmediate"));

	    this.jq(ID_FILTER_HIGHLIGHT).change(function() {
		_this.setProperty("filterHighlight", $(this).val()=="highlight");
		_this.haveCalledUpdateUI = false;
		inputFunc($(this));
	    });


	    $("#" + this.getFilterId(ID_FILTER_DATE)).change(function() {
		inputFunc($(this));
	    });
	    this.jq("filterDatePlay").click(function() {
		_this.filterDatePlayingAnimation = !_this.filterDatePlayingAnimation;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		$(this).html(HU.getIconImage(icon,[STYLE,HU.css("cursor","pointer")]));
		if(_this.filterDatePlayingAnimation) {
		    _this.stepFilterDateAnimation(inputFunc,1);
		}
	    });
	    this.jq("filterDateStepBackward").click(function() {
		_this.filterDatePlayingAnimation = false;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		_this.jq("filterDatePlay").html(HU.getIconImage(icon,[STYLE,HU.css("cursor","pointer")]));
		_this.stepFilterDateAnimation(inputFunc,-1);
	    });
	    this.jq("filterDateStepForward").click(function() {
		_this.filterDatePlayingAnimation = false;
		let icon = _this.filterDatePlayingAnimation?"fa-stop":"fa-play";
		_this.jq("filterDatePlay").html(HU.getIconImage(icon,[STYLE,HU.css("cursor","pointer")]));
		_this.stepFilterDateAnimation(inputFunc,1);
	    });

            this.jq("displayfields").change(function(){
		let val = $(this).val();
		if(Array.isArray(val)) {
		    val = val.join(",");
		}
		_this.displayFieldsChanged(val);
		_this.propagateEvent("handleEventPropertyChanged", {
		    property:'displayFields',
		    value: val
		});
	    });


	    selectFieldProps.forEach(prop=>{
                this.jq("fieldselect_" + prop).change(function(){
		    _this.fieldSelectedChanged(prop,$(this).val());
		});
	    });


            this.jq("colorbyselect").change(function(){
		_this.colorByFieldChanged($(this).val());
	    });
            this.jq("sortbyselect").change(function(){
		_this.sortByFieldChanged($(this).val());
	    });
	    this.jq("sortdirection").change(function(){
		let val = $(this).val();
		_this.setProperty("sortAscending",val=="up");
		_this.forceUpdateUI();
	    });
            this.jq("sizebyselect").change(function(){
		_this.sizeByFieldChanged($(this).val());
	    });

            this.jq(ID_FILTERBAR).find("input").keyup(function(e){
		var keyCode = e.keyCode || e.which;
		if (keyCode == 13) {
		    inputFunc($(this));
		}
	    });
	    this.jq(ID_FILTERBAR).find("input:radio,select").change(function() {
		inputFunc($(this));
	    });
	    this.jq(ID_FILTERBAR).find("input:checkbox").change(function() {
		inputFunc($(this));
	    });
	    

	    var dates = [];
	    if(debug) console.log("checkSearchBar-getting filtered data");
	    let filteredRecords  = this.filterData();
	    if(debug) console.log("checkSearchBar-done getting filtered data");
	    let dateInfo = this.getDateInfo(filteredRecords);
	    if(debug) console.log("checkSearchBar-11");
            if (dateInfo.dateMax) {
		if(debug) console.log("checkSearchBar-getAnimation");
		var animation = this.getAnimation();
		if(animation.getEnabled()) {
		    if(debug) console.log("checkSearchBar-calling animation.init");
//		    console.log("dateMin:" + dateMin.toUTCString());
		    animation.init(dateInfo.dateMin, dateInfo.dateMax,filteredRecords);
		    if(debug) console.log("checkSearchBar-done calling animation.init");
		    if(!this.minDateObj) {
			if(debug) console.log("checkSearchBar-calling setDateRange");
			if(this.getProperty("animationFilter", true)) {
			    this.setDateRange(animation.begin, animation.end);
			}
			if(debug) console.log("checkSearchBar-done calling setDateRange");
		    }
		}
            }
	    if(debug) console.log("checkSearchBar-done");
        },
	getDateInfo:function(records) {
	    let dateMin = null;
	    let dateMax = null;
	    let dates =[];
	    records.every(record=>{
		if (dateMin == null) {
		    dateMin = record.getDate();
		    dateMax = record.getDate();
		} else {
		    var date = record.getDate();
		    if (date) {
			dates.push(date);
			if (date.getTime() < dateMin.getTime())
			    dateMin = date;
			if (date.getTime() > dateMax.getTime())
			    dateMax = date;
		    }
		}
		return true;
	    });
	    return { dateMin:dateMin, dateMax:dateMax, dates:dates};
	},
	    
	checkFilterField: function(f) {
	    var min = f.attr("data-min");
	    var max = f.attr("data-max");
	    var value = f.val();
	    if(Utils.isDefined(min)) {
		if(value != min) {
		    f.css("background",TEXT_HIGHLIGHT_COLOR);
		} else {
		    f.css("background","white");
		}
	    } else if(Utils.isDefined(max)) {
		if(value != max) {
		    f.css("background",TEXT_HIGHLIGHT_COLOR);
		} else {
		    f.css("background","white");
		}
	    }

	},
	fieldSelectedChanged: function(prop,val) {
	    this.setProperty(prop,val);
	    this.haveCalledUpdateUI = false;
	    this.callUpdateUI();
	},
	colorByFieldChanged:function(field) {
	    this.setProperty("colorBy", field);
	    this.callUpdateUI();
	},
	sortByFieldChanged:function(field) {
	    this.setProperty("sortFields", field);
	    this.callUpdateUI();
	},
	sizeByFieldChanged:function(field) {
	},
	someFieldChanged:function(type,field) {
	},	
	macroChanged: function() {
	    this.pageSkip = 0;
	},
	dataFilterChanged: function(args) {
	    args = args||{};
	    args.dataFilterChanged = true;
	    this.callUpdateUI(args);
	},
	addFieldClickHandler: function(jq, records, addHighlight) {
	    let _this = this;
	    if(records) {
		if(!jq) jq = this.jq(ID_DISPLAY_CONTENTS);
		let map = this.makeIdToRecords(records);
		let func = function() {
		    if(addHighlight) {
			$(this).parent().find(".display-row-highlight").removeClass("display-row-highlight");
			$(this).addClass("display-row-highlight");
		    }
		    let record = records[$(this).attr(RECORD_INDEX)];
		    if(!record) record = map[$(this).attr(RECORD_ID)];
		    if(record)
			_this.propagateEventRecordSelection({record:record});
		};
		let children = jq.find("[" +RECORD_INDEX+"]");
		if(!children.length) children = jq.find("[" +RECORD_ID+"]");
		if(!children.length) children = jq;
		children.click(func);
	    }

	    if(this.getProperty("propagateValueClick",true)) {
		let _this = this;
		if(!jq) jq = this.jq(ID_DISPLAY_CONTENTS);
		jq.find("[field-id]").click(function() {
		    let fieldId = $(this).attr("field-id");
		    let value = $(this).attr("field-value");
		    let args = {
			property: PROP_FILTER_VALUE,
			id:fieldId,
			fieldId: fieldId,
			value: value
		    };
		    _this.propagateEvent("handleEventPropertyChanged", args);
		});
	    }

	},
	makeIdToRecords: function(records) {
	    let idToRecord = {};
	    records.forEach(r=>idToRecord[r.getId()] = r);	    
	    return idToRecord;
	},
	//Make sure to set the title attribute on the elements
	makeTooltips: function(selector, records, callback, tooltipArg,propagateHighlight) {		
	    if(!Utils.isDefined(propagateHighlight) || propagateHighlight==null)
		propagateHighlight = this.getProperty("propagateEventRecordHighlight",false);
	    if(!this.getProperty("showTooltips",true)) {
		return;
	    }
	    var tooltip = tooltipArg || this.getProperty("tooltip");
	    if(tooltip==null) {
		return;
	    }
	    let _this = this;
	    let idToRecord = this.makeIdToRecords(records);
	    let tooltipFunc = {
		content: function() {
		    let record = idToRecord[$(this).attr(RECORD_ID)];
		    if(!record)  record = records[parseFloat($(this).attr(RECORD_INDEX))];
		    if(!record) return null;
		    let propagateOk = true;
		    if(callback && callback(true, record) === false) {
			propagateOk = false;
		    }
		    if(propagateOk && propagateHighlight) {
			_this.getDisplayManager().notifyEvent("handleEventRecordHighlight", _this, {highlight:true,record: record});
		    }
		    if(tooltip=="" || tooltip=="none") return null;
		    let style = _this.getProperty("tooltipStyle");
		    let tt =  _this.getRecordHtml(record,null,tooltip);
		    if(style) tt=HU.div([STYLE,style],tt);
		    return tt;
		},
		close: function(event,ui) {
		    let record = idToRecord[$(this).attr(RECORD_ID)];
		    if(!record)
			record = records[parseFloat($(this).attr(RECORD_INDEX))];
		    let propagateOk = true;
		    if(callback && callback(false, record) === false) {
			propagateOk = false;
		    }
		    if(propagateOk && propagateHighlight)
			_this.getDisplayManager().notifyEvent("handleEventRecordHighlight", _this, {highlight:false,record: record});
		},
		position: {
		    my: _this.getProperty("tooltipPositionMy", "left top"),
		    at: _this.getProperty("tooltipPositionAt", "left bottom+2"),
		    collision: _this.getProperty("tooltipCollision", "none none")
		},
		show: {
		    delay: parseFloat(_this.getProperty("tooltipDelay",1000)),
		    duration: parseFloat(_this.getProperty("tooltipDuration",500)),
	    
		},
		classes: {
		    "ui-tooltip": _this.getProperty("tooltipClass", "ramadda-shadow-box  display-tooltip")
		}
	    };
	    if(selector.length>500) {
		//A hack to fix really slow tooltip calls when there are lots of elements
		selector.mouseenter(function() {
		    let tooltip = $(this).tooltip(tooltipFunc);
		    tooltip.tooltip('open');
		});
		selector.mouseleave(function() {
		    let tooltip = $(this).tooltip({});
		    tooltip.tooltip('close');
		});
	    } else {
		selector.tooltip(tooltipFunc);
	    }
	},
	makeRecordSelect: function(selector,idToRecords, callback) {
	    let _this = this;
	    selector.click(function(event){
		var record = idToRecords[$(this).attr(RECORD_ID)];
		if(!record) return;
		if(callback) callback(record);
		_this.propagateEventRecordSelection({select:true,record: record});
	    });
	},
	makePopups: function(selector, records, callback, popupTemplate) {
	    if(!popupTemplate)
		popupTemplate = this.getProperty("popupTemplate");
	    if(!popupTemplate) return;
	    let _this = this;
	    selector.click(function(event){
		var record = records[parseFloat($(this).attr(RECORD_INDEX))];
		if(!record) return;
		if(callback) callback(record);
		_this.propagateEventRecordSelection({select:true,record: record});
		_this.showRecordPopup($(this),record, callback,popupTemplate);
	    });
	},
	showRecordPopup: function(element, record, popupTemplate) {
	    if(!record) return;
	    if(!popupTemplate)
		popupTemplate = this.getProperty("popupTemplate");
	    if(!popupTemplate) return;
	    let _this = this;
	    HtmlUtils.hidePopupObject();
	    var html =  _this.getRecordHtml(record,null,popupTemplate);
	    html = HU.div([CLASS, "display-popup " + _this.getProperty("popupClass",""),STYLE, _this.getProperty("popupStyle","")],html);
	    let popup = HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
	    popup.html(html);
	    popup.show();
	    popup.position({
		of: element,
		my: _this.getProperty("popupPositionMy", "left top"),
		at: _this.getProperty("popupPositionAt", "left bottom+2"),
		collision: _this.getProperty("popupCollision", "none none")
	    });
	},
	animationStart: function(animation) {
	},
	animationApply: function(animation, skipUpdateUI) {
	    if(this.getProperty("animationFilter", true))
		this.setDateRange(animation.begin, animation.end);
	    if(!skipUpdateUI) {
		this.haveCalledUpdateUI = false;
		//		var t1 = new Date();
		this.dataFilterChanged({source:"animation"});
		//		var t2 = new Date();
		//		Utils.displayTimes("timeChanged",[t1,t2]);
	    }
	    this.propagateEvent("handleEventPropertyChanged", {
		property: "dateRange",
		minDate: animation.begin,
		maxDate: animation.end
	    });
	},
        makeDialog: function(text) {
            var html = "";
	    if(!text) {
		var tabTitles = [];
		var tabContents = [];
		this.getDialogContents(tabTitles, tabContents);
		tabTitles.push("Edit");
		tabContents.push(this.makeToolbar({
                    addLabel: true
		}));
		var tabLinks = "<ul>";
		var tabs = "";
		for (var i = 0; i < tabTitles.length; i++) {
                    var id = this.getDomId("tabs") + i;
                    tabLinks += HU.tag("li", [], HU.tag("a", ["href", "#" + id],
							tabTitles[i]));
                    tabLinks += "\n";
                    var contents = HU.div([ATTR_CLASS, "display-dialog-tab"], tabContents[i]);
                    tabs += HU.div([ID, id], contents);
                    tabs += "\n";
		}
		tabLinks += "</ul>\n";
		text =  HU.div([ID, this.getDomId(ID_DIALOG_TABS)], tabLinks + tabs);
	    }
	    return text;
        },
        initDialog: function() {
            var _this = this;
            var updateFunc = function(e) {
                if (e && e.which != 13 && e.which!=0) {
                    return;
                }
		var changed = false;
		["column","row","width","height"].forEach(f=>{
                    if(_this[f] != _this.jq(f).val() && (_this[f] || _this.jq(f).val().trim()!="")) {
			changed = true;
			_this[f] = _this.jq(f).val();
		    }});
		

                if(changed) {
		    _this.getLayoutManager().doLayout();
		}
            };
	    ["column","row","width","height"].forEach(f=>{
		this.jq(f).blur(updateFunc);
		this.jq(f).keypress(updateFunc);
	    });

            this.jq("showtitle").change(function() {
                _this.setShowTitle(_this.jq("showtitle").is(':checked'));
            });
            this.jq("showdetails").change(function() {
                _this.setShowDetails(_this.jq("showdetails").is(':checked'));
            });
            this.jq(ID_DIALOG_TABS).tabs();

        },
        showDialog: function(text, from, initDialog, title) {
	    if(this.dialog) this.dialog.remove();
	    if(!this.dialogElement) {
//		$(document.body).append(HU.div([ATTR_CLASS, "display-dialog",ID,this.getDomId(ID_DIALOG)]));
//		this.dialogElement = this.jq(ID_DIALOG);
	    }
	    let html = this.makeDialog(text);
	    this.dialog = HU.makeDialog({content:html,title:title||this.getTitle(),anchor:from||this.jq(ID_MENU_BUTTON),draggable:true,header:true});
	    if(initDialog) initDialog();
            else this.initDialog();
	    return this.dialog;
        },
        copyDisplay: function() {
            let newOne = {};
            $.extend(true, newOne, this);
            newOne.setId(newOne.getId() + this.getUniqueId("display"));
            addRamaddaDisplay(newOne);
            this.getDisplayManager().addDisplay(newOne);
        },
        removeDisplay: function() {
            this.getDisplayManager().removeDisplay(this);
	    if(this.dialogElement)  this.dialogElement.remove();
        },
        doingQuickEntrySearch: false,
        doQuickEntrySearch: function(request, callback) {
            if (this.doingQuickEntrySearch) return;
            var text = request.term;
            if (text == null || text.length <= 1) return;
            this.doingQuickEntrySearch = true;
            var searchSettings = new EntrySearchSettings({
                name: text,
                max: 10,
            });
            if (this.searchSettings) {
                searchSettings.clearAndAddType(this.searchSettings.entryType);
            }
	    let _this = this;
            var jsonUrl = this.getRamadda().getSearchUrl(searchSettings, OUTPUT_JSON);
            var handler = {
                entryListChanged: function(entryList) {
                    _this.doneQuickEntrySearch(entryList, callback);
                }
            };
            var entryList = new EntryList(this.getRamadda(), jsonUrl, handler, true);
        },
        doneQuickEntrySearch: function(entryList, callback) {
            var names = [];
            var entries = entryList.getEntries();
            for (var i = 0; i < entries.length; i++) {
                names.push(entries[i].getName());
            }
            callback(names);
            this.doingQuickEntrySearch = false;

        },
        addData: async function(pointData) {
            var records = pointData.getRecords();
            if (records && records.length > 0) {
                this.hasElevation = records[0].hasElevation();
            } else {
                this.hasElevation = false;
            }
	    pointData = this.convertPointData(pointData);
            this.dataCollection.addData (pointData);
            var entry = pointData.entry;
            if (entry == null && pointData.entryId) {
                await this.getRamadda().getEntry(pointData.entryId, e => {
                    entry = e
                });
            }
            if (entry) {
                pointData.entry = entry;
                this.addEntry(entry);
            }
        },
	setErrorMessage: function(msg) {
            this.setContents(this.getMessage(msg));
	},
	clearProgress: function() {
	    this.jq(ID_DISPLAY_PROGRESS).html("");
	},
	startProgress: function() {
	    if(this.jq(ID_DISPLAY_PROGRESS).length>0) 
		this.jq(ID_DISPLAY_PROGRESS).html(HU.image(icon_progress));
	    else {
		if(this.useDisplayMessage()) {
                    this.setDisplayMessage(this.getLoadingMessage());
		} else {
		    this.setContents(this.getLoadingMessage());
		}
	    }
	},
	handleNoData: function(pointData,reload) {
	    let debug = displayDebug.handleNoData;
	    this.jq(ID_PAGE_COUNT).html("");
            if (!reload) {
		if(debug) console.log("\tno reload");
                this.addData(pointData);
                this.checkSearchBar();
            } else {
		if(!this.dataCollection)
		    this.dataCollection = new DataCollection();
		this.dataCollection.setData(pointData);
	    }
            this.setContents(this.getMessage(this.getNoDataMessage()));
	},
        pointDataLoadFailed: function(data) {
	    this.clearProgress();
            this.inError = true;
            errorMessage = this.getProperty("errorMessage", null);
            if (errorMessage != null) {
                this.setContents(errorMessage);
                return;
            }
            var msg = "";
            if (data && data.errorcode && data.errorcode == "warning") {
                msg = data.error;
            } else {
                msg = "<b>An error has occurred:</b>";
                if (!data) data = this.getNoDataMessage();
                var error = data.error ? data.error : data;
                error = error.replace(/<[^>]*>/g, "");
                var tmp = "";
                var lines = error.split("\n");
                var seen = {};
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line == "") continue;
                    if (seen[line]) continue;
                    seen[line] = true;
                    tmp += line + "\n";
                }
                error = tmp;
                error = HU.tag("pre", [STYLE, HU.css("max-height","300px","overflow-y","auto","max-width","100%","overflow-x","auto")], error);
                msg += error;
            }
	    this.setErrorMessage(msg);
        },
        //callback from the pointData.loadData call
        clearCache: function() {},
	handleEventDataSelection: function(source, args) {
	    if(this.getAcceptEventDataSelection()) {
		this.pointDataLoaded(args.data,"",true);
	    }
	},
	getRequirement:function() {
	    return null;
	},
        pointDataLoaded: function(pointData, url, reload) {
//	    console.log(this.type +".pointDataLoaded");
	    let debug = displayDebug.pointDataLoaded;

	    this.clearProgress();
            this.inError = false;
            this.clearCache();
	    if(debug) console.log(this.type+" pointDataLoad:" + this.getId() + " " + this.type +" #records:" + pointData.getRecords().length);
	    if(debug)
		console.log("\tclearing last selected fields");
	    
	    this.lastSelectedFields = null;
            if (!reload) {
		if(debug) console.log("\tcalling addData");
                this.addData(pointData);
		//		if(debug) console.log("\tcalling checkSearchBar");
                this.checkSearchBar();
		//		if(debug) console.log("\done calling checkSearchBar");
            } else {
		pointData = this.convertPointData(pointData);
		if(!this.dataCollection)
		    this.dataCollection = new DataCollection();
		if(debug) console.log("\tcalling setData");
		this.dataCollection.setData(pointData);
	    }

	    if(this.getProperty("pageRequest")) {
		if(debug) console.log("\tupdating pageRequest");
		let count = pointData.getRecords().length;
		let skip = null;
		let skipToks = url?url.match(/skip=([0-9]+)/):null;
		if(skipToks) skip = +skipToks[1];
		let max = +this.getProperty("max",5000);
		//		console.log("max:" +max +" count:" + count +" skip:" + skip);
		let label = count;
		if(skip!=null && skip>0)
		    label = String(skip+1)+"-"+(count+skip);
		else if(count==max)
		    label = "1" +"-"+count;
		let pageInfo = this.getProperty("pageRequestLabel","Showing: ${count}").replace("${count}",label) +" ";
		let gotAll = !skip &&  count<max;

		if(skip!=null && skip>0) {
		    pageInfo+= HU.getIconImage("fa-step-backward",[ID,this.getDomId(ID_PAGE_PREV),CLASS,"display-page-button",TITLE,"View previous"])
		}  else if(!gotAll) {
		    pageInfo+= HU.getIconImage("fa-step-backward",[CLASS,"display-page-button fa-disabled"])
		}
		if(count==max) {
		    pageInfo+= HU.getIconImage("fa-step-forward",[ID,this.getDomId(ID_PAGE_NEXT),CLASS,"display-page-button",TITLE,"View next"])
		}  else if(!gotAll) {
		    pageInfo+= HU.getIconImage("fa-step-forward",[CLASS,"display-page-button fa-disabled"])
		}
		this.jq(ID_PAGE_COUNT).html(pageInfo+"&nbsp;&nbsp;");
		this.jq(ID_PAGE_NEXT).click(()=>{
		    if(!this.pageSkip)
			this.pageSkip=0;
		    this.pageSkip+=max;
		    this.reloadData();
		});
		this.jq(ID_PAGE_PREV).click(()=>{
		    if(!this.pageSkip)
			this.pageSkip=0;
		    this.pageSkip-=max;
		    if(this.pageSkip<0) this.pageSkip=0;
		    this.reloadData();
		});		
	    }

            if (url != null) {
                this.jsonUrl = url;
            } else {
                this.jsonUrl = null;
            }
            if (!this.getDisplayReady()) {
		if(debug)console.log("pointDataLoaded: display not ready");
                return;
            }

	    if(!this.getProperty("dateFormat")) {
                pointData.getRecordFields().forEach(f=>{
		    if(f.isFieldDate() && f.getId() == "year") {
			this.setProperty("dateFormat","yyyy");
		    }
		});
	    }
	    
	    this.haveCalledUpdateUI = false;
	    if(debug) console.log("\tcalling updateUI");
	    try {
		let requirement = this.getRequirement();
		if(requirement) {
//		    console.log("waiting on:" + requirement);
		    HU.waitForIt(requirement,()=>{
			this.updateUI({reload:reload});
		    });
		} else {
		    this.updateUI({reload:reload});
		}

	    } catch(err) {
                this.displayError("Error creating display:<br>" + err);
		console.log(err);
		return;
	    }
            if (!reload) {
                this.lastPointData = pointData;
                this.propagateEvent("handleEventPointDataLoaded", pointData);
            }
        },
        getHasDate: function(records) {
            var lastDate = null;
            this.hasDate = false;
            for (j = 0; j < records.length; j++) {
                var record = records[j];
                var date = record.getDate();
                if (date == null) {
                    continue;
                }
                if (lastDate != null && lastDate.getTime() != date.getTime()) {
                    this.hasDate = true;
                    break
                }
                lastDate = date;
            }
            return this.hasDate;
        },
        dateInRange: function(date, debug) {
	    if(debug) {
		console.log("dateInRange: date:" + date +" minDate:" + this.minDateObj +" maxDate:" + this.maxDateObj);
	    }

            if (date != null) {
		if(this.dateRangeDoDay && this.minDateObj) {
		    if(date.getUTCFullYear()!=this.minDateObj.getUTCFullYear() ||
		       date.getUTCMonth()!=this.minDateObj.getUTCMonth() ||
 		       date.getUTCDate()!=this.minDateObj.getUTCDate())  {
			return false;
		    }
		    
		} else {
                    if (this.minDateObj != null && date.getTime() < this.minDateObj.getTime()) {
			if(debug) {
			    console.log("    minDate:\n\t" + date.getTime() +"\n\t" + this.minDateObj.getTime());
			}
			return false;
                    }
                    if (this.maxDateObj != null && date.getTime() > this.maxDateObj.getTime()) {
			if(debug) {
			    console.log("    maxDate:\n\t" + date.getTime() +"\n\t" + this.minDateObj.getTime());
			}
			return false;
		    }
                }
		
//		let str =  date.toUTCString() +" " +(date.getTime() < this.startDateObject.getTime());
		if (this.startDateObject != null && date.getTime() < this.startDateObject.getTime()) {
		    if(debug) {
//			console.log("    startDate:\n\t" + date.getTime() +"\n\t" + this.startDateObject.getTime());
		    }
//		    console.log("skip " + str);
                    return false;
                }
//		console.log("no skip " + str +" " + date);
                if (this.endDateObject != null && date.getTime() > this.endDateObject.getTime()) {
		    if(debug) {
			console.log("    endDate:\n\t" + date.getTime() +"\n\t" + this.endDateObject.getTime());
		    }
                    return false;
                }
            }
            return true;
        },
        getPointData: function() {
            if (this.dataCollection.getList().length == 0) return null;
            return this.dataCollection.getList()[0];
        },
	getRecords: function() {
            let pointData = this.getData();
            if (pointData == null) return null;
            return  pointData.getRecords();
        },
        //get an array of arrays of data 
        getDataValues: function(obj) {
            if (obj.tuple) return obj.tuple;
            else if (obj.getData) return obj.getData();
            return obj;
        },
	indexToRecord: {},
	recordToIndex: {},
	findMatchingDates: function(date, records, within) {
	    if(!Utils.isDefined(within)) within=0;
	    let good = [];
	    let millis = date.getTime();
	    records.forEach(r=>{
		let rd = r.getDate();
		if(!rd) return;
		let diff = Math.abs(rd.getTime()-millis);
		if(diff<=within) {
		    good.push(r);
		}
	    });
	    return good;
	},
	findMatchingIndex: function(record) {
	    if(!record) return {index:-1,record:null};
	    var index = this.recordToIndex[record.getId()];
	    if(Utils.isDefined(index)) {
		return {index:index, record:this.indexToRecord[index]}
	    }
	    if(!record.hasDate()) return -1;
	    let records =this.filteredRecords;
	    if(!records) {
		records = [];
		for(i in this.indexToRecord) {
		    records.push(this.indexToRecord[i]);
		}
	    }
	    var closest;
	    var min  =0;
	    records.forEach(r=>{
		if(!r.hasDate()) {
		    return -1;
		}
		var diff = Math.abs(record.getDate().getTime()-r.getDate().getTime());
		if(!closest) {
		    min = diff;
		    closest = r;
		} else {
		    if(diff<min) {
			min = diff;
			closest = r;
		    }
		}
	    });
	    if(!closest) 
		return {index:-1, record:null}
	    return {index:this.recordToIndex[closest.getId()], record:closest};
	},
        makeDataArray: function(dataList) {
            if (dataList.length == 0) return dataList;
            var data = [];
            if (dataList[0].getData) {
                for (var i = 0; i < dataList.length; i++) {
		    data.push(dataList[i].getData()[0]);
		}
            } else if (dataList[0].tuple) {
                for (var i = 0; i < dataList.length; i++) {
                    data.push(dataList[i].tuple);
		}
            } else {
                data = dataList;
            }
            return data;
        },

        printFields: function(label, fields) {
            console.log(label);
            if (!fields) {
                console.log("   null fields");
                return;
            }

            for (a in fields)
                console.log("   " + fields[a].getId());
        },
	makeIndexValue: function(indexField, value, offset) {
	    return value+offset;
	},
        getStandardData: function(fields, args) {
	    if(!args) args = {};
	    let debug = displayDebug.getStandardData;
	    if(debug) console.log("getStandardData:" + this.type +"  fields:" + fields);
	    let showUnit  = this.getProperty("showUnit",this.getProperty("showUnitInSeries",true));
	    this.recordToIndex = {};
	    this.indexToRecord = {};
            var pointData = this.getPointData();
            var excludeZero = this.getProperty(PROP_EXCLUDE_ZERO, false);
            var excludeNan = this.getProperty(PROP_EXCLUDE_NAN, false);	    
            if (fields == null) {
                fields = pointData.getRecordFields();
		if(debug) console.log("\tgetRecordFields: " + fields.length);
            } else {
		//		if(debug) console.log("\tfields 2: " + fields.length);
	    }
            props = {
                makeObject: true,
                includeIndex: true,
                includeIndexIfDate: false,
                groupByIndex: -1,
                raw: false,
            };
            if (args != null) {
                $.extend(props, args);
            }



            let groupByIndex = props.groupByIndex;
            let groupByList = [];
 	    let groupByValues = {};

	    let groupByRecords = [];
	    let groupByDate = this.getProperty("groupByDate");
	    let groupByFill = this.getProperty("groupByFill");
	    let groupByDateMap = {};
	    let groupByDates = [];

            var dataList = [];
            //The first entry in the dataList is the array of names
            //The first field is the domain, e.g., time or index
            var fieldNames = [];
            var fieldsForTuple = [];	    
	    if(this.getProperty("binDate")) {
		if(debug)
		    console.log("binning date");
		var binType = this.getProperty("binType","total");
		var binCount = binType=="count";
		if(binCount) {
		    var f = [];
		    fields.forEach((field)=>{
			f.push(new RecordField({
			    index:0,
			    id:field.getId(),
			    label:this.getProperty("binDateLabel", this.getProperty("binCountLabel","Count")),
			    type:"double",
			    chartable:true
			}));
		    });
		    fields=f;
		}
	    }

	    let seenDate = false;
	    fields  = fields.filter(f=>{
		if(f.isFieldDate()) {
		    if(seenDate  && f.isRecordDate()) return null;
		    seenDate = true;
		}
		return f;
	    });
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (field.isFieldNumeric() && field.isFieldDate()) {
                    //                        console.log("Skipping:" + field.getLabel());
                    //                        continue;
                }
                var name = field.getLabel();
                if (showUnit && field.getUnit() != null) {
                    name += " (" + field.getUnit() + ")";
                }
                //                    name = name.replace(/!!/g,"<br><hr>&nbsp;&nbsp;&nbsp;")
                name = name.replace(/!!/g, " -- ")
                fieldNames.push(name);
		fieldsForTuple.push(field);
            }
            if (props.makeObject) {
                dataList.push({
                    tuple: fieldNames,
		    fields:fieldsForTuple,
                    record: null
                });
            } else {
                dataList.push(fieldNames);
            }
            //console.log(fieldNames);



            groupByList.push("");
	    groupByRecords.push(null);
	    if(!this.minDateObj) {
		this.minDateObj = Utils.parseDate(this.minDate, false);
		if(debug)
		    console.log("getStandardData setting min date:" + this.minDateObj);
	    }
	    if(!this.minDateObj) {
		this.maxDateObj = Utils.parseDate(this.maxDate, true, this.minDateObj);
		if(debug)
		    console.log("getStandardData setting max date:" + this.maxDateObj);
	    }

            if (this.minDateObj == null && this.maxDateObj != null) {
                this.minDateObj = Utils.parseDate(this.minDate, false, this.maxDateObj);
            }



            let offset = 0;
            if (Utils.isDefined(this.offset)) {
                offset = parseFloat(this.offset);
            }

            let nonNullRecords = 0;
            let records = args.records?args.records:this.filterData();
	    if(debug)
		console.log("getStandardData #fields:" + fields.length +" #records:" + records.length);
            let allFields = pointData.getRecordFields();

            //Check if there are dates and if they are different
            this.hasDate = this.getHasDate(records);
            let date_formatter = null;
            let rowCnt = -1;
            let indexField = this.getFieldById(null,this.getProperty("indexField"));
	    var t1 = new Date();
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let record = records[rowIdx];
                let date = record.getDate();
                if (!this.dateInRange(date)) {
		    continue;
		}
                rowCnt++;
		this.recordToIndex[record.getId()] = rowCnt;
		this.indexToRecord[rowCnt] = record;
                let values = [];


                if (props && (props.includeIndex || props.includeIndexIfDate)) {
                    var indexName = null;
                    if (indexField) {
			let value = this.makeIndexValue(indexField,record.getValue(indexField.getIndex()),rowIdx);
                        values.push(value);
                        indexName = indexField.getLabel();
                    } else {
                        if (this.hasDate) {
			    let dttm = this.getDateValue(date, date_formatter);
                            values.push(dttm);
                            indexName = "Date";
                        } else {
                            if (!props.includeIndexIfDate) {
                                values.push(rowIdx);
				indexName = this.getProperty("indexName", "Index");
                            }
                        }
                    }
                    if (indexName != null && rowCnt == 0) {
                        fieldNames.unshift(indexName);
                    }
                }

                let allNull = true;
                let allZero = true;
                let hasNumber = false;
		let hasNan = false;
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    if (field.isFieldNumeric() && field.isFieldDate()) {
                        //                            continue;
                    }
                    var value = record.getValue(field.getIndex());
                    if (offset != 0) {
                        value += offset;
                    }

		    //		    if(debug&& rowIdx<10)
		    //			console.log("   v:"+ value);
                    if (value != null) {
                        allNull = false;
                    }
                    if (typeof value == 'number') {
			if(excludeNan &&  isNaN(value))  {
			    hasNan=true;
			}
                        hasNumber = true;
                        if (value != 0) {
                            allZero = false;
                        }
                    }
                    if (field.isFieldDate()) {
                        value = this.getDateValue(value, date_formatter);
                    }
                    values.push(value);
		}


		if(hasNan) {
		    continue;
		}
                if (hasNumber && allZero && excludeZero) {
		    //		    console.log(" skipping due to zero: " + values);
                    continue;
                }
                //TODO: when its all null values we get some errors
                if (groupByIndex >= 0) {
		    var value = record.getValue(groupByIndex);
		    if(!groupByValues[value]) groupByValues[value] = true;
		    if(groupByDate)
			groupByList.push(record.getDate() +"-"+value);
		    else
			groupByList.push(value);
		    groupByRecords.push(record);
                }
                if (props.makeObject)
                    dataList.push({
                        tuple: values,
                        record: record
                    });
                else
                    dataList.push(values);
                if (!allNull) {
                    nonNullRecords++;
                }
	    }

	    var t2= new Date();
//	    console.log("#records:" + records.length);
//	    Utils.displayTimes("chart.standardData loop:",[t1,t2], true);
            if (nonNullRecords == 0) {
		//		console.log("Num non null:" + nonNullRecords);
		console.log("no nonNull records");
		return [];
            }

            if (groupByIndex >= 0) {
                var groupToTuple = {};
                var groups = [];
                var agg = [];
                var title = [];
		let groupByCount = this.getProperty("groupByCount");
                title.push(props.groupByField.getLabel());
		if(groupByCount) {
		    title.push(this.getProperty("groupByCountLabel", "Count"));
		} else {
                    for (var fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
			var field = fields[fieldIdx];
			if (field.getIndex() != groupByIndex) {
                            title.push(field.getLabel());
			}
                    }
		}
		//                agg.push(title);
		let groupByValueTuples = {};
                for (var rowIdx = 0; rowIdx < dataList.length; rowIdx++) {
                    var data = this.getDataValues(dataList[rowIdx]);
                    if (rowIdx == 0) {
                        continue;
                    }
                    var groupBy = groupByList[rowIdx];
		    var record = groupByRecords[rowIdx];
		    var groupByValue = record.getValue(groupByIndex);
                    var tuple = groupToTuple[groupBy];
                    if (tuple == null) {
                        tuple = new Array();
                        groups.push(groupBy);
			if(groupByDate) {
			    let dateList = groupByDateMap[record.getDate()];
			    if(dateList == null) {
				groupByDateMap[record.getDate()] = dateList = [];
				groupByDates.push(record.getDate());
			    }
			    dateList.push(tuple);
			}
			if(!groupByValueTuples[groupByValue]) groupByValueTuples[groupByValue] = [];
			groupByValueTuples[groupByValue].push(tuple)
			tuple.record = record;
                        agg.push(tuple);
                        tuple.push(groupByValue);
			if(groupByCount) {
			    tuple.push(0);
			} else {
                            for (var fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
				var field = fields[fieldIdx];
				if (field.getIndex() == groupByIndex) {
                                    continue;
				}
				tuple.push(0);
                            }
			}
                        groupToTuple[groupBy] = tuple;
                    }
                    var index = 0;
		    if(groupByCount) {
			tuple[1]++;
			continue;
		    }
                    for (var fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                        var field = fields[fieldIdx];
                        if (field.getIndex() == groupByIndex) {
                            continue;
                        }
                        var dataValue = data[fieldIdx];
                        index++;
                        if (Utils.isNumber(dataValue)) {
                            if (typeof tuple[index] == "string") {
                                tuple[index] = 0;
                            }
                            tuple[index] += parseFloat(dataValue);
                        } else {
                            if (tuple[index] == 0) {
                                tuple[index] = "";
                            }
                            var s = tuple[index];
                            if (!Utils.isDefined(s)) {
                                s = "";
                            }
                            //Only concat string values for a bit
                            if (s.length < 150) {
                                if (!Utils.isDefined(dataValue)) {
                                    dataValue = "";
                                }
                                var sv = ("" + dataValue);
                                if (s.indexOf(sv) < 0) {
                                    if (s != "") {
                                        s += ", ";
                                    }
                                    s += sv;
                                    tuple[index] = s;
                                }
                            }

                        }
                    }
		}

		if(groupByFill) {
		    groupByDates.forEach(date=>{
			let dateList = groupByDateMap[date];
			let seen = {};
			dateList.forEach(tuple =>{
			    seen[tuple[0]] = true;
			});
			for(v in groupByValues) {
			    if(!seen[v]) {
				seen[v] = true;
				let tuple = [v,0];
				tuple.date = date;
				agg.push(tuple);
			    }
			}
		    });
		}

		if(this.getProperty("groupBySort")) {
		    agg.sort(function(a,b) {return b[1]-a[1]});
		}
		if(this.getProperty("groupByMaxNumber")) {
		    let cnt = +this.getProperty("groupByMaxNumber");
		    agg = agg.filter((t,idx)=>{
			return idx<cnt;
			
		    });

		}
		let tmp = [];
		tmp.push(title);
		agg.forEach(t=>tmp.push(t));
                return tmp;
            }

	    //	    console.log("display.getStandardData returning "+ dataList.length);
	    if(this.getProperty("movingAverageSteps")) {
		let steps = +this.getProperty("movingAverageSteps");
		let tmp = [dataList[i]];
		let isNumeric = dataList[1].tuple.map((v,idx)=>{return Utils.isNumber(v);});
		dataList.forEach((o,rowIdx)=>{
		    if(rowIdx==0) return;
		    let tuple = Utils.mergeLists(o.tuple);
		    tmp.push({
			record:o.record,
			tuple:tuple});
		    tuple[0] = "x"; tuple[1] = 5;
		    tuple.forEach((v,colIdx)=>{
			if(!isNumeric[colIdx]) return;
			tuple[colIdx]=5;
		    });
		});
		dataList = tmp;
	    }
            return dataList;
        },
        isGoogleLoaded: function() {
            if ((typeof google === 'undefined') || (typeof google.visualization === 'undefined') || (typeof google.visualization.DateFormat === 'undefined')) {
                return false;
            }
            return true;
        },
        initDateFormats: function() {
            if (!this.isGoogleLoaded()) {
                //                    console.log("google hasn't loaded");
                return false;
            }
            if (this.fmt_yyyy) return true;
            var tz = 0;
            this.timezone = this.getProperty("timezone");
            if (Utils.isDefined(this.timezone)) {
                tz = parseFloat(this.timezone);
            }
            this.fmt_yyyymmddhhmm = new google.visualization.DateFormat({
                pattern: "yyyy-MM-dd HH:mm Z",
                timeZone: tz
            });
            this.fmt_yyyymmdd = new google.visualization.DateFormat({
                pattern: "yyyy-MM-dd",
                timeZone: tz
            });
            this.fmt_yyyy = new google.visualization.DateFormat({
                pattern: "yyyy",
                timeZone: tz
            });
            return true;
        },
        getDateValue: function(arg) {
            if (!this.initDateFormats()) {
                return arg;
            }
            if (!(typeof arg == "object")) {
                date = new Date(arg);
            } else {
                date = arg;
            }
	    if(isNaN(date.getUTCFullYear())) return {v:date,f:"NA"};
	    if(this.getProperty("dateFormatDaysAgo",false)) {
		let now = new Date();
		let diff = Math.round((now.getTime()-date.getTime())/1000/60/60/24);
		return {v:date,f:diff+" days ago"};
	    }

            return  {
                v: date,
                f: this.formatDate(date)
            };
        },
        applyFilters: function(record, values) {
            for (var i = 0; i < this.filters.length; i++) {
                if (!this.filters[i].isRecordOk(record)) {
                    return false;
                }
            }
            return true;
        }
    });

    var filter = this.getProperty(PROP_DISPLAY_FILTER);
    if (filter != null) {
        //semi-colon delimited list of filter definitions
        //display.filter="filtertype:params;filtertype:params;
        //display.filter="month:0-11;
        var filters = filter.split(";");
        for (var i = 0; i < filters.length; i++) {
            filter = filters[i];
            var toks = filter.split(":");
            var type = toks[0];
            if (type == "month") {
                this.filters.push(new MonthFilter(toks[1]));
            } else {
                console.log("unknown filter:" + type);
            }
        }
    }
}




function DisplayGroup(argDisplayManager, argId, argProperties, type) {
    const LAYOUT_TABLE = "table";
    const LAYOUT_HTABLE = "htable";
    const LAYOUT_TABS = "tabs";
    const LAYOUT_COLUMNS = "columns";
    const LAYOUT_ROWS = "rows";
    const SUPER = new RamaddaDisplay(argDisplayManager, argId, type||"group", argProperties);
    RamaddaUtil.inherit(this, SUPER);
    RamaddaUtil.defineMembers(this, {
        displays: [],
        layout: this.getProperty(PROP_LAYOUT_TYPE, LAYOUT_TABLE),
        columns: this.getProperty(PROP_LAYOUT_COLUMNS, 1),
        isLayoutColumns: function() {
            return this.layout == LAYOUT_COLUMNS;
        },
        getWikiText: function() {
            var attrs = ["layoutType", this.layout,
			 "layoutColumns",
			 this.columns,
			 "showMenu",
			 "false",
			 "groupDiv",			 
			 "$entryid_maindiv"
			];
            let wiki = "";
            wiki += "<div id=\"{{entryid}}_maindiv\"></div>\n";
            wiki += "{{group " + HU.attrs(attrs) + "}}\n"
            return wiki;
        },

        walkTree: function(func, data) {
            for (var i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.walkTree != null) {
                    display.walkTree(func, data);
                } else {
                    func.call(data, display);
                }
            }
        },
        collectEntries: function(entries) {
            if (entries == null) entries = [];
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.collectEntries != null) {
                    display.collectEntries(entries);
                } else {
                    let displayEntries = display.getEntries();
                    if (displayEntries != null && displayEntries.length > 0) {
                        entries.push({
                            source: display,
                            entries: displayEntries
                        });
                    }
                }
            }
            return entries;
        },
        isLayoutRows: function() {
            return this.layout == LAYOUT_ROWS;
        },

        getPosition: function() {
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display.getPosition) {
                    return display.getPosition();
                }
            }
        },
        getDisplays: function() {
            return this.displays;
        },
        notifyEvent: function(func, source, data) {
            let displays = this.getDisplays();
            for (let i = 0; i < this.displays.length; i++) {
                let display = this.displays[i];
                if (display == source) {
                    continue;
                }
		if(!display.getProperty("accept." + func, true)) continue;
                let eventSource = display.getEventSource();
                if (eventSource != null && eventSource.length > 0) {
                    if (eventSource != source.getId() && eventSource != source.getName()) {
                        continue;
                    }
                }
                display.notifyEvent(func, source, data);
            }
        },
        getDisplaysToLayout: function() {
            let result = [];
            for (let i = 0; i < this.displays.length; i++) {
                if (this.displays[i].getIsLayoutFixed()) {
		    continue;
		}
                result.push(this.displays[i]);
            }
            return result;
        },
        pageHasLoaded: function(display) {
	    //Maybe we don't need to do this since the displays get called globally
	    //            for (let i = 0; i < this.displays.length; i++) {
	    //                this.displays[i].setDisplayReady(true);
	    //            }
            this.doLayout();
        },
        addDisplay: function(display) {
            this.displays.push(display);
            if (display.getIsLayoutFixed()) {
		display.initDisplay();
	    } else {
		if (Utils.getPageLoaded()) {
                    this.doLayout();
		}
	    }
        },
        layoutChanged: function(display) {
            this.doLayout();
        },
        removeDisplay: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= 0) {
                this.displays.splice(index, 1);
            }
            this.doLayout();
        },
        doLayout: function() {
	    let html = "";
            let colCnt = 100;
            let displaysToLayout = this.getDisplaysToLayout();
            let displaysToPrepare = this.displays;
	    displaysToPrepare.forEach(display=>{
                if (display.prepareToLayout != null) {
                    display.prepareToLayout();
                }
            });

            let weightIdx = 0;
            let weights = null;
            if (typeof this.weights != "undefined") {
                weights = this.weights.split(",");
            }

            for (let i=0; i < displaysToLayout.length; i++) {
                let divId = HU.getUniqueId("divid_");
                let div =  HU.div([CLASS, " display-wrapper",ID,divId],"");
                displaysToLayout[i].setProperty(PROP_DIVID,divId);
                displaysToLayout[i].layoutDiv=div;
            }
            let tabId = HU.getUniqueId("tabs_");
            if (this.layout == LAYOUT_TABLE) {
                if  (displaysToLayout.length== 1) {
                    html += displaysToLayout[0].layoutDiv;
                } else {
                    let weight = 12 / this.columns;
                    let i = 0;
                    let map = {};
                    for (; i < displaysToLayout.length; i++) {
                        let d = displaysToLayout[i];
                        if (Utils.isDefined(d.column) && Utils.isDefined(d.row) && d.columns >= 0 && d.row >= 0) {
                            let key = d.column + "_" + d.row;
                            if (map[key] == null) map[key] = [];
                            map[key].push(d);
                        }
                    }

                    i = 0;
                    for (; i < displaysToLayout.length; i++) {
                        colCnt++;
                        if (colCnt >= this.columns) {
                            if (i > 0) {
                                html += HU.close(TAG_DIV);
                            }
                            html += HU.open("div", [CLASS, "row"]);
                            colCnt = 0;
                        }
                        let weightToUse = weight;
                        if (weights != null) {
                            if (weightIdx >= weights.length) {
                                weightIdx = 0;
                            }
                            weightToUse = weights[weightIdx];
                            weightIdx++;
                        }
                        html += HU.div([CLASS, "col-md-" + weightToUse + " display-wrapper display-cell"], displaysToLayout[i].layoutDiv);
			html+="\n";
		    }

                    if (i > 0) {
                        html += HU.close(TAG_DIV);
                    }
                }
	    } else if (this.layout == LAYOUT_HTABLE) {
                if  (displaysToLayout.length== 1) {
                    html += displaysToLayout[0].layoutDiv;
                } else {
                    let percent = Math.round((100 / this.columns))+"%";
                    let i = 0;
		    html+=HU.open(TABLE,[WIDTH,'100%']);
		    let colCnt = 100;
                    for (let i =0;i < displaysToLayout.length; i++) {
                        colCnt++;
                        if (colCnt >= this.columns) {
                            if (i > 0) {
                                html += HU.close(TAG_TR);
                            }
                            html += HU.open("tr", ["valign", "top"]);
			    html+="\n";
                            colCnt = 0; 
                        }
                        html += HU.td(["width",percent], displaysToLayout[i].layoutDiv);
			html+="\n";
		    }
                    if (i > 0) {
                        html += HU.close(TAG_TR);
                    }
                }
            } else if (this.layout == LAYOUT_TABS) {
                html += HU.open(TAG_DIV, [ID, tabId, CLASS, "ui-tabs"]);
                html += HU.open(TAG_UL, []);
                let hidden = "";
                let cnt = 0;
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let label = display.getTitle(false);
                    if (label.length > 20) {
                        label = label.substring(0, 19) + "...";
                    }
                    html += HU.tag(TAG_LI, [], HU.tag(TAG_A, ["href", "#" + tabId + "-" + cnt], label));
                    hidden += HU.div([ID, tabId + "-" + cnt, CLASS, "ui-tabs-hide"], display.layoutDiv);
                    cnt++;
                }
                html += HU.close(TAG_UL);
                html += hidden;
                html += HU.close(TAG_DIV);
            } else if (this.layout == LAYOUT_ROWS) {
                let rows = [];
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let row = display.getRow();
                    if (("" + row).length == 0) row = 0;
                    while (rows.length <= row) {
                        rows.push([]);
                    }
                    rows[row].push(display.layoutDiv);
                }
                for (let i = 0; i < rows.length; i++) {
                    let cols = rows[i];
                    let width = Math.round(100 / cols.length) + "%";
                    html += HU.open(TAG_TABLE, ["border", "0", "width", "100%", "cellpadding", "0", "cellspacing", "0"]);
                    html += HU.open(TAG_TR, ["valign", "top"]);
                    for (let col = 0; col < cols.length; col++) {
                        let cell = cols[col];
                        cell = HU.div([CLASS, "display-cell"], cell);
                        html += HU.tag(TAG_TD, ["width", width], cell);
                    }
                    html += HU.close(TAG_TR);
                    html += HU.close(TAG_TABLE);
                }
            } else if (this.layout == LAYOUT_COLUMNS) {
                let cols = [];
                for (let i = 0; i < displaysToLayout.length; i++) {
                    let display = displaysToLayout[i];
                    let column = display.getColumn();
                    //                        console.log("COL:" + column);
                    if (("" + column).length == 0) column = 0;
                    while (cols.length <= column) {
                        cols.push([]);
                    }
                    cols[column].push(display.layoutDiv);
                    //                        cols[column].push("HTML");
                }
                html += HU.open(TAG_DIV, [CLASS, "row"]);
                let width = Math.round(100 / cols.length) + "%";
                let weight = 12 / cols.length;
                for (let i = 0; i < cols.length; i++) {
                    let rows = cols[i];
                    let contents = "";
                    for (let j = 0; j < rows.length; j++) {
                        contents += rows[j];
                    }
                    let weightToUse = weight;
                    if (weights != null) {
                        if (weightIdx >= weights.length) {
                            weightIdx = 0;
                        }
                        weightToUse = weights[weightIdx];
                        weightIdx++;
                    }
                    html += HU.div([CLASS, "col-md-" + weightToUse], contents);
                }
                html += HU.close(TAG_DIV);
            } else {
                html += "Unknown layout:" + this.layout;
            }

	    //If we don't  have any displays to show then hide us
	    if(!this.getShowMenu() && displaysToLayout.length==0) {
		//TODO: This hides the change entry group menu 
//		$("#" + this.getId()).hide();
	    } else {
		$("#" + this.getId()).show();
	    }
	    let div = this.getGroupDiv();
	    if(div.length>0) {
		div.html(html);
	    } else {
		this.writeHtml(ID_DISPLAYS, html);
	    }
            if (this.layout == LAYOUT_TABS) {
                $("#" + tabId).tabs({activate: HtmlUtil.tabLoaded});
            }
            this.initDisplays();
        }, 
	initDisplays: function() {
	    this.getDisplaysToLayout().forEach(display=>{
		try {
                    display.initDisplay();
		} catch (e) {
                    display.displayError("Error creating display:<br>" + e);
                    console.log("error creating display: " + display.type);
                    console.log(e.stack)
		}
            });
	},
        displayData: function() {},
        setLayout: function(layout, columns) {
            this.layout = layout;
            if (columns) {
                this.columns = columns;
            }
            this.doLayout();
        },
        askMinZAxis: function() {
            let v = prompt("Minimum axis value", "0");
            if (v != null) {
                v = parseFloat(v);
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMinZAxis) {
                        display.setMinZAxis(v);
                    }
                }
            }
        },

        askMaxZAxis: function() {
            let v = prompt("Maximum axis value", "0");
            if (v != null) {
                v = parseFloat(v);
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMaxZAxis) {
                        display.setMaxZAxis(v);
                    }
                }
            }
        },

        askMinDate: function() {
            let d = this.minDate;
            if (!d) d = "1950-0-0";
            this.minDate = prompt("Minimum date", d);
            if (this.minDate != null) {
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMinDate) {
                        display.setMinDate(this.minDate);
                    }
                }
            }
        },

        askMaxDate: function() {
            let d = this.maxDate;
            if (!d) d = "2020-0-0";
            this.maxDate = prompt("Maximum date", d);
            if (this.maxDate != null) {
                for (let i = 0; i < this.displays.length; i++) {
                    let display = this.displays[i];
                    if (display.setMaxDate) {
                        display.setMaxDate(this.maxDate);
                    }
                }
            }
        },


        titlesOff: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowTitle(false);
            }
        },
        titlesOn: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowTitle(true);
            }
        },
        detailsOff: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowDetails(false);
            }
            this.doLayout();
        },
        detailsOn: function() {
            for (let i = 0; i < this.displays.length; i++) {
                this.displays[i].setShowDetails(true);
            }
            this.doLayout();
        },

        deleteAllDisplays: function() {
            this.displays = [];
            this.doLayout();
        },
        moveDisplayUp: function(display) {
            let index = this.displays.indexOf(display);
            if (index <= 0) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(index - 1, 0, display);
            this.doLayout();
        },
        moveDisplayDown: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= this.displays.length) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(index + 1, 0, display);
            this.doLayout();
        },

        moveDisplayTop: function(display) {
            let index = this.displays.indexOf(display);
            if (index >= this.displays.length) {
                return;
            }
            this.displays.splice(index, 1);
            this.displays.splice(0, 0, display);
            this.doLayout();
        },


    });

}



/*
 */
function RamaddaFieldsDisplay(displayManager, id, type, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    defineDisplay(this, SUPER, [], {
        needsData: function() {
            return true;
        },
        initDisplay: function() {
            SUPER.initDisplay.call(this);
            if (this.needsData()) {
		if(this.useDisplayMessage()) {
                    this.setDisplayMessage(this.getLoadingMessage());
		} else {
                    this.setContents(this.getLoadingMessage());
		}
            }
            this.callUpdateUI();
        },
        updateUI: function(args) {
            this.addFieldsCheckboxes();
        },
        getWikiAttributes: function(attrs) {
            SUPER.getWikiAttributes.call(this, attrs);
            if (this.lastSelectedFields) {
                attrs.push(PROP_FIELDS);
                var v = "";
                for (var i = 0; i < this.lastSelectedFields.length; i++) {
                    v += this.lastSelectedFields[i].getId();
                    v += ",";
                }
                attrs.push(v);
            }
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            this.addFieldsCheckboxes();
        },
        getDialogContents: function(tabTitles, tabContents) {
            var height = "600";
//            var html = HU.div([ATTR_ID, this.getDomId(ID_FIELDS), STYLE, HU.css("overflow-y","auto","max-height", height + "px")], "");
//            tabTitles.push("Fields");
//            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },
        handleEventFieldsSelected: function(source, fields) {
	    if(fields.length>0 && (typeof fields[0] =="string")) {
		var tmp = [];
		fields.forEach(f=>{
		    f = this.getFieldById(null, f);
		    if(f) tmp.push(f);
		});
		fields=tmp;
	    }
            this.userHasSelectedAField = true;
            this.overrideFields = null;
            this.removeProperty(PROP_FIELDS);
            this.setSelectedFields(fields);
            this.fieldSelectionChanged();
        },
        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        canDoMultiFields: function() {
            return true;
        }
    })
}

/**
   Copyright 2008-2019 Geode Systems LLC
*/


//Properties
const PROP_LAYOUT_TYPE = "layoutType";
const PROP_LAYOUT_COLUMNS = "layoutColumns";
const PROP_SHOW_MAP = "showMap";
const PROP_SHOW_MENU = "showMenu";
const PROP_FROMDATE = "fromDate";
const PROP_TODATE = "toDate";
const DISPLAY_MULTI = "multi";



//
//adds the display manager to the list of global display managers
//
function addDisplayManager(displayManager) {
    if (window.globalDisplayManagers == null) {
        window.globalDisplayManagers = {};
        // window.globalDisplayManager = null;
    }
    window.globalDisplayManagers[displayManager.getId()] = displayManager;
    window.globalDisplayManager = displayManager;
}




addGlobalDisplayType({
    type: DISPLAY_MULTI,
    label: "Multi Chart",
    requiresData: true,
    forUser: false,
    category: "Misc"
});





//
//This will get the currently created global displaymanager or will create a new one
//
function getOrCreateDisplayManager(id, properties, force) {
    if (!force) {
        var displayManager = getDisplayManager(id);
        if (displayManager != null) {
            return displayManager;
        }
        if (window.globalDisplayManager != null) {
            return window.globalDisplayManager;
        }
    }
    var displayManager = new DisplayManager(id, properties);
    if (window.globalDisplayManager == null) {
        window.globalDisplayManager = displayManager;
    }
    return displayManager;
}

//
//return the global display manager with the given id, null if not found
//
function getDisplayManager(id) {
    if (window.globalDisplayManagers == null) {
        return null;
    }
    var manager = window.globalDisplayManagers[id];
    return manager;
}



var ID_DISPLAYS = "displays";

//
//DisplayManager constructor
//

function DisplayManager(argId, argProperties) {

    var ID_MENU_BUTTON = "menu_button";
    var ID_MENU_CONTAINER = "menu_container";
    var ID_MENU_OUTER = "menu_outer";
    var ID_MENU_INNER = "menu_inner";


    RamaddaUtil.inherit(this, this.SUPER = new DisplayThing(argId, argProperties));
    addRamaddaDisplay(this);

    RamaddaUtil.initMembers(this, {
        dataList: [],
        displayTypes: [],
        initMapBounds: null,
    });


    RamaddaUtil.defineMembers(this, {
        group: new DisplayGroup(this, argId, argProperties),
        showmap: this.getProperty(PROP_SHOW_MAP, null),
        setDisplayReady: function() {
            SUPER.setDisplayReadyCall(this);
            this.getLayoutManager().setDisplayReady();
        },
        getLayoutManager: function() {
            return this.group;
        },
        collectEntries: function() {
            var entries = this.getLayoutManager().collectEntries();
            return entries;
        },
        getData: function() {
            return this.dataList;
        },
        handleEventFieldValueSelect: function(source, args) {
            this.notifyEvent("handleEventFieldValueSelected", source, args);
        },
        handleEventFieldsSelected: function(source, fields) {
            this.notifyEvent("handleEventFieldsSelected", source, fields);
        },
        handleEventPropertyChanged: function(source, prop) {
            this.notifyEvent("handleEventPropertyChanged", source, prop);
        },
        handleEventEntriesChanged: function(source, entries) {
            this.notifyEvent("handleEventEntriesChanged", source, entries);
        },
        handleEventMapBoundsChanged: function(source, bounds, forceSet) {
            var args = {
                "bounds": bounds,
                "force": forceSet
            };
            this.notifyEvent("handleEventMapBoundsChanged", source, args);
        },
        addMapLayer: function(source, entry) {
            this.notifyEvent("addMapLayer", source, {
                entry: entry
            });
        },
        propagateEventRecordSelection: function(source, pointData, args) {
            var index = args.index;
            if (pointData == null && this.dataList.length > 0) {
                pointData = this.dataList[0];
            }
            var fields = pointData.getRecordFields();
            var records = pointData.getRecords();
            if (records == null) {
                return;
            }
            if (index < 0 || index >= records.length) {
                console.log("propagateEventRecordSelection: bad index= " + index);
                return;
            }
            var record = records[index];
            if (record == null) return;
            var values = source?source.getRecordHtml(record, fields):"";
            if (source.recordSelectionCallback) {
                var func = source.recordSelectionCallback;
                if ((typeof func) == "string") {
                    func = window[func];
                }
                func({
                    display: source,
                    pointData: pointData,
                    index: index,
                    pointRecord: record
                });
            }
            var params = {
                index: index,
                record: record,
                html: values,
                data: pointData
            };
            this.notifyEvent("handleEventRecordSelection", source, params);
            var entries = source.getEntries();
            if (entries != null && entries.length > 0) {
                this.handleEventEntrySelection(source, {
                    entry: entries[0],
                    selected: true
                });
            }
        },
        handleEventEntrySelection: function(source, props) {
            this.notifyEvent("handleEventEntrySelection", source, props);
        },
        handleEventEntryMouseover: function(source, props) {
            this.notifyEvent("handleEventEntryMouseover", source, props);
        },
        handleEventEntryMouseout: function(source, props) {
            this.notifyEvent("handleEventEntryMouseout", source, props);
        },
        handleEventPointDataLoaded: function(source, pointData) {
            this.notifyEvent("handleEventPointDataLoaded", source, pointData);
        },
        ranges: {
            //               "TRF": [0,100],
        },
        setRange: function(field, range) {
            if (this.ranges[field.getId()] == null) {
                this.ranges[field.getId()] = range;
            }
        },
        getRange: function(field) {
            return this.ranges[field.getId()];
        },
        makeMainMenu: function() {
	    if(!this.getShowMenu()) {
		return "";
	    }
            //How else do I refer to this object in the html that I add 
            var get = "getDisplayManager('" + this.getId() + "')";
            var layout = "getDisplayManager('" + this.getId() + "').getLayoutManager()";
            var html = "";

            var newMenus = {};
            var cats = [];
            var displayTypes = [];
            if (window.globalDisplayTypes != null) {
                displayTypes = window.globalDisplayTypes;
            }
	    DISPLAY_CATEGORIES.forEach(category=>{
                newMenus[category] = [];
                cats.push(category);
	    });
            for (var i = 0; i < displayTypes.length; i++) {
                //The ids (.e.g., 'linechart' have to match up with some class function with the name 
                var type = displayTypes[i];
                if (Utils.isDefined(type.forUser) && !type.forUser) {
                    continue;
                }
		var category = type.category;
                if (!category) {
                    category = CATEGORY_MISC;
                }
                if (newMenus[category] == null) {
                    newMenus[category] = [];
                    cats.push(category);
                }
		let menuAttrs = ["onclick", get + ".userCreateDisplay('" + type.type + "');"];
		if(type.desc) {
		    menuAttrs.push(TITLE);
		    menuAttrs.push(type.desc);
		}
                newMenus[category].push(HU.tag(TAG_LI, [], HU.tag(TAG_A, menuAttrs, type.label)));
            }
            let newMenu = "";
            for (var i = 0; i < cats.length; i++) {
                var cat = cats[i];
		var menu = Utils.join(newMenus[cat],"");
                var subMenu = HU.tag("ul", [], menu);
                var catLabel = HU.tag(TAG_A, [], cat);
                newMenu += HU.tag(TAG_LI, [], catLabel + subMenu);
            }


            var publishMenu =
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('media_photoalbum');", "New Photo Album")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('wikipage');", "New Wiki Page")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".publish('blogentry');", "New Blog Post")) + "\n";


            var fileMenu =
                HU.tag(TAG_LI, [], "<a>Publish</a>" + HU.tag("ul", [], publishMenu)) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".showWikiText();", "Show Text")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".copyWikiText();", "Copy Text")) + "\n" +		
                HU.tag(TAG_LI, [], HU.onClick(layout + ".copyDisplayedEntries();", "Save entries")) + "\n";


            var titles = HU.tag(TAG_DIV, ["class", "ramadda-menu-block"], "Titles: " + HU.onClick(layout + ".titlesOn();", "On") + "/" + HU.onClick(layout + ".titlesOff();", "Off"));
            var dates = HU.tag(TAG_DIV, ["class", "ramadda-menu-block"],
				      "Set date range: " +
				      HU.onClick(layout + ".askMinDate();", "Min") + "/" +
				      HU.onClick(layout + ".askMaxDate();", "Max"));
            var editMenu =
                HU.tag(TAG_LI, [], HU.tag(TAG_DIV, ["class", "ramadda-menu-block"],
							"Set axis range :" +
							HU.onClick(layout + ".askMinZAxis();", "Min") + "/" +
							HU.onClick(layout + ".askMaxZAxis();", "Max"))) +
                HU.tag(TAG_LI, [], dates) +
                HU.tag(TAG_LI, [], titles) + "\n" +
                HU.tag(TAG_LI, [], HU.tag(TAG_DIV, ["class", "ramadda-menu-block"], "Details: " + HU.onClick(layout + ".detailsOn();", "On", []) + "/" +
							HU.onClick(layout + ".detailsOff();", "Off", []))) +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".deleteAllDisplays();", "Delete all displays")) + "\n" +
                "";


            var table = HU.tag(TAG_DIV, ["class", "ramadda-menu-block"], "Table: " +
				      HU.onClick(layout + ".setLayout('table',1);", "1 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',2);", "2 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',3);", "3 column") + " / " +
				      HU.onClick(layout + ".setLayout('table',4);", "4 column"));
            var layoutMenu =
                HU.tag(TAG_LI, [], table) +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('rows');", "Rows")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('columns');", "Columns")) + "\n" +
                HU.tag(TAG_LI, [], HU.onClick(layout + ".setLayout('tabs');", "Tabs"));


            var menuBar = HU.tag(TAG_LI, [], "<a>File</a>" + HU.tag("ul", [], fileMenu));
            menuBar += HU.tag(TAG_LI, [], "<a>Edit</a>" + HU.tag("ul", [], editMenu)) +
                HU.tag(TAG_LI, [], "<a>New</a>" + HU.tag("ul", [], newMenu)) +
                HU.tag(TAG_LI, [], "<a>Layout</a>" + HU.tag("ul", [], layoutMenu));


            var menu = HU.div([STYLE,"background:#fff;z-index:1000;", ATTR_CLASS, "xramadda-popup", ATTR_ID, this.getDomId(ID_MENU_OUTER)],
			      HU.tag("ul", [ATTR_ID, this.getDomId(ID_MENU_INNER), ATTR_CLASS, "sf-menu"], menuBar));

            html += menu;
            //                html += HU.tag(TAG_A, [ATTR_CLASS, "display-menu-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)],"&nbsp;");
            //                html+="<br>";
            return html;
        },
        hasGeoMacro: function(jsonUrl) {
	    if(!jsonUrl) return false;
            return jsonUrl.match(/(\${latitude})/g) != null;
        },
        getJsonUrl: function(jsonUrl, display, props) {
	    display.getRequestMacros().forEach(m=>{
		jsonUrl = m.apply(jsonUrl);
	    });
	    if(display.getAnimationEnabled()) {
		//Not now. Once was needed for gridded data
		//jsonUrl +='&doAnimation=true'
	    }
	    if(display.getProperty('dbSelect')) {
		jsonUrl +="&" + "dbSelect" +"=" +display.getProperty("select");
	    }
	    if(display.getProperty("requestArgs")) {
		let args = display.getProperty("requestArgs").split(",");
		for(let i=0;i<args.length;i+=2) {
		    jsonUrl +="&" + args[i] +"=" + args[i+1];
		}
	    }

	    if(display.pageSkip) {
		jsonUrl+="&skip=" + display.pageSkip;
	    }


            var fromDate = display.getProperty(PROP_FROMDATE);
            if (fromDate != null) {
                jsonUrl += "&fromdate=" + fromDate;
            }
            var toDate = display.getProperty(PROP_TODATE);
            if (toDate != null) {
                jsonUrl += "&todate=" + toDate;
            }

            if (this.hasGeoMacro(jsonUrl)) {
                var lon = props.lon;
                var lat = props.lat;

                if ((lon == null || lat == null) && this.map != null) {
                    var tuple = this.getPosition();
                    if (tuple != null) {
                        lat = tuple[0];
                        lon = tuple[1];
                    }
                }
                if (lon != null && lat != null) {
                    jsonUrl = jsonUrl.replace("${latitude}", lat.toString());
                    jsonUrl = jsonUrl.replace("${longitude}", lon.toString());
                }
            }
            jsonUrl = jsonUrl.replace("${numpoints}", 1000);
            return jsonUrl;
        },
        getDefaultData: function() {
            for (var i in this.dataList) {
                var data = this.dataList[i];
                var records = data.getRecords();
                if (records != null) {
                    return data;
                }
            }
            if (this.dataList.length > 0) {
                return this.dataList[0];
            }
            return null;
        },

        writeDisplay: function() {
            if (this.originalLocation == null) {
                this.originalLocation = document.location;
            }
            var url = this.originalLocation + "#";
            url += "&display0=linechart";
            for (var attr in document) {
                //                   if(attr.toString().contains("location")) 
                //                       console.log(attr +"=" + document[attr]);
            }
            document.location = url;

        },
        userCreateDisplay: function(type, props) {
            if (props == null) {
                props = {};
            }
            props.editMode = true;
            props.layoutHere = false;
            if (type == DISPLAY_LABEL && props.text == null) {
                var text = prompt("Text");
                if (text == null) return;
                props.text = text;
            }
            return this.createDisplay(type, props);
        },
        createDisplay: function(type, props) {

            if (props == null) {
                props = {};
            }

            if (props.data != null) {
		props.theData = props.data;
		props.data = null;
	    }

            if (props.theData != null) {
                var haveItAlready = false;
                for (var i = 0; i < this.dataList.length; i++) {
                    var existingData = this.dataList[i];
                    if (existingData.equals(props.theData)) {
                        props.theData = existingData;
                        haveItAlready = true;
                        break;
                    }
                }
                if (!haveItAlready) {
                    this.dataList.push(props.theData);
                }
                //                console.log("data:" + haveItAlready);
            }

	    if(type==null || type.trim().length==0) return null;
            //            console.log("props:" + JSON.stringify(props));
            //Upper case the type name, e.g., linechart->Linechart
            var proc = type.substring(0, 1).toUpperCase() + type.substring(1);


            //Look for global functions  Ramadda<Type>Display, <Type>Display, <Type> 
            //e.g. - RamaddaLinechartDisplay, LinechartDisplay, Linechart 
            var classname = null;
            var names = ["Ramadda" + proc + "Display",
			 proc + "Display",
			 "Display"+ proc,
			 proc
			];
            var func = null;
            var funcName = null;
            var msg = "";
            for (var i = 0; i < names.length; i++) {
                msg += ("trying:" + names[i] + "\n");
                if (window[names[i]] != null) {
                    funcName = names[i];
                    func = window[names[i]];
                    break;
                }

            }

            if (func == null) {
                console.log("Error: could not find display function:" + type);
                //                    alert("Error: could not find display function:" + type);
                alert("Error: could not find display function:" + type + " msg: " + msg);
                return;
            }
            let displayId = props.displayId;
	    if(!displayId) 
		displayId = this.getUniqueId("display");
            if (props.theData == null && this.dataList.length > 0) {
                props.theData = this.dataList[0];
            }
            props.createdInteractively = true;
            if (!props.entryId) {
                props.entryId = this.group.entryId;
            }
            let display = eval(" new " + funcName + "(this,'" + displayId + "', props);");
            if (display == null) {
                console.log("Error: could not create display using:" + funcName);
                alert("Error: could not create display using:" + funcName);
                return;
            }
	    if(props.dummy) return display;
            this.addDisplay(display);
	    display.doFinalInitialization();
            return display;
        },
        pageHasLoaded: function(display) {
            this.getLayoutManager().pageHasLoaded();
        },
        addDisplay: function(display) {
            display.setDisplayManager(this);
            display.loadInitialData();
            this.getLayoutManager().addDisplay(display);
        },
	getDisplays: function() {
	    return this.getLayoutManager().getDisplays();
	},
        notifyEvent: function(func, source, data) {
            this.getLayoutManager().notifyEvent(func, source, data);
        },
        removeDisplay: function(display) {
            this.getLayoutManager().removeDisplay(display);
            this.notifyEvent("handleEventRemoveDisplay", this, display);
        },
	setEntry: function(entry) {
	    var displays = this.getLayoutManager().getDisplays();
	    for (var i = 0; i < displays.length; i++) {
		var display = displays[i];
		display.setEntry(entry);
	    }
	},
    });

    addDisplayManager(this);

    let displaysHtml = HU.div([ATTR_ID, this.getDomId(ID_DISPLAYS), ATTR_CLASS, "display-container",STYLE,HU.css("display","block")]);
    let html = HU.openTag(TAG_DIV,["style","position:relative;"]);
    html += HU.div(["id", this.getDomId(ID_MENU_CONTAINER)]);
    html +=  this.getEntriesMenu(argProperties);

    if(this.getShowMenu()) {
        html += HU.tag(TAG_A, [ATTR_CLASS, "display-menu-button", ATTR_ID, this.getDomId(ID_MENU_BUTTON)], SPACE);
    }
    let targetDiv = this.getProperty("target",this.getProperty("targetDiv"));
    let _this = this;
    if (targetDiv != null) {
	if($("#" + targetDiv).length==0) {
	    console.log("Error: display group could not find targetDiv:" + targetDiv);
	    targetDiv=null;
	}
    }

    if (targetDiv != null) {
        $(document).ready(function() {
            $("#" + targetDiv).html(displaysHtml);
            _this.getLayoutManager().doLayout();
	});
    } else {
        html += displaysHtml;
    }
    html += HU.closeTag(TAG_DIV);
    let divid = this.getProperty("divId",this.getId());
    $("#" + divid).html(html)
    this.initializeEntriesMenu();

    this.jq(ID_MENU_BUTTON).html(HU.getIconImage("fa-cog",[TITLE,"Display menu"] )).button({
	classes: {
	    "ui-button": "display-manager-button",
	}	
    }).click(function(event) {
	if(this.dialog) {
	    this.dialog.remove();
	}
        let html = _this.makeMainMenu();
	this.dialog = HU.makeDialog({content:html,title:"Displays",my:"left top",at:"left bottom",anchor:_this.jq(ID_MENU_BUTTON)});
        _this.jq(ID_MENU_INNER).superfish({
            //Don't set animation - it is broke on safari
            //                    animation: {height:'show'},
            speed: 'fast',
            delay: 300
        });


    });

}


function RamaddaMultiDisplay(displayManager, id, properties) {
    this.props = properties;
    let SUPER = new DisplayGroup(displayManager, id, properties, DISPLAY_MULTI);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        inInitDisplay: false,
        haveInited: false,
        needsData: function() {
            return true;
        },

        pointDataLoaded: function(pointData, url, reload) {
            SUPER.pointDataLoaded.call(this, pointData, url, reload);
            this.initDisplay();
        },
        processMacros: function(selectedFields, value, makeList) {
            if ((typeof value) != "string") return null;
            var toks = [];
            if (value.includes("${fieldLabel}")) {
                for (i = 0; i < selectedFields.length; i++) {
                    var v = value.replace("\${fieldLabel}", selectedFields[i].getLabel());
                    toks.push(v);
                }
            } else if (value.includes("${fieldId}")) {
                for (i = 0; i < selectedFields.length; i++) { 
                   var v = value.replace("\${fieldId}", selectedFields[i].getId());
                    toks.push(v);
                }
            } else if (value.includes("${fieldCnt}")) {
                var v = value.replace("\${fieldCnt}", selectedFields.length);
                toks.push(v);
            } else if (value.includes("${")) {

            } else {
                return null;
            }
            if (makeList) return toks;
            return Utils.join(toks, ",");
        },
        initDisplay: function() {
            try {
                this.initDisplayInner();
            } catch (e) {
                this.setContents(this.getMessage("An error occurred:" + e));
                console.log("An error occurred:" + e);
                console.log(e.stack);
            }
        },
        useChartableFields: function() {
            return false;
        },
        initDisplayInner: function() {
            SUPER.initDisplay.call(this);
            let records = this.filterData();
            if (!records) {
                this.setDisplayMessage(this.getLoadingMessage());
                return null;
            }

            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0) {
                this.setContents(this.getMessage("no fields"));
                return;
            }

            if (this.inInitDisplay) return;
            if (this.haveInited) return;
            this.haveInited = true;
            this.inInitDisplay = true;

            var props = {};
            var foreachMap = {};
            var foreachList = [];
            var cnt = 0;
            for (a in this.props) {
                if (a.startsWith("foreach_")) {
                    var value = this.props[a];
                    var toks;
                    var tmp = this.processMacros(fields, value, true);
                    if (tmp) {
                        toks = tmp;
                    } else {
                        toks = value.split(",");
                    }
                    a = a.substring(8);
                    if (toks.length > cnt) cnt = toks.length;
                    foreachMap[a] = toks;
                    foreachList.push({
                        attr: a,
                        toks: toks
                    });
                }
                if (a.startsWith("sub_")) {
                    var value = this.props[a];
                    a = a.substring(4);
                    var tmp = this.processMacros(fields, value, false);
                    if (tmp) {
                        value = tmp;
                    }
                    props[a] = value;
                }
            }
            var html = HU.div([ATTR_ID, this.getDomId(ID_DISPLAYS), ATTR_CLASS, "display-container"]);
            this.setContents(html);
            var groupProps = {
                target: this.getDomId(ID_DISPLAYS),
            }
            groupProps[PROP_LAYOUT_TYPE] = 'table';
            groupProps[PROP_LAYOUT_COLUMNS] = this.getProperty(PROP_LAYOUT_COLUMNS, "2");
            this.displayManager = new DisplayManager(this.getId() + "_manager", groupProps);


            props.layoutHere = false;
            if (this.props['data'])
                props['data'] = this.props['data'];
            var subType = this.getProperty("subType", "table");
            if (cnt == 0) cnt = 1;
            for (var i = 0; i < cnt; i++) {
                var dprops = {};
                $.extend(dprops, props);
                for (var j = 0; j < foreachList.length; j++) {
                    if (i < foreachList[j].toks.length) {
                        dprops[foreachList[j].attr] = foreachList[j].toks[i];
                    }
                }
                if (dprops['fields']) dprops['fields'] = dprops['fields'].split(",");
                this.displayManager.createDisplay(subType, dprops);
            }
            this.inInitDisplay = false;
        }
    });
}

/**
   Copyright 2008-2020 Geode Systems LLC
*/

const FILTER_ALL = "-all-";
let pointDataCache = {};

function DataCollection() {
    RamaddaUtil.defineMembers(this, {
        data: [],
        hasData: function() {
            for (var i = 0; i < this.data.length; i++) {
		if(this.data[i])
                    if (this.data[i].hasData()) return true;
            }
            return false;
        },
        getList: function() {
            return this.data;
        },
	setData: function(data) {
	    this.data = [data];
	},
        addData: function(data) {
            this.data.push(data);
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
            var anyHandled = false;
            for (var i = 0; i < this.data.length; i++) {
                if (this.data[i].handleEventMapClick(myDisplay, source, lon, lat)) {
                    anyHandled = true;
                }
            }
            return anyHandled;

        },


    });

}

function BasePointData(name, properties) {
    if (properties == null) properties = {};

    RamaddaUtil.defineMembers(this, {
        recordFields: null,
        records: null,
        entryId: null,
        entry: null
    });

    $.extend(this, properties);

    RamaddaUtil.defineMembers(this, {
        name: name,
        properties: properties,
        initWith: function(thatPointData) {
            this.recordFields = thatPointData.recordFields;
            this.records = thatPointData.records;
            this.setGroupField();
	    return this;
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
            return false;
        },
        hasData: function() {
            return this.records != null;
        },
        clear: function() {
            this.records = null;
            this.recordFields = null;
        },
        getProperties: function() {
            return this.properties;
        },
        getProperty: function(key, dflt) {
            var value = this.properties[key];
            if (value == null) return dflt;
            return value;
        },

        getRecordFields: function() {
            return this.recordFields;
        },
        addRecordField: function(field) {
            this.recordFields.push(field);
        },
        getRecords: function() {
            return this.records;
        },
        getNumericFields: function() {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (field.isNumeric()) numericFields.push(field);
            }
            return numericFields;
        },
        getChartableFields: function(display) {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            var skip = /(TIME|HOUR|MINUTE|SECOND|YEAR|MONTH|DAY|LATITUDE|LONGITUDE|^ELEVATION$)/g;
            var skip = /(xxxnoskip)/g;
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (!field.isNumeric() || !field.isChartable()) {
                    continue;
                }
                var ID = field.getId().toUpperCase();
                if (ID.match(skip)) {
                    continue;
                }
                numericFields.push(field);
            }

            return RecordUtil.sort(numericFields);
        },
        getNonGeoFields: function(display) {
            var recordFields = this.getRecordFields();
            var numericFields = [];
            //                var skip = /(TIME|HOUR|MINUTE|SECOND|YEAR|MONTH|DAY|LATITUDE|LONGITUDE|ELEVATION)/g;
            var hadDate = false;
            for (var i = 0; i < recordFields.length; i++) {
                var field = recordFields[i];
                if (field.isFieldGeo()) {
                    continue;
                }
		//		console.log("F:" + field.getId());
                if (field.isFieldDate()) {
                    if (hadDate && field.getId() == "recordDate") {
                        continue;
                    }
                    hadDate = true;
                }

                //                    var ID = field.getId().toUpperCase() ;
                //                    if(ID.match(skip)) {
                //                        continue;
                //                    }
                numericFields.push(field);
            }
            return numericFields;
            //                return RecordUtil.sort(numericFields);
        },

        loadData: function(display) {},
        getName: function() {
            return this.name;
        },
        getTitle: function() {
            if (this.records != null && this.records.length > 0)
                return this.name + " - " + this.records.length + " points";
            return this.name;
        }
    });
}





function convertToPointData(array) {
    var fields = [];
    var records = [];
    var header = array[0];
    var samples = array[1];
    for(var i=0;i<header.length;i++) {
        let label = String(header[i]);
	let id = label.toLowerCase().replace(/[ ., ]+/g,"_");
        let sample =samples[i];
        let tof= typeof sample;
        let type;
        if(tof=="string")
            type = "string";
        else if(tof=="number")
            type = "double";
        else if(sample.getTime)
            type = "date";
        else 
            console.log("Unknown type:" + tof);
        fields.push(new RecordField({
            id:id,
	    index:i,
            label:label,
            type:type,
            chartable:true
        }));
    }
    for(var i=1;i<array.length;i++) {
        records.push(new  PointRecord(fields,NaN, NaN, NaN, null, array[i]));
    }
    return new  PointData("pointdata", fields, records,null,null);
}


/*
  This encapsulates some instance of point data. 
  name - the name of this data
  recordFields - array of RecordField objects that define the metadata
  data - array of Record objects holding the data
*/
function PointData(name, recordFields, records, url, properties) {
    RamaddaUtil.inherit(this, new BasePointData(name, properties));
    this.parentPointData = properties?properties.parent:null;
    RamaddaUtil.defineMembers(this, {
        recordFields: recordFields,
        records: records,
        url: url,
        loadingCnt: 0,
	getRootPointData: function() {
	    if(this.parentPointData)
		return this.parentPointData.getRootPointData();
	    return this;
	},
        getUrl: function() {
	    if(this.url) return this.url;
	    if(this.parentPointData) return this.parentPointData.getUrl();
	    return null;
	},
        equals: function(that) {
	    if(this.jsonUrl) {
		return this.jsonUrl == that.jsonUrl;
	    }
            return this.url == that.url;
        },
        getIsLoading: function() {
            return this.loadingCnt > 0;
        },
        handleEventMapClick: function(myDisplay, source, lon, lat) {
	    let url = this.getUrl();
            this.lon = lon;
            this.lat = lat;
	    ///repository/grid/json?entryid=3715ca8e-3c42-4105-96b1-da63e3813b3a&location.latitude=0&location.longitude=179.5
	    //	    initiallatitude=40&location.latitude=0&location.longitude=179.5
            if (myDisplay.getDisplayManager().hasGeoMacro(url)) {
		this.loadData(myDisplay, true);
                return true;
            }
            return false;
        },
        startLoading: function() {
            this.loadingCnt++;
        },
        stopLoading: function() {
            this.loadingCnt--;
        },
        setGroupField: function() {
            if(this.recordFields) {
                for(var i=0;i<this.recordFields.length;i++) {
                    var field = this.recordFields[i];
                    if(field.isFieldGroup()) {
                        this.groupField = field;
                        break;
                    }
                }
            }
        },
        extractGroup: function(group, records) {
            if(!this.groupField) return records;
            var groupData = this.getDataGroups(records);
            if(groupData.length==0) return records;
            if(!group) group = groupData[0];
            return records;
        },
        getDataGroups: function(records) {
            if(!this.groupData) {
                if(!records) return [];
                this.groupData= [];
                var groupField = this.getGroupField();
                if(!groupField) return this.groupData;
                var seen = {};
                for(var i=0;i<records.length;i++) {
                    var record = records[i];
                    var data;
                    if(record.tuple) 
                        data = record.tuple;
                    else if(record.record)
                        data = record.record.getData();
                    console.log("data:" + data);
                    var value = groupField.getValue(record);
                    if(!seen[value]) {
                        seen[value] = true;
                        this.groupData.push(value);
                    }
                }
            }
            console.log(this.groupData);
            return this.groupData;
        },
        getGroupField: function() {
            return this.groupField;
        },
        isGroup: function() {
            return this.getGroupField()!=null;
        },
        loadData: function(display, reload) {
	    let root = this.getRootPointData();
            if (root.url == null) {
                console.log("No URL");
                return;
            }
            var props = {
                lat: this.lat,
                lon: this.lon,
            };
            var jsonUrl = display.displayManager.getJsonUrl(root.url, display, props);
	    root.jsonUrl = jsonUrl;
            root.loadPointJson(jsonUrl, display, reload);
        },
        loadPointJson: function(url, display, reload) {
	    let debug =  displayDebug.loadPointJson;
	    let debug2 = false;
            let pointData = this;
            this.startLoading();
            let _this = this;
	    if(debug) {
		console.log("loadPointJson: "+ display.type +" " + display.getId() +" reload:" + reload);
	    } 
            let cacheObject = pointDataCache[url];
            if (cacheObject == null) {
                cacheObject = {
                    pointData: null,
                    pending: [],
		    displays:[],
		    size:0,
		    url:url,
		    toString:function() {
			return "cache:" + (this.pointData==null?" no data ":" data:" +this.pointData.pdcnt +" " + this.pointData.getRecords().length) +" url:" + this.url;
		    }

                };
		if(debug)
                    console.log("\tcreated new obj in cache: " +url);
                pointDataCache[url] = cacheObject;
            } else {
		if(cacheObject.pending.indexOf(display)>=0) {
		    if(debug)
			console.log("\tcache hit - display in pending list");
		    return;
		} else {
		    if(debug)
			console.log("\tcache hit - display not in pending list");
		}
	    }		
	    if(cacheObject.displays.indexOf(display)<0) {
		if(debug2)
		    console.log("adding to displays-1:" + display);
		cacheObject.displays.push(display);
	    }
	    //If we are reloading then clear the data
	    //Don't do this for now
	    if(reload) {
		//If its a reload then add all dependent displays to the pending list
		cacheObject.pointData = null;
		cacheObject.pending = [];
		if(debug)
		    console.log("\treloading adding to pending:" + cacheObject.displays);
		cacheObject.displays.forEach(d=>{
		    if(debug)
			console.log("\tdisplay:" + d.type +" " + d.getId());
		    cacheObject.pending.push(d);
		});
	    } else {
		if(cacheObject.displays.indexOf(display)<0) {
		    if(debug2)
			console.log("adding to displays-2:" + display);
		    cacheObject.displays.push(display);
		}
		if (cacheObject.pointData != null) {
		    if(debug)
			console.log("\tdata was in cache:" +cacheObject.pointData.getRecords().length+" url:" + url);
                    display.pointDataLoaded(cacheObject.pointData, url, reload);
                    return;
		}
		cacheObject.pending.push(display);
		if (cacheObject.pending.length > 1) {
		    if(debug)
			console.log("\tWaiting on callback:" + cacheObject.pending.length +" " + url +" d:" + display);
                    return;
		}
	    }
            var fail = function(jqxhr, textStatus, error) {
		console.log("Point data load error:" + textStatus +" " + error);
                var err = textStatus;
		if(err) {
		    if(error)
			err += ": " + error;
		} else {
		    err = error;
		}
		console.log("Point data load error:" + (err?err:""));
		cacheObject.pending.map(display=>{
                    display.pointDataLoadFailed(err);
		});
		delete pointDataCache[url];
                pointData.stopLoading();
            }

            var success=function(data) {
		if(typeof data == "string") {
		    data = JSON.parse(data);
		}
		if(debug) console.log("pointDataLoaded");
                if (GuiUtils.isJsonError(data)) {
		    if(debug)
			console.log("\tloadPointData failed");
                    display.pointDataLoadFailed(data);
                    return;
                }
		if(data.errorcode == "nodata" || !data.fields) {
		    if(debug)
			console.log("\tno data:" + url);
		    let dummy = new PointData("", [],[]);
                    var tmp = cacheObject.pending;
                    cacheObject.pending = [];
                    for (var i = 0; i < tmp.length; i++) {
			tmp[i].handleNoData(dummy);
		    }
		    return;
		}
		if(debug)
		    console.log("\tmaking point data");
		let t1 = new Date();
                var newData = makePointData(data, _this.derived, display,_this.url);
		let t2 = new Date();
		if(debug)
		    Utils.displayTimes("makePointData",[t1,t2],true);

		if(debug)
		    console.log("\tdone making point data #records:" + newData.getRecords().length);
                pointData = cacheObject.pointData = newData;
		//                cacheObject.pointData = pointData.initWith(newData);
		if(data.properties) {
		    display.applyRequestProperties(data.properties);
		}
		if(debug)
		    console.log("\tcalling pointDataLoaded on  " + tmp.length + " displays");
                var tmp = cacheObject.pending;
                cacheObject.pending = [];
                for (let i = 0; i < tmp.length; i++) {
		    if(debug)
			console.log("\tcalling pointDataLoaded:" + tmp[i] +" #:" + pointData.getRecords().length);
                    tmp[i].pointDataLoaded(pointData, url, reload);
                }

		if(cacheObject.pointData.records && cacheObject.pointData.records.length) {
		    cacheObject.size = cacheObject.pointData.records.length*cacheObject.pointData.records[0].getData().length;
		}

		let size = 0;
		Object.keys(pointDataCache).map(key=>{
		    size+=pointDataCache[key].size;
		});
		if(debug)
		    console.log("\tcache size:" + size);
		//Size is just the number of rows*columns
		if(size>1000000) {
		    Object.keys(pointDataCache).map(key=>{
			if(pointDataCache[key].pending.length==0) {
			    if(debug)
				console.log("\tDeleting from cache:" + key);
			    delete pointDataCache[key];
			}
		    });
		}
                pointData.stopLoading();
	    }
	    let fullUrl = url;
	    if(!fullUrl.startsWith("http")) {
		var base = window.location.protocol + "//" + window.location.host;
		fullUrl = base+fullUrl;
	    }

	    //            Utils.doFetch(url, success,fail,"json");
	    //Handle the snapshot relative file
	    if(!url.startsWith("/") && !url.startsWith("http")) {
		let root = String(window.location).replace(/\/[^\/]+$/,"");
		url = root + "/" + url;
	    }
	    console.log("point data:" + url);
            Utils.doFetch(url, success,fail,null);	    
//            var jqxhr = $.getJSON(url, success,{crossDomain:true}).fail(fail);
        }

    });
    this.setGroupField();
}


function DerivedPointData(displayManager, name, pointDataList, operation) {
    RamaddaUtil.inherit(this, new BasePointData(name));
    RamaddaUtil.defineMembers(this, {
        displayManager: displayManager,
        operation: operation,
        pointDataList: pointDataList,
        loadDataCalls: 0,
        display: null,
        pointDataLoaded: function(pointData) {
            this.loadDataCalls--;
            if (this.loadDataCalls <= 0) {
                this.initData();
            }
        },
        equals: function(that) {
            if (that.pointDataList == null) return false;
            if (this.pointDataList.length != that.pointDataList.length) return false;
            for (var i in this.pointDataList) {
                if (!this.pointDataList[i].equals(that.pointDataList[i])) {
                    return false;
                }
            }
            return true;
        },
        initData: function() {
            var pointData1 = this.pointDataList[0];
            if (this.pointDataList.length == 1) {
                this.records = pointData1.getRecords();
                this.recordFields = pointData1.getRecordFields();
		console.log("initData:" + this.recordFields.length);
            } else if (this.pointDataList.length > 1) {
                var results = this.combineData(pointData1, this.pointDataList[1]);
                this.records = results.records;
                this.recordFields = results.recordFields;
		console.log("initData 2:" + this.recordFields.length);
            }
            this.setGroupField();
            this.display.pointDataLoaded(this);
        },

        combineData: function(pointData1, pointData2) {
            var records1 = pointData1.getRecords();
            var records2 = pointData2.getRecords();
            var newRecords = [];
            var newRecordFields;

            //TODO:  we really need visad here to sample

            if (records1.length != records2.length) {
                console.log("bad records:" + records1.length + " " + records2.length);
            }

            if (this.operation == "average") {
                for (var recordIdx = 0; recordIdx < records1.length; recordIdx++) {
                    var record1 = records1[recordIdx];
                    var record2 = records2[recordIdx];
                    if (record1.getDate() != record2.getDate()) {
                        console.log("Bad record date:" + record1.getDate() + " " + record2.getDate());
                        break;
                    }
                    var newRecord = $.extend(true, {}, record1);
                    var data1 = newRecord.getData();
                    var data2 = record2.getData();
                    for (var colIdx = 0; colIdx < data1.length; colIdx++) {
                        data1[colIdx] = (data1[colIdx] + data2[colIdx]) / 2;
                    }
                    newRecords.push(newRecord);
                }
                newRecordFields = pointData1.getRecordFields();
            } else if (this.operation == "other func") {}
            if (newRecordFields == null) {
                //for now just use the first operand
                newRecords = records1;
                newRecordFields = pointData1.getRecordFields();
            }
            return {
                records: newRecords,
                recordFields: newRecordFields
            };
        },
        loadData: function(display) {
            this.display = display;
            this.loadDataCalls = 0;
            for (var i in this.pointDataList) {
                var pointData = this.pointDataList[i];
                if (!pointData.hasData()) {
                    this.loadDataCalls++;
                    pointData.loadData(this);
                }
                if (this.loadDataCalls == 0) {
                    this.initData();
                }
            }
            //TODO: notify display
        }
    });
}





/*
  This class defines the metadata for a record column. 
  index - the index i the data array
  id - string id
  label - string label to show to user
  type - for now not used but once we have string or other column types we'll need it
  missing - the missing value forthis field. Probably not needed and isn't used
  as I think RAMADDA passes in NaN
  unit - the unit of the value
*/
function RecordField(props, source) {
    $.extend(this, {
        isDate: props.type == "date",
        isLatitude: false,
        isLongitude: false,
        isElevation: false,
	forDisplay:true
    });
    $.extend(this, props);
    $.extend(this, {
        isGroup:props.group,
        properties: props
    });

    //check for extended attributes
    if(source && source.getProperty) {
	["type","label","unit"].forEach(t=>{
	    let ext = source.getProperty(props.id+"." + t);
	    if(ext) this[t] = ext;
	});
    }
    RamaddaUtil.defineMembers(this, {
	clone: function() {
	    var newField = {};
	    $.extend(newField,this);
	    return newField;
	},
	toString: function() {
	    return this.getId();
	},
	getForDisplay: function() {
	    return this.forDisplay;
	},
        getIndex: function() {
            return this.index;
        },
        getValue: function(record,dflt) {
	    let v;
	    if(record.getValue)
		v= record.getValue(this.index);
	    else
		v = record[this.index];
	    if(!v && !Utils.isDefined(v)) return dflt;
	    return v;
        },
        getEnumeratedValues: function(row) {
	    return this.enumeratedValues;
	},
        isFieldGroup: function() {
            return this.isGroup;
        },
	isRecordDate: function() {
	    return this.getId()=="recordDate";
	},
        isFieldGeo: function() {
            return this.isFieldLatitude() || this.isFieldLongitude() || this.isFieldElevation();
        },
        isFieldLatitude: function() {
            return this.isLatitude || this.id.toLowerCase() == "latitude";
        },
        isFieldLongitude: function() {
            return this.isLongitude || this.id.toLowerCase() == "longitude";
        },
        isFieldElevation: function() {
            return this.isElevation || this.id.toLowerCase() == "elevation" || this.id.toLowerCase() == "altitude";
        },
        isFieldNumeric: function() {
            return this.isNumeric();
        },
        isFieldString: function() {
            return this.type == "string" || this.type == "enumeration";
        },
        isFieldEnumeration: function() {
            return this.type == "enumeration";
        },
        isFieldDate: function() {
            return this.isDate;
        },
        isChartable: function() {
            return this.chartable;
        },
        getSortOrder: function() {
            return this.sortorder;
        },
        getId: function() {
            return this.id;
        },
        getTypeLabel: function() {
            var type = "fa-font";
            if(this.isFieldGeo()) {
                type="fa-globe";
            } else if(this.isFieldNumeric()) {
                type="fa-hashtag";
            } else if(this.isFieldEnumeration()) {
                type="fa-list";
            }
            var tt = this.getType();
            return  HtmlUtils.span(["title",tt,"class","fa " +type,"style","color:rgb(169, 169, 169);font-size:12pt;"]);
        },
        getUnitLabel: function() {
            return this.getLabel() + this.getUnitSuffix();
        },
        getUnitSuffix: function() {
            if (this.unit && this.unit != "")
                return "&nbsp;[" + this.unit + "]";
            return "";
        },

        getLabel: function() {
            if (this.label == null || this.label.length == 0) return this.id;
            return this.label;
        },
        setLabel: function(l) {
            this.label = l;
        },
        isNumeric: function() {
	    return this.type == "double" || this.type == "integer";
	},
	isString: function() {
	    return this.type == "string" || this.type=="enumeration" || this.type =="url" || this.type == "image";
	},
        getType: function() {
            return this.type;
        },
        setType: function(t) {
            this.type = t;
        },	
        getMissing: function() {
            return this.missing;
        },
        setUnit: function(u) {
            this.unit = u;
        },
        getUnit: function() {
            return this.unit;
        }
    });

}



/*
  The main data record. This holds a lat/lon/elevation, time and an array of data
  The data array corresponds to the RecordField fields
*/
function PointRecord(fields,lat, lon, elevation, time, data) {
    this.isPointRecord = true;
    $.extend(this, {
	fields:fields,
        latitude: lat,
        longitude: lon,
        elevation: elevation,
        recordTime: time,
        data: data,
	id: HtmlUtils.getUniqueId(),
    });
    if(!time && data) {
	data.every(d=>{
	    if(d && d.getTime) {
		this.recordTime = d;
		return false;
	    }
	    return true;
	});
    }
}


PointRecord.prototype =  {
    clone: function() {
	var newRecord = {};
	$.extend(newRecord,this);
	newRecord.data = [];
	this.data.map((v,idx)=>{newRecord.data[idx] = v;});
	return newRecord;
    },
    isHighlight: function(display) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	return this.highlightForDisplay[display];
    },
    getDisplayProperty: function(display,prop,dflt) {
	if(!this.displayProperties) this.displayProperties={};
	let props = this.displayProperties[display];
	if(!props) {
	    props = this.displayProperties[display] = {};
	}
	return props[prop] || dflt;
    },
    setDisplayProperty: function(display,prop,value) {
	if(!this.displayProperties) this.displayProperties={};
	let props = this.displayProperties[display];
	if(!props) {
	    props = this.displayProperties[display] = {};
	}
	props[prop] =value;
    },
    setHighlight:function(display, value) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	if(!value || this.highlightForDisplay[display] == null) {
	    this.highlightForDisplay[display] = value;
	}
    },
    clearHighlight:function(display) {
	if(!this.highlightForDisplay) this.highlightForDisplay={};
	delete this.highlightForDisplay[display];
    },
    toString: function() {
	return "data:"  + this.data;
    },
    getId: function() {
	return this.id;
    },
    getData: function() {
        return this.data;
    },
    setData: function(d) {
        this.data = d;
    },    
    allZeros: function() {
        var tuple = this.getData();
        var allZeros = false;
        var nums = 0;
        var nonZero = 0;
        for (var j = 0; j < tuple.length; j++) {
            if (typeof tuple[j] == "number") {
                nums++;
                if (!isNaN(tuple[j]) && tuple[j] != 0) {
                    nonZero++;
                    break;
                }
            }
        }
        if (nums > 0 && nonZero == 0) {
            return true;
        }
        return false;
    },
    getValue: function(index) {
        return this.data[index];
    },
    setValue: function(index,value) {
        this.data[index] = value;
    },
    push: function(v) {
        this.data.push(v);
    },
    hasDate: function() {
	return this.getDate()!=null;
    },
    hasLocation: function() {
        return this.latitude !=null && !isNaN(this.latitude);
    },
    hasElevation: function() {
        return this.elevation !=null && !isNaN(this.elevation);
    },
    setLocation: function(lat,lon) {
	this.latitude=lat;
	this.longitude=lon;
    },
    getLatitude: function() {
        return this.latitude;
    },
    getLongitude: function() {
        return this.longitude;
    },
    getTime: function() {
        return this.recordTime;
    },
    getElevation: function() {
        return this.elevation;
    },
    getDate: function() {
        return this.recordTime;
    }
};


function makePointData(json, derived, source,url) {
    let debug  =false;
    if(debug) console.log("makePointData");
    var fields = [];
    var latitudeIdx = -1;
    var longitudeIdx = -1;
    var elevationIdx = -1;
    var dateIdx = -1;
    var dateIndexes = [];

    var offsetFields = [];
    var lastField = null;
    for (var i = 0; i < json.fields.length; i++) {
        var field = json.fields[i];
        var recordField = new RecordField(field,source);
        if (recordField.isFieldNumeric()) {
            if (source.getProperty) {
                var offset1 = source.getProperty(recordField.getId() + ".offset1", source.getProperty("offset1"));
                var offset2 = source.getProperty(recordField.getId() + ".offset2", source.getProperty("offset2"));
                var scale = source.getProperty(recordField.getId() + ".scale", source.getProperty("scale"));

                if (offset1 || offset2 || scale) {
                    var unit = source.getProperty(recordField.getId() + ".unit", source.getProperty("unit"));
                    if (unit) {
                        recordField.unit = unit;
                    }
                    var o = {
                        offset1: 0,
                        offset2: 0,
                        scale: 1
                    };
                    if (offset1) o.offset1 = parseFloat(offset1);
                    if (offset2) o.offset2 = parseFloat(offset2);
                    if (scale) o.scale = parseFloat(scale);
                    recordField.offset = o;
                    offsetFields.push(recordField);
                }
            }
        }


        lastField = recordField;
        fields.push(recordField);
        //        console.log("field:" + recordField.getId());
        if (recordField.isFieldLatitude()) {
            latitudeIdx = recordField.getIndex();
        } else if (recordField.isFieldLongitude()) {
            longitudeIdx = recordField.getIndex();
            //            console.log("Longitude idx:" + longitudeIdx);
        } else if (recordField.isFieldElevation()) {
            elevationIdx = recordField.getIndex();
            //            console.log("Elevation idx:" + elevationIdx);
        } else if (recordField.isFieldDate()) {
	    dateIdx = recordField.getIndex();
	    dateIndexes.push(dateIdx);
        }

    }

    if (derived) {
        var index = lastField.getIndex() + 1;
        for (var dIdx = 0; dIdx < derived.length; dIdx++) {
            var d = derived[dIdx];
            var label = d.label || d.name;
            var recordField = new RecordField({
                type: "double",
                index: (index + dIdx),
                chartable: true,
                id: d.name,
                label: label,
            });
            recordField.derived = d;
            fields.push(recordField);
        }
    }

    let pointRecords = [];
    let isArray = false;
    let hasGeo = false;
    let hasDate = false;
    let setDateFlags = false;
    let dateIsString = false;
    json.data.forEach((tuple,i)=>{
	//	if(i>100) return;
	if(debug && i>0 && (i%10000)==0) console.log("\tprocessed:" + i);
	if(i==0) {
	    isArray = Array.isArray(tuple);
	    hasDate = !(typeof tuple.date === 'undefined');
	}
	let values;
	if(isArray)
	    values = tuple;
	else
            values = tuple.values;
        //lat,lon,alt,time,data values
        let date = null;
        if (isArray || !hasDate) {
            if (dateIdx >= 0) {
		if(!setDateFlags) {
		    dateIsString = (typeof values[dateIdx] == "string");
		    setDateFlags = true;
		}
		if(dateIsString) {
		    date = new Date(values[dateIdx]);
		} else {
		    date = new Date(0);
		    date.setUTCMilliseconds(values[dateIdx]);
		}
            }
        } else {
            if (tuple.date != null && tuple.date != 0) {
		date = new Date(0);
		date.setUTCMilliseconds(tuple.date);
            }
        }
        if (isArray || (typeof tuple.latitude === 'undefined')) {
            if (latitudeIdx >= 0)
                tuple.latitude = values[latitudeIdx];
            else
                tuple.latitude = NaN;
        }
        if (isArray || (typeof tuple.longitude === 'undefined')) {
            if (longitudeIdx >= 0)
                tuple.longitude = values[longitudeIdx];
            else
                tuple.longitude = NaN;
        }
        for (var j = 0; j < dateIndexes.length; j++) {
            values[dateIndexes[j]] = new Date(values[dateIndexes[j]]);
        }
        for (var col = 0; col < values.length; col++) {
            if(values[col]==null) {
                values[col] = NaN;
            } 
        }

        if (derived) {
            for (var dIdx = 0; dIdx < derived.length; dIdx++) {
                var d = derived[dIdx];
                if (!d.isRow) {
                    continue;
                }
                if (!d.compiledFunction) {
                    var funcParams = [];
                    var params = (d.columns.indexOf(";") >= 0 ? d.columns.split(";") : d.columns.split(","));
                    d.fieldsToUse = [];
                    for (var i = 0; i < params.length; i++) {
                        var param = params[i].trim();
                        funcParams.push("v" + (i + 1));
                        var theField = null;
                        for (var fIdx = 0; fIdx < fields.length; fIdx++) {
                            var f = fields[fIdx];
                            if (f.getId() == param) {
                                theField = f;
                                break;
                            }
                        }
                        d.fieldsToUse.push(theField);

                    }
                    var code = "";
                    for (var i = 0; i < funcParams.length; i++) {
                        code += "var v" + (i + 1) + "=args[" + i + "];\n";
                    }
                    var tmp = d["function"];
                    if (tmp.indexOf("return") < 0) tmp = "return " + tmp;
                    code += tmp + "\n";
                    d.compiledFunction = new Function("args", code);
                    //                    console.log("Func:" + d.compiledFunction);
                }
                //TODO: compile the function once and call it
                var args = [];
                var anyNotNan = false;
                for (var fIdx = 0; fIdx < d.fieldsToUse.length; fIdx++) {
                    var f = d.fieldsToUse[fIdx];
                    var v = NaN;
                    if (f != null) {
                        v = values[f.getIndex()];
                        if (v == null) v = NaN;
                    }
                    if (!isNaN(v)) {
                        anyNotNan = true;
                    } else {}
                    args.push(v);
                }
                //                console.log("anyNot:" + anyNotNan);
                //                console.log(args);
                try {
                    var result = NaN;
                    if (anyNotNan) {
                        result = d.compiledFunction(args);
                        if (d.decimals >= 0) {
                            result = result.toFixed(d.decimals);
                        }
                        result = parseFloat(result);
                    } else {
                        //                        console.log("NAN");
                    }
                    //                    console.log("in:" + result +" out: " + result);
                    values.push(result);
                } catch (e) {
                    console.log("Error evaluating function:" + d["function"] + "\n" + e);
                    values.push(NaN);
                }
            }
	}

        for (var fieldIdx = 0; fieldIdx < offsetFields.length; fieldIdx++) {
            var field = offsetFields[fieldIdx];
            var offset = field.offset;
            var value = values[field.getIndex()];
            value = (value + offset.offset1) * offset.scale + offset.offset2;
            values[field.getIndex()] = value;
        }

        var record = new PointRecord(fields, tuple.latitude, tuple.longitude, tuple.elevation, date, values);
        pointRecords.push(record);
    });


    if (source != null) {
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var prefix = "field." + field.getId() + ".";
            if (Utils.isDefined(source[prefix + "unit"])) {
                field.setUnit(source[prefix + "unit"]);
            }
            if (Utils.isDefined(source[prefix + "label"])) {
                field.setLabel(source[prefix + "label"]);
            }
            if (Utils.isDefined(source[prefix + "scale"]) || Utils.isDefined(source[prefix + "offset1"]) || Utils.isDefined(source[prefix + "offset2"])) {
                var offset1 = Utils.isDefined(source[prefix + "offset1"]) ? parseFloat(source[prefix + "offset1"]) : 0;
                var offset2 = Utils.isDefined(source[prefix + "offset2"]) ? parseFloat(source[prefix + "offset2"]) : 0;
                var scale = Utils.isDefined(source[prefix + "scale"]) ? parseFloat(source[prefix + "scale"]) : 1;
                var index = field.getIndex();
                for (var rowIdx = 0; rowIdx < pointRecords.length; rowIdx++) {
                    var record = pointRecords[rowIdx];
                    var values = record.getData();
                    var value = values[index];
                    values[index] = (value + offset1) * scale + offset2;
                }
            }

        }
    }

    var name = json.name;
    if ((typeof name === 'undefined')) {
        name = "Point Data";
    }

    pointRecords.sort(function(a, b) {
        if (a.getDate() && b.getDate()) {
            if (a.getDate().getTime() < b.getDate().getTime()) return -1;
            if (a.getDate().getTime() > b.getDate().getTime()) return 1;
            return 0;
        }
    });

    let pd =  new PointData(name, fields, pointRecords,url);
    return pd;
}



function BaseFilter(display,properties) {
    this.display = display;
    if (properties == null) properties = {};
    RamaddaUtil.defineMembers(this, {
        properties: properties,
	isEnabled: function() {
	    return true;
	},
	prepareToFilter: function() {
	},
        isRecordOk: function(display, record, values) {
            return true;
        },
	getWidget: function() {return ""}
    });
}



function BoundsFilter(display, properties) {
    RamaddaUtil.inherit(this, new BaseFilter(display, properties));
    $.extend(this, {
	isRecordOk: function(record) {
	    if(this.display.filterBounds && record.hasLocation()) {
		var b = this.display.filterBounds;
		var lat = record.getLatitude();
		var lon = record.getLongitude();
		if(lat>b.top || lat<b.bottom || lon <b.left || lon>b.right)
		    return false;
	    }
            return true;
	},
    });
}


function RecordFilter(display,filterFieldId, properties) {
    let filterField = display.getFieldById(null, filterFieldId);
    RamaddaUtil.inherit(this, new BaseFilter(display, properties));
    this.id = filterFieldId;
    let getAttr = (suffix,dflt)=>{
	if(filterField==null) return dflt;
	let key = filterField.getId()+"." + suffix;
	let v = display.getProperty(key,dflt);
	return v;
    };
	


    $.extend(this, {
	field: filterField,
	values:[],
	hideFilterWidget: display.getProperty("hideFilterWidget",false, true),
	displayType:getAttr("filterDisplay","menu"),
	label:   getAttr("filterLabel",filterField?filterField.getLabel()+":":""),
	suffix:  getAttr("filterSuffix",""),
	depends: getAttr("filterDepends",null),
	dateIds: [],
	prefix:display.getProperty(this.id +".filterPrefix"),
	suffix:display.getProperty(this.id +".filterSuffix"),
	startsWith:display.getProperty(this.id +".filterStartsWith",false),
	ops:Utils.split(display.getProperty(this.id +".filterOps"),";",true,true)
    });


    if(this.ops) {
	let tmp = [];
	this.ops.forEach(tok=>{
	    let tuple  = tok.split(",");
	    tmp.push({
		op: tuple[0],
		value: tuple[1],
		label: tuple[2]||this.id+tuple[0] +tuple[1]
	    });
	});
	this.ops = tmp;
    }


    RamaddaUtil.defineMembers(this, {
	
	toString:function() {
	    return "filter:" + filterFieldId;
	},
	getField: function() {
	    return this.field;
	},
	getFilterId: function(id) {
	    return  this.display.getDomId("filterby_" + id);
	},
	isEnabled: function() {
	    return this.field!=null;
	},
	recordOk: function(display, record, values) {
            return true;
        },
	getProperty: function(key, dflt) {
	    return this.display.getProperty(key, dflt);
	},
	getPropertyFromUrl: function(key, dflt) {
	    return this.display.getPropertyFromUrl(key, dflt);
	},	
	prepareToFilter: function() {
	    if(this.depend) {
		this.checkDependency();
	    }
	    if(!this.field) return;
	    //	    if (prefix) pattern = prefix + value;
	    //	    if (suffix) pattern = value + suffix;
	    var value=null;
	    var _values =[];
	    var values=null;
	    var matchers =[];
	    if(this.ops) {
		let v = $("#" + this.getFilterId(filterField.getId())).val();
		if(v==FILTER_ALL) {
		    this.mySearch = null;
		    return;
		}
		this.mySearch =  {
		    index: parseFloat(v)
		};
		return;
	    } else  if(this.field.isNumeric()) {
		var minField = $("#" + this.display.getDomId("filterby_" + this.field.getId()+"_min"));
		var maxField = $("#" + this.display.getDomId("filterby_" + this.field.getId()+"_max"));
		if(!minField.val() || !maxField.val()) return;
		var minValue = parseFloat(minField.val().trim());
		var maxValue = parseFloat(maxField.val().trim());
		var dfltMinValue = parseFloat(minField.attr("data-min"));
		var dfltMaxValue = parseFloat(maxField.attr("data-max"));
		if(minValue!= dfltMinValue || maxValue!= dfltMaxValue) {
		    value = [minValue,maxValue];
		}
 	    } else if(this.field.getType()=="date"){
		var date1 = $("#" + this.display.getDomId("filterby_" + this.field.getId()+"_date1")).val();
		var date2 = $("#" + this.display.getDomId("filterby_" + this.field.getId()+"_date2")).val();
		if(date1!=null && date1.trim()!="") 
		    date1 =  Utils.parseDate(date1);
		else
		    date1=null;
		if(date2!=null && date2.trim()!="") 
		    date2 =  Utils.parseDate(date2);
		else
		    date2=null;
		if(date1!=null || date2!=null)
		    value = [date1,date2]; 
	    }  else {
		values = this.getFieldValues();
		if(!values && !Array.isArray(values)) values = [values];
		if(values.length==0) return;
		var tmp = [];
		values.map(v=>{
		    tmp.push(v.replace(/_comma_/g,","));
		});
		values = tmp;
		values.map(v=>{
		    _values.push((""+v).toLowerCase());
		    try {
			matchers.push(new TextMatcher(v));
		    } catch(skipIt){}
		});
	    }
	    var anyValues = value!=null;
	    if(!anyValues && values) {
		values.forEach(v=>{if(v.length>0 && v!= FILTER_ALL)anyValues = true});
	    }
	    if(anyValues) {
		this.mySearch =  {
		    value:value,
		    values:values,
		    matchers:matchers,
		    _values:_values,
		    anyValues:anyValues,
		};
	    } else {
		this.mySearch = null;
	    }
	},
	isRecordOk:function(record,debug) {
	    let ok = true;
	    if(!this.isEnabled() || !this.mySearch) {
		return ok;
	    }
	    var rowValue = record.getValue(this.field.getIndex());
	    let filterField = this.field;
	    if(this.ops) {
		let op = this.ops[this.mySearch.index];
		if(op.op=="<") ok =  rowValue<op.value;
		else if(op.op=="<=") ok = rowValue<=op.value;
		else if(op.op==">") ok= rowValue>op.value;
		else if(op.op==">=") ok= rowValue>=op.value;
		else if(op.op=="==") ok= rowValue==op.value;				
	    } else   if(filterField.getType() == "enumeration") {
		ok = this.mySearch.values.includes(""+rowValue);
	    } else if(filterField.isNumeric()) {
		if(isNaN(this.mySearch.value[0]) && isNaN(this.mySearch.value[0])) return ok;
		if(!isNaN(this.mySearch.value[0]) && rowValue<this.mySearch.value[0]) ok = false;
		else if(!isNaN(this.mySearch.value[1]) && rowValue>this.mySearch.value[1]) ok = false;
	    } else if(filterField.getType()=="date"){
		if(this.mySearch.value &&  Array.isArray(this.mySearch.value)) {
		    if(rowValue == null) {
			ok = false;
		    }  else  {
			var date1 = this.mySearch.value[0];
			var date2 = this.mySearch.value[1];
			var dttm = rowValue.getTime();
			if(isNaN(dttm)) ok = false;
			else if(date1 && dttm<date1.getTime())
			    ok = false;
			else if(date2 && dttm>date2.getTime())
			    ok = false;
		    }
		}
	    } else {
		var startsWith = this.startsWith;
		ok = false;
		roWValue  = String(rowValue).toLowerCase();

		for(var j=0;j<this.mySearch._values.length;j++) {
		    var fv = this.mySearch._values[j];
		    if(startsWith) {
			if(rowValue.toString().startsWith(fv)) {
			    ok = true;
			    break;
			}
		    } else  if(rowValue.toString().indexOf(fv)>=0) {
			ok = true;
			break;
		    }
		}
		
		if(!ok && !startsWith) {
		    for(ri=0;ri<this.mySearch.matchers.length;ri++) {
			var matcher = this.mySearch.matchers[ri];
			if(matcher.matches(rowValue.toString())) {
			    ok = true;
			    break;
			}
		    }
		}
	    }
	    return ok;
	},

	getFieldValues: function() {
	    var element =$("#" + this.display.getDomId("filterby_" + this.field.getId()));
	    var value=null;
	    if(element.attr("isCheckbox")) {
		if(element.is(':checked')) {
		    value = element.attr("onValue");
		} else {
		    value = element.attr("offValue");
		}
	    } else if(element.attr("isButton")) {
		value = element.attr("data-value");
	    } else {
		value = element.val();
	    }
	    if(!value) {
		if(this.defaultValue) value = this.defaultValue;
		else value = FILTER_ALL;
	    }
	    if(!Array.isArray(value)) {
		if(!this.field.isFieldEnumeration()) {
		    value = value.split(",");
		} else {
		    value = [value];
		}
	    }
	    var tmp = [];
	    value.forEach(v=>tmp.push(v.trim()));
	    value = tmp;
	    //	    console.log(this.type +".getFilterFieldValues:" + Array.isArray(value) +" " + value.length +" " +value);
	    return value;
	},
	initWidget: function(inputFunc) {
	    this.initDateWidget(inputFunc);
	},
	initDateWidget: function(inputFunc) {
	    if(!this.hideFilterWidget) {
		for(var i=0;i<this.dateIds.length;i++) {
		    let id = this.dateIds[i];
		    HtmlUtils.datePickerInit(id);
		    $("#" + id).change(function(){
			inputFunc($(this));
		    });
		}
	    }
	},
	checkDependency: function() {
	    if(!this.depend || !this.records || !this.dependMySearch || !this.depend.mySearch || !this.dependMySearch.values || !this.depend.mySearch.values) {
		console.log("no depend:" + this.depend +" " + (this.records!=null) + " " + this.dependMySearch);
		return;
	    }

	    let v1 = this.dependMySearch.values;
	    let v2 = this.depend.mySearch.values;
	    if(v1.length == v2.length) {
		let equals = true;
		for(let i=0;i<v1.length && equals;i++)
		    equals = v1[i] == v2[i];
		if(equals) return;
	    }
            let enums = this.getEnums(this.records);
	    let widgetId = this.getFilterId(filterField.getId());
	    let tmp = [];
	    enums.map(e=>tmp.push(e.value));
	    this.display.ignoreFilterChange = true;
	    let widget = $("#" + widgetId);
	    let val = widget.val();
	    if(!val) val  = 	widget.attr("data-value");
	    widget.html(HU.makeOptions(tmp,val));
	    this.display.ignoreFilterChange = false;
	},
	getWidget: function(fieldMap, bottom,records) {
	    this.records = records;
	    let debug = false;
	    if(debug) console.log(this.id +".getWidget");
	    if(!this.isEnabled()) {
		if(debug) console.log("\tnot enabled");
		return "";
	    }
	    let widgetStyle = "";
	    if(this.hideFilterWidget)
		widgetStyle = "display:none;";
	    let filterField = this.field;
	    fieldMap[filterField.getId()] = {
		field: filterField,
		values:[],
	    };
            let widget;
	    let widgetId = this.widgetId = this.getFilterId(filterField.getId());
            if(this.ops) {
		let labels =[];
		this.ops.forEach((op,idx)=>{
		    labels.push([String(idx),op.label]);
		});

		let selected = this.getPropertyFromUrl(filterField.getId() +".filterValue",FILTER_ALL);
		let showLabel = this.getProperty(filterField.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true));
		let allName = this.getProperty(filterField.getId() +".allName",!showLabel?filterField.getLabel():"All");
		let enums = Utils.mergeLists([[FILTER_ALL,allName]],labels);
		let attrs= [STYLE,widgetStyle, ID,widgetId,"fieldId",filterField.getId()];
		widget = HU.select("",attrs,enums,selected);
	    } else   if(filterField.getType() == "enumeration") {
		if(debug) console.log("\tis enumeration");
		let dfltValue = this.defaultValue = this.getPropertyFromUrl(filterField.getId() +".filterValue",FILTER_ALL);
                let enums = this.getEnums(records);
		let attrs= ["style",widgetStyle, "id",widgetId,"fieldId",filterField.getId()];
		if(this.getProperty(filterField.getId() +".filterMultiple",false)) {
		    attrs.push("multiple");
		    attrs.push("");
		    attrs.push("size");
		    attrs.push(this.getProperty(filterField.getId() +".filterMultipleSize","3"));
		    dfltValue = dfltValue.split(",");
		}

		if(this.displayType!="menu") {
		    if(debug) console.log("\tnot menu");
		    let includeAll = this.getProperty(filterField.getId() +".includeAll",this.getProperty("filter.includeAll", true));
		    if(!includeAll && dfltValue == FILTER_ALL) dfltValue = enums[0].value;
		    let buttons = "";
		    let colorMap = Utils.parseMap(this.getProperty(filterField.getId() +".filterColorByMap"));
		    let useImage = this.displayType == "image";
		    let imageAttrs = [];
		    let imageMap = Utils.getNameValue(this.getProperty(filterField.getId() +".filterImages"));
		    if(useImage) {
			let w = this.getProperty(filterField.getId() +".filterImageWidth");
			let h = this.getProperty(filterField.getId() +".filterImageHeight");
			if(h) {
			    imageAttrs.push("height");
			    imageAttrs.push(h);
			}
			if(w) {
			    imageAttrs.push("width");
			    imageAttrs.push(w);
			}
			if(!h && !w) {
			    imageAttrs.push("width");
			    imageAttrs.push("50");
			}
			
			imageAttrs.push("style");
			imageAttrs.push(this.getProperty(filterField.getId() +".filterImageStyle","border-radius:50%;"));
		    }
		    for(let j=0;j<enums.length;j++) {
			var extra = "";
			var v = enums[j].value;
			var color = colorMap?colorMap[v]:null;
			var label;
			if(Array.isArray(v)) {
			    label = v[1];
			    v = v[0];
			} else {
			    label = v;
			}

			var style = this.getProperty(filterField.getId() +".filterItemStyle","");
			if(color) {
			    style += " background-color:" + color +"; ";
			}
			
			var clazz = " display-filter-item display-filter-item-" + this.displayType +" ";
			if(v == dfltValue) {
			    clazz+=  " display-filter-item-" + this.displayType +"-selected ";
			} else {
			}
			if(v == FILTER_ALL) {
			    extra = " display-filter-item-all ";
			}
			if(useImage) {
			    var image=null;
			    if(imageMap) image = imageMap[v];
			    if(!image || image=="") image = enums[j].image;
			    if(image) {
				buttons+=HtmlUtils.div(["fieldId",filterField.getId(),"class",clazz,"style",style, "data-value",v,"title",label],
						       HtmlUtils.image(image,imageAttrs));
			    } else {
				buttons+=HtmlUtils.div(["fieldId",filterField.getId(),"class",clazz,"style",style,"data-value",v,"title",label],label);
			    }
			} else {
			    buttons+=HtmlUtils.div(["fieldId",filterField.getId(),"class",clazz, "style",style,"data-value",v],label);
			}
			buttons+="\n";
		    }

		    if(useImage && this.getProperty(filterField.getId() +".filterShowButtonsLabel")) {
			buttons+=HtmlUtils.div(["class","display-filter-item-label","id",this.display.getDomId("filterby_" + filterField.getId() +"_label")],"&nbsp;");
		    }
		    bottom[0]+= HtmlUtils.div(["data-value",dfltValue,"class","display-filter-items","id",widgetId,"isButton","true", "fieldId",
					       filterField.getId()], buttons);
		    if(debug) console.log("\treturn 1");
		    return "";
		} else if(this.getProperty(filterField.getId() +".filterCheckbox")) {
		    if(debug) console.log("\tis checkbox");
		    attrs.push("isCheckbox");
		    attrs.push(true);
		    var tmp = [];
		    enums.map(e=>tmp.push(e.value));
		    var checked = tmp.includes(dfltValue);
		    if(tmp.length>0) {
			attrs.push("onValue");
			attrs.push(tmp[0]);
		    }
		    if(tmp.length>1) {
			attrs.push("offValue");
			attrs.push(tmp[1]);
		    }
		    widget = HtmlUtils.checkbox("",attrs,checked);
		    //			    console.log(widget);
		} else {
		    if(debug) console.log("\tis select");
		    let tmp = [];
		    let showCount = this.getProperty(filterField.getId()+".filterShowCount",this.getProperty("filterShowCount",true));
		    enums.map(e=>{
			let count  = e.count;
			let v = e.value;
			let label = v;
			if(Array.isArray(v)) {
			    v = e.value[0];
			    label = e.value[1];
			    if(v == "")
				label = "-blank-";
			}
			if(count) label = label +(showCount?" (" + count+")":"");
			tmp.push([v,label]);
		    }); 
                    widget = HtmlUtils.select("",attrs,tmp,dfltValue);
//Don't think we need this as the label gets set later on
//		    if(this.getProperty(filterField.getId() +".filterLabel")) {
//			widget=HU.vbox([this.getProperty(filterField.getId() +".filterLabel"),widget]);
//		    }
		}
	    } else if(filterField.isNumeric()) {
		if(debug) console.log("\tis numeric");
		var min=0;
		var max=0;
		var cnt=0;
		records.map(record=>{
		    var value = this.display.getDataValues(record)[filterField.getIndex()];
		    if(isNaN(value))return;
		    if(cnt==0) {min=value;max=value;}
		    else {
			min = Math.min(min, value);
			max = Math.max(max, value);
		    }
		    cnt++;
		});
		let tmpMin = this.getPropertyFromUrl(filterField.getId() +".filterValueMin",this.getProperty("filterValueMin"));
		let tmpMax = this.getPropertyFromUrl(filterField.getId() +".filterValueMax",this.getProperty("filterValueMax"));		
		let minStyle = "";
		let maxStyle = "";
		let dfltValueMin = min;
		let dfltValueMax = max;
		if(Utils.isDefined(tmpMin)) {
		    minStyle = "background:" + TEXT_HIGHLIGHT_COLOR+";";
		    dfltValueMin = parseFloat(tmpMin);
		}
		if(Utils.isDefined(tmpMax)) {
		    maxStyle = "background:" + TEXT_HIGHLIGHT_COLOR+";";
		    dfltValueMax = parseFloat(tmpMax);
		}


                widget = HtmlUtils.input("",dfltValueMin,[STYLE,minStyle,"data-min",min,"class","display-filter-range display-filter-input","style",widgetStyle, "id",widgetId+"_min","size",3,"fieldId",filterField.getId()]);
		widget += "-";
                widget += HtmlUtils.input("",dfltValueMax,[STYLE,maxStyle,"data-max",max,"class","display-filter-range display-filter-input","style",widgetStyle, "id",widgetId+"_max","size",3,"fieldId",filterField.getId()]);
	    } else if(filterField.getType() == "date") {
                widget =HtmlUtils.datePicker("","",["class","display-filter-input","style",widgetStyle, "id",widgetId+"_date1","fieldId",filterField.getId()]) +"-" +
		    HtmlUtils.datePicker("","",["class","display-filter-input","style",widgetStyle, "id",widgetId+"_date2","fieldId",filterField.getId()]);
		this.dateIds.push(widgetId+"_date1");
		this.dateIds.push(widgetId+"_date2");
            } else {

		var dfltValue = this.getPropertyFromUrl(filterField.getId() +".filterValue","");
		var attrs =["style",widgetStyle, "id",widgetId,"fieldId",filterField.getId(),"class","display-filter-input"];
		var placeholder = this.getProperty(filterField.getId() +".filterPlaceholder");
		if(placeholder) {
		    attrs.push("placeholder");
		    attrs.push(placeholder);
		}

                widget =HtmlUtils.input("",dfltValue,attrs);
		var values=fieldMap[filterField.getId()].values;
		var seen = {};
		records.map(record=>{
		    var value = this.display.getDataValues(record)[filterField.getIndex()];
		    if(!seen[value]) {
			seen[value] = true;
			values.push(value);
		    }	
		});
            }
	    var label =   this.getProperty(filterField.getId()+".filterLabel",filterField.getLabel()+":");
	    var suffix =   this.getProperty(filterField.getId()+".filterSuffix","");
	    if(!this.hideFilterWidget) {
		var tt = label;
		if(label.length>50) label = label.substring(0,49)+"...";
		if(!this.getProperty(filterField.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true))) {
		    label = "";
		}
		else
		    label = label+" ";
		let vertical = this.getProperty(filterField.getId()+".filterVertical",false)  || this.getProperty("filterVertical",false);


		label = this.display.makeFilterLabel(label,tt);
		widget = HtmlUtils.div(["style","display:inline-block;"],label + (vertical?"<br>":"") + widget+suffix);
	    }
            widget= widget +(this.hideFilterWidget?"":"&nbsp;&nbsp;");
	    return widget;
	},
	getEnums: function(records) {
	    let counts = {};
	    records.forEach((record,idx)=>{
		let v = record.getValue(filterField.getIndex());
		if(!counts[v]) counts[v]=1;
		else   counts[v]++;
	    });

	    let enums = null;
	    let filterValues = this.getProperty(filterField.getId()+".filterValues");
	    let showLabel = this.getProperty(filterField.getId() +".showFilterLabel",this.getProperty("showFilterLabel",true));

	    if (filterValues) {
		let toks;
		if ((typeof filterValues) == "string") {
		    filterValues = Utils.getMacro(filterValues);
		    toks = filterValues.split(",");
		} else {
		    toks = filterValues;
		}
		enums=[];
		toks.map(tok=>{
		    let tmp = tok.split(":");
		    if(tmp.length>1) {
			tok = [tmp[0],tmp[1]];
		    } else if(tok == FILTER_ALL) {
			let allName = this.getProperty(filterField.getId() +".allName",!showLabel?filterField.getLabel():"All");
			tok = [tmp[0],allName];
		    } else {
			tok = [tok,tok];
		    }
		    let count = counts[tok[0]];
		    enums.push({value:tok,count:count});
		})
	    }
	    let includeAll = this.getProperty(filterField.getId() +".includeAll",this.getProperty("filter.includeAll", true));
	    if(enums == null) {
		let depend = this.getProperty(filterField.getId() +".depends");
		if(depend) {
		    depend=this.depend = this.display.getRecordFilter(depend);
		}
		let allName = this.getProperty(filterField.getId() +".allName",!showLabel?filterField.getLabel():"All");
		enums = [];
		if(includeAll && !this.getProperty(filterField.getId() +".filterLabel")) {
		    enums.push({value:[FILTER_ALL,allName]});
		}
		let seen = {};
		let dflt = filterField.getEnumeratedValues();
		if(dflt) {
		    for(let v in dflt) {
			seen[v] = true;
			let count = counts[v];
			enums.push({value:[v,dflt[v]],count:count});
		    }
		}
		let enumValues = [];
		let imageField=this.display.getFieldByType(null, "image");
		let valuesAreNumbers = true;

		if(depend) {
		    depend.prepareToFilter();
		    this.dependMySearch = depend.mySearch;
		}

		records.forEach((record,idx)=>{
		    if(depend) {
			if(!depend.isRecordOk(record,idx<5)) return;
		    }
		    let value = this.display.getDataValues(record)[filterField.getIndex()];
		    if(!seen[value]) {
			seen[value]  = true;
			let obj = {};
			if(imageField)
			    obj.image = this.display.getDataValues(record)[imageField.getIndex()];
			if((+value+"") != value) valuesAreNumbers = false;
			let label = value;
			if(label.length>30) {
			    label=  label.substring(0,29)+"...";
			}
			if(typeof value == "string")
			    value = value.replace(/\'/g,"&apos;");
			let tuple = [value, label];
			obj.value = tuple;
			obj.count =  counts[value];
			enumValues.push(obj);
		    }
		});
		if(this.getProperty(filterField.getId() +".filterSort",true)) {
		    let sortCount = this.getProperty(filterField.getId() +".filterSortCount",true);
		    enumValues.sort((a,b)  =>{
			if(sortCount && a.count && b.count) {
			    if(b.count!=a.count)
				return b.count-a.count;
			}
			a= a.value;
			b = b.value;
			if(valuesAreNumbers) {
			    return +a - +b;
			}
			return (""+a[1]).localeCompare(""+b[1]);
		    });
		}
		for(let j=0;j<enumValues.length;j++) {
		    let v = enumValues[j];
		    enums.push(v);
		}
	    }
	    return enums;
	}
	
    });


    


}




function MonthFilter(param) {
    RamaddaUtil.inherit(this, new BaseFilter());
    RamaddaUtil.defineMembers(this, {
        months: param.split(","),

        recordOk: function(display, record, values) {
            for (i in this.months) {
                var month = this.months[i];
                var date = record.getDate();
                if (date == null) return false;
                if (date.getMonth == null) {
                    //console.log("bad date:" + date);
                    return false;
                }
                if (date.getMonth() == month) return true;
            }
            return false;
        }
    });
}



var ArrayUtil = {
    add: function(v1, v2) {
        if (isNaN(v1) || isNaN(v2)) return NaN;
        return v1 + v2;
    },
    average: function(values) {
        var sum = 0;
        if (values.length == 0) return 0;
        for (var i = 0; i < values.length; i++) {
            sum += values[i];
        }
        return sum / values.length;
    },
    percentIncrease: function(values) {
        var percents = [];
        var sum = 0;
        if (values.length == 0) return 0;
        var lastValue;
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            var incr = NaN;
            if (i > 0 && lastValue != 0) {
                incr = (v - lastValue) / lastValue;
            }
            lastValue = v;
            percents.push(incr * 100);
        }
        return percents;
    },
    movingAverage: function(values, props) {
        if (!props) {
            props = {};
        }
        if (!props.step) props.step = 5;
	if(values.length==0) return values;
        var newValues = [];
        console.log("STEP:" + props.step);
	let tupleGetter = values[0].tuple?v=>{return v.tuple}:v=>{return  v};
	let isNumeric = tupleGetter(values[0]).map((v,idx)=>{return Utils.isNumber(v);});
	dataList.forEach((o,rowIdx)=>{
		    if(rowIdx==0) return;
		    let tuple = Utils.mergeLists(o.tuple);
		    tmp.push({
			record:o.record,
			tuple:tuple});
		    tuple[0] = "x"; tuple[1] = 5;
		    tuple.forEach((v,colIdx)=>{
			if(!isNumeric[colIdx]) return;
			tuple[colIdx]=5;
		    });
		});
		dataList = tmp;



        for (var i = props.step; i < values.length; i++) {
            var total = 0;
            var cnt = 0;
            for (var j = i - props.step; j < i; j++) {
                if (values[j] == values[j]) {
                    total += values[j];
                    cnt++;
                }
            }
            var value = (cnt > 0 ? total / cnt : NaN);
            if (newValues.length == 0) {
                for (var extraIdx = 0; extraIdx < props.step; extraIdx++) {
                    newValues.push(value);
                }
            }
            newValues.push(value);
        }

        console.log("MovingAverage: values:" + values.length + " new:" + newValues.length);
        return newValues;
    },
    expMovingAverage: function(values, props) {
        if (!props) {
            props = {};
        }
        if (!props.step) props.step = 5;
        var sma = ArrayUtil.movingAverage(values, props);
        var mult = (2.0 / (props.step + 1));
        var newValues = [];
        console.log("STEP:" + props.step);
        for (var i = props.step; i < values.length; i++) {
            var total = 0;
            var cnt = 0;
            for (var j = i - props.step; j < i; j++) {
                if (values[j] == values[j]) {
                    total += values[j];
                    cnt++;
                }
            }
            var value = (cnt > 0 ? total / cnt : NaN);
            if (newValues.length == 0) {
                for (var extraIdx = 0; extraIdx < props.step; extraIdx++) {
                    newValues.push(value);
                }
            }
            newValues.push(value);
        }

        console.log("MovingAverage: values:" + values.length + " new:" + newValues.length);
        return newValues;
    },

    max: function(values) {
        var max = NaN;
        for (var i = 0; i < values.length; i++) {
            if (i == 0 || values[i] > max) {
                max = values[i];
            }
        }
        return max;
    },
    min: function(values) {
        var min = NaN;
        for (var i = 0; i < values.length; i++) {
            if (i == 0 || values[i] < min) {
                min = values[i];
            }
        }
        return min;
    },

}

var RecordUtil = {
    groupBy:function(records, display, dateBin, field) {
	let debug = displayDebug.groupBy;
	if(debug) console.log("groupBy");
	let groups ={
	    max:0,
	    values:[],
	    labels:[],
	    map:{},
	}
	records.forEach((r,idx)=>{
	    let key;
	    let label = null;
	    let date = r.getDate();
	    //	    if(debug && idx>0 && (idx%10000)==0) console.log("\trecord:" + idx);
	    if(field) {
		if(field=="latlon") {
		    key = label = r.getLatitude() +"/" + r.getLongitude(); 
		} else {
		    key = label = r.getValue(field.getIndex());
		}
	    } else {
		if(!date) {
		    return;
		}
		key = date;
		if(dateBin===true) {
		    //do the label later
		} else {
		    if(dateBin=="day") {
			key = new Date(label=date.getFullYear()+"-" + date.getUTCMonth() +"-" +date.getUTCDay())
		    } else if(dateBin=="month") {
			label=date.getFullYear()+"-" + date.getUTCMonth();
			key = new Date(label +"-01");
		    } else if(dateBin=="year") {
			label = date.getFullYear();
			key = new Date(date.getFullYear()+"-01-01");
		    } else if(dateBin=="decade") {
			let year = date.getFullYear();
			year = year-year%10;
			label = year+"s";
			key = new Date(year+"-01-01");
		    } else if(dateBin) {
			label = String(key);
		    }
		}
	    }
	    let array = groups.map[key];
	    if(!array) {
		if(debug) console.log("\tadding group:"  + key);
		array = groups.map[key] = [];
		groups.values.push(key);
		if(label==null)
		    label = display.formatDate(date,null,true);
		groups.labels.push(label);
	    }
	    array.push(r);
	    groups.max = Math.max(groups.max, array.length);
	});
	return groups;
    },
    expandBounds: function(bounds, perc) {
	return new RamaddaBounds(
	    Math.min(90,bounds.north +(bounds.north-bounds.south)*perc),
	    Math.max(-180, bounds.west -(bounds.east-bounds.west)*perc),
	    Math.max(-90,bounds.south -(bounds.north-bounds.south)*perc),
	    Math.min(180,bounds.east +(bounds.east-bounds.west)*perc)
	);
    },
    convertBounds: function(bounds) {
	if(!bounds) return null;
	return new RamaddaBounds(bounds);
    },
    subset:function(records,bounds) {
	bounds = RecordUtil.convertBounds(bounds);
	//	console.log("subset:" + JSON.stringify(bounds));
	let cnt = 0;
	records =  records.filter((record,idx)=>{
	    let lat = record.getLatitude?record.getLatitude():record.r?record.r.getLatitude():record.y;
	    let lon = record.getLongitude?record.getLongitude():record.r?record.r.getLongitude():record.x;
	    let ok =   lat<= bounds.north &&
		lat>= bounds.south &&
		lon>= bounds.west &&
		lon<= bounds.east;
	    return ok;
	});
	return records;
    },
    getRanges: function(fields, records) {
        var maxValues = [];
        var minValues = [];
        for (var i = 0; i < fields.length; i++) {
            maxValues.push(NaN);
            minValues.push(NaN);
        }

        for (var row = 0; row < records.length; row++) {
            for (var col = 0; col < fields.length; col++) {
                var value = records[row].getValue(col);
                if (isNaN(value)) continue;
                maxValues[col] = (isNaN(maxValues[col]) ? value : Math.max(value, maxValues[col]));
                minValues[col] = (isNaN(minValues[col]) ? value : Math.min(value, minValues[col]));
            }
        }

        var ranges = [];
        for (var col = 0; col < fields.length; col++) {
            ranges.push([minValues[col], maxValues[col]]);
        }
        return ranges;
    },



    getElevationRange: function(fields, records) {
        var maxValue = NaN;
        var minValue = NaN;

        for (var row = 0; row < records.length; row++) {
            if (records[row].hasElevation()) {
                var value = records[row].getElevation();
                maxValue = (isNaN(maxValue) ? value : Math.max(value, maxValue));
                minValue = (isNaN(minValue) ? value : Math.min(value, minValue));
            }
        }
        return [minValue, maxValue];
    },


    slice: function(records, index) {
        var values = [];
        for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
            var row = records[rowIdx];
            if (row.getValue) {
                values.push(row.getValue(index));
            } else {
                values.push(row[index]);
            }
        }
        return values;
    },


    sort: function(fields) {
        fields = fields.slice(0);
        fields.sort(function(a, b) {
            var s1 = a.getSortOrder();
            var s2 = b.getSortOrder();
            return s1 < s2;
        });
        return fields;
    },
    getPoints: function(records, bounds) {
	let points = [];
	this.getBounds(records, bounds,points);
	return points;
    },
    getBounds: function(records, bounds,points) {
	bounds = bounds||{};
        if (records == null) {
	    return bounds;
	}
        var north = NaN,
            west = NaN,
            south = NaN,
            east = NaN;
	let errorCnt = 0;
        for (j = 0; j < records.length; j++) {
            var record = records[j];
            if (!isNaN(record.getLatitude()) && !isNaN(record.getLongitude())) {
                if (j == 0) {
                    north = record.getLatitude();
                    south = record.getLatitude();
                    west = record.getLongitude();
                    east = record.getLongitude();
                } else {
                    north = Math.max(north, record.getLatitude());
                    south = Math.min(south, record.getLatitude());
                    west = Math.min(west, record.getLongitude());
                    east = Math.max(east, record.getLongitude());
                }
                if (record.getLongitude() < -180 || record.getLatitude() > 90) {
		    //		    if(errorCnt++<50)
		    //			console.log("bad location: index=" + j + " " + record.getLatitude() + " " + record.getLongitude());
                }
		if(points)
                    points.push(new OpenLayers.Geometry.Point(record.getLongitude(), record.getLatitude()));
            }
        }
        bounds.north = north;
        bounds.west = west;
        bounds.south = south;
        bounds.east = east;
        return new RamaddaBounds(bounds);
    },

    findClosest: function(records, lon, lat, indexObj) {
        if (records == null) return null;
        var closestRecord = null;
        var minDistance = 1000000000;
        var index = -1;
        for (j = 0; j < records.length; j++) {
            var record = records[j];
            if (isNaN(record.getLatitude())) {
                continue;
            }
            var distance = Math.sqrt((lon - record.getLongitude()) * (lon - record.getLongitude()) + (lat - record.getLatitude()) * (lat - record.getLatitude()));
            if (distance < minDistance) {
                minDistance = distance;
                closestRecord = record;
                index = j;
            }
        }
        if (indexObj != null) {
            indexObj.index = index;
        }
        return closestRecord;
    },
    clonePoints: function(points) {
        var result = [];
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            result.push(new OpenLayers.Geometry.Point(point.x, point.y));
        }
        return result;
    }
};


function CsvUtil() {
    let eg = "convertData=\"derived(field=field_id, function=population*10);\nrotateData(includeFields=true,includeDate=true,flipColumns=true);\naddPercentIncrease(replaceValues=false);\"\n";
    $.extend(this, {
	process: function(display, pointData, cmds) {
	    this.display = display;
	    let theCmd;
	    try {
		let commands = DataUtils.parseCommands(cmds);
		commands.map(cmd=>{
		    theCmd =cmd;
		    if(this[cmd.command]) {
			let orig = pointData;
    			pointData = this[cmd.command](pointData, cmd.args);
			if(!pointData) pointData=orig;
			else pointData.entryId = orig.entryId;
		    } else {
			console.log("unknown command:" + cmd.command);
		    }
		});
	    } catch(e) {
		console.log("Error applying derived function:" + theCmd.command);
		console.log(e);
	    }
	    return pointData;
	},
	help: function(pointData, args) {
	    console.log(eg);
	    return null;
	},
	furlData: function(pointData, args) {
	    /** TODO
		let records = pointData.getRecords(); 
		let header = this.display.getDataValues(records[0]);
		var newRecords  =[];
		var newFields = [];
		var lastRecord = dataList[dataList.length-1];
		var fields  = pointData.getRecordFields();
		var newData  =[];
		newData.push(["label","value"]);
		//		dataList.map(r=>{
		fields.map((f,idx)=>{
		let row = [f.getLabel(),lastRecord.getValue(f.getIndex())];
		newData.push();
		});
		pointData = convertToPointData(newData);
		pointData.entryId = originalPointData.entryId;
	    **/
	},
	derived: function(pointData, args) {
	    let records = pointData.getRecords(); 
	    let fields =  pointData.getRecordFields();
	    let newFields =  fields.slice();
	    let newRecords  =[];
	    let id = args["field"] || ("field_" + fields.length);
            newFields.push(new RecordField({
		id:id,
		index:fields.length,
		label:Utils.makeLabel(id),
		type:"double",
		chartable:true,
		unit: args.unit
            }));
	    let func = args["function"];
	    if(!func) {
		console.log("No func specified in derived");
		return null;
	    }
	    func = func.replace(/_nl_/g, "\n").replace(/_semi_/g,";");
	    if(func.indexOf("return")<0) {
		func = "return " + func;
	    }
            let setVars = "";
            fields.forEach((field,idx)=>{
		if(/*field.isFieldNumeric() && */field.getId()!="") {
		    let varName = field.getId().replace(/^([0-9]+)/g,"v$1");
		    setVars += "\tvar " + varName + "=displayGetFunctionValue(args[\"" + field.getId() + "\"]);\n";
		}
            });

            let code = "function displayDerivedEval(args) {\n" + setVars +  func + "\n}";
//	    console.log(code);

            eval(code);
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.data= record.data.slice();
		newRecord.fields =  newFields;
		newRecords.push(newRecord);
		let funcArgs = {};
		fields.map((field,idx)=>{
		    if(/*field.isFieldNumeric() &&*/ field.getId()!="") {
			funcArgs[field.getId()] = record.getValue(field.getIndex());
		    }
		});
		try {
		    let value = displayDerivedEval(funcArgs);
		    newRecord.data.push(value);
		} catch(exc) {
		    console.log("Error processing derived:" + exc);
		    newRecord.data.push(NaN);
		}
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	rotateData: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
	    let rotated = [];
	    for(var colIdx=0;colIdx<header.length;colIdx++) {
		rotated.push([]);
	    }
	    let includeFields =args["includeFields"] == "true";
	    let includeDate = args["includeDate"] == "true";
	    let flipColumns =args["flipColumns"]=="true";
	    let fields = pointData.getRecordFields();
	    if (!flipColumns && includeFields) {
                fields.map((f,colIdx)=>{
		    if(f.isRecordDate()) return;
		    rotated[colIdx].push(colIdx==0?args["fieldName"]||"Field":f.getLabel());
		});
	    }
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.display.getDataValues(records[rowIdx]);
		for(var colIdx=0;colIdx<row.length;colIdx++) {
		    let field = fields[colIdx];
		    if(field.isRecordDate()) {
			continue;
		    }
		    var value = row[colIdx];
		    if(value.f) value = value.f;
		    if(value.getTime) {
			value = this.display.formatDate(value);
		    }
		    if(!includeFields && rowIdx==0 && colIdx==0) value="";

		    if(flipColumns)
			rotated[colIdx].unshift(value);
		    else
			rotated[colIdx].push(value);
		}
            }
	    if (flipColumns && includeFields) {
                fields.map((f,colIdx)=>{
		    if(f.isRecordDate()) return;
		    rotated[colIdx].unshift(colIdx==0?args["fieldName"]||"Field":f.getLabel());
		});
	    }
	    return  convertToPointData(rotated);
	},
	addPercentIncrease: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let firstRecord= records[0];
	    let replaceValues = args["replaceValues"]=="true";
	    let newFields = [];
	    let fieldOk = f=>{
		return !f.isFieldGeo() && f.isNumeric();
	    };
	    fields.forEach((f,fieldIdx)=>{
		f = f.clone();
		let newField = f.clone();
		f.index = newFields.length;
		if(!fieldOk(newField)) {
		    newFields.push(f);
		    return;
		}
		if(!replaceValues) {
		    newFields.push(f);
		}
		newField.unit = "%";
		newField.index = newFields.length;
		newField.id = newField.id +"_percent";
		newField.label = newField.label+" % increase";
		newFields.push(newField);
	    });
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
//	    newFields.forEach((f,fieldIdx)=>{
//		if(fieldIdx>3) return;
//		console.log("F:" + f.getLabel() +" " + f.index);
//	    });
	    records.forEach((record, rowIdx)=>{
		let data = [];
		let newRecord = record.clone();
		newRecord.data=data;
		newRecord.fields =newFields;
		newRecords.push(newRecord);
		fields.forEach((f,fieldIdx)=>{
		    let value = record.data[f.getIndex()];
		    if(!fieldOk(f)) {
			if(rowIdx==records.length-1) {
	//		    console.log(f +" ==" +  value);
			}
			data.push(value);
			return;
		    }
		    if(!replaceValues) {
			data.push(value);
		    }
		    if(rowIdx==0) {
			data.push(0);
		    } else {
			let basev = firstRecord.data[f.getIndex()];
			let perc = basev==0?0:(value-basev)/basev;
			data.push(perc);
			if(rowIdx==records.length-1) {
//			    console.log(f +" =" + basev +" " + value +" perc:" + perc);
			}
		    }
		}); 
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	addBearing: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let newRecords  =[];
	    let newFields = [];
	    fields.forEach((f,fieldIdx)=>{
		f = f.clone();
		newFields.push(f);
	    });
	    let bearingField = new RecordField();
	    newFields.push(new RecordField({
		id:"bearing",
		index:newFields.length,
		label:"Bearing",
		type:"double",
		chartable:true,
	    }));
	    let pervPoint;
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.fields =newFields;
		newRecords.push(newRecord);
		let bearing = NaN;
		if(prevPoint) {
		    let point = {lat:newRecord.getLatitude(),lon: newRecord.getLongitude()};
		    bearing  = Utils.getBearing(prevPoint, point);
		    prevPoint = point;
		}
		newRecord.data.push(bearing);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	cut: function(pointData, args) {
	    let cut  = args.fields?args.fields.split(","):[];
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    let newFields = [];
	    let newRecords = [];
	    let indices = [];
	    fields.forEach((f,fieldIdx)=>{
//		console.log(f.getId());
		if(cut.indexOf(f.getId())>=0) return;
		f = f.clone();
		let newField = f.clone();
		indices.push(newField.index);
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    records.forEach((record, rowIdx)=>{
		let newRecord = record.clone();
		newRecord.fields =newFields;
		let data= newRecord.data;
		let newData=[];
		indices.forEach(i=>{
		    newData.push(data[i]);
		});
		newRecord.data = newData;
		newRecords.push(newRecord);
	    });
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	doAverage: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let header = this.display.getDataValues(records[0]);
            let fields  = pointData.getRecordFields();
	    var newRecords  =[];
	    var newFields = [];
	    var firstRow = records[0];
	    fields.forEach(f=>{
		var newField = f.clone();
		newFields.push(newField);
		newField.label = newField.label+" (avg)";
	    });
	    var sums=[];
	    fields.forEach(f=>{sums.push(0)});
	    var newRecord;
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		if(newRecord==null) {
		    newRecord = record.clone();
		    newRecords.push(newRecord);
		    newRecord.fields =newFields;
		    newRecord.parentRecords=[];
		}
		newRecord.parentRecords.push(record);
		fields.forEach((f,idx)=>{
		    if(!f.isNumeric()) return;
		    var v = record.data[f.getIndex()];
		    sums[idx]+=v;
		});
		fields.map((f,idx)=>{
		    if(!f.isNumeric()) return;
		    newRecord.data[idx] = sums[idx]/records.length;
		});
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	noop: function(pointData, args) {
	    return pointData;
	},
	doublingRate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields =  this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    let keyFields =  this.display.getFieldsByIds(allFields, (args.keyFields||"").replace(/_comma_/g,","));
	    let newRecords  =[]
	    let newFields = Utils.cloneList(allFields);
	    fields.map(f=>{
		if(!f.isNumeric()) return;
		let newField = f.clone();
		newField.id = newField.id+"_doubling";
		newField.unit = "days";
		newField.label = newField.label+" doubling";
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    let keys = [];
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		let key = "";
		keyFields.forEach(f=>{
		    key+="_"+record.getValue(f.getIndex());
		});
		keys.push(key);
	    }

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		let key = keys[rowIdx];
		newRecords.push(newRecord);
		newRecord.fields =newFields;
		fields.map((f,idx)=>{
		    if(!f.isNumeric()) return;
		    let v = record.getValue(f.getIndex());
		    let v2 = NaN;
		    let lastDate = null;
		    for (var j=rowIdx-1; j>=0; j--) {
			if(keyFields.length>0) {
			    let key2 = keys[j];
			    if(key!=key2) continue;
			}
			let record2 = records[j];
			v2 = record2.getValue(f.getIndex());
			if(v>=v2*2) {
			    lastDate  = record2.getDate();
			    break;
			}
		    }
		    let diff = NaN;
		    if(lastDate) {
			diff = (record.getDate().getTime()-lastDate.getTime())/1000/60/60/24;
		    }
		    newRecord.data.push(diff);
		});
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	scaleAndOffset: function(pointData,args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let unit = args.unit;
	    let scale = args.scale?parseFloat(args.scale):1;
	    let offset1 = args.offset1?parseFloat(args.offset1):0;
	    let offset2 = args.offset?parseFloat(args.offset):args.offset2?parseFloat(args.offset2):0;	    	    
	    let newRecords  =[]
	    let newFields = [];
	    let changedFields = {};
	    fields.forEach(f=>{changedFields[f.getId()]  =true});
	    allFields.map(f=>{
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) {
		    return;
		}
		if(changedFields[newField.getId()]) {
		    newField.unit = unit;
		}
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			d  = (d + offset1) * scale + offset2;
			newData[f.getIndex()]=d;
		    }
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	scaleAndOffset: function(pointData,args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let unit = args.unit;
	    let scale = args.scale?parseFloat(args.scale):1;
	    let offset1 = args.offset1?parseFloat(args.offset1):0;
	    let offset2 = args.offset?parseFloat(args.offset):args.offset2?parseFloat(args.offset2):0;	    	    
	    let newRecords  =[]
	    let newFields = [];
	    let changedFields = {};
	    fields.forEach(f=>{changedFields[f.getId()]  =true});
	    allFields.map(f=>{
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) {
		    return;
		}
		if(changedFields[newField.getId()]) {
		    newField.unit = unit;
		}
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			d  = (d + offset1) * scale + offset2;
			newData[f.getIndex()]=d;
		    }
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	accum: function(pointData, args) {
	    let records = pointData.getRecords(); 

            let allFields  = pointData.getRecordFields();
	    let fields;
	    let suffix = args.suffix!=null?args.suffix:"_accum";
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    let totals =[];
	    allFields.map(f=>{
		totals.push(0);
		let newField = f.clone();
		newFields.push(newField);
		if(!f.isNumeric()) return;
		newField.id = newField.id+suffix;
		newField.label = newField.label+suffix;
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			let x = d;
			totals[f.getIndex()]+=d;
			d = totals[f.getIndex()];
		    }
		    newData[f.getIndex()] = d;
		});
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	mean: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    allFields.map(f=>{
		newFields.push(f.clone());
	    });
	    newFields.push(new RecordField({
		id:"mean",
		index:newFields.length,
		label:"Mean",
		type:"double",
		chartable:true,
	    }));

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let newRecord = record.clone();
		newRecords.push(newRecord);
		let data = record.getData();
		let newData=Utils.cloneList(data);
		let total = 0;
		let fieldCnt = 0;
		fields.forEach(f=>{
		    if(!f.isNumeric()) return;
		    fieldCnt++;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			total+=d;
		    }
		});
		newData.push(total/fieldCnt);
		newRecord.setData(newData);
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},

	prune: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let allFields  = pointData.getRecordFields();
	    let fields;
	    if(args.fields)
		fields = this.display.getFieldsByIds(allFields, (args.fields||"").replace(/_comma_/g,","));
	    else 
		fields = allFields;
	    let newRecords  =[]
	    let newFields = [];
	    allFields.map(f=>{
		newFields.push(f.clone());
	    });
	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
		let data = record.getData();
		let newData=Utils.cloneList(data);
		let ok = false;
		let fieldCnt= 0;
		fields.every(f=>{
		    if(!f.isNumeric()) return true;
		    fieldCnt++;
		    let d = data[f.getIndex()];
		    if(!isNaN(d)) {
			ok = true;
			return false;
		    }
		    return true;
		});
		if(ok)  {
		    let newRecord = record.clone();
		    newRecord.setData(newData);
		    newRecords.push(newRecord);
		}
	    }
	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


	mergeRows: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let op = args.operator || "count";
	    let ops = {};
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    let altFields =  this.display.getFieldsByIds(fields, (args.altFields||"").replace(/_comma_/g,","));
	    let newFields = [];
	    let seen = {};
	    keyFields.forEach((f,idx)=>{
		seen[f.getId()] = true;
		let newField = f.clone();
		newField.index = newFields.length;
		newFields.push(newField);
	    });
	    let tmp =  this.display.getFieldsByIds(fields, (args["valueFields"]||"").replace(/_comma_/g,","));
	    if(args.valueFields==null) tmp=fields;
	    let valueFields = [];


	    tmp.forEach(f=>{
		if(!seen[f.getId()]) {
		    ops[f.getId()] = args[f.getId()+".operator"];
		    valueFields.push(f);
		}
	    });

	    valueFields.forEach((f,idx)=>{
		var newField = f.clone();
		newField.index = newFields.length;
		if(newField.isNumeric()) {
		    let label = args[newField.id+".label"];
		    newField.id = newField.id +"_" + (ops[f.getId()+".operator"] || op);
		    newField.label = label || Utils.makeLabel(newField.id);
		}
		newFields.push(newField);
	    });
	    //	    console.log("key fields:" + keyFields);
	    //	    console.log("value fields:" + valueFields);
	    if(op == "count") {
		newFields.push(new RecordField({
		    id:"count",
		    index:newFields.length,
		    label:"Count",
		    type:"double",
		    chartable:true,
		}));
	    }
//	    console.log("fields:" + newFields);
	    let keys = [];
	    let collection ={
	    };

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		let key = "";
		keyFields.forEach(f=>{
		    let v = record.getValue(f.getIndex());
		    if(v=="" && altFields.length>0) {
			altFields.forEach(f2=>{
			    v+=record.getValue(f1.getIndex()) +"-";
			});
		    }
		    key +=v+"-";
		});
		let obj = collection[key];
		if(!obj) {
		    keys.push(key);
		    obj = collection[key]= {
			count:0,
			sums: [],
			mins: [],
			maxs:[],
			records:[]
		    };
		    valueFields.forEach((f,idx)=>{
			obj.sums.push(0);
			obj.mins.push(NaN);
			obj.maxs.push(NaN);
		    });
		}
		valueFields.forEach((f,idx)=>{
		    let v = record.getValue(f.getIndex());
		    if(f.isNumeric() && !isNaN(v)) {
			obj.sums[idx]+=v;
			obj.mins[idx] = isNaN(obj.mins[idx])?v:Math.min(obj.mins[idx],v);
			obj.maxs[idx] = isNaN(obj.maxs[idx])?v:Math.max(obj.maxs[idx],v);
		    }
		});
		obj.count++;
		obj.records.push(record);
	    }
	    let newRecords = [];
	    let cnt = 0;
	    keys.forEach((key,idx)=>{
		let obj = collection[key];
		let data =[];
		let seen = {};
		let date = obj.records[0].getDate();
		let bounds = RecordUtil.getBounds(obj.records);
		let lat =  bounds.south+(bounds.north-bounds.south)/2;
		let lon =  bounds.west+(bounds.east-bounds.west)/2;
		if(key.indexOf("US")>=0) {
		    cnt++;
		    if(cnt==1) {
			//			console.log(obj.records.length +" " +bounds.west +" " + bounds.east +" " + lat  +" " +lon);
			obj.records.forEach(r=>{
			    //			    console.log(r.getValue(0) + " " + r.getLatitude() +" " + r.getLongitude())
			});
		    }
		}
		keyFields.forEach(f=>{
		    let v = obj.records[0].getValue(f.getIndex());
		    data.push(v);
		    seen[f.getId()]=true;
		});
		valueFields.forEach((f,idx)=>{
		    if(seen[f.getId()]) return;
		    if(!f.isNumeric()) {
			data.push(obj.records[0].getValue(f.getIndex()));
		    } else {
			if(op == "sum") 
			    data.push(obj.sums[idx]);
			else if(op == "average") 
			    data.push(obj.sums[idx]/obj.count);
			else if(op == "min") 
			    data.push(obj.mins[idx]);
			else if(op == "max") 
			    data.push(obj.maxs[idx]);
		    }
		});
		if(op == "count") {
		    data.push(obj.count);
		}
		let newRecord = new  PointRecord(newFields,lat,lon, NaN, date, data);
		newRecords.push(newRecord);
	    });

	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},
	maxDate: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let keyFields =  this.display.getFieldsByIds(fields, (args.keyFields||"").replace(/_comma_/g,","));
	    let seen = {};
	    let keys = [];
	    let collection ={
	    };

	    for (var rowIdx=0; rowIdx <records.length; rowIdx++) {
		var record = records[rowIdx];
		let key = "";
		keyFields.forEach(f=>{
		    key +=  record.getValue(f.getIndex())+"-";
		});
		let obj = collection[key];
		if(!obj) {
		    keys.push(key);
		    obj = collection[key]= {
			records:[]
		    };
		}
		obj.records.push(record);
	    }
	    let newRecords = [];
	    let cnt = 0;
	    keys.forEach((key,idx)=>{
		let records = collection[key].records;
		let maxRecord = null;
		let maxDate = null;
		records.forEach(r=>{
		    if(maxRecord==null || r.getDate().getTime()>maxDate) {
			maxDate = r.getDate().getTime();
			maxRecord = r;
		    }
		});
		newRecords.push(maxRecord);
	    });

	    return   new  PointData("pointdata", fields, newRecords,null,{parent:pointData});
	},

	unfurl: function(pointData, args) {
	    let records = pointData.getRecords(); 
            let fields  = pointData.getRecordFields();
	    let headerField =  this.display.getFieldById(fields, args.headerField||"");
	    let uniqueField =  this.display.getFieldById(fields, args.uniqueField||"");
	    let valueFields =  this.display.getFieldsByIds(fields, args.valueFields||"");
	    let includeFields =  this.display.getFieldsByIds(fields, args.includeFields||"");
	    let prefix = args.prefix||"";
	    if(!headerField) throw new Error("No headerField");
	    let uniqueIsDate = false;
	    if(!uniqueField) {
		if(args.uniqueField=="date") {
		    uniqueIsDate = true;
		} else {
		    throw new Error("No uniqueField");
		}
	    }
	    if(valueFields.length==0) throw new Error("No value fields");
	    /*
	      newFields.push(new RecordField({
	      id:"count",
	      index:newFields.length,
	      label:"Count",
	      type:"double",
	      chartable:true,
	      }));
	    */
	    let newColumns = [];
	    let newColumnMap = {};
	    let uniqueToRecords = {};
	    let rowMap = {};
	    let uniques = [];
	    let indexMap={};
	    records.forEach(record=>{
		let unfurlValue = record.getValue(headerField.getIndex());
		let uniqueValue = uniqueIsDate?record.getDate():record.getValue(uniqueField.getIndex());
		if(!newColumnMap[unfurlValue]) {
                    newColumnMap[unfurlValue] = true;
                    if (valueFields.length > 1) {
                        valueFields.forEach(f=>{
                            let label = unfurlValue + " - "
                                + f.getLabel();
                            newColumns.push(label);
                        });
                    } else {
			newColumns.push(unfurlValue);
		    }
		}
                let rowGroup    = rowMap[uniqueValue];
                if (rowGroup == null) {
                    rowMap[uniqueValue] =  rowGroup = [];
                    uniques.push(uniqueValue);
                }
                rowGroup.push(record);
	    });

	    //In case the new colum labels are numbers
	    newColumns.sort((a,b)=>{
		if(typeof a =="number" &&  typeof b =="number") {
		    return a-b;
		}
		return (""+a).localeCompare(""+b);
	    });
            newColumns.forEach((v,idx) => {
                indexMap[v] = idx;
            });

	    let newRecords = [];
	    let newFields = [];
	    let uniqueType = "string";
	    if(uniques[0]) {
		if(uniques[0].getTime)
		    uniqueType ="date";
		else if(typeof uniques[0] =="number")
		    uniqueType ="double";
		    
	    }
	    if(uniqueIsDate)
		newColumns = Utils.mergeLists(["date"], newColumns);
	    else
		newColumns = Utils.mergeLists([uniqueField.getId()], newColumns);
	    newColumns.forEach((c,idx)=>{
		if(idx>0)
		    c = prefix+""+c;
		else
		    c = ""+c;
		let label =Utils.makeLabel(c);
		let id  = Utils.makeId(c);
		let type = (idx==0?uniqueType:"double");
		newFields.push(new RecordField({
		    id:id,
		    index:newFields.length,
		    label:label,
		    type:type,
		    chartable:true,
		}));
	    });
	    uniques.forEach(u=>{
		let array = [];
		newColumns.forEach(c=>{
		    array.push("");
		});
                array[0] = u;
                let  includeCnt = 0;
                let rowValues  = null;
                let firstRow   = null;
                cnt = 0;
                rowMap[u].forEach(row=>{
                    if (firstRow == null) {
                        firstRow = row;
                    }
                    let colname = row.getValue(headerField.getIndex());
                    if (valueFields.length > 1) {
                        valueFields.forEach(f=>{
                            let label = colname + " - "  + f.getId();
                            let idx = indexMap[label];
                            if (idx == null) {
				return;
                            }
                            let value =  row.getValue(valueIndex);
                            array[1 + includeFields.length + idx] = value;
                        });
		    } else {
                        let idx = indexMap[colname];
                        if (idx == null) {
			    return;
                        }
                        let    valueIndex = valueFields[0].getIndex();
                        let value = row.getValue(valueIndex);
                        array[1 + includeFields.length + idx] = value;
                    }
                    cnt++;
		});

                includeFields.forEach(f=>{
                    array[1 + includeCnt] = firstRow.getValue(f.getIndex());
                    includeCnt++;
                });
		let newRecord = new  PointRecord(newFields,firstRow.getLatitude(),firstRow.getLongitude(), NaN, null, array);
//		console.log("lat:" + firstRow.getLatitude());
		newRecords.push(newRecord);
                cnt++;
            });
 	    return   new  PointData("pointdata", newFields, newRecords,null,{parent:pointData});
	},


    });
}




var DataUtils = {
    getCsv: function(fields, records, filename) {
	let csv = "";
	fields.forEach((f,idx)=>{
	    if(idx>0) csv+=",";
	    csv+=f.getId();
	});
	csv+="\n";
	records.forEach(r=>{
	    fields.forEach((f,idx)=>{
		let v = r.getValue(f.getIndex());
		if(v && v.getTime) {
		    v  =Utils.formatDateYYYYMMDDHHMM(v);
		} else {
		    v = String(v);
		}
		if(idx>0) csv+=",";
		let needToQuote = v.indexOf("\n")>=0 || v.indexOf(",")>=0;
		if(v.indexOf("\"")>=0) {
		    needToQuote = true;
		    v = v.replace(/\"/g,"\"\"");
		}
		if(needToQuote) {
		    v = "\"" + v +"\"";
		}
		csv+=v;
	    });
	    csv+="\n";
	});
	Utils.makeDownloadFile(filename, csv);
    },
    getJson: function(fields, records, filename) {
	let json = [];
	records.forEach(r=>{
	    let obj = {};
	    json.push(obj);
	    fields.forEach((f,idx)=>{
		let v = r.getValue(f.getIndex());
		if(v && v.getTime) {
		    v  =Utils.formatDateYYYYMMDDHHMM(v);
		} else {
		    v = String(v);
		}
		obj[f.getId()] = v;
	    });
	});
	Utils.makeDownloadFile(filename, JSON.stringify(json,null,2));
    },


    parseCommands: function(commands) {
	let result = [];
	if(!commands) return result;
	commands.split(";").forEach(command=>{
	    command = command.trim();
	    let idx=command.indexOf("(");
	    let args = {};
	    if(idx>=0) {
		let rest = command.substring(idx+1).trim();
		command = command.substring(0,idx).trim();
		if(rest.endsWith(")")) rest = rest.substring(0,rest.length-1);
		let toks = [];
		let inQuote = false;
		let escape = false;
		let tok = "";
		for(let i=0;i<rest.length;i++) {
		    let c = rest[i];
		    if(c=="\\") {
			escape=true;
			continue;
		    }
		    if(escape) {
			tok += c;
			escape=false;
			continue;
		    }
		    if(c=="\'") {
			if(!inQuote) {
			    inQuote = true;
			} else {
			    inQuote = false;
			}
			tok += c;
			continue;
		    }
		    if(c == ",") {
			if(inQuote) {
			    tok += c;			    
			    continue;
			}
			toks.push(tok);
			tok = "";
			continue;
		    }
		    tok += c;			    
		}
		toks.push(tok);
		toks.forEach(arg=>{
		    arg =arg.trim();
		    let value = "";
		    let atoks = arg.match(/(.*)=(.*)/);
		    if(atoks) {
			arg=atoks[1];
			value= atoks[2];
		    }
		    arg = arg.trim();
		    value = value.trim();
		    //		    console.log("arg:" + arg +" v:" + value);
		    //Strip off quotes
		    value = value.replace(/^'/g,"").replace(/'$/g,"");
		    if(arg!="") {
			args[arg] = value;
		    }
		});
	    }
	    if(command!="") {
		result.push({command:command,args:args});
	    }
	});
	return result;
    },
    getDataFilters: function(display, prop) {
	let filters = [];
	if(!prop) return filters;
	let baseId = display.getId();
	let cnt = 0;
	DataUtils.parseCommands(prop).map(cmd=>{
	    let filterId = baseId+"_" + (cnt++);
	    let [type,fieldId,value,enabled,label,expr]  = [cmd.command,cmd.args.field,cmd.args.value,cmd.args.enabled,cmd.args.label,cmd.args.expr];
	    if(!Utils.isDefined(enabled))
		enabled = true;
	    else {
		enabled = enabled.trim()=="true" || enabled.trim()=="";
	    }
	    if(label) {
		var cbx =  display.jq("datafilterenabled_" + filterId);
		if(cbx.length) {
		    enabled = cbx.is(':checked');
		} 
	    }
	    if(type=="match" || type=="notmatch")
		value = new RegExp(value);
	    else
		value = +value;
	    let fields = null;
	    if(cmd.args.fields) {
		fields = display.getFieldsByIds(null, cmd.args.fields.replace(/:/g,","));
	    }
	    let allFields = display.getData().getRecordFields();
	    let field = display.getFieldById(null,fieldId);
	    filters.push({
		id:filterId,
		props:cmd.args,
		type:type.trim(),
		field:field,
		fields:fields?fields:field?[field]:null,
		allFields:allFields,
		value:value,
		label:label,
		enabled: enabled,
		expr:expr,
		isRecordOk: function(r) {
		    if(!this.enabled) {
			return true;
		    }
		    let value = this.field?r.getValue(this.field.getIndex()):NaN;
		    if(this.type == "match") {
			return String(value).match(this.value);
		    } else if(this.type == "nomissing") {
			let fieldsToUse =null;
			if(this.fields) {
			    fieldsToUse = this.fields;
			} else if(this.field) {
			    fieldsToUse = [this.field];
			} else {
			    fieldsToUse = r.fields;
			}
			let ok = false;
			fieldsToUse.some(f=>{
			    if(field && !(field.isFieldLatitude() || f.isFieldLongitude()))
				if(f.isFieldLatitude() || f.isFieldLongitude()) return true;
			    if(f.isNumeric()) {
				let v  = r.getValue(f.getIndex());
				//				console.log("V:" + v);
				ok  =!isNaN(v);
			    }
			    return ok;
			});
			//			if(!ok) 
			//			    console.log("****** V:" +value + " v:" + this.value);
			return ok;
		    } else if(this.type == "notmatch") {
			return  !String(value).match(this.value);
		    } else if(this.type == "lessthan") {
			return  value<this.value;
		    } else if(this.type == "greaterthan") {
			return  value>this.value;
		    }  else if(this.type == "equals") {
			return  value==this.value;
		    }  else if(this.type == "notequals") {
			return value!=this.value;
		    }  else if(this.type == "bounds") {
			let lat =  r.getLatitude();
			let lon =  r.getLongitude();
			if(this.props.north && lat>+this.props.north) return false;
			if(this.props.south && lat<+this.props.south) return false;
			if(this.props.west && lon<+this.props.west)   return false;
			if(this.props.east && lon>+this.props.east) {return false;}
			return true;
		    }  else if(this.type == "eval") {
			//return true;
			//assume its inline code
			let code = "function dataFilterCall(){\n";
			this.allFields.every(f=>{
			    let value = r.getValue(f.getIndex());
			    if(typeof value == "string") value = "'" + value +"'";
			    else if(typeof value != "number") value = "'" + value +"'";
			    code+=f.getId() +"=" + value+";\n"
			    return true;
			});
			let expr = this.expr;
			if(expr == null) throw "No expr given in data filter";
			if(expr.indexOf("return")<0)  expr  = " return " + expr;
			code+=expr+"\n}\n";
			code +="var dataFilterValue = dataFilterCall();\n";
			eval(code);
			return dataFilterValue;
		    } else {
			console.log("Unknown filter:" + this.type);
			return true;
		    }

		}
	    });
	});
	return filters;
    },
}


function RequestMacro(display, macro) {
    this.display = display;
    let values = null;
    let enums = this.getProperty("request." +macro+".values");
    if(enums) {
	values =[]	
	let includeAll = false;
	if(this.getProperty("request." + macro+".includeAll",this.getProperty("request.includeAll",false))) {
	    values.push(["","All"]);
	    includeAll = true;
	}
	if(this.getProperty("request." + macro+".includeNone",false)) {
	    values.push(["","None"]);
	}
	enums.split(",").forEach(tok=>{
	    let toks = tok.split(":");
	    let id = toks[0];
	    let label = toks[1];
	    if(!includeAll && id=="_all_") return;
	    values.push([id,label||id]);
	});
    }

    let macroType = this.getProperty("request." +macro+".type",values!=null?"enumeration":macro=="bounds"?"bounds":"string");
    //    console.log(macro +" type:" + macroType +" v:" + values);
    let dflt =this.getProperty("request." +macro+".default",null);
    if(dflt == null) {
	if(values && values.length>0  && macroType=="enumeration") {
	    dflt = values[0][0];
	} else {
	    dflt = "";
	}
    }
    if(dflt && macroType=="enumeration") {
	if(dflt.split)	dflt = dflt.split(",");
    }

    $.extend(this,{
	name: macro,
	values:values,
	urlarg: this.getProperty("request." +macro+".urlarg",macro),
	type:macroType,
	triggerReload:this.getProperty("request." +macro+".triggerReload",true),
	dflt:dflt,
	dflt_from:this.getProperty("request." +macro+"_from.default",""),		    
	dflt_to:this.getProperty("request." +macro+"_to.default",""),
	dflt_min:this.getProperty("request." +macro+"_min.default",""),		    
	dflt_max:this.getProperty("request." +macro+"_max.default",""),
	label:this.getProperty("request." +macro+".label",Utils.makeLabel(macro)),
	multiple:this.getProperty("request." +macro+".multiple",false),
	template:this.getProperty("request." +macro+".template"),
	multitemplate:this.getProperty("request." +macro+".multitemplate"),
	nonetemplate:this.getProperty("request." +macro+".nonetemplate"),		
	delimiter:this.getProperty("request." +macro+".delimiter"),
	rows:this.getProperty("request." +macro+".rows",3),
    });
}


RequestMacro.prototype = {
    getProperty: function(prop, dflt)   {
	return this.display.getProperty(prop, dflt);
    },
    isVisible: function() {
	return  this.getProperty("request." +this.name +".visible",
				 this.getProperty("macros.visible",true));
    },
    getWidget: function(dateIds) {
	let debug = false;
	let visible = this.isVisible();
	let style = visible?"":"display:none;";
	let widget;
	let label = this.label;
	if(debug)console.log(this.getId() +".getWidget:" + label +" type:" + this.type);
	if(this.type=="bounds") {
	    widget = HU.checkbox("",[ID,this.display.getDomId(this.getId())], false) +HU.span([CLASS,"display-request-reload",TITLE,"Reload with current bounds"], " In bounds");
	    label = null;
	} else if(this.type=="enumeration") {
 	    if(this.values && this.values.length>0) {
		let attrs = [STYLE, style, ID,this.display.getDomId(this.getId()),CLASS,"display-filter-input"];
		let values = this.values;
		if(this.dflt) {
		    let first = [];
		    let rest = [];
		    values.forEach(v=>{
			if(this.dflt.indexOf(v[0])>=0)  first.push(v);
			else rest.push(v);
		    });
		    values = Utils.mergeLists(first,rest);
		}

		if(this.multiple) {
		    attrs.push("multiple");
		    attrs.push(null);
		    attrs.push("size");
		    attrs.push(Math.min(this.rows,values.length));
		    console.log("m:" + attrs);
		}
		if(debug)
		    console.log("\tselect: dflt:" + this.dflt +" values:" + this.values);
		
		widget = HU.select("",attrs,values,this.dflt,20);
	    }
	} else if(this.type=="numeric") {
	    let minId = this.display.getDomId(this.getId()+"_min");
	    let maxId = this.display.getDomId(this.getId()+"_max");			    
	    widget = HU.input("","",["data-min", this.dflt_min, STYLE, style, ID,minId,"size",4,CLASS,"display-filter-input display-filter-range"],this.dflt_min) +
		" - " +
		HU.input("","",["data-max", this.dflt_max, STYLE, style, ID,maxId,"size",4,CLASS,"display-filter-input display-filter-range"],this.dflt_max)
	    label = label+" range";
	} else if(this.type=="date") {
	    let fromId = this.display.getDomId(this.getId()+"_from");
	    let toId = this.display.getDomId(this.getId()+"_to");
	    dateIds.push(fromId);
	    dateIds.push(toId);
	    widget = HU.datePicker("",this.dflt_from,[CLASS,"display-filter-input",STYLE, style, "name","",ID,fromId]) +
		" - " +
		HU.datePicker("",this.dflt_to,[CLASS,"display-filter-input",STYLE, style, "name","",ID,toId])
	    label = label+" range";
	} else {
	    let size = "10";
	    if(this.type=="number")
		size = "4";
	    widget = HU.input("",this.dflt,[STYLE, style, ID,this.display.getDomId(this.getId()),"size",size,CLASS,"display-filter-input"]);
	}
	if(!widget) return "";
	return (visible?this.display.makeFilterWidget(label,widget):widget);
    },
    isMacro: function(id) {
	return id == this.name;
    },
    getId: function() {
	return "macro_" + this.name;
    },
    getValue: function() {
	let widget = this.display.jq(this.getId());
	let value = this.dflt;
	if(widget.length!=0) {
	    value =  widget.val();
	}
	this.display.setProperty("request." + this.name+".default",value);
	//	console.log(this.getId() +".getValue=" + value);
	return value;
    },
    setValue: function(prop) {
	let id = this.getId();
	if(prop.what == "min")
	    this.display.jq(i+"_min").val(prop.value);
	else if(prop.what == "max")
	    this.display.jq(id+"_max").val(prop.value);
	else if(prop.what == "from")
	    this.display.jq(id+"_from").val(prop.value);
	else if(prop.what == "to")
	    this.display.jq(id+"_to").val(prop.value);
	else {
	    console.log(this.type +" macroChanged:" + prop.value +" " + this.display.jq(id).length);
	    this.display.jq(id).val(prop.value);
	    console.log("after:" + this.display.jq(id).val());
	}
    },
    apply: function(url) {
	if(this.type == "bounds") {
	    if(this.display.getBounds && this.display.jq(this.getId()).is(':checked')) {
		let bounds = this.display.getBounds();
		if(bounds) {
		    bounds = RecordUtil.convertBounds(bounds);
		    ["north","south","east","west"].map(b=>{
			url+="&" + b+"=" +bounds[b];
		    });
		    
		}
	    }
	} else if(this.type=="numeric") {
	    let min = this.display.jq(this.getId()+"_min").val()||"";
	    let max = this.display.jq(this.getId()+"_max").val()||"";
	    this.dflt_min = min;
	    this.dflt_max = max;
	    if(min!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_from",min);
	    if(max!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_to",max);
	    this.display.setProperty("request." +this.name+"_min.default",min);
	    this.display.setProperty("request." +this.name+"_max.default",max);

	} else if(this.type=="date") {
	    let from = this.display.jq(this.getId()+"_from").val()||"";
	    let to = this.display.jq(this.getId()+"_to").val()||"";
	    this.dflt_from = from;
	    this.dflt_to = to;
	    this.display.setProperty("request." +this.name+"_from.default",from);
	    this.display.setProperty("request." +this.name+"_to.default",to);
	    if(from!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_fromdate",from);
	    if(to!="")
		url = url +"&" + HU.urlArg(this.urlarg+"_todate",to);
	    //			    this.display.setProperty(this.name+".default",value);
	} else if(this.type=="enumeration") {
	    let value = this.getValue();
	    if(!Array.isArray(value)) {value=[value];}
	    if(value[0] == "_all_" || value[0] == "_none_") return url;
	    if(value.length>0) {
		let regexp = new RegExp(this.urlarg+"=[^$&]*",'g');
		url = url.replace(regexp,"");
		let values = [];
		value.forEach(v=>{
		    if(this.template) v = this.template.replace(/\${value}/,v);
		    values.push(v);
		});
		if(this.delimiter) {
		    let arg = "";
		    values.forEach((v,idx)=>{
			if(idx>0) arg+=this.delimiter;
			arg+=v;
		    });
		    if(this.multitemplate && values.length>1) {
			arg =this.multitemplate.replace(/\${value}/,arg);
		    }
		    url = url +"&" + HU.urlArg(this.urlarg,arg);
		} else {
		    values.forEach(v=>{
			url = url +"&" + HU.urlArg(this.urlarg,v);
		    });
		}
	    } else {
	    }
	} else {
	    let value = this.getValue();
	    this.dflt  = value;
	    if(value!="") {
		let regexp = new RegExp(this.urlarg+"=[^$&]*",'g');
		url = url.replace(regexp,"");
		url = url +"&" + HU.urlArg(this.urlarg,value);
	    }
	}
	return  url;
    }

}



function RamaddaBounds(north,west,south,east) {
    if(Utils.isDefined(north.north)) {
	let b = north;
	this.north = b.north;
	this.west  = b.west;
	this.south  =b.south;
	this.east = b.east;
    } else if(Utils.isDefined(north.top)) {
	let b = north;
	this.north = b.top;
	this.west  = b.left;
	this.south  =b.bottom;
	this.east = b.right
    }  else { 
	this.north = north;
	this.west  = west;
	this.south  =south;
	this.east = east;
    }
    $.extend(this,{
	toString: function() {
	    return "N:" + this.north +" W:" + this.west +" S:" + this.south +" E:" + this.east;
	}
    });
	      
}


function makeInlineData(display, src) {
    let csv = $("#"+src).html().trim();
    let lines = csv.split("\n");
    let fields = [];
    let samples = lines[1].split(",");
    let latField  =null, lonField=null,dateField=null;
    lines[0].split(",").forEach((tok,idx)=>{
	tok = tok.trim();
	let id = Utils.makeId(tok);
	let label = Utils.makeLabel(tok);
	let type = "string";
	let sample = samples[idx];
	if(display.getProperty(id+".label")) {
	    label =display.getProperty(id+".label");
	}
	if(display.getProperty(id+".type")) {
	    type =  display.getProperty(id+".type");
	    if(type=="enum") type = "enumeration";
	} else {
	    if(id=="date") {
		type="date";
	    } else {
		if(!isNaN(parseFloat(sample))) type = "double";
		//check for numeric
	    }
	}
	let field = new RecordField({
            id:tok,
	    index:idx,
            label:label,
            type:type,
            chartable:true
        });
	fields.push(field);
	if(field.isFieldLatitude()) latField = field;
	else if(field.isFieldLongitude()) lonField = field;
    });
    let records =[];
    lines.forEach((line,idx)=>{
	if(idx==0) return;
	line = line.trim();
	if(line.length==0) return;
	let data =[];
	let lat = NaN;
	let lon = NaN;
	let date = null;
	line.split(",").forEach((tok,col)=>{
	    tok  = tok.replace(/_nl_/g,"\n").replace(/_qt_/g,"\"").replace(/_comma_/g,",");
	    let field = fields[col];
	    if(latField && latField.getIndex()==col) {
		lat = tok = parseFloat(tok);
	    } else  if(lonField && lonField.getIndex()==col) {
		lon = tok = parseFloat(tok);
	    } else  if(dateField && dataField.getIndex()==col) {
		date = tok = new Data(tok);
	    } else {
		if(field.isFieldNumeric()) {
		    tok = parseFloat(tok);
		}
	    }
	    data.push(tok);
	});
	//PointRecord(fields,lat, lon, elevation, time, data)
        records.push(new  PointRecord(fields,lat, lon, NaN, date, data));
    });
    return  new PointData(src, fields, records,"#" + src);
}
/**
   Copyright 2008-2019 Geode Systems LLC
*/


const DISPLAY_LINECHART = "linechart";
const DISPLAY_AREACHART = "areachart";
const DISPLAY_BARCHART = "barchart";
const DISPLAY_BARTABLE = "bartable";
const DISPLAY_BARSTACK = "barstack";
const DISPLAY_PIECHART = "piechart";
const DISPLAY_TIMERANGECHART = "timerangechart";
const DISPLAY_SANKEY = "sankey";
const DISPLAY_CALENDAR = "calendar";
const DISPLAY_SCATTERPLOT = "scatterplot";
const DISPLAY_HISTOGRAM = "histogram";
const DISPLAY_BUBBLE = "bubble";
const DISPLAY_GAUGE = "gauge";
const DISPLAY_TABLE = "table";
const DISPLAY_WORDTREE = "wordtree";
const DISPLAY_TREEMAP = "treemap";
const ID_CHART = "chart";
const ID_CHARTS = "charts";
const ID_CHARTS_INNER = "chartsinner";


var googleChartsLoaded = false;
function googleChartsHaveLoaded() {
    googleChartsLoaded = true;
}
if(window["google"]) {
    google.charts.setOnLoadCallback(googleChartsHaveLoaded);
}

function haveGoogleChartsLoaded() {
    if (!googleChartsLoaded) {
        if (Utils.isDefined(google.visualization)) {
            if (Utils.isDefined(google.visualization.Gauge)) {
                googleChartsLoaded = true;
            }
        }
    }
    return googleChartsLoaded;
}

function waitOnGoogleCharts(object, callback) {
    if (haveGoogleChartsLoaded()) {
	return true;
    }
    if (!object.googleChartCallbackPending) {
        object.googleChartCallbackPending = true;
        var func = function() {
            object.googleChartCallbackPending = false;
            callback();
        }
        setTimeout(func, 100);
    }
    return false;
}


addGlobalDisplayType({
    type: DISPLAY_TABLE,
    label: "Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    desc:"Basic tabular display",
    tooltip: makeDisplayTooltip("Tabular display of data","table.png")                        
}, true);
addGlobalDisplayType({
    type: DISPLAY_LINECHART,
    label: "Line Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip("Basic line chart","linechart.png","Show time series or other data"),
    helpurl:true
});
addGlobalDisplayType({
    type: DISPLAY_BARCHART,
    label: "Bar Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"barchart.png")    
});
addGlobalDisplayType({
    type: DISPLAY_BARSTACK,
    label: "Stacked Bar Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip("Stacked bar chart","barstack.png"),
    helpurl:true    
});
addGlobalDisplayType({
    type: DISPLAY_AREACHART,
    label: "Area Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"areachart.png")    
});

addGlobalDisplayType({
    type: DISPLAY_BARTABLE,
    label: "Bar Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"bartable.png")        
});
addGlobalDisplayType({
    type: DISPLAY_SCATTERPLOT,
    label: "Scatter Plot",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"scatterplot.png")            
});
addGlobalDisplayType({
    type: DISPLAY_HISTOGRAM,
    label: "Histogram",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"histogram.png")                
});
addGlobalDisplayType({
    type: DISPLAY_BUBBLE,
    label: "Bubble Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"bubblechart.png")    
});
addGlobalDisplayType({
    type: DISPLAY_PIECHART,
    label: "Pie Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"piechart.png")                    
});

addGlobalDisplayType({
    type: DISPLAY_GAUGE,
    label: "Gauge",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("A gauge","gauge.png")
});
addGlobalDisplayType({
    type: DISPLAY_TIMERANGECHART,
    label: "Timerange",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Time ranges","timerange.png","Show data with start/end times")    
});
addGlobalDisplayType({
    type: DISPLAY_SANKEY,
    label: "Sankey Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"sankey.png")                                    
});

addGlobalDisplayType({
    type: DISPLAY_CALENDAR,
    label: "Calendar Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Show a calendar","calendar.png")
});
addGlobalDisplayType({
    type: DISPLAY_WORDTREE,
    label: "Word Tree",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Displays data as a tree of words","wordtree.png","Specify a number of fields. Each field value is a level in the tree")    
});
addGlobalDisplayType({
    type: DISPLAY_TREEMAP,
    label: "Tree Map",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip("A tree map","treemap.png")    
});



var PROP_CHART_MIN = "chartMin";
var PROP_CHART_MAX = "chartMax";
var DFLT_WIDTH = "600px";
var DFLT_HEIGHT = "200px";

/*
  Create a chart
  id - the id of this chart. Has to correspond to a div tag id 
  pointData - A PointData object (see below)
*/
function RamaddaGoogleChart(displayManager, id, chartType, properties) {
    const ID_TRENDS_CBX = "trends_cbx";
    const ID_PERCENT_CBX = "percent_cbx";
    const ID_COLORS = "colors";
    const ID_HIGHLIGHTFIELDSHOLDER = "highlightfieldsholder";
    const ID_HIGHLIGHTFIELDS = "highlightfields";	    
    var _this = this;
    //Init the defaults first
    $.extend(this, {
	debugChartOptions:false,
	useTestData:false,	
        indexField: -1,
        curveType: 'none',
        fontSize: 0,
        showPercent: false,
        percentFields: null,
    });
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, chartType, properties);
    let myProps = [
	{label:'Chart Style'},
	{p:'highlightFields',d:null,ex:'fields'},
	{p:'highlightShowFields',d:null,ex:'true'},
	{p:'highlightShowFieldsSize',d:"4",ex:'4'},
	{p:"acceptHighlightFieldsEvent",d:true,ex:'true'},
	{p:'highlightDim',d:'true',ex:'true',tt:'Dim the non highlight lines'},

	{p:'lineDashStyle',d:null,ex:'2,2,20,2,20'},
	{p:'highlight.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},
	{p:'nohighlight.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},	
	{p:'some_field.lineDashStyle',d:'2,2,20,2,20',ex:'2,2,20,2,20'},

	{p:'labelInLegend',d:null,ex:'label'},
	{p:'highlight.labelInLegend',d:null,ex:'label'},
	{p:'nohighlight.labelInLegend',d:null,ex:'label'},	
	{p:'some_field.labelInLegend',d:null,ex:'label'},

	{p:'seriesType',d:null,ex:'line|area|bars'},
	{p:'highlight.seriesType',d:null,ex:'line|area|bars'},
	{p:'nohighlight.seriesType',d:null,ex:'line|area|bars'},	
	{p:'some_field.seriesType',d:null,ex:'line|area|bars'},	

	{p:'pointSize',d:null,ex:'0'},
	{p:'highlight.pointSize',d:'0',ex:'4'},
	{p:'nohighlight.pointSize',d:'0',ex:'4'},	
	{p:'some_field.pointSize',d:'4',ex:'4'},

	{p:'lineWidth',d:null,ex:null},
	{p:'highlight.lineWidth',d:null,ex:'2'},
	{p:'nohighlight.lineWidth',d:null,ex:'2'},	
	{p:'some_field.lineWidth',d:'2',ex:'2'},

	{p:'highlight.color',d:null,ex:null},
	{p:'nohighlight.color',d:null,ex:null},
	{p:'some_field.color',d:null,ex:null},

	{p:'pointShape',d:null,ex:null},
	{p:'highlight.pointShape',d:null,ex:null},
	{p:'nohighlight.pointShape',d:null,ex:null},	
	{p:'some_field.pointShape',d:null,ex:null},

	{label:'Trendlines'},
	{p:'showTrendline',d:null,ex:"true"},
	{p:"trendlineType",ex:"exponential"},
	{p:"trendlineVisibleInLegend",ex:"true"},
	{p:"trendlineColor",ex:""},
	{p:"trendlineLineWidth",ex:"true"},
	{p:"trendlineOpacity",ex:"0.3"}		    		    		    
    ];


    defineDisplay(this, SUPER, myProps, {
	useDisplayMessage:function() {
	    return true;
	},
	//Override so we don't include the expandable class
	getContentsClass: function() {
	    return "display-contents-inner display-" + this.type;
	},

        useChartableFields: function() {
            return true;
        },
        defaultSelectedToAll: function() {
            return false;
        },
        updateUI: function(args) {
	    let debug = false;
	    args = args || {};
            SUPER.updateUI.call(this, args);
	    if(debug)
		console.log(this.type+".updateUI")
            if (!this.getDisplayReady()) {
		if(debug)
		    console.log("\tdisplay not ready");
                return;
            }
	    if(debug)
		console.log("\tcalling displayData");
	    if(args.dataFilterChanged) {
		this.setDisplayMessage("Creating display...");
		setTimeout(()=>{
		    this.displayData(args.reload, debug);
		},1);
		return;
	    }
            this.displayData(args.reload, debug);
        },
        getWikiAttributes: function(attrs) {
            this.defineWikiAttributes(["vAxisMinValue", "vAxisMaxValue"]);
            SUPER.getWikiAttributes.call(this, attrs);
            if (this.colorList.join(",") != "blue,red,green") {
                attrs.push("colors");
                attrs.push(this.getColorList().join(", "));
            }
        },

        initDialog: function() {
            SUPER.initDialog.call(this);
            var _this = this;
            var updateFunc = function(e) {
                if (e && e.which != 13 && e.which!=0) {
                    return;
                }
                _this.vAxisMinValue = Utils.toFloat(_this.jq("vaxismin").val());
		//		console.log("vaxis:" + _this.vAxisMinValue + " " + this.getVAxisMinValue());
                _this.vAxisMaxValue = Utils.toFloat(_this.jq("vaxismax").val());
                _this.minDate = _this.jq("mindate").val();
                _this.maxDate = _this.jq("maxdate").val();
                _this.displayData();

            };
	    ["vaxismin","vaxismax","mindate","maxdate"].map(f=>{
		this.jq(f).blur(updateFunc);
		this.jq(f).keypress(updateFunc);
	    });



            this.jq(ID_COLORS).keypress(function(e) {
                if (e.which != 13) {
                    return;
                }
                var v = _this.jq(ID_COLORS).val();
                _this.colorList = v.split(",");
                _this.displayData();
                var pointData = _this.dataCollection.getList();
                _this.getDisplayManager().handleEventPointDataLoaded(_this, _this.lastPointData);
            });

            this.jq(ID_TRENDS_CBX).click(function() {
                _this.showTrendLines = _this.jq(ID_TRENDS_CBX).is(':checked');
                _this.displayData();

            });
            this.jq(ID_PERCENT_CBX).click(function() {
                _this.showPercent = _this.jq(ID_PERCENT_CBX).is(':checked');
                _this.displayData();

            });

        },
        setColor: function() {
            var v = prompt("Enter comma separated list of colors to use", this.colorList.join(","));
            if (v != null) {
                this.colorList = v.split(",");
                this.displayData();
                var pointData = this.dataCollection.getList();
                this.getDisplayManager().handleEventPointDataLoaded(this, this.lastPointData);
            }
        },
        getVAxisMinValue: function() {
            return parseFloat(this.getProperty("vAxisMinValue", NaN));
        },
        getVAxisMaxValue: function() {
            return parseFloat(this.getProperty("vAxisMaxValue", NaN));
        },
	getHAxisMinValue: function() {
            return parseFloat(this.getProperty("hAxisMinValue", NaN));
        },
        getHAxisMaxValue: function() {
            return parseFloat(this.getProperty("hAxisMaxValue", NaN));
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            var get = this.getGet();
            //                menuItems.push(HU.onClick(get+".setColor();", "Set color"));

            var min = "0";
            if (!isNaN(this.getVAxisMinValue())) {
                min = "" + this.getVAxisMinValue();
            }
            var max = "";
            if (!isNaN(this.getVAxisMaxValue())) {
                max = "" + this.getVAxisMaxValue();
            }

            var tmp = HU.formTable();
            tmp += HU.formEntry("Axis Range:", HU.input("", min, ["size", "7", ATTR_ID, this.domId("vaxismin")]) + " - " +
				HU.input("", max, ["size", "7", ATTR_ID, this.domId("vaxismax")]));
            tmp += HU.formEntry("Date Range:", HU.input("", this.minDate, ["size", "10", ATTR_ID, this.domId("mindate")]) + " - " +
				HU.input("", this.maxDate, ["size", "10", ATTR_ID, this.domId("maxdate")]));


            tmp += HU.formEntry("Colors:",
				HU.input("", this.getColorList().join(","), ["size", "35", ATTR_ID, this.domId(ID_COLORS)]));
            tmp += "</table>";
            menuItems.push(tmp);

        },
        getChartType: function() {
            return this.getType();
        },
        askMinZAxis: function() {
            this.setMinZAxis(prompt("Minimum axis value", "0"));
        },
        setMinZAxis: function(v) {
            if (v != null) {
                this.vAxisMinValue = parseFloat(v);
                this.displayData();
            }
        },
        askMaxZAxis: function() {
            this.setMaxZAxis(prompt("Maximum axis value", "100"));
        },
        setMaxZAxis: function(v) {
            if (v != null) {
                this.vAxisMaxValue = parseFloat(v);
                this.displayData();
            }
        },
        askMinDate: function() {
            var ex = this.minDate;
            if (ex == null || ex == "") {
                ex = "1800-01-01";
            }
            var v = prompt("Minimum date", ex);
            if (v == null) return;
            this.setMinDate(v);
        },
        setMinDate: function(v) {
            this.minDate = v;
            this.displayData();
        },
        askMaxDate: function() {
            var ex = this.maxDate;
            if (ex == null || ex == "") {
                ex = "2100-01-01";
            }
            var v = prompt("Maximum date", ex);
            if (v == null) return;
            this.setMaxDate(v);
        },
        setMaxDate: function(v) {
            this.maxDate = v;
            this.displayData();
        },
        trendLineEnabled: function() {
            return false;
        },
        getDialogContents: function(tabTitles, tabContents) {
            var height = "600";
            var html = HU.div([ATTR_ID, this.domId(ID_FIELDS), STYLE, HU.css('overflow-y','auto','max-height', height + "px")], " FIELDS ");
            if (this.trendLineEnabled()) {
                html += HU.div([ATTR_CLASS, "display-dialog-subheader"], "Other");

                html += HU.checkbox(this.domId(ID_TRENDS_CBX),
				    [],
				    this.getProperty("showTrendLines", false)) + "  " + "Show trend line";
                html += " ";
                html += HU.checkbox(this.domId(ID_PERCENT_CBX),
				    [],
				    this.showPercent) + "  " + "Show percent of displayed total" + "<br>";
                html += "<br>";
            }

            tabTitles.push("Fields");
            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },
        okToHandleEventRecordSelection: function() {
            return true;
        },
        handleEventRecordHighlight: function(source, args) {
	    this.handleEventRecordSelection(source, args);
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
            //TODO: don't do this in index space, do it in time or space space
            if (source == this) {
                return;
            }
            if (!this.okToHandleEventRecordSelection()) {
                return;
	    }
	    var index = this.findMatchingIndex(args.record).index
	    if(index<0 || !Utils.isDefined(index)) {
		return;
	    }
	    this.setChartSelection(index);
        },
        getFieldsToSelect: function(pointData) {
            //STRING return pointData.getChartableFields();
	    return pointData.getRecordFields();
        },
        canDoGroupBy: function() {
            return false;
        },
        clearCache: function() {
        },
        googleChartCallbackPending: false,
        includeIndexInData: function() {
            return false;
        },
        getGroupBy: function() {
            return this.getProperty("groupByField");
        },
        getIncludeIndexIfDate: function() {
            return false;
        },
	makeIndexValue: function(indexField, value, offset) {
	    if(indexField.isString()) {
		return  {v:offset,f:value};
	    } 
	    if(value && value.getTime) {
		return  {v:value,f:this.formatDate(value)}
	    }
	    return value;
	},
	getFieldsToDisplay: function(fields) {
	    return fields;
	},

        displayData: function(reload, debug) {
	    if(debug)
		console.log(this.type +" displayData " + this.getId() +" " + this.type);

	    let isExpanded = this.jq(ID_CHART).attr("isexpanded");
	    let originalHeight = this.jq(ID_CHART).attr("original-height");
	    if(isExpanded==="true") {
		this.setProperty("expandedHeight",this.jq(ID_CHART).css("height"));
		this.setProperty("isExpanded",true);
		this.setProperty("originalHeight",originalHeight);
	    } else {
		this.setProperty("expandedHeight",null);
		this.setProperty("isExpanded",false);
		this.setProperty("originalHeight",null);
	    }
            if (!this.getDisplayReady()) {
		if(debug)
		    console.log("\tdisplay not ready");
                return;
            }
            if (this.inError) {
		if(debug)
		    console.log("\tin error");
                return;
            }
            if (!haveGoogleChartsLoaded()) {
		if(debug)
		    console.log("\tgoogle charts have not loaded callback pending:" +this.googleChartCallbackPending);
                if (!this.googleChartCallbackPending) {
                    this.googleChartCallbackPending = true;
		    this.setDisplayMessage(this.getLoadingMessage());
                    setTimeout(()=> {
                        this.googleChartCallbackPending = false;
                        this.displayData();
                    }, 10000);
                }
                return;
            }
            if (this.inError) {
                return;
            }
            if (!this.hasData()) {
                this.clearChart();
		this.setDisplayMessage(this.getLoadingMessage());
                return;
            }

	    if(!this.getAcceptEventDataSelection()) {
		this.setDisplayMessage("Creating display...");
	    }

	    if(debug)
		console.log("\tpointData #records:" +(!pointData?"NULL": pointData.getRecords().length));


            //            var selectedFields = this.getSelectedFields(this.getFieldsToSelect(pointData));
	    let records =this.filterData();
            let selectedFields = this.getSelectedFields();
	    if(debug)
		console.log("\tselectedFields:" + selectedFields);

            if (selectedFields.length == 0 && this.lastSelectedFields != null) {
                selectedFields = this.lastSelectedFields;
		if(debug)
		    console.log("\tusing last selectedFields:" + selectedFields);
            }


            if (selectedFields == null || selectedFields.length == 0) {
                if (this.getChartType() == DISPLAY_TABLE || this.getChartType() == DISPLAY_TREEMAP) {
                    selectedFields = this.dataCollection.getList()[0].getNonGeoFields();
		    if(debug)
			console.log("\tfields from data collection:" + selectedFields);
                } else {
                    selectedFields = this.getSelectedFields();
		    if(debug)
			console.log("\tgetSelectedFields again:" + selectedFields);
		    
                    selectedFields = this.getSelectedFields();
		    if(selectedFields.length==0) {
			this.getFields().every(f=>{
			    if(f.isNumeric() && !f.isFieldGeo()) {
				selectedFields = [f];
				return false;
			    }
			    return true;
			});

		    }
                }
            }


            if (selectedFields.length == 0) {
		if(!this.getAcceptEventDataSelection()) {
//                    this.setContents("No fields selected");
		    this.setDisplayMessage("No fields selected");
		}
                return;
            }

            //Check for the skip
            var tmpFields = [];
            for (var i = 0; i < selectedFields.length; i++) {
                if (!this.shouldSkipField(selectedFields[i])) {
                    tmpFields.push(selectedFields[i]);
                }
            }
            selectedFields = tmpFields;
	    if(debug)
		console.log("\tsetting lastSelectedFields:" + selectedFields);
            this.lastSelectedFields = selectedFields;
	    //Do this here because the title, if displayed, may hold a {field} macro
	    //that doesn't get set before we've loaded the data
	    if(this.lastSelectedFields && this.lastSelectedFields.length>0) {
		this.jq(ID_TITLE_FIELD).html(this.lastSelectedFields[0].getLabel());
	    }

            var props = {
                includeIndex: this.includeIndexInData()
            };
            props.groupByIndex = -1;

            var groupBy = this.getGroupBy();
            if (groupBy) {
		this.getFields().every(field=>{
                    if (field.getId() == groupBy) {
                        props.groupByIndex = field.getIndex();
                        props.groupByField = field;
			return false;
                    }
		    return true;
                });
            }

            var fieldsToSelect = selectedFields;
            if (this.raw) {
                fieldsToSelect = this.dataCollection.getList()[0].getRecordFields();
                props.raw = true;
            }

            props.includeIndexIfDate = this.getIncludeIndexIfDate();

            var dataHasIndex = props.includeIndex;

	    var t1= new Date();
            let dataList = this.getStandardData(this.getFieldsToDisplay(fieldsToSelect), props);
	    var t2= new Date();
//	    Utils.displayTimes("chart.getStandardData",[t1,t2],true);
	    if(debug)
		console.log(this.type +" fields:" + fieldsToSelect.length +" dataList:" + dataList.length);
            if (dataList.length == 0 && !this.userHasSelectedAField) {
                var pointData = this.dataCollection.getList()[0];
                var chartableFields = this.getFieldsToSelect(pointData);
                for (var i = 0; i < chartableFields.length; i++) {
                    var field = chartableFields[i];
                    dataList = this.getStandardData([field], props);
                    if (dataList.length > 0) {
                        this.setSelectedFields([field]);
                        break;
                    }
                }
            }

            if (dataList.length == 0) {
                this.setDisplayMessage(this.getNoDataMessage());
                return;
            }

            if (this.showPercent) {
                var newList = [];
                var isNumber = [];
                var isOk = [];
                var headerRow = null;
                var fields = null;
                if (this.percentFields != null) {
                    fields = this.percentFields.split(",");
                }
                for (var i = 0; i < dataList.length; i++) {
                    var row = this.getDataValues(dataList[i]);
                    if (i == 0) {
                        headerRow = row;
                        continue;
                    }
                    if (i == 1) {
                        var seenIndex = false;
                        for (var j = 0; j < row.length; j++) {
                            var valueIsNumber = (typeof row[j] == "number");
                            var valueIsDate = (typeof row[j] == "object");
                            if (valueIsNumber) {
                                if (dataHasIndex && !seenIndex) {
				    valueIsNumber = false;
                                    seenIndex = true;
                                }
                            }
                            if (valueIsDate) {
                                seenIndex = true;
                            }
                            if (valueIsNumber && fields != null) {
                                valueIsNumber = fields.indexOf(fieldsToSelect[j].getId()) >= 0 ||
                                    fields.indexOf("#" + (j + 1)) >= 0;
                            }
                            isNumber.push(valueIsNumber);
                        }
                        var newHeader = [];
                        for (var j = 0; j < headerRow.length; j++) {
                            var v = headerRow[j];
                            if (!isNumber[j]) {
                                newHeader.push(v);
                            } else {
                                newHeader.push("% " + v);
                            }
                        }
                        newList.push(newHeader);
                    }

                    var total = 0;
                    var cnt = 0;
                    for (var j = 0; j < row.length; j++) {
                        if (isNumber[j]) {
                            total += parseFloat(row[j]);
                            cnt++;
                        }
                    }
                    var newRow = [];
                    for (var j = 0; j < row.length; j++) {
                        if (isNumber[j]) {
                            if (total != 0) {
                                var v = parseFloat(((row[j] / total) * 100).toFixed(1));
                                newRow.push(v);
                            } else {
                                newRow.push(NaN);
                            }
                        } else {
                            newRow.push(row[j]);
                        }
                    }
                    newList.push(newRow);
                }
                dataList = newList;
            }
            try {
		this.clearDisplayMessage();
                this.makeGoogleChart(dataList, props, selectedFields);
            } catch (e) {
		console.log(this.type+" Error making chart:\n" + e +"\n" + e.stack);
                return;
            }
            var container = this.jq(ID_CHART);
	    if(this.jq(ID_CHART).is(':visible')) {
		this.lastWidth = container.width();
	    } else {
		this.lastWidth = -1;
	    }

	    if(reload) {
		var pointData = this.getData();
		if(pointData) {
		    let dataList = pointData.getRecords();
		    if(dataList.length>0) {
			let record = dataList[0];
			this.propagateEventRecordSelection({record: record});
		    }
		}
	    }
        },
        printDataList: function(dataList) {
            console.log("data list:" + dataList.length);
            for (var i = 0; i < dataList.length; i++) {
                var row = dataList[i];
                var s = "";
                for (var j = 0; j < row.length; j++) {
                    if (j > 0) s += ", ";
                    s += row[j];
                }
                console.log("row: " + i + "  " + s);
            }
        },
	mapCharts: function(func) {
            if (this.charts != null) {
		this.charts.map(chart=>{
		    func(chart);
		});
	    }
	},
        clearChart: function() {
	    this.mapCharts(chart=>{
		if(chart.clearChart) {
		    chart.clearChart();
		}
	    });
        },
        setChartSelection: function(index) {
	    this.mapCharts(chart=>{
                if (chart.setSelection) {
		    chart.setSelection([{
                        row: index,
			column:null
		    }]);
		}});
        },
        tableHeaderMouseover: function(i, tooltip) {},
	getAddToolTip: function() {
	    return true;
	},
	getAddStyle: function() {
	    return true;
	},
	getAnnotationTemplate: function() {
	    return this.getProperty("annotationTemplate");
	},
	getFormatNumbers: function() {
	    return false;
	},
        getDataTableValueGetter: function() {
	    return (v)=>{return v;}
	},
	getHighlightFields:function() {
	    let p = this.getPropertyFromUrl("highlightFields");
	    return  Utils.split(this.getPropertyFromUrl("highlightFields"),",",true,true)||[];
	},
        handleEventPropertyChanged: function(source, prop) {
	    if(prop.property == "highlightFields") {
		if(this.getProperty("acceptHighlightFieldsEvent",true)) {
		    this.setProperty("highlightFields",prop.value);
		    this.forceUpdateUI();
		    let v = Utils.split(prop.value,",",true,true);
		    this.jq(ID_HIGHLIGHTFIELDS).val(v);
		}
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this, source,prop);
	},
	makeSeriesInfo: function(dataTable) {
	    let seriesNames =[];
	    //Assume first one is the index
	    for(let i=1;i<dataTable.getNumberOfColumns();i++) {
		//Styles, etc
		if(dataTable.getColumnRole(i)!="") continue;
		seriesNames.push(dataTable.getColumnLabel(i));
	    }
	    let colors = this.getColorList();
	    let highlightMap  ={};
	    let highlightFields = this.getHighlightFields();
	    let highlightDim = this.getProperty("highlightDim",false);
	    highlightFields.forEach(f=>{highlightMap[f] = true});
	    let seriesInfo = {};
            let useMultipleAxes = this.getProperty("useMultipleAxes", true);
	    seriesNames.forEach((name,idx)=>{
		name = name.replace(/\(.*\)/g,"");
		let id = Utils.makeId(name);
		let highlight = highlightMap[id];
		let s = {
		};
		["labelInLegend ", "seriesType","lineDashStyle","pointSize", "lineWidth","color","pointShape"].forEach(a=>{
		    let dflt = this.getProperty((highlight?"highlight.":"nohighlight.") + a,this.getProperty(a));
		    let value = this.getProperty(id+"." + a,dflt);
		    if(value && a=="lineDashStyle") {
			let tmp = [];
			Utils.split(value,",",true,true).forEach(tok=>{
			    tmp.push(parseFloat(tok));
			});
			value=tmp;
		    }
		    if(a=="seriesType") a = "type";
		    s[a] = value;
		});
		if(!s.color) s.color = colors[idx%colors.length];
		if(highlightFields.length>0) {
		    if(!highlight && highlightDim) {
			s.color = Utils.pSBC(0.75,s.color);
		    }
		}
		if (useMultipleAxes) {
		    if(idx%2==0) {
			s.targetAxisIndex=0;
		    }  else  {
			s.targetAxisIndex=1;
		    }
		}
		seriesInfo[idx] = s;
	    });


	    if(this.getProperty("highlightShowFields",false)) {
		if(this.jq(ID_HIGHLIGHTFIELDSHOLDER).length==0) {
		    this.jq(ID_HEADER2).append(HU.span([ID,this.domId(ID_HIGHLIGHTFIELDSHOLDER)]));
		}
		
		if(this.jq(ID_HIGHLIGHTFIELDS).length==0) {
		    let seriesValues = [];
		    seriesNames.forEach(n=>{
			seriesValues.push([Utils.makeId(n),n]);
		    });
		    seriesValues.sort((a,b)=>{
			return a[1].localeCompare(b[1]);
			
		    });
		    let highlightWidget = SPACE + HU.vbox(["Highlight",
							  HU.select("",[ID,this.domId(ID_HIGHLIGHTFIELDS),"multiple","true","size",this.getProperty("highlightShowFieldsSize","3")],seriesValues,highlightFields)]);
		    let select =  HU.span([CLASS,"display-filter",STYLE,""],highlightWidget);
		    this.jq(ID_HIGHLIGHTFIELDSHOLDER).html(select);
		    this.jq(ID_HIGHLIGHTFIELDS).change(()=>{
			let v = Utils.makeArray(this.jq(ID_HIGHLIGHTFIELDS).val());
			v = Utils.join(v,",");
			this.setProperty("highlightFields",v);
			this.addToDocumentUrl("highlightFields",v);
			this.forceUpdateUI();
			let props = {
			    property: "highlightFields",
			    value:v
			};

			this.propagateEvent("handleEventPropertyChanged", props);
		    });
		}
	    }
	    //	    console.log(JSON.stringify(seriesInfo,null,2));
	    return seriesInfo;
	},
	    
	makeTrendlinesInfo: function(dataTable) {
	    let seriesNames =[];
	    //Assume first one is the index
	    for(let i=1;i<dataTable.getNumberOfColumns();i++) {
		//Styles, etc
		if(dataTable.getColumnRole(i)!="") continue;
		seriesNames.push(dataTable.getColumnLabel(i));
	    }
	    let trendlinesInfo = {};
	    seriesNames.forEach((name,idx)=> {
		let id = Utils.makeId(name);
		if(this.getProperty("showTrendline." + id, this.getProperty("showTrendline"))) {
		    let s = {
		    };
		    trendlinesInfo[idx] = s;
		    s.type = this.getProperty("trendlineType." + id,this.getProperty("trendlineType"));
		    s.visibleInLegend = this.getProperty("trendlineVisibleInLegend." + id,this.getProperty("trendlineVisibleInLegend"));
		    s.color = this.getProperty("trendlineColor." + id,this.getProperty("trendlineColor"));
		    s.lineWidth = this.getProperty("trendlineLineWidth." + id,this.getProperty("trendlineLineWidth"));
		    s.opacity = this.getProperty("trendlineOpacity." + id,this.getProperty("trendlineOpacity"));		    		    		    
		}
	    });
	    return trendlinesInfo;
	},
        makeDataTable: function(dataList, props, selectedFields, chartOptions) {
	    let dateType = this.getProperty("dateType","date");
	    let debug =   displayDebug.makeDataTable;
	    let debugRows = 4;
	    if(debug) console.log(this.type+" makeDataTable #records" + dataList.length);
	    if(debug) console.log("\tfields:" + selectedFields);
	    let maxWidth = this.getProperty("maxFieldLength",this.getProperty("maxFieldWidth",-1));
	    let addTooltip = this.getAddToolTip();
    	    let addStyle= this.getAddStyle();
	    let annotationTemplate = this.getAnnotationTemplate();
	    let formatNumbers = this.getFormatNumbers();
            if (dataList.length == 1) {
		return google.visualization.arrayToDataTable(this.makeDataArray(dataList));
            }

	    let groupField = this.getFieldById(null,  this.getProperty("groupBy"));
	    if(groupField) {
		dataList = this.filterData();
		let groupedData =[];
		let groupValues = [];
		let seen = {};
		let cnt =0;
		let dateToValue =  {};
		let dates = [];
		dataList.map(record=>{
		    if(cnt++==0) return;
		    let values = this.getDataValues(record);
		    let value = values[groupField.getIndex()];
		    if(!seen[value]) {
			seen[value]  = true;
			seen[Utils.makeId(value)]  = true;			
			groupValues.push(value);
		    }
		    let newValues =dateToValue[record.getDate()];
		    if(!newValues) {
			dates.push(record.getDate());
			newValues = {};
			dateToValue[record.getDate()] = newValues;
		    }
		    newValues[value] = values[selectedFields[0].getIndex()];
		});

		let data = [];
		let tmp = [];
		let highlightFields = this.getHighlightFields();
		let tmpMap ={};
		highlightFields.forEach(f=>{
		    if(seen[f]) {
			tmp.push(Utils.makeLabel(f));
		    }
		});

		groupValues = Utils.mergeLists(tmp,groupValues);
		groupValues = groupValues.filter(v=>{
		    if(tmpMap[v]) return false;
		    tmpMap[v] = true;
		    return true;
		});
		dates.map(date=>{
		    let tuple=[this.getDateValue(date)];
		    data.push(tuple);
		    let valueMap = dateToValue[date];
		    groupValues.map(group=>{
			let value = valueMap[group];
			tuple.push(value);
		    });
		});

		let header = Utils.mergeLists(["Date"],groupValues);
		let dataTable = new google.visualization.DataTable();
		if(data.length>0) {
		    //TODO: figure out type of columns with null values
		    let tuple = data[0];
		    tuple.forEach((t,idx)=>{
			let name = header[idx];
			let type = t==null?"number":(typeof t);
			if(type =="number")
			    dataTable.addColumn("number", name);
			else if(type =="string")
			    dataTable.addColumn("string", name);
			else if(t.getTime || (t.v && t.v.getTime))
			    dataTable.addColumn("date", name);						
			else {
			    console.log("Unknown type:" + t);
			    console.log(JSON.stringify(t,null,2));
			    sdfdsfdf()
			}
		    });
		}
		dataTable.addRows(data);
		if(chartOptions) {
		    chartOptions.series = this.makeSeriesInfo(dataTable);
		    chartOptions.trendlines = this.makeTrendlinesInfo(dataTable);		    
		}
		return dataTable;
	    }

            let justData = [];
            let tooltipFields = this.getFieldsByIds(null,this.getProperty("tooltipFields", ""));
	    //	    addTooltip=false;
            let dataTable = new google.visualization.DataTable();
            let header = this.getDataValues(dataList[0]);
            let sample = this.getDataValues(dataList[1]);
	    let fixedValueS = this.getProperty("fixedValue");
	    let fixedValueN;
	    if(fixedValueS) fixedValueN = parseFloat(fixedValueS);
	    let fIdx = 0;
	    let forceStrings = this.getProperty("forceStrings",false);
	    let maxHeaderLength = this.getProperty("maxHeaderLength",-1);
	    let maxHeaderWidth = this.getProperty("maxHeaderWidth",-1);
	    let headerStyle= this.getProperty("headerStyle");
            for (let j = 0; j < header.length; j++) {
		let field=null;
		if(j>0 || !props.includeIndex) {
		    field = selectedFields[fIdx++];
		} else {
		    //todo?
		}
                var value = sample[j];
		let headerLabel = header[j];
		if(maxHeaderLength>0 && headerLabel.length>maxHeaderLength) {
		    let orig = headerLabel;
		    headerLabel = headerLabel.substring(0,maxHeaderLength-1)+"...";
		    headerLabel = HU.span([TITLE,orig], headerLabel);
		}
		if(maxHeaderWidth>0 || headerStyle) {
		    let orig = headerLabel;
		    let style = "";
		    if(maxHeaderWidth>0)
			headerLabel = headerLabel.replace(/ /g,"&nbsp;");
		    if(maxHeaderWidth>0)
			style+="max-width:" + maxHeaderWidth +"px;overflow-x:auto;";
		    if(headerStyle)
			style+=headerStyle;
		    headerLabel = HU.div([TITLE,orig,STYLE,style], headerLabel);
		} 

                if (j == 0 && props.includeIndex) {
                    //This might be a number or a date
                    if ((typeof value) == "object") {
                        //assume its a date
 			if(typeof value.v == "number") {
			    if(forceStrings) 
				dataTable.addColumn('string', headerLabel);
			    else {
				dataTable.addColumn('number', headerLabel);
			    }
			} else {
			    dataTable.addColumn(dateType, headerLabel);
			}
                    } else {
                        dataTable.addColumn((typeof value), headerLabel);
                    }
                } else {
		    if(j>0 && fixedValueS) {
			dataTable.addColumn('number', this.getProperty("fixedValueLabel","Count"));
		    } else {
			if(field.isString()) {
			    dataTable.addColumn('string', headerLabel);
			} else if(field.isFieldDate()) {
			    dataTable.addColumn(dateType, headerLabel);
			} else {
			    dataTable.addColumn('number', headerLabel);
			}
		    }
		    if(annotationTemplate) {
			dataTable.addColumn({
			    type: 'string',
			    role: 'annotation',
			    'p': {
				'html': true
			    }
			});
		    }

		    if(addStyle) {
			if(debug)
			    console.log("add style column");
			dataTable.addColumn({ type: 'string', role: 'style' });
		    }
		    if(addTooltip) {
			if(debug)
			    console.log("add tooltip column");
			dataTable.addColumn({
                            type: 'string',
                            role: 'tooltip',
                            'p': {
				'html': true
                            }
			});
		    }
		    if(j>0 && fixedValueS) {
			break;
		    }
                }
            }

	    if(debug) {
		for(var i=0;i<dataTable.getNumberOfColumns();i++)
		    console.log("col[" + i +"]=" + dataTable.getColumnLabel(i) +" " + dataTable.getColumnType(i));
	    }
	    if(this.getProperty("annotations") ||  this.getProperty("annotationFields")) {
		let clonedList = Utils.cloneList(dataList);
		clonedList.shift();
		this.annotations  = new Annotations(this,clonedList);
		if(this.annotations.hasFields()) {
                    dataTable.addColumn({
			type: 'string',
			role: 'annotation',
			'p': {
                            'html': true
			}
                    });
		    dataTable.addColumn({
			type: 'string',
			role: 'annotationText',
			'p': {
                            'html': true
			}
                    });
		}
	    }

	    if(this.annotations && this.annotations.isEnabled()) {
		if(this.annotations.getShowLegend()) {
		    //Pad the left to align with  the chart axis
		    this.jq(ID_LEGEND).html("<table width=100%><tr valign=top><td width=10%></td><td width=90%>" +
					    HU.div([CLASS, "display-chart-legend"],this.annotations.getLegend())
					    +"</td></tr></table>");
		}
		dataTable.addColumn({
                    type: 'string',
                    role: 'annotation',
                    'p': {
                        'html': true
                    }
                });
		dataTable.addColumn({
                    type: 'string',
                    role: 'annotationText',
                    'p': {
                        'html': true
                    }
                });
	    }


	    let annotationCnt=0;

	    let records = [];
            for (var i = 1; i < dataList.length; i++) {
		records.push(dataList[i].record);
	    }
	    let colors =  this.getColorTable(true);
            let colorBy = this.getColorByInfo(records);
	    let valueGetter = this.getDataTableValueGetter(records);
	    let didColorBy = false;
	    let tuples = [];
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
		let record =dataList[rowIdx];
                let row = this.getDataValues(record);
		//		var index = row[0];
		//		if(index.v) index  = index.v;
		let theRecord = record.record;
		let color = "";
                if (colorBy.index >= 0) {
                    let value = theRecord.getData()[colorBy.index];
		    hasColorByValue  = true;
		    colorByValue = value;
                    didColorBy = true;
		    color =  colorBy.getColorFromRecord(theRecord);
                }

                row = row.slice(0);
                let label = "";
                if (theRecord) {
                    for (let j = 0; j < tooltipFields.length; j++) {
                        label += "<b>" + tooltipFields[j].getLabel() + "</b>: " +
                            theRecord.getValue(tooltipFields[j].getIndex()) + "<br>";
                    }
		}
		let tooltip = "";
                tooltip += label;
                for (let j = 0; j < row.length; j++) {
		    if (j > 0)
                        tooltip += "<br>";
		    label = header[j].replace(/ /g, "&nbsp;");
		    value = row[j];
		    if (!Utils.isDefined(value)) value = "NA";
		    if (value && (typeof value) == "object") {
                        if (value.f) {
			    value = value.f;
                        }
		    }
		    if (Utils.isNumber(value)) {
                        value = this.formatNumber(value);
		    }
		    value = "" + value;
		    value = value.replace(/ /g, SPACE);
		    tooltip += HU.b(label) + ":" + SPACE + value;
                }

		let tt = this.getProperty("tooltip");
		if(tt) {
		    tt  = this.getRecordHtml(theRecord,null,tt);
		    tt = tt.replace("${default}",tooltip);
		    tooltip = tt;
		}
		tooltip = HU.div([STYLE,HU.css('padding','8px')],tooltip);
                let newRow = [];
		if(debug && rowIdx<debugRows)
		    console.log("row[" + rowIdx+"]:");

		let fIdx=0;
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
		    let field = selectedFields[fIdx++];
                    let value = row[colIdx];
		    if(forceStrings) {
			if(value.f) value = (value.f).toString().replace(/\n/g, " ");
		    }
		    if(colIdx>0 && fixedValueS) {
			newRow.push(valueGetter(fixedValueN, colIdx, field, theRecord));
			if(debug && rowIdx<debugRows)
			    console.log("\t fixed:" + fixedValueN);
		    } else {
			let type = (typeof value);
			if(type == "number") {
                            if(formatNumbers) {
				value = {v:value,f:String(this.formatNumber(value))};
			    }
			}  else if(type=="boolean") {
			    value = String(value);
			}
			if(debug && rowIdx<debugRows) {
			    let v = value.f?("f:" + value.f +" v:" +value.v):value;
			    console.log("\t value[" + colIdx +"]="+ v +" " + (typeof value));
			}
			if(maxWidth>0 && type == "string" && value.length > maxWidth)
			    value = value.substring(0,maxWidth) +"...";
			let o = valueGetter(value, colIdx, field, theRecord);
			newRow.push(o);
		    }
                    if (colIdx == 0 && props.includeIndex) {
			/*note to self - an inline comment breaks the minifier 
			  if the index so don't add a tooltip */
                    } else {
			if(annotationTemplate) {
			    let v = annotationTemplate.replace("${value}",value.f||value);
			    if(debug && rowIdx<debugRows)
				console.log("\t annotation" + v);
			    newRow.push(v);
			}
			if(addStyle) {
			    newRow.push(color);
			    if(debug && rowIdx<debugRows)
				console.log("\t color:" + color);
			    //			    if(debug && rowIdx<debugRows)
			    //				console.log("\t style:" + color);
			}
			if(addTooltip) {
                            newRow.push(tooltip);
			    if(debug && rowIdx<debugRows)
			    	console.log("\t tooltip:");
			}
                    }
		    if(colIdx>0 && fixedValueS) {
			break;
		    }
		}


		if(this.annotations && this.annotations.hasFields()) {
                    if (theRecord) {
			let desc = "";
			this.annotations.getFields().forEach(f=>{
			    let d = ""+theRecord.getValue(f.getIndex());
			    if(d!="")
				desc+= (d+"<br>");
			});
			desc = desc.trim();
			desc = desc.replace(/ /g,"&nbsp;");
			annotationCnt++;
			let label = null; 
			if(desc.trim().length>0) {
			    label =""+( this.annotations.labelField?theRecord.getValue(this.annotations.labelField.getIndex()):(annotationCnt))
			    if(label.trim().length==0) label = ""+annotationCnt;
			}
			debug =true;
			if(debug && rowIdx<debugRows) {
			    console.log("\t label:" + label);
			    console.log("\t desc:" + desc);
			}
			debug =false;
			console.log("A2:" +label);
			newRow.push(label);
			newRow.push(desc);
		    } else {
			if(i<2)
			    console.log("No records for annotation");
		    }
		}
		if(this.annotations &&  this.annotations.isEnabled()) {
		    let annotations = this.annotations.getAnnotationsFor(rowIdx);
		    if(annotations) {
			if(debug && rowIdx<debugRows) {
			    console.log("\t annotation:" + annotations);
			}
			let label = "";
			let desc = "";
			annotations.forEach(a=>{
			    if(label!="") label+="/";
			    label+=a.label;
			    if(desc!="") desc+="<br>";
			    else {
				if(a.record && a.record.getDate()) {
				    desc+=HU.b(this.formatDate(a.record.getDate()))+"<br>";
				}
			    }
			    desc+=a.description;			    
			});
			newRow.push(label);
			newRow.push(desc);
		    } else {
			if(debug && rowIdx<debugRows) {
			    console.log("\t annotation:" + "null");
			    console.log("\t desc:" + "null");
			}
			newRow.push(null);
			newRow.push(null);
		    }
		    debug =false;
		}
                justData.push(newRow);
//		console.log("row:" + newRow);
		//		if(debug && rowIdx>debugRows) break;
	    }

	    if(debug)
		console.log("#rows:" + justData.length);


            dataTable.addRows(justData);
            if (didColorBy) {
		colorBy.displayColorTable();
            }
	    if(chartOptions) {
		//Only make the series if it isn't stacked
		if(!chartOptions.isStacked) {
		    chartOptions.series = this.makeSeriesInfo(dataTable);
		}
		chartOptions.trendlines = this.makeTrendlinesInfo(dataTable);
	    }

            return dataTable;
        },
        makeChartOptions: function(dataList, props, selectedFields) {
            let chartOptions = {
                tooltip: {
                    isHtml: true,
//		    ignoreBounds: true, 
		    trigger: 'both' 
                },
            };

            $.extend(chartOptions, {
		width:"100%",
                lineWidth: this.getProperty("lineWidth",1),
                colors: this.getColorList(),
                curveType: this.curveType,
		pointShape:this.getProperty("pointShape"),
		pointSize: this.getProperty("pointSize"),
                vAxis: {}
            });

            chartOptions.backgroundColor = {};
            chartOptions.chartArea = {};
            chartOptions.chartArea.backgroundColor = {};

            chartOptions.legend = {
                textStyle: {}
            };
            chartOptions.hAxis = {
                gridlines: {},
                minorGridlines: {},		
                textStyle: {},
            };
	    chartOptions.xannotations = {
		textStyle: {
		    fontSize: this.getProperty('annotationsFontSize',12),
		    color: this.getProperty('annotationsTextColor')
		},
		stem: {
		    color:this.getProperty('annotationsStemColor'),
		    length:this.getProperty('annotationsStemLength'),
		},
		style: this.getProperty('annotationsStyle')
	    };



            chartOptions.vAxis = {
                gridlines: {},
                minorGridlines: {},		
                textStyle: {}
            };
	    chartOptions.hAxis.minValue = this.getProperty("hAxisMinValue");
	    chartOptions.hAxis.maxValue = this.getProperty("hAxisMaxValue");
	    chartOptions.vAxis.minValue = this.getProperty("vAxisMinValue");
	    chartOptions.vAxis.maxValue = this.getProperty("vAxisMaxValue");


	    chartOptions.vAxis.logScale = this.getProperty("vAxisLogScale",this.getProperty("logScale"));
	    chartOptions.hAxis.logScale = this.getProperty("hAxisLogScale");

            chartOptions.hAxis.titleTextStyle = {};
            chartOptions.vAxis.titleTextStyle = {};
	    if(this.getProperty("hAxisDateFormat")) {
		chartOptions.hAxis.format = this.getProperty("hAxisDateFormat");
	    }


	    //	    this.getPropertyShow = true;
	    var lineColor = this.getProperty("lineColor");
	    var backgroundColor = this.getProperty("chartBackground");
            this.setPropertyOn(chartOptions.backgroundColor, "chart.fill", "fill", backgroundColor);
            this.setPropertyOn(chartOptions.backgroundColor, "chart.stroke", "stroke", this.getProperty("chartArea.fill", ""));
            this.setPropertyOn(chartOptions.backgroundColor, "chart.strokeWidth", "strokeWidth", null);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.fill", "fill", backgroundColor);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.stroke", "stroke", null);
            this.setPropertyOn(chartOptions.chartArea.backgroundColor, "chartArea.strokeWidth", "strokeWidth", null);

	    let minorGridLinesColor = this.getProperty("minorGridLines.color",this.getProperty("gridlines.color", lineColor||"transparent"));
            this.setPropertyOn(chartOptions.hAxis.gridlines, "hAxis.gridlines.color", "color", this.getProperty("gridlines.color", lineColor));
	    this.setPropertyOn(chartOptions.hAxis.minorGridlines, "hAxis.minorGridlines.color", "color", minorGridLinesColor);

	    this.setPropertyOn(chartOptions.hAxis, "hAxis.baselineColor", "baselineColor", this.getProperty("baselineColor", lineColor));	    

            this.setPropertyOn(chartOptions.vAxis.gridlines, "vAxis.gridlines.color", "color", this.getProperty("gridlines.color", lineColor));
	    this.setPropertyOn(chartOptions.vAxis.minorGridlines, "vAxis.minorGridlines.color", "color",  minorGridLinesColor);
	    this.setPropertyOn(chartOptions.vAxis, "vAxis.baselineColor", "baselineColor", this.getProperty("baselineColor", lineColor));


            var textColor = this.getProperty("textColor", "#000");
	    var textBold = this.getProperty("textBold", "false");
            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.color", "color", this.getProperty("axis.text.color", textColor));
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.color", "color", this.getProperty("axis.text.color", textColor));

            this.setPropertyOn(chartOptions.hAxis.textStyle, "hAxis.text.bold", "bold", textBold);
            this.setPropertyOn(chartOptions.vAxis.textStyle, "vAxis.text.bold", "bold", textBold);

	    chartOptions.vAxis.title  = Utils.decodeText(this.getProperty("vAxis.text", this.getProperty("vAxisText")));
	    chartOptions.hAxis.title  = Utils.decodeText(this.getProperty("hAxis.text", this.getProperty("hAxisText")));	    
	    chartOptions.hAxis.slantedText = this.getProperty("hAxis.slantedText",this.getProperty("slantedText",false));
            this.setPropertyOn(chartOptions.hAxis.titleTextStyle, "hAxis.text.color", "color", textColor);
            this.setPropertyOn(chartOptions.vAxis.titleTextStyle, "vAxis.text.color", "color", textColor);
            this.setPropertyOn(chartOptions.legend.textStyle, "legend.text.color", "color", textColor);

	    if(this.getProperty("hAxis.ticks") || this.getProperty("hAxis.ticks")=="")  {
		chartOptions.hAxis.ticks  = Utils.split(this.getProperty("hAxis.ticks"),",",true,true);
	    }
	    if(this.getProperty("vAxis.ticks") || this.getProperty("vAxis.ticks")=="")  {
		chartOptions.vAxis.ticks  = Utils.split(this.getProperty("vAxis.ticks"),",",true,true);
	    }


            if (this.fontSize > 0) {
                chartOptions.fontSize = this.fontSize;
            }

	    let defaultRanges=[];
	    let numeric = [];
            dataList.forEach((v,idx)=>{
		if(idx==0) return;
		let tuple = this.getDataValues(v);
		if(idx==1) {
		    tuple.forEach((tv,idx)=>{
			numeric.push((typeof tv)=="number");
		    });
		    numeric.forEach(v=>defaultRanges.push([Number.MAX_VALUE,Number.MIN_VALUE]));
		}
		
		
		let cnt = 0;
		tuple.forEach((tv,idx)=>{
		    if(numeric[idx]) {
			defaultRanges[cnt][0] = Math.min(defaultRanges[cnt][0],tv);
			defaultRanges[cnt][1] = Math.max(defaultRanges[cnt][1],tv);
			cnt++;
		    }
		});
	    });

            var range = [NaN, NaN];
	    //	    console.log("range:" +this.getVAxisMinValue());
            if (!isNaN(this.getVAxisMinValue())) {
                range[0] = this.getVAxisMinValue();
            } else if (defaultRanges.length>0) {
		if(this.getProperty("vAxisUseDefault")) {
                    range[0] = defaultRanges[0][0];
		}
            }

	    if (!isNaN(this.getVAxisMaxValue())) {
                range[1] = this.getVAxisMaxValue();
            } else if (defaultRanges.length>0) {
//                range[1] = defaultRanges[0][1];
            }



            if (!isNaN(range[0])) {
                chartOptions.vAxis.minValue = range[0];
            }
            if (!isNaN(range[1])) {
                chartOptions.vAxis.maxValue = range[1];
//		chartOptions.vAxis.maxValue = null;
            }

//	    console.log(chartOptions.vAxis.maxValue);

            this.chartDimensions = {
                width: "90%",
                left: "10%",
                right: 10,
            }

            useMultipleAxes = this.getProperty("useMultipleAxes", true);

            if ((selectedFields.length > 1 && useMultipleAxes) || this.getProperty("padRight", false) === true) {
                this.chartDimensions.width = "80%";
            }

            if (this.getProperty("showTrendLines", false)) {
                chartOptions.trendlines = {
                    0: {
                        type: 'linear',
                        color: 'green',
                    }
                };
            }
	    
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(expandedHeight) {
		chartOptions.height = expandedHeight;
	    }
	    if(this.getPropertyShow) {
		this.getPropertyShow = false;
		Utils.makeDownloadFile("props.txt",this.getPropertyOutput);
	    }
            this.setContents(HU.div([ID,this.domId(ID_CHARTS)]));
            return chartOptions;
        },
        getChartHeight: function() {
            return this.getProperty("height");
        },
        getChartWidth: function() {
            return this.getProperty("width");
        },
        getChartDiv: function(chartId) {
            var divAttrs = [ATTR_ID, chartId];
            var style = "";
            var width = this.getChartWidth();
            if (false && width) {
		if(width.endsWith("%")) {
                    style += HU.css("width", width);
		} else {
                    if (width > 0)
			style += HU.css("width", width + "px");
                    else if (width < 0)
			style += HU.css("width" , (-width) + "%");
                    else
			style += HU.css("width", width);
		}
            } else {
		//                style += HU.css("width","100%");
            }
	    let expandedHeight  = this.getProperty("expandedHeight");
            var height =  this.getChartHeight();
	    if(expandedHeight) {
                style += HU.css("height", expandedHeight);
	    } else {
		if (height) {
                    if (height > 0)
			style += HU.css("height", height + "px");
                    else if (height < 0)
			style += HU.css("height", (-height) + "%");
                    else
			style += HU.css("height", height);
		} else {
                    style += HU.css("height", "100%");
		}
	    }
	    //	    style += HU.css("text-align","center");
            divAttrs.push(STYLE);
            divAttrs.push(style);
	    divAttrs.push(CLASS);
	    divAttrs.push("ramadda-expandable-target");
	    let isExpanded = this.getProperty("isExpanded");
	    let originalHeight = this.getProperty("originalHeight");
	    if(isExpanded) {
		divAttrs.push("isexpanded","true")
		divAttrs.push("original-height",originalHeight)
	    }
	    if(this.getProperty("expandableHeight")) {
		divAttrs.push("expandable-height");
		divAttrs.push(this.getProperty("expandableHeight"));
	    }
            return HU.div(divAttrs, "");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            throw new Error("doMakeGoogleChart undefined");
        },
	makeGoogleChart: function(dataList, props, selectedFields) {
	    try {
		this.doMakeGoogleChartInner(dataList,props,selectedFields);
	    } catch(err) {
		this.setErrorMessage("Error creating chart: " + err);
		console.log(this.type+ " Error creating chart:" + err);
		console.log(err.stack);
	    }
	},
	setAxisRanges: function(chartOptions, selectedFields, records) {
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[0]);
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }

	    if(this.getProperty("vAxisFixedRange") || this.getProperty("vAxisSelectedFields") || this.getProperty("vAxisAllFields")) {
		let min = Number.MAX_VALUE;
		let max = Number.MIN_VALUE;		
		let fields = this.getProperty("vAxisAllFields")?this.getFields():selectedFields;
		fields.forEach(f=>{
		    if(f.isFieldNumeric()) {
			let y = this.getColumnValues(records, f);
			if(!isNaN(y.min))
			    min  = Math.min(min, y.min);
			if(!isNaN(y.max))
			    max  = Math.max(max, y.max);
		    }
		});
		if(min!=Number.MAX_VALUE) {
		    chartOptions.vAxis.minValue = min;
		    chartOptions.vAxis.maxValue = max;
		}
	    }

	},
	doMakeGoogleChartInner: function(dataList, props, selectedFields) {
            if (typeof google == 'undefined') {
                this.setDisplayMessage("No google");
                return;
            }
            this.chartOptions = this.makeChartOptions(dataList, props, selectedFields);

	    this.chartOptions.bar = {groupWidth:"95%"}
            if (!Utils.isDefined(this.chartOptions.height)) {
                this.chartOptions.height = "100%";
            }

	    this.charts = [];
	    this.chartCount  = -1;

            let records = this.getPointData().getRecords();
	    this.setAxisRanges(this.chartOptions, selectedFields, records);

//	    console.log(JSON.stringify(this.chartOptions, null,2));
	    
	    if(this.getProperty("doMultiCharts",this.getProperty("multipleCharts",false))) {
		let multiField=this.getFieldById(null,this.getProperty("multiField"));
		let labelPosition = this.getProperty("multiChartsLabelPosition","bottom");
		let map = {};
		let groups = [];
		let tmp = [];
		dataList.forEach((v,idx)=>{if(idx>0) tmp.push(v)});
		if(!multiField) {
		    tmp.sort(function(a,b) {
			var v1 = a.record?a.record.getDate():a.date;
			var v2 = b.record?b.record.getDate():b.date;
			return v1.getTime()-v2.getTime();
		    });
		}
		dataList = Utils.mergeLists([dataList[0]], tmp);
		dataList.forEach((v,idx)=>{
		    if(idx==0) return;
                    var record = v.record;
		    var groupValue = record?multiField?record.getValue(multiField.getIndex()):record.getDate():v.date;
		    let list=null;
		    list = map[groupValue];
		    if(!list) {
			list = [];
			map[groupValue] = list;
			groups.push(groupValue);
		    }
		    list.push(v);
		})
		this.jq(ID_CHARTS).html(HU.div([ID,this.domId(ID_CHARTS_INNER),STYLE,HU.css('text-align','center')]));
		let multiStyle="width:200px;" + this.getProperty("multiStyle","");
		let multiLabelTemplate=this.getProperty("multiLabelTemplate","${value}");
		if(multiField) groups.sort();
		groups.forEach((groupValue,idx)=>{
		    this.chartCount  =idx;
		    let tmpDataList = [];
		    let list = map[groupValue];
		    tmpDataList.push(dataList[0]);
		    tmpDataList = Utils.mergeLists(tmpDataList,list);
		    var innerId = this.domId(ID_CHART)+"_" + this.chartCount;
		    var label = groupValue;
		    if(groupValue.getTime) label = this.formatDate(groupValue);
		    label = multiLabelTemplate.replace("${value}",label);
		    var header = HU.div([CLASS,"display-multi-header"], label);
		    var top =labelPosition=="top"?header:"";
		    var bottom = labelPosition=="bottom"?header:"";
		    var div = HU.div([CLASS,"display-multi-div", STYLE,HU.css('display','inline-block')+ multiStyle], top + this.getChartDiv(innerId) + bottom);
		    this.jq(ID_CHARTS_INNER).append(div);
		    let chart = this.makeGoogleChartInner(tmpDataList, innerId, props, selectedFields);
		    if(chart) this.charts.push(chart);
		});
	    } else {
		this.jq(ID_CHARTS).append(this.getChartDiv(this.domId(ID_CHART)));
		let chart = this.makeGoogleChartInner(dataList, this.domId(ID_CHART), props, selectedFields);
		if(chart) this.charts.push(chart);
	    }
	    

	    this.mapCharts(chart=>{
		google.visualization.events.addListener(chart, 'onmouseout',()=>{this.setChartSelection(null)});
	    });



	},
	makeGoogleChartInner: function(dataList, chartId, props, selectedFields) {
	    let chartDiv = document.getElementById(chartId);
	    if(!chartDiv) return;
	    var dataTable = this.makeDataTable(dataList, props, selectedFields, this.chartOptions);
            let chart = this.doMakeGoogleChart(dataList, props, chartDiv, selectedFields, this.chartOptions);
            if (chart == null) return null;
            if (!dataTable) {
                this.setDisplayMessage(this.getNoDataMessage());
                return null;
            }
	    if(this.getProperty("vAxisSharedRange")) {
		let max = NaN;
		for(let i=0;i<dataTable.getNumberOfColumns();i++) {
		    let minmax = dataTable.getColumnRange(i);
		    if(!isNaN(minmax.max) && minmax.max!=null && (typeof minmax.max) == "number") {
			max = max==null|| isNaN(max)?minmax.max:Math.max(max, minmax.max);
		    }
		}
                chartOptions.vAxis.maxValue = max;
            }


	    if(this.getProperty("animation",false,true)) {
		this.chartOptions.animation = {
		    startup: true,
		    duration:parseFloat(this.getProperty("animationDuration",1000,true)),
		    easing:this.getProperty("animationEasing","linear",true)
		};
		HU.callWhenScrolled(this.domId(ID_CHART),()=>{
		    if(!this.animationCalled) {
			this.animationCalled = true;
			this.mapCharts(chart=>{
			    chart.draw(dataTable, this.chartOptions);
			});
		    }
		});
	    } else {
		try {
		    if(this.debugChartOptions)
			console.log(JSON.stringify(this.chartOptions, null,2));
		    this.chart = chart;
		    this.dataTable = dataTable;
		    let testData = google.visualization.arrayToDataTable([
			['Genre', 'Fantasy & Sci Fi', 'Western'],
			['2010', 10, 24],
			['2020', 16, 22],
			['2030', 28, 19]
		    ]);

		    
		    chart.draw(this.useTestData?testData:dataTable, this.chartOptions);
		} catch(err) {
		    this.setErrorMessage("Error creating chart: " + err);
		    console.log(this.type+ " Error creating chart:" + err);
		    console.log(err.stack);
		    return null;
		}
	    }
	    this.addEvents(chart);
	    return chart;
	},
	addEvents: function(chart) {
            let _this = this;
	    if(this.getProperty("propagateHighlightEvent")) {
		google.visualization.events.addListener(chart, 'onmouseover', function(event) {
                    pointData = _this.dataCollection.getList()[0];
                    let fields = pointData.getRecordFields();
                    let records = pointData.getRecords();
	            let record = records[event.row];
		    if(!record) return;
		    _this.getDisplayManager().notifyEvent("handleEventRecordHighlight", _this, {highlight:true,record: record});
		});
	    }
            google.visualization.events.addListener(chart, 'select', function(event) {
                _this.mapCharts(chart=>{
		    if (chart.getSelection) {
			let selected = chart.getSelection();
			if (selected && selected.length > 0) {
                            let index = selected[0].row;
			    let record = _this.indexToRecord[index];
			    if(record) {
				let records = _this.getBinnedRecords(record);
				if(records) {
				    if(records.length==1)  {
					_this.propagateEventRecordSelection({record: records[0]});
				    } else {
					_this.propagateEventRecordSelection({record: records[0],
									     records:records});
				    }
				} else {
				    _this.propagateEventRecordSelection({record: record});
				}
			    }
			}
		    }});
            });
	}


    });
}



function RamaddaAxisChart(displayManager, id, chartType, properties) {
    let SUPER = new RamaddaGoogleChart(displayManager, id, chartType, properties);
    let myProps = [
	{label:'Chart Properties'},
	{p:'indexField',w:'field'},
	{p:'vAxisMinValue',w:''},
	{p:'vAxisMaxValue',w:''},
	{p:'vAxisSharedRange',w:'true',tt:'use the same max value across all time series'},
	{p:"hAxisFixedRange"},
	{p:"vAxisSelectedFields",w:'true',tt:'Use selected fields to find min/max for the range'},
	{p:"vAxisAllFields",w:'true',tt:'Use all field values to find min/max for the range'},
	{p:'vAxisLogScale',w:'true'},
	{p:'hAxisLogScale',w:'true'},
	{p:'tooltipFields',w:''},
	{p:'annotations',w:'date,label,desc;date,label,desc;',tt:'e.g. 2008-09-29,A,Start of housing crash;2008-11-04,B,Obama elected;'},
 	{p:'annotationFields',w:''},
	{p:'annotationLabelField',w:''},
	{p:'indexField',w:'',tt:'alternate field to use as index'},
 	{p:'dateType',w:'datetime'},
 	{p:'forceStrings',w:'',tt:'if index is a string set to true'},
	{inlineLabel:'Multiples Charts'},
	{p:'doMultiCharts',w:'true'},
	{p:'multiField',w:'field'},
	{p:'multiStyle',w:''},
	{p:'multiLabelTemplate',w:'${value}'},
	{p:'multiChartsLabelPosition',w:'bottom|top|none'},
	{inlineLabel:'Chart Layout'},
	{p:'chartHeight',w:''},
	{p:'chartWidth',w:''},
	{p:'chartLeft',w:'0'},
	{p:'chartRight',w:'0'},
	{p:'chartTop',w:'0'},
	{p:'chartBottom',w:'0'},
	{p:'lineColor',w:''},
	{p:'chartBackground',w:''},
	{p:'chart.fill',w:''},
	{p:'chartArea.fill',w:''},
	{p:'chart.stroke',w:''},
	{p:'chart.strokeWidth',w:''},
	{p:'chartArea.fill',w:''},
	{p:'chartArea.stroke',w:''},
	{p:'chartArea.strokeWidth',w:''},
	{p:'gridlines.color',w:'transparent'},
	{p:'minorGridLines.color',w:'transparent'},
	{p:'gridlines.color',w:''},
	{p:'hAxis.gridlines.color',w:''},
	{p:'hAxis.minorGridlines.color',w:'transparent'},
	{p:'baselineColor',w:''},
	{p:'hAxis.baselineColor',w:''},
	{p:'gridlines.color',w:''},
	{p:'vAxis.gridlines.color',w:''},
	{p:'vAxis.minorGridlines.color',w:'transparent'},
	{p:'baselineColor',w:''},
	{p:'vAxis.baselineColor',w:''},
	{p:'textColor',w:'#000'},
	{p:'textBold',w:'true'},
	{p:'axis.text.color',w:'#000'},
	{p:'hAxis.text.color',w:'#000'},
	{p:'axis.text.color',w:'#000'},
	{p:'vAxis.text.color',w:'#000'},
	{p:'hAxis.text.bold',w:'false'},
	{p:'vAxis.text.bold',w:'false'},
	{p:'vAxisText',w:''},
	{p:'vAxis.text',w:''},
	{p:'slantedText',w:'true'},
	{p:'hAxis.slantedText',w:''},
	{p:'hAxis.text.color',w:'#000'},
	{p:'vAxis.text.color',w:'#000'},
	{p:'legend.position',w:'top|bottom|none'},
	{p:'legend.text.color',w:'#000'},
	{p:'hAxis.ticks',w:''},
	{p:'hAxis.ticks',w:''},
	{p:'vAxis.ticks',w:''},
	{p:'vAxis.ticks',w:''},
	{p:'useMultipleAxes',w:'true'},
	{p:'showTrendLines',w:'true'},
    ];

    defineDisplay(this, SUPER, myProps, {

	setChartArea: function(chartOptions) {
            if (!chartOptions.chartArea) {
                chartOptions.chartArea = {};
            }
	    $.extend(chartOptions.chartArea, {
                left: this.getProperty("chartLeft", this.chartDimensions.left),
                right: this.getProperty("chartRight", this.chartDimensions.right),
                top: this.getProperty("chartTop", "10"),
		bottom: this.getProperty("chartBottom"),
                height: this.getProperty("chartHeight", "70%"),
                width: this.getProperty("chartWidth", this.chartDimensions.width),
            });
	    ["left","top","right","bottom"].forEach(a=>{
		let v =chartOptions.chartArea[a];
		if(v) v = String(v).replace("px","");
		chartOptions.chartArea[a] = v;
	    });						    

	},

        makeChartOptions: function(dataList, props, selectedFields) {
            chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);

	    let dataFields = dataList[0].fields;


	    let expandedHeight  = this.getProperty("expandedHeight");
            chartOptions.height = expandedHeight || this.getProperty("chartHeight", this.getProperty("height", "150"));

            if (!chartOptions.legend)
                chartOptions.legend = {};


	    this.setPropertyOn(chartOptions.legend, "legend.position", "position", this.getProperty("legendPosition", 'bottom'));
	    this.setChartArea(chartOptions);
   
            let useMultipleAxes = this.getProperty("useMultipleAxes", true);
            if (useMultipleAxes) {
		//TODO: 
                chartOptions.series = [
		    {
			targetAxisIndex: 0
                    }, {
			targetAxisIndex: 1
                    }];
            }

	    if(chartOptions.legend.position=="left") {
		console.log(chartOptions.legend.position);
                chartOptions.series = [
		    {
			targetAxisIndex: 1
		    }]
	    }

	    if (!chartOptions.hAxis) {
		chartOptions.hAxis = {};
	    }
	    if (!chartOptions.vAxis) {
		chartOptions.vAxis = {};
	    }
	    chartOptions.hAxis.textPosition = this.getProperty("hAxisTextPosition","top");
	    chartOptions.vAxis.textPosition = this.getProperty("vAxisTextPosition");


            if (this.getProperty("hAxisTitle")) {
                chartOptions.hAxis.title = this.getProperty("hAxisTitle");
            }
            if (this.getProperty("vAxisTitle")) {
                chartOptions.vAxis.title = this.getProperty("vAxisTitle");
		if(chartOptions.vAxis.title && dataFields) {
		    let label = dataFields.reduce((acc,v)=>{
			return acc+" " + v.getLabel();
		    },"");
		    chartOptions.vAxis.title = chartOptions.vAxis.title.replace("${fields}",label);
		}

            }
//	    console.log(JSON.stringify(chartOptions,null,2));

            if (Utils.isDefined(this.chartHeight)) {
                chartOptions.height = this.chartHeight;
            }

            return chartOptions;

        }
    });

}



function RamaddaSeriesChart(displayManager, id, chartType, properties) {
    const SUPER = new RamaddaAxisChart(displayManager, id, chartType, properties);
    defineDisplay(this, SUPER, [], {
        includeIndexInData: function() {
            return this.getProperty("includeIndex", true);
        },
        trendLineEnabled: function() {
            return true;
        },
    });
}


function BlankchartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, "blankchart", properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            return null;
        },
    });
}


function LinechartDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaSeriesChart(displayManager, id, DISPLAY_LINECHART, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            return new google.visualization.LineChart(chartDiv);
        },
    });
}




function AreachartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, DISPLAY_AREACHART, properties);
    let myProps = [
	{p:'isStacked',ex:'true'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            if (this.isStacked)
                chartOptions.isStacked = true;
            return new google.visualization.AreaChart(chartDiv);
        }
    });
}


function RamaddaBaseBarchart(displayManager, id, type, properties) {
    const SUPER  = new RamaddaSeriesChart(displayManager, id, type, properties);
    let myProps = [
    ];
    defineDisplay(this, SUPER, myProps, {
        canDoGroupBy: function() {
            return true;
        },
        makeChartOptions: function(dataList, props, selectedFields) {
            chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            var chartType = this.getChartType();
            if (chartType == DISPLAY_BARSTACK) {
		chartOptions.series = null;
                chartOptions.isStacked = true;
            }
            if (this.getProperty("barWidth")) {
		let w = this.getProperty("barWidth");
		if(w=="flex") {
		    if(dataList.length<100) {
			w = "10";
		    } else {
			w = null;
		    }
		}
		if(w) {
                    chartOptions.bar = {
			groupWidth: w
                    }
		}
	    }
	    chartOptions.orientation = this.getProperty("orientation","horizontal");
	    return chartOptions;
	},

        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            return new google.visualization.BarChart(chartDiv);
        }
    });
}


function BarchartDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaBaseBarchart(displayManager, id, DISPLAY_BARCHART, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {});
}

function BarstackDisplay(displayManager, id, properties) {
    properties = $.extend({
        "isStacked": true
    }, properties);
    const SUPER =  new RamaddaBaseBarchart(displayManager, id, DISPLAY_BARSTACK, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {});
}


function HistogramDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_HISTOGRAM, properties);
    let myProps = [
	{label:'Histogram Properties'},
	{p:'legendPosition',ex:'none|top|right|left|bottom'},
	{p:'textPosition',ex:'out|in|none'},
	{p:'isStacked',ex:'false|true|percent|relative'},
	{p:'logScale',ex:'true|false'},
	{p:'scaleType',ex:'log|mirrorLog'},
	{p:'minValue',ex:''},
	{p:'maxValue',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        okToHandleEventRecordSelection: function() {
            return false;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            return google.visualization.arrayToDataTable(this.makeDataArray(dataList));
        },
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            //            chartOptions = {};
            if (this.legendPosition) {
                if (!chartOptions.legend)
                    chartOptions.legend = {};
                chartOptions.legend.position = this.legendPosition;
            }
            var isStacked = this.getProperty("isStacked", null);
            if (isStacked)
                chartOptions.isStacked = isStacked == "true" ? true : isStacked == "false" ? false : isStacked;
            chartOptions.vAxis = {};
            chartOptions.vAxis.viewWindow = {};
            if (Utils.isDefined(this.logScale)) {
                chartOptions.vAxis.logScale = ("" + this.logScale) == true;
            }
            if (this.textPosition) {
                chartOptions.vAxis.textPosition = this.textPosition;
            }


            if (Utils.isDefined(this.minValue)) {
                chartOptions.vAxis.viewWindow.min = parseFloat(this.minValue);
            }
            if (Utils.isDefined(this.maxValue)) {
                chartOptions.vAxis.viewWindow.max = parseFloat(this.maxValue);
            }
            if (!isNaN(this.getVAxisMaxValue())) {
                chartOptions.vAxis.maxValue = this.getVAxisMaxValue();
            }
            if (!isNaN(this.getVAxisMinValue())) {
                chartOptions.vAxis.minValue = parseFloat(this.getVAxisMinValue());
            }
            if (!isNaN(this.getHAxisMaxValue())) {
                chartOptions.hAxis.maxValue = this.getHAxisMaxValue();
            }
            if (!isNaN(this.getHAxisMinValue())) {
                chartOptions.hAxis.minValue = parseFloat(this.getHAxisMinValue());
            }	    
            return new google.visualization.Histogram(chartDiv);
        },

    });
}


function RamaddaTextChart(displayManager, id, chartType, properties) {
    const SUPER = new RamaddaGoogleChart(displayManager, id, chartType, properties);
    defineDisplay(this, SUPER, [], {
        getFieldsToSelect: function(pointData) {
            return pointData.getNonGeoFields();
        },
    });
}




function PiechartDisplay(displayManager, id, properties) {
    let ID_PIE_LEGEND = "pielegend";
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_PIECHART, properties);
    let myProps = [
	{label:'Pie Chart Properties'},
	{p:'groupBy',ex:''},
	{p:'groupByCount',ex:'true'},
	{p:'groupByCountLabel',ex:''},
	{p:'binCount',ex:'true'},
	{p:'pieHole',ex:'0.5'},
	{p:'is3D',ex:'true'},
	{p:'bins',ex:''},
	{p:'binMin',ex:''},
	{p:'binMax',ex:'max'},
	{p:'sliceVisibilityThreshold',ex:'0.01'},
	{p:'pieSliceTextColor',ex:'black'},
	{p:'pieSliceBorderColor',ex:'black'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {

	uniqueValues:[],
	uniqueValuesMap:{},
        canDoGroupBy: function() {
            return true;
        },
	makeGoogleChart: function(dataList, props, selectedFields) {
	    this.uniqueValues = [];
	    this.uniqueValuesMap = {};
	    SUPER.makeGoogleChart.call(this, dataList, props, selectedFields);
	    if(!this.getProperty("showTopLegend")) return;
	    let legend = "";
	    let colors = this.getColorList();
	    let colorCnt = 0;
	    this.uniqueValues.map((v,idx)=>{
		if(colorCnt>=colors.length) colorCnt = 0;
		var color  = colors[colorCnt];
		legend += HU.div([STYLE,HU.css('display','inline-block','width','8px','height','8px','background', color)]) +SPACE + v +SPACE2;
		colorCnt++;
	    });
	    if(this.jq(ID_PIE_LEGEND).length==0) {
		this.jq(ID_HEADER2).append(HU.div([ID,this.domId(ID_PIE_LEGEND)]));
	    }
	    this.jq(ID_PIE_LEGEND).html(legend);

	},
        setChartSelection: function(index) {
	    //noop
	},
        getGroupBy: function() {
            if (!this.groupBy && this.groupBy != "") {
                var stringField = this.getFieldByType(this.getFields(), "string");
                if (stringField) {
                    this.groupBy = stringField.getId();
                }
            }
            return this.groupBy;
        },
        getChartDiv: function(chartId) {
            var divAttrs = [ATTR_ID, chartId];
            divAttrs.push(STYLE);
            var style = "";
	    var width = this.getProperty("chartWidth") || this.getChartWidth();
	    var height = this.getProperty("chartHeight") || this.getChartHeight();
            if (width) {
                if (width > 0)
                    style += "width:" + width + "px;";
                else if (width < 0)
                    style += "width:" + (-width) + "%;";
                else
                    style += "width:" + width + ";";
            } else {
                style += "width:" + "100%;";
            }
            if (height) {
                if (height > 0)
                    style += "height:" + height + "px;";
                else if (height < 0)
                    style += "height:" + (-height) + "%;";
                else
                    style += "height:" + height + ";";
            } else {
                style += "height:" + "100%;";
            }
	    //	    style += "border:1px solid green;"
	    style += "padding:5px;"
            divAttrs.push(style);
            return HU.div(divAttrs, "");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            chartOptions.tooltip = {
                textStyle: {
                    color: '#000000',
		    fontSize:12,
                },
                showColorCode: true,
		//		isHtml: true,
		//		ignoreBounds: true,
            };
	    this.chartOptions.legend = {'position':this.getProperty("legendPosition", 'right'),'alignment':'center'};
            if (this.getProperty("bins", null)) {
                chartOptions.title = "Bins: " + this.getDataValues(dataList[0])[1];
	    } else if(this.getProperty("sumFields")) {
                chartOptions.title = this.getProperty("chartTitle","Categories/Values");
            } else {
                chartOptions.title = this.getDataValues(dataList[0])[0] + " - " + this.getDataValues(dataList[0])[1];
            }

            if (this.is3D) {
                chartOptions.is3D = true;
            }
            if (this.pieHole) {
                chartOptions.pieHole = this.pieHole;
            }
            if (this.sliceVisibilityThreshold) {
                chartOptions.sliceVisibilityThreshold = this.sliceVisibilityThreshold;
            }

	    chartOptions.pieSliceBorderColor = this.getProperty("pieSliceBorderColor","transparent");
	    chartOptions.pieSliceTextStyle  = {
		color: this.getProperty("pieSliceTextColor","white")
            };

	    chartOptions.chartArea = {};
	    $.extend(chartOptions.chartArea, {
                left: this.getProperty("chartLeft", 0),
                right: this.getProperty("chartRight", 0),
                top: this.getProperty("chartTop", 0),
		bottom: this.getProperty("chartBottom",0),
                width: '100%',
                height: '100%'
            });

            return new google.visualization.PieChart(chartDiv);
        },
	getColorList:function() {
	    if (this.getProperty("colors") && this.getProperty("colors")!="default") {
		return SUPER.getColorList.call(this);
	    }
	    if (this.getProperty("colorTable")) {
		let ct =this.getColorTable();
		return ct.colors;
	    }	    
	    return Utils.mergeLists(Utils.getColorTable("schemeset1",true),
				    Utils.getColorTable("schemecategory",true));
	},

        makeDataTable: function(dataList, props, selectedFields) {
            var dataTable = new google.visualization.DataTable();
            var list = [];
            var header = this.getDataValues(dataList[0]);
            dataTable.addColumn("string", header[0]);
            dataTable.addColumn("number", header[1]);


            if (this.getProperty("bins", null)) {
                var bins = parseInt(this.getProperty("bins", null));
                var min = Number.MAX_VALUE;
                var max = Number.MIN_VALUE;
                var haveMin = false;
                var haveMax = false;
                if (this.getProperty("binMin")) {
                    min = parseFloat(this.getProperty("binMin"));
                    haveMin = true;
                }
                if (this.getProperty("binMax")) {
                    max = parseFloat(this.getProperty("binMax"));
                    haveMax = true;
                }

                var goodValues = [];
                for (var i = 1; i < dataList.length; i++) {
                    var tuple = this.getDataValues(dataList[i]);
                    var value = tuple[1];
                    if (!Utils.isRealNumber(value)) {
                        continue;
                    }
                    if (!haveMin)
                        min = Math.min(value, min);
                    if (!haveMax)
                        max = Math.max(value, max);
                    goodValues.push(value);
                }

                var binList = [];
                var step = (max - min) / bins;
                for (var binIdx = 0; binIdx < bins; binIdx++) {
                    binList.push({
                        min: min + binIdx * step,
                        max: min + (binIdx + 1) * step,
                        values: []
                    });
                }

                for (var rowIdx = 0; rowIdx < goodValues.length; rowIdx++) {
                    var value = goodValues[rowIdx];
                    var ok = false;

                    for (var binIdx = 0; binIdx < binList.length; binIdx++) {
                        if (value < binList[binIdx].min || (value >= binList[binIdx].min && value <= binList[binIdx].max)) {
                            binList[binIdx].values.push(value);
                            ok = true;
                            break;
                        }
                    }
                    if (!ok) {
                        binList[binList.length - 1].values.push(value);
                    }
                }
                for (var binIdx = 0; binIdx < bins; binIdx++) {
                    var bin = binList[binIdx];
                    list.push(["Bin:" + this.formatNumber(bin.min) + "-" + this.formatNumber(bin.max),
                               bin.values.length
			      ]);
                }
            } else if(this.getProperty("sumFields")) {
		dataTable = new google.visualization.DataTable();
		dataTable.addColumn("string", "Category");
		dataTable.addColumn("number", "Value");
		var records=  this.filterData();
		let sumFields =  this.getFieldsByIds(null, this.getProperty("sumFields"));
		let sums = [];
		sumFields.map(f=>{sums.push(0)});
		if(this.chartCount>=0) {
		    records = [records[this.chartCount]];
		}
                records.map(record=>{
		    sumFields.map((f,idx)=>{
			var v = record.getValue(f.getIndex());
			if(!isNaN(v))  sums[idx]+=v;
		    });
		});
		sumFields.map((f,idx)=>{
                    list.push([f.getLabel(),sums[idx]>0?sums[idx]:0]);
		});

            } else {
                for (var i = 1; i < dataList.length; i++) {
                    var tuple = this.getDataValues(dataList[i]);
                    var s = "" + (tuple.length == 1 ? "#" + i : tuple[0]);
                    var v = tuple.length == 1 ? tuple[0] : tuple[1];
                    list.push([s, v]);
                }
            }
	    list.map(tuple=>{
		var s = tuple[0];
		if(!this.uniqueValuesMap[s]) {
		    this.uniqueValuesMap[s] = true;
		    this.uniqueValues.push(s);
		}
	    });
	    //	    list =[];
	    //	    for(i=0;i<20;i++)list.push([""+i,5]);


            dataTable.addRows(list);
            return dataTable;
        }
    });


}


//TODO: this is broken because we don't load the sankey package because it loads an old version of d3

function SankeyDisplay(displayManager, id, properties) {
    this.tries = 0;
    google.charts.load('49', {
        packages: ['sankey']
    });
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_SANKEY, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv,  selectedFields, chartOptions) {
            chartOptions.height = parseInt(this.getProperty("chartHeight", this.getProperty("height", "400")));
            chartOptions.sankey = {
                node: {
                    colors: this.colors,
                    width: 5,
                },
                link: {
                    colorMode: 'source',
                    colors: this.colors,
                    color: {
                        //                                stroke:'black',
                        //strokeWidth:1,
                    }
                }
            }
	    try {
		return new google.visualization.Sankey(chartDiv);
	    } catch(e) {
		//maybe sankey hasn't been loaded
		if(this.tries++<5) {
		    setTimeout(()=>{
			this.callUpdateUI();
		    },1000);
		}
		return null;
	    }
        },
        defaultSelectedToAll: function() {
            return true;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            if (!this.getProperty("doCategories", false)) {
                var values = this.makeDataArray(dataList);
                return google.visualization.arrayToDataTable(values);
            }
            var strings = [];
            for (var i = 0; i < selectedFields.length; i++) {
                var field = selectedFields[i];
                if (field.isFieldString()) {
                    strings.push(field);
                }
            }
            var values = [];
            values.push(["characteristic 1", "characteristic 2", "value"]);
            for (var i = 1; i < strings.length; i++) {
                var field1 = strings[i - 1];
                var field2 = strings[i];
                var cnts = {};
                for (var r = 1; r < dataList.length; r++) {
                    var row = this.getDataValues(dataList[r]);
                    var value1 = row[i - 1];
                    var value2 = row[i];
                    var key = value1 + "-" + value2;
                    if (!cnts[key]) {
                        cnts[key] = {
                            v1: value1,
                            v2: value2,
                            cnt: 0
                        }
                    }
                    cnts[key].cnt++;
                }
                for (a in cnts) {
                    values.push([cnts[a].v1, cnts[a].v2, cnts[a].cnt]);
                }
            }
            return google.visualization.arrayToDataTable(values);
        }
    });
}

function WordtreeDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_WORDTREE, properties);
    let myProps = [
	{label:"Word Tree"},
	{p:"treeRoot",d:"root", tt:"Word to use for root"},
	{p:"wordColors",ex:"red,green,blue",tt:"Colors to use for tree levels"},
	{p:"fixedSize",d:"false",tt:""},
	{p:"buckets",ex:"100,110,115,120,130",tt:"For numeric fields the buckets to put the records in"},	
	{p:"&lt;field&gt;.buckets",ex:"100,110,115,120,130",tt:"Specify buckets for a particular field"},
	{p:"bucketLabels",ex:"young,middle,old,really_old",tt:"For numeric fields the labels used for the buckets"},	
	{p:"&lt;field&gt;.bucketLabels",ex:"young,middle,old,really_old",tt:"Specify bucket labels for a particular field"},			
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        handleEventRecordSelection: function(source, args) {},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            if (this.getProperty("chartHeight"))
                chartOptions.height = parseInt(this.getProperty("chartHeight"));
            if (this.getWordColors()) {
                var tmp = this.getWordColors().split(",");
                var colors = [];
                for (var i = 0; i < 3 && i < tmp.length; i++) {
                    colors.push(tmp[i]);
                }
                if (colors.length == 3)
                    chartOptions.colors = colors;
            }

            if (this.getProperty("chartWidth")) {
                chartOptions.width = parseInt(this.getProperty("chartWidth"));
            }

            chartOptions.wordtree = {
                format: 'implicit',
                wordSeparator: "_SEP_",
                word: this.getTreeRoot(),
                //                    type: this.getProperty("treeType","double")

            }
            if (this.getProperty("maxFontSize")) {
                chartOptions.maxFontSize = parseInt(this.getProperty("maxFontSize"));
            }

            return new google.visualization.WordTree(chartDiv); 
        },


        makeDataTable: function(dataList, props, selectedFields) {
            //null ->get all data
            var root = this.getTreeRoot();
            var records = this.filterData(null, selectedFields, {skipFirst:true});
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var valueField = this.getFieldById(null, this.getProperty("colorBy"));
            var values = [];
            var typeTuple = ["phrases"];
            values.push(typeTuple);
            var fixedSize = this.getFixedSize();
            if (valueField)
                fixedSize = 1;
            if (fixedSize) typeTuple.push("size");
            if (valueField)
                typeTuple.push("value");
            var fieldInfo = {};

            var header = "";
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (header != "")
                    header += " -&gt;";
                header += field.getLabel();
                if (!field.isFieldNumeric()) continue;
                var column = this.getColumnValues(records, field);
                var buckets = [];
                var argBuckets = this.getProperty("buckets." + field.getId(), this.getProperty("buckets", null));
                var min, max;
                if (argBuckets) {
                    var argBucketLabels = this.getProperty("bucketLabels." + field.getId(), this.getProperty("bucketLabels", null));
                    var bucketLabels;
                    if (argBucketLabels)
                        bucketLabels = argBucketLabels.split(",");
                    var bucketList = argBuckets.split(",");
                    var prevValue = 0;
                    for (var bucketIdx = 0; bucketIdx < bucketList.length; bucketIdx++) {
                        var v = parseFloat(bucketList[bucketIdx]);
                        if (bucketIdx == 0) {
                            min = v;
                            max = v;
                        }
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                        if (bucketIdx > 0) {
                            var label;
                            if (bucketLabels && i <= bucketLabels.length)
                                label = bucketLabels[bucketIdx - 1];
                            else
                                label = Utils.formatNumber(prevValue, true) + "-" + Utils.formatNumber(v, true);
                            buckets.push({
                                min: prevValue,
                                max: v,
                                label: label
                            });
                        }
                        prevValue = v;
                    }
                } else {
                    var numBuckets = parseInt(this.getProperty("numBuckets." + field.getId(), this.getProperty("numBuckets", 10)));
                    min = column.min;
                    max = column.max;
                    var step = (column.max - column.min) / numBuckets;
                    for (var bucketIdx = 0; bucketIdx < numBuckets; bucketIdx++) {
                        var r1 = column.min + (bucketIdx * step);
                        var r2 = column.min + ((bucketIdx + 1) * step);
                        var label = Utils.formatNumber(r1, true) + "-" + Utils.formatNumber(r2, true);
                        buckets.push({
                            min: r1,
                            max: r2,
                            label: label
                        });
                    }
                }
                fieldInfo[field.getId()] = {
                    min: min,
                    max: max,
                    buckets: buckets
                };
            }

            var sep = "_SEP_";
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var row = this.getDataValues(records[rowIdx]);
                var string = root;
                for (var fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    var field = fields[fieldIdx];
                    string += sep;
                    var value = row[field.getIndex()];
                    if (field.isFieldNumeric()) {
                        var info = fieldInfo[field.getId()];
                        for (var bucketIdx = 0; bucketIdx < info.buckets.length; bucketIdx++) {
                            var bucket = info.buckets[bucketIdx];
                            if (value >= bucket.min && value <= bucket.max) {
                                value = bucket.label;
                                break;
                            }
                        }
                    }
                    string += value;
                }
                var data = [string.trim()];
                if (fixedSize) data.push(parseInt(fixedSize));
                if (valueField)
                    data.push(row[valueField.getIndex()]);
                values.push(data);
            }
            if (this.getProperty("header")) {
                header = this.getProperty("header", "");
            } else {
                header = "<b>Fields: </b>" + header;
                if (this.getProperty("headerPrefix"))
                    header = this.getProperty("headerPrefix") + " " + header;
            }
            this.writeHtml(ID_DISPLAY_TOP, header);
            return google.visualization.arrayToDataTable(values);
        },
    });
}



function TableDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TABLE, properties);
    let myProps = [
	{label:'Table'},
	{p:'imageField',ex:''},
	{p:'tableWidth',ex:'100%'},
	{p:'frozenColumns',ex:'1'},
	{p:'colorCells',ex:'field1,field2'},
	{p:'foregroundColor'},
	{p:'showRowNumber',ex:true},
	{p:'field.colorTable',ex:''},
	{p:'field.colorByMap',ex:'value1:color1,value2:color2'},
	{p:'maxHeaderLength',ex:'60'},
	{p:'maxHeaderWidth',ex:'60'},
	{p:'headerStyle'}];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        canDoGroupBy: function() {
            return true;
        },
        defaultSelectedToAll: function() {
            return true;
        },
        getDataTableValueGetter: function(records) {
	    let unhighlightColor = this.getProperty("unhighlightColor","#fff");
	    let highlightColor = this.getProperty("highlightColor","#FFFFCC");
	    let colorCells = this.getProperty("colorCells");
	    let colorByMap = {};
	    let linkField = this.getFieldById(null,this.getProperty("linkField"));
	    let iconField = this.getFieldById(null,this.getProperty("iconField"));
	    let foreground = this.getProperty("foregroundColor");
	    let cbs = [];
	    if(colorCells) {
		colorCells.split(",").forEach(c=>{
		    let f = this.getFieldById(null,c);
		    if(f) {
			colorByMap[c] = new ColorByInfo(this, null, records, null,c+".colorByMap",null, c, f);
			cbs.push(colorByMap[c]);
		    }
		});
	    }

	    //Show the bars
	    let dom = this.jq(ID_COLORTABLE);
	    cbs.forEach((cb,idx)=>{
		let id = this.domId(ID_COLORTABLE+idx);
		dom.append(HU.div([ID,id]));
		cb.displayColorTable(null,true,ID_COLORTABLE+idx);
	    });


	    return  (v,idx, field, record)=>{
		if(v===null) {
		    return {
			v:0,
			f:""
		    }
		}
		let f = v;
		if(v.f) {
		    f = v.f;
		    v = v.v;
		}
		if(v.getTime) {
		    f = this.formatDate(v);
		}
		if(iconField && record && idx==0) {
		    let icon = record.getValue(iconField.getIndex());
		    f = HU.image(icon) +"&nbsp;" +f;
		}
		if(linkField && record&& idx==0) {
		    let url = record.getValue(linkField.getIndex());
		    if(f) f = f.trim();
		    if (Utils.isDefined(f) && f!="") {
			f = HU.href(url,f);
		    }
		}

		if(!this.getFilterHighlight() || !record) {
		    f = HU.div([STYLE,HU.css('padding','4px')],f)
		} else {
		    let c = record.isHighlight(this) ? highlightColor: unhighlightColor;
		    f = HU.div([STYLE,HU.css('padding','4px','background', c)],f)
		}


		if(field) {
		    let colorBy = colorByMap[field.getId()];
		    if(colorBy && record) {
			let color =  colorBy.getColorFromRecord(record);
			let fg = foreground || Utils.getForegroundColor(color);
			f = HU.div([STYLE,HU.css('height','100%','background', color,'color',fg+" !important")],f)
		    }
		    if(field.getType()=="url") {
			return {
			    v:v,
			    f:HU.href(v,v)
			};
		    }
		    if(field.getType()=="image") {
			return {
			    v:v,
			    f:HU.href(v,HU.image(v,[WIDTH,this.getProperty("imageWidth",100)]))
			};
		    }		    
		}

		return {
		    v:v,
		    f:f
		};
	    }
	},
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    let expandedHeight  = this.getProperty("expandedHeight");
	    if(!expandedHeight) {
		chartOptions.height = null;
		if (this.chartHeight) {
                    chartOptions.height = this.chartHeight;
		}
		if (chartOptions.height == null) {
                    var height = this.getProperty("height", null);
                    if (height) {
			chartOptions.height = height;
                    }
		}
		if (chartOptions.height == null) {
                    chartOptions.height = "300px";
		}
	    }


	    if(this.debugChartOptions)
		console.log(JSON.stringify(chartOptions,null,2));
            chartOptions.allowHtml = true;
	    if(this.getProperty("tableWidth"))
		chartOptions.width=this.getProperty("tableWidth");
            chartOptions.frozenColumns =this.getProperty("frozenColumns",0);
	    chartOptions.showRowNumber=this.getProperty("showRowNumber",false);

            if (dataList.length && this.getDataValues(dataList[0]).length > 4) {
                chartOptions.cssClassNames = {
                    headerCell: 'display-table-header-max'
                };
            } else {
                chartOptions.cssClassNames = {
                    headerCell: 'display-table-header'
                };
            }
	    if(!chartOptions.cssClassNames)
		chartOptions.cssClassNames = {};

	    if(this.getProperty("fixCellHeight",true)) {
		chartOptions.cssClassNames.headerCell= 'display-table-cell';
		chartOptions.cssClassNames.tableCell= 'display-table-cell';
	    }
            return new google.visualization.Table(chartDiv); 
        },
	getAddToolTip: function() {
	    return false;
	},
	getAddStyle: function() {
	    return false;
	},
	getFormatNumbers: function() {
	    return true;
	},
	formatNumber: function(n) {
	    if(isNaN(n))
                return this.getProperty("nanValue", "--");
	    return SUPER.formatNumber.call(this, n);
	},
        xxxxmakeDataTable: function(dataList, props, selectedFields) {
            var rows = this.makeDataArray(dataList);
            var data = [];
            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var row = rows[rowIdx];
                for (var colIdx = 0; colIdx < row.length; colIdx++) {
		    var t = (typeof row[colIdx]);
                    if (t == "string") {
                        row[colIdx] = row[colIdx].replace(/\n/g, "<br>");
			if(row[colIdx].startsWith("http:") || row[colIdx].startsWith("https:")) {
			    row[colIdx] = "<a href='" +row[colIdx] +"'>" + row[colIdx]+"</a>";
			}
		    } else if(t == "number") {
			//This doesn't stick
			if(isNaN(row[colIdx])) 
			    row[colIdx] = "--";
		    }
                }
                data.push(row);
            }
            return google.visualization.arrayToDataTable(data);
        }
    });

}



function BubbleDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_BUBBLE, properties);
    let myProps = [
	{label:'Bubble Chart Attibutes'},
	{p:'legendPosition',ex:'none|top|right|left|bottom'},
	{p:'hAxisFormat',ex:'none|decimal|scientific|percent|short|long'},
	{p:'vAxisFormat',ex:'none|decimal|scientific|percent|short|long'},
	{p:'hAxisTitle',ex:''},
	{p:'vAxisTitle',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getChartDiv: function(chartId) {
            var divAttrs = [ATTR_ID, chartId];
            divAttrs.push(STYLE);
            var style = "";
	    var width = this.getProperty("chartWidth") || this.getChartWidth();
	    var height = this.getProperty("chartHeight") || this.getChartHeight();
            if (width) {
                if (width > 0)
                    style += "width:" + width + "px;";
                else if (width < 0)
                    style += "width:" + (-width) + "%;";
                else
                    style += "width:" + width + ";";
            } else {
                style += "width:" + "100%;";
            }
            if (height) {
                if (height > 0)
                    style += "height:" + height + "px;";
                else if (height < 0)
                    style += "height:" + (-height) + "%;";
                else
                    style += "height:" + height + ";";
            } else {
                style += "height:" + "100%;";
            }
	    //	    style += "border:1px solid green;"
	    style += "padding:5px;"
            divAttrs.push(style);
            return HU.div(divAttrs, "");
        },

	getFieldsToDisplay: function(fields) {
	    if(fields.length>=4) return fields;
	    let labelField=this.getFieldById(null, this.getProperty("labelField"));
	    let colorField=this.getFieldById(null, this.getProperty("labelField"));
	    let sizeField=this.getFieldById(null, this.getProperty("sizeField"));
	    let xField=this.getFieldById(null, this.getProperty("xField"));
	    let yField=this.getFieldById(null, this.getProperty("yField"));	    	    	    	    
	    if(!labelField) throw new Error("Need to specify labelField");
	    if(!xField) throw new Error("Need to specify xField");
	    if(!yField) throw new Error("Need to specify yField");	    
	    let f = [labelField, xField, yField];
	    if(colorField) f.push(colorField);
	    if(sizeField) f.push(sizeField);
	    console.log("F:" + f);
	    return f;
	},

        makeDataTable: function(dataList, props, selectedFields, chartOptions) {
	    let debug =displayDebug.makeDataTable;
	    if(debug) {
		console.log(this.type+" makeDataTable #records:" + dataList.length);
                var fields = this.getSelectedFields();
		console.log("\t fields:" + fields);
	    }
	    var tmp =[];
	    var a = this.makeDataArray(dataList);
	    while(a[0].length<5)
		a[0].push("");
	    tmp.push(a[0]);
	    //Remove nans
	    this.didUnhighlight = false;
	    let minColorValue = Number.MAX_SAFE_INTEGER;
	    for(var i=1;i<a.length;i++) {
		var tuple = a[i];
		while(tuple.length<5) {
		    tuple.push(1);
		}
		minColorValue = Math.min(minColorValue, tuple[3]);
	    }


	    for(var i=1;i<a.length;i++) {
		var tuple = a[i];
		while(tuple.length<5)
		    tuple.push(1);
		if(debug && i<5)
		    console.log("\tdata:" + tuple);
		var ok = true;
		for(j=1;j<tuple.length && ok;j++) {
		    if(isNaN(tuple[j])) ok = false;
		}
		//If highlighting and have color then set to NaN
		if(this.getFilterHighlight()) {
		    let unhighlightColor = this.getProperty("unhighlightColor","#eee");
		    if(dataList[i].record && !dataList[i].record.isHighlight(this)) {
			this.didUnhighlight = true;
			tuple[3] =minColorValue-0.111;
		    }
		}
		if(ok) 
		    tmp.push(tuple);
	    }
            return google.visualization.arrayToDataTable(tmp);
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            var ct = this.getColorTable(true);
            if (ct) {
                chartOptions.colors = ct;
            } else if (!this.colors) {
                chartOptions.colors = this.getColorList();
            }
            if (chartOptions.colors) {
                chartOptions.colors = Utils.getColorTable("rainbow", true);
            }
	    $.extend(chartOptions.chartArea, {
                left: this.getProperty("chartLeft", this.chartDimensions.left),
                right: this.getProperty("chartRight", this.chartDimensions.right),
                top: this.getProperty("chartTop", "10"),
		bottom: this.getProperty("chartBottom",40),
		//                width: this.getProperty("chartWidth", '98%'),
                height: this.getProperty("chartHeight", '200')
            });
            chartOptions.height = "100px";
            chartOptions.sizeAxis = {
	    }

            chartOptions.colorAxis = {
                legend: {
                    position: this.getProperty("legendPosition", "in")
                }
            }
	    var colorTable = this.getColorTable(true);
	    if(colorTable) {
		chartOptions.colorAxis.colors = colorTable;
		if(this.didUnhighlight) {
		    chartOptions.colorAxis.colors = [...chartOptions.colorAxis.colors];
		    chartOptions.colorAxis.colors.unshift(this.getProperty("unhighlightColor","#eee"));
		}
	    }

            chartOptions.bubble = {
                textStyle: {
                    auraColor: "none"
                },
                stroke: "#666"
            };


            header = this.getDataValues(dataList[0]);
	    chartOptions.hAxis = chartOptions.hAxis||{};
            chartOptions.vAxis = chartOptions.vAxis||{};

	    chartOptions.hAxis.minValue = this.getProperty("hAxisMinValue");
	    chartOptions.hAxis.maxValue = this.getProperty("hAxisMaxValue");
	    chartOptions.vAxis.minValue = this.getProperty("vAxisMinValue");
	    chartOptions.vAxis.maxValue = this.getProperty("vAxisMaxValue");


            let records = this.getPointData().getRecords();
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[1]);
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }
	    if(this.getProperty("vAxisFixedRange")) {
		let y = this.getColumnValues(records, selectedFields[2]);
		chartOptions.vAxis.minValue = y.min;
		chartOptions.vAxis.maxValue = y.max;
	    }



	    chartOptions.vAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");
	    chartOptions.hAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");

            chartOptions.hAxis.format = this.getProperty("hAxisFormat", null);
            chartOptions.vAxis.format = this.getProperty("vAxisFormat", null);

            chartOptions.hAxis.title = this.getProperty("hAxisTitle", header.length > 1 ? header[1] : null);
            chartOptions.vAxis.title = this.getProperty("vAxisTitle", header.length > 2 ? header[2] : null);

	    //	    console.log(JSON.stringify(chartOptions,null,2));

            return new google.visualization.BubbleChart(chartDiv); 
        }

    });
}


function BartableDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaSeriesChart(displayManager, id, DISPLAY_BARTABLE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            var height = "";
            if (Utils.isDefined(this.chartHeight)) {
                height = this.chartHeight;
            } else {
                if (dataList.length > 1) {
                    var numBars = dataList.length;
                    if (this.isStacked) {
                        height = numBars * 22;
                    } else {
                        height = numBars * 22 + numBars * 14 * (this.getDataValues(dataList[0]).length - 2);
                    }
                }
            }

            $.extend(chartOptions, {
                title: "the title",
                bars: 'horizontal',
                colors: this.getColorList(),
                width: (Utils.isDefined(this.chartWidth) ? this.chartWidth : "100%"),
                chartArea: {
                    left: '30%',
                    top: 0,
                    width: '70%',
                    height: '80%'
                },
                height: height,
                bars: 'horizontal',
                tooltip: {
                    showColorCode: true,
                },
                legend: {
                    position: 'none'
                },
            });

            if (Utils.isDefined(this.isStacked)) {
                chartOptions.isStacked = this.isStacked;
            }

            if (this.hAxis)
                chartOptions.hAxis = {
                    title: this.hAxis
                };
            if (this.vAxis)
                chartOptions.vAxis = {
                    title: this.vAxis
                };
            return new google.charts.Bar(chartDiv); 
        },
        getDefaultSelectedFields: function(fields, dfltList) {
            var f = [];
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (!field.isNumeric()) {
                    f.push(field);
                    break;
                }
            }
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (field.isNumeric()) {
                    f.push(field);
                    break;
                }
            }
            return f;
        }
    });


}


function TreemapDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TREEMAP, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        handleEventRecordSelection: function(source, args) {},
        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        tooltips: {},
        makeChartOptions: function(dataList, props, selectedFields) {
            let _this = this;
            var tooltip = function(row, size, value) {
                if (_this.tooltips[row]) {
                    return _this.tooltips[row];
                }
                return "<div class='display-treemap-tooltip-outer'><div class='display-treemap-tooltip''><i>left-click: go down<br>right-click: go up</i></div></div>";
            };
            var chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            $.extend(chartOptions, {
                highlightOnMouseOver: true,
                generateTooltip: tooltip,
                maxDepth: parseInt(this.getProperty("maxDepth", 2)),
                maxPostDepth: parseInt(this.getProperty("maxPostDepth", 3)),
            });

            return chartOptions;
        },
        defaultSelectedToAll: function() {
            return true;
        },

        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            var dataTable = this.makeDataTable(dataList, props, selectedFields, chartOptions);
            if (!dataTable) return null;
            return new google.visualization.TreeMap(chartDiv);
        },

        addTuple: function(data, colorField, seen, value, parent, n1, n2) {
            var ovalue = value;
            var cnt = 0;
            if (Utils.isDefined(seen[value]) && parent) {
                value = parent + ":" + value;
            }
            while (true) {
                if (!Utils.isDefined(seen[value])) {
                    seen[value] = true;
                    break;
                }
                value = ovalue + " " + (++cnt);
            }
            var tuple = [value, parent, n1];
            if (colorField) tuple.push(n2);
            data.push(tuple);
            return value;
        },

        valueClicked: function(field, value) {
            field = this.getFieldById(this.getFields(), field);
            this.propagateEvent("handleEventFieldValueSelect", {
                field: field,
                value: value
            });
        },
        makeDataTable: function(dataList, props, selectedFields) {
            var records = this.filterData(null,null,{skipFirst:true});
            if (!records) {
                return null;
            }
            var allFields = this.getFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length < 2) {
                this.displayError("No string fields specified");
                return null;
            }
            var addPrefix = this.getProperty("addPrefix", true);
            var sizeField = this.getFieldById(allFields, this.getProperty("sizeBy"));
            var colorField = this.getFieldById(allFields, this.getProperty("colorBy"));
            var values = this.getFieldsByType(fields, "numeric");
            if (!sizeField && values.length > 0)
                sizeField = values[0];
            if (!colorField && values.length > 1)
                colorField = values[1];

            var tooltipFields = [];
            var toks = this.getProperty("tooltipFields", "").split(",");
            for (var i = 0; i < toks.length; i++) {
                var tooltipField = this.getFieldById(null, toks[i]);
                if (tooltipField)
                    tooltipFields.push(tooltipField);
            }
            if (tooltipFields.length == 0) tooltipFields = allFields;

            this.tooltips = {};

            var columns = [];
            for (var fieldIndex = 0; fieldIndex < strings.length; fieldIndex++) {
                var field = strings[fieldIndex];
                columns.push(this.getColumnValues(records, field).values);
            }

            var data = [];
            var leafs = [];
            var tmptt = [];
            var seen = {};
            this.addTuple(data, colorField, {}, "Node", "Parent", "Value", "Color");
            var root = strings[0].getLabel();
            this.addTuple(data, colorField, seen, root, null, 0, 0);
            var keys = {};
            var call = this.getGet();
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                //               if(rowIdx>20) break;
                var row = this.getDataValues(records[rowIdx]);
                var key = "";
                var parentKey = "";
                for (var fieldIndex = 0; fieldIndex < strings.length - 1; fieldIndex++) {
                    var values = columns[fieldIndex];
                    if (key != "")
                        key += ":";
                    key += values[rowIdx];
                    if (!Utils.isDefined(keys[key])) {
                        var parent = Utils.isDefined(keys[parentKey]) ? keys[parentKey] : root;
                        var value = values[rowIdx];
                        if (addPrefix && fieldIndex > 0)
                            value = parent + ":" + value;
                        keys[key] = this.addTuple(data, colorField, seen, value, parent, 0, 0);
                    }
                    parentKey = key;
                }
                var parent = Utils.isDefined(keys[parentKey]) ? keys[parentKey] : root;
                var value = row[strings[strings.length - 1].getIndex()];
                var size = sizeField ? row[sizeField.getIndex()] : 1;
                var color = colorField ? row[colorField.getIndex()] : 0;
                value = this.addTuple(leafs, colorField, seen, value, parent, size, color);
                var tt = "<div class='display-treemap-tooltip-outer'><div class='display-treemap-tooltip''>";
                for (var f = 0; f < tooltipFields.length; f++) {
                    var v = row[tooltipFields[f].getIndex()];
                    var field = tooltipFields[f];
                    v = HU.onClick(call + ".valueClicked('" + field.getId() + "','" + v + "')", v, []);
                    tt += HU.b(field.getLabel()) + ": " + v + "<br>";
                }
                tt += "</div></div>";
                tmptt.push(tt);
            }
            for (var i = 0; i < leafs.length; i++) {
                data.push(leafs[i]);
                this.tooltips[data.length - 2] = tmptt[i];
            }
            return google.visualization.arrayToDataTable(data);
        },
    });
}



function TimerangechartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaTextChart(displayManager, id, DISPLAY_TIMERANGECHART, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            return new google.visualization.Timeline(chartDiv);
        },
        makeDataTable: function(dataList, props, selectedFields) {
	    var records = this.filterData(null,null,{skipFirst:true});
            var strings = [];
            var stringField = this.getFieldByType(selectedFields, "string");
            if (!stringField)
                stringField = this.getFieldByType(null, "string");
            var showLabel = this.getProperty("showLabel", true);
            var labelFields = [];
            var labelFieldsTemplate = this.getProperty("labelFieldsTemplate");
            var toks = this.getProperty("labelFields", "").split(",");
            for (var i = 0; i < toks.length; i++) {
                var field = this.getFieldById(null, toks[i]);
                if (field)
                    labelFields.push(field);
            }
            var dateFields = this.getFieldsByType(selectedFields, "date");
            if (dateFields.length == 0)
                dateFields = this.getFieldsByType(null, "date");
            var values = [];
            var dataTable = new google.visualization.DataTable();
            if (dateFields.length < 2) {
                throw new Error("Need to have at least 2 date fields");
            }
            if (stringField) {
                dataTable.addColumn({
                    type: 'string',
                    id: stringField.getLabel()
                });
            } else {
                dataTable.addColumn({
                    type: 'string',
                    id: "Index"
                });
            }
            if (labelFields.length > 0) {
                dataTable.addColumn({
                    type: 'string',
                    id: 'Label'
                });
            }
            dataTable.addColumn({
                type: 'date',
                id: dateFields[0].getLabel()
            });
            dataTable.addColumn({
                type: 'date',
                id: dateFields[1].getLabel()
            });
            for (var r = 0; r < records.length; r++) {
                var row = this.getDataValues(records[r]);
                var tuple = [];
                values.push(tuple);
                if (stringField && showLabel)
                    tuple.push(row[stringField.getIndex()]);
                else
                    tuple.push("#" + (r + 1));
                if (labelFields.length > 0) {
                    var label = "";
                    if (labelFieldsTemplate)
                        label = labelFieldsTemplate;
                    for (var l = 0; l < labelFields.length; l++) {
                        var f = labelFields[l];
                        var value = row[f.getIndex()];
                        if (labelFieldsTemplate) {
                            label = label.replace("{" + f.getId() + "}", value);
                        } else {
                            label += value + " ";
                        }

                    }
                    tuple.push(label);
                }
                tuple.push(row[dateFields[0].getIndex()]);
                tuple.push(row[dateFields[1].getIndex()]);
            }
            dataTable.addRows(values);
            return dataTable;
        }
    });
}



function CalendarDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_CALENDAR, properties);
    let myProps = [
	{label:'Calendar'},
	{p:'cellSize',d:15,ex:"15"},
	{p:'missingValue',ex:""},	
	{p:'strokeColor',d: '#76a7fa', ex:'#76a7fa'},
	{p:'strokeWidth',ex:'1'},
	{p:'strokeOpacity',d:0.5,ex:'0.5'},	    		
	{p:'noDataBackground',ex:'green'},
	{p:'noDataColor',ex:'red'},
	{p:'colorAxis',ex:'red,blue'},	

    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    let opts = {
		calendar: {
                    cellSize: parseInt(this.getPropertyCellSize()),
		    cellColor: {
			stroke: this.getPropertyStrokeColor(),
			strokeOpacity: this.getPropertyStrokeOpacity(),
			strokeWidth: this.getPropertyStrokeWidth(1),
		    },
		},
		height: this.getProperty("height", 800),
		noDataPattern: {
		    backgroundColor: this.getPropertyNoDataBackground(),
		    color: this.getPropertyNoDataColor()
		},
	    };
	    let colors = this.getPropertyColorAxis();
	    if(colors) {
		opts.colorAxis =  {
		    colors:colors.split(",")
		}
	    }
	    $.extend(chartOptions, opts);
            //If a calendar is show in tabs then it never returns from the draw
            if (this.jq(ID_CHART).width() == 0) {
                return;
            }

            let cal =  new google.visualization.Calendar(chartDiv);
	    return cal;

        },
        defaultSelectedToAll: function() {
            return true;
        },
        getContentsStyle: function() {
            var height = this.getProperty("height", 800);
            if (height > 0) {
                return " height:" + height + "px; " + " max-height:" + height + "px; overflow-y: auto;";
            }
            return "";
        },
        canDoMultiFields: function() {
            return false;
        },
        getIncludeIndexIfDate: function() {
            return true;
        },
        makeDataTable: function(dataList, props, selectedFields) {
            var dataTable = new google.visualization.DataTable();
            var header = this.getDataValues(dataList[0]);
            if (header.length < 2) return null;
            dataTable.addColumn({
                type: 'date',
                id: 'Date'
            });
            dataTable.addColumn({
                type: 'number',
                id: header[1]
            });
            dataTable.addColumn({
                type: 'string',
                role: 'tooltip',
                'p': {
                    'html': true
                }
            });
            var haveMissing = false;
            var missing = this.getPropertyMissingValue();
            if (missing) {
                haveMissing = true;
                missing = parseFloat(missing);
            }
            var list = [];
            var cnt = 0;
            var options = {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            };
	    this.dateToRecords = {};
            for (var i = 1; i < dataList.length; i++) {
		let records = this.getBinnedRecords(dataList[i].record);
		let obj = dataList[i];
		if(!records && obj.record) records  = [obj.record];
                var value = this.getDataValues(obj)[1];
                if (value == NaN) continue;
                if (haveMissing && value == missing) {
                    continue;
                }
                cnt++;

		let dttm = this.getDataValues(dataList[i])[0];
		this.dateToRecords[dttm.v.getTime()] = records;
                var tooltip = "<center><b>" + dttm.f + "</b></center>" +
                    "<b>" + header[1].replace(/ /g, "&nbsp;") + "</b>:&nbsp;" + this.formatNumber(value);
                tooltip = HU.div([STYLE, HU.css('padding','5px')], tooltip);
                list.push([this.getDataValues(dataList[i])[0], value, tooltip]);
            }
            dataTable.addRows(list);
            return dataTable;
	}

    });


}




function GaugeDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaGoogleChart(displayManager, id, DISPLAY_GAUGE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getChartHeight: function() {
            return this.getProperty("height", this.getChartWidth());
        },
        getChartWidth: function() {
            return this.getProperty("width", "150");
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
            this.dataList = dataList;
            this.chartOptions = chartOptions;
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            var setMinMax = true;
            for (var row = 1; row < dataList.length; row++) {
                var tuple = this.getDataValues(dataList[row]);
                //                        if(tuple.length>2) setMinMax = false;
                for (var col = 0; col < tuple.length; col++) {
                    if (!Utils.isNumber(tuple[col])) {
                        continue;
                    }
                    var value = tuple[col];
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
            min = Utils.formatNumber(min, true);
            max = Utils.formatNumber(max, true);
            if (Utils.isDefined(this.gaugeMin)) {
                setMinMax = true;
                min = parseFloat(this.gaugeMin);
            }
            if (Utils.isDefined(this.gaugeMax)) {
                setMinMax = true;
                max = parseFloat(this.gaugeMax);
            }
            if (setMinMax) {
                chartOptions.min = min;
                chartOptions.max = max;
            }
            return new google.visualization.Gauge(chartDiv);
        },

        makeDataTable: function(dataList, props, selectedFields) {
            dataList = this.makeDataArray(dataList);
            if (!Utils.isDefined(this.index)) this.index = dataList.length - 1;
            var index = this.index + 1;
            var list = [];
            list.push(["Label", "Value"]);
            var header = this.getDataValues(dataList[0]);
            if (index >= dataList.length) index = dataList.length - 1;
            var row = this.getDataValues(dataList[index]);
            for (var i = 0; i < row.length; i++) {
                if (!Utils.isNumber(row[i])) continue;
                var h = header[i];
                if (h.length > 20) {
                    var index = h.indexOf("(");
                    if (index > 0) {
                        h = h.substring(0, index);
                    }
                }
                if (h.length > 20) {
                    h = h.substring(0, 19) + "...";
                }
                if (this.getProperty("gaugeLabel"))
                    h = this.getProperty("gaugeLabel");
                else if (this["gaugeLabel" + (i + 1)]) h = this["gaugeLabel" + (i + 1)];
                var value = row[i];
                list.push([h, Utils.formatNumber(value, true)]);
            }
            return google.visualization.arrayToDataTable(list);
        },
        setChartSelection: function(index) {
            this.index = index;
            var dataTable = this.makeDataTable(this.dataList);
            this.mapCharts(chart=>{

                chart.draw(dataTable, this.chartOptions);
	    });
        },
    });
}




function ScatterplotDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaGoogleChart(displayManager, id, DISPLAY_SCATTERPLOT, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        trendLineEnabled: function() {
            return true;
        },
	setAxisRanges: function(chartOptions, selectedFields, records) {
	    if(this.getProperty("hAxisFixedRange")) {
		let x = this.getColumnValues(records, selectedFields[0]);
		if(chartOptions.hAxis) chartOptions.hAxis = {};
		chartOptions.hAxis.minValue = x.min;
		chartOptions.hAxis.maxValue = x.max;
	    }

	    if(this.getProperty("vAxisFixedRange")) {
		if(chartOptions.vAxis) chartOptions.vAxis = {};
		let x = this.getColumnValues(records, selectedFields[1]);
		chartOptions.vAxis.minValue = x.min;
		chartOptions.vAxis.maxValue = x.max;
	    }
	},
        makeChartOptions: function(dataList, props, selectedFields) {
            var chartOptions = SUPER.makeChartOptions.call(this, dataList, props, selectedFields);
            chartOptions.curveType = null;
            chartOptions.lineWidth = 0;
            $.extend(chartOptions, {
                title: '',
                tooltip: {
                    isHtml: true
                },
                legend: 'none',
            });

            if (!chartOptions.chartArea) chartOptions.chartArea = {};
            $.extend(chartOptions.chartArea, {
                left: "10%",
                top: 10,
                height: "80%",
                width: "90%"
            });
            if (this.getShowTitle()) {
                chartOptions.title = this.getTitle(true);
            }

	    if (!chartOptions.hAxis) chartOptions.hAxis = {};
	    if (!chartOptions.vAxis) chartOptions.vAxis = {};
	    if(this.getProperty("hAxisLogScale", false)) 
		chartOptions.hAxis.logScale = true;
	    if(this.getProperty("vAxisLogScale", false)) 
		chartOptions.vAxis.logScale = true;


	    chartOptions.vAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");
	    chartOptions.hAxis.viewWindowMode = this.getProperty("viewWindowMode","pretty");

	    /*
	      chartOptions.trendlines =  {
	      0: {
	      type: 'linear',
	      color: 'green',
	      lineWidth: 3,
	      opacity: 0.3,
	      showR2: true,
	      visibleInLegend: true
	      }
	      };		

	    */


            if (dataList.length > 0 && this.getDataValues(dataList[0]).length > 1) {
                if (!chartOptions.vAxis) chartOptions.vAxis = {};
                if (!chartOptions.hAxis) chartOptions.hAxis = {};
		if (this.getProperty("hAxisTitle")) {
                    chartOptions.hAxis.title = this.getProperty("hAxisTitle");
		}
		if (this.getProperty("vAxisTitle")) {
                    chartOptions.vAxis.title = this.getProperty("vAxisTitle");
		}

		if(!chartOptions.hAxis.title) {
                    $.extend(chartOptions.hAxis, {
			title: this.getDataValues(dataList[0])[0]
                    });
		}

		if(!chartOptions.vAxis.title) {
                    $.extend(chartOptions.vAxis, {
			title: this.getDataValues(dataList[0])[1]
                    });
		}
                //We only have the one vAxis range for now
                if (!isNaN(this.getVAxisMinValue())) {
		    //                    chartOptions.hAxis.minValue = this.getVAxisMinValue();
                    chartOptions.vAxis.minValue = this.getVAxisMinValue();
                }
                if (!isNaN(this.getVAxisMaxValue())) {
		    //                    chartOptions.hAxis.maxValue = this.getVAxisMaxValue();
                    chartOptions.vAxis.maxValue = this.getVAxisMaxValue();
                }
            }
	    //	    console.log(JSON.stringify(chartOptions,null,2));

            return chartOptions;
        },
        doMakeGoogleChart: function(dataList, props, chartDiv, selectedFields, chartOptions) {
	    if(!chartDiv) return
            var height = this.getProperty("height",400);
            if (Utils.isDefined(this.getProperty("chartHeight"))) {
                height = this.getProperty("chartHeight");
            }
            var width = "100%";
	    if (Utils.isDefined(this.getProperty("chartWidth"))) {
                width = this.getProperty("chartWidth");
            }
	    if((typeof height)=="number") height = height+"px";
	    if((typeof width)=="number") width = width+"px";

            $("#" + chartDiv.id).css("width", width);
            $("#" + chartDiv.id).css("height", height);
            return new google.visualization.ScatterChart(chartDiv);
        },

        getDefaultSelectedFields: function(fields, dfltList) {
            var f = [];
            for (i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (field.isNumeric()) {
                    f.push(field);
                    if (f.length >= 2)
                        break;
                }
            }
            return f;
        }
    });


}



/*
  Copyright 2008-2020 Geode Systems LLC
*/

const DISPLAY_SLIDES = "slides";
const DISPLAY_IMAGES = "images";
const DISPLAY_IMAGEZOOM = "imagezoom";
const DISPLAY_CARDS = "cards";


addGlobalDisplayType({
    type: DISPLAY_IMAGES,
    label: "Images",
    requiresData: true,
    forUser: true,
    category:CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Image Gallery","images.png"),                    
});

addGlobalDisplayType({
    type: DISPLAY_IMAGEZOOM,
    label: "Image Zoom",
    requiresData: true,
    forUser: true,
    category:CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Image Zoom","imagezoom.png","Show a set of images and allow for zooming in"),                        
});

addGlobalDisplayType({
    type: DISPLAY_SLIDES,
    label: "Slides",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Show records in a slide like format","slides.png")
});


addGlobalDisplayType({
    type: DISPLAY_CARDS,
    label: "Cards",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Group records hierachically showing images","cards.png"),                
});


function RamaddaCardsDisplay(displayManager, id, properties) {
    const ID_RESULTS = "results";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CARDS, properties);
    Utils.importJS(ramaddaBaseUrl + "/lib/color-thief.umd.js",
		   () => {},
		   (jqxhr, settings, exception) => {
		       console.log("err");
		   });
  
    let myProps = [
	{label:'Cards Attributes'},
	{p:'groupByFields',ex:''},
	{p:'groupBy',ex:''},
	{p:'tooltipFields',ex:''},
	{p:'initGroupFields',ex:''},
	{p:'captionTemplate',ex:'${name}'},
	{p:'sortFields',ex:''},
	{p:'labelField',ex:''},
	{p:'imageWidth',ex:'100'},
	{p:'imageMargin',ex:'5'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        updateUI: function() {
            this.colorAnalysisEnabled = this.getProperty("doColorAnalysis");
            var pointData = this.getData();
            if (pointData == null) return;
            var allFields = pointData.getRecordFields();
	    var fields = this.getSelectedFields(allFields);
            if (fields == null || fields.length == 0) {
                fields = allFields;
	    }
            var records = this.filterData();
            if(!records) return;
	    let theFields = fields;
	    this.initGrouping  = this.getFieldsByIds(fields, this.getProperty("initGroupFields","",true));
            this.groupByFields = this.getFieldsByIds(fields, this.getProperty("groupByFields","",true));
            this.groupByMenus= +this.getProperty("groupByMenus",this.groupByFields.length);
            this.imageField = this.getFieldByType(fields, "image");
            this.urlField = this.getFieldByType(fields, "url");
            this.tooltipFields = this.getFieldsByIds(fields, this.getProperty("tooltipFields","",true));
            this.labelFields = this.getFieldsByIds(fields, this.getProperty("labelFields", null, true));
	    if(this.labelFields.length==0) {
		var tmp = this.getFieldById(fields,this.getProperty("labelField", null, true));
		if(tmp) {
		    this.labelFields.push(tmp);
		}
	    }
            this.onlyShowImages =this.getProperty("onlyShowImages", false);
            this.altLabelField = this.getFieldById(fields, this.getProperty("altLabelField", null, true));
            this.captionFields = this.getFieldsByIds(fields, this.getProperty("captionFields", "", true));
            this.captionTemplate = this.getProperty("captionTemplate",null, true);
            if(this.captionFields.length==0) this.captionFields = this.tooltipFields;
            this.colorByField = this.getFieldById(fields, this.getProperty("colorBy", null, true));
            this.colorList = this.getColorTable(true);
            this.foregroundList = this.getColorTable(true,"foreground");
            if(!this.getProperty("showImages",true)) this.imageField = null;

            if(!this.imageField)  {
                if(this.captionFields.length==0) {
                    this.displayError("No image or caption fields specified");
                    return;
                }
            }
            var contents = "";

	    if(!this.groupByHtml) {
		this.groupByHtml = "";
		if(this.colorAnalysisEnabled)
		    this.groupByHtml +=  HU.span([CLASS,"ramadda-button",ID,this.domId("docolors")], "Do colors")+" " +
		    HU.span([CLASS,"ramadda-button",ID,this.domId("docolorsreset")], "Reset");
		if(this.groupByFields.length>0) {
		    var options = [["","--"]];
		    this.groupByFields.map(field=>{
			options.push([field.getId(),field.getLabel()]);
		    });

		    this.groupByHtml +=  HU.span([CLASS,"display-fitlerby-label"], " Group by: ");
		    for(var i=0;i<this.groupByMenus;i++) {
			var selected = "";
			if(i<this.initGrouping.length) {
			    selected = this.initGrouping[i].getId();
			}
			this.groupByHtml+= HU.select("",[ID,this.domId(ID_GROUPBY_FIELDS+i)],options,selected)+"&nbsp;";
		    }
		    this.groupByHtml+="&nbsp;";
		    this.jq(ID_HEADER1).html(HU.div([CLASS,"display-filterby"],this.groupByHtml));
		    this.jq("docolors").button().click(()=>{
			this.analyzeColors();
		    });
		    this.jq("docolorsreset").button().click(()=>{
			this.updateUI();
		    });


		}
	    }



            contents += HU.div([ID,this.domId(ID_RESULTS)]);
            this.setContents(contents);
            let _this = this;
            this.jq(ID_HEADER1).find("input, input:radio,select").change(function(){
                _this.updateUI();
            });

            this.displaySearchResults(records,theFields);
        },
	analyzeColors: function() {
	    if(!window["ColorThief"]) {
		setTimeout(()=>this.analyzeColors(),1000);
		return;
	    }
	    const colorThief = new ColorThief();
	    var cnt = 0;
	    while(true) {
		var img = document.querySelector('#' + this.domId("gallery")+"img" + cnt);
		var div = $('#' + this.domId("gallery")+"div" + cnt);
		cnt++;
		if(!img) {
		    return;
		    
		}
		img.crossOrigin = 'Anonymous';
		// Make sure image is finished loading
		//		    if (img.complete) {
		var c = colorThief.getColor(img);
		var p = colorThief.getPalette(img);
		var width = img.width/p.length;
		var html = "";
		for(var i=0;i<p.length;i++) {
		    var c = p[i];
		    html+=HU.div([STYLE,HU.css('display','inline-block','width', width + "px','height', img.height +'px','background','rgb(" + c[0]+"," + c[1] +"," + c[2]+")")],"");
		}
		div.css("width",img.width);
		div.css("height",img.height);
		div.html(html);
		//			div.css("background","rgb(" + c[0]+"," + c[1] +"," + c[2]);
		img.style.display = "none";
	    }
	},
	displaySearchResults: function(records, fields) {
	    records= this.sortRecords(records);
            var fontSize = this.getProperty("fontSize",null);
            var cardStyle = this.getProperty("cardStyle",null);

            var width = this.getProperty("imageWidth","50");
            var margin = this.getProperty("imageMargin","0");
            var groupFields = [];
            var seen=[];
            for(var i=0;i<this.groupByMenus;i++) {
                var id =  this.jq(ID_GROUPBY_FIELDS+i).val();
                if(!seen[id]) {
                    seen[id] = true;
                    var field= this.getFieldById(fields, id);
                    if(field) {
                        groupFields.push(field);
                        if(field.isNumeric() && !field.range) {
                            var min = Number.MAX_VALUE;
                            var max = Number.MIN_VALUE;
                            records.map(record=>{
                                var v =field.getValue(record);
                                if(isNaN(v)) return;
                                if(v<min) min  = v;
                                if(v > max) max =v;
                            });
                            field.range = [min,max];
                            var binsProp = this.getProperty(field.getId() +".bins");
                            field.bins = [];
                            if(binsProp) {
                                var l  = binsProp.split(",");
                                for(var i=0;i<l.length-1;i++) {
                                    field.bins.push([+l[i],+l[i+1]]);
                                }
                            } else {
                                var numBins = +this.getProperty(field.getId() +".binCount",10); 
                                field.binSize = (max-min)/numBins;
                                for(var bin=0;bin<numBins;bin++) {
				    field.bins.push([min+field.binSize*bin,min+field.binSize*(bin+1)]);
				}
                            }
                        }
                    }
                }
            }

            function groupNode(id,field) {
                $.extend(this,{
                    id: id,
		    field:field,
		    members:[],
                    isGroup:true,
                    getCount: function() {
                        if(this.members.length==0) return 0;
                        if(this.members[0].isGroup) {
                            var cnt = 0;
                            this.members.map(node=>cnt+= node.getCount());
                            return cnt;
                        }
                        return this.members.length;
                    },
                    findGroup: function(v) {
                        for(var i=0;i<this.members.length;i++) {
                            if(this.members[i].isGroup && this.members[i].id == v) return this.members[i];
                        }
                        return null;
                    },
                });
            }
            var topGroup = new groupNode("");
            var colorMap ={};
            var colorCnt = 0;
	    var imgCnt = 0;
            for (var rowIdx = 0; rowIdx <records.length; rowIdx++) {
		let record = records[rowIdx];
                var row = this.getDataValues(records[rowIdx]);
                var contents = "";
                var tooltip = "";
                this.tooltipFields.map(field=>{
                    if(tooltip!="") tooltip+="&#10;";
                    tooltip+=field.getValue(record);
                });
		tooltip =tooltip.replace(/\"/g,"&quot;");
                var label = "";
                var caption="";
                if(this.captionFields.length>0) {
                    if(this.captionTemplate) caption  = this.captionTemplate;
                    this.captionFields.map(field=>{
			var value = (""+field.getValue(record)).replace(/\"/g,"&quot;");
                        if(this.captionTemplate)
                            caption = caption.replace("\${" + field.getId()+"}",value);
                        else
                            caption+=value+"<br>";
                    });
                    if(this.urlField) {
                        var url = this.urlField.getValue(record);
                        if(url && url!="") {
                            caption = "<a style='color:inherit;'  href='" +url+"' target=_other>" +caption+"</a>";
                        }
                    }
                }
		this.labelFields.map(f=>{
		    label += row[f.getIndex()]+" ";
		});
		label = label.trim();
                var html ="";
                var img = null;
                if(this.imageField) {
                    img = row[this.imageField.getIndex()];
		    
                    if(this.onlyShowImages && !Utils.stringDefined(img)) continue;
                } 
                
                var  imgAttrs= [CLASS,"display-cards-popup","data-fancybox",this.domId("gallery"),"data-caption",caption];
		if(img) img = img.trim();
                if(Utils.stringDefined(img)) {
		    if(this.colorAnalysisEnabled)
			img = ramaddaBaseUrl+"/proxy?url=" + img;
                    img =  HU.href(img, HU.div([ID,this.domId("gallery")+"div" + imgCnt], HU.image(img,["width",width,ID,this.domId("gallery")+"img" + imgCnt])),imgAttrs)+label;
		    imgCnt++;
                    html = HU.div([CLASS,"display-cards-item", TITLE, tooltip, STYLE,HU.css('margin', margin+'px')], img);
                } else {
                    var style = "";
                    if(fontSize) {
                        style+= " font-size:" + fontSize +"; ";
                    }
                    if(this.colorByField && this.colorList) {
                        var value = this.colorByField.getValue(record);
                        if(!Utils.isDefined(colorMap[value])) {
                            colorMap[value] = colorCnt++;
                        }
                        var index = colorMap[value];
                        if(index>=this.colorList.length) {
                            index = this.colorList.length%index;
                        }
                        style+="background:" + this.colorList[index]+";";
                        if(this.foregroundList) {
                            if(index<this.foregroundList.length) {
                                style+="color:" + this.foregroundList[index]+" !important;";
                            } else {
                                style+="color:" + this.foregroundList[this.foregroundList-1]+" !important;";
                            }
                        }
                    }
                    if(cardStyle)
                        style +=cardStyle;
                    var attrs = [TITLE,tooltip,CLASS,"ramadda-gridbox display-cards-card",STYLE,style];
                    if(this.altLabelField) {
                        html = HU.div(attrs,this.altLabelField.getValue(record));
                    } else {
                        html = HU.div(attrs,caption);
                    }
                    html =  HU.href("", html,imgAttrs);
                }
                var group = topGroup;
                for(var groupIdx=0;groupIdx<groupFields.length;groupIdx++) {
                    var groupField  = groupFields[groupIdx];
                    var value = row[groupField.getIndex()];
                    if(groupField.isNumeric()) {
                        for(var binIdx=0;binIdx<groupField.bins.length;binIdx++) {
                            var bin= groupField.bins[binIdx];
                            if(value<=bin[1] || binIdx == groupField.bins.length-1) {
                                value = Utils.formatNumber(bin[0]) +" - " + Utils.formatNumber(bin[1]);
                                break;
                            }
                        }
                    }
                    var child = group.findGroup(value);
                    if(!child) {
                        group.members.push(child = new groupNode(value,groupField));
                    }
                    group = child;
                }
                group.members.push(html);
            }
	    let total = topGroup.getCount();
            let topHtml = HU.div([CLASS,"display-cards-header"],"Total" +" (" + total+")");
            topHtml+=this.makeGroupHtml(topGroup, topGroup);
            this.writeHtml(ID_RESULTS, topHtml);
            this.jq(ID_RESULTS).find("a.display-cards-popup").fancybox({
                caption : function( instance, item ) {
                    return  $(this).data('caption') || '';
                }});
        },
        makeGroupHtml: function(group, topGroup) {
            if(group.members.length==0) return "";
            var html="";
            if(group.members[0].isGroup) {
                group.members.sort((a,b)=>{
                    if(a.id<b.id) return -1;
                    if(a.id>b.id) return 1;
                    return 0;
                });
                var width = group.members.length==0?"100%":100/group.members.length;
                html +=HU.open(TABLE,[WIDTH,'100%','border',0]) +HU.open(TR,['valign','top']);
                for(var i=0;i<group.members.length;i++) {
                    var child = group.members[i];
		    var prefix="";
		    if(child.field)
			prefix = child.field.getLabel()+": ";
                    html+=HU.open(TD,[WIDTH, width+"%"]);
		    let perc = Math.round(100*child.getCount()/topGroup.getCount());
		    html+=HU.div([CLASS,"display-cards-header"],prefix+child.id +" (#" + child.getCount()+" - " + perc +"%)");
		    html+= this.makeGroupHtml(child, topGroup);
                    html+=HU.close(TD);
                }
                html +=HU.close(TR, TABLE);
            } else {
                html+=Utils.join(group.members,"");
            }
            return html;
        }
    });
}




function RamaddaImagesDisplay(displayManager, id, properties) {
    const ID_GALLERY = "gallery";
    const ID_NEXT = "next";
    const ID_PREV = "prev";
    const ID_IMAGES = "images";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_IMAGES, properties);
    let myProps = [
	{label:'Image Gallery Properties'},
	{p:'imageField',ex:''},
	{p:'labelFields',ex:''},
	{p:'topLabelTemplate',ex:''},	
	{p:'bottomLabelTemplate',ex:''},	
	{p:'tooltipFields',ex:''},
	{p:'numberOfImages',ex:'100'},	
	{p:'includeBlanks',ex:'true'},
	{p:'imageWidth',ex:'150'},
	{p:'imageHeight',ex:'150'},	
	{p:'imageMargin',ex:'10px'},
	{p:'decorate',ex:'false'},
	{p:'doPopup',ex:'false'},
	{p:'imageStyle',ex:''},			
	{p:'minHeightGallery',ex:150},
	{p:'maxHeightGallery',ex:150},	
	{p:'columns',ex:'5'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	startIndex:0,
	dataFilterChanged: function() {
	    this.startIndex=0;
	    this.updateUI();
	},
        handleEventRecordSelection: function(source, args) {
	    let blocks = this.find(".display-images-block");
	    let select = HU.attrSelect(RECORD_ID, args.record.getId());
	    let block = this.find(select);
	    blocks.css('background','transparent');
	    block.css('background',HIGHLIGHT_COLOR);
	    HU.scrollVisible(this.jq(ID_IMAGES),block);
	},
        updateUI: function() {
            let records = this.filterData();
            if(!records) return;
	    let includeBlanks  = this.getPropertyIncludeBlanks(false);
	    let imageField = this.getFieldById(null, this.getProperty("imageField"));
	    if(!imageField) {
		imageField = this.getFieldByType(null,"image");
	    }

            let pointData = this.getData();
            let fields = pointData.getRecordFields();

            let labelFields = this.getFieldsByIds(null, this.getProperty("labelFields", null, true));
            let topLabelTemplate = this.getPropertyTopLabelTemplate();
            let bottomLabelTemplate = this.getPropertyBottomLabelTemplate();	    
            let tooltipFields = this.getFieldsByIds(null, this.getProperty("tooltipFields", null, true));
	    if(!imageField) {
		this.setDisplayMessage("No image field in data");
		return;
	    }
	    let decorate = this.getPropertyDecorate(true);
	    let columns = +this.getPropertyColumns(0);
	    let number = +this.getPropertyNumberOfImages(50);
	    let colorBy = this.getColorByInfo(records);
	    let width = this.getPropertyImageWidth();
	    let height = this.getPropertyImageHeight();	    
	    if(!width && !height) width="150";
	    let imageStyle = this.getPropertyImageStyle("");
	    let contents = "";
	    let uid = HtmlUtils.getUniqueId();
	    let base = "gallery"+uid;
	    let displayedRecords = [];
	    let doPopup = this.getPropertyDoPopup(true);
	    let recordIndex = 0;
	    let columnCnt = -1;
	    let columnMap = {};
	    let class1= "display-images-image-outer display-images-block ";
	    let class2 = "display-images-image-inner";
	    let style = "";
	    let idToRecord = {};
	    if(!decorate) {
		class2 = "";
		class1 = "display-images-block";
		style = HU.css("margin",this.getPropertyImageMargin("10px"));
	    }
	    if(columns) {
		if(width && width.endsWith("%"))
		    style+=HU.css(WIDTH,width);
	    }
	    if(this.startIndex<0) this.startIndex=0;
	    if(this.startIndex>records.length) this.startIndex=records.length-number;
	    let cnt = 1;
            for (let rowIdx = this.startIndex; rowIdx < records.length; rowIdx++) {
		let record = records[rowIdx];
                let row = this.getDataValues(record);
		let image = record.getValue(imageField.getIndex());
		if(image=="" && !includeBlanks) {
		    continue;
		}
		if(cnt++>number) break;
		displayedRecords.push(record);
		idToRecord[record.getId()] = record;
		let topLabel = null;
		if(topLabelTemplate) {
		    topLabel = this.getRecordHtml(record,fields,topLabelTemplate);
		}
		let label = "";
		let galleryLabel = "";
		if(bottomLabelTemplate) {
		    label = this.getRecordHtml(record,fields,bottomLabelTemplate);
		} 
		labelFields.forEach(l=>{
		    let value  = record.getValue(l.getIndex());
		    if(value.getTime) {
			value = this.formatDate(value);
		    } 
		    galleryLabel += " " + value; 
		});
		if(galleryLabel=="") galleryLabel=label;
		else if(label=="") label = galleryLabel;		
		let tt = "";
		tooltipFields.forEach(l=>{tt += "\n" + l.getLabel()+": " + row[l.getIndex()]});
		tt = tt.trim();
		let imgAttrs = [STYLE,imageStyle,"alt",galleryLabel,ID,base+"image" + rowIdx,"loading","lazy"];
		if(width) imgAttrs.push(WIDTH,width);
		else if(height) imgAttrs.push(HEIGHT,height);		
		let img = image==""?SPACE1:HU.image(image,imgAttrs);
		let topLbl = (topLabel!=null?HU.div([CLASS,"display-images-toplabel"], topLabel):"");
		let lbl = HU.div([CLASS,"display-images-label"], label.trim());
		if(colorBy.isEnabled()) {
		    let c = colorBy.getColorFromRecord(record);
		    style+=HU.css(BACKGROUND,c);
		}

		style+=HU.css("vertical-align","top");
		let block = 
		    HU.div([STYLE, style, RECORD_ID,record.getId(),RECORD_INDEX,recordIndex++,ID,base+"div"+  rowIdx, CLASS, class1,TITLE,tt],
			   HU.div([CLASS,class2], topLbl + img + lbl));
		if(doPopup) {
		    block = HU.href(image,block,[CLASS,"popup_image","data-fancybox",base,"data-caption",galleryLabel]);
		}
		if(columns) {
		    if(++columnCnt>=columns) {
			columnCnt=0;
		    }
		    if(!columnMap[columnCnt]) columnMap[columnCnt] = "";
		    columnMap[columnCnt] += block;
		} else {
		    contents += block;
		}
	    }
	    if(columns) {
		contents = "<table border=0 width=100%><tr valign=top>";
		for(let col=0;true;col++) {
		    if(!columnMap[col]) break;
		    contents+=HU.td(['align','center'],columnMap[col]);
		}
		contents+="</tr></table>";
	    } else {
	    }

	    let header = "";
	    if(this.startIndex>0) {
		header += HU.span([ID,this.domId(ID_PREV)],"Previous")+" ";
	    }
	    if(this.startIndex+number<records.length) {
		header += HU.span([ID,this.domId(ID_NEXT)],"Next") +" ";
	    }
	    cnt--;
	    if(number<records.length) {
		header += "Showing " + (this.startIndex+1) +" - " +(this.startIndex+cnt);
		header += " of " + records.length +" images";
	    }

	    if(header!="") header  = header +"<br>";

	    if(this.getPropertyMinHeightGallery() || this.getPropertyMaxHeightGallery()) {
		let css = "";
		if(this.getPropertyMinHeightGallery()) css+=HU.css("min-height",HU.getDimension(this.getPropertyMinHeightGallery()));
		if(this.getPropertyMinHeightGallery())	css+= HU.css("max-height",HU.getDimension(this.getPropertyMaxHeightGallery()));
		contents = HU.div([ID,this.domId(ID_IMAGES),STYLE,css+HU.css("overflow-y","auto")], contents);
	    }

            this.setContents(header + contents);
	    let blocks = this.find(".display-images-block");
	    this.makeTooltips(blocks,displayedRecords);
	    if(!doPopup) {
		let _this = this;
		blocks.click(function() {
		    let record = idToRecord[$(this).attr(RECORD_ID)];
		    if(record) {
			_this.propagateEventRecordSelection({record: record});
		    }
		});
	    }
	    this.jq(ID_PREV).button().click(()=>{
		this.startIndex-=number;
		this.updateUI();
	    });
	    this.jq(ID_NEXT).button().click(()=>{
		this.startIndex+=number;
		this.updateUI();
	    });

	    if(this.getProperty("propagateEventRecordList",false)) {
		this.getDisplayManager().notifyEvent("handleEventRecordList", this, {
		    recordList: displayedRecords,
		});
	    }
	}
    })
}



function RamaddaImagezoomDisplay(displayManager, id, properties) {
    const ID_THUMBS = "thumbs";
    const ID_THUMB = "thumb";    
    const ID_IMAGE = "image";
    const ID_IMAGEINNER = "imageinner";    
    const ID_POPUP = "imagepopup";
    const ID_POPUPIMAGE = "imagepopupimage";
    const ID_RECT = "imagerect";            
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_IMAGEZOOM, properties);
    let myProps = [
	{label:"Image Zoom Attributes"},
	{p:'labelFields'},
	{p:'thumbField'},
	{p:'thumbWidth',ex:'100'},
	{p:'imageWidth',ex:'150'},
	{p:'urlField'},
	{p:'popupWidth'},
	{p:'popupHeight'},	
	{p:"popupImageWidth",d:2000}
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	dataFilterChanged: function() {
	    this.updateUI();
	},
        updateUI: function() {
            let pointData = this.getData();
            if (pointData == null) return;
            let records = this.filterData();
            if(!records) return;
            let fields = pointData.getRecordFields();
            this.urlField = this.getFieldById(fields, this.getProperty("urlField", "url"));
	    this.imageField = this.getFieldById(fields,"image");
	    if(!this.imageField)
		this.imageField = this.getFieldByType(fields,"image");
	    if(!this.imageField) {
		this.setDisplayMessage("No image field in data");
		return;
	    }
	    this.labelFields = this.getFieldsByIds(fields, this.getPropertyLabelFields());
            let thumbField = this.getFieldById(fields, this.getProperty("thumbField", "thumb")) || this.imageField;
	    let thumbWidth = parseFloat(this.getProperty("thumbWidth",100));
	    let height=this.getHeightForStyle();
	    let imageWidth = this.getProperty("imageWidth",500);
	    this.popupWidth =  +this.getProperty("popupWidth",imageWidth);
	    this.popupHeight = +this.getProperty("popupHeight",300);

	    let rect = HU.div([STYLE,HU.css("border","1px solid " + HIGHLIGHT_COLOR,"width","20px","height","20px","left","10px","top","10px","display","none","position","absolute","z-index",1000,"pointer-events","none"),ID, this.domId(ID_RECT)]);
	    let imageDiv = HU.div(["style","position:relative"],
				  rect+
				  HU.div([ID,this.domId(ID_IMAGE),STYLE,HU.css("position","relative") ]) +
				  HU.div([ID,this.domId(ID_POPUP),CLASS,"display-imagezoom-popup",STYLE,HU.css("z-index","100","display","none",WIDTH,this.popupWidth+"px",HEIGHT,this.popupHeight+"px","overflow-y","hidden","overflow-x","hidden", "position","absolute","top","0px","left", imageWidth+"px")],""));

	    let contents = HU.table(["border",0,WIDTH,"100%"],
				    HU.tr(["valign","top"],
					  HU.td([WIDTH,"2%"],
						HU.div([ID,this.domId(ID_THUMBS), STYLE,HU.css("max-height",height,"overflow-y","auto","display","inline-block")],"")) +
					  HU.td([WIDTH,"90%"],
						imageDiv)));
	    let thumbsHtml = "";
	    let first = null;
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
		let image = row[this.imageField.getIndex()];
		if(image=="") {
		    continue;
		}
		if(!first) first=records[rowIdx];
		let thumb = row[thumbField.getIndex()];		
		thumbsHtml += HU.image(thumb,[RECORD_INDEX,rowIdx,ID,this.domId(ID_THUMB)+rowIdx,WIDTH, thumbWidth,CLASS,"display-imagezoom-thumb"])+"<br>\n";
	    }
            this.setContents(contents);
	    this.jq(ID_THUMBS).html(thumbsHtml);
	    let _this = this;
	    let thumbs = this.jq(ID_THUMBS).find(".display-imagezoom-thumb");
	    let thumbSelect = (thumb=>{
		thumbs.css("border","1px solid transparent");
		thumb.css("border","1px solid " + HIGHLIGHT_COLOR);
		let index = parseFloat(thumb.attr(RECORD_INDEX));
		HU.addToDocumentUrl("imagezoom_thumb",index);
		let record = records[index]
		_this.handleImage(record);
		_this.propagateEventRecordSelection({record: record});
	    });

	    thumbs.mouseover(function() {	
		thumbSelect($(this));
	    });
	    this.jq(ID_THUMBS).css("border","1px solid transparent");
	    let selectedIndex =  HU.getUrlArgument("imagezoom_thumb");
	    let x = HU.getUrlArgument("imagezoom_x");
	    let y = HU.getUrlArgument("imagezoom_y");	    
	    let selectedThumb = this.jq(ID_THUMB+(selectedIndex||"0"));
	    if(selectedThumb.length)
		thumbSelect(selectedThumb);
	    if(selectedIndex) this.showPopup();
	    if(Utils.isDefined(x)) {
		setTimeout(()=>{
		    this.handleMouseMove({x:parseFloat(x),y:parseFloat(y)});
		},250);
	    }

	    this.jq(ID_IMAGE).click((e)=>{
		let width = +this.getPopupImageWidth();
                if (event.shiftKey) {
		    this.setProperty("popupImageWidth",Math.max(width*0.9,500));
		} else {
		    this.setProperty("popupImageWidth",width*1.2);
		}
		this.showPopup();
		this.handleMouseMove();
	    });
	},
	showPopup: function() {
	    if(!this.currentRecord) return;
	    let row = this.getDataValues(this.currentRecord);
	    let image = row[this.imageField.getIndex()];
	    this.jq(ID_POPUP).css("display","block");
	    let imageAttrs = [ID,this.domId(ID_POPUPIMAGE),STYLE,HU.css("xposition","absolute")];
	    if(this.getPopupImageWidth()) {
		imageAttrs.push(WIDTH);
		imageAttrs.push(this.getPopupImageWidth());
	    } 
	    this.jq(ID_POPUP).html(HU.image(image,imageAttrs));
	},
	handleImage: function(record, offset) {
	    let _this = this;
	    this.currentRecord = record;
            let row = this.getDataValues(record);
	    let image = row[this.imageField.getIndex()];
	    let width = this.getProperty("imageWidth",500);
    	    let label = "";
	    if(this.labelFields.length>0) {
		this.labelFields.map(l=>{label += " " + row[l.getIndex()]});
		if(this.urlField) {
                    var url = this.urlField.getValue(record);
                    if(url && url!="") {
                        label = "<a style='color:inherit;'  href='" +url+"' target=_other>" +label+ "</a>";

                    }
		}
	    }
	    let html =  HU.image(image,["x","+:zoom in/-:zoom out",STYLE,HU.css("z-index",1000),WIDTH, width,ID,this.domId(ID_IMAGEINNER)]);
	    if(label!="")
		html+=HU.div([STYLE,"color:#000"],label);
	    this.jq(ID_IMAGE).html(html);

	    this.jq(ID_POPUP).html("");
	    this.jq(ID_POPUP).css("display","none");
	    this.jq(ID_IMAGEINNER).mouseenter(()=>{
		this.showPopup();
	    });
	    this.jq(ID_IMAGEINNER).mouseout(()=>{
		this.jq(ID_POPUP).html("");
		this.jq(ID_POPUP).css("display","none");
		this.jq(ID_RECT).css("display","none");		
	    });

	    this.jq(ID_IMAGEINNER).mousemove((e)=>{
		this.handleMouseMove({
		    event:e});
	    });
	    if(offset)
		this.jq(ID_POPUPIMAGE).offset(offset);
	},
	handleMouseMove(params) {
	    if(!params) params = {event:this.currentMouseEvent};
	    this.currentMouseEvent=params.event;
	    let image = this.jq(ID_IMAGEINNER);
	    let w = image.width();
	    let h = image.height();
	    let popupImage = this.jq(ID_POPUPIMAGE);
	    let iw = popupImage.width();
	    let ih = popupImage.height();		
	    if(h==0 || ih==0) return false;
	    let popupWidth = popupImage.parent().width();
	    let popupHeight = popupImage.parent().height(); 	    	    
	    let scaleX = w/iw;
	    let scaleY = h/ih;
	    let scaledWidth = scaleX*popupWidth;
	    let scaledHeight = scaleY*popupHeight;
	    let sw2 = scaledWidth/2;
	    let sh2 = scaledHeight/2;	    
	    let parentOffset = image.parent().offset();
	    if(!Utils.isDefined(params.x)) 
		params.x = params.event.pageX - parentOffset.left;
	    if(!Utils.isDefined(params.y)) 
		params.y = params.event.pageY - parentOffset.top;
	    if(params.x<sw2) params.x=sw2;
	    if(params.y<sh2) params.y=sh2;
	    if(params.x>w-sw2) params.x=w-sw2;
	    if(params.y>h-sh2) params.y=h-sh2;	    	    
	    

	    //This causes problems
//	    HU.addToDocumentUrl("imagezoom_x",params.x);
//	    HU.addToDocumentUrl("imagezoom_y",params.y);	    

	    let offX = scaleX*iw/2;
	    let offY = scaleY*ih/2;		
	    let percentW = (params.x-sw2)/w;
	    let percentH = (params.y-sh2)/h;

	    if(popupImage.parent().length==0) return;
	    let pp = popupImage.parent().offset();
	    let offset = {
		left:pp.left-percentW*iw,
		top:pp.top-percentH*ih};
	    this.jq(ID_POPUPIMAGE).offset(offset);		    
	    let rect = this.jq(ID_RECT);
	    rect.css({"display":"block",top:params.y-sh2+"px",left:params.x-sw2+"px",width:scaledWidth+"px",height:scaledHeight+"px"});
	    return true;
	},

    })
}






function RamaddaSlidesDisplay(displayManager, id, properties) {
    const ID_SLIDE = "slide";
    const ID_PREV = "prev";
    const ID_NEXT = "next";
    if(!Utils.isDefined(properties.displayStyle)) properties.displayStyle = "background:rgba(0,0,0,0);";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_SLIDES, properties);
    let myProps = [
	{label:'Slides Attributes'},
	{p:'template',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	slideIndex:0,

        handleEventRecordSelection: function(source, args) {
	    //	    console.log(this.type+ ".recordSelection");
	    if(!this.records) return;
	    var index =-1;
	    for(var i=0;i<this.records.length;i++) {
		if(this.records[i].getId() == args.record.getId()) {
		    index = i;
		    break;
		}
	    }
	    if(index>=0) {
		this.slideIndex=index;
		this.displaySlide();
	    }
	    
	},
        getContentsStyle: function() {
            var style = "";
            var height = this.getHeightForStyle();
            if (height) {
		style += " height:" + height + ";";
            }
            var width = this.getWidthForStyle();
            if (width) {
                style += " width:" + width + ";";
            }
            return style;
        },

	updateUI: function() {
	    var pointData = this.getData();
	    if (pointData == null) return;
	    this.records = this.filterData();
	    if(!this.records) return;
            this.fields = this.getData().getRecordFields();
	    this.records= this.sortRecords(this.records);
	    var template = this.getProperty("template","");
	    var slideWidth = this.getProperty("slideWidth","100%");
            var height = this.getHeightForStyle("400");
	    var left = HU.div([ID, this.domId(ID_PREV), STYLE,HU.css('font-size','200%'),CLASS,"display-slides-arrow-left fas fa-angle-left"]);
	    var right = HU.div([ID, this.domId(ID_NEXT), STYLE,HU.css('font-size','200%'), CLASS,"display-slides-arrow-right fas fa-angle-right"]);
	    var slide = HU.div([STYLE,HU.css('overflow-y','auto','max-height', height), ID, this.domId(ID_SLIDE), CLASS,"display-slides-slide"]);

	    var navStyle = "padding-top:20px;";
	    var contents = HU.div([STYLE,HU.css('position','relative')], "<table width=100%><tr valign=top><td width=20>" + HU.div([STYLE,navStyle], left) + "</td><td>" +
					 slide + "</td>" +
					 "<td width=20>" + HU.div([STYLE,navStyle],right) + "</td></tr></table>");
	    this.setContents(contents);
	    this.jq(ID_PREV).click(() =>{
		this.slideIndex--;
		this.displaySlide(true);
	    });
	    this.jq(ID_NEXT).click(() =>{
		this.slideIndex++;
		this.displaySlide(true);
	    });
	    setTimeout(()=>{
		this.displaySlide();},200);

	},
	displaySlide: function(propagateEvent) {
	    if(this.slideIndex<0) this.slideIndex=0;
	    if(this.slideIndex>=this.records.length) this.slideIndex=this.records.length-1;
	    if(this.slideIndex==0)
		this.jq(ID_PREV).hide();
	    else
		this.jq(ID_PREV).show();
	    if(this.slideIndex==this.records.length-1)
		this.jq(ID_NEXT).hide();
	    else
		this.jq(ID_NEXT).show();
	    var record = this.records[this.slideIndex];
	    var row = this.getDataValues(record);
	    var html = this.applyRecordTemplate(record, row,this.fields,this.getProperty("template",""));
	    html = html.replace(/\${recordIndex}/g,(this.slideIndex+1));
	    this.jq(ID_SLIDE).html(html);
	    var args = {highlight:true,record: record};
	    if(propagateEvent)
		this.getDisplayManager().notifyEvent("handleEventRecordHighlight", this, args);
	},
        handleEventRecordHighlight: function(source, args) {
	}
    })}



/**
   Copyright 2008-2019 Geode Systems LLC
*/


const DISPLAY_FILTER = "filter";
const DISPLAY_ANIMATION = "animation";
const DISPLAY_LABEL = "label";
const DISPLAY_DOWNLOAD = "download";
const DISPLAY_LEGEND = "legend";
const DISPLAY_RELOADER = "reloader";
const DISPLAY_MESSAGE = "message";
const DISPLAY_FIELDSLIST = "fieldslist";
const DISPLAY_TICKS = "ticks";

addGlobalDisplayType({
    type: DISPLAY_DOWNLOAD,
    label: "Download",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Show a download link",null,"Allows user to select fields and<br>download CSV and JSON")                                        
});
addGlobalDisplayType({
    type: DISPLAY_RELOADER,
    label: "Reloader",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Reload the displays",null,"Automatically reloads the displays on a set frequency")                                            
});
addGlobalDisplayType({
    type: DISPLAY_FILTER,
    label: "Filter",
    requiresData: false,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just provides data filtering")
});
addGlobalDisplayType({
    type: DISPLAY_ANIMATION,
    label: "Animation",
    requiresData: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Steps through time to drive other displays","animation.png","")                                                        
});
addGlobalDisplayType({
    type: DISPLAY_MESSAGE,
    label: "Message",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a formatted message",null,"")                                                    
});
addGlobalDisplayType({
    type: DISPLAY_FIELDSLIST,
    label: "Fields List",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
//    tooltip: makeDisplayTooltip("No data, just a formatted message",null,"")                                                    
});

addGlobalDisplayType({
    type: DISPLAY_LABEL,
    label: "Label",
    requiresData: false,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a text label",null,"Useful to add text to the display layout")                                                
});
addGlobalDisplayType({
    type: DISPLAY_LEGEND,
    label: "Legend",
    requiresData: false,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("No data, just a configurable legend","legend.png")
});
addGlobalDisplayType({
    type: DISPLAY_TICKS,
    label: "Ticks",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows records as ticks in a timeline","ticks.png")
});

function RamaddaFilterDisplay(displayManager, id, properties) {
    let SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_FILTER, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        html: "<p>&nbsp;&nbsp;&nbsp;Nothing selected&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p>",
        initDisplay: function() {
            this.createUI();
            this.setContents(this.html);
        },
    });
}


function RamaddaAnimationDisplay(displayManager, id, properties) {
    var ID_START = "start";
    var ID_STOP = "stop";
    var ID_TIME = "time";
    let SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_ANIMATION, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        running: false,
        timestamp: 0,
        index: 0,
        sleepTime: 500,
        iconStart: "fa-play",
        iconStop: "fa-stop",
        iconBack: "fa-step-backward",
        iconForward: "fa-step-forward",
        iconSlower: "fa-minus",
	iconFaster: "fa-plus",
	iconBegin: "fa-fast-backward",
	iconEnd: "fa-fast-forward",
        needsData: function() {
            return true;
        },
        deltaIndex: function(i) {
            this.stop();
            this.setIndex(this.index + i);
        },
        setIndex: function(i) {
            if (i < 0) i = 0;
            this.index = i;
            this.applyStep(true, !Utils.isDefined(i));
        },
        toggle: function() {
            if (this.running) {
                this.stop();
            } else {
                this.start();
            }
        },
        tick: function() {
            if (!this.running) return;
            this.index++;
            this.applyStep();
            var theAnimation = this;
            setTimeout(function() {
                theAnimation.tick();
            }, this.sleepTime);
        },
        applyStep: function(propagate, goToEnd) {
            if (!Utils.isDefined(propagate)) propagate = true;
	    let records = this.currentRecords;
            if (records == null) {
                $("#" + this.getDomId(ID_TIME)).html("No data");
                return;
            }
            if (goToEnd) this.index = records.length - 1;
            if (this.index >= records.length) {
                this.index = 0;
            }
            var record = records[this.index];
            var label = "";
            if (record.getDate() != null) {
                var dttm = this.formatDate(record.getDate(), {
                    suffix: this.getTimeZone()
                });
                label += HU.b("Date:") + " " + dttm;
            } else {
                label += HU.b("Index:") + " " + this.index;
            }
            $("#" + this.getDomId(ID_TIME)).html(label);
            if (propagate) {
		this.propagateEventRecordSelection({record: record});
            }
        },
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let records = this.currentRecords;
	    if(!records) {
		if(args.record) records = [args.record];
	    }
	    records.every((r,idx)=>{
		if(r.getId() == args.record.getId()) {
		    this.index = idx;
		    this.applyStep(false);
		    return false;
		}
		return true;
	    });
        },
        faster: function() {
            this.sleepTime = this.sleepTime / 2;
            if (this.sleepTime == 0) this.sleepTime = 100;
        },
        slower: function() {
            this.sleepTime = this.sleepTime * 1.5;
        },
        start: function() {
            if (this.running) return;
            this.running = true;
            this.timestamp++;
            $("#" + this.getDomId(ID_START)).html(HU.getIconImage(this.iconStop));
            this.tick();
        },
        stop: function() {
            if (!this.running) return;
            this.running = false;
            this.timestamp++;
            $("#" + this.getDomId(ID_START)).html(HU.getIconImage(this.iconStart));
        },
        updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    this.currentRecords = records;
	    //            this.createUI();
            this.stop();

            var get = this.getGet();
            var html = "";
	    let c = "display-animation-button";
            html += HU.onClick(get + ".setIndex(0);", HU.div([ATTR_TITLE, "beginning", ATTR_CLASS, c],HU.getIconImage(this.iconBegin)));
            html += HU.onClick(get + ".deltaIndex(-1);", HU.div([ATTR_TITLE, "step back", ATTR_CLASS, c],HU.getIconImage(this.iconBack)));
            html += HU.onClick(get + ".toggle();", HU.div([ATTR_ID, this.getDomId(ID_START),ATTR_TITLE, "play/stop",ATTR_CLASS, c], HU.getIconImage(this.iconStart)));
            html += HU.onClick(get + ".deltaIndex(1);", HU.div([ATTR_TITLE, "step forward", ATTR_CLASS, c],HU.getIconImage(this.iconForward)));
            html += HU.onClick(get + ".setIndex();", HU.div([ATTR_TITLE, "end", ATTR_CLASS, c],HU.getIconImage(this.iconEnd)));
            html += HU.onClick(get + ".faster();", HU.div([ATTR_TITLE, "faster", ATTR_CLASS, c],HU.getIconImage(this.iconFaster)));
            html += HU.onClick(get + ".slower();", HU.div([ATTR_TITLE, "slower", ATTR_CLASS, c],HU.getIconImage(this.iconSlower)));
            html += HU.div(["style", "display:inline-block; min-height:24px; margin-left:10px;", ATTR_ID, this.getDomId(ID_TIME)], "&nbsp;");
            this.setDisplayTitle("Animation");
            this.setContents(html);
        },
    });
}



function RamaddaMessageDisplay(displayManager, id, properties) {
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_MESSAGE, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return false;
        },
	updateUI: function() {
	    if(this.getProperty("decorate",true)) {
		this.setContents(this.getMessage(this.getProperty("message",this.getNoDataMessage())));
	    } else {
		this.setContents(this.getProperty("message",this.getNoDataMessage()));
	    }
	}});
}

function RamaddaFieldslistDisplay(displayManager, id, properties) {
    const ID_POPUP = "popup";
    const ID_POPUP_BUTTON = "popupbutton";    
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_FIELDSLIST, properties);
    let myProps =[
	{label:"Metadata"},
	{p:"decorate",ex:true},
	{p:"selectable",ex:true},
	{p:"showFieldDetails",ex:true},
	{p:"showPopup",d:true,ex:true,tt:"Popup the selector"},	
    ];
    
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(records == null) return;
	    let html = "";
	    let fields = this.fields = this.getData().getRecordFields();
	    this.fieldsMap={};
	    this.fields.forEach(f=>{
		this.fieldsMap[f.getId()] = f;
	    });
	    html += HU.center("#" + records.length +" records");
	    let fs = [];
	    let clazz = " display-fields-field ";
	    if(this.getDecorate(true)) clazz+= " display-fields-field-decorated ";
	    let selectable = this.getSelectable(true);
	    let details = this.getShowFieldDetails(false);	    
	    fields.forEach((f,idx)=>{
		let block  =HU.b(f.getLabel());
		if(details) {
		    block+= "<br>" +
			f.getId() + f.getUnitSuffix()+"<br>" +
			f.getType();
		}
		let c = clazz;
		let selected = true;
		if(selectable) c += " display-fields-field-selectable ";
		if(selectable && selected) c += " display-fields-field-selected ";
		let title = "";
		if(selectable)
		    title = "Click to toggle. Shift-click toggle all";
		block =HU.div([TITLE,title,"field-selected",selected, "field-id", f.getId(),'class',c], block);
		fs.push(block);
	    });
	    let fhtml = Utils.wrap(fs,"","");
	    html += fhtml;

	    if(this.getShowPopup()) {
		html = HU.div([ID,this.domId(ID_POPUP_BUTTON)],"Select fields") +
		    HU.div([ID,this.domId(ID_POPUP),STYLE,"display:none;width:600px;"], html);
	    }
	    this.setContents(html);
	    if(this.getShowPopup()) {
		this.jq(ID_POPUP_BUTTON).button().click(()=>{
		    HU.makeDialog({contentId:this.domId(ID_POPUP),inPlace:true,anchor:this.domId(ID_POPUP_BUTTON),draggable:true,header:true,sticky:true});
		});
	    }
	    if(selectable) {
		let _this = this;
		let fieldBoxes = this.find(".display-fields-field");
		fieldBoxes.click(function(event) {
		    let shift = event.shiftKey ;
		    let selected  = $(this).attr("field-selected")=="true";
		    selected = !selected;
		    $(this).attr("field-selected",selected);
		    if(selected) {
			$(this).addClass("display-fields-field-selected");
		    } else {
			$(this).removeClass("display-fields-field-selected");
		    }

		    if(shift) {
			fieldBoxes.attr("field-selected",selected);
			if(selected) {
			    fieldBoxes.addClass("display-fields-field-selected");
			} else {
			    fieldBoxes.removeClass("display-fields-field-selected");
			}

		    }
		    let selectedFields = [];
		    fieldBoxes.each(function(){
			let selected  = $(this).attr("field-selected")=="true";
			if(selected) {
			    let id = $(this).attr("field-id");
			    let field = _this.fieldsMap[id];
			    if(field) selectedFields.push(field);
			}
		    });
                    _this.propagateEvent("handleEventFieldsSelected", selectedFields);
		});
	    }
	}});
}


function RamaddaLabelDisplay(displayManager, id, properties) {
    var ID_TEXT = "text";
    var ID_EDIT = "edit";

    if (properties && !Utils.isDefined(properties.showTitle)) {
        properties.showTitle = false;
    }
    this.text = "";
    this.editMode = properties.editMode;
    if (properties.text) this.text = properties.text;
    else if (properties.label) this.text = properties.label;
    else if (properties.html) this.text = properties.html;
    if (properties["class"]) this["class"] = properties["class"];
    else this["class"] = "display-text";

    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_LABEL, properties);
    let myProps =[];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        initDisplay: function() {
            var theDisplay = this;
            this.createUI();
            var textClass = this["class"];
            if (this.editMode) {
                textClass += " display-text-edit ";
            }
            var style = "color:" + this.getTextColor("contentsColor") + ";";
            var html = HU.div([ATTR_CLASS, textClass, ATTR_ID, this.getDomId(ID_TEXT), "style", style], this.text);
            if (this.editMode) {
                html += HU.textarea(ID_EDIT, this.text, ["rows", 5, "cols", 120, ATTR_SIZE, "120", ATTR_CLASS, "display-text-input", ATTR_ID, this.getDomId(ID_EDIT)]);
            }
            this.setContents(html);
            if (this.editMode) {
                var editObj = this.jq(ID_EDIT);
                editObj.blur(function() {
                    theDisplay.text = editObj.val();
                    editObj.hide();
                    theDisplay.initDisplay();
                });
                this.jq(ID_TEXT).click(function() {
                    var src = theDisplay.jq(ID_TEXT);
                    var edit = theDisplay.jq(ID_EDIT);
                    edit.show();
                    edit.css('z-index', '9999');
                    edit.position({
                        of: src,
                        my: "left top",
                        at: "left top",
                        collision: "none none"
                    });
                    theDisplay.jq(ID_TEXT).html("");
                });
            }


        },
        getWikiAttributes: function(attrs) {
            SUPER.getWikiAttributes(attrs);
            attrs.push("text");
            attrs.push(this.text);
        },
    });
}



function RamaddaLegendDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width='100%';
    let SUPER =  new RamaddaDisplay(displayManager, id, DISPLAY_LEGEND, properties);
    RamaddaUtil.inherit(this,SUPER);
    let myProps = [
	{label:'Legend'},
	{p:'labels',ex:''},
	{p:'colors',ex:''},
	{p:'inBox',ex:'true'},
	{p:'labelColor',ex:'#fff'},
	{p:'labelColors',ex:'color1,color2,...'},
	{p:'orientation',ex:'vertical'}
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	needsData: function() {
            return false;
	},
	updateUI: function() {
	    let labels = this.getProperty("labels","").split(",");
	    let colors = this.getColorList();
	    let html = "";
	    let colorWidth = this.getProperty("colorWidth","20px");
	    let labelColor = this.getProperty("labelColor","#000");
	    let labelColors = this.getProperty("labelColors")?this.getProperty("labelColors").split(","):null;
	    let inBox = this.getProperty("inBox",false);
	    let orientation = this.getProperty("orientation","horizontal");
	    let delim = orientation=="horizontal"?" ":"<br>";
	    for(let i=0;i<labels.length;i++) {
		let label = labels[i];
		let color = colors[i]||"#fff";
		if(i>0) html+=delim;
		if(!inBox) {
		    html+=HU.div(["class","display-legend-item"], HU.div(["class","display-legend-color","style","background:" + color+";width:" + colorWidth+";"+
									  "height:15px;"]) +
				 HU.div(["class","display-legend-label"],label));
		} else {
		    let lc = labelColors?labelColors[i]:labelColor || labelColor;
		    html+=HU.div(["class","display-legend-color","style","margin-left:8px;background:" + color+";"],
				 HU.div(["class","display-legend-label","style","margin-left:8px;margin-right:8x;color:" + lc+";"],label));
		}
	    }
	    if(orientation!="vertical") {
		html = HU.center(html); 
	    }
	    this.setContents(html);
	},
    });
}



function RamaddaDownloadDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_DOWNLOAD, properties);
    const ID_DOWNLOAD_CSV = "downloadcsv";
    const ID_DOWNLOAD_JSON = "downloadjson";    
    const ID_CANCEL = "cancel";    
    let myProps =[
	{label:'Download'},
	{p:'csvLabel',ex:'Download'},
	{p:'useIcon',d:'false',ex:'false'},
	{p:'fileName',d:'download',ex:'download'},
	{p:'askFields',d:'false',ex:'true'},		
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	fieldOn:{},
	needsData: function() {
            return true;
	},
	updateUI: function() {
	    let label = this.getPropertyCsvLabel("Download Data");
	    label = label.replace("${title}",this.getProperty("title",""));
	    let useIcon = this.getPropertyUseIcon(true);
	    label = useIcon?HU.getIconImage("fa-download",[STYLE,"cursor:pointer;",TITLE,label]):label;
	    this.setContents(HU.div([],HU.span([ID,this.getDomId("csv")],label)));
	    if(useIcon) {
		this.jq("csv").click(() => {
		    this.doDownload();
		});
	    } else {
		this.jq("csv").button().click(() => {
		    this.doDownload();
		});
	    }
	},
	getCsv: function(fields, records) {
            fields = fields || this.getData().getRecordFields();
	    DataUtils.getCsv(fields, records,this.getPropertyFileName()+".csv");
	},
	getJson: function(fields, records) {
            fields = fields || this.getData().getRecordFields();
	    DataUtils.getJson(fields, records,this.getPropertyFileName()+".json");
	},

	applyFieldSelection: function() {
	    this.getData().getRecordFields().forEach(f=>{
		let cbx = this.jq("cbx_" + f.getId());
		let on = cbx.is(':checked');
		this.fieldOn[f.getId()] = on;
	    });
	},
	getDownloadDialog: function(records) {
            let selectedFields = this.getSelectedFields();
	    if(selectedFields) {
		this.fieldOn = {};
		this.getData().getRecordFields().forEach(f=>{
		    this.fieldOn[f.getId()] = false;
		});
		selectedFields.forEach(f=>{
		    this.fieldOn[f.getId()] = true;
		});
	    }
	    
	    let html = HU.center("#" +records.length +" records") +
		HU.center(HU.div([ID,this.getDomId(ID_DOWNLOAD_CSV)],"Download CSV") +"&nbsp;&nbsp;" +
			  HU.div([ID,this.getDomId(ID_DOWNLOAD_JSON)],"Download JSON") +"&nbsp;&nbsp;" +			     			     HU.div([ID,this.getDomId(ID_CANCEL)],"Cancel"));
	    html += "<b>Include:<br></b>";
	    let cbx = "";
	    this.getData().getRecordFields().forEach((f,idx)=>{
		let on = this.fieldOn[f.getId()];
		if(!Utils.isDefined(on)) {
		    on = true;
		}
		cbx += HU.checkbox(this.getDomId("cbx_" + f.getId()),[],on) +" " + f.getLabel() +"<br>";
	    });
	    
	    html = HU.div([STYLE,HU.css("margin","5px")],html);
	    html += HU.div([STYLE,HU.css("max-height","200px","overflow-y","auto","margin","5px")], cbx);
	    return html;
	},
	doDownload: function() {
	    let records = this.filterData();

	    let func = json=>{
		this.jq(ID_DIALOG).hide();
		let fields = [];
		this.applyFieldSelection();
		this.getData().getRecordFields().forEach(f=>{
		    if(this.fieldOn[f.getId()]) {
			fields.push(f);
		    }
		});
		if(json) 
		    this.getJson(fields, records);
		else
		    this.getCsv(fields, records);
		if(this.dialog) this.dialog.remove();
		this.dialog =null;	    };
	    if(this.getPropertyAskFields(true)) {
		let html = this.getDownloadDialog(records);
		let init = ()=>{
		    this.jq(ID_CANCEL).button().click(() =>{
			this.applyFieldSelection();
			this.jq(ID_DIALOG).hide();
			if(this.dialog) this.dialog.remove();
			this.dialog =null;
		    });
		    this.jq(ID_DOWNLOAD_CSV).button().click(() =>{
			func(false);
		    });
		    this.jq(ID_DOWNLOAD_JSON).button().click(() =>{
			func(true);
		    });		
		};
		this.showDialog(html,this.getDomId(ID_DISPLAY_CONTENTS),init,this.getTitle());
	    } else  {
		this.getCsv(null, records);
	    }
	},
    });
}

function RamaddaReloaderDisplay(displayManager, id, properties) {
    const ID_CHECKBOX= "cbx";
    const ID_COUNTDOWN= "countdown";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RELOADER, properties);
    let myProps = [
	{label:'Reloader'},
	{p:'interval',ex:'30',d:30,label:"Interval"},
	{p:'showCheckbox',ex:'false',d:true,label:"Show Checkbox"},
	{p:'showCountdown',ex:'false',d:true,label:"Show Countdown"},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        xxpointDataLoaded: function(pointData, url, reload) {
	},
	reloadData: function() {
	    let pointData = this.dataCollection.getList()[0];
	    pointData.loadData(this,true);
	},
	updateUI: function() {
	    let html = "";
	    //If we are already displaying then don't update the UI
	    if(this.jq(ID_COUNTDOWN).length>0) return;
	    if(this.getPropertyShowCheckbox()) {
		html += HU.checkbox(this.getDomId(ID_CHECKBOX),[],true);
	    }		
	    if(this.getPropertyShowCountdown()) {
		html+=" " + HU.span([CLASS,"display-reloader-label", ID,this.getDomId(ID_COUNTDOWN)],this.getCountdownLabel(this.getPropertyInterval()));
	    } else {
		if(this.getPropertyShowCheckbox()) {
		    html+=" " + HU.span([ID,this.getDomId(ID_COUNTDOWN)],"Reload");
		}
	    }
	    this.setContents(html);
	    this.jq(ID_CHECKBOX).change(()=>{
		let cbx = this.jq(ID_CHECKBOX);
		if(cbx.is(':checked')) {
		    this.setTimer(this.lastTime);
		}
	    });
	    this.jq(ID_COUNTDOWN).addClass("ramadda-clickable").css("cursor","pointer").attr("title","Reload").click(()=>{
		this.checkReload(-1);
	    });
	    this.setTimer(this.getPropertyInterval());
	},
	okToRun: function() {
	    let cbx = this.jq(ID_CHECKBOX);
	    if(cbx.length==0) return true;
	    return cbx.is(':checked');
	},
	getCountdownLabel: function(time) {
	    let pad = "";
	    if(time<10) pad = "&nbsp;";
	    if(time>60) {
		let minutes = Math.round((time-time%60)/60);
		let seconds = time%60;
		if(minutes<10) minutes  = "0" + String(minutes);
		if(seconds<10) seconds = "0"+String(seconds);
		return "Reload in " + minutes +":" + seconds+pad;
	    }
	    return "Reload in " + time +" seconds"+pad;
	},
	updateCountdown(time) {
	    if(this.getPropertyShowCountdown()) {
		this.jq(ID_COUNTDOWN).html(this.getCountdownLabel(time));
	    } else {
		this.jq(ID_COUNTDOWN).html("Reload");
	    }
	},
	setTimer(time) {
	    if(!this.okToRun()) return;
	    this.lastTime = time;
	    this.updateCountdown(time);
	    if(this.lastTimeout) clearTimeout(this.lastTimeout);
	    this.lastTimeout = setTimeout(()=>{
		this.checkReload(time);
	    },1000);
	},
	checkReload: function(time) {
	    time--;
	    if(time<=0) {
		this.jq(ID_COUNTDOWN).html("Reloading..." +HU.span([STYLE,"color:transparent;"],""));
		this.reloadData();
		time = this.getPropertyInterval();
		//Start up again in a bit so the reloading... label is shown
		if(this.lastTimeout) clearTimeout(this.lastTimeout);
		this.lastTimeout = setTimeout(()=>{
		    this.setTimer(time);
		},1000);
	    } else {
		this.setTimer(time);
	    }
	}
    });
}

function RamaddaTicksDisplay(displayManager, id, properties) {
    if(!properties.animationHeight) properties.animationHeight = "30px";
    properties.doAnimation =  false;
    properties.animationShowButtons = false;
    properties.animationMakeSlider = false;
    const ID_ANIMATION = "animation";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TICKS, properties);
    let myProps = [
	{label:'Time Ticks'},
	{p:'animationHeight',ex:'30px'},
	{p:'showYears',ex:'true'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {    
        needsData: function() {
            return true;
        },
	dataFilterChanged: function() {
	    SUPER.dataFilterChanged.call(this);
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let dateInfo = this.getDateInfo(records);
	    let years = {
	    }
	    if(!this.getPropertyShowYears(false)) {
		years["all"] = {
		    records:records,
		    yearCnt:"all"
		}
	    } else {
		let yearCnt=0;
		records.forEach(record=>{
		    if(!record.getDate()) return;
		    let year = record.getDate().getUTCFullYear();
		    if(years[year] == null) {
			years[year] = {
			    records:[],
			}
		    }
		    years[year].records.push(record);
		});
	    }
	    let html = "";
	    Object.keys(years).sort().forEach(year=>{
		html+=HU.div([CLASS,'display-ticks-ticks', ID,this.getDomId(ID_ANIMATION+year)]);
	    })
	    this.setContents(html);
	    Object.keys(years).sort().forEach((year,idx)=>{		 
		let info=years[year];
		let dateInfo = this.getDateInfo(info.records);
		let animation = new DisplayAnimation(this,true,{baseDomId:ID_ANIMATION+year,targetDiv:this.jq(ID_ANIMATION+year)});
		animation.makeControls();
		if(year!="all") {
		    dateInfo.dateMin = new Date(Date.UTC(year,0,1));
		    dateInfo.dateMax = new Date(Date.UTC(year,11,31));
		}
		animation.init(dateInfo.dateMin, dateInfo.dateMax,info.records);
	    });
	}
    });
}


/**
Copyright 2008-2019 Geode Systems LLC
*/

const DISPLAY_NOTEBOOK = "notebook";
addGlobalDisplayType({
    type: DISPLAY_NOTEBOOK,
    label: "Notebook",
    requiresData: false,
    category: CATEGORY_CONTROLS
});

var pluginDefintions = {
    'jsx': {
        "languageId": "jsx",
        "displayName": "React JSX",
        "url": "https://raw.githubusercontent.com/hamilton/iodide-jsx/master/docs/evaluate-jsx.js",
        "module": "jsx",
        "evaluator": "evaluateJSX",
        "pluginType": "language"
    },
    "lisp": {
        "languageId": "lisp",
        "displayName": "Microtalk Lisp",
        "url": "https://ds604.neocities.org/js/microtalk.js",
        "module": "MICROTALK",
        "evaluator": "evaluate",
        "pluginType": "language",
        "outputHandler": "processLispOutput",
    },
    "sql": {
        "languageId": "sql",
        "displayName": "SqlLite",
        "url": ramaddaBaseHtdocs+"/lib/notebook/sqllite.js",
        "module": "SqlLite",
        "evaluator": "evaluate",
        "pluginType": "language"
    },
    "plantuml": {
        "languageId": "plantuml",
        "displayName": "PlantUml",
        "codeMirrorMode": "",
        "keybinding": "x",
        "url": "https://raw.githubusercontent.com/six42/iodide-plantuml-plugin/master/src/iodide-plantuml-plugin.js",
        "depends": [{
            "type": "js",
            "url": "https://raw.githubusercontent.com/johan/js-deflate/master/rawdeflate.js"
        }],
        "module": "plantuml",
        "evaluator": "plantuml_img",
        "pluginType": "language"
    },
    "ml": {
        "languageId": "ml",
        "displayName": "ocaml",
        "codeMirrorMode": "mllike",
        "keybinding": "o",
        "url": "https://louisabraham.github.io/domical/eval.js",
        "module": "evaluator",
        "evaluator": "execute",
        "pluginType": "language",
        "depends": [{
            "type": "css",
            "url": "https://louisabraham.github.io/domical/style.css"
        }]
    }
};




function RamaddaNotebookDisplay(displayManager, id, properties) {
    var ID_NOTEBOOK = "notebook";
    var ID_IMPORTS = "imports";
    var ID_CELLS = "cells";
    var ID_CELLS_BOTTOM = "cellsbottom";
    var ID_INPUTS = "inputs";
    var ID_OUTPUTS = "outputs";
    var ID_CONSOLE = "console";
    var ID_CONSOLE_TOOLBAR = "consoletoolbar";
    var ID_CONSOLE_CONTAINER = "consolecontainer";
    var ID_CONSOLE_OUTPUT = "consoleout";
    var ID_CELL = "cell";
    var ID_MENU = "menu";
    this.properties = properties || {};
    let SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_NOTEBOOK, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        runOnLoad: this.getProperty("runOnLoad", true),
        displayMode: this.getProperty("displayMode", false),
        showConsole: this.getProperty("showConsole", true),
        consoleHidden: this.getProperty("consoleHidden", false),
        layout: this.getProperty("layout", "horizontal"),
        columns: this.getProperty("columns", 1),
    });

    RamaddaUtil.defineMembers(this, {
        cells: [],
        cellCount: 0,
        fetchedNotebook: false,
        currentEntries: {},
        globals: {},
        baseEntries: {},
        outputRenderers: [],
        initDisplay: async function() {
            this.createUI();
            var imports = HtmlUtils.div(["id", this.getDomId(ID_IMPORTS)]);
            var contents = imports + HtmlUtils.div([ATTR_CLASS, "display-notebook-cells", ATTR_ID, this.getDomId(ID_CELLS)], "&nbsp;&nbsp;Loading...") +
                HtmlUtils.div([ATTR_ID, this.getDomId(ID_CELLS_BOTTOM)]);
            var popup = HtmlUtils.div(["class", "ramadda-popup", ATTR_ID, this.getDomId(ID_MENU)]);
            contents = HtmlUtils.div([ATTR_ID, this.getDomId(ID_NOTEBOOK)], popup + contents);
            this.setContents(contents);
            this.makeCellLayout();
            this.jq(ID_NOTEBOOK).hover(() => {}, () => {
                this.jq(ID_MENU).hide()
            });
            if (!this.fetchedNotebook) {
                this.initOutputRenderers();
                if (!this.fetchingNotebook) {
                    this.fetchingNotebook = true;
                    await Utils.importCSS(ramaddaBaseHtdocs + "/lib/fontawesome/css/all.min.css");
                    await Utils.importJS(ramaddaBaseHtdocs + "/lib/ace/src-min/ace.js");
                    await Utils.importJS(ramaddaBaseUrl + "/lib/showdown.min.js");
                    var imports = "<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Main-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Math-Italic.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Size2-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'>\n<link rel='preload' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/fonts/KaTeX_Size4-Regular.woff2' as='font' type='font/woff2' crossorigin='anonymous'/>\n<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Lato:300,400,700,700i'>\n<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css' crossorigin='anonymous'>\n<link rel='stylesheet' href='static/index.css'><script defer src='https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js' crossorigin='anonymous'></script>";
                    $(imports).appendTo("head");
                    setTimeout(() => this.fetchNotebook(1), 10);
                }
            } else {
                this.layoutCells();
            }
        },
        fetchNotebook: async function(cnt) {
            if (!window["ace"]) {
                if (cnt > 50) {
                    alert("Could not load ace.js");
                    return;
                }
                setTimeout(() => this.fetchNotebook(cnt + 1), cnt * 10);
                return;
            }
            var dttm = new Date().getTime();
            ace.config.set('basePath', ramaddaBaseUrl + "/htdocs_v" + dttm + "/lib/ace/src-min");
            let _this = this;
            this.fetchedNotebook = true;
            await this.getEntry(this.getProperty("entryId", ""), entry => {
                this.baseEntry = entry;
            });
            await this.baseEntry.getRoot(entry => {
                this.rootEntry = entry;
            });
            var id = this.getProperty("entryId", "");
            var url = ramaddaBaseUrl + "/getnotebook?entryid=" + id;
            url += "&notebookId=" + this.getProperty("notebookId", "default_notebook");
            var jqxhr = $.getJSON(url, function(data) {
                _this.loadJson(data);
            }).fail(function() {
                var props = {
                    showInput: true,
                }
                this.addCell("init cell", props, false).run();
                this.cells[0].focus();
            });

        },
        formatObject: function(value) {
            return Utils.formatJson(value);
        },
        initOutputRenderers: function() {
            let notebook = this;
            this.outputRenderers = [];
            /*
            this.addOutputRenderer({
                    shouldRender: (value) => {return typeof value === "object";},
                        render: (value) => {if(Array.isArray(value)) return HtmlUtils.div(["style"," white-space: pre;"], JSON.stringify(value)); return HtmlUtils.div(["style"," white-space: pre;"],JSON.stringify(value,null,2))},
                        });
            */
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return Array.isArray(value);
                },
                render: (value) => {
                    return Utils.formatJson(value);
                },
            });
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return Array.isArray(value) && value.length > 0 && Array.isArray(value[0]);
                },
                render: (value) => {
                    var table = "<table>";
                    for (var rowIdx = 0; rowIdx < value.length; rowIdx++) {
                        var row = value[rowIdx];
                        table += "<tr>";
                        for (var colIdx = 0; colIdx < row.length; colIdx++) {
                            table += "<td>&nbsp;" + row[colIdx] + "</td>";
                        }
                        table += "</tr>";
                    }
                    table += "</table>";
                    return table;

                }
            });


            this.addOutputRenderer({
                shouldRender: (value) => {
                    return typeof value === "object" && value.getTime;
                },
                render: (value) => {
                    return notebook.formatDate(value)
                },
            });

            this.addOutputRenderer({
                shouldRender: (value) => {
                    var t = typeof value;
                    return t === "string" || t === "number" || t === "boolean";
                },
                render: (value) => {
                    if (typeof value === "string") {
                        if (value.split("\n").length > 1) {
                            return HtmlUtils.div(["style", " white-space: pre;"], value);
                        }
                    }
                    return value
                },
            });
            this.addOutputRenderer({
                shouldRender: (value) => {
                    return typeof value === "object" && "lat" in value && "lon" in value;
                },
                render: (value) => {
                    var url = 'http://staticmap.openstreetmap.de/staticmap.php?center=' + value.lat + ',' + value.lon + '&zoom=17&size=400x150&maptype=mapnik';
                    return "<img src='" + url + "'/>"
                },
            });

        },
        addOutputRenderer: function(renderer) {
            if (this.outputRenderers.indexOf(renderer) < 0) {
                this.outputRenderers.push(renderer);
            }
        },
        formatOutput: function(value) {
            if (!value) return null;
            for (var i = this.outputRenderers.length - 1; i >= 0; i--) {
                var renderer = this.outputRenderers[i];
                if (renderer.shouldRender && renderer.shouldRender(value)) {
                    return renderer.render(value);
                }
            }
            var v = null;
            if (value.iodideRender) {
                v = value.iodideRender();
            } else if (value.notebookRender) {
                v = value.notebookRender();
            }
            if (v) {
                //TODO handle elements
                if (typeof v == "string") {
                    return v;
                }
            }
            return null;
        },
        getBaseEntry: function() {
            return this.baseEntry;
        },
        getRootEntry: function() {
            return this.rootEntry;
        },
        getPopup: function() {
            return this.jq(ID_MENU);
        },
        loadJson: async function(data) {
            if (data.error) {
                this.setContents(_this.getMessage("Failed to load notebook: " + data.error));
                return;
            }
            if (!Utils.isDefined(this.properties.runOnLoad) && Utils.isDefined(data.runOnLoad)) {
                this.runOnLoad = data.runOnLoad;
            }
            if (!Utils.isDefined(this.properties.displayMode) && Utils.isDefined(data.displayMode)) {
                this.displayMode = data.displayMode;
            }
            if (!Utils.isDefined(this.properties.showConsole) && Utils.isDefined(data.showConsole)) {
                this.showConsole = data.showConsole;
            }
            if (Utils.isDefined(data.consoleHidden)) {
                this.consoleHidden = data.consoleHidden;
            }
            if (!Utils.isDefined(this.properties.columns) && Utils.isDefined(data.columns)) {
                this.columns = data.columns;
            }
            if (!Utils.isDefined(this.properties.layout) && Utils.isDefined(data.layout)) {
                this.layout = data.layout;
            }

            if (Utils.isDefined(data.currentEntries)) {
                for (a in data.currentEntries) {
                    var obj = {};
                    if (this.currentEntries[a]) continue;
                    obj.name = a;
                    obj.entryId = data.currentEntries[a].entryId;
                    try {
                        await this.getEntry(obj.entryId, e => obj.entry = e);
                        this.currentEntries[a] = obj;
                    } catch (e) {}
                }
            }
            if (Utils.isDefined(data.cells)) {
                this.cells = [];
                data.cells.forEach(cell => this.addCell(cell.outputHtml, cell, true));
                this.layoutCells();
            }
            if (this.cells.length == 0) {
                var props = {
                    showInput: true,
                }
                this.addCell("%%wiki\n", props, false);
                this.layoutCells();
                this.cells[0].focus();
            }
            if (this.runOnLoad) {
                this.runAll();
            }
        },
        addEntry: async function(name, entryId) {
            var entry;
            await this.getEntry(entryId, e => entry = e);
            this.currentEntries[name] = {
                entryId: entryId,
                entry: entry
            };
        },
        getCurrentEntries: function() {
            return this.currentEntries;
        },
        clearEntries: function() {
            this.currentEntries = {};
            for (a in this.baseEntries)
                this.currentEntries[a] = this.baseEntries[a];
        },
        saveNotebook: function(output) {
            var json = this.getJson(output);
            json = JSON.stringify(json, null, 2);
            var args = {
                entryid: this.getProperty("entryId", ""),
                notebookId: this.getProperty("notebookId", "default_notebook"),
                notebook: json
            };
            var url = ramaddaBaseUrl + "/savenotebook";
            $.post(url, args, (result) => {
                if (result.error) {
                    alert("Error saving notebook: " + result.error);
                    return;
                }
                if (result.result != "ok") {
                    alert("Error saving notebook: " + result.result);
                    return;
                }
                if (!this.getShowConsole()) {
                    alert("Notebook saved");
                } else {
                    this.log("Notebook saved", "info", "nb");
                }
            });
        },
        showInput: function() {
            if (this.displayMode && !this.getProperty("user")) {
                return false;
            }
            if (this.getProperty("showInput", true) == false) {
                return false;
	    }
            return true;
        },
        getJson: function(output) {
            var obj = {
                cells: [],
                currentEntries: {},
                runOnLoad: this.runOnLoad,
                displayMode: this.displayMode,
                showConsole: this.showConsole,
                consoleHidden: this.consoleHidden,
                layout: this.layout,
                columns: this.columns,
            };
            for (var name in this.currentEntries) {
                var e = this.currentEntries[name];
                obj.currentEntries[name] = {
                    entryId: e.entryId
                };
            }
            this.cells.forEach(cell => obj.cells.push(cell.getJson(output)));
            return obj;
        },
        initConsole: function() {
            if (!this.showInput()) {
                return;
            }
            let _this = this;
            this.console = this.jq(ID_CONSOLE_OUTPUT);
            if (this.consoleHidden)
                this.console.hide();
            this.jq(ID_CONSOLE).find(".ramadda-image-link").click(function(e) {
                var what = $(this).attr("what");
                if (what == "clear") {
                    _this.console.html("");
                }
                e.stopPropagation();
            });

            this.consoleToolbar = this.jq(ID_CONSOLE_TOOLBAR);
            this.consoleToolbar.click(() => {
                if (this.console.is(":visible")) {
                    this.console.hide(400);
                    this.consoleHidden = true;
                } else {
                    this.consoleHidden = false;
                    this.console.show(400);
                }
            });
        },
        getShowConsole: function() {
            return this.showInput() && this.showConsole;
        },
        makeConsole: function() {
            this.console = null;
            if (!this.getShowConsole()) {
                return "";
            }
            var contents = this.jq(ID_CONSOLE_OUTPUT).html();
            var consoleToolbar = HtmlUtils.div(["id", this.getDomId(ID_CONSOLE_TOOLBAR), "class", "display-notebook-console-toolbar", "title", "click to hide/show console"],
                HtmlUtils.leftRight("",
                    HtmlUtils.span(["class", "ramadda-image-link", "title", "Clear", "what", "clear"],
                        HtmlUtils.image(Utils.getIcon("clear.png")))));
            return HtmlUtils.div(["id", this.getDomId(ID_CONSOLE), "class", "display-notebook-console"],
                consoleToolbar +
                HtmlUtils.div(["class", "display-notebook-console-output", "id", this.getDomId(ID_CONSOLE_OUTPUT)], contents || ""));
        },

        makeCellLayout: function() {
            var html = "";
            var consoleContainer = HtmlUtils.div(["id", this.getDomId(ID_CONSOLE_CONTAINER)]);
            this.jq(ID_CELLS_BOTTOM).html("");
            if (this.showInput() && this.layout == "horizontal") {
                var left = HtmlUtils.div(["id", this.getDomId(ID_INPUTS), "style", "width:100%;"]);
                var right = HtmlUtils.div(["id", this.getDomId(ID_OUTPUTS), "style", "width:100%;"]);
                var center = HtmlUtils.div([], "");
                left += consoleContainer;
                html = "<table style='table-layout:fixed;' border=0 width=100%><tr valign=top><td width=50%>" + left + "</td><td style='border-left:1px #ccc solid;' width=1>" + center + "</td><td width=49%>" + right + "</td></tr></table>";
            } else {
                this.jq(ID_CELLS_BOTTOM).html(consoleContainer);
            }
            this.jq(ID_CELLS).html(html);
        },
        plugins: {},
        addPlugin: async function(plugin, chunk) {
            var error;
            if (plugin.depends) {
                for (var i = 0; i < plugin.depends.length; i++) {
                    var obj = plugin.depends[i];
                    var type = obj.type;
                    var url = obj.url;
                    if (type == "js") {
                        await Utils.importJS(url,
                            () => {},
                            (jqxhr, settings, exception) => {
                                error = "Error fetching plugin url:" + url;
                            });
                    } else if (type == "css") {
                        await Utils.importCSS(url,
                            () => {},
                            (jqxhr, settings, exception) => {
                                error = "Error fetching plugin url:" + url;
                            });
                    }
                    if (error) {
                        this.log(error, "error", "nb", chunk ? chunk.div : null);
                        return;
                    }
                }
            }

            var url = Utils.replaceRoot(plugin.url);
            await Utils.importJS(url,
                () => {},
                (jqxhr, settings, exception) => {
                    error = "Error fetching plugin url:" + url;
                });
            if (!error) {
                var module = plugin.module;
                var tries = 200;
                //Wait 20 seconds max
                while (window[module] == null && tries-- > 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                if (!window[module]) {
                    error = "Could not load plugin module: " + module;
                } else {
                    if (window[module].isPluginReady) {
                        var tries = 200;
                        while (!window[module].isPluginReady() && tries-- > 0) {
                            //                            console.log("not ready yet:" + tries);
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        //                        console.log("final ready:" + window[module].isPluginReady() );
                        if (!window[module].isPluginReady())
                            error = "Could not load plugin module: " + module;
                    }
                }
            }
            if (error) {
                this.log(error, "error", "nb", chunk ? chunk.div : null);
                return;
            }
            this.plugins[plugin.languageId] = plugin;
        },
        hasPlugin: async function(id, callback) {
            if (!this.plugins[id]) {
                if (window.pluginDefintions[id]) {
                    await this.addPlugin(window.pluginDefintions[id], null);
                }
            }
            Utils.call(callback, this.plugins[id] != null);
        },
        processChunkWithPlugin: async function(id, chunk, callback) {
            var module = this.plugins[id].module;
            var func = this.plugins[id].evaluator;
            var result = window[module][func](chunk.getContent(), chunk);
            return Utils.call(callback, result);

        },
        processPluginOutput: function(id, chunk, result) {
            if (!result) return;
            var module = this.plugins[id].module;
            var func = window[this.plugins[id].outputHandler];
            if (func) {
                chunk.div.append(func(result));
            } else {
                if (typeof result == "object") {
                    //TODO: for now don't format this as some results are recursive
                    //                   console.log(result);
                    //                   chunk.div.set(this.formatObject(result));
                } else {
                    chunk.div.set(result);
                }
            }
        },
        log: function(msg, type, from, div) {
            var icon = "";
            var clazz = "display-notebook-console-item";
            if (typeof msg == "object") {
                msg = Utils.formatJson(msg);
            }
            if (type == "error") {
                clazz += " display-notebook-console-item-error";
                icon = HtmlUtils.image(Utils.getIcon("cross-octagon.png"));
                if (div) {
                    div.append(HtmlUtils.div(["class", "display-notebook-chunk-error"], msg));
                }
            } else if (type == "output") {
                clazz += " display-notebook-console-item-output";
                icon = HtmlUtils.image(Utils.getIcon("arrow-000-small.png"));
            } else if (type == "info") {
                clazz += " display-notebook-console-item-info";
                icon = HtmlUtils.image(Utils.getIcon("information.png"));
            }
            if (!this.console) return;
            if (!from) from = "";
            else from = HtmlUtils.div(["class", "display-notebook-console-from"], from);
            var block = HtmlUtils.div(["style", "margin-left:5px;"], msg);
            var html = "<table width=100%><tr valign=top><td width=10>" + icon + "</td><td>" +
                block +
                "</td><td width=10>" +
                from +
                "</td></tr></table>";
            var item = HtmlUtils.div(["class", clazz], html);
            this.console.append(item);
            //200 is defined in display.css
            var height = this.console.prop('scrollHeight');
            if (height > 200)
                this.console.scrollTop(height - 200);
        },
        clearConsole: function() {
            this.console.html("");
        },
        layoutCells: function() {
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.prepareToLayout();
            }
            this.makeCellLayout();
            if (this.showInput() && this.layout == "horizontal") {
                var left = "";
                var right = "";
                var id;
                for (var i = 0; i < this.cells.length; i++) {
                    var cell = this.cells[i];
                    id = cell.id;
                    cell.index = i + 1;
                    left += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], "");
                    left += "\n";
                    right += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], "");
                }
                this.jq(ID_INPUTS).html(left);
                this.jq(ID_OUTPUTS).html(right);
            } else {
                var html = "<div class=row style='padding:0px;margin:0px;'>";
                var clazz = HtmlUtils.getBootstrapClass(this.columns);
                var colCnt = 0;
                for (var i = 0; i < this.cells.length; i++) {
                    var cell = this.cells[i];
                    cell.index = i + 1;
                    html += HtmlUtils.openTag("div", ["class", clazz]);
                    html += HtmlUtils.openTag("div", ["style", "max-width:100%;overflow-x:auto;padding:0px;margin:px;"]);
                    html += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], "");
                    html += HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], "");
                    html += HtmlUtils.closeTag("div");
                    html += HtmlUtils.closeTag("div");
                    html += "\n";
                    colCnt++;
                    if (colCnt >= this.columns) {
                        colCnt = 0;
                        html += HtmlUtils.closeTag("div");
                        html += "<div class=row style='padding:0px;margin:0px;'>";
                    }
                };
                html += HtmlUtils.closeTag("div");
                this.jq(ID_CELLS).append(html);
            }
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.createCell();
            };
            this.jq(ID_CONSOLE_CONTAINER).html(this.makeConsole());
            this.initConsole();
        },
        addCell: function(content, props, layoutLater) {
            cell = this.createCell(content, props);
            this.cells.push(cell);
            if (!layoutLater) {
                if (this.showInput() && this.layout == "horizontal") {
                    this.jq(ID_INPUTS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], ""));
                    this.jq(ID_OUTPUTS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], ""));
                } else {
                    this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_cellinput"], ""));
                    this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cell.id + "_celloutput"], ""));
                }
                cell.createCell();
            }
            return cell;
        },
        createCell: function(content, props) {
            if (!props) props = {
                showInput: true
            };
            var cellId = this.getId() + "_" + this.cellCount;
            //Override any saved id
            props.id = cellId;
            this.cellCount++;
            this.jq(ID_CELLS).append(HtmlUtils.div([ATTR_CLASS, "display-notebook-cell", ATTR_ID, cellId], ""));
            var cell = new RamaddaNotebookCell(this, cellId, content, props);
            return cell;
        },
        clearOutput: function() {
            this.cells.forEach(cell => cell.clearOutput());
        },
        getIndex: function(cell) {
            var idx = 0;
            for (var i = 0; i < this.cells.length; i++) {
                if (cell.id == this.cells[i].id) {
                    idx = i;
                    break;
                }
            }
            return idx;
        },
        moveCellUp: function(cell) {
            var cells = [];
            var newCell = null;
            var idx = this.getIndex(cell);
            if (idx == 0) return;
            this.cells.splice(idx, 1);
            this.cells.splice(idx - 1, 0, cell);
            this.layoutCells();
            cell.focus();
        },
        moveCellDown: function(cell) {
            var cells = [];
            var newCell = null;
            var idx = this.getIndex(cell);
            if (idx == this.cells.length - 1) return;
            this.cells.splice(idx, 1);
            this.cells.splice(idx + 1, 0, cell);
            this.layoutCells();
            cell.focus();
        },

        newCellAbove: function(cell) {
            var cells = [];
            var newCell = null;
            for (var i = 0; i < this.cells.length; i++) {
                if (cell.id == this.cells[i].id) {
                    newCell = this.createCell("%%wiki\n", {
                        showInput: true,
                        showHeader: false
                    });
                    cells.push(newCell);
                }
                cells.push(this.cells[i]);
            }
            this.cells = cells;
            this.layoutCells();
            newCell.focus();
        },

        newCellBelow: function(cell) {
            var cells = [];
            var newCell = null;
            for (var i = 0; i < this.cells.length; i++) {
                cells.push(this.cells[i]);
                if (cell.id == this.cells[i].id) {
                    newCell = this.createCell("%%wiki\n", {
                        showInput: true,
                        showHeader: false
                    });
                    cells.push(newCell);
                }
            }
            this.cells = cells;
            this.layoutCells();
            newCell.focus();
        },
        deleteCell: function(cell) {
            cell.jq(ID_CELL).remove();
            var cells = [];
            this.cells.forEach(c => {
                if (cell.id != c.id) {
                    cells.push(c);
                }
            });
            this.cells = cells;
            if (this.cells.length == 0) {
                this.addCell("", null);
            }
        },
        cellValues: {},
        setCellValue: function(name, value) {
            this.cellValues[name] = value;
        },
        getCellValues: function() {
            return this.cellValues;
        },
        convertInput: function(input) {
            for (name in this.cellValues) {
                var re = new RegExp("\\$\\{" + name + "\\}", "g");
                input = input.replace(re, this.cellValues[name]);
            }
            return input;
        },
        inGlobalChanged: false,
        globalChanged: async function(name, value) {
                var globalChangeCalled = this.inGlobalChanged;
                var top = !this.inGlobalChanged;
                if(this.inRunAll) {
                    top =  false;
                }
                this.inGlobalChanged=true;
                if(top) {
                    this.cells.forEach(cell=>cell.prepareToRun());
                }
                for(var i=0;i<this.cells.length;i++) {
                    await this.cells[i].globalChanged(name,value);
                }
                if(!globalChangeCalled) {
                    this.inGlobalChanged = false;
                }
        },
        addGlobal: async function(name, value, dontPropagate) {
            //TODO: more var name cleanup
            name = name.trim().replace(/[ -]/g, "_");
            var oldValue = this.getGlobalValue(name);
            if (Utils.isDefined(window[name])) window[name] = value;
            this.globals[name] = value;
            if(!dontPropagate) {
                var newValue = this.getGlobalValue(name);
                if(newValue!=oldValue) {
                    //TODO:
                    //                    await this.globalChanged(name, newValue);
                }
            }
        },
        getGlobalValue: function(name) {
                if(!this.globals[name]) return null;
                if(typeof this.globals[name] =="function") return this.globals[name]();
                return this.globals[name];
        },
        inRunAll: false,
        runAll: async function() {
            this.inRunAll = true;
            var ok = true;
            this.cellValues = {};
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                cell.prepareToRun();
            }
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                if (!cell.runFirst) continue;
                await this.runCell(cell).then(result => ok = result);
            }
            if (!ok) return;
            for (var i = 0; i < this.cells.length; i++) {
                var cell = this.cells[i];
                if (cell.runFirst) continue;
                await this.runCell(cell, true).then(result => ok = result);
            }
            this.inRunAll = false;
        },
        runCell: async function(cell, doingAll) {
            if (cell.hasRun) return true;
            await cell.run(result => ok = result, {
                doingAll: doingAll
            });
            if (!ok) return false;
            var raw = cell.getRawOutput();
            if (raw) {
                raw = raw.trim();
                if (Utils.stringDefined(cell.cellName)) {
                    this.cellValues[cell.cellName] = raw;
                }
            }
            return true;
        },
        toggleAll: function(on) {
            this.cells.forEach(cell => {
                cell.showInput = on;
                cell.applyStyle();
            });
        },

    });
}




var iodide = {
    addOutputRenderer: function(renderer) {
        notebook.addOutputRenderer(renderer);
    },
    addOutputHandler: function(renderer) {
        notebook.addOutputHandler(renderer);
    },
    output: {
        text: function(t) {
            notebook.write(t);
        },
        element: function(tag) {
            var id = HtmlUtils.getUniqueId();
            notebook.write(HtmlUtils.tag(tag, ["id", id]));
            return document.getElementById(id);
        }
    },
};

var notebook;


function NotebookState(cell, div) {
    this.id = HtmlUtils.getUniqueId();
    this.cell = cell;
    this.notebook = cell.notebook;
    $.extend(this, {
        entries: {},
        div: div,
        stopFlag: false,
        result: null,
        log: function(msg, type, from) {
            this.getNotebook().log(msg, type, from, this.div);
        },
        clearConsole: function() {
            this.getNotebook().clearConsole();
        },
        getStop: function() {
            return this.stopFlag;
        },
        getCell: function() {
            return this.cell;
        },
        addGlobal: async function(name,value) {
                await this.getNotebook().addGlobal(name,value);
        },

        globalChanged: async function(name,value) {
                await this.getNotebook().globalChanged(name,value);
        },
        setValue: function(name, value) {
            this.notebook.setCellValue(name, value);
        },
        makeData: async function(entry) {
            if (!entry)
                await this.getCurrentEntry(e => entry = e);
            if ((typeof entry) == "string") {
                await this.notebook.getEntry(entry, e => entry = e);
            }
            var jsonUrl = this.notebook.getPointUrl(entry);
            if (jsonUrl == null) {
                this.writeError("Not a point type:" + entry.getName());
                return null;
            }
            var pointDataProps = {
                entry: entry,
                entryId: entry.getId()
            };
            return new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
        },
        log: function(msg, type) {
            this.getNotebook().log(msg, type, "js");
        },
        getNotebook: function() {
            return this.notebook;
        },

        save: function(output) {
            this.notebook.saveNotebook(output);
            return "notebook saved";
        },

        clearEntries: function() {
            this.clearEntries();
        },

        ls: async function(entry) {
            var div = new Div();
            if (!entry)
                await this.getCurrentEntry(e => entry = e);
            this.call.getEntryHeading(entry, div);
            this.write(div.toString());
        },

        lsEntries: function() {
            var h = "";
            var entries = this.currentEntries;
            for (var name in entries) {
                var e = entries[name];
                h += name + "=" + e.entry.getName() + "<br>";
            }
            this.write(h);
        },

        stop: function() {
            this.stopFlag = true;
        },
        setGlobal: async function(name, value) {
                await this.cell.notebook.addGlobal(name, value);
        },
        setEntry: function(name, entryId) {
            this.cell.notebook.addEntry(name, entryId);
        },
        getEntry: async function(entryId, callback) {
            await this.cell.notebook.getEntry(e => entry = e);
            return Utils.call(callback, entry);
        },
        wiki: async function(s, entry, callback) {
            if (!callback) {
                var wdiv = new Div();
                this.div.append(wdiv.toString());
                callback = h => wdiv.append(h);
            }
            if (entry == null)
                await this.cell.getCurrentEntry(e => entry = e);
            if ((typeof entry) != "string") entry = entry.getId();
            await GuiUtils.loadHtml(ramaddaBaseUrl + "/wikify?doImports=false&entryid=" + entry + "&text=" + encodeURIComponent(s),
                callback);
        },
        //These are for the iodiode mimic
        addOutputRenderer: function(renderer) {
            this.getNotebook().addOutputRenderer(renderer);
        },
        addOutputHandler: function(renderer) {
            this.getNotebook().addOutputRenderer(renderer);
        },
        output: {
            text: function(t) {
                notebook.write(t);
            },
            element: function(tag) {
                var id = HtmlUtils.getUniqueId();
                notebook.write(HtmlUtils.tag(tag, ["id", id]));
                return document.getElementById(id);
            }
        },
        clearOutput: function() {
            this.cell.clearOutput();
        },
        clearAllOutput: function() {
            this.getNotebook().clearOutput();
        },
        write: function(value, clear) {
            if (!value) return;
            var s = this.getNotebook().formatOutput(value);
            if (s == null && (typeof value) == "object") {
                s = this.notebook.formatObject(value);
            }
            if (clear)
                this.div.set(s);
            else
                this.div.append(s);
        },
        linechart: async function(entry, props) {
            if (!entry)
                await this.cell.getCurrentEntry(e => entry = e);
            this.cell.createDisplay(this, entry, DISPLAY_LINECHART, props);
        },
    });
}


var notebookStates = {};

function RamaddaNotebookCell(notebook, id, content, props) {
    this.notebook = notebook;

    var ID_CELL = "cell";
    var ID_HEADER = "header";
    var ID_CELLNAME = "cellname";
    var ID_INPUT = "input";
    var ID_INPUT_TOOLBAR = "inputtoolbar";
    var ID_OUTPUT = "output";
    var ID_MESSAGE = "message";
    var ID_BUTTON_MENU = "menubutton";
    var ID_BUTTON_RUN = "runbutton";
    var ID_BUTTON_TOGGLE = "togglebutton";
    var ID_MENU = "menu";
    var ID_CELLNAME_INPUT = "cellnameinput";
    var ID_SHOWHEADER_INPUT = "showheader";
    var ID_SHOWEDIT = "showedit";
    var ID_RUN_ON_LOAD = "runonload";
    var ID_DISPLAY_MODE = "displaymode";
    var ID_LAYOUT_TYPE = "layouttype";
    var ID_SHOWCONSOLE = "showconsole";
    var ID_LAYOUT_COLUMNS = "layoutcolumns";
    var ID_RUNFIRST = "runfirst";
    var ID_SHOW_OUTPUT = "showoutput";
    var ID_RUN_ICON = "runningicon";

    let SUPER = new DisplayThing(id, {});
    RamaddaUtil.inherit(this, SUPER);

    RamaddaUtil.defineMembers(this, {
        id: id,
        inputRows: 1,
        index: 0,
        content: content,
        outputHtml: "",
        showInput: false,
        showHeader: false,
        cellName: "",
        runFirst: false,
        showOutput: true,
    });

    if (props) {
        $.extend(this, props);
    }
    RamaddaUtil.defineMembers(this, {
        getJson: function(output) {
            var obj = {
                id: this.id,
                inputRows: this.inputRows,
                content: this.getInputText(),
                showInput: this.showInput,
                showHeader: this.showHeader,
                runFirst: this.runFirst,
                showOutput: this.showOutput,
                cellName: this.cellName,
            };
            if (this.currentEntry)
                obj.currentEntryId = this.currentEntry.getId();
            if (output)
                obj.outputHtml = this.outputHtml;
            return obj;
        },
        createCell: function() {
            if (this.content == null) {
                this.content = "%% wiki";
            }
            this.editId = addHandler(this);
            addHandler(this, this.editId + "_entryid");
            addHandler(this, this.editId + "_wikilink");
            var _this = this;
            var buttons =
                this.makeButton(ID_BUTTON_MENU, icon_menu, "Show menu", "showmenu") +
                this.makeButton(ID_BUTTON_RUN, Utils.getIcon("run.png"), "Run this cell", "run") +
                this.makeButton(ID_BUTTON_RUN, Utils.getIcon("runall.png"), "Run all", "runall");

            var runIcon = HtmlUtils.image(icon_blank, ["align", "right", "id", this.getDomId(ID_RUN_ICON), "style", "padding-bottom:2px;padding-top:2px;padding-right:5px;"]);
            buttons = buttons + "&nbsp;" + HtmlUtils.span(["id", this.getDomId(ID_CELLNAME)], this.cellName);
            buttons += runIcon;
            var header = HtmlUtils.div([ATTR_CLASS, "display-notebook-header", ATTR_ID, this.getDomId(ID_HEADER), "tabindex", "0", "title", "Click to toggle input\nShift-click to clear output"], "&nbsp;" + buttons);

            //Strip out the meta chunks
            var content = "";
            var lines = this.content.split("\n");
            var inMeta = false;
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var _line = line.trim();
                if (_line.startsWith("%%")) {
                    if (_line.match(/^%% *meta/)) {
                        inMeta = true;
                    } else {
                        inMeta = false;
                    }
                }
                if (!inMeta) {
                    content += line + "\n";
                }
            }


            content = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            var input = HtmlUtils.div([ATTR_CLASS, "display-notebook-input ace_editor", ATTR_ID, this.getDomId(ID_INPUT), "title", "shift-return: run chunk\nctrl-return: run to end"], content);
            var inputToolbar = HtmlUtils.div(["id", this.getDomId(ID_INPUT_TOOLBAR)], "");

            input = HtmlUtils.div(["class", "display-notebook-input-container"], inputToolbar + input);
            var output = HtmlUtils.div([ATTR_CLASS, "display-notebook-output", ATTR_ID, this.getDomId(ID_OUTPUT)], this.outputHtml);
            output = HtmlUtils.div(["class", "display-notebook-output-container"], output);
            var menu = HtmlUtils.div(["id", this.getDomId(ID_MENU), "class", "ramadda-popup"], "");
            var html = header + input;
            html = HtmlUtils.div(["id", this.getDomId(ID_CELL)], html);
            $("#" + this.id + "_cellinput").html(html);
            $("#" + this.id + "_celloutput").html(output);
            var url = ramaddaBaseUrl + "/wikitoolbar?doImports=false&entryid=" + this.entryId + "&handler=" + this.editId;
            url += "&extrahelp=" + ramaddaBaseUrl + "/userguide/notebook.html|Notebook Help";
            GuiUtils.loadHtml(url, h => {
                this.inputToolbar = h;
                this.jq(ID_INPUT_TOOLBAR).html(h);
                $("#" + this.editId + "_prefix").html(HtmlUtils.span(["id", this.getDomId("toolbar_notebook"),
                    "style", "border-right:1px #ccc solid;",
                    "class", "ramadda-menubar-button"
                ], "Notebook"));
                this.jq("toolbar_notebook").click(() => this.showNotebookMenu());

            });
            this.header = this.jq(ID_HEADER);
            this.header.click((e) => {
                if (e.shiftKey)
                    this.processCommand("clear");
                else {
                    this.hidePopup();
                    this.processCommand("toggle");
                }

            });

            let wikiEditor = new WikiEditor("", "", this.getDomId(ID_INPUT), false, {
                maxLines: 30,
                minLines: 5
            });
	    this.editor = wikiEditor.getEditor();
            this.editor.getSession().on('change', () => {
                this.inputChanged();
            });
            this.menuButton = this.jq(ID_BUTTON_MENU);
            this.toggleButton = this.jq(ID_BUTTON_TOGGLE);
            this.cell = this.jq(ID_CELL);
            this.input = this.jq(ID_INPUT);
            this.output = this.jq(ID_OUTPUT);
            this.inputContainer = this.cell.find(".display-notebook-input-container");
            this.inputMenu = this.cell.find(".display-notebook-input-container");
            this.applyStyle();
            this.header.find(".display-notebook-menu-button").click(function(e) {
                _this.processCommand($(this).attr("what"));
                e.stopPropagation();
            });

            this.calculateInputHeight();
            this.input.focus(() => this.hidePopup());
            this.input.click(() => this.hidePopup());
            this.output.click(() => this.hidePopup());
            this.input.on('input selectionchange propertychange', () => this.calculateInputHeight());
            var moveFunc = (e) => {
                var key = e.key;
                if (key == 'v' && e.ctrlKey) {
                    this.notebook.moveCellDown(_this);
                    return;
                }
                if (key == 6 && e.ctrlKey) {
                    this.notebook.moveCellUp(_this);
                    return;
                }

            };
            this.input.keydown(moveFunc);
            this.header.keydown(moveFunc);
            this.input.keydown(function(e) {
                var key = e.key;
                if (key == 's' && e.ctrlKey) {
                    _this.notebook.saveNotebook(false);
                    return;
                }
                if (key == 'Enter') {
                    //                    console.log(key +"  shift:"  + e.shiftKey +" ctrl:" + e.ctrlKey);
                    if (e.shiftKey || e.ctrlKey) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (e.shiftKey && e.ctrlKey) {
                            //run all
                            _this.run(null);
                        } else {
                            //run current, run to end
                            _this.run(null, {
                                justCurrent: true,
                                toEnd: e.ctrlKey
                            });
                            if (!e.ctrlKey) {
                                _this.stepToNextChunk();
                            }
                        }
                    }
                }

            });
        },
        selectClick(type, id, entryId, value) {
            if (type == "entryid") {
                this.insertText(entryId);
            } else {
                this.insertText("[[" + entryId + "|" + value + "]]");
            }
            this.input.focus();
        },
        insertTags: function(tagOpen, tagClose, sampleText) {
            var id = this.getDomId(ID_INPUT);
            var textComp = GuiUtils.getDomObject(id);
            insertTagsInner(id, textComp.obj, tagOpen, tagClose, sampleText);
            this.calculateInputHeight();
        },
        insertText: function(value) {
            var id = this.getDomId(ID_INPUT);
            var textComp = GuiUtils.getDomObject(id);
            insertAtCursor(id, textComp.obj, value);
            this.calculateInputHeight();
        },
        showNotebookMenu: function() {
            var link = this.jq("toolbar_notebook");
            this.makeMenu(link, "left bottom");
        },
        makeButton: function(id, icon, title, command) {
            if (!command) command = "noop";
            return HtmlUtils.div(["what", command, "title", title, "class", "display-notebook-menu-button", "id", this.getDomId(id)], HtmlUtils.image(icon, []));
        },
        makeMenu: function(src, at) {
            if (!src) {
                src = this.input;
            }
            if (!src.is(":visible")) {
                src = this.header;
            }
            if (!src.is(":visible")) {
                src = this.output;
            }
            if (!at) at = "left top";
            let _this = this;
            var space = "&nbsp;&nbsp;";
            var line = "<div style='border-top:1px #ccc solid;margin-top:4px;margin-bottom:4px;'></div>"
            var menu = "";
            menu += HtmlUtils.input(ID_CELLNAME_INPUT, _this.cellName, ["placeholder", "Cell name", "style", "width:100%;", "id", _this.getDomId(ID_CELLNAME_INPUT)]);
            menu += "<br>";
            menu += "<table  width=100%> ";
            menu += "<tr><td align=right><b>New cell:</b>&nbsp;</td><td>";
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "newabove"], "Above") + space;
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "newbelow"], "Below");
            menu += "</td></tr>"
            menu += "<tr><td align=right><b>Move:</b>&nbsp;</td><td>";
            menu += HtmlUtils.div(["title", "ctrl-^", "class", "ramadda-link", "what", "moveup"], "Up") + space;
            menu += HtmlUtils.div(["title", "ctrl-v", "class", "ramadda-link", "what", "movedown"], "Down");
            menu += "</td></tr>"

            menu += "</table>";

            menu += line;
            menu += HtmlUtils.div(["title", "ctrl-return", "class", "ramadda-link", "what", "hideall"], "Hide all inputs");
            menu += "<br>"
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "clearall"], "Clear all outputs");
            menu += "<br>";
            var cols = this.notebook.columns;
            var colId = _this.getDomId(ID_LAYOUT_COLUMNS);
            menu += "<b>Layout:</b> ";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_LAYOUT_TYPE), [], _this.notebook.layout == "horizontal") + " Horizontal" + "<br>";
            //            menu += "Columns: ";
            //            menu += HtmlUtils.input(colId, this.notebook.columns, ["size", "3", "id", _this.getDomId(ID_LAYOUT_COLUMNS)]);
            menu += line;

            menu += HtmlUtils.checkbox(_this.getDomId(ID_SHOW_OUTPUT), [], _this.showOutput) + " Output enabled" + "<br>";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_SHOWCONSOLE), [], _this.notebook.showConsole) + " Show console" + "<br>";

            menu += HtmlUtils.checkbox(_this.getDomId(ID_RUNFIRST), [], _this.runFirst) + " Run first" + "<br>";
            menu += HtmlUtils.checkbox(_this.getDomId(ID_RUN_ON_LOAD), [], _this.notebook.runOnLoad) + " Run on load" + "<br>";
            menu += HtmlUtils.div(["title", "Don't show the left side and input for anonymous users"], HtmlUtils.checkbox(_this.getDomId(ID_DISPLAY_MODE), [], _this.notebook.displayMode) + " Display mode" + "<br>");

            menu += line;
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "savewithout"], "Save notebook") + "<br>";
            menu += line;
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "delete"], "Delete cell") + "<br>";
            menu += HtmlUtils.div(["class", "ramadda-link", "what", "help"], "Help") + "<br>";
            menu = HtmlUtils.div(["class", "display-notebook-menu"], menu);


            var popup = this.getPopup();
            this.dialogShown = true;
            popup.html(HtmlUtils.div(["class", "ramadda-popup-inner"], menu));
            popup.show();
            popup.position({
                of: src,
                my: "left top",
                at: at,
                collision: "fit fit"
            });
            _this.jq(ID_SHOWHEADER_INPUT).focus();

            _this.jq(ID_SHOWCONSOLE).change(function(e) {
                _this.notebook.showConsole = _this.jq(ID_SHOWCONSOLE).is(':checked');
                _this.hidePopup();
                _this.notebook.layoutCells();
            });


            _this.jq(ID_SHOWHEADER_INPUT).change(function(e) {
                _this.showHeader = _this.jq(ID_SHOWHEADER_INPUT).is(':checked');
                _this.applyStyle();
            });


            _this.jq(ID_RUNFIRST).change(function(e) {
                _this.runFirst = _this.jq(ID_RUNFIRST).is(':checked');
            });

            _this.jq(ID_SHOW_OUTPUT).change(function(e) {
                _this.showOutput = _this.jq(ID_SHOW_OUTPUT).is(':checked');
                _this.applyStyle();
            });
            _this.jq(ID_RUN_ON_LOAD).change(function(e) {
                _this.notebook.runOnLoad = _this.jq(ID_RUN_ON_LOAD).is(':checked');
            });
            _this.jq(ID_DISPLAY_MODE).change(function(e) {
                _this.notebook.displayMode = _this.jq(ID_DISPLAY_MODE).is(':checked');
            });
            _this.jq(ID_SHOWEDIT).change(function(e) {
                _this.showInput = _this.jq(ID_SHOWEDIT).is(':checked');
                _this.applyStyle();
            });

            _this.jq(ID_LAYOUT_TYPE).change(function(e) {
                if (_this.jq(ID_LAYOUT_TYPE).is(':checked')) {
                    _this.notebook.layout = "horizontal";
                } else {
                    _this.notebook.layout = "vertical";
                }
                _this.hidePopup();
                _this.notebook.layoutCells();
            });
            _this.jq(ID_LAYOUT_COLUMNS).keypress(function(e) {
                var keyCode = e.keyCode || e.which;
                if (keyCode != 13) {
                    return;
                }
                var cols = parseInt(_this.jq(ID_LAYOUT_COLUMNS).val());
                if (isNaN(cols)) {
                    _this.jq(ID_LAYOUT_COLUMNS).val("bad:" + _this.jq(ID_LAYOUT_COLUMNS).val());
                    return;
                }
                _this.hidePopup();
            });
            _this.jq(ID_CELLNAME_INPUT).keypress(function(e) {
                var keyCode = e.keyCode || e.which;
                if (keyCode == 13) {
                    _this.hidePopup();
                    return;
                }
            });
            popup.find(".ramadda-link").click(function() {
                var what = $(this).attr("what");
                _this.processCommand(what);
            });
        },
        hidePopup: function() {
            var popup = this.getPopup();
            if (popup && this.dialogShown) {
                var cols = parseInt(this.jq(ID_LAYOUT_COLUMNS).val());
                this.cellName = this.jq(ID_CELLNAME_INPUT).val();
                this.jq(ID_CELLNAME).html(this.cellName);
                popup.hide();
                this.applyStyle();

                if (!isNaN(cols) && this.notebook.columns != cols) {
                    this.notebook.columns = cols;
                    this.notebook.layoutCells();
                }
            }
            this.dialogShown = false;
        },
        processCommand: function(command) {
            if (command == "showmenu") {
                this.makeMenu();
                return;
            } else if (command == "toggle") {
                this.showInput = !this.showInput;
                this.applyStyle(true);
            } else if (command == "showthis") {
                this.showInput = true;
                this.applyStyle();
            } else if (command == "hidethis") {
                this.showInput = false;
                this.applyStyle();
            } else if (command == "showall") {
                this.notebook.toggleAll(true);
            } else if (command == "hideall") {
                this.notebook.toggleAll(false);
            } else if (command == "run") {
                this.notebook.runCell(this);
            } else if (command == "runall") {
                this.notebook.runAll();
            } else if (command == "clear") {
                this.clearOutput();
            } else if (command == "clearall") {
                this.notebook.clearOutput();
            } else if (command == "moveup") {
                this.notebook.moveCellUp(this);
            } else if (command == "movedown") {
                this.notebook.moveCellDown(this);
            } else if (command == "newabove") {
                this.notebook.newCellAbove(this);
            } else if (command == "newbelow") {
                this.notebook.newCellBelow(this);
            } else if (command == "savewith") {
                this.notebook.saveNotebook(true);
            } else if (command == "savewithout") {
                this.notebook.saveNotebook(false);
            } else if (command == "help") {
                var win = window.open(ramaddaBaseUrl + "/userguide/notebook.html", '_blank');
                win.focus();
            } else if (command == "delete") {
                this.askDelete();
                return;
            } else {
                console.log("unknown command:" + command);
            }
            this.hidePopup();
        },
        shouldShowInput: function() {
            return this.showInput && this.notebook.showInput();
        },
        applyStyle: function(fromUser) {
            if (this.shouldShowInput()) {
                this.jq(ID_INPUT_TOOLBAR).css("display", "block");
                this.inputContainer.show(400, () => this.editor.resize());
                this.showHeader = true;
            } else {
                this.jq(ID_INPUT_TOOLBAR).css("display", "none");
                this.inputContainer.hide(fromUser ? 200 : 0);
                this.showHeader = false;
            }
            this.showHeader = this.notebook.showInput();
            if (this.showHeader) {
                this.header.css("display", "block");
            } else {
                this.header.css("display", "none");
            }
            if (this.showOutput) {
                this.output.css("display", "block");
            } else {
                this.output.css("display", "none");
            }
        },
        getPopup: function() {
            return this.notebook.getPopup();
        },
        askDelete: function() {
            let _this = this;
            var menu = "";
            menu += "Are you sure you want to delete this cell?<br>";
            menu += HtmlUtils.span(["class", "ramadda-link", "what", "yes"], "Yes");
            menu += HtmlUtils.span(["style", "margin-left:50px;", "class", "ramadda-link", "what", "cancel"], "No");
            var popup = this.getPopup();

            popup.html(HtmlUtils.div(["class", "ramadda-popup-inner"], menu));
            popup.show();
            var src = this.input;
            if (!src.is(":visible")) {
                src = this.output;
            }
            if (!src.is(":visible")) {
                src = this.header;
            }
            popup.position({
                of: src,
                my: "left top",
                at: "left top",
                collision: "fit fit"
            });
            popup.find(".ramadda-link").click(function() {
                var what = $(this).attr("what");
                _this.hidePopup();
                if (what == "yes") {
                    _this.notebook.deleteCell(_this);
                }
            });
        },
        inputChanged: function() {
            var value = this.getInputText();
            var lines = value.split("\n");
            var cursor = this.editor.getCursorPosition();
            for (var i = cursor.row; i >= 0; i--) {
                var line = lines[i].trim();
                if (line.startsWith("%%")) {
                    var type = line.substring(2).trim();
                    if (type.startsWith("md") || type.startsWith("html") || type.startsWith("css") || type.startsWith("raw")) {
                        var doRows = {};
                        doRows[i] = true;
                        this.runInner(value, doRows);
                    }
                    break;
                }
            }
        },
        stepToNextChunk: function() {
            var value = this.getInputText();
            var lines = value.split("\n");
            var cursor = this.editor.getCursorPosition();
            for (var i = cursor.row + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith("%%")) {
                    var ll = lines[i].length;
                    this.editor.selection.moveTo(i, ll);
                    this.editor.scrollToLine(i, true, true, function() {});
                    break;
                }
            }

        },
        run: async function(callback, args) {
            if (!args) args = {};
            var justCurrent = args.justCurrent;
            var toEnd = args.toEnd;
            var doingAll = args.doingAll;
            if (this.running) return Utils.call(callback, true);
            this.running = true;
            var doRows = null;
            try {
                var ok = true;
                var value = this.getInputText();
                if (justCurrent) {
                    doRows = {};
                    var cursor = this.editor.getCursorPosition();
                    var row = cursor.row;
                    var lines = value.split("\n");
                    var percentCnt = 0;
                    if (toEnd) {
                        justCurrent = false;
                        while (row >= 0) {
                            if (lines[row].trim().startsWith("%%")) {
                                break;
                            }
                            row--;
                        }
                        if (row < 0) row = 0;
                        while (row < lines.length) {
                            doRows[row] = true;
                            row++;
                        }
                    } else {
                        //go to the next chunk
                        row++;
                        while (row < lines.length) {
                            if (lines[row].trim().startsWith("%%")) {
                                row--;
                                break;
                            }
                            row++;
                        }
                        if (row >= lines.length) row = lines.length - 1;
                        while (row >= 0) {
                            var line = lines[row].trim();
                            doRows[row] = true;
                            if (line.startsWith("%%")) break;
                            row--;
                        }
                    }
                }

                this.jq(ID_RUN_ICON).attr("src", icon_progress);
                await this.runInner(value, doRows, doingAll).then(r => ok = r);
                this.jq(ID_RUN_ICON).attr("src", icon_blank);
                if (!ok) {
                    this.running = false;
                    return Utils.call(callback, false);
                }
                this.outputUpdated();
            } catch (e) {
                this.jq(ID_RUN_ICON).attr("src", icon_blank);
                this.running = false;
                this.writeOutput("An error occurred:" + e.toString() + " " + (typeof e));
                console.log("error:" + e.toString());
                if (e.stack)
                    console.log(e.stack);
                return Utils.call(callback, false);
            }
            this.running = false;
            return Utils.call(callback, true);
        },
        prepareToLayout: function() {
            this.content = this.getInputText();
        },
        getInputText: function() {
            if (!this.editor) return this.content;
            return this.editor.getValue();
        },
        globalChanged: async function(name, value) {
            for(var i=0;i<this.chunks.length;i++) {
                var chunk = this.chunks[i];
                if(chunk.hasRun) continue;
                if(chunk.depends.includes(name)) {
                   var ok = true;
                   await this.runChunk(chunk,r=>ok=r);
                   if(!ok) break;
                }
            }
        },
        prepareToRun: function() {
            this.hasRun = false;
            if(this.chunks) {
                this.chunks.forEach(chunk=>chunk.hasRun = false);
            }
        },
        runInner: async function(value, doRows, doingAll) {
            value = value.trim();
            value = value.replace(/{cellname}/g, this.cellName);
            value = this.notebook.convertInput(value);
            if (!this.chunks) this.chunks = [];
            var chunks = this.chunks;
            var type = "wiki";
            var rest = "";
            var commands = value.split("\n");
            var prevChunk = null;
            var chunkCnt = 0;
            var _cell = this;
            var getChunk = (cell,type, content,  doChunk, rest) => {
                var props = Utils.parseAttributes(rest);
                props.type = type;
                props.doChunk = doChunk;
                props.content   = content;
                var chunk = (chunkCnt < chunks.length ? chunks[chunkCnt] : null);
                chunkCnt++;
                if (chunk) {
                    if (chunk.div.jq().length == 0) {
                        chunk = null;
                    } else {}
                } else {}
                if (!chunk) {
                    chunk = new NotebookChunk(cell, props);
                    chunks.push(chunk);
                    if(!chunk.skipOutput) {
                        if (prevChunk) prevChunk.div.jq().after(chunk.div.toString());
                        else cell.output.html(chunk.div.toString());
                    }
                } else {
                    chunk.initChunk(props);
                }
                prevChunk = chunk;
                chunk.div.jq().show();
                return chunk;
            };
            var content = "";
            var doChunk = true;
            for (var rowIdx = 0; rowIdx < commands.length; rowIdx++) {
                var command = commands[rowIdx];
                var _command = command.trim();
                if (_command.startsWith("//")) continue;
                if (_command.startsWith("%%")) {
                    var newRest = _command.substring(2).trim();
                    var newType;
                    var index = newRest.indexOf(" ");
                    if (index < 0) {
                        newType = newRest;
                        newRest = "";
                    } else {
                        newType = newRest.substring(0, index).trim();
                        newRest = newRest.substring(index);
                    }
                    if (content != "") {
                        getChunk(this, type, content, doChunk, rest);
                    }
                    doChunk = doRows ? doRows[rowIdx] : true;
                
                    content = "";
                    if (content != "") content += "\n";
                    if (newType != "")
                        type = newType;
                    rest = newRest;
                    continue;
                }
                content = content + command + "\n";
            }

            if (content != "") {
                getChunk(this,type, content, doChunk, rest);
            }

            this.chunkMap = {};
            for (var i = 0; i < this.chunks.length; i++) {
                var chunk = this.chunks[i];
                if (chunk.name) {
                    this.chunkMap[chunk.name] = chunk;
                }
            }
            for (var i = chunkCnt; i < this.chunks.length; i++) {
                this.chunks[i].div.jq().hide();
            }
            this.rawOutput = "";
            var ok = true;
            await this.runChunks(this.chunks, doingAll, true, r => ok = r);
            if (!ok) return false;
            await this.runChunks(this.chunks, doingAll, false, r => ok = r);
            if (!ok) return false;
            Utils.initContent("#" + this.getDomId(ID_OUTPUT));
            return true;
        },
        runChunks: async function(chunks, doingAll, justFirst, callback) {
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                var ok = true;
                if (justFirst === true && !chunk.props["runfirst"]) {
                    continue;
                }
                if (justFirst === false && chunk.props["runfirst"] === true) {
                    continue;
                }
                if (doingAll && chunk.props["skiprunall"] === true) {
                    continue;
                }
                if (!chunk.doChunk) {
                    continue;
                }
                await this.runChunk(chunk, (r => ok = r));
                if (!ok) return Utils.call(callback, false);
            }
            return Utils.call(callback, true);
        },
        runChunk: async function(chunk,   callback) {
            if (chunk.hasRun) {
                //                console.log("runChunk: chunk has run");
                return Utils.call(callback, true);
            }
            chunk.ok = true;
            chunk.div.set("");
            chunk.hasRun = true;
            for (var i = 0; i < chunk.depends.length; i++) {
                var name = chunk.depends[i];
                if (this.chunkMap[name] && !this.chunkMap[name].hasRun) {
                    var ok = true;
                    var otherChunk = this.chunkMap[name];
                    await this.runChunk(otherChunk, false, null, (r => ok = r));
                    if (!ok || !otherChunk.ok) {
                        return Utils.call(callback, false);
                    }
                }
            }
            await this.processChunk(chunk);
            if (!chunk.ok) {
                Utils.call(callback, false);
                return;
            }
            if (chunk.name && (typeof chunk.name == "string")) {
                var name = chunk.name.trim();
                if (chunk.output) {
                    if (name != "") {
                        await this.notebook.addGlobal(name, chunk.output);
                    }
                } else {
                    await this.notebook.addGlobal(name, null);
                }
            }
            return Utils.call(callback, true);
        },

        writeOutput: function(h) {
            if (!this.output) {
                err = new Error();
                console.log("no output:" + err.stack);
                return;
            }
            this.output.html(h);
            this.outputUpdated();
        },
        outputUpdated: function() {
            this.outputHtml = this.jq(ID_OUTPUT).html();
        },
        getRawOutput: function() {
            return this.rawOutput;
        },
        focus: function() {
            this.input.focus();
        },
        clearOutput: function() {
            if (this.chunks)
                this.chunks.forEach(chunk => chunk.div.set(""));
            this.outputHtml = "";
        },
        processHtml: async function(chunk) {
            var content = chunk.getContent();
            if (content.match("%\n*$")) {
                content = content.trim();
                content = content.substring(0, content.length - 1);
            }
            this.rawOutput += content + "\n";
            chunk.output = content;
            chunk.div.set(content);
        },
        processCss: async function(chunk) {
            var css = HtmlUtils.tag("style", ["type", "text/css"], chunk.getContent());
            this.rawOutput += css + "\n";
            chunk.output = css;
            chunk.div.set(css);
        },
        handleError: function(chunk, error, from) {
            chunk.ok = false;
            console.log("An error occurred:" + error);
            this.notebook.log(error, "error", from, chunk.div);
        },
        getFetchUrl: async function(url, type, callback) {
            //Check for entry id
            url = Utils.replaceRoot(url);
            if (url.match(/^[a-z0-9]+-[a-z0-9].*/)) {
                return Utils.call(callback, ramaddaBaseUrl + "/entry/get?entryid=" + url);
            } else {
                if (!url.startsWith("http")) {
                    if ((url.startsWith("/") && !url.startsWith(ramaddaBaseUrl)) || url.startsWith("..") || !url.startsWith("/")) {
                        var entry;
                        await this.getEntryFromPath(url, e => entry = e);
                        if (!entry) {
                            return Utils.call(callback, null);
                        }
                        return Utils.call(callback, ramaddaBaseUrl + "/entry/get?entryid=" + entry.getId());
                    }
                }
                return Utils.call(callback, url);
            }
        },
        processFetch: async function(chunk) {
            var lines = chunk.getContent().split("\n");
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line == "") continue;
                var origLine = line;
                var error = null;
                var msgExtra = "";
                var idx = line.indexOf(":");
                if (idx < 0) {
                    this.handleError(chunk, "Bad fetch line:" + line, "io");
                    return;
                }
                var tag = line.substring(0, idx);
                line = line.substring(idx + 1).trim();
                var idx = line.indexOf(" //");
                if (idx >= 0) {
                    line = line.substring(0, idx).trim();
                }


                var url = null;
                var variable = null;
                if (["text", "json", "blob"].includes(tag)) {
                    var args = line.match(/^([a-zA-Z0-9_]+) *= *(.*)$/);
                    if (args) {
                        variable = args[1];
                        line = args[2].trim();
                        msgExtra = " (var " + variable + ")";
                    }
                }

                await this.getFetchUrl(line, tag, u => url = u);
                if (!url) {
                    this.handleError(chunk, "Unable to get entry url:" + line, "io");
                    return;
                }

                if (tag == "js") {
                    //Don't import jquery
                    if (url.match("jquery-.*\\.js")) return;
                    await Utils.importJS(url,
                        () => {},
                        (jqxhr, settings, exception) => {
                            error = "Error fetching " + origLine + " " + (exception ? exception.toString() : "");
                        },
                        //Check the cache
                        false
                    );
                } else if (tag == "css") {
                    await Utils.importCSS(url,
                        null,
                        (jqxhr, settings, exception) => error = "Error fetching " + origLine + " " + exception, true);
                } else if (tag == "html") {
                    await Utils.doFetch(url, h => chunk.div.append(h), (jqxhr, settings, exception) => error = "Error fetching " + origLine + " " + exception);
                } else if (tag == "text" || tag == "json" || tag == "blob") {
                    var isJson = tag == "json";
                    var isBlob = tag == "blob";
                    var results = null;
                    await Utils.doFetch(url, h => results = h, (jqxhr, settings, err) => error = "Error fetching " + origLine + " error:" + (err ? err.toString() : ""), tag == "blob" ? "blob" : "text");
                    if (results) {
                        if (isJson) {
                            if (typeof results == "string")
                                results = JSON.parse(results);
                        } else if (isBlob) {
                            results = new Blob([results], {});
                        }
                        if (variable) {
                            await this.notebook.addGlobal(variable, results);
                        } else {
                            if (isJson) {
                                chunk.div.append(Utils.formatJson(results));
                            } else {
                                chunk.div.append(HtmlUtils.pre(["style", "max-width:100%;overflow-x:auto;"], results));
                            }
                        }
                    }
                } else {
                    error = "Unknown fetch:" + origLine;
                }
                if (error) {
                    this.handleError(chunk, error, "io");
                    return;
                } else {
                    this.notebook.log("Loaded: " + url + msgExtra, "output", "io");
                }
            }
        },
        processMd: async function(chunk) {
            //            await Utils.importJS(ramaddaBaseUrl + "/lib/katex/lib/katex/katex.min.css");
            //            await Utils.importJS(ramaddaBaseUrl + "/lib/katex/lib/katex/katex.min.js");

            var content = chunk.getContent();
            this.rawOutput += content + "\n";
            if (content.match("%\n*$")) {
                content = content.trim();
                content = content.substring(0, content.length - 1);
            }
            var o = "";
            var tex = null;
            var lines = content.split("\n");
            var texs = [];
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var _line = line.trim();
                if (_line.startsWith("$$")) {
                    if (tex != null) {
                        try {
                            var html = katex.renderToString(tex, {
                                throwOnError: true
                            });
                            o += "tex:" + texs.length + ":\n";
                            texs.push(html);
                        } catch (e) {
                            o += "Error parsing tex:" + e + "<pre>" + tex + "</pre>";
                        }
                        tex = null;
                    } else {
                        tex = "";
                    }
                } else if (tex != null) {
                    tex += line + "\n";
                } else {
                    o += line + "\n";
                }
            }

            var converter = new showdown.Converter();
            var html = converter.makeHtml(o);
            for (var i = 0; i < texs.length; i++) {
                html = html.replace("tex:" + i + ":", texs[i]);
            }
            var md = HtmlUtils.div(["class", "display-notebook-md"], html);
            chunk.output = html;
            chunk.div.set(md);
        },
        processPy: async function(chunk) {
            if (!this.notebook.loadedPyodide) {
                chunk.div.set("Loading Python...");
                await Utils.importJS(ramaddaBaseHtdocs + "/lib/pyodide/pyodide.js");
                await languagePluginLoader.then(() => {
                    pyodide.runPython('import sys\nsys.version;');
                    //                        pyodide.runPython('print ("hello python")');
                }, (e) => console.log("error:" + e));
                await pyodide.loadPackage(['numpy', 'cycler', 'pytz', 'matplotlib'])
                chunk.div.set("");
                this.notebook.loadedPyodide = true;
            }

            pyodide.runPython(chunk.getContent());
        },
        processPlugin: async function(chunk) {
            var plugin = JSON.parse(chunk.getContent());
            await this.notebook.addPlugin(plugin, chunk);
        },
        processWiki: async function(chunk) {
            this.rawOutput += chunk.getContent() + "\n";
            var id = this.notebook.getProperty("entryId", "");
            await this.getCurrentEntry(e => entry = e);
            if (entry) id = entry.getId();
            let _this = this;
            let divId = HtmlUtils.getUniqueId();
            var wikiCallback = function(html) {
                var h = HtmlUtils.div(["id", divId, "style"], html);
                chunk.div.set(h);
                chunk.output = h;
            }
            var wiki = "{{group showMenu=false}}\n" + chunk.getContent();
            await GuiUtils.loadHtml(ramaddaBaseUrl + "/wikify?doImports=false&entryid=" + id + "&text=" + encodeURIComponent(chunk.getContent()),
                wikiCallback);
        },
        processSh: async function(chunk) {
            var r = "";
            var lines = chunk.getContent().split("\n");
            var commands = [];
            for (var i = 0; i < lines.length; i++) {
                var fullLine = lines[i].trim();
                if (fullLine == "") continue;
                var cmds = fullLine.split(";");
                for (var cmdIdx = 0; cmdIdx < cmds.length; cmdIdx++) {
                    var line = cmds[cmdIdx].trim();
                    if (line == "" || line.startsWith("#") || line.startsWith("//")) continue;
                    var toks = line.split(" ");

                    var command = toks[0].trim();
                    var proc = null;
                    var extra = null;
                    if (this["processCommand_" + command]) {
                        proc = this["processCommand_" + command];
                    } else {
                        proc = this.processCommand_help;
                        extra = "Unknown command: <i>" + command + "</i>";
                    }
                    var div = new Div("");
                    commands.push({
                        proc: proc,
                        line: line,
                        toks: toks,
                        extra: extra,
                        div: div
                    });
                    r += div.set("");
                }
            }
            let _this = this;
            chunk.div.set(r);
            var i = 0;
            for (i = 0; i < commands.length; i++) {
                var cmd = commands[i];
                if (cmd.extra) {
                    cmd.div.append(extra);
                }
                await cmd.proc.call(_this, cmd.line, cmd.toks, cmd.div, cmd.extra);
            }
        },
        processJs: async function(chunk,state) {
            var lines;
            var topLines = 0;
            await this.getCurrentEntry(e => {
                    current = e
                });
            if(!notebookStates[state.id]) {
                throw new Error("Null NB:" + state.id);
            }
            try {
                var notebookEntries = this.notebook.getCurrentEntries();
                for (name in notebookEntries) {
                    state.entries[name] = notebookEntries[name].entry;
                }
                var jsSet = "";
                state.entries["current"] = current;
                state.entries["parent"] = this.parentEntry;
                state.entries["base"] = this.notebook.getBaseEntry();
                state.entries["root"] = this.notebook.getRootEntry();

                var stateJS = "notebookStates['" + state.id + "']";
                topLines++;
                jsSet += "var notebook= " + stateJS + ";\n";
                topLines++;
                for (name in state.entries) {
                    var e = state.entries[name];
                    topLines++;
                    jsSet += "var " + name + "= notebook.entries['" + name + "'];\n"
                }
                for (name in this.notebook.cellValues) {
                    var clean = name.replace(/ /g, "_").replace(/[^a-zA-Z0-9_]+/g, "_");
                    topLines++;
                    jsSet += "var " + clean + "= notebook.getNotebook().cellValues['" + name + "'];\n";
                }
                for (name in this.notebook.globals) {
                    name = name.trim();
                    if (name == "") continue;
                    //                    if (!Utils.isDefined(window[name])) {
                        topLines++;
                        jsSet += "var " + name + "= notebook.getNotebook().getGlobalValue('" + name + "');\n";
                        //                    }
                }
                var js = chunk.getContent().trim();
                lines = js.split("\n");
                js = jsSet + "\n" + js;
                var result = eval.call(null, js);
                if (state.getStop()) {
                    chunk.ok = false;
                }
                var html = "";
                if (result != null) {
                    chunk.output = result;
                    var rendered = this.notebook.formatOutput(result);
                    if (rendered != null) {
                        html = rendered;
                        this.rawOutput += html + "\n";
                    } else {
                        var type = typeof result;
                        if (type != "object" && type != "function") {
                            html = result;
                            this.rawOutput += html + "\n";
                        }
                    }
                }
                chunk.div.append(html);
            } catch (e) {
                chunk.ok = false;
                var line = lines[e.lineNumber - topLines - 1];
                console.log("Error:" + e.stack);
                this.notebook.log("Error: " + e.message + "<br>&gt;" + (line ? line : ""), "error", "js", chunk.div);
            }
        },
        processChunk: async function(chunk) {
            var state = new NotebookState(this, chunk.div);
            window.notebook = state;
            notebookStates[state.id] = state;
            if (chunk.type == "html") {
                await this.processHtml(chunk, state);
            } else if (chunk.type == "plugin") {
                await this.processPlugin(chunk,state);
            } else if (chunk.type == "wiki") {
                await this.processWiki(chunk,state);
            } else if (chunk.type == "css") {
                await this.processCss(chunk,state);
            } else if (chunk.type == "fetch") {
                await this.processFetch(chunk,state);
            } else if (chunk.type == "raw") {
                var content = chunk.getContent();
                chunk.output = content;
                this.rawOutput += content;
            } else if (chunk.type == "js") {
                await this.processJs(chunk,state);
            } else if (chunk.type == "sh") {
                await this.processSh(chunk,state);
            } else if (chunk.type == "meta") {
                //noop
            } else if (chunk.type == "md") {
                await this.processMd(chunk,state);
            } else if (chunk.type == "py") {
                await this.processPy(chunk,state);
            } else {
                var hasPlugin;
                await this.notebook.hasPlugin(chunk.type, p => hasPlugin = p);
                if (hasPlugin) {
                    chunk.div.set("");
                    var result;
                    await this.notebook.processChunkWithPlugin(chunk.type, chunk, r => result = r);
                    //TODO: what to do with the result
                    if (result) {
                        this.notebook.processPluginOutput(chunk.type, chunk, result);
                    }
                    return;
                }
                this.notebook.log("Unknown type:" + chunk.type, "error", null, chunk.div);
                chunk.ok = false;
            }
            delete  notebookStates[state.id];
            if (state.getStop()) {
                chunk.ok = false;
            }

        },



        calculateInputHeight: function() {
            this.content = this.getInputText();
            if (!this.content) return;
            var lines = this.content.split("\n");
            if (lines.length != this.inputRows) {
                this.inputRows = lines.length;
                this.input.attr("rows", Math.max(1, this.inputRows));
            }
        },

        writeStatusMessage: function(v) {
            var msg = this.jq(ID_MESSAGE);
            if (!v) {
                msg.hide();
                msg.html("");
            } else {
                msg.show();
                msg.position({
                    of: this.getOutput(),
                    my: "left top",
                    at: "left+4 top+4",
                    collision: "none none"
                });
                msg.html(v);
            }
        },
        handleControlKey: function(event) {
            var k = event.which;
        },
        getOutput: function() {
            return this.jq(ID_OUTPUT);
        },
        getInput: function() {
            return this.jq(ID_INPUT);
        },
        writeResult: function(html) {
            this.writeStatusMessage(null);
            html = HtmlUtils.div([ATTR_CLASS, "display-notebook-result"], html);
            var output = this.jq(ID_OUTPUT);
            output.append(html);
            output.animate({
                scrollTop: output.prop("scrollHeight")
            }, 1000);
            this.currentOutput = output.html();
            this.currentInput = this.getInputText();
        },
        writeError: function(msg) {
            this.writeStatusMessage(msg);
            //                this.writeResult(msg);
        },
        header: function(msg) {
            return HtmlUtils.div([ATTR_CLASS, "display-notebook-header"], msg);
        },
        processCommand_help: function(line, toks, div, callback, prefix) {
            if (div == null) div = new Div();
            var help = "";
            if (prefix != null) help += prefix;
            help += "<pre>pwd, ls, cd</pre>";
            return div.append(help);
        },
        entries: {},

        selectEntry: function(entryId) {
            var cnt = 1;
            var entries = this.notebook.getCurrentEntries();
            while (entries["entry" + cnt]) {
                cnt++;
            }
            var id = prompt("Set an ID", "entry" + cnt);
            if (id == null || id.trim() == "") return;
            this.notebook.addEntry(id, entryId);
        },
        setId: function(entryId) {
            var cursor = this.editor.getCursorPosition();
            this.editor.insert(entryId);
            //            this.editor.selection.moveTo(cursor.row, cursor.column);
            //            this.editor.focus();
        },
        cdEntry: function(entryId) {
            var div = new Div("");
            this.currentEntry = this.entries[entryId];
            notebookState.entries["current"] = this.currentEntry;
            this.output.html(div.toString());
            this.processCommand_pwd("pwd", [], div);
            this.outputUpdated();
        },
        addToToolbar: function(id, entry, toolbarItems) {
            var call = "getHandler('" + id + "').setId('" + entry.getId() + "')";
            var icon = HtmlUtils.image(ramaddaBaseUrl + "/icons/setid.png", ["border", 0, ATTR_TITLE, "Set ID in Input"]);
            toolbarItems.unshift(HtmlUtils.tag(TAG_A, ["onclick", call], icon));
            var call = "getHandler('" + id + "').selectEntry('" + entry.getId() + "')";
            var icon = HtmlUtils.image(ramaddaBaseUrl + "/icons/circle-check.png", ["border", 0, ATTR_TITLE, "Select Entry"]);
            toolbarItems.unshift(HtmlUtils.tag(TAG_A, ["onclick", call], icon));
        },
        getEntryPrefix: function(id, entry) {
            this.entries[entry.getId()] = entry;
            var call = "getHandler('" + id + "').cdEntry('" + entry.getId() + "')";
            return HtmlUtils.div(["style", "padding-right:4px;", "title", "cd to entry", "onclick", call, "class", "ramadda-link"], HtmlUtils.image(ramaddaBaseUrl + "/icons/go.png"));
        },
        displayEntries: function(entries, div) {
            if (div == null) div = new Div();
            this.currentEntries = entries;
            if (entries == null || entries.length == 0) {
                return div.msg("No children");
            }
            var handlerId = addHandler(this);
            var html = this.notebook.getEntriesTree(entries, {
                handlerId: handlerId,
                showIndex: false,
                suffix: Utils.getUniqueId("_shell_")
            });
            div.set(HtmlUtils.div(["style", "max-height:200px;overflow-y:auto;"], html));
            this.outputUpdated();
        },
        getEntryFromArgs: function(args, dflt) {
            var currentEntries = this.currentEntries;
            if (currentEntries == null) {
                return dflt;
            }
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (arg.match("^\d+$")) {
                    var index = parseInt(arg);
                    break;
                }
                if (arg == "-entry") {
                    i++;
                    var index = parseInt(args[i]) - 1;
                    if (index < 0 || index >= currentEntries) {
                        this.writeError("Bad entry index:" + index + " should be between 1 and " + currentEntries.length);
                        return;
                    }
                    return currentEntries[index];
                }
            }
            return dflt;
        },
        setCurrentEntry: async function(entry) {
            this.currentEntry = entry;
            this.parentEntry = null;
            if (this.currentEntry)
                await this.currentEntry.getParentEntry(entry => {
                    this.parentEntry = entry;
                });
        },
        getCurrentEntry: async function(callback) {
            if (this.currentEntry == null) {
                await this.setCurrentEntry(this.notebook.getBaseEntry());
            }
            if (this.currentEntry == null) {
                if (Utils.isDefined(dflt)) return dflt;
                this.rootEntry = new Entry({
                    id: ramaddaBaseEntry,
                    name: "Root",
                    type: "group"
                });
                this.currentEntry = this.rootEntry;
            }
            return Utils.call(callback, this.currentEntry);
        },
        createDisplay: async function(state, entry, displayType, displayProps) {
            if (!entry) await this.getCurrentEntry(e => entry = e);
            if ((typeof entry) == "string") {
                await this.notebook.getEntry(entry, e => entry = e);
            }

            if (!state.displayManager) {
                var divId = HtmlUtils.getUniqueId();
                state.div.append(HtmlUtils.div(["id", divId], ""));
                state.displayManager = new DisplayManager(divId, {
                    "showMap": false,
                    "showMenu": false,
                    "showTitle": false,
                    "layoutType": "table",
                    "layoutColumns": 1,
                    "defaultMapLayer": "osm",
                    "entryId": ""
                });
            }

            var divId = HtmlUtils.getUniqueId();
            state.div.append(HtmlUtils.div(["id", divId], "DIV"));
            var props = {
                layoutHere: true,
                divid: divId,
                showMenu: true,
                sourceEntry: entry,
                entryId: entry.getId(),
                showTitle: true,
                showDetails: true,
                title: entry.getName(),
            };

            if (displayProps) {
                $.extend(props, displayProps);
            }
            if (!props.data && displayType != DISPLAY_ENTRYLIST) {
                var jsonUrl = this.notebook.getPointUrl(entry);
                if (jsonUrl == null) {
                    this.writeError("Not a point type:" + entry.getName());
                    return;
                }
                if (jsonUrl == null) {
                    jsonUrl = this.getPointUrl(entry);
                }
                var pointDataProps = {
                    entry: entry,
                    entryId: entry.getId()
                };
                props.data = new PointData(entry.getName(), null, null, jsonUrl, pointDataProps);
            }
            state.displayManager.createDisplay(displayType, props);
        },
        createPointDisplay: async function(toks, displayType) {
            await this.getCurrentEntry(e => current = e);
            var entry = this.getEntryFromArgs(toks, currentEntry);
            var jsonUrl = this.notebook.getPointUrl(entry);
            if (jsonUrl == null) {
                this.writeError("Not a point type:" + entry.getName());
                return;
            }
            this.notebook.createDisplay(entry.getId(), displayType, jsonUrl);
        },
        processCommand_table: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_TABLE);
        },
        processCommand_linechart: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_LINECHART);
        },

        processCommand_barchart: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_BARCHART);
        },
        processCommand_bartable: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_BARTABLE);
        },
        processCommand_hello: function(line, toks) {
            this.writeResult("Hello, how are you?");
        },
        processCommand_scatterplot: function(line, toks) {
            this.createPointDisplay(toks, DISPLAY_SCATTERPLOT)
        },
        processCommand_blog: function(line, toks) {
            this.getLayoutManager().publish('blogentry');
        },
        getEntryHeading: function(entry, div) {
            var entries = [entry];
            var handlerId = addHandler(this);
            var html = this.notebook.getEntriesTree(entries, {
                handlerId: handlerId,
                showIndex: false,
                suffix: Utils.getUniqueId("_shell_")
            });
            div.set(HtmlUtils.div(["style", "max-height:200px;overflow-y:auto;"], html));
            return div;
            //            var icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
            //            return "&gt; "+ icon +" " +entry.getName();
        },
        processCommand_pwd: async function(line, toks, div) {
            if (div == null) div = new Div();
            await this.getCurrentEntry(e => entry = e);
            return this.getEntryHeading(entry, div);
        },
        processCommand_set: async function(line, toks, div) {
            if (div == null) div = new Div();
            if (toks.length < 2) {
                div.append("Error: usage: set &lt;name&gt; &lt;value&gt;");
                return;
            }
            var name = toks[1];
            if (toks.length == 2) {
                var v = this.notebook.getGlobalValue(name);
                if (v) {
                    div.append(v);
                } else {
                    div.append("Unknown: " + name);
                }
            } else {
                var v = Utils.join(toks, " ", 2);
                v = v.replace(/\"/g, "");
                await this.notebook.addGlobal(name, v);
            }
        },
        processCommand_clearEntries: function(line, toks, div) {
            this.notebook.clearEntries();
            div.set("Entries cleared");
        },
        processCommand_printEntries: async function(line, toks, div) {
            var h = "";
            await this.getCurrentEntry(e => current = e);
            h += "current" + "=" + current.getName() + "<br>";
            var entries = this.notebook.getCurrentEntries();
            for (var name in entries) {
                var e = entries[name];
                h += name + "=" + e.entry.getName() + "<br>";
            }
            if (h == "") h = "No entries";
            div.set(h);
        },
        processCommand_echo: async function(line, toks, div) {
            line = line.replace(/^echo */, "");
            div.set(line);
        },
        processCommand_print: async function(line, toks, div) {
            line = line.replace(/^print */, "");
            div.set(line);
        },

        processCommand_info: async function(line, toks, div) {
            await this.getCurrentEntry(e => entry = e);
            div.append("current:" + entry.getName() + " id:" + entry.getId() + "<br>");
        },

        processCommand_cd: async function(line, toks, div) {
            if (div == null) div = new Div();
            if (toks.length <= 1) {
                await this.setCurrentEntry(this.notebook.getBaseEntry());
                return;
                //                return this.getEntryHeading(this.currentEntry, div);
            }
            var arg = Utils.join(toks, " ", 1).trim();
            var entry;
            await this.getEntryFromPath(arg, e => entry = e);
            if (!entry) {
                div.msg("Could not get entry:" + arg);
                return;
            }
            await this.setCurrentEntry(entry);
        },
        getEntryFromPath: async function(arg, callback) {
            var entry;
            await this.getCurrentEntry(e => entry = e);
            if (arg.startsWith("/")) {
                await entry.getRoot(e => {
                    entry = e
                });
            }
            var dirs = arg.split("/");
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                if (dir == "") continue;
                if (dir == "..") {
                    await entry.getParentEntry(e => {
                        entry = e
                    });
                    if (!entry) {
                        break;
                    }
                } else {
                    await entry.getChildrenEntries(c => children = c);
                    var child = null;
                    var startsWith = false;
                    var endsWith = false;
                    if (dir.endsWith("*")) {
                        dir = dir.substring(0, dir.length - 1);
                        startsWith = true;
                    }
                    if (dir.startsWith("*")) {
                        dir = dir.substring(1);
                        endsWith = true;
                    }
                    for (var childIdx = 0; childIdx < children.length; childIdx++) {
                        var name = children[childIdx].getName();
                        if (startsWith && endsWith) {
                            if (name.includes(dir)) {
                                child = children[childIdx];
                                break;
                            }
                        } else if (startsWith) {
                            if (name.startsWith(dir)) {
                                child = children[childIdx];
                                break;
                            }
                        } else if (endsWith) {
                            if (name.endsWith(dir)) {
                                child = children[childIdx];
                                break;
                            }
                        }
                        if (children[childIdx].getName() == dir) {
                            child = children[childIdx];
                            break;
                        }
                    }
                    if (!child) {
                        break;
                    }
                    entry = child;
                }
            }
            return Utils.call(callback, entry);
        },


        processCommand_ls: async function(line, toks, div) {
            if (div == null) div = new Div();
            div.set("Listing entries...");
            await this.getCurrentEntry(e => entry = e);
            await entry.getChildrenEntries(children => {
                this.displayEntries(children, div)
            }, "");
        },
        entryListChanged: function(entryList) {
            var entries = entryList.getEntries();
            if (entries.length == 0) {
                this.writeStatusMessage("Sorry, nothing found");
            } else {
                this.displayEntries(entries);
            }
        },
        processCommand_search: async function(line, toks, div) {
            var text = "";
            for (var i = 1; i < toks.length; i++) text += toks[i] + " ";
            text = text.trim();
            var settings = new EntrySearchSettings({
                text: text,
            });
            var jsonUrl = this.notebook.getRamadda().getSearchUrl(settings, OUTPUT_JSON);
            let _this = this;
            var myCallback = {
                entryListChanged: function(list) {
                    var entries = list.getEntries();
                    div.set("");
                    if (entries.length == 0) {
                        div.append("Nothing found");
                    } else {
                        _this.displayEntries(entries, div)
                    }
                }
            };
            var entryList = new EntryList(this.notebook.getRamadda(), jsonUrl, myCallback, false);
            div.set("Searching...");
            await entryList.doSearch();
        },
        processCommand_clear: function(line, toks, div) {
            this.clearOutput();
        },
        processCommand_save: function(line, toks, div) {
            this.notebook.saveNotebook();
        },

    });

}


function processLispOutput(r) {
    if (r && r.val) return r.val;
    return Utils.formatJson(r);
}




function NotebookChunk(cell, props) {
    for(name in props)
        props[name.toLowerCase()] = props[name];
    this.div =  new Div(null, "display-notebook-chunk");
    this.cell = cell;
    $.extend(this, {
            getContent: function() {
                var content = this.content;
                for (name in this.cell.notebook.globals) {
                    var value = this.cell.notebook.getGlobalValue(name);
                    if (typeof value == "object") {
                        value = Utils.formatJson(value);
                    }
                    content = content.replace("${" + name.trim() + "}", value);
                }
                return content;
            },
           initChunk: function(props) {
                this.skipOutput = false;
                if (props["skipoutput"] === true) {
                    this.skipOutput = true;
                    this.div.set("");
                    this.div = new Div();
                }
                var depends = [];
                if (props["depends"] && typeof props["depends"] == "string") depends = props["depends"].split(",");
                var content = props.content||"";
                var regexp = RegExp(/\${([^ }]+)}/g);
                while((result = regexp.exec(content)) !== null) {
                    var param = result[1];
                    if(!depends.includes(param)) depends.push(param);
                }
                $.extend(this, {
                        name: props["name"],
                            depends: depends,
                            output: null,
                            runFirst: props["runFirst"],
                            hasRun: false,
                            content: content,
                            type: props.type,
                            props: props,
                            doChunk: !!props.doChunk,
                            ok: true
                            });
            }
        });
    this.initChunk(props);
}
/**
   Copyright 2008-2019 Geode Systems LLC
*/


//Note: I put all of the chart definitions together at the top so one can see everything that is available here
const DISPLAY_D3_GLIDER_CROSS_SECTION = "GliderCrossSection";
//const DISPLAY_D3_PROFILE = "profile";
const DISPLAY_D3_LINECHART = "D3LineChart";
const DISPLAY_SKEWT = "skewt";
const DISPLAY_VENN = "venn";
const DISPLAY_CHERNOFF = "chernoff";
const DISPLAY_D3BUBBLE = "d3bubble";
const DISPLAY_MINIDOTS = "minidots";

//Note: Added requiresData and category
addGlobalDisplayType({
    type: DISPLAY_D3_LINECHART,
    forUser: false,
    label: "D3 LineChart",
    requiresData: true,
    category: "Charts"
});
/*
addGlobalDisplayType({
    type: DISPLAY_D3_PROFILE,
    forUser: false,
    label: "Profile",
    requiresData: true,
    category: "Charts"
});
*/
addGlobalDisplayType({
    type: DISPLAY_D3_GLIDER_CROSS_SECTION,
    forUser: false,
    label: "Glider cross section",
    requiresData: true,
    category: CATEGORY_MISC
});


addGlobalDisplayType({
    type: DISPLAY_VENN,
    forUser: true,
    label: "Venn Diagram",
    requiresData: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("A Venn diagram","venn.png")    
});

addGlobalDisplayType({
    type: DISPLAY_MINIDOTS,
    forUser: false,
    label: "Mini Dots",
    requiresData: true,
    category: CATEGORY_MISC
});

addGlobalDisplayType({
    type: DISPLAY_CHERNOFF,
    forUser: false,
    label: "Chernoff Faces",
    requiresData: true,
    category: CATEGORY_MISC
});

addGlobalDisplayType({
    type: DISPLAY_D3BUBBLE,
    forUser: true,
    label: "Bubble Chart",
    requiresData: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Animated bubbles showing images","d3bubble.png"),            
});


addGlobalDisplayType({
    type: DISPLAY_SKEWT,
    forUser: false,
    label: "SkewT",
    requiresData: true,
    category: CATEGORY_MISC
});

//Note: define meaningful things as variables not as string literals
const FIELD_TIME = "time";
const FIELD_DEPTH = "depth";
const FIELD_VALUE = "value";
const FIELD_SELECTEDFIELD = "selectedfield";

const TYPE_LATITUDE = "latitude";
const TYPE_LONGITUDE = "longitude";
const TYPE_TIME = "time";
const TYPE_VALUE = "value";
const TYPE_ELEVATION = "elevation";


const FUNC_MOVINGAVERAGE = "movingAverage";

const D3Util = {
    foo: "bar",
    getAxis: function(axisType, range) {
        var axis;
        if (axisType == FIELD_TIME) {
            axis = d3.time.scale().range(range);
        } else {
            axis = d3.scale.linear().range(range);
        }
        return axis;
    },
    getDataValue: function(axis, record, index) {
        var data;
        if (axis.fieldIdx >= 0) {
            data = record.getData()[axis.fieldIdx];
        } else {
            switch (axis.type) {
            case TYPE_TIME:
                data = new Date(record.getDate());
                break;
            case TYPE_ELEVATION:
                //console.log(record.getElevation());
                data = record.getElevation();
                break;
            case TYPE_LATITUDE:
                data = record.getLatitude();
            case TYPE_LONGITUDE:
                data = record.getLongitude();
            default:
                data = record.getData()[index];
            }
        }


        if (axis.reverse == true) {
            return -1 * data;
        } else {
            return data;
        }
    },
    // This will be the default but we can add more colorscales
    getColorFromColorBar: function(value, range) {
        var colors = ["#00008B", "#0000CD", "#0000FF", "#00FFFF", "#7CFC00", "#FFFF00", "#FFA500", "#FF4500", "#FF0000", "#8B0000"];
        var colorScale = d3.scale.linear()
            .domain([0, colors.length - 1])
            .range(range);

        var colorScaler = d3.scale.linear()
            .range(colors)
            .domain(d3.range(0, colors.length).map(colorScale));

        color = colorScaler(value);
        return color;
    },
    // This is for the path lines the previous function for generic ones. 
    addColorBar: function(svg, colors, colorSpacing, displayWidth) {
        //Note: this originally had this.displayWidth which was undefined
        var colorBar = svg.append("g")
            .attr({
                "id": "colorBarG",
                "transform": "translate(" + (displayWidth - 40) + ",0)"
            });

        colorBar.append("g")
            .append("defs")
            .append("linearGradient")
            .attr({
                id: "colorBarGradient",
                x1: "0%",
                y1: "100%",
                x2: "0%",
                y2: "0%"
            })
            .selectAll("stop")
            .data(colors)
            .enter()
            .append("stop")
            .attr({
                "offset": function(d, i) {
                    return colorSpacing * (i) + "%"
                },
                "stop-color": function(d, i) {
                    return colors[i]
                },
                "stop-opacity": 1
            });

        return colorBar;
    }
}


function RamaddaSkewtDisplay(displayManager, id, properties) {
    const ID_SKEWT = "skewt";
    const ID_DATE_LABEL = "skewtdate";
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_SKEWT, properties);
    let myProps = [
        {label:'Skewt Attributes'},
        {p:'skewtWidth',ex:'500'},
        {p:'skewtHeight',ex:'550'},
        {p:'hodographWidth',ex:'150'},
        {p:'showHodograph',ex:'false'},
        {p:'windStride',ex:'1'},
        {p:'showText',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        initDisplay:  function() {
            SUPER.initDisplay.call(this);
        },
        handleEventPointDataLoaded: function(source, pointData) {
            //TODO: this results in a double  call to updateUI when first created
            this.updateUI();
        },
        updateUI: async function() {
//          console.log("skewt.updateui");
            if(!this.loadedResources) {
                var time = new Date();
                await Utils.importCSS(ramaddaBaseUrl +"/htdocs_v_" + time.getTime()+"/lib/skewt/sounding.css");
                //            await Utils.importCSS(ramaddaBaseHtdocs+"/lib/skewt/sounding.css");
                //            await Utils.importJS(ramaddaBaseHtdocs +"/lib/skewt/d3skewt.js");
                await Utils.importJS(ramaddaBaseUrl +"/htdocs_v_" + time.getTime()+"/lib/skewt/d3skewt.js");
                this.loadedResources = true;
            }

            if(!window["D3Skewt"]) {
                setTimeout(()=>this.updateUI(),100);
                return;
            }
            SUPER.updateUI.call(this);

//          console.log("skewt.updateui-1");
            let records =  this.filterData();
            if (!records || records.length==0) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
//          console.log("skewt.updateui-2");

            let skewtId = this.getDomId(ID_SKEWT);
            let html = HtmlUtils.div(["id", skewtId], "");
            this.setContents(html);
            var date = records[0].getDate();
            if(this.jq(ID_DATE_LABEL).length==0) {
                this.jq(ID_TOP_LEFT).append(HtmlUtils.div([ID,this.getDomId(ID_DATE_LABEL)]));
            }
            if(date!=null) {
                this.jq(ID_DATE_LABEL).html("Date: " + this.formatDate(date));
            } else {
                this.jq(ID_DATE_LABEL).html("");
            }
            var options = {};
            if (this.propertyDefined("showHodograph"))
                options.showHodograph = this.getProperty("showHodograph", true);
            if (this.propertyDefined("showText"))
                options.showText = this.getProperty("showText", true);
            if (this.propertyDefined("skewtWidth"))
                options.skewtWidth = parseInt(this.getProperty("skewtWidth"));
            if (this.propertyDefined("skewtHeight"))
                options.skewtHeight = parseInt(this.getProperty("skewtHeight"));
            if (this.propertyDefined("hodographWidth")){
                options.hodographWidth = parseInt(this.getProperty("hodographWidth"));
            }
            if (this.propertyDefined("windStride")){
                options.windStride = parseInt(this.getProperty("windStride"));
            }
            options.showText = this.getProperty("showText",true);
            //            options.hodographWidth = 200;
            var fields = this.getData().getRecordFields();
            var names = [
                {id:"pressure",aliases:["vertCoord"]},
                {id:"height",aliases:["Geopotential_height_isobaric"]},
                {id:"temperature",aliases:["Temperature_isobaric"]},
                {id:"dewpoint",aliases:[]},
                {id:"rh",aliases:["Relative_humidity_isobaric","relative_humidity"]},
                {id:"wind_direction",aliases:[]},
                {id:"wind_speed",aliases:[]},
                {id:"uwind",aliases:["u-component_of_wind_isobaric","u"]},
                {id:"vwind",aliases:["v-component_of_wind_isobaric","v"]},
            ];
            //TODO: check for units
            var data ={};
            var dataFields ={};
            for(var i=0;i<names.length;i++) {
                var obj = names[i];
                var id = obj.id;
                var field = this.getFieldById(fields,id);
                if(field == null) {
                    for(var j=0;j<obj.aliases.length;j++) {
                        field = this.getFieldById(fields,obj.aliases[j]);
                        if(field) break;
                    }
                }
                if(field) {
                    data[id] = this.getColumnValues(records, field).values;
                    dataFields[id]=field;
                }
            }

            if(!data.pressure) {
                this.displayError("No pressure defined in data");
                return;
            }

            if(!data.temperature) {
                this.displayError("No temperature defined in data");
                return;
            }

            if(!data.height) {
                var pressures = [
                    1013.25, 954.61, 898.76, 845.59, 795.01, 746.91, 701.21,
                    657.80, 616.6, 577.52, 540.48, 505.39, 472.17, 440.75,
                    411.05, 382.99, 356.51, 331.54, 303.00, 285.85, 264.99,
                    226.99, 193.99, 165.79, 141.70, 121.11, 103.52, 88.497,
                    75.652, 64.674, 55.293, 25.492, 11.970, 5.746, 2.871,
                    1.491, 0.798, 0.220, 0.052, 0.010,];
                var alts = [
                    0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000,
                    5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000,
                    11000, 12000, 13000, 14000, 15000, 16000, 17000, 18000, 19000,
                    20000, 25000, 30000, 35000, 40000, 45000, 50000, 60000, 70000,
                    80000,
                ];
                
                data.height = [];
                for(var i=0;i<data.pressure.length;i++) {
                    var pressure = data.pressure[i];
                    var alt = alts[alts.length-1];
                    for(var j=0;j<pressures.length;j++) {
                        if(pressure>=pressures[j]) {
                            if(j==0) alt = 0;
                            else {
                                var p1 = pressures[j-1];
                                var p2 = pressures[j];
                                var a1 = alts[j-1];
                                var a2 = alts[j];
                                var percent = 1-(pressure-p2)/(p1-p2);
                                alt = (a2-a1)*percent+a1;
                            }
                            break;
                        }
                    }
                    data.height.push(alt);
                }
            }


            if(!data.dewpoint) {
                if(!data.rh) {
                    this.displayError("No dewpoint or rh");
                    return;
                }
                data.dewpoint = [];
                for(var i=0;i<data.rh.length;i++) {
                    var rh=data.rh[i];
                    var t=data.temperature[i];
                    var dp = t-(100-rh)/5;
                    data.dewpoint.push(dp);
                }
            }


            if(!data.wind_speed) {
                if(!data.uwind || !data.vwind) {
                    this.displayError("No wind speed defined in data");
                    return;
                }
                data.wind_speed = [];
                data.wind_direction = [];
                for(var i=0;i<data.uwind.length;i++) {
                    var u = data.uwind[i];
                    var v = data.vwind[i];
                    var ws = Math.sqrt(u*u+v*v);
                    var wdir = 180+(180/Math.PI)*Math.atan2(v,u);
                    data.wind_speed.push(ws);
                    data.wind_direction.push(wdir);
                }
            }

            var alldata = data;
            data = {};
            //if any missing then don't include
            for(a  in alldata) data[a] = [];
            alldata[names[0].id].map((v,idx)=>{
                var ok = true;
                for(id in alldata) {
                    if(isNaN(alldata[id][idx])) {
                        ok = false;
                        break;
                    }
                }
                if(ok) {
                    for(id in alldata) {
                        data[id].push(alldata[id][idx]);
                    }
                }
            });


            if(data.height.length>1) {
                if(data.height[0]>data.height[1]) {
                    for(name in data)
                        data[name] = Utils.reverseArray(data[name]);
                }
            }
            if(data.temperature.length==0) {
                this.displayError(this.getNoDataMessage());
                return;
            }

            /*
            if(options.windStride > 1) {
                
                var new_wind_speed = [];
                var new_wind_direction = [];
                for (var i = 0; i<data.wind_speed.length; i++) {
		    var pres = data.pressure[i];
                    if (i%options.windStride == 0) {
                        new_wind_speed.push(data.wind_speed[i]);
                        new_wind_direction.push(data.wind_direction[i]);
                    } else {
                        new_wind_speed.push(0);
                        new_wind_direction.push(0);
		    }
                }
                data.wind_speed = new_wind_speed;
                data.wind_direction = new_wind_direction;
            }
            */


            options.myid = this.getId();
            try {
                this.skewt = new D3Skewt(skewtId, options,data);
            } catch(e) {
                this.displayError("An error occurred: " +e);
                console.log("error:" + e.stack);
                return;
            }
            await this.getDisplayEntry((e)=>{
		if(!e) return;
                var q= e.getAttribute("variables");
                if(!q) return;
                q = q.value;
                q = q.replace(/\r\n/g,"\n");
                q = q.replace(/^ *\n/,"");
                q = q.replace(/^ *([^:]+):([^\n].*)$/gm,"<div title='$1' class=display-skewt-index-label>$1</div>: <div title='$2'  class=display-skewt-index>$2</div>");
                q = q.replace(/[[\r\n]/g,"\n");
                q = HtmlUtils.div(["class", "display-skewt-text"],q);
                $("#" + this.skewt.textBoxId).html(q);
            });
        }
    });
}


function RamaddaD3Display(displayManager, id, properties) {
    const ID_SVG = "svg";
    const SUPER = new RamaddaDisplay(displayManager, id, "d3", properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        initDisplay: function() {
            this.createUI();
            this.setDisplayTitle(properties.graph.title);

            //Note: use innerHeight/innerWidth wiki attributes
            var width = this.getProperty("innerWidth", 600);
            var height = this.getProperty("innerHeight", 300);
            var margin = {
                top: 20,
                right: 50,
                bottom: 30,
                left: 50
            };
            var divStyle =
                "height:" + height + "px;" +
                "width:" + width + "px;";
            var html = HtmlUtils.div([ATTR_ID, this.getDomId(ID_SVG), ATTR_STYLE, divStyle], "");
            this.setContents(html);

            // To create dynamic size of the div
            this.displayHeight = parseInt((d3.select("#" + this.getDomId(ID_SVG)).style("height")).split("px")[0]) - margin.top - margin.bottom; //this.getProperty("height",300);//d3.select("#"+this.getDomId(ID_SVG)).style("height");//
            this.displayWidth = parseInt((d3.select("#" + this.getDomId(ID_SVG)).style("width")).split("px")[0]) - margin.left - margin.right; //this.getProperty("width",600);//d3.select("#"+this.getDomId(ID_SVG)).style("width");//

            //                console.log("WxH:" + this.displayHeight +" " + this.displayWidth);

            // To solve the problem with the classess within the class
            var myThis = this;
            var zoom = d3.behavior.zoom()
                .on("zoom", function() {
                    myThis.zoomBehaviour()
                });
            this.zoom = zoom;
            this.svg = d3.select("#" + this.getDomId(ID_SVG)).append("svg")
                .attr("width", this.displayWidth + margin.left + margin.right)
                .attr("height", this.displayHeight + margin.top + margin.bottom)
                .attr(ATTR_CLASS, "D3graph")
                .call(zoom)
                .on("click", function() {
                    myThis.click(d3.event)
                })
                .on("dblclick", function() {
                    myThis.dbclick(d3.event)
                })
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Define the Axis
            // 100 pixels for the legend... lets see if we keep it
            this.x = D3Util.getAxis(properties.graph.axis.x.type, [0, this.displayWidth - 100]);
            this.y = D3Util.getAxis(properties.graph.axis.y.type, [this.displayHeight, 0]);

            this.xAxis = d3.svg.axis()
                .scale(this.x)
                .orient("bottom");

            this.yAxis = d3.svg.axis()
                .scale(this.y)
                .orient("left");

            // Add Axis to the plot
            this.svg.append("g")
                .attr(ATTR_CLASS, "x axis")
                .attr("transform", "translate(0," + this.displayHeight + ")")
                .call(this.xAxis);

            this.svg.append("g")
                .attr(ATTR_CLASS, "y axis")
                .call(this.yAxis);


            // Color Bar
            var colors = ["#00008B", "#0000CD", "#0000FF", "#00FFFF", "#7CFC00", "#FFFF00", "#FFA500", "#FF4500", "#FF0000", "#8B0000"];

            var colorSpacing = 100 / (colors.length - 1);

            var colorBar = D3Util.addColorBar(this.svg, colors, colorSpacing, this.displayWidth);
            this.color = d3.scale.category10();
            this.updateUI();
        },
        needsData: function() {
            return true;
        },
        initDialog: function() {
            this.addFieldsCheckboxes();
        },
        getDialogContents: function() {
            var height = this.getProperty(PROP_HEIGHT, "400");
            var html = HtmlUtils.div([ATTR_ID, this.getDomId(ID_FIELDS), ATTR_CLASS, "display-fields", ]);
            html += SUPER.getDialogContents.apply(this);
            return html;
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        // onlyZoom is not updating the axis
        updateUI: function() {
            //Note: Not sure why onlyZoom was a function param. The pointData gets passes in 
            //when the json is loaded
            //            updateUI: function(onlyZoom) {
            var onlyZoom = false;

            //Note: if we write to the SVG dom element then we lose the svg object that got created in initDisplay
            //Not sure how to show a message to the user
            if (!this.hasData()) {
                return;
            }
            test = this;
            var selectedFields = this.getSelectedFields();
            if (selectedFields.length == 0) {
                //this.writeHtml(ID_SVG, "No fields selected");
                return;
            }
            this.addFieldsCheckboxes();
            pointData = this.getData();
            if (pointData == null) {
                //this.writeHtml(ID_SVG, "No data");
                console.log("no data");
                return;
            }

            var fields = pointData.getNumericFields();
            var records = pointData.getRecords();
            var ranges = RecordUtil.getRanges(fields, records);
            var elevationRange = RecordUtil.getElevationRange(fields, records);
            var offset = (elevationRange[1] - elevationRange[0]) * 0.05;
            // To be used inside a function we can use this.x inside them so we extract as variables. 
            var x = this.x;
            var y = this.y;
            var color = this.color;
            var axis = properties.graph.axis;

            if (onlyZoom) {
                this.zoom.x(this.x);
                this.zoom.y(this.y);
            } else {
                // Update axis for the zoom and other changes
                this.x.domain(d3.extent(records, function(d) {
                    return D3Util.getDataValue(axis.x, d, selectedFields[0].getIndex());
                }));
                // the y domain depends on the first selected element I have to think about it.
                this.y.domain(d3.extent(records, function(d) {
                    return D3Util.getDataValue(axis.y, d, selectedFields[0].getIndex());
                }));

                this.zoom.x(this.x);
                this.zoom.y(this.y);
            }

            this.svg.selectAll(".y.axis").call(this.yAxis);
            this.svg.selectAll(".x.axis").call(this.xAxis);

            // Remove previous lines
            this.svg.selectAll(".line").remove();
            this.svg.selectAll(".legendElement").remove();

            var myThis = this;
            for (var fieldIdx = 0; fieldIdx < selectedFields.length; fieldIdx++) {
                var dataIndex = selectedFields[fieldIdx].getIndex();
                var range = ranges[dataIndex];
                // Plot line for the values
                var line = d3.svg.line()
                    .x(function(d) {
                        return x(D3Util.getDataValue(axis.x, d, selectedFields[fieldIdx].getIndex()));
                    })
                    .y(function(d) {
                        return y(D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex()));
                    });

                displayLine = this.svg.append("path")
                    .datum(records)
                    .attr(ATTR_CLASS, "line")
                    .attr("d", line)
                    .on("mousemove", function() {
                        myThis.mouseover(d3.event)
                    })
                    .attr("fill", "none")
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("stroke-width", "0.5px");

                if (properties.graph.axis.z == FIELD_SELECTEDFIELD) {
                    displayLine.attr("stroke", "url(#colorBarGradient)");
                }

                if (properties.graph.derived != null) {
                    var funcs = properties.graph.derived.split(",");
                    for (funcIdx = 0; funcIdx < funcs.length; funcIdx++) {
                        var func = funcs[funcIdx];
                        if (func == FUNC_MOVINGAVERAGE) {
                            // Plot moving average Line
                            var movingAverageLine = d3.svg.line()
                                .x(function(d) {
                                    return x(D3Util.getDataValue(axis.x, d, selectedFields[fieldIdx].getIndex()));
                                })
                                .y(function(d, i) {
                                    if (i == 0) {
                                        return _movingSum = D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex());
                                    } else {
                                        _movingSum += D3Util.getDataValue(axis.y, d, selectedFields[fieldIdx].getIndex());
                                    }
                                    return y(_movingSum / i);
                                })
                                .interpolate("basis");
                            this.svg.append("path")
                                .attr(ATTR_CLASS, "line")
                                .attr("d", movingAverageLine(records))
                                .attr("fill", "none")
                                .attr("stroke", function(d) {
                                    return color(fieldIdx);
                                })
                                .attr("stroke-width", "1.5px")
                                .attr("viewBox", "50 50 100 100 ")
                                .style("stroke-dasharray", ("3, 3"));
                        } else {
                            console.log("Error: Unknown derived function:" + func);
                        }

                    }
                }

                // Legend element Maybe create a function or see how we implement the legend
                this.svg.append("svg:rect")
                    .attr(ATTR_CLASS, "legendElement")
                    .attr("x", this.displayWidth - 100)
                    .attr("y", (50 + 50 * fieldIdx))
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("height", 2)
                    .attr("width", 40);

                this.svg.append("svg:text")
                    .attr(ATTR_CLASS, "legendElement")
                    .attr("x", this.displayWidth - 100 + 40 + 10) // position+color rect+padding
                    .attr("y", (55 + 55 * fieldIdx))
                    .attr("stroke", function(d) {
                        return color(fieldIdx);
                    })
                    .attr("style", "font-size:50%")
                    .text(selectedFields[fieldIdx].getLabel());
            }
        },

        zoomBehaviour: function() {
            // Call redraw with only zoom don't update extent of the data.
            this.updateUI(true);
        },
        //this gets called when an event source has selected a record
        handleEventRecordSelection: function(source, args) {},
        mouseover: function() {
            // TO DO
            testing = d3.event;
            console.log("mouseover");
        },
        click: function(event) {
            // TO DO
            console.log("click:" + event);
        },
        dbclick: function(event) {
            // Unzoom
            this.zoom();
            this.updateUI();
        },
        getSVG: function() {
            return this.svg;
        }
    });
}


function RamaddaD3LineChartDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Line chart",
        //Note: changed this to "derived" from "extraLine".
        //This is a comma separated list of functions (for now just one)
        derived: FUNC_MOVINGAVERAGE,
        axis: {
            y: {
                type: TYPE_VALUE,
                fieldname: FIELD_SELECTEDFIELD
            },
            x: {
                type: TYPE_TIME,
                fieldname: FIELD_TIME,
            }
        }
    };

    properties = $.extend(dfltProperties, properties);
    return new RamaddaD3Display(displayManager, id, properties);
}


/*
function RamaddaProfileDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Profile chart",
        derived: null,
        axis: {
            y: {
                type: TYPE_ELEVATION,
                fieldname: FIELD_DEPTH,
                fieldIdx: 3,
                reverse: true
            },
            x: {
                type: TYPE_VALUE,
                fieldname: FIELD_VALUE,
            },
        }
    };
    //Note: now set the properties
    properties = $.extend(dfltProperties, properties);
    return new RamaddaD3Display(displayManager, id, properties);
}
*/



function RamaddaGliderCrossSectionDisplay(displayManager, id, properties) {
    var dfltProperties = {};
    //Note: use json structures to define the props
    dfltProperties.graph = {
        title: "Glider cross section",
        derived: null,
        axis: {
            y: {
                type: TYPE_ELEVATION,
                fieldname: FIELD_DEPTH,
                reverse: true
            },
            x: {
                type: TYPE_TIME,
                fieldname: FIELD_TIME,
            },
            z: FIELD_SELECTEDFIELD,
        }
    };
    properties = $.extend(dfltProperties, properties);

    return new RamaddaD3Display(displayManager, id, properties);
}






function RamaddaVennDisplay(displayManager, id, properties) {
    const ID_VENN = "venn";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_VENN, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
            var includes = "<script src='" + ramaddaBaseUrl + "/lib/venn.js'></script>";
            this.writeHtml(ID_DISPLAY_TOP, includes);
            let _this = this;
            var func = function() {
                _this.updateUIInner();
            };
            setTimeout(func, 10);
        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return;
            }
            /*
              var sets = [{sets : [0], label : 'SE', size : 28,}, 
              {sets : [1], label : 'Treat', size: 35},
              {sets : [2], label : 'Anti-CCP', size : 108}, 
              {sets : [3], label : 'DAS28', size:106},
              {sets : [0,1], size:1},
              {sets : [0,2], size:1},
              {sets : [0,3], size:14},
            */
            var setInfos = {};
            var setCnt = 0;
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var row = this.getDataValues(records[rowIdx]);
                var keys = [];
                var key = "";
                for (var fieldIdx = 0; fieldIdx < strings.length; fieldIdx++) {
                    var field = strings[fieldIdx];
                    var value = row[field.getIndex()];
                    var setKey = field.getId() + "--" + value;
                    keys.push(setKey);
                    key += "--" + setKey;
                    if (!Utils.isDefined(setInfos[setKey])) {
                        setInfos[setKey] = {
                            count: 0,
                            setIds: [setCnt],
                            label: value,
                        };
                        setCnt++;
                    }
                    setInfos[setKey].count++;
                }
                var ids = [];
                if (!Utils.isDefined(setInfos[key])) {
                    for (var i = 0; i < keys.length; i++) {
                        ids.push(setInfos[keys[i]].setIds[0]);
                    }
                    setInfos[key] = {
                        count: 0,
                        setIds: ids,
                        label: null,
                    };
                }
                setInfos[key].count++;
            }

            var sets = [];
            for (var a in setInfos) {
                var setInfo = setInfos[a];
                var obj = {
                    sets: setInfo.setIds,
                    size: setInfo.count
                };
                if (setInfo.label)
                    obj.label = setInfo.label;
                sets.push(obj);
            }
            this.setContents(HtmlUtils.div(["id", this.getDomId(ID_VENN), "style", "height:300px;"], ""));
            var chart = venn.VennDiagram()
                .width(600)
                .height(400);
            var id = "#" + this.getDomId(ID_VENN);
            var strokeColors = this.getColorTable(true, "strokeColors", "nice");
            var fillColors = this.getColorTable(true, "fillColors", "nice");
            var textColors = this.getColorTable(true, "textColors");
            if (!textColors)
                textColors = strokeColors;
            d3.select(id).datum(sets).call(chart);
            d3.selectAll(id + " .venn-circle path")
                .style("fill-opacity", parseFloat(this.getProperty("fillOpacity", 0.5)))
                .style("stroke-width", parseInt(this.getProperty("strokeWidth", 1)))
                .style("stroke-opacity", parseFloat(this.getProperty("strokeOpacity", 0.5)))
                .style("stroke", function(d, i) {
                    return i < strokeColors.length ? strokeColors[i] : strokeColors[i % strokeColors.length];
                })
                .style("fill", function(d, i) {
                    return i < fillColors.length ? fillColors[i] : fillColors[i % fillColors.length];
                })
            d3.selectAll(id + " .venn-circle text")
                .style("fill", function(d, i) {
                    return i < textColors.length ? textColors[i] : textColors[i % textColors.length];
                })
                .style("font-size", this.getProperty("fontSize", "16px"))
                .style("font-weight", this.getProperty("fontWeight", "100"));

        }
    });
}


function RamaddaMinidotsDisplay(displayManager, id, properties) {
    const ID_MINIDOTS = "minidots";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MINIDOTS, properties);
    let myProps = [
	{label:'Minidots Properties'},
	{p:'dateField',ex:''},
	{p:'valueField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUI();
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let dotsWidth = +this.getProperty("dotsWidth",500);
	    let dotsHeight = +this.getProperty("dotsHeight",200);	    
	    let valueField = this.getFieldById(null,this.getPropertyValueField());
	    let dateField = this.getFieldById(null,this.getPropertyDateField());
	    let groupByField = this.getFieldById(null,this.getProperty("groupBy"));
	    let divisor = +this.getProperty("divisor",1);
	    if(!valueField) {
                this.displayError("No value field specified");
		return;
	    }
	    if(!dateField) dateField = this.getFieldByType(null,"date");
	    let dateToCount = {};
	    let minDate=null, maxDate = null;
	    let groups = {};

	    records.forEach(record=>{
		let date = dateField?record.getValue(dateField.getIndex()):record.getDate();
		minDate = minDate!=null?Math.min(minDate,date.getTime()):date;
		maxDate = maxDate!=null?Math.max(maxDate,date.getTime()):date;
	    });
	    records.forEach(record=>{
		let groupByValue = groupByField?record.getValue(groupByField.getIndex()):"all";
		let date = dateField?record.getValue(dateField.getIndex()):record.getDate();
		minDate = minDate!=null?Math.min(minDate,date.getTime()):date;
		maxDate = maxDate!=null?Math.max(maxDate,date.getTime()):date;
		let data = groups[groupByValue];
		if(!data) {
		    groups[groupByValue] = data = {
			records:[],
			total:0,
			list:[],
			seen:{}
		    }
		}
		data.records.push(record);
		let value = record.getValue(valueField.getIndex());
		data.total+=value;
		value = value/divisor;
		if(data.list.length>5000) return;
		for(let i=0;i<value;i++) {
		    data.list.push({x:date.getTime(),
				    y:Math.random(),
				    record:record});
		}
	    });
	    let range = {
		minx:minDate,
		maxx:maxDate,
		miny:0,
		maxy:1
	    }
	    let groupList = Object.keys(groups).sort();
	    if(!groupByField) {
		let data = groups["all"];
		this.setContents(HtmlUtils.div([CLASS,"display-minidots-dots", ID, this.getDomId(ID_MINIDOTS), STYLE, HU.css(HEIGHT,HU.getDimension(dotsHeight),WIDTH,HU.getDimension(dotsWidth))], ""));
		drawDots(this,"#"+ this.getDomId(ID_MINIDOTS),dotsWidth,dotsHeight,data.list,range,null/*colorBy*/);
	    } else {
		let container = this.jq(ID_MINIDOTS);
		let table = "<table border=1>";
		groupList.forEach((key,idx)=>{
		    let data = groups[key];
		    table+="<tr>";
		    table += HU.td([],key +" (" + data.total+")");
		    let id = this.getDomId(ID_MINIDOTS+"_"+idx);
		    table += HU.td([],HtmlUtils.div([CLASS,"display-minidots-dots", ID, id, STYLE, HU.css(HEIGHT,HU.getDimension(dotsHeight),WIDTH,HU.getDimension(dotsWidth))], ""));
		    table+="</tr>\n";
		});
		this.setContents(table);
		groupList.forEach((key,idx)=>{
		    let data = groups[key];
		    let id = this.getDomId(ID_MINIDOTS+"_"+idx);
		    drawDots(this,"#"+ id,dotsWidth,dotsHeight,data.list,range,null/*colorBy*/);
		});
	    }

        }
    });
}



function RamaddaChernoffDisplay(displayManager, id, properties) {
    const ID_VENN = "venn";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_VENN, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        timeout: 100,
        written: false,
        updateUI: function() {
            if (!this.written) {
                this.written = true;
                var includes = "<script src='" + ramaddaBaseUrl + "/lib/chernoff.js'></script>";
                this.writeHtml(ID_DISPLAY_TOP, includes);
            }
            this.updateUIInner();
        },
        updateUIInner: function() {
            let _this = this;
            if (!Utils.isDefined(d3.chernoff)) {
                this.timeout = this.timeout * 2;
                var func = function() {
                    _this.updateUIInner();
                };
                setTimeout(func, this.timeout);
                return;
            }
            let records = this.filterData();
            if (!records) {
                return;
            }
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length == 0)
                fields = allFields;
            var string = this.getFieldByType(fields, "string");
            var legend = "";
            var colorField = this.getFieldById(allFields, this.getProperty("colorBy"));
            var colorscale;
            if (colorField) {
                var colors = this.getColorTable(true, null, "blue_white_red");
                var colorValues = this.getColumnValues(records, colorField);
                colorscale = [];
                var min = parseFloat(this.getProperty("colorByMin", colorValues.min));
                var max = parseFloat(this.getProperty("colorByMax", colorValues.max));
                var range = max - min;
                //                console.log("range:" +  max +" " +min +" #colors:" + colors.length);
                for (var i = 0; i < colorValues.values.length; i++) {
                    var value = colorValues.values[i];
                    var percent = (value - min) / range;
                    var idx = Math.round(percent * (colors.length - 1));
                    //                    console.log(idx+" " +colors[idx] +" " + value + " " + percent);
                    colorscale.push(colors[idx]);
                }
                this.displayColorTable(colors, ID_DISPLAY_BOTTOM, min, max);
                legend += "<b>Colored by</b>: " + colorField.getLabel() + "&nbsp;&nbsp;";
            }
            var attrs = [{
                label: "Face width",
                name: "face",
                key: "f",
                min: 0,
                max: 1
            }, {
                label: "Hair",
                name: "hair",
                key: "h",
                min: -1,
                max: 1
            }, {
                label: "Mouth",
                name: "mouth",
                key: "m",
                min: -1,
                max: 1
            }, {
                label: "Nose height",
                name: "noseHeight",
                key: "nh",
                min: 0,
                max: 1
            }, {
                label: "Nose width",
                name: "noseWidth",
                key: "nw",
                min: 0,
                max: 1
            }, {
                label: "Eyes height",
                name: "eyesHeight",
                key: "eh",
                min: 0,
                max: 1
            }, {
                label: "Eyes width",
                name: "eyesWidth",
                key: "ew",
                min: 0,
                max: 1
            }, {
                label: "Brow",
                name: "brow",
                key: "b",
                min: -1,
                max: 1
            }];
            var html = "";
            var showHelp = this.getProperty("showHelp", false);
            if (showHelp) {
                html += "Settings:<br><table class=ramadda-table><thead><tr><th>Attribute&nbsp;</th><th>&nbsp;Default range&nbsp;</th><th>&nbsp;Set field&nbsp;</th><th>&nbsp;Set min&nbsp;</th><th>&nbsp;Set max&nbsp;</th></tr></thead><tbody>";
            }

            for (a in attrs) {
                var attr = attrs[a];
                if (showHelp) {
                    html += "<tr><td>" + attr.label + "</td><td align=center>" + attr.min + " - " + attr.max + "</td><td>" + attr.name + "Field=&lt;field_id&gt;" + "</td><td>" + attr.name + "Min=&lt;min_value&gt;" + "</td><td>" + attr.name + "Max=&lt;max_value&gt;" + "</td></tr>";
                }
                attr.field = this.getFieldById(allFields, this.getProperty(attr.name + "Field"));
                if (attr.field) {
                    legend += "<b>" + attr.label + "</b>: " + attr.field.getLabel() + "&nbsp;&nbsp;";
                    if (Utils.isDefined(this.getProperty(attr.name + "Min"))) {
                        attr.min = parseFloat(this.getProperty(attr.name + "Min"));
                    }
                    if (Utils.isDefined(this.getProperty(attr.name + "Max"))) {
                        attr.max = parseFloat(this.getProperty(attr.name + "Max"));
                    }
                    attr.column = this.getColumnValues(records, attr.field);
                }
            }
            if (showHelp) {
                html += "</tbody></table>";
            }

            var sortField = this.getFieldById(allFields, this.getProperty("sortBy"));

            var rows = [];
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var blob = {
                    values: this.getDataValues(records[rowIdx])
                };
                if (colorscale) blob.color = colorscale[rowIdx]
                rows.push(blob);
            }

            if (sortField) {
                rows.sort(function(a, b) {
                    var v1 = a.values[sortField.getIndex()];
                    var v2 = b.values[sortField.getIndex()];
                    if (v1 < v2) return 1;
                    if (v1 > v2) return -1;
                    return 0;
                });
            }

            var data = [];
            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var blob = rows[rowIdx];
                var row = blob.values;
                var color = blob.color;
                var faceData = {
                    f: 0.5, //0-1
                    h: 0, //-1-1
                    m: 0, //-1-1
                    nh: 0.5, //0-1
                    nw: 0.5, //0-1
                    eh: 0.5, //0-1
                    ew: 0.5, //0-1
                    b: 0 //-1-1
                };
                data.push({
                    faceData: faceData,
                    color: color
                });
                var tt = "";
                for (a in attrs) {
                    var attr = attrs[a];
                    var field = attr.field;
                    if (!field) {
                        faceData[attr.key] = attr.min + (attr.max - attr.min) / 2;
                    } else {
                        var value = row[field.getIndex()];
                        var min = attr.column.min;
                        var max = attr.column.max;
                        tt += field.getLabel() + ": " + value + " range: " + min + " - " + max + " (" + attr.label + ")\n";
                        if (max != min) {
                            var percent = (value - min) / (max - min);
                            var adjValue = attr.min + (attr.max - attr.min) * percent;
                            //                            console.log(" %:" + percent + " v:" + value +" min:" + min +" max:" + max +" adj:" + adjValue);
                            faceData[attr.key] = adjValue;
                        }
                    }
                }
                var label = (string ? row[string.getIndex()] : "Row: " + rowIdx);
                var labelValue = (string ? row[string.getIndex()] : "");
                label = HtmlUtils.div(["class", "display-chernoff-label"], label);
                var div = HtmlUtils.div(["id", this.getDomId("chernoff") + "_" + rowIdx, "class", "display-chernoff-face"], "");
                html += HtmlUtils.div(["title", tt, "class", "display-chernoff-wrapper ramadda-div-link", "value", labelValue], div + label);
            }
            legend = HtmlUtils.div(["class", "display-chernoff-legend"], legend);
            var height = this.getProperty("height", "400px");
            if (!height.endsWith("px")) height += "px";
            this.setContents(legend + HtmlUtils.div(["style", "height:" + height + ";", "class", "display-chernoff-container", "id", this.getDomId("chernoff")], html));
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var div = "#" + this.getDomId("chernoff") + "_" + rowIdx;
                this.makeFace(div, data[rowIdx].faceData, data[rowIdx].color);
            }

            if (string) {
                this.find(".ramadda-div-link").click(function() {
                    var value = $(this).attr("value");
                    _this.propagateEvent("handleEventFieldValueSelect", {
                        field: string,
                        value: value
                    });
                });
            }
        },
        makeFace: function(div, faceData, color) {
            function chernoffFace() {
                var width = 400,
                    height = 200;
                var chernoff = d3.chernoff()
                    .face(function(d) {
                        return d.f;
                    })
                    .hair(function(d) {
                        return d.h;
                    })
                    .mouth(function(d) {
                        return d.m;
                    })
                    .nosew(function(d) {
                        return d.nw;
                    })
                    .noseh(function(d) {
                        return d.nh;
                    })
                    .eyew(function(d) {
                        return d.ew;
                    })
                    .eyeh(function(d) {
                        return d.eh;
                    })
                    .brow(function(d) {
                        return d.b;
                    });

                function data() {
                    return [faceData];
                }

                function drawFace(selection) {
                    var svg = selection.append("svg")
                        .attr("width", width)
                        .attr("height", height);
                    var face = svg.selectAll("g.chernoff")
                        .data(data())
                        .enter().append("g")
                        .attr("class", "chernoff")
                        .call(chernoff);
                    if (color)
                        face.attr("style", "fill:" + color);
                }

                function draw(selection) {
                    selection.call(drawFace);
                }
                return draw;
            }
            d3.select(div)
                .call(chernoffFace());
        }





    });
}



function RamaddaD3bubbleDisplay(displayManager, id, properties) {
    const ID_BUBBLES = "bubbles";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_D3BUBBLE, properties);
    if(!window["BubbleChart"]) {
	Utils.importJS(ramaddaBaseUrl +"/lib/d3/d3-legend.min.js");
	Utils.importJS(ramaddaBaseUrl +"/lib/d3/bubblechart.js");
    }
    let myProps = [
	{label:'Bubble Chart'},
	{p:'labelField',ex:''},
	{p:'colorBy',ex:''},
	{p:'valueField',ex:''},
	{p:'descriptionField',ex:''},
	{p:'imageField',ex:''},
	{p:'sizeLabel1',ex:''},
	{p:'sizeLabel2',ex:''},
	{p:'showSizeLegend',ex:'false'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	callbackWaiting:false,
        displayData: function() {
	    this.updateUI();
	},
        updateUI: function() {
            if(!window["BubbleChart"]) {
		if(!this.callbackWaiting) {
		    this.callbackWaiting = true;
                    setTimeout(()=>{
			this.callbackWaiting = false;
			this.updateUI()
		    },100);
		}
                return;
            }
	    //If the width is 0 then there is an error in the d3
	    if(this.getContents().width() ==0)  {
		this.setContents("...");
		return;
	    }
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
            let colorByField = this.getFieldById(null, this.getProperty("colorBy","category"));
	    let valueField = this.getFieldById(null, this.getProperty("valueField"));
	    if(colorByField)
		this.setProperty("sortFields",colorByField.getId());
	    let html = HtmlUtil.tag("svg", ["id", this.getDomId(ID_BUBBLES),
					    "width","100%","height","700", "font-family","sans-serif","font-size","10", "text-anchor","middle"])
	    this.setContents(html);
	    let values;
	    let min = 0;
	    let max = 0;
	    if(valueField) {
		values =  this.getColumnValues(records, valueField).values;
		values.map((v,idx)=>{
		    min  = idx==0?v:Math.min(v,min);
		    max  = idx==0?v:Math.max(v,max);
		});
	    }

	    let labelField = this.getFieldById(null, this.getProperty("labelField","name"));
	    let descField = this.getFieldById(null, this.getProperty("descriptionField"));	    
	    let imageField = this.getFieldById(null, this.getProperty("imageField"));	    
	    let template = this.getProperty("template","${default}");
	    if(!labelField) {
                this.setContents(this.getMessage("No label field found"));
		return
	    }

	    let data =[];
	    records.map(r=>{
		let desc =  descField?r.getValue(descField.getIndex()):this.getRecordHtml(r,null, template);
		let label = r.getValue(labelField.getIndex());
		let obj = {
		    name: label,
		    icon:label,
		    desc:desc,
		    cat:"",
		    value:10,
		}
		if(colorByField)
		    obj.cat = r.getValue(colorByField.getIndex());
		if(valueField)
		    obj.value = r.getValue(valueField.getIndex());
		if(imageField)
		    obj.icon = r.getValue(imageField.getIndex());
		data.push(obj);
	    });
	    if(data.length==0) {
		this.setContents(this.getMessage(this.getNoDataMessage()));
		return;
	    }
	    let colors =  this.getColorTable(true);
	    new BubbleChart("#"+this.domId(ID_BUBBLES),data,{
		label1:this.getProperty("sizeLabel1"),
		label2: this.getProperty("sizeLabel2"), 
		colors:colors,
		showSizeLegend: this.getProperty("showSizeLegend",valueField!=null)
	    });
	}
    })
}
/*
  Copyright 2008-2020 Geode Systems LLC
*/

const DISPLAY_WORDCLOUD = "wordcloud";
const DISPLAY_TEXTSTATS = "textstats";
const DISPLAY_FREQUENCY = "frequency";
const DISPLAY_TEXTANALYSIS = "textanalysis";
const DISPLAY_TEXTRAW = "textraw";
const DISPLAY_TEXT = "text";

const DISPLAY_BLOCKS = "blocks";
const DISPLAY_TEMPLATE = "template";
const DISPLAY_TOPFIELDS = "topfields";
const DISPLAY_GLOSSARY = "glossary";

addGlobalDisplayType({
    type: DISPLAY_TEXT,
    label: "Text Readout",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Simple text display","text.png")
});

addGlobalDisplayType({
    type: DISPLAY_TEMPLATE,
    label: "Template",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Flexible text template to show records","template.png")    
});


addGlobalDisplayType({
    type: DISPLAY_TOPFIELDS,
    label: "Top Fields",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("List Fields","topfields.png","For every row it sorts the field values and lists the field names"),    
});

addGlobalDisplayType({
    type: DISPLAY_WORDCLOUD,
    forUser: true,
    label: "Word Cloud",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Cloud of words","wordcloud.png")
});

addGlobalDisplayType({
    type: DISPLAY_TEXTSTATS,
    forUser: true,
    label: "Text Stats",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Summary statistics for text","textstats.png","Incudes line/word count, word length and frequency")    
});

addGlobalDisplayType({
    type: DISPLAY_FREQUENCY,
    forUser: true,
    label: "Frequency",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Text field based frequencies","frequency.png")
});
addGlobalDisplayType({
    type: DISPLAY_TEXTRAW,
    forUser: true,
    label: "Text Raw",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Shows raw text","textraw.png","Provides a search field")                                        
});
addGlobalDisplayType({
    type: DISPLAY_TEXTANALYSIS,
    forUser: true,
    label: "Text Analysis",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Analyzes text","textanalysis.png")
});
addGlobalDisplayType({
    type: DISPLAY_BLOCKS,
    forUser: true,
    label: "Blocks",
    requiresData: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Blocks","blocks.png","Shows a certain number of small blocks or<br> icons color coded from the data"),        
});

addGlobalDisplayType({
    type: DISPLAY_GLOSSARY,
    forUser: true,
    label: "Glossary",
    requiresData: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Searchable glossary","glossary.png")    
});


function RamaddaBaseTextDisplay(displayManager, id, type, properties) {
    const ID_TEXTBLOCK = "textblock";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    defineDisplay(this, SUPER, [], {
        processText: function(cnt,fields) {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            var fieldInfo = {};
            var allFields = this.getData().getRecordFields();
            fields = fields || this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
            var minLength = parseInt(this.getProperty("minLength", 0));
            var maxLength = parseInt(this.getProperty("maxLength", 100));
            var stopWords = this.getProperty("stopWords");
            if (stopWords) {
                if (stopWords == "default") {
                    stopWords = Utils.stopWords;
                } else {
                    stopWords = stopWords.split(",");
                }
            }
            var extraStopWords = this.getProperty("extraStopWords");
            if (extraStopWords) extraStopWords = extraStopWords.split(",");

            var stripTags = this.getProperty("stripTags", false);
            var tokenize = this.getProperty("tokenize", false);
            var lowerCase = this.getProperty("lowerCase", false);
            var removeArticles = this.getProperty("removeArticles", false);
            if (cnt) {
                cnt.count = 0;
                cnt.total = 0;
                cnt.lengths = {};
            }
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var row = this.getDataValues(records[rowIdx]);
                for (var fieldIdx = 0; fieldIdx < strings.length; fieldIdx++) {
                    var field = strings[fieldIdx];
                    if (!fieldInfo[field.getId()]) {
                        fieldInfo[field.getId()] = {
                            field: field,
                            words: [],
                            counts: {},
                            divId: this.domId(ID_TEXTBLOCK + (field.getIndex())),
                        }
                    }
                    var fi = fieldInfo[field.getId()];
                    var value = row[field.getIndex()];
                    if (stripTags) {
                        value = Utils.stripTags(value);
                    }
                    var values = [value];
                    if (tokenize) {
			values[0] = values[0].replace(/\"/g," ");
                        values = Utils.tokenizeWords(values[0], stopWords, extraStopWords, removeArticles);
                    }
                    for (var valueIdx = 0; valueIdx < values.length; valueIdx++) {
                        var value = values[valueIdx].trim();
			if(values.length>1 && value.length<=1) continue;
			if(value.startsWith("&")) continue;  
			var _value = value.toLowerCase();
                        if (cnt) {
                            cnt.count++;
                            cnt.total += value.length;
                            if (!Utils.isDefined(cnt.lengths[value.length]))
                                cnt.lengths[value.length] = 0;
                            cnt.lengths[value.length]++;
                        }


                        if (!tokenize) {
                            if (stopWords && stopWords.includes(_value)) continue;
                            if (extraStopWords && extraStopWords.includes(_value)) continue;
                        }
                        if (value.length > maxLength) continue;
                        if (value.length < minLength) continue;
                        if (lowerCase) value = value.toLowerCase();
                        if (!Utils.isDefined(fi.counts[value])) {
                            fi.counts[value] = 0;
                        }
                        fi.counts[value]++;
                    }
                }
            }



            return fieldInfo;
        }
    });
}


function RamaddaWordcloudDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_WORDCLOUD, properties);
    let myProps = [
	{label:"Wordcloud"},
	{p:'termField'},
	{p:'fields'},	
	{p:'tableFields'},
	{p:'countField'},
	{p:'tokenize',ex:true},
	{p:'handleClick',ex:true},
	{p:'showFieldLabel',ex:true},
	{p:'showRecords'},
	{p:'combined'},
	{p:'shape',ex:'rectangular'},
	{p:'stopWords',ex:'word1,word2'},
	{p:'showFieldLabel',ex:'false'}	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
	    if(!this.loadedJq) {
		this.loadedJq = true;
		let includes = "<link rel='stylesheet' href='" + ramaddaBaseUrl + "/lib/jqcloud.min.css'>";
		includes += "<script src='" + ramaddaBaseUrl + "/lib/jqcloud.min.js'></script>";
		this.writeHtml(ID_DISPLAY_TOP, includes);
		let _this = this;
		let func = function() {
                    _this.updateUIInner();
		};
		setTimeout(func, 10);
	    } else {
                this.updateUIInner();
	    }
        },
        updateUIInner: function() {
            let records = this.filterData();
	    if(records == null) return;
            let options = {
                autoResize: true,
            };
            let colors = this.getColorTable(true);
            if (colors) {
                options.colors = colors,
                options.classPattern = null;
                options.fontSize = {
                    from: 0.1,
                    to: 0.02
                };
            }
            if (this.getProperty("shape"))
                options.shape = this.getProperty("shape");

	    let countField = this.getFieldById(null, this.getProperty("countField"));
	    let termField = this.getFieldById(null, this.getProperty("termField"));
	    if(countField && termField) {
		let minLength = parseInt(this.getProperty("minLength", 0));
		let maxLength = parseInt(this.getProperty("maxLength", 100));
		let stopWords = this.getProperty("stopWords");
		if (stopWords) {
                    if (stopWords == "default") {
			stopWords = Utils.stopWords;
                    } else {
			stopWords = stopWords.split(",");
                    }
		}
		let info = [];
		let wordToWeight = {};
		records.every(record=>{
		    let word =termField.getValue(record);
		    let _word = word.toLowerCase();
                    if (stopWords && stopWords.includes(_word)) return true;
		    if(!wordToWeight[word]) {
			wordToWeight[word]=0;
		    }
		    wordToWeight[word]+=countField.getValue(record);
		    return true;
		});
                let handlers = null;
		let _this = this;
                if (this.getProperty("handleClick", true)) {
                    handlers = {
                        click: function(w) {
                            let word = w.target.innerText;
                            _this.showRows(records, null, word, fields);
                        }
                    }
                };

		    
		for(word in wordToWeight) {
		    info.push({
			text: word,
			html:{style:"cursor:pointer;"},
			weight:wordToWeight[word] ,
			handlers:handlers,
		    });

		}
                this.setContents(HU.div([ID, this.domId("words"), STYLE, HU.css('height','300px')], ""));
                $("#" + this.domId("words")).jQCloud(info, options);
		return
	    }
            let allFields = this.getData().getRecordFields();
            let fields = termField?[termField]:this.getSelectedFields(allFields);
            let fieldInfo = this.processText(null,fields);
            if (fieldInfo == null) return;
            if (fields.length == 0)
                fields = allFields;
            let strings = this.getFieldsByType(fields, "string");
            let _this = this;
            let divs = "";
            let words = [];
            let maxWords = parseInt(this.getProperty("maxWords", -1));
            let minCount = parseInt(this.getProperty("minCount", 0));
            let width = (100 * 1 / strings.length) + "%;";
            for (a in fieldInfo) {
                let fi = fieldInfo[a];
                let field = fi.field;
                let handlers = null;
                if (this.getProperty("handleClick", true)) {
                    handlers = {
                        click: function(w) {
                            let word = w.target.innerText;
                            _this.showRows(records, field, word, fields);
                        }
                    }
                };

                let counts = [];
                for (word in fi.counts) {
                    let count = fi.counts[word];
                    counts.push({
                        word: word,
                        count: count
                    });
                }
                counts.sort(function(a, b) {
                    if (a.count < b.count) return -1;
                    if (a.count > b.count) return 1;
                    return 0;
                });
                if (minCount > 0) {
                    let tmp = [];
                    for (let i = 0; i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }
                if (maxWords > 0) {
                    let tmp = [];
                    for (let i = 0; i <= maxWords && i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                for (let wordIdx = 0; wordIdx < counts.length; wordIdx++) {
                    let word = counts[wordIdx];
                    let obj1 = {
                        weight: word.count,
			html:{style:"cursor:pointer;"},
                        handlers: handlers,
                        text: word.word,
                    };
                    let obj2 = {
                        weight: word.count,
			html:{style:"cursor:pointer;"},
                        handlers: handlers,
                        text: field.getLabel() + ":" + word.word,
                    };
                    fi.words.push(obj1);
                    words.push(obj2);
                }
                let label = "";
                if (this.getProperty("showFieldLabel", true))
                    label = HU.b(fi.field.getLabel());

                divs += HU.div([STYLE,HU.css('display','inline-block','width', width)], 
			       label + HU.div([STYLE, HU.css('border','1px #ccc solid','height','300px'), ID, fi.divId], ""));
            }

            this.setContents("");
            if (this.getProperty("combined", false)) {
                this.setContents(HU.div([ID, this.domId("words"), STYLE, HU.css('height','300px')], ""));
                $("#" + this.domId("words")).jQCloud(words, options);
            } else {
                this.setContents(divs);
                for (a in fieldInfo) {
                    let fi = fieldInfo[a];
                    $("#" + fi.divId).jQCloud(fi.words, options);
                }
            }
        },
        showRows: function(records, field, word, stringFields) {
	    if(!field)
		field = this.getFieldById(null, this.getProperty("termField"));
            let tokenize = this.getProperty("tokenize", false);
            if (stringFields && word.startsWith(field.getLabel() + ":")) {
                word = word.replace(field.getLabel() + ":", "");
            }
            let tableFields;
            if (this.getProperty("tableFields")) {
                tableFields = {};
                let list = this.getProperty("tableFields").split(",");
                for (a in list) {
                    tableFields[list[a]] = true;
                }
            }
            let fields = this.getData().getRecordFields();
            let html = "";
            let data = [];
            let header = [];
            data.push(header);
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let f = fields[fieldIdx];
                if (tableFields && !tableFields[f.getId()]) continue;
                header.push(fields[fieldIdx].getLabel());
            }
            let showRecords = this.getProperty("showRecords", false);
            if (showRecords) {
                html += "<br>";
            }
            let re = new RegExp("(\\b" + word + "\\b)", 'i');
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                let value =  row[field.getIndex()];
                if (tokenize) {
                    if (!value.match(re)) {
                        continue;
                    }
                } else {
                    if (word != value) {
                        continue;
                    }
                }
                let tuple = [];
                data.push(tuple);
                for (let col = 0; col < fields.length; col++) {
                    let f = fields[col];
                    if (tableFields && !tableFields[f.getId()]) continue;
                    let v = row[f.getIndex()];
		    if(v.getTime) {
			v = {v:v,f:this.formatDate(v)};
		    } else {
			if (tokenize) {
                            v = v.replace(re, "<span style=background:yellow;>$1</span>");
			}
		    }
                    if (showRecords) {
                        html += HU.b(f.getLabel()) + ": " + v + "</br>";
                    } else {
                        tuple.push(v);
                    }
                }
                if (showRecords) {
                    html += "<p>";
                }
            }

            if (showRecords) {
                this.writeHtml(ID_DISPLAY_BOTTOM, HU.center(html));
            } else {
                let prefix = "";
                if (!tokenize) {
                    prefix = (field?field.getLabel():"Word") + "=" + word
                }
                this.writeHtml(ID_DISPLAY_BOTTOM, HU.center(prefix + HU.div([ID, this.domId("table"), STYLE, HU.css('height','300px')], "")));
                let dataTable = google.visualization.arrayToDataTable(data);
                this.chart = new google.visualization.Table(document.getElementById(this.domId("table")));
                this.chart.draw(dataTable, {
                    allowHtml: true
                });
            }
        }
    });
}




function RamaddaTemplateDisplay(displayManager, id, properties) {
    if(!Utils.isDefined(properties.showTitle)) properties.showTitle=false;
    if(!Utils.isDefined(properties.showMenu)) properties.showMenu=false;
    if(!Utils.isDefined(properties.displayStyle)) properties.displayStyle = "background:rgba(0,0,0,0);";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TEMPLATE, properties);
    let myProps = [
	{label:"Template"},
	{p: "template"},
	{p:"headerTemplate",ex:"... ${totalCount} ... ${selectedCount}"},
	{p:"footerTemplate",ex:"... ${totalCount} ... ${selectedCount}"},
	{p:"emptyMessage"},
	{p:"select",ex:"max|min|<|>|=|<=|>=|contains"},
	{p:"selectField"},
	{p:"selectValue"},
	{p:'onlyShowSelected',ex:'true'},
	{p:'showFirst',ex:'false'},	
	{p:'selectHighlight',ex:'true'},	
	{p:'handleSelectOnClick'},
	{p:"groupByField"},
	{p:"groupDelimiter",ex:"<br>"},	
	{p:"groupTemplate",wikivalue:"<b>${group}</b><ul>${contents}</ul>"},
	{p:"sortGroups",wikivalue:"true"},
	{p:'${&lt;field&gt;_total}'},
	{p:'${&lt;field&gt;_max}'},
	{p:'${&lt;field&gt;_min}'},
	{p:'${&lt;field&gt;_average}'},
	{p:'highlightOnScroll',ex:'true'}];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	dataFilterChanged: function() {
	    if(this.getPropertyOnlyShowSelected() && this.selectedRecord ) {
		this.selectedRecord = null;
		this.selectedRecords = null;		
		this.setContents("");
	    }
	    SUPER.dataFilterChanged.call(this);
	},
	updateUI: function() {
	    let pointData = this.getData();
	    if(pointData==null) return;
	    let records = this.filterData();
	    if(!records) return;
	    if(this.getPropertyOnlyShowSelected()) {
		if(!this.selectedRecord && !this.selectedRecords) {
		    if(this.getPropertyShowFirst(true)) {
			this.selectedRecord = records[0];
		    }
		}
	    }
	    if(this.getPropertyOnlyShowSelected()) {
		if(!this.selectedRecord && !this.selectedRecords) {
		    this.setContents("<br>");
		    return;
		}
		
		records = this.selectedRecords|| [this.selectedRecord];
	    }
	    records= this.sortRecords(records);
	    let fields = pointData.getRecordFields();
	    let uniqueFields  = this.getFieldsByIds(fields, this.getProperty("uniqueFields"));
	    let uniqueMap ={};
	    let template = this.getProperty("template","");
	    let select = this.getProperty("select","all");
	    let selected = [];
	    let summary = {};
	    let goodRecords = [];
	    records.forEach(record=>{
		if(uniqueFields.length>0) {
		    var key= "";
		    uniqueFields.map(uf=>{
			key += "__" +uf.getValue(record);
		    });
		    if(Utils.isDefined(uniqueMap[key])) {
			return;
		    }
		    uniqueMap[key] = true;
		}
		goodRecords.push(record);
		for(var i=0;i<fields.length;i++) {
		    var f = fields[i];
		    var v =f.getValue(record);
		    if(!summary[f.getId()]) {
			summary[f.getId()] = {
			    total: 0,
			    min: v,
			    max:v,
			    count:0,
			    uniques:{},
			    uniqueCount:0
			}
		    }
		    var s = summary[f.getId()];
		    if(f.isString()) {
			if(!s.uniques[v]) {
			    s.uniqueCount++;
			    s.uniques[v] = true;
			}
			continue;
		    } 
		    if(f.isDate&& v.getTime) {
			if(v.getTime()<s.min.getTime()) s.min = v;
			if(v.getTime()>s.max.getTime()) s.max = v;
		    }  else if(!isNaN(v)) {
			s.total+=v;
			s.min = Math.min(s.min,v);
			s.max = Math.max(s.max,v);
			s.count++;
		    }
		}
	    });

	    records=goodRecords;

	    for(var i=0;i<fields.length;i++) {
		var f = fields[i];
		if(!f.isNumeric()) continue;
		var s = summary[f.getId()];
		if(s && s.count) {
		    s.average =  s.total/s.count;
		}
	    }
	    

	    if(select == "max" || select=="min" || select=="=" || select=="<" || select == ">" ||
	       select == "<=" || 	       select == "?>=" || select=="match") {
		var selectField = this.getProperty("selectField",null);
		if(selectField) selectField  =this.getFieldById(null, selectField);
		if(!selectField) {
		    this.setContents("No selectField specified");
		    return;
		}
		var selectValue = this.getProperty("selectValue","0");
		var selectValueNum = parseFloat(selectValue);
		var max =0; 
		var min = 0;
		var cnt = 0;
		var maxRecord;
		var minRecord;
		var equalsRecord;
		records.map(record=>{
		    var v =selectField.getValue(record);
		    if(select == "match") {
			if(v.match(selectValue)) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == "=") {
			if(v == selectValue) {
			    selected.push(record);
			}
			return;
		    }
		    if(isNaN(v)) return;
		    if(select == "<") {
			if(v < selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == ">") {
			if(v > selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == ">=") {
			if(v >= selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(select == "<=") {
			if(v <= selectValueNum) {
			    selected.push(record);
			}
			return;
		    }
		    if(cnt++ == 0) {
			min  = v;
			max = v;
			minRecord = record;
			maxRecord = record;
			return;
		    }
		    if(v<min) {
			min  = v;
			minRecord = record;
		    }
		    if(v > max) {
			max =v;
			maxRecord = record;
		    }
		});
		if(select == "min") {
		    if(minRecord)
			selected.push(minRecord);
		} else 	if(select == "max") {
		    if(maxRecord)
			selected.push(maxRecord);
		}
	    } else {
		selected = records;
	    }
	    var contents = "";
	    if(selected.length==0) {
		contents = this.getProperty("emptyMessage","Nothing found");
	    }

            var colorBy = this.getColorByInfo(selected);

	    let attrs = {};
	    attrs["selectedCount"] = selected.length;
	    attrs["totalCount"] = records.length;


	    for(var i=0;i<fields.length;i++) {
		var f = fields[i];
		var s = summary[f.getId()];
		if(!s) continue;
		if(f.isDate) {
		    attrs[f.getId()+"_min"] = s.min;
		    attrs[f.getId()+"_max"] = s.max;
		    continue;
		}
		if(s && f.isString()) {
		    attrs[f.getId() +"_uniques"] =  s.uniqueCount;
		    continue;
		}
		if(!f.isNumeric()) continue;
		if(s) {
		    attrs[f.getId() +"_total"] = s.total;
		    attrs[f.getId() +"_min"] = s.min;
		    attrs[f.getId() +"_max"] = s.max;
		    attrs[f.getId() +"_average"] = s.average;
		}
	    }

	    var headerTemplate = this.getProperty("headerTemplate","");
	    var footerTemplate = this.getProperty("footerTemplate","");

	    if(selected.length==1) {
		var row = this.getDataValues(selected[0]);
		headerTemplate = this.applyRecordTemplate(selected[0],row,fields,headerTemplate);
		footerTemplate = this.applyRecordTemplate(selected[0],row,fields,footerTemplate);
	    }

	    if(this.filters) {
		for(var filterIdx=0;filterIdx<this.filters.length;filterIdx++) {
		    let filter = this.filters[filterIdx];
		    if(!filter.field)continue;
		    let f = filter.field;
		    if(f.isNumeric()) {
			var min = $("#" + this.domId("filterby_" + f.getId()+"_min")).val().trim();
			var max = $("#" + this.domId("filterby_" + f.getId()+"_max")).val().trim();
			attrs["filter_" + f.getId() +"_min"] = min;
			attrs["filter_" + f.getId() +"_max"] = max;
		    } else {
			var widget =$("#" + this.domId("filterby_" + f.getId())); 
			if(!widget.val || widget.val()==null) continue;
			var value = widget.val();
			if(!value) continue;
			if(Array.isArray(value)) {
			    var tmp = "";
			    value.map(v=>{
				if(tmp!="") tmp+=", ";
				tmp+=v;
			    });
			    value = tmp;
			}
			value = value.trim();
			if(value==FILTER_ALL) {
			    var regexp = new RegExp("\\${filter_" + f.getId()+"[^}]*\\}",'g');
			    headerTemplate = headerTemplate.replace(regexp,"");
			    footerTemplate = footerTemplate.replace(regexp,"");
			} else {
			    var regexp = new RegExp("\\${filter_" + f.getId()+" +prefix='([^']*)' +suffix='([^']*)' *\\}",'g');
			    headerTemplate = headerTemplate.replace(regexp,"$1" + value +"$2");
			    footerTemplate = footerTemplate.replace(regexp,"$1" + value +"$2");
			    var regexp = new RegExp("\\${filter_" + f.getId()+" +prefix='([^']*)' *\\}",'g');
			    headerTemplate = headerTemplate.replace(regexp,"$1" + value);
			    footerTemplate = footerTemplate.replace(regexp,"$1" + value);
			    var regexp = new RegExp("\\${filter_" + f.getId()+" +suffix='([^']*)' *\\}",'g');
			    headerTemplate = headerTemplate.replace(regexp,value +"$1");
			    footerTemplate = footerTemplate.replace(regexp,value +"$1");
			    var regexp = new RegExp("\\${filter_" + f.getId()+" *\\}",'g');
			    headerTemplate = headerTemplate.replace(regexp,value);
			    footerTemplate = footerTemplate.replace(regexp,value);
			}
		    }
		}
	    }

	    let th = Utils.tokenizeMacros(headerTemplate);
	    let tf = Utils.tokenizeMacros(footerTemplate);
	    headerTemplate = th.apply(attrs);
	    footerTemplate = tf.apply(attrs);	    

	    if(selected.length>0) {
		contents+= headerTemplate;
	    }
	    if(template!= "") {
		let groupByField  =this.getFieldById(null, this.getProperty("groupByField"));
		let groupDelimiter  = this.getProperty("groupDelimiter"," ");
		let groupTemplate  = this.getProperty("groupTemplate","<b>${group}</b><ul>${contents}</ul>");
		let groupList = [];
		let groups = {};
		var props = this.getTemplateProps(fields);
		var max = parseFloat(this.getProperty("maxNumber",-1));
		var cols = parseFloat(this.getProperty("templateColumns",-1));
		var colTag;
		if(cols>0) {
		    colTag = "col-md-" +Math.round(12/cols);
		    contents += '<div class="row-tight row">';
		}
		var colCnt = 0;
		var style = this.getProperty("templateStyle","");
		let handleSelectOnClick = this.getPropertyHandleSelectOnClick(true);

		for(var rowIdx=0;rowIdx<selected.length;rowIdx++) {
		    if(max!=-1 && rowIdx>=max) break;
		    if(cols>0) {
			if(colCnt>=cols) {
			    colCnt=0;
			    contents += '</div>\n';
			    contents += '<div class="row-tight row">\n';
			}
			contents+='<div  class="' + colTag+'">\n';
			colCnt++;
		    }
		    var record = selected[rowIdx];
		    var color = null;
                    if (colorBy.index >= 0) {
			var value =  record.getData()[colorBy.index];
			color =  colorBy.getColor(value, record);
                    }
		    let s = template.trim();
		    let row = this.getDataValues(record);
		    if(s.startsWith("${default")) {
			s = this.getRecordHtml(record,fields,s);
		    } else {
			s= this.applyRecordTemplate(record, row,fields,s,props);
		    }


		    let macros = Utils.tokenizeMacros(s);
		    let rowAttrs = {};
		    rowAttrs["selectCount"] = selected.length;
		    rowAttrs["totalCount"] = records.length;
		    rowAttrs[RECORD_INDEX] = rowIdx+1;
		    let dataFilters = this.getDataFilters();
		    this.filters.forEach(f=>{
			if(!f.isEnabled() || !f.getField) return;
			rowAttrs["filter." + f.getField().getId()] =  f.getFieldValues();
		    });
		    var recordStyle = style;
		    if(color) {
			if(this.getProperty("colorBackground",false)) {
			    recordStyle = HU.css("background",color) + recordStyle;
			}
			rowAttrs["color"] = color;
		    }
		    if(!handleSelectOnClick)
			recordStyle+=HU.css("cursor","default");
		    var tag = HU.openTag("div",[CLASS,"display-template-record",STYLE,recordStyle, ID, this.getId() +"-" + record.getId(), TITLE,"",RECORD_ID,record.getId(),RECORD_INDEX, rowIdx]);
		    s = macros.apply(rowAttrs);
		    if(s.startsWith("<td")) {
			s = s.replace(/<td([^>]*)>/,"<td $1>"+tag);
			s = s.replace(/<\/td>$/,"</div></td>");
		    } else if(s.startsWith("<tr")) {
			s = s.replace(/<td([^>]*)>/g,"<td $1>"+tag);
			s = s.replace(/<\/td>/g,"</div></td>");
		    }  else {
			s = tag +s +HU.close(DIV);
		    }
		    if (groupByField) {
			let groupValue =groupByField.getValue(record);
			if(groupValue.getTime) groupValue = this.formatDate(groupValue);
			if(!groups[groupValue]) {
			    groupList.push(groupValue);
			    groups[groupValue] = "";
			} else {
			    groups[groupValue]+=groupDelimiter;
			}
			groups[groupValue]+=s;
		    } else {
			contents+=s;
		    }


		    if(cols>0) {
			contents+=HU.close(DIV);
		    }
		}
		if (groupByField) {
		    if(this.getPropertySortGroups(false))
			groupList = groupList.sort();
		    groupList.forEach(group=>{
			contents+=  groupTemplate.replace("${group}",group).replace("${contents}",groups[group]);
		    });
		}
		if(cols>0) {
		    contents += HU.close(DIV);
		}
	    }
	    if(selected.length>0) 
		contents+= footerTemplate;
	    this.setContents(contents,true);
	    this.addFieldClickHandler(null,null,false);
	    var recordElements = this.find(".display-template-record");
	    this.makeTooltips(recordElements, selected);
	    this.makePopups(recordElements, selected);
	    let _this = this;
	    if(this.getPropertyHandleSelectOnClick(true)) {
		this.find(".display-template-record").click(function() {
		    var record = selected[$(this).attr(RECORD_INDEX)];
		    _this.handleEventRecordHighlight(this, {record:record,highlight:true,immediate:true,skipScroll:true});
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		});
	    }


	    if(this.getPropertyHighlightOnScroll(false)) {
		let items = this.find(".display-template-record");
		this.getContents().scroll(()=>{
		    let topElement = null;
		    items.each(function() {
			let pos  = $(this).position();
			if(pos.top<0) {
			    topElement = $(this);
			}
		    });
		    if(topElement) {
			var record = selected[topElement.attr(RECORD_INDEX)];
			if(record && this.currentTopRecord && record!=this.currentTopRecord) {
			    this.propagateEventRecordSelection({highlight:true,record: record});
			}
			this.currentTopRecord = record;
		    }
		});
	    }





	},
	highlightCount:0,
        handleEventRecordSelection: function(source, args) {
	    this.selectedRecords = args.records;
	    this.selectedRecord = args.record;
	    if(this.getProperty("onlyShowSelected")) {
		this.updateUI();
	    } else {
		args.highlight = true;
		this.handleEventRecordHighlight(source, args);
	    }
	},
        handleEventRecordHighlight: function(source, args) {
	    if(this.getPropertySelectHighlight()) {
		this.selectedRecord=args.record;
		this.callUpdateUI();
		return
	    }

	    this.currentTopRecord = null;
	    let myCount = ++this.highlightCount;
	    var id = "#" + this.getId()+"-"+args.record.getId();
	    if(this.highlightedElement) {
		this.unhighlightElement(this.highlightedElement);
		this.highlightedElement = null;
	    }
//	    console.log(this.type+ " handleEventRecordHighlight " + args.highlight); 
	    if(args.highlight) {
		if(args.immediate) {
		    this.highlightElement(args);
		} else {
		    setTimeout(() =>{
			if(myCount == this.highlightCount) {
			    this.highlightElement(args);
			}
		    },500);
		}
	    } else {
		var id = "#" + this.getId()+"-"+args.record.getId();
		var element = $(id);
		this.unhighlightElement(element);
	    }
	},
	unhighlightElement: function(element) {
	    this.currentTopRecord = null;
	    element.removeClass("display-template-record-highlight");
	    var css = this.getProperty("highlightOffCss","").split(";");
	    if(css.length>0) {
		css.map(tok=>{
		    var c = tok.split(":");
		    var a = c[0];
		    var v = c.length>1?c[1]:null;
		    if(!v || v=="") {
			v = element.attr("prev-" + a);
		    }
		    if(v) {
			//			    console.log("un highlight css:" + element.css("background")+ " idx:" + element.attr(RECORD_INDEX));
			element.css(a,v);
		    }
		});
	    } 
	},
	highlightElement: function(args) {
	    var id = "#" + this.getId()+"-"+args.record.getId();
	    var element = $(id);
	    this.highlightedElement = element;
	    element.addClass("display-template-record-highlight");
	    var css = this.getProperty("highlightOnCss","").split(";");
	    if(css.length>0) {
		css.map(tok=>{
		    var c = tok.split(":");
		    var a = c[0];
		    var v = c.length>1?c[1]:null;
		    if(!v || v=="") {
			v = element.attr("prev-" + a);
		    }
		    if(v) {
			var oldV = element.css(a);
			if(oldV) {
			    element.attr("prev-" + a,oldV);
			}
			element.css(a,v);
		    }
		});
	    } 
	    

	    try {
		if(!args.skipScroll) {
		    var eo = element.offset();
		    if(eo==null) return;
		    var container = this.getContents();
		    if(this.getProperty("orientation","vertical")== "vertical") {
			var c = container.offset().top;
			var s = container.scrollTop();
			container.scrollTop(eo.top- c + s)
		    } else {
			var c = container.offset().left;
			var s = container.scrollLeft();
			container.scrollLeft(eo.left- c + s)
		    }
		}

	    } catch(err) {
		console.log("Error:" + err);
	    }

	}
    })}





function RamaddaTopfieldsDisplay(displayManager, id, properties) {
    const ID_SLIDE = "slide";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TOPFIELDS, properties);
    let myProps = [
	{label:'Top Fields'},
	{p:'fieldCount',tt:''},
	{p:'labelField',tt:''},
	{p:'dateFormat',ex:'yyyy'},
	{p:'labelField'},
	{p:'scaleFont',ex:'false'}
    ]
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    var pointData = this.getData();
	    if (pointData == null) return;
	    let records = this.filterData();
	    if(!records) return;

            var fields = this.getData().getNonGeoFields();
	    var labelField = this.getFieldById(fields,this.getProperty("labelField"));
	    if(labelField==null) {
		labelField = this.getFieldById(fields, TITLE);
	    }
	    if(labelField==null) {
		labelField = this.getFieldById(fields, "name");
	    }
	    var fieldsToUse = this.getFieldsByIds(fields,this.getPropertyFields());
	    if(fieldsToUse.length==0) fieldsToUse = fields;
	    var html = "";
	    var fieldCount = +this.getProperty("fieldCount",10);
	    var dataList = [];
	    var min = Number.MAX_VALUE;
	    var max = Number.MIN_VALUE;
	    var dateFormat = this.getProperty("dateFormat");
	    for(var i=0;i<records.length;i++) {
		var record = records[i]; 
		var tuple = record.getData();
		var data =[];
		for(var j=0;j<fieldsToUse.length;j++) {
		    var field = fieldsToUse[j];
		    if(!field.isNumeric()) continue;
		    var value  =tuple[field.getIndex()];
		    if(!isNaN(value)) {
			min  = Math.min(min, value);
			max  = Math.max(max, value);
		    }
		    data.push({value: value, field: field});
		}
		data.sort((a,b)=>{
		    return b.value-a.value;
		});
		var header = labelField?tuple[labelField.getIndex()]:" Record:" + (i+1);
		if((labelField && labelField.isFieldDate()) || (typeof header =="date"))  {
		    header = Utils.formatDateWithFormat(header, dateFormat);
		}
		dataList.push({data:data,record:record,header:header});
	    }
	    var scaleFont = this.getProperty("scaleFont",true);
	    for(var i=0;i<dataList.length;i++) {
		var data = dataList[i].data;
		var record = dataList[i].record;
		var header = dataList[i].header;
		var tuple = record.getData();
		var div = "";
		var contents = "";
		for(var j=0;j<data.length && j<fieldCount;j++) {
		    var value = data[j].value;
		    var percent = max==min?1:(value-min)/(max-min);
		    var fontSize = 6+Math.round(percent*24)+"pt";
		    if(!scaleFont) fontSize = "100%";
		    var field = data[j].field;
		    contents += HU.div(["field-id",field.getId(), "data-value",field.getLabel(), TITLE,"Value: " + value, CLASS,"display-topfields-row",STYLE,"font-size:" + fontSize+";"], field.getLabel());
		}
		div += HU.div([CLASS,"display-topfields-header",RECORD_INDEX,i],header);
		div += HU.div([CLASS,"display-topfields-values"], contents);
		html+=HU.div([CLASS,"display-topfields-record"], div);
	    }
	    this.setContents(html);
	    let _this = this;
	    this.find(".display-topfields-header").click(function(){
		var idx = $(this).attr(RECORD_INDEX);
		_this.find(".display-topfields-record").removeClass("display-topfields-selected");
		$(this).parent().addClass("display-topfields-selected");
		var record = records[idx];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    let rows =this.find(".display-topfields-row");
	    rows.hover(function() {
		rows.removeClass("display-topfields-highlight");
		var value = $(this).attr("data-value");
		_this.find(HU.attrSelect("data-value", value)).addClass("display-topfields-highlight");
		
	    });
	    rows.click(function() {
		var field = $(this).attr("field-id");
		_this.getDisplayManager().notifyEvent("handleEventFieldsSelected", _this, [field]);
		
	    });
	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    var index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    var container = this.getContents();
	    container.find(".display-topfields-record").removeClass("display-topfields-selected");
	    var element =   container.find(HU.attrSelect(RECORD_INDEX, index)).parent();
	    element.addClass("display-topfields-selected");
	    var c = container.offset().top;
	    var s = container.scrollTop();
	    var eo = element.offset();
	    var diff = eo.top- c + s;
	    container.scrollTop(diff)
	},



    })}










function RamaddaBlocksDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_BLOCKS, properties);
    const ID_BLOCKS_HEADER = "blocks_header";
    const ID_BLOCKS = "blocks";
    const ID_BLOCKS_FOOTER = "blocks_footer";
    let myProps = [
	{label:'Block'},
	{p:'animStep',d:1000,ex:"1000",tt:'Delay'},
	{p:'doSum',d:true,ex:"false",tt:''},
	{p:'numBlocks',d:1000,ex:"1000",tt:'How many blocks to show'},
	{p:'header',d:true,ex:"Each block represents ${blockValue} ... There were a total of ${total} ...",tt:''},

//	{p:'counts',d:100,ex:"100",tt:''},	
	{p:'blockIcon',d:null,ex:"fa-male",tt:'Use an icon'},
//	{p:'',d:"",ex:"",tt:''},
    ];


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getContentsStyle: function() {
            return "";
        },
        updateUI: function() {
	    let f = this.getPropertyFields();
	    let records;
	    if(f) {
		records = this.filterData();
		if(!records) return;
	    }
	    this.counts = [];
	    this.counts2 = [];
	    if(f) {
		let fields = this.getFieldsByIds(null,f);
		if(!fields) return;
		this.footers = [];
		this.headers = [];
		let numBlocks  = this.getPropertNumBlocks(1000);
		this.total = 0;
		fields.forEach(f=>{
		    this.footers.push("${count} " + f.getLabel());
		    let v = f.getValue(records[0]);
		    if(!isNaN(v)) this.total+=v;
		    this.counts.push(v);
		});

		if(this.total>0) {
		    this.blockValue = this.total/numBlocks;
		    this.counts.forEach(v=>{
			let percent = isNaN(v)?0:v/this.total;
			let scaledValue = percent*numBlocks;
			this.counts2.push(scaledValue);
		    });
		}
	    } else {
		//todo: set this
		this.blockValue = 0;
		let counts = this.getProperty("counts","100",true).split(";");
		for(var i=0;i<counts.length;i++) 
		    this.counts.push(parseFloat(counts[i]));
		let doSum = this.getPropertyDoSum();
		if(doSum) {
		    this.counts2 = this.counts;
		} else {
		    this.total = 0;
		    for(var i=0;i<this.counts.length;i++) {
			let tmp = this.counts[i];
			this.counts2.push(this.counts[i]-this.total);
			this.total+= tmp;
		    }
		}
		this.footers = this.getProperty("footers","",true).split(";");
		this.headers = this.getProperty("headers","",true).split(";");
	    }
	    while(this.footers.length< this.counts.length)
		this.footers.push("");
	    while(this.headers.length< this.counts.length)
		this.headers.push("");
	    this.showBlocks(true);

	    this.setContents(
		HU.div([CLASS,"display-blocks-header",STYLE, this.getProperty("headerStyle","", true),ID,this.domId(ID_BLOCKS_HEADER)]) +
		    HU.div([CLASS,"display-blocks-blocks",ID,this.domId(ID_BLOCKS)])+
		    HU.div([CLASS,"display-blocks-footer", STYLE, this.getProperty("footerStyle","", true), ID,this.domId(ID_BLOCKS_FOOTER)]));
	    //Show the outline
	    this.showBlocks(false);
	    if(this.getProperty("displayOnScroll")) {
		HU.callWhenScrolled(this.domId(ID_DISPLAY_CONTENTS),()=>{
		    if(!this.displayedBlocks) {
			this.displayedBlocks = true;
			setTimeout(()=>{this.showBlocks(false)},this.getPropertyAnimStep());
		    }
		},500);
	    }
	},
	showBlocks: function(initial, step) {
	    if(!Utils.isDefined(step)) {
		if(initial)step = this.counts.length;
		else step = 0;
	    }
	    let contents = "";
	    contents += HU.openDiv([CLASS,"display-blocks"]);
	    let tmp =this.getProperty("colors","#d73027,#fdae61,#74add1,#423E3B,red,green,blue",true); 
	    let ct = (typeof tmp) =="string"?tmp.split(","):tmp;
	    let footer ="";
	    while(ct.length<this.counts.length) {
		ct.push(ct[ct.length-1]);
	    }


	    let multiplier = parseFloat(this.getProperty("multiplier","1",true));
	    let dim=this.getProperty("blockDimensions","8",true);
	    let labelStyle = this.getProperty("labelStyle","", true);
	    let blockCnt = 0;
	    let iconProp = this.getProperty("blockIcon");
	    let clazz = iconProp?"display-block-icon":"display-block";
	    for(var i=0;i<this.counts2.length;i++) {
		let num = multiplier*this.counts[i];
		if(isNaN(num)) num = 0;
		let label = this.footers[i].replace("${count}",Utils.formatNumberComma(num));
		let style =  iconProp?"":"width:" + dim+"px;height:" + dim+"px;";
		let iconStyle = "";
		if(!initial) {
		    if(i<step) {
			if(!iconProp)
			    style += "background:" + ct[i]+";" ;
			else
			    iconStyle+="color:" + ct[i]+";";
			let footerIcon =  iconProp?HU.getIconImage(iconProp, null, [STYLE, iconStyle]):"";
			footer += HU.div([CLASS,clazz,STYLE,style],footerIcon) +" " + HU.span([STYLE,labelStyle], label)+"&nbsp;&nbsp;";
		    } else {
			footer += "&nbsp;&nbsp;";
		    }
		}
		let icon = iconProp?HU.getIconImage(iconProp, null, [STYLE, iconStyle]):"";
		let cnt = this.counts2[i];
		for(let j=0;j<10000 && j<this.counts2[i];j++) {
		    contents += HU.div([CLASS,clazz,STYLE,style,TITLE,label],icon);
		}
		blockCnt++;
	    }

	    contents += HU.closeDiv();
	    let header = this.getProperty("header","");
	    header = header.replace("${total}",Utils.formatNumberComma(this.total)).replace("${blockValue}", Utils.formatNumberComma(Math.round(this.blockValue)));

	    this.jq(ID_BLOCKS_HEADER).html(header);
	    this.jq(ID_BLOCKS).html(contents);
	    this.jq(ID_BLOCKS_FOOTER).html(footer);
	    if(step < this.counts.length) {
		if(this.getPropertyAnimStep()==0) {
		    this.showBlocks(false, step+1);
		} else {
		    setTimeout(()=>{this.showBlocks(false, step+1)},this.getPropertyAnimStep());
		}
	    }
	}
    });
}





function RamaddaTextstatsDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTSTATS, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        updateUI: function() {
            var cnt = {};
            var fieldInfo = this.processText(cnt);
            if (fieldInfo == null) return;
            let records = this.filterData();
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;

            var strings = this.getFieldsByType(fields, "string");
            let _this = this;
            var divs = "";
            var words = [];
            var html = "";
            var counts = [];
            var maxWords = parseInt(this.getProperty("maxWords", -1));
            var minCount = parseInt(this.getProperty("minCount", 0));
            var showBars = this.getProperty("showBars", true);
            var scale = this.getProperty("barsScale", 10);
            var barColor = this.getProperty("barColor", "blue");

            var barWidth = parseInt(this.getProperty("barWidth", "400"));
            for (a in fieldInfo) {
                var fi = fieldInfo[a];
                let field = fi.field;
                for (word in fi.counts) {
                    var count = fi.counts[word];
                    counts.push({
                        word: word,
                        count: count
                    });
                }
                counts.sort(function(a, b) {
                    if (a.count < b.count) return -1;
                    if (a.count > b.count) return 1;
                    return 0;
                });
                if (minCount > 0) {
                    var tmp = [];
                    for (var i = 0; i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                if (maxWords > 0) {
                    var tmp = [];
                    for (var i = 0; i <= maxWords && i < counts.length; i++) {
                        if (counts[i].count >= minCount)
                            tmp.push(counts[i]);
                    }
                    counts = tmp;
                }

                var min = 0;
                var max = 0;
                if (counts.length > 0) {
                    max = counts[0].count;
                    min = counts[counts.length - 1].count;
                }

                var tmp = [];
                for (a in cnt.lengths) {
                    tmp.push({
                        length: parseInt(a),
                        count: cnt.lengths[a]
                    });
                }
                tmp.sort(function(a, b) {
                    if (a.length < b.length) return -1;
                    if (a.length > b.length) return 1;
                    return 0;
                });
                var min = 0;
                var max = 0;
                for (var i = 0; i < tmp.length; i++) {
                    max = (i == 0 ? tmp[i].count : Math.max(max, tmp[i].count));
                    min = (i == 0 ? tmp[i].count : Math.min(min, tmp[i].count));
                }
                if (this.getProperty("showFieldLabel", true))
                    html += HU.b(fi.field.getLabel()) + "<br>";
                var td1Width = "20%";
                var td2Width = "10%";
                if (this.getProperty("showSummary", true)) {
                    html += HU.openTag("table", [CLASS, "nowrap ramadda-table", ID, this.domId("table_summary")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Summary") + HU.th([], "&nbsp;"));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    html += HU.tr([], HU.td(["align", "right"], "Total lines:") + HU.td([], records.length));
                    html += HU.tr([], HU.td(["align", "right"], "Total words:") + HU.td([], cnt.count));
                    html += HU.tr([], HU.td(["align", "right"], "Average word length:") + HU.td([], Math.round(cnt.total / cnt.count)));
                    html += HU.closeTag("tbody");

                    html += HU.closeTag("table");
                    html += "<br>"
                }
                if (this.getProperty("showCounts", true)) {
                    html += HU.openTag("table", [CLASS, "row-border nowrap ramadda-table", ID, this.domId("table_counts")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Word Length") + HU.th(["width", td2Width], "Count") + (showBars ? HU.th([], "") : ""));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    for (var i = 0; i < tmp.length; i++) {
                        var row = HU.td([], tmp[i].length) + HU.td([], tmp[i].count);
                        if (showBars) {
                            var wpercent = (tmp[i].count - min) / max;
                            var width = 2 + wpercent * barWidth;
                            var color = barColor;
                            var div = HU.div([STYLE, "height:10px;width:" + width + "px;background:" + color], "");
                            row += HU.td([], div);
                        }
                        html += HU.tr([], row);
                    }
                    html += HU.closeTag("tbody");
                    html += HU.closeTag("table");
                    html += "<br>"
                }
                if (this.getProperty("showFrequency", true)) {
                    html += HU.openTag("table", [CLASS, "row-border ramadda-table", ID, this.domId("table_frequency")]);
                    html += HU.openTag("thead", []);
                    html += HU.tr([], HU.th(["width", td1Width], "Word") + HU.th(["width", td2Width], "Frequency") + (showBars ? HU.th([], "") : ""));
                    html += HU.closeTag("thead");
                    html += HU.openTag("tbody", []);
                    var min = 0;
                    var max = 0;
                    if (counts.length > 0) {
                        min = counts[0].count;
                        max = counts[counts.length - 1].count;
                    }
                    var totalWords = 0;
                    for (var i = 0; i < counts.length; i++) {
                        totalWords += counts[i].count;
                    }
                    for (var i = counts.length - 1; i >= 0; i--) {
                        var percent = Math.round(10000 * (counts[i].count / totalWords)) / 100;
                        var row = HU.td([], counts[i].word + "&nbsp;:&nbsp;") +
                            HU.td([], counts[i].count + "&nbsp;&nbsp;(" + percent + "%)&nbsp;:&nbsp;");
                        if (showBars) {
                            var wpercent = (counts[i].count - min) / max;
                            var width = 2 + wpercent * barWidth;
                            var color = barColor;
                            var div = HU.div([STYLE, "height:10px;width:" + width + "px;background:" + color], "");
                            row += HU.td([], div);
                        }
                        html += HU.tr([], row);
                    }
                    html += HU.closeTag("tbody");
                    html += HU.closeTag("table");
                }
            }
            this.setContents(html);
            var tableHeight = this.getProperty("tableHeight", "200");

            if (this.getProperty("showSummary", true))
                HU.formatTable("#" + this.domId("table_summary"), {
                    scrollY: this.getProperty("tableSummaryHeight", tableHeight)
                });
            if (this.getProperty("showCounts", true))
                HU.formatTable("#" + this.domId("table_counts"), {
                    scrollY: this.getProperty("tableCountsHeight", tableHeight)
                });
            if (this.getProperty("showFrequency", true)) {
                this.frequencyTable = HU.formatTable("#" + this.domId("table_frequency"), {
		    scrollY: this.getProperty("tableFrequenecyHeight", tableHeight),
		    searching: this.getProperty("showSearch", true)
		});
		this.frequencyTable.on( 'search.dt', ()=>{
		    if(this.settingSearch) return;
		    this.propagateEvent("handleEventPropertyChanged", {
			property: "searchValue",
			value: this.frequencyTable.search()
		    });

		} );
	    }
	    
        },
        handleEventPropertyChanged: function(source, prop) {
            if (prop.property == "searchValue") {
		this.settingSearch=true;
		this.setProperty("searchValue", prop.value);
		this.frequencyTable.search(prop.value);
		this.frequencyTable.draw();
		this.settingSearch=false;
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this,source, prop);
	},

    });
}



function RamaddaFrequencyDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_FREQUENCY, properties);
    let myProps = [
	{label:'Frequency'},
	{p:'orientation',ex:'vertical'},
	{p:'tableHeight',ex:'300px'},
	{p:'showPercent',ex:'false'},
	{p:'showCount',ex:'false'},
	{p:'showBars',ex:'true'},
	{p:'showBars',ex:'false'},
	{p:'showHeader',ex:'false'},
	{p:'banner',ex:'true'},
	{p:'barWidth',ex:'200'},
	{p:'clickFunction',ex:'selectother'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        updateUI: function() {
            let records = this.filterData();
	    if(!records) return;
            let allFields = this.getData().getRecordFields();
            let fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
	    let summary={};
	    for (let col = 0; col < fields.length; col++) {
		let f = fields[col];
		if(!Utils.isDefined(summary[f.getId()])) {
		    summary[f.getId()] = {
			counts:{},
			values:[],
			min:null,
			max:null,
			total:0,
			numbers:[],
			field:f
		    }
		}
	    }

	    let showCount = this.getProperty("showCount",true);
	    let showPercent = this.getProperty("showPercent",true);
	    let showBars = this.getProperty("showBars",false);
	    let barWidth = +this.getProperty("barWidth",200);

            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
                let row = this.getDataValues(records[rowIdx]);
                for (let col = 0; col < fields.length; col++) {
                    let f = fields[col];
		    let s = summary[f.getId()];
                    let value =  row[f.getIndex()];
		    if(!Utils.isDefined(s.min)) {
			s.min=value;
			s.max=value;
		    }
		    if(f.isNumeric()) {
			s.numbers.push(value);
			if(isNaN(s.max)) s.max = value;
			else if(!isNaN(value))s.max = Math.max(value,s.max);
			if(isNaN(s.min)) s.min = value;
			else if(!isNaN(value))s.min = Math.min(value,s.min);
		    } else {
			if(!Utils.isDefined(s.counts[value])) {
			    let tuple = {value:value,count:0}
			    s.counts[value] = tuple;
			    s.values.push(tuple);
			}
			s.total++;
			s.counts[value].count++;
		    }
                }
	    }
	    let html = "";
	    let bannerHtml = "";
	    for (let col = 0; col < fields.length; col++) {
		bannerHtml += "<div style='text-align:center;'>";
		let f = fields[col];
		let s = summary[f.getId()];
		//		if(col>0) html+="<br>";
		if(f.isNumeric()) {
		    let numBins = parseFloat(this.getProperty("numBins",10,true));
		    s.bins = [];
		    let range = s.max-s.min;
		    let binWidth = (s.max-s.min)/numBins;
		    let label = "Not defined";
		    s.bins.push(label);
		    let tuple = {value:label,count:0}
		    s.counts[label] = tuple;
		    s.values.push(tuple);
                    let binsProp = this.getProperty(f.getId() +".bins");
		    let hasBins = Utils.stringDefined(binsProp);
		    let binValues;
                    if(hasBins) {
                        let l  = binsProp.split(",");
			binValues = [];
			l.map(v=>binValues.push(+v));
                        for(let i=0;i<l.length-1;i++) {
			    let v1 = +l[i];
			    let v2 = +l[i+1];
			    let label = v1 +" - " + v2;
			    s.bins.push(label);
			    let tuple = {value:label,count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
                        }
		    } else {
			for(let i=0;i<numBins;i++) {
			    let label = (Utils.formatNumber(s.min+binWidth*i)) +" - " + Utils.formatNumber(s.min+binWidth*(i+1));
			    s.bins.push(label);
			    let tuple = {value:label,count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
			}
		    }
		    for(let i=0;i<s.numbers.length;i++) {
			let value = s.numbers[i];
			let bin=0;
			if(!isNaN(value)) {
			    if(binValues) {
				for(let j=0;j<binValues.length-1;j++) {
				    if(value>=binValues[j] && value< binValues[j+1]) {
					bin = j;
					break;
				    }
				}
			    } else {
				if(binWidth!=0) {
				    let perc = (value-s.min)/range;
				    bin = Math.round(perc/(1/numBins))+1;
				    if(bin>numBins) bin = numBins;
				}
			    }
			}
			let label = s.bins[bin]; 
			if(!Utils.isDefined(s.counts[label])) {
			    let tuple = {value:s.bins[bin],count:0}
			    s.counts[label] = tuple;
			    s.values.push(tuple);
			}
			s.total++;
			s.counts[label].count++;
		    }
		}

		let hor = this.getProperty("orientation","") != "vertical";
		if(this.getProperty("floatTable") !=null) {
		    hor = this.getProperty("floatTable")==true;
		}
		html += HU.openTag("div", [CLASS,"display-frequency-table",STYLE,hor?"":"display:block;"]);
		html += HU.openTag("table", ["cellpadding","3",ID,this.domId("summary"+col),"table-height",this.getProperty("tableHeight","300",true), CLASS, "stripe row-border nowrap ramadda-table"]);
		if(this.getProperty("showHeader",true)) {
		    html += HU.openTag("thead", []);
		    let label =  HU.span([TITLE,"Click to reset",CLASS,"display-frequency-label","data-field",s.field.getId()],f.getLabel());

		    
		    label = HU.div([STYLE,"max-width:500px;overflow-x:auto;"], label);
		    let count = showCount? HU.th(["align","right","width","20%"],HU.div([STYLE,"text-align:right"],"Count")):"";
		    let percent  = showPercent?HU.th(["align","right","width","20%"],  HU.div([STYLE,"text-align:right"],"Percent")):"";
		    let bars = showBars? HU.th(["align","right","width",barWidth],HU.div([STYLE,"text-align:right"],"&nbsp;")):"";
		    html += HU.tr([], HU.th(["xxwidth","60%"],  label+ count+ percent+bars));
		    html += HU.closeTag("thead");
		}

		html += HU.openTag("tbody", []);
		let colors = this.getColorTable(true);
		let dfltColor = this.getProperty("barColor","blue");
		if(colors) {
		    for(let i=0;i<s.values.length;i++) {
			let value = s.values[i].value;
			if(i<colors.length)
			    s.values[i].color = colors[i];
			else
			    s.values[i].color = colors[colors.length-1];
		    }
		}

	    	if(!f.isNumeric()) {
		    s.values.sort((a,b)=>{
			if(a.count<b.count) return 1;
			if(a.count>b.count) return -1;
			return 0;
		    });
		}

		let maxPercent = 0;
		for(let i=0;i<s.values.length;i++) {
		    let count = s.values[i].count;
		    if(count==0) continue;
		    let perc = count/s.total;
		    maxPercent = Math.max(maxPercent, perc);
		}

		for(let i=0;i<s.values.length;i++) {
		    let value = s.values[i].value;
		    let label = value;
		    if(label=="") label="&lt;blank&gt;";
		    let count = s.values[i].count;
		    if(count==0) continue;
		    let perc = count/s.total;
		    value = value.replace(/\'/g,"&apos;");
		    let countLabel = count
		    let color = s.values[i].color;
		    if(!color) color = dfltColor;

		    if(showPercent) countLabel+=" (" + Math.round(perc*100)+"%)";
		    bannerHtml += HU.div([TITLE,"Click to select",CLASS," display-frequency-item","data-field",s.field.getId(),"data-value",value], value +"<br>" + countLabel);
		    let tdv = HU.td([], value);
		    let tdc =  (showCount?HU.td(["align", "right"], count):"");
		    let tdp =  showPercent?HU.td(["align", "right"], s.total==0?"0":Math.round(perc*100)+"%"):"";
		    let bw = perc/maxPercent;
		    let tdb = showBars?HU.td(["valign","center","width",barWidth], HU.div([TITLE,Math.round(perc*100)+"%",STYLE,"background:" + color+";height:10px;width:"+ (Math.round(bw*barWidth))+"px"],"")):"";
		    html += HU.tr([], 
					 tdv + tdc + tdp + tdb
					);
		}
		html += HU.close(TBODY,TABLE,DIV);
		bannerHtml += HU.close(TD);
	    }

	    let doBanner = this.getProperty("banner",false);
	    if(doBanner) html = HU.div([CLASS,"display-frequency-banner"], bannerHtml);
	    this.setContents(html);
	    let _this = this;
	    let cnt = 0;
	    let items = this.find(".display-frequency-item");
	    items.click(function(){
		let click = _this.getProperty("clickFunction")
		let value = $(this).attr("data-value");
		let fieldId = $(this).attr("data-field");
		let parent = $(this).parent();
		let isSelected = $(this).hasClass("display-frequency-item-selected");
		items.removeClass("display-frequency-item-selected");
		if(!isSelected) {
		    $(this).addClass("display-frequency-item-selected");
		} else {
		    value = FILTER_ALL;
		}
		if(!click || click =="select") {
		    _this.handleEventPropertyChanged(_this,{
			property: "pattern",
			fieldId: fieldId,
			value: value
		    });
		} else if(click == "selectother") {
		    _this.propagateEvent("handleEventPropertyChanged", {
			property: PROP_FILTER_VALUE,
			value: value,
			id:_this.getFilterId(fieldId),
			fieldId: fieldId,
		    });
		}
	    });
	    this.find(".display-frequency-label").click(function(){
		let field = $(this).attr("data-field");
		//		    _this.find("[data-field=" + field+"]").css("color","black");
		_this.handleEventPropertyChanged(_this,{
		    property: PROP_FILTER_VALUE,
		    id:ID,
		    fieldId: field,
		    value: "-all-"
		});
	    });

	    if(this.getProperty("showHeader",true)) {
		for (let col = 0; col < fields.length; col++) {
		    HU.formatTable("#" +this.domId("summary"+col),{});
		}
	    }
	}
    });
}

function RamaddaTextanalysisDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTANALYSIS, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        checkLayout: function() {
            this.updateUIInner();
        },
        updateUI: function() {
            var includes = "<script src='" + ramaddaBaseUrl + "/lib/compromise.min.js'></script>";
            this.writeHtml(ID_DISPLAY_TOP, includes);
            let _this = this;
            var func = function() {
                _this.updateUIInner();
            };
            setTimeout(func, 10);
        },
        updateUIInner: function() {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            let _this = this;
            this.setDisplayMessage("Processing text...");
            var func = function() {
                _this.updateUIInnerInner();
            };
            setTimeout(func, 10);
        },
        updateUIInnerInner: function() {
            let records = this.filterData();
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
	    var strings = this.getFieldsByIds(fields,"fields");
            if (strings.length == 0) {
		strings = this.getFieldsByType(fields, "string");
	    }
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
	    if(!this.lastRecords || this.lastRecords.length!= records.length) {
		this.lastRecords = records;
		var corpus = "";
		for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                    var row = this.getDataValues(records[rowIdx]);
                    var line = "";
                    for (var col = 0; col < strings.length; col++) {
			var f = fields[col];
			line += " ";
			line += row[f.getIndex()];
                    }
                    corpus += line;
		    corpus += "\n";
		}
		//		console.log("corpus:" + corpus.length +"\n" + corpus.substring(0,1000));
		this.nlp = window.nlp(corpus);
		//		console.log("after");
	    }
	    var nlp = this.nlp;
            var cols = [];
            if (this.getProperty("showPeople", false)) {
                cols.push(this.printList("People", nlp.people().out('topk')));
            }
            if (this.getProperty("showPlaces", false)) {
                cols.push(this.printList("Places", nlp.places().out('topk')));
            }
            if (this.getProperty("showOrganizations", false)) {
                cols.push(this.printList("Organizations", nlp.organizations().out('topk')));
            }
            if (this.getProperty("showTopics", false)) {
                cols.push(this.printList("Topics", nlp.topics().out('topk')));
            }
            if (this.getProperty("showNouns", false)) {
                cols.push(this.printList("Nouns", nlp.nouns().out('topk')));
            }
            if (this.getProperty("showVerbs", false)) {
                cols.push(this.printList("Verbs", nlp.verbs().out('topk')));
            }
            if (this.getProperty("showAdverbs", false)) {
                cols.push(this.printList("Adverbs", nlp.adverbs().out('topk')));
            }
            if (this.getProperty("showAdjectives", false)) {
                cols.push(this.printList("Adjectives", nlp.adjectives().out('topk')));
            }
            if (this.getProperty("showClauses", false)) {
                cols.push(this.printList("Clauses", nlp.clauses().out('topk')));
            }
            if (this.getProperty("showContractions", false)) {
                cols.push(this.printList("Contractions", nlp.contractions().out('topk')));
            }
            if (this.getProperty("showPhoneNumbers", false)) {
                cols.push(this.printList("Phone Numbers", nlp.phoneNumbers().out('topk')));
            }
            if (this.getProperty("showValues", false)) {
                cols.push(this.printList("Values", nlp.values().out('topk')));
            }
            if (this.getProperty("showAcronyms", false)) {
                cols.push(this.printList("Acronyms", nlp.acronyms().out('topk')));
            }
            if (this.getProperty("showNGrams", false)) {
                cols.push(this.printList("NGrams", nlp.ngrams().out('topk')));
            }
            if (this.getProperty("showDates", false)) {
                cols.push(this.printList("Dates", nlp.dates().out('topk')));
            }
            if (this.getProperty("showQuotations", false)) {
                cols.push(this.printList("Quotations", nlp.quotations().out('topk')));
            }
            if (this.getProperty("showUrls", false)) {
                cols.push(this.printList("URLs", nlp.urls().out('topk')));
            }
            if (this.getProperty("showStatements", false)) {
                cols.push(this.printList("Statements", nlp.statements().out('topk')));
            }
            if (this.getProperty("showTerms", false)) {
                cols.push(this.printList("Terms", nlp.terms().out('topk')));
            }
            if (this.getProperty("showPossessives", false)) {
                cols.push(this.printList("Possessives", nlp.possessives().out('topk')));
            }
            if (cols.length == 0) {
                this.setDisplayMessage("No text types specified");
                return;
            }
            var height = this.getProperty("height", "400");
            var html = HU.openTag("div", [ID, this.domId("tables")]);

            for (var i = 0; i < cols.length; i += 3) {
                var c1 = cols[i];
                var c2 = i + 1 < cols.length ? cols[i + 1] : null;
                var c3 = i + 2 < cols.length ? cols[i + 2] : null;
                var width = c2 ? (c3 ? "33%" : "50%") : "100%";
                var style = "padding:5px";
                var row = "";
                row += HU.td(["width", width], HU.div([STYLE, style], c1));
                if (c2)
                    row += HU.td(["width", width], HU.div([STYLE, style], c2));
                if (c3)
                    row += HU.td(["width", width], HU.div([STYLE, style], c3));
                html += HU.tag("table", ["width", "100%"], HU.tr(row));
            }
            html += HU.closeTag("div");
            this.setContents(html);
            HU.formatTable("#" + this.domId("tables") + " .ramadda-table", {
                scrollY: this.getProperty("tableHeight", "200")
            });
        },
        printList: function(title, l) {
            var maxWords = parseInt(this.getProperty("maxWords", 10));
            var minCount = parseInt(this.getProperty("minCount", 0));
            var table = HU.openTag("table", ["width", "100%", CLASS, "stripe hover ramadda-table"]) + HU.openTag("thead", []);
            table += HU.tr([], HU.th([], title) + HU.th([], "&nbsp;"));
            table += HU.close(THEAD);
            table += HU.open(TBODY);
            var cnt = 0;
            for (var i = 0; i < l.length; i++) {
                if (l[i].count < minCount) continue;
                var row = HU.td([], l[i].normal) +
                    HU.td([], l[i].count + " (" + l[i].percent + "%)");
                table += HU.tr([], row);
                if (cnt++ > maxWords) break;
            }
            table += HU.close(TBODY,TABLE);
            return table;
        }
    });
}


function RamaddaTextrawDisplay(displayManager, id, properties) {
    const ID_TEXT = "text";
    const ID_OVERLAY = "overlay";
    const ID_OVERLAY_TABLE = "overlaytable";
    const ID_LABEL = "label";
    const ID_SEARCH = "search";
    const ID_HIGHLIGHT = "highlight"; 
    const ID_SHRINK = "shrink";
    const SUPER = new RamaddaBaseTextDisplay(displayManager, id, DISPLAY_TEXTRAW, properties);
    let myProps = [
	{label:'Raw Text'},
	{p:'doBubble',ex:'true'},
	{p:'addLineNumbers',ex:'false'},
	{p:'labelTemplate',ex:'${lineNumber}'},
	{p:'maxLines',ex:'1000'},
	{p:'pattern',ex:'initial search pattern'},
	{p:'fromField',ex:''},
	{p:'linesDescriptor',ex:''},
	{p:'asHtml',ex:'false'},
	{p:'breakLines',ex:'true'},
	{p:'includeEmptyLines',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	doShrink: properties["initialShrink"],
        checkLayout: function() {
            this.updateUI();
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) {
                return null;
            }
            var pointData = this.getData();
            this.allRecords = pointData.getRecords();
            var pattern = this.getProperty("pattern");
            if (pattern && pattern.length == 0) pattern = null;
	    if(pattern) pattern = pattern.replace(/"/g,"&quot;");
	    let input = "";
	    if(!this.filters || this.filters.length==0) 
		input += " " + HU.input("pattern", (pattern ? pattern : "") , ["placeholder", "Search text", ID, this.domId(ID_SEARCH)]);
	    this.showShrink = this.getProperty("showShrink",false);
	    if(this.showShrink) {
		input += " " + HU.checkbox("shrink",[ID,this.domId(ID_SHRINK)], this.getProperty("initialShrink", true)) +" Shrink ";
	    }

            this.writeHtml(ID_TOP_RIGHT, HU.span([ID,this.domId(ID_LABEL)]," ") + input);
            let _this = this;
	    this.jq(ID_SHRINK).click(function() {
		_this.doShrink = _this.jq(ID_SHRINK).is(':checked');
		_this.setProperty("initialShrink",_this.doShrink);
		_this.updateUI();
	    });
            this.jq(ID_SEARCH).keypress(function(event) {
                if (event.which == 13) {
                    _this.setProperty("pattern", $(this).val());
		    _this.propagateEvent("handleEventPropertyChanged", {
			property: "pattern",
			value: $(this).val()
		    });
                    _this.updateUI();
                }
            });
            var height = this.getProperty("height", "600");
	    var style = this.getProperty("displayInnerStyle","");
            var html = HU.div([ID, this.domId(ID_TEXT), STYLE, "padding:4px;border:1px #ccc solid; max-height:" + height + "px;overflow-y:auto;" + style]);
            this.setContents(html);
	    let t1 = new Date();
            this.showText();
	    let t2 = new Date();
//	    Utils.displayTimes("T",[t1,t2]);
        },
        handleEventPropertyChanged: function(source, prop) {
            if (prop.property == "pattern") {
		this.setProperty("pattern", prop.value);
		this.updateUI();
		return;
	    }
            SUPER.handleEventPropertyChanged.call(this,source, prop);
	},

        showText: function() {
	    let _this  = this;
            let records = this.filterData();
            if (!records) {
                return null;
            }
	    this.records = records;
 	    this.recordToIndex = {};
	    this.indexToRecord = {};
            var pattern = this.getProperty("pattern");
            if (pattern && pattern.length == 0) pattern = null;
	    var asHtml = this.getProperty("asHtml", true);
            var addLineNumbers = this.getProperty("addLineNumbers", true);
	    var labelTemplate = this.getProperty("labelTemplate","");
	    var labelWidth = "10px";
	    if(labelTemplate == "") {
		labelWidth = "1px";
	    }
	    if(labelTemplate == "" && addLineNumbers) {
		labelTemplate = "${lineNumber}";
	    }

            if (labelTemplate) asHtml = true;
            var maxLines = parseInt(this.getProperty("maxLines", 100000));
            var lineLength = parseInt(this.getProperty("lineLength", 10000));
            var breakLines = this.getProperty("breakLines", true);


            var includeEmptyLines = this.getProperty("includeEmptyLines", false);
            var allFields = this.getData().getRecordFields();
            var fields = this.getSelectedFields(allFields);
            if (fields.length == 0)
                fields = allFields;
            var strings = this.getFieldsByType(fields, "string");
            if (strings.length == 0) {
                this.displayError("No string fields specified");
                return null;
            }
	    var highlights;
	    var highlightStyles;
	    if(this.getProperty("highlights")) {
		highlights=[];
		highlightStyles = this.getProperty("highlightStyles","background:rgb(250_comma_0_comma_0);").split(",");
		this.getProperty("highlights","").split(",").map(h=>{
		    if(h.indexOf("(")<0) h = "(" + h +")";
		    highlights.push(RegExp(h,'ig'));
		});
	    }

            var corpus = HU.openTag("div", [STYLE,"position:relative;"]);
	    corpus+=HU.div([ID,this.domId(ID_OVERLAY),STYLE,"position:absolute;top:0;left:0;"],
				  HU.tag("table",[ID,this.domId(ID_OVERLAY_TABLE)]));

	    var fromField = this.getFieldById(null,this.getProperty("fromField"));
	    var bubble=this.getProperty("doBubble",false);
            if (labelTemplate) {
                corpus += "<table width=100%>";
            }
            var lineCnt = 0;
            var displayedLineCnt = 0;
	    var patternMatch = new TextMatcher(pattern);
	    var regexpMaps = {};
	    var filterFieldMap = {};
	    if(this.filters) {
		this.filters.map(f=>{if(f.field && f.field.isString)filterFieldMap[f.field.getId()]=f;});
	    }
	    var templates = {};
	    fields.map(f=>{
		templates[f.getId()] = this.getProperty(f.getId() +".template");
	    });
            var colorBy = this.getColorByInfo(records);
	    var delimiter = this.getProperty("delimiter","");
	    var rowScale = this.showShrink?this.getProperty("rowScale",0.3):null;

	    if(this.showShrink) {
		corpus+=HU.tr([],HU.td([],HU.getIconImage("fa-caret-down")));
	    }
	    let templateFields = this.getFields();
	    let templateProps = this.getTemplateProps(templateFields);	    
	    let templateMacros = Utils.tokenizeMacros(labelTemplate?labelTemplate:"");
            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
		var record = records[rowIdx];
		if(!Utils.isDefined(record.lineNumber)) {
		    record.lineNumber = (rowIdx+1);
		}
		this.indexToRecord[rowIdx] = record;
		this.recordToIndex[record.getId()] = rowIdx;
                var row = this.getDataValues(record);
                var line = "";
                for (var col = 0; col < fields.length; col++) {
                    var f = fields[col];
		    if(rowIdx==0) {
			if(filterFieldMap[f.getId()]) {
			    let filter = filterFieldMap[f.getId()];
			    var value = filter.getFieldValues();
			    if(value) {
				if(!Array.isArray(value)) {
				    value = [value];
				}
				try {
				    regexpMaps[f.getId()] =  [];
				    value.map(v=>{
					if(v == "" || v == FILTER_ALL) return;
					var re = new TextMatcher(v);
					regexpMaps[f.getId()].push(re);
				    })
				} catch(e) {console.log("Error making regexp:" + e);}
			    }
			}
		    }
		    var value = ""+row[f.getIndex()];
                    value = value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
		    if(regexpMaps[f.getId()]) {
			regexpMaps[f.getId()].map(re=>{
			    value  = re.highlight(value);
			});
		    }
		    
		    if(line!="") 
			line += delimiter+" ";
		    if(templates[f.getId()]) {
			value = templates[f.getId()].replace("${value}",value);
		    }
                    line += value;
                }
                line = line.trim();
                if (!includeEmptyLines && line.length == 0) continue;
                lineCnt++;
		var rowAttrs =["valign", "top"];
		var rowStyle="";
                if (colorBy.index >= 0) {
		    var value = record.getData()[colorBy.index];
		    var color =  colorBy.getColor(value, record);
		    if(color) {
			rowAttrs.push(STYLE);
			rowStyle +="background:" + Utils.addAlphaToColor(color,"0.25")+";";
		    }
                }
		rowAttrs.push(CLASS);
		rowAttrs.push("display-raw-row");
		var matches=patternMatch.matches(line);
		var hasMatch = matches && patternMatch.hasPattern();
		if(hasMatch) {
		    rowAttrs.push("matched");
		    rowAttrs.push(true);
		}
		if(rowScale) {
		    if(!hasMatch) {
			rowStyle += "-webkit-transform: scale(1," + rowScale +");";
			rowStyle += "line-height:"+ rowScale +";";
			rowAttrs.push(STYLE);
			rowAttrs.push(rowStyle);
		    }
		} else  if(!matches) {
		    continue;
		}
                line = patternMatch.highlight(line);
                displayedLineCnt++;
                if (displayedLineCnt > maxLines) break;
		let lineAttrs = [TITLE," ",CLASS, " display-raw-line ",RECORD_INDEX,rowIdx]
		if(bubble) line = HU.div([CLASS,"ramadda-bubble"],line);
		if(fromField) line+=HU.div([CLASS,"ramadda-bubble-from"],  ""+row[fromField.getIndex()]);

		if(highlights) {
		    for(var hi=0;hi<highlights.length;hi++) {
			var h = highlights[hi];
			var s = hi<highlightStyles.length?highlightStyles[hi]:highlightStyles[highlightStyles.length-1];
			s = s.replace(/_comma_/g,",");
			line= line.replace(h, "<span style='" + s +"'>$1</span>");
		    }
		}
		line = HU.div(lineAttrs,line);
                if (labelTemplate) {
		    let row = this.getDataValues(record);
		    let label = this.applyRecordTemplate(record, row, templateFields,labelTemplate, templateProps,templateMacros);
		    var num = record.lineNumber;
		    if(!Utils.isDefined(num)) {
			num - lineCnt;
		    }
		    label = label.replace("${lineNumber}", "#" +(num));
		    label = label.replace(/ /g,"&nbsp;");
		    var r =  "";
		    if(this.showShrink) {
			r+= HU.td([WIDTH, "5px",STYLE,HU.css('background','#ccc')],  HU.getIconImage("fa-caret-right",null, [STYLE,"line-height:0px;"]));
		    }
		    r+= HU.td([WIDTH, labelWidth], "<a name=line_" + lineCnt + "></a>" +
				     "<a href=#line_" + lineCnt + ">" + label + "</a>&nbsp;  ") +
			HU.td([], line);
		    corpus += HU.tr(rowAttrs, r);
                } else {
                    corpus += line;
                    if (asHtml) {
                        if (breakLines)
                            corpus += "<p>";
                        else
                            corpus += "<br>";
                    } else {
                        corpus += "\n";
                        if (breakLines)
                            corpus += "\n";
                    }
                }
            }
            if (addLineNumbers) {
                corpus += HU.close(TABLE);
            }
            corpus+= HU.close(DIV);

            if (!asHtml)
                corpus = HU.tag(PRE, [], corpus);
            this.writeHtml(ID_TEXT, corpus);
	    colorBy.displayColorTable();
	    var linesWord = " "+ this.getProperty("linesDescriptor","lines");
	    var label =displayedLineCnt +linesWord;
	    if(this.allRecords.length!=displayedLineCnt) {
		label = displayedLineCnt+"/" + this.allRecords.length+linesWord+" (" + Math.round(displayedLineCnt/this.allRecords.length*100)+"%)";
	    }
	    this.jq(ID_LABEL).html(label);
	    this.jq(ID_SEARCH).focus();
	    if(rowScale) {
		var rows =  this.jq(ID_TEXT).find(".display-raw-row");
		var open = function() {
		    $(this).css("transform","scaleY(1)");		    
		    $(this).css("line-height","1.5");
		    $(this).css("border-bottom","1px solid #ccc");
		    $(this).css("border-top","1px solid #ccc");
		};
		var close = function() {
		    var row = this;
		    if(!$(row).attr("matched")) {	
			$(row).css("transform","scaleY(" + rowScale +")");
			$(row).css("line-height",rowScale);
			$(row).css("border-bottom","0px solid #ccc");
			$(row).css("border-top","0px solid #ccc");
		    }
		}
		rows.each(close);
		rows.mouseenter(open);
		rows.mousemove(open);
		rows.mouseout(close);
	    }
	    let lines =this.jq(ID_TEXT).find(".display-raw-line");
	    lines.click(function() {
		var idx = $(this).attr(RECORD_INDEX);
		var record = _this.indexToRecord[idx];
		if(record) {
		    _this.showRecordPopup($(this),record);
		    _this.propagateEventRecordSelection({record: record});
		    _this.highlightLine(idx);
		}
	    });
	    this.makeTooltips(lines,records);
        },
	highlightLine: function(index) {
	    var container = this.jq(ID_TEXT);
	    container.find(".display-raw-line").removeClass("display-raw-line-selected");
	    var sel = HU.attrSelect(RECORD_INDEX,index);
	    var element =  container.find(sel);
	    element.addClass("display-raw-line-selected");

	},
        handleEventRecordSelection: function(source, args) {
	    var index = this.findMatchingIndex(args.record).index;
	    if(index<0 || !Utils.isDefined(index)) {
		return;
	    }
	    this.highlightLine(index);
	    var container = this.jq(ID_TEXT);
	    var sel = HU.attrSelect(RECORD_INDEX,index);
	    var element =  container.find(sel);
	    var c = container.offset().top;
	    var s = container.scrollTop();
	    var eo = element.offset();
	    var diff = eo.top- c + s;
	    container.scrollTop(diff)
	},
    });
}


function RamaddaTextDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_TEXT, properties);
    let myProps = [
	{label:'Text Display'},
	{p:'recordTemplate',ex:''},
	{p:'showDefault',d:true,ex:"false"},
	{p:'message',d:null,ex:""},
    ];
    if(!properties["recordTemplate"]) {
	properties["recordTemplate"] = "${default}";
    }

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	handleAnnotation: function() {
	    let annotation = null;
	    let template = this.getProperty("template","${date} - ${description}");
	    let  macros = Utils.tokenizeMacros(template);
	    let attrs = {};
	    let date = null;
	    if(this.selectedRecord) {
		annotation = this.annotations.getAnnotationFromDate(date = this.selectedRecord.getDate());
	    }
	    if(!annotation) {
		annotation = this.annotations.getAnnotationFromDate(date=this.getAnimation().getBeginTime());
	    }
	    if(date) {
		attrs.date = date;
	    }  else {
		attrs.date = "";
	    }
	    if(!annotation) {
		this.setContents("");
		return;
	    }
	    attrs.description = annotation.description;
	    attrs.label = annotation.label;
	    if(this.annotations.getShowLegend()) {
		attrs.legend  = this.annotations.getLegend();
	    } else {
		attrs.legend  = "";
	    }
	    let html =  macros.apply(attrs);
	    if(this.getProperty("decorate",true)) {
		html = this.getMessage(html);
	    }
	    this.setContents(html);
	},
	updateUI: function() {
            SUPER.updateUI.call(this);
	    if(this.getProperty("annotations")) {
		var pointData = this.getData();
		if (pointData == null) return;
		if(!this.annotations) {
		    this.annotations  = new Annotations(this,this.filterData());
		} 
		if(this.annotations.isEnabled()) {
		    this.handleAnnotation();
		    return;
		}
	    }
	    if(this.selectedRecord) {
		this.setContents(this.getRecordHtml(this.selectedRecord));
	    } else  if(this.getPropertyShowDefault()) {
		let records = this.filterData();
		if(records && records.length>0) {
		    this.setContents(this.getRecordHtml(records[0]));
		}
	    } else  if(this.getPropertyMessage()) {
		this.setDisplayMessage(this.getPropertyMessage());
	    }
        },
        handleEventRecordSelection: function(source, args) {
	    this.selectedRecord= args.record;
	    this.updateUI();
        }
    });
}




function RamaddaGlossaryDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_GLOSSARY, properties);
    const ID_GLOSSARY_HEADER = "glossary_header";
    let myProps = [
	{label:'Glossary'},
	{p:'wordField',ex:""},
	{p:'definitionField',ex:""},	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let wordField = this.getFieldById(null,this.getProperty("wordField"));
	    let definitionField = this.getFieldById(null,this.getProperty("definitionField"));	    
	    if(!wordField) {
                this.displayError("No word field specified");
                return;
	    }
	    if(!definitionField) {
                this.displayError("No definition field specified");
                return;
	    }	    
	    let letters = {};
	    records.forEach(record=>{
		let word = String(wordField.getValue(record)).trim();
		let definition = definitionField.getValue(record);
		let letter = word.substring(0,1).toUpperCase();
		let list = letters[letter] || (letters[letter] = []);
		list.push({word:word,definition:definition, record:record});
	    });
	    let highlight  = this.getFilterTextMatchers();
	    let header =  HU.div([CLASS,"display-glossary-letter"], "All");
	    let html = "";
	    Object.keys(letters).sort().forEach(letter=>{
		let _letter = letter.trim();
		_letter = _letter==""?"_":_letter;
		let clazz = " display-glossary-letter ";
		if(this.searchLetter == _letter) {
		    clazz+=" display-glossary-letter-highlight ";
		}
		header += HU.div([CLASS,clazz,"letter",_letter], _letter);
		if(this.searchLetter && this.searchLetter!=_letter) return;
		let group =  HU.div([CLASS,"display-glossary-group-header"],  _letter) +
		    HU.openTag(DIV,[CLASS,"display-glossary-group-inner"]);
		letters[letter].sort((a,b)=>{
		    return a.word.localeCompare(b.word);
		}).forEach(info=>{
		    let def = String(info.definition);
		    highlight.forEach(h=>{
			def  = h.highlight(def);
		    });

		    let entry  = HU.div([CLASS,"display-glossary-word"], info.word) + HU.div([CLASS,"display-glossary-definition"], def); 
		    group+=HU.div([TITLE,"",CLASS,"display-glossary-entry",RECORD_ID,info.record.getId()],entry);
		});
		group += HU.closeTag(DIV);
		html+=group;
	    });

	    let height = this.getProperty("glossaryHeight","600px");
	    header = HU.div([ID,this.domId(ID_GLOSSARY_HEADER), CLASS,"display-glossary-header"], header);
	    html = HU.div([STYLE,HU.css("max-height",HU.getDimension(height),"overflow-y","auto")], html);
	    this.setContents(header  + html);
	    let _this = this;
	    this.jq(ID_GLOSSARY_HEADER).find(".display-glossary-letter").click(function() {
		_this.searchLetter =  $(this).attr("letter");
		_this.forceUpdateUI();
	    });
	    this.makeTooltips(this.find(".display-glossary-entry"),records);
	},
    });
}



/**
Copyright 2008-2019 Geode Systems LLC
*/


let DISPLAY_ENTRYLIST = "entrylist";
let DISPLAY_TESTLIST = "testlist";
let DISPLAY_ENTRYDISPLAY = "entrydisplay";
let DISPLAY_ENTRY_GALLERY = "entrygallery";
let DISPLAY_ENTRY_GRID = "entrygrid";
let DISPLAY_OPERANDS = "operands";
let DISPLAY_METADATA = "metadata";
let DISPLAY_ENTRYTIMELINE = "entrytimeline";
let DISPLAY_REPOSITORIES = "repositories";
let DISPLAY_ENTRYTITLE = "entrytitle";
let DISPLAY_SEARCH  = "search";
let DISPLAY_SIMPLESEARCH  = "simplesearch";
let ID_RESULTS = "results";
let ID_SEARCH_HEADER = "searchheader";
let ID_SEARCH_BAR = "searchbar";
let ID_SEARCH_TAG = "searchtag";
let ID_SEARCH_TAG_GROUP = "searchtaggroup";
let ID_ENTRIES = "entries";
let ID_DETAILS_INNER = "detailsinner";
let ID_DETAILS_ANCESTORS = "detailsancestors";
let ID_DETAILS_TAGS= "detailstags";
let ID_PROVIDERS = "providers";
let ID_SEARCH_ORDERBY = "orderby";
let ID_SEARCH_SETTINGS = "searchsettings";
let ID_TREE_LINK = "treelink";
let ATTR_ENTRYID = "entryid";

let ID_SEARCH = "search";
let ID_FORM = "form";
let ID_TEXT_FIELD = "textfield";
let ID_TYPE_FIELD = "typefield";
let ID_TYPE_DIV = "typediv";
let ID_TYPEFIELDS = "typefields";
let ID_METADATA_FIELD = "metadatafield";
let ID_COLUMN = "column";




addGlobalDisplayType({
    type: DISPLAY_ENTRYLIST,
    label: "Entry List",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_SEARCH,
    label: "Entry Search",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
/*
addGlobalDisplayType({
    type: DISPLAY_TESTLIST,
    label: "Test  List",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
*/
addGlobalDisplayType({
    type: DISPLAY_ENTRYDISPLAY,
    label: "Entry Display",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRYTITLE,
    label: "Entry Title",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRY_GALLERY,
    label: "Entry Gallery",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
addGlobalDisplayType({
    type: DISPLAY_ENTRY_GRID,
    label: "Entry Date Grid",
    requiresData: false,
    category: CATEGORY_ENTRIES
});
//addGlobalDisplayType({type: DISPLAY_OPERANDS, label:"Operands",requiresData:false,category:CATEGORY_ENTRIES});
addGlobalDisplayType({
    type: DISPLAY_METADATA,
    label: "Metadata Table",
    requiresData: false,
    category: CATEGORY_ENTRIES
});



function RamaddaEntryDisplay(displayManager, id, type, properties) {
    let  SUPER = new RamaddaDisplay(displayManager, id, type, properties);
    RamaddaUtil.inherit(this, SUPER);
    this.defineProperties([
	{label:'Entry Search'},
	{p:'providers',ex:'',tt:'List of search providers'},
    ]);

    this.ramaddas = new Array();
    var repos = this.getProperty("repositories", this.getProperty("repos", null));
    if (repos != null) {
        var toks = repos.split(",");
        //OpenSearch;http://adasd..asdasdas.dasdas.,
        for (var i = 0; i < toks.length; i++) {
            var tok = toks[i];
            tok = tok.trim();
            this.ramaddas.push(getRamadda(tok));
        }
        if (this.ramaddas.length > 0) {
            var container = new RepositoryContainer("all", "All entries");
            addRepository(container);
            for (var i = 0; i < this.ramaddas.length; i++) {
                container.addRepository(this.ramaddas[i]);
            }
            this.ramaddas.push(container);
            this.setRamadda(this.ramaddas[0]);
        }
    }



    RamaddaUtil.defineMembers(this, {
        searchSettings: new EntrySearchSettings({
            parent: properties.entryParent,
            provider: properties.provider,
            text: properties.entryText,
            entryType: properties.entryType,
            orderBy: properties.orderBy,
	    entryRoot: properties.entryRoot,
        }),
        entryList: properties.entryList,
        entryMap: {},
	writeEntries: function(msg, entries) {
	    this.jq(ID_ENTRIES).html(msg);
	},
	writeMessage:function( msg)  {
	    this.jq(ID_RESULTS).html(msg);
	},
	writeResults: function(msg) {
	    this.jq(ID_RESULTS).html(msg);
	},
        getSearchSettings: function() {
            if (this.getPropertyProviders() != null) {
                var provider = this.searchSettings.provider;
		var select = this.jq(ID_PROVIDERS);
                var fromSelect = select.val();
                if (fromSelect != null) {
                    provider = fromSelect;
                } else {
                    var toks = this.getPropertyProviders().split(",");
                    if (toks.length > 0) {
                        var tuple = toks[0].split(":");
                        provider = tuple[0];
                    }
                }
                this.searchSettings.provider = provider;
            }
            return this.searchSettings;
        },
        getEntries: function() {
            if (this.entryList == null) return [];
            return this.entryList.getEntries();
        },

    });
    if (properties.entryType != null) {
        this.searchSettings.addType(properties.entryType);
    }
}






function RamaddaSearcherDisplay(displayManager, id,  type, properties) {
    let NONE = "-- None --";
    let myProps = [
	{label:'Search'},
        {p:"showForm",d: true},
        {p:"formOpen",d: true},	
        {p:"showOrderBy",ex: "true"},
        {p:"orderBy",ex: "name_ascending|name_descending|fromdate_ascending|fromdate_descending|todate_|createdate_|size_"},
        {p:"searchText",d: ""},
        {p:"orientation",ex:"horizontal|vertical",d:"horizontal"},
        {p:"showSearchSettings",d: true},
        {p:"showToggle",d: true},
        {p:"showEntries",d: true},
        {p:"showType",d: true},
        {p:"types",ex:'comma separated list of types'},
        {p:"doSearch",d: true},
        {p:"showMetadata",d: true},
        {p:"showTags",d: true},	
        {p:"showArea",d: true},
        {p:"showText",d: true},
        {p:"showDate",d: true},
        {p:"showCreateDate",ex:"true",d: false},	
        {p:"fields",d: null},
        {p:"formWidth",d: 0},
        {p:"entriesWidth",d: 0},
        {p:"entriesHeight",ex: "300px"},	
        {p:"showDetailsForGroup",d: false},
	{p:'doWorkbench',ex:'true', tt:'Show the new, charts, etc links'},
	];

    const SUPER = new RamaddaEntryDisplay(displayManager, id, type, properties);

    defineDisplay(this, SUPER, myProps, {
        metadataTypeList: [],
	haveSearched: false,
        haveTypes: false,
        metadata: {},
        metadataLoading: {},
	ctor: function() {
	    if (this.getProperty("showMetadata") && this.getProperty("showSearchSettings")) {
		let metadataTypesAttr = this.getProperty("metadataTypes", "enum_tag:Tag");
		//look for type:value:label, or type:label,
		let toks = metadataTypesAttr.split(",");
		for (let i = 0; i < toks.length; i++) {
		    let type = toks[i];
		    let label = type;
		    let value = null;
		    let subToks = type.split(":");
		    if (subToks.length > 1) {
			type = subToks[0];
			if (subToks.length >= 3) {
			    value = subToks[1];
			    label = subToks[2];
			} else {
			    label = subToks[1];
			}
		    }
		    this.metadataTypeList.push(new MetadataType(type, label, value));
		}
	    }
	},
        isLayoutHorizontal: function() {
	    return this.getOrientation()== "horizontal";
        },

	initHtml: function() {
	    if(this.areaWidget) this.areaWidget.initHtml();
	    if(this.getShowOrderBy()) {
		let settings = this.getSearchSettings();
		let byList = [["A-Z","name_ascending"],["Z-A","name_descending"],
			  ["Create date - oldest first","createdate_ascending"],
			  ["Create date - youngest first","createdate_descending"],
			  ["From date - oldest first","fromdate_ascending"],
			  ["From date - youngest first","fromdate_descending"],			  			  
			  ["Size - largest first","size_descending"],
			  ["Size - smallest first","size_ascending"]];			  
		let options = "";
		byList.forEach(tuple=>{
		    let label = tuple[0];
		    let by = tuple[1];
		    let extra = settings.orderBy==by?" selected ":""
		    options += "<option title='" + label+"'  " + "" + extra + " value=\"" + by + "\">" + label + "</option>\n";
		    
		});
		let select = HU.tag("select", ["id", this.getDomId(ID_SEARCH_ORDERBY), ATTR_CLASS, "display-search-orderby"], options);
		this.jq(ID_SEARCH_HEADER).append("Order by: "+ select);
	    }
            this.addExtraForm();
	},
        getDefaultHtml: function() {
            var html = "";
            var horizontal = this.isLayoutHorizontal();
            var footer = this.getFooter();
            if (!this.getProperty("showFooter", true)) {
                footer = "";
            }
	    this.jq(ID_BOTTOM).html(footer);
	    footer = "";
            var entriesDivAttrs = [ATTR_ID, this.getDomId(ID_ENTRIES), ATTR_CLASS, this.getClass("content")];
            var innerHeight = this.getProperty("innerHeight", null);
            var entriesStyle = this.getProperty("entriesStyle", "");	    
	    let style = "";
            if (innerHeight == null) {
                innerHeight = this.getEntriesHeight();
            }
            if (innerHeight != null) {
                style = "margin: 0px; padding: 0px;  xmin-height:" + HU.getDimension(innerHeight) + "; max-height:" + HU.getDimension(innerHeight) + "; overflow-y: auto;";
            }
	    style+= entriesStyle;
            entriesDivAttrs.push(ATTR_STYLE);
            entriesDivAttrs.push(style);	    
	    let searchBar = HU.div([CLASS,"display-search-bar",ID, this.domId(ID_SEARCH_BAR)],"");
            var resultsDiv = "";
            if (this.getProperty("showHeader", true)) {
                resultsDiv = HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)], "&nbsp;");
            }
	    resultsDiv = HU.leftRightTable(resultsDiv,HU.div([CLASS,"display-search-header", ID,this.domId(ID_SEARCH_HEADER)]),null,null,{valign:"bottom"});
            var entriesDiv =
		searchBar +
                resultsDiv +
                HU.div(entriesDivAttrs, this.getLoadingMessage());

            if (horizontal) {
                html += HU.openTag(TAG_DIV, ["class", "row"]);
                var entriesAttrs = ["class", "col-md-12"];
                if (this.getShowForm()) {
                    var attrs = [];
                    if (this.getFormWidth() === "") {
                        attrs = [];
                    } else if (this.getFormWidth() != 0) {
                        attrs = [ATTR_WIDTH, this.getFormWidth()];
                    }
                    html += HU.tag(TAG_DIV, ["class", "col-md-4"], this.makeSearchForm());
                    entriesAttrs = ["class", "col-md-8"];
                }
                if (this.getShowEntries()) {
                    var attrs = [ATTR_WIDTH, "75%"];
                    if (this.getEntriesWidth() === "") {
                        attrs = [];
                    } else if (this.getEntriesWidth() != 0) {
                        attrs = [ATTR_WIDTH, this.getEntriesWidth()];
                    }
                    html += HU.tag(TAG_DIV, entriesAttrs, entriesDiv);
                }
                html += HU.closeTag("row");

                html += HU.openTag(TAG_DIV, ["class", "row"]);
                if (this.getShowForm()) {
                    html += HU.tag(TAG_DIV, ["class", "col-md-6"], "");
                }
                if (this.getShowEntries()) {
                    if (this.getProperty("showFooter", true)) {
                        html += HU.tag(TAG_DIV, ["class", "col-md-6"], footer);
                    }
                }
                html += HU.closeTag(TAG_DIV);
            } else {
                if (this.getShowForm()) {
                    html += this.makeSearchForm();
                }
                if (this.getShowEntries()) {
                    html += entriesDiv;
                    html += footer;
                }
            }
            html += HU.div([ATTR_CLASS, "display-entry-popup", ATTR_ID, this.getDomId(ID_DETAILS)], "&nbsp;");
            return html;
        },
        initDisplay: function() {
            var theDisplay = this;

            this.jq(ID_SEARCH).click(function(event) {
                theDisplay.submitSearchForm();
                event.preventDefault();
            });

            this.jq(ID_TEXT_FIELD).autocomplete({
                source: function(request, callback) {
                    //                            theDisplay.doQuickEntrySearch(request, callback);
                }
            });

	    this.selectboxit(this.jq(ID_SEARCH_ORDERBY));
	    this.jq(ID_SEARCH_ORDERBY).change(()=>{	    
                this.submitSearchForm();
	    });
            this.selectboxit(this.jq(ID_REPOSITORY));
            this.jq(ID_REPOSITORY).change(function() {
                let v = theDisplay.jq(ID_REPOSITORY).val();
                let ramadda = getRamadda(v);
                theDisplay.setRamadda(ramadda);
                theDisplay.addTypes(null);
                theDisplay.typeChanged();
            });

            this.jq(ID_FORM).submit(function(event) {
                theDisplay.submitSearchForm();
                event.preventDefault();
            });


            this.addTypes(this.entryTypes);
            for (let i = 0; i < this.metadataTypeList.length; i++) {
                let type = this.metadataTypeList[i];
                this.addMetadata(type, null);
            }
            if (!this.haveSearched) {
                if (this.getDoSearch()) {
                    this.submitSearchForm();
                }
            }
        },
        showEntryDetails: async function(event, entryId, src, leftAlign) {
            if (true) return;
            var entry;
            await this.getEntry(entryId, e => {
                entry = e
            });
            var popupId = "#" + this.getDomId(ID_DETAILS + entryId);
            if (this.currentPopupEntry == entry) {
                this.hideEntryDetails(entryId);
                return;
            }
            var myloc = 'right top';
            var atloc = 'right bottom';
            if (leftAlign) {
                myloc = 'left top';
                atloc = 'left bottom';
            }
            this.currentPopupEntry = entry;
            if (src == null) src = this.getDomId("entry_" + entry.getIdForDom());
            var closeImage = HU.getIconImage(icon_close, []);
            var close = HU.onClick(this.getGet() + ".hideEntryDetails('" + entryId + "');",closeImage);

            var contents = this.getEntryHtml(entry, {
                headerRight: close
            });
            $(popupId).html(contents);
            $(popupId).show();
            /*
            $(popupId).position({
                    of: jQuery( "#" +src),
                        my: myloc,
                        at: atloc,
                        collision: "none none"
                        });
            */
        },

	getCloser: function() {
	    return "";
	    return  HU.jsLink("",HU.getIconImage(icon_close, [ID,this.domId("close"),STYLE,HU.css("cursor","pointer")]));
	},
	initCloser: function(what) {
	    this.jq("close").click(()=>{
		this.jq(what||ID_RESULTS).hide();
	    });
	},
        getResultsHeader: function(entries, includeCloser) {
            if (entries.length < 10) return entries.length+" result" +(entries.length>1?"s":"");
            var left = "Showing " + (this.searchSettings.skip + 1) + "-" + (this.searchSettings.skip + Math.min(this.searchSettings.max, entries.length));
            var nextPrev = [];
            var lessMore = [];
            if (this.searchSettings.skip > 0) {
                nextPrev.push(HU.onClick(this.getGet() + ".loadPrevUrl();", HU.getIconImage("fa-arrow-left", [ATTR_TITLE, "Previous"]), [ATTR_CLASS, "display-link"]));
            }
            var addMore = false;
            if (entries.length == this.searchSettings.getMax()) {
                nextPrev.push(HU.onClick(this.getGet() + ".loadNextUrl();", HU.getIconImage("fa-arrow-right", [ATTR_TITLE, "Next"]), [ATTR_CLASS, "display-link"]));
                addMore = true;
            }

            lessMore.push(HU.onClick(this.getGet() + ".loadLess();", HU.getIconImage("fa-minus", [ATTR_TITLE, "View less"]), [ATTR_CLASS, "display-link"]));
            if (addMore) {
                lessMore.push(HU.onClick(this.getGet() + ".loadMore();", HU.getIconImage("fa-plus", [ATTR_TITLE, "View more"]), [ATTR_CLASS, "display-link"]));
            }
            var results = "";
            var spacer = "&nbsp;&nbsp;&nbsp;"
	    if(includeCloser)
		results = this.getCloser();
	    results += "&nbsp;" + left + spacer;
            results += 
                HU.join(nextPrev, "&nbsp;") + spacer +
                HU.join(lessMore, "&nbsp;");
            return results+"<br>";
        },
        submitSearchForm: function() {
            if (this.fixedEntries) {
                return;
            }
            this.haveSearched = true;
            let settings = this.getSearchSettings();
            settings.text = this.getFieldValue(this.getDomId(ID_TEXT_FIELD), settings.text);
	    if(settings.text)
		HU.addToDocumentUrl(ID_TEXT_FIELD,settings.text);
	    else
		HU.addToDocumentUrl(ID_TEXT_FIELD,"");

	    let orderBy = this.jq(ID_SEARCH_ORDERBY).val();
	    if(orderBy) {
		let ascending = orderBy.indexOf("_ascending")>=0;
		orderBy = orderBy.replace("_ascending","").replace("_descending","");
		settings.orderBy =  orderBy;
		settings.ascending = ascending;
	    }

            if (this.textRequired && (settings.text == null || settings.text.trim().length == 0)) {
                this.writeEntries("");
                return;
            }



            if (this.haveTypes) {
                settings.entryType = this.getFieldValue(this.getDomId(ID_TYPE_FIELD), settings.entryType);
		if(settings.entryType) {
		    HU.addToDocumentUrl(ID_TYPE_FIELD,settings.entryType);
		} else {
		    HU.addToDocumentUrl(ID_TYPE_FIELD,"");
		}
            } else if(this.typeList && this.typeList.length==1) {
		settings.entryType = this.typeList[0];
	    }
            settings.clearAndAddType(settings.entryType);
            if (this.areaWidget) {
                this.areaWidget.setSearchSettings(settings);
            }
            if (this.dateRangeWidget) {
                this.dateRangeWidget.setSearchSettings(settings);
            }
            if (this.createdateRangeWidget) {
                this.createdateRangeWidget.setSearchSettings(settings);
            }	    
	    
            settings.metadata = [];
	    if(!this.getShowTags()) {
		for (var i = 0; i < this.metadataTypeList.length; i++) {
                    var metadataType = this.metadataTypeList[i];
                    var value = metadataType.getValue();
                    if (value == null) {
			value = this.getFieldValues(this.getMetadataFieldId(metadataType), null);
                    }
                    if (value != null) {
			if(!Array.isArray(value)) {value=[value]}
			value.forEach(v=>{
			    settings.metadata.push({
				type: metadataType.getType(),
				value: v
			    });
			});
                    }
		}
	    } else {
		let _this = this;
		this.jq(ID_SEARCH_BAR).find(".display-search-tag").each(function() {
		    let type  = $(this).attr("metadata-type");
		    let value  = $(this).attr("metadata-value");			
		    settings.metadata.push({
			type: type,
			value: value
		    });
		});
            }

            //Call this now because it sets settings


            var theRepository = this.getRamadda()

            if (theRepository.children) {
                this.entryList = new EntryListHolder(theRepository, this);
                this.multiSearch = {
                    count: 0,
                };

                for (var i = 0; i < theRepository.children.length; i++) {
                    var ramadda = theRepository.children[i];
                    var jsonUrl = this.makeSearchUrl(ramadda);
                    this.updateForSearching(jsonUrl);
                    this.entryList.addEntryList(new EntryList(ramadda, jsonUrl, null, false));
                    this.multiSearch.count++;
                }
                this.entryList.doSearch(this);
            } else {
                this.multiSearch = null;
                var jsonUrl = this.makeSearchUrl(this.getRamadda());
                console.log(jsonUrl);
                this.entryList = new EntryList(this.getRamadda(), jsonUrl, this, true);
                this.updateForSearching(jsonUrl);
            }
        },
        entryListChanged:function(entryList) {
	},
        handleSearchError: function(url, msg) {
            this.writeEntries("");
            this.writeMessagel( "");
            console.log("Error performing search:" + msg);
            //alert("There was an error performing the search\n" + msg);
        },
        updateForSearching: function(jsonUrl) {
            var outputs = this.getRamadda().getSearchLinks(this.getSearchSettings());
            this.footerRight = outputs == null ? "" : "Links: " + HU.join(outputs, " - ");
            this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
            var msg = this.searchMessage;
            if (msg == null) {
                msg = this.getRamadda().getSearchMessage();
            }
            var provider = this.getSearchSettings().provider;
            if (provider != null) {
                msg = null;
                if (this.providerMap != null) {
                    msg = this.providerMap[provider];
                }
                if (msg == null) {
                    msg = provider;
                }
                msg = "Searching " + msg;
            }
            this.hideEntryDetails();
        },
        prepareToLayout: function() {
            SUPER.prepareToLayout.apply(this);
            this.savedValues = {};
            var cols = this.getSearchableColumns();
            for (var i = 0; i < cols.length; i++) {
                var col = cols[i];
                var id = this.getDomId(ID_COLUMN + col.getName());
                var value = $("#" + id).val();
                if (value == null || value.length == 0) continue;
                this.savedValues[id] = value;
            }
        },
        makeSearchUrl: function(repository) {
            let extra = "";
            let cols = this.getSearchableColumns();
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                let value = this.jq(ID_COLUMN + col.getName()).val();
                if (value == null || value.length == 0) continue;
                extra += "&" + col.getSearchArg() + "=" + encodeURI(value);
            }
            this.getSearchSettings().setExtra(extra);
            let jsonUrl = repository.getSearchUrl(this.getSearchSettings(), OUTPUT_JSON);
            return jsonUrl;
        },
        makeSearchForm: function() {
            let form = HU.openTag("form", [ATTR_ID, this.getDomId(ID_FORM), "action", "#"]);
            let buttonLabel = HU.getIconImage("fa-search", [ATTR_TITLE, "Search"]);
            let topItems = [];
            let searchButton = HU.div([ATTR_ID, this.getDomId(ID_SEARCH), ATTR_CLASS, "display-search-button ramadda-clickable"], buttonLabel);
            let extra = "";
            let settings = this.getSearchSettings();
	    let addWidget = (label, widget)=>{
		if(horizontal) 
		    return HU.div([CLASS,"display-search-label"], label) + 
		    HU.div([CLASS,"display-search-widget"], widget);
		return HU.formEntry("",widget);
	    };

            let horizontal = this.isLayoutHorizontal();

            if (this.ramaddas.length > 0) {
                let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_REPOSITORY), ATTR_CLASS, "display-repositories-select"]);
                let icon = ramaddaBaseUrl + "/icons/favicon.png";
                for (let i = 0; i < this.ramaddas.length; i++) {
                    let ramadda = this.ramaddas[i];
                    let attrs = [ATTR_TITLE, "", ATTR_VALUE, ramadda.getId(),
                        "data-iconurl", icon
                    ];
                    if (this.getRamadda().getId() == ramadda.getId()) {
                        attrs.push("selected");
                        attrs.push(null);
                    }
                    let label =
                        select += HU.tag(TAG_OPTION, attrs,
                            ramadda.getName());
                }
                select += HU.closeTag(TAG_SELECT);
                topItems.push(select);
            }


            this.providerMap = {};
            if (this.getPropertyProviders() != null) {
                let options = "";
                let selected = Utils.getUrlArgs(document.location.search).provider;
                let toks = this.getPropertyProviders().split(",");
                let currentCategory = null;
                let catToBuff = {};
                let cats = [];

                for (let i = 0; i < toks.length; i++) {
                    let tuple = toks[i].split(":");
                    let id = tuple[0];
		    if(!Utils.isDefined(selected)) {
			selected = id;
		    }

                    id = id.replace(/_COLON_/g, ":");
                    let label = tuple.length > 1 ? tuple[1] : id;
                    if (label.length > 40) {
                        label = label.substring(0, 39) + "...";
                    }
                    this.providerMap[id] = label;
                    let extraAttrs = "";
                    if (id == selected) {
                        extraAttrs += " selected ";
                    }
                    let category = "";

                    if (tuple.length > 3) {
                        category = tuple[3];
                    }
                    let buff = catToBuff[category];
                    if (buff == null) {
                        cats.push(category);
                        catToBuff[category] = "";
                        buff = "";
                    }
                    if (tuple.length > 2) {
                        let img = tuple[2];
                        img = img.replace(/\${urlroot}/g, ramaddaBaseUrl);
                        img = img.replace(/\${root}/g, ramaddaBaseUrl);
                        extraAttrs += " data-iconurl=\"" + img + "\" ";
                    }
                    buff += "<option title='" + label+"' class=display-search-provider " + extraAttrs + " value=\"" + id + "\">" + label + "</option>\n";
                    catToBuff[category] = buff;
                }

                for (let catIdx = 0; catIdx < cats.length; catIdx++) {
                    let category = cats[catIdx];
                    if (category != "")
                        options += "<optgroup label=\"" + category + "\">\n";
                    options += catToBuff[category];
                    if (category != "")
                        options += "</optgroup>";

                }
		let select = HU.tag("select", ["multiple", null, "id", this.getDomId(ID_PROVIDERS), ATTR_CLASS, "display-search-providers"], options);
                topItems.push(select);
            }


	    this.typeList = null;
            if (this.getTypes()) {
		this.typeList = this.getTypes().split(",");
	    }
            if (this.getShowType()) {
		if(this.typeList == null || this.typeList.length==0) {
                    topItems.push(HU.span([ATTR_ID, this.getDomId(ID_TYPE_DIV)], HU.span([ATTR_CLASS, "display-loading"], "Loading types...")));
		} else {
		    extra+= HU.span([ATTR_ID, this.getDomId(ID_TYPE_DIV)]);
		}
            }



	    let text  = this.getFormText();
	    if(!text || text=="")
		text = HU.getUrlArgument(ID_TEXT_FIELD);
            let textField = HU.input("", text, ["placeholder", this.getEgText("Search text"), ATTR_CLASS, "display-simplesearch-input", ATTR_SIZE, this.getProperty("inputSize", "30"), ATTR_ID, this.domId(ID_TEXT_FIELD)]);

            if (this.getShowText()) {
		if(topItems.length>0) extra+=addWidget("",textField);
		else topItems.push(textField);
            }

            if (horizontal) {
                let tmp = HU.join(topItems, "<br>");
                form += "<table><tr valign=top><td>" + searchButton + "</td><td>" + tmp + "</td></tr></table>";
            } else {
                form += searchButton + " " + HU.join(topItems, " ");
            }
		

	    if(!horizontal) 
		extra += HU.formTable();
            if (this.getShowDate()) {
                this.dateRangeWidget = new DateRangeWidget(this);
                extra += addWidget("", this.dateRangeWidget.getHtml());
            }
            if (this.getShowCreateDate(true)) {
                this.createdateRangeWidget = new DateRangeWidget(this,"createdate");
                extra += addWidget("", this.createdateRangeWidget.getHtml());
            }
            if (this.getShowArea()) {
                this.areaWidget = new AreaWidget(this);
                extra += addWidget("", this.areaWidget.getHtml());
            }


            extra += HU.div([ATTR_ID, this.getDomId(ID_TYPEFIELDS)], "");
            if (this.getShowMetadata()) {
                for (let i = 0; i < this.metadataTypeList.length; i++) {
                    let type = this.metadataTypeList[i];
                    let value = type.getValue();
                    let metadataSelect;
                    if (value != null) {
                        metadataSelect = value;
                    } else {
                        metadataSelect = HU.tag(TAG_SELECT, [ATTR_ID, this.getMetadataFieldId(type),
                                ATTR_CLASS, "display-metadatalist"
                            ],
                            HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""],
                                NONE));
                    }
		    if(this.getShowTags()) {
			extra += HU.div([CLASS,"display-search-label"], type.getLabel());
			extra += HU.div([CLASS,"display-search-metadata-block"], HU.div([CLASS,"display-search-metadata-block-inner", ID,this.getMetadataFieldId(type)]));
		    } else {
			extra += addWidget(type.getLabel() + ":", metadataSelect);
		    }
                }
            }
	    if(!horizontal) 
		extra += HU.closeTag(TAG_TABLE);

//            extra += HU.div([ATTR_ID, this.getDomId(ID_TYPEFIELDS)], "");

            if (this.getShowSearchSettings()) {
                let id = this.getDomId(ID_SEARCH_SETTINGS);
                if (this.getShowToggle()) {
                    form += HU.div([ATTR_CLASS, "display-search-extra", ATTR_ID, id],
				   HU.toggleBlock("Search Settings", HU.div([ATTR_CLASS, "display-search-extra-inner"], extra), this.getFormOpen(true)));
                } else {
                    form += HU.div([ATTR_CLASS, "display-search-extra", ATTR_ID, id],
                        HU.div([ATTR_CLASS, "display-search-extra-inner"], extra));
                }
            }

            //Hide the real submit button
            form += "<input type=\"submit\" style=\"position:absolute;left:-9999px;width:1px;height:1px;\"/>";
            form += HU.closeTag("form");

            return form;

        },
	getEgText:function(eg) {
            eg = this.getProperty("placeholder",eg);
            if (this.eg) {
                eg = " " + this.eg;
            }
	    return eg;
	},

	getFormText:function() {
	    var text = this.getSearchSettings().text;
            if (text == null) {
                var args = Utils.getUrlArgs(document.location.search);
                text = args.text;
            }
            if (text == null) {
                text = this.getSearchText();
            }
	    return text;
	},

        handleEventMapBoundsChanged: function(source, args) {
            if (this.areaWidget) {
                this.areaWidget.handleEventMapBoundsChanged(source, args);
            }
        },
        typeChanged: function() {
            var settings = this.getSearchSettings();
            settings.skip = 0;
            settings.max = DEFAULT_MAX;
            settings.entryType = this.getFieldValue(this.getDomId(ID_TYPE_FIELD), settings.entryType);
            settings.clearAndAddType(settings.entryType);
            this.addExtraForm();
            this.submitSearchForm();
        },
        addMetadata: function(metadataType, metadata) {
            if (metadata == null) {
                metadata = this.metadata[metadataType.getType()];
            }
            if (metadata == null) {
                let theDisplay = this;
                if (!this.metadataLoading[metadataType.getType()]) {
                    this.metadataLoading[metadataType.getType()] = true;
                    metadata = this.getRamadda().getMetadataCount(metadataType, function(metadataType, metadata) {
                        theDisplay.addMetadata(metadataType, metadata);
                    });
                }
            }
            if (metadata == null) {
                return;
            }

            this.metadata[metadataType.getType()] = metadata;

            let select = HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""], NONE);
	    let cbxs = [];
            for (let i = 0; i < metadata.length; i++) {
                let count = metadata[i].count;
                let value = metadata[i].value;
                let label = metadata[i].label;
                let optionAttrs = [ATTR_VALUE, value, ATTR_CLASS, "display-metadatalist-item"];
                let selected = false;
                if (selected) {
                    optionAttrs.push("selected");
                    optionAttrs.push(null);
                }
                select += HU.tag(TAG_OPTION, optionAttrs, label + " (" + count + ")");
		let cbxId = this.getMetadataFieldId(metadataType)+"_checkbox_" + i;
		cbxs.push(HU.checkbox("",[ID,cbxId,"metadata-type",metadataType.getType(),"metadata-value",value],false) +" " + HU.tag( "label",  [CLASS,"ramadda-noselect ramadda-clickable","for",cbxId],label +" (" + count+")"));
            }
	    if(!this.getShowTags()) {
		$("#" + this.getMetadataFieldId(metadataType)).html(select);
		this.selectboxit($("#" + this.getMetadataFieldId(metadataType)));
	    } else {
		$("#" + this.getMetadataFieldId(metadataType)).html(Utils.wrap(cbxs,"","<br>"));
		let _this = this;
		$("#" + this.getMetadataFieldId(metadataType)).find(":checkbox").change(function(){
		    let value  = $(this).attr("metadata-value");
		    let type  = $(this).attr("metadata-type");		
                    let on = $(this).is(':checked');
		    let tagId = Utils.makeId(_this.domId(ID_SEARCH_TAG) +"_" + metadataType.getType() +"_" + value);
		    let cbx = $(this);
		    let tagGroupId = ID_SEARCH_TAG_GROUP+"_"+metadataType.getType();
		    let tagGroup = _this.jq(tagGroupId);
		    if(tagGroup.length==0) {
			tagGroup = $(HU.div([CLASS,"display-search-tag-group",ID,_this.domId(tagGroupId)])).appendTo(_this.jq(ID_SEARCH_BAR));			     
		    }
		    if(on) {
			let tag = $(HU.div(["metadata-type",type,"metadata-value",value,TITLE,metadataType.getLabel()+":" + value, CLASS,"display-search-tag", ID,tagId],value+SPACE +HU.getIconImage("fas fa-times"))).appendTo(tagGroup);
			tag.click(function() {
			    $(this).remove();
			    cbx.prop("checked",false);
			    _this.submitSearchForm();
			});
		    } else {
			$("#" + tagId).remove();
		    }		
		    _this.submitSearchForm();
		});
	    }
        },

        getMetadataFieldId: function(metadataType) {
            var id = metadataType.getType();
            id = id.replace(".", "_");
            return this.getDomId(ID_METADATA_FIELD + id);
        },

        findEntryType: function(typeName) {
            if (this.entryTypes == null) return null;
            for (var i = 0; i < this.entryTypes.length; i++) {
                var type = this.entryTypes[i];
                if (type.getId() == typeName) return type;
            }
            return null;
        },
        addTypes: function(newTypes) {
            if (!this.getShowType()) {
                return;
            }
            if (newTypes == null) {
                newTypes = this.getRamadda().getEntryTypes((ramadda, types) =>{
                    this.addTypes(types);
                });
            }
            if (newTypes == null) {
                return;
            }

            this.entryTypes = newTypes;

            if (this.getTypes()) {
                let showType = {};
		let typeList = this.getTypes().split(",");
                typeList.forEach(type=>{
                    showType[type] = true;
                });
                let tmp = [];
                for (let i = 0; i < this.entryTypes.length; i++) {
                    let type = this.entryTypes[i];
                    if (showType[type.getId()]) {
                        tmp.push(type);
                    } else if (type.getCategory() != null && showType[type.getCategory()]) {
                        tmp.push(type);
                    }
                }
                this.entryTypes = tmp;
            }

            this.haveTypes = true;
            let cats = [];
            let catMap = {};
            let select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_TYPE_FIELD),
                ATTR_CLASS, "display-typelist",
                "onchange", this.getGet() + ".typeChanged();"
            ]);
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""], "Any Type");
	    let hadSelected = false;
            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                let icon = type.getIcon();
                let optionAttrs = [ATTR_TITLE, type.getLabel(), ATTR_VALUE, type.getId(), ATTR_CLASS, "display-typelist-type",
                    "data-iconurl", icon
                ];
                let selected = this.getSearchSettings().hasType(type.getId());
		if(!selected) {
		    let fromUrl = HU.getUrlArgument(ID_TYPE_FIELD);
		    if(fromUrl)
			selected = type.getId()==fromUrl;
		}
                if (selected) {
		    hadSelected = true;
                    optionAttrs.push("selected");
                    optionAttrs.push(null);
                }
                let option = HU.tag(TAG_OPTION, optionAttrs, type.getLabel() + " (" + type.getEntryCount() + ")");
                let map = catMap[type.getCategory()];
                if (map == null) {
                    catMap[type.getCategory()] = HU.tag(TAG_OPTION, [ATTR_CLASS, "display-typelist-category", ATTR_TITLE, "", ATTR_VALUE, ""], type.getCategory());
                    cats.push(type.getCategory());
                }
                catMap[type.getCategory()] += option;

            }
            for (let i in cats) {
                select += catMap[cats[i]];
            }
            select += HU.closeTag(TAG_SELECT);
	    if(this.entryTypes.length==1) {
		this.writeHtml(ID_TYPE_DIV, HU.hidden(ID_TYPE_FIELD,this.entryTypes[0].getId()));
	    } else {
		this.writeHtml(ID_TYPE_DIV, select);
	    }
            this.selectboxit(this.jq(ID_TYPE_FIELD));
            this.addExtraForm();
	    if(hadSelected) {
		this.submitSearchForm();
	    }
        },
        getSelectedType: function() {
            if (this.entryTypes == null) {
		return null;
	    }
	    if(this.entryTypes.length==1) return this.entryTypes[0];
            for (let i = 0; i < this.entryTypes.length; i++) {
                let type = this.entryTypes[i];
                if (type.getId) {
                    if (this.getSearchSettings().hasType(type.getId())) {
                        return type;
                    }
                }
            }
            let selectedType =  this.getFieldValue(this.getDomId(ID_TYPE_FIELD), null);
	    if(selectedType) {
		for (let i = 0; i < this.entryTypes.length; i++) {
                    let type = this.entryTypes[i];
                    if (type.getId) {
			if(selectedType == type.getId())
                            return type;
                    }
                }
            }
	    return null;

        },
        getSearchableColumns: function() {
            let searchable = [];
            let type = this.getSelectedType();
            if (type == null) {
                return searchable;
            }
            let cols = type.getColumns();
            if (cols == null) {
                return searchable;
            }
            for (var i = 0; i < cols.length; i++) {
                var col = cols[i];
                if (!col.getCanSearch()) continue;
                searchable.push(col);
            }
            return searchable;
        },
        addExtraForm: function() {
            if (this.savedValues == null) this.savedValues = {};
            let extra = "";
            let cols = this.getSearchableColumns();
            for (let i = 0; i < cols.length; i++) {
                let col = cols[i];
                if (this.getProperty("fields") != null && this.getProperty("fields").indexOf(col.getName()) < 0) {
                    continue;
                }

                if (extra.length == 0) {
//                    extra += HU.formTable();
                }
                let field = "";
                let id = this.getDomId(ID_COLUMN + col.getName());
                let savedValue = this.savedValues[id];
                if (savedValue == null) {
                    savedValue = this.jq(ID_COLUMN + col.getName()).val();
                }
                if (savedValue == null) savedValue = "";
                if (col.isEnumeration()) {
                    field = HU.openTag(TAG_SELECT, [ATTR_ID, id, ATTR_CLASS, "display-menu display-metadatalist"]);
                    field += HU.tag(TAG_OPTION, [CLASS,"display-metadatalist-item", ATTR_TITLE, "", ATTR_VALUE, ""],
                        "-- Select --");
                    let values = col.getValues();
                    for (let vidx in values) {
                        let value = values[vidx].value;
                        let label = values[vidx].label;
                        let extraAttr = "";
                        if (value == savedValue) {
                            extraAttr = " selected ";
                        }
                        field += HU.tag(TAG_OPTION, [CLASS,"display-metadatalist-item", ATTR_TITLE, label, ATTR_VALUE, value, extraAttr, null],
                            label);
                    }
                    field += HU.closeTag(TAG_SELECT);
                    extra += HU.div([CLASS,"display-search-label"], col.getLabel()+":")+
			HU.div([CLASS,"display-search-widget"], field+col.getSuffix());
                } else {
                    field = HU.input("", savedValue, ["placeholder",col.getLabel(),ATTR_CLASS, "input", ATTR_SIZE, "15", ATTR_ID, id]);
                    extra += HU.div([CLASS,"display-search-label"], "") +HU.div([CLASS,"display-search-widget"], field + " " + col.getSuffix());
                }
            }
            if (extra.length > 0) {
                extra += HU.closeTag(TAG_TABLE);
            }
            this.writeHtml(ID_TYPEFIELDS, extra);
	    let menus = this.jq(ID_TYPEFIELDS).find(".display-menu");
	    this.selectboxit(menus);
	    menus.change(()=>{
		this.submitSearchForm();
	    });
        },
        getEntries: function() {
            if (this.entryList == null) return [];
            return this.entryList.getEntries();
        },
        loadNextUrl: function() {
            this.getSearchSettings().skip += this.getSearchSettings().max;
            this.submitSearchForm();
        },
        loadMore: function() {
            this.getSearchSettings().max = this.getSearchSettings().max += DEFAULT_MAX;
            this.submitSearchForm();
        },
        loadLess: function() {
            let max = this.getSearchSettings().max;
            max = parseInt(0.75 * max);
            this.getSearchSettings().max = Math.max(1, max);
            this.submitSearchForm();
        },
        loadPrevUrl: function() {
            this.getSearchSettings().skip = Math.max(0, this.getSearchSettings().skip - this.getSearchSettings().max);
            this.submitSearchForm();
        },
        entryListChanged: function(entryList) {
            this.entryList = entryList;
        }
    });
}


function RamaddaEntrylistDisplay(displayManager, id, properties, theType) {
    if (theType == null) {
        theType = DISPLAY_ENTRYLIST;
    }
    const SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_ENTRYLIST, properties);
    let myProps = [];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        haveDisplayed: false,
        selectedEntries: [],
        getSelectedEntries: function() {
            return this.selectedEntries;
        },
        initDisplay: function() {
            let _this = this;
            if (this.getIsLayoutFixed() && this.haveDisplayed) {
                return;
            }
            this.haveDisplayed = true;
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
            if (this.dateRangeWidget) {
                this.dateRangeWidget.initHtml();
            }
            if (this.createdateRangeWidget) {
                this.createdateRangeWidget.initHtml();
            }	    
            SUPER.initDisplay.apply(this);
            if (this.entryList != null && this.entryList.haveLoaded) {
                this.entryListChanged(this.entryList);
            }
            this.selectboxit(this.jq(ID_PROVIDERS),
			     {width:"100px",
			      "max-height":"50px"});
            this.jq(ID_PROVIDERS).change(function() {
                _this.providerChanged();
            });
        },
        providerChanged: function() {
            let provider = this.jq(ID_PROVIDERS).val();
            if (provider != "this") {
                this.jq(ID_SEARCH_SETTINGS).hide();
            } else {
                this.jq(ID_SEARCH_SETTINGS).show();
            }
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.apply(this, menuItems);
            if (this.getSelectedEntriesFromTree().length > 0) {
                let get = this.getGet();
                menuItems.push(HU.onClick(get + ".makeDisplayList();", "Make List"));
                menuItems.push(HU.onClick(get + ".makeDisplayGallery();", "Make Gallery"));
            }
        },
        makeDisplayList: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries,
                showForm: false,
                showMenu: true,
                fixedEntries: true
            };
            props.entryList = new EntryList(this.getRamadda(), "", this, false);
            props.entryList.setEntries(entries);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRYLIST, props);
        },
        makeDisplayGallery: function() {
            let entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            let props = {
                selectedEntries: entries
            };

	    let eg = this.getEgText();
	    let text  = this.getFormText();
            let textField = HU.input("", text, ["placeholder", eg, ATTR_CLASS, "display-search-input", ATTR_SIZE, "30", ATTR_ID, this.getDomId(ID_TEXT_FIELD)]);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRY_GALLERY, props);
        },
        handleEventEntrySelection: function(source, args) {
            this.selectEntry(args.entry, args.selected);
        },
        selectEntry: function(entry, selected) {
            let changed = false;
            if (selected) {
                this.jq("entry_" + entry.getIdForDom()).addClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index < 0) {
                    this.selectedEntries.push(entry);
                    changed = true;
                }
            } else {
                this.jq("entry_" + entry.getIdForDom()).removeClass("ui-selected");
                let index = this.selectedEntries.indexOf(entry);
                if (index >= 0) {
                    this.selectedEntries.splice(index, 1);
                    changed = true;
                }
            }
        },
        makeEntriesDisplay: function(entries) {
            return this.getEntriesTree(entries);
        },

        entryListChanged: function(entryList) {
            if (this.multiSearch) {
                this.multiSearch.count--;
            }
            SUPER.entryListChanged.apply(this, [entryList]);
            let entries = this.entryList.getEntries();

            if (entries.length == 0) {
                this.getSearchSettings().skip = 0;
                this.getSearchSettings().max = DEFAULT_MAX;
                let msg = "Nothing found";
                if (this.multiSearch) {
                    if (this.multiSearch.count > 0) {
                        msg = "Nothing found so far. Still searching " + this.multiSearch.count + " repositories";
                    } else {}
                }
                this.writeHtml(ID_FOOTER_LEFT, "");
                this.writeMessage(msg);		
                this.getDisplayManager().handleEventEntriesChanged(this, []);
		this.jq(ID_ENTRIES).html("");
                return;
            }
	    this.writeMessage(this.getResultsHeader(entries));

            let get = this.getGet();
            this.writeHtml(ID_FOOTER_LEFT, "");
            if (this.footerRight != null) {
                this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
            }

            //                let entriesHtml  = this.getEntriesTree(entries);
            let entriesHtml = this.makeEntriesDisplay(entries);
            let html = "";
            html += HU.openTag(TAG_OL, [ATTR_CLASS, this.getClass("list"), ATTR_ID, this.getDomId(ID_LIST)]);
            html += entriesHtml;
            html += HU.closeTag(TAG_OL);
            this.writeEntries(html, entries);
            this.addEntrySelect();
            this.getDisplayManager().handleEventEntriesChanged(this, entries);
        },
    });
}



function RamaddaTestlistDisplay(displayManager, id, properties) {
    let SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaEntrylistDisplay(displayManager, id, properties, DISPLAY_TESTLIST));
    RamaddaUtil.defineMembers(this, {
        //This gets called by the EntryList to actually make the display
        makeEntriesDisplay: function(entries) {

            return "Overridden display<br>" + this.getEntriesTree(entries);
        },
    });

}



var RamaddaListDisplay = RamaddaEntrylistDisplay;



function RamaddaEntrygalleryDisplay(displayManager, id, properties) {
    var ID_GALLERY = "gallery";
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaEntryDisplay(displayManager, id, DISPLAY_ENTRY_GALLERY, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        entries: properties.entries,
        initDisplay: function() {
            var _this = this;
            this.createUI();
            var html = HU.div([ATTR_ID, this.getDomId(ID_GALLERY)], "Gallery");
            this.setContents(html);

            if (this.selectedEntries != null) {
                this.jq(ID_GALLERY).html(this.getEntriesGallery(this.selectedEntries));
                return;
            }
            if (this.entries) {
                var props = {
                    entries: this.entries
                };
                var searchSettings = new EntrySearchSettings(props);
                var jsonUrl = this.getRamadda().getSearchUrl(searchSettings, OUTPUT_JSON, "BAR");
                var myCallback = {
                    entryListChanged: function(list) {
                        var entries = list.getEntries();
                        _this.jq(ID_GALLERY).html(_this.getEntriesGallery(entries));
                        $("a.popup_image").fancybox({
                            'titleShow': false
                        });
                    }
                };
                var entryList = new EntryList(this.getRamadda(), jsonUrl, myCallback, true);
            }

            if (this.entryList != null && this.entryList.haveLoaded) {
                this.entryListChanged(this.entryList);
            }
        },
        getEntriesGallery: function(entries) {
            var nonImageHtml = "";
            var html = "";
            var imageCnt = 0;
            var imageEntries = [];
	    for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                //Don: Right now this just shows all of the images one after the other.
                //If there is just one image we should just display it
                //We should do a gallery here if more than 1

                if (entry.isImage()) {
                    imageEntries.push(entry);
                    var link = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], entry.getName());
                    imageCnt++;
                    html += HU.tag(TAG_IMG, ["src", entry.getResourceUrl(), ATTR_WIDTH, "500", ATTR_ID,
                            this.getDomId("entry_" + entry.getIdForDom()),
                            ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
                        ]) + "<br>" +
                        link + "<p>";
                } else {
                    var icon = entry.getIconImage([ATTR_TITLE, "View entry"]);
                    var link = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], icon + " " + entry.getName());
                    nonImageHtml += link + "<br>";
                }
            }

            if (imageCnt > 1) {
                //Show a  gallery instead
                var newHtml = "";
                newHtml += "<div class=\"row\">\n";
                var columns = parseInt(this.getProperty("columns", "3"));
                var colClass = "col-md-" + (12 / columns);
                for (var i = 0; i < imageEntries.length; i++) {
                    if (i >= columns) {
                        newHtml += "</div><div class=\"row\">\n";
                    }
                    newHtml += "<div class=" + colClass + ">\n";
                    var entry = imageEntries[i];
                    var link = HU.tag(TAG_A, [ATTR_HREF, entry.getEntryUrl()], entry.getName());
                    //Don: right now I just replicate what I do above
                    var img = HU.image(entry.getResourceUrl(), [ATTR_WIDTH, "100%", ATTR_ID,
                        this.getDomId("entry_" + entry.getIdForDom()),
                        ATTR_ENTRYID, entry.getId(), ATTR_CLASS, "display-entrygallery-entry"
                    ]);
                    img = HU.href(entry.getResourceUrl(), img, ["class", "popup_image"]);
                    newHtml += HU.div(["class", "image-outer"], HU.div(["class", "image-inner"], img) +
                        HU.div(["class", "image-caption"], link));

                    newHtml += "</div>\n";
                }
                newHtml += "</div>\n";
                html = newHtml;
            }


            //append the links to the non image entries
            if (nonImageHtml != "") {
                if (imageCnt > 0) {
                    html += "<hr>";
                }
                html += nonImageHtml;
            }
            return html;
        }
    });
}




function RamaddaEntrygridDisplay(displayManager, id, properties) {
    var SUPER;
    var ID_CONTENTS = "contents";
    var ID_GRID = "grid";
    var ID_AXIS_LEFT = "axis_left";
    var ID_AXIS_BOTTOM = "axis_bottom";
    var ID_CANVAS = "canvas";
    var ID_LINKS = "links";
    var ID_RIGHT = "right";

    var ID_SETTINGS = "gridsettings";
    var ID_YAXIS_ASCENDING = "yAxisAscending";
    var ID_YAXIS_SCALE = "scaleHeight";
    var ID_XAXIS_ASCENDING = "xAxisAscending";
    var ID_XAXIS_TYPE = "xAxisType";
    var ID_YAXIS_TYPE = "yAxisType";
    var ID_XAXIS_SCALE = "scaleWidth";
    var ID_SHOW_ICON = "showIcon";
    var ID_SHOW_NAME = "showName";
    var ID_COLOR = "boxColor";

    RamaddaUtil.inherit(this, SUPER = new RamaddaEntryDisplay(displayManager, id, DISPLAY_ENTRY_GRID, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        entries: properties.entries,
        initDisplay: function() {
            var _this = this;
            this.createUI();
            var html = HU.div([ATTR_ID, this.getDomId(ID_CONTENTS)], this.getLoadingMessage("Loading entries..."));
            this.setContents(html);
            if (!this.entryIds) {
                _this.jq(ID_CONTENTS).html(this.getLoadingMessage("No entries specified"));
                return;
            }
            var props = {
                entries: this.entryIds
            };
            var searchSettings = new EntrySearchSettings(props);
            var jsonUrl = this.getRamadda().getSearchUrl(searchSettings, OUTPUT_JSON, "BAR");
            var myCallback = {
                entryListChanged: function(list) {
                    _this.entries = list.getEntries();
                    if (_this.entries.length == 0) {
                        _this.jq(ID_CONTENTS).html(_this.getLoadingMessage("No entries selected"));
                        return;
                    }
                    _this.drag = null;
                    _this.jq(ID_CONTENTS).html(_this.makeFramework());

                    _this.canvas = $("#" + _this.getDomId(ID_CANVAS));
                    _this.gridPopup = $("#" + _this.getDomId(ID_GRID) + " .display-grid-popup");
                    var debugMouse = false;
                    var xAxis = _this.jq(ID_AXIS_BOTTOM);
                    var yAxis = _this.jq(ID_AXIS_LEFT);
                    var mousedown = function(evt) {
                        if (debugMouse)
                            console.log("mouse down");
                        _this.handledClick = false;
                        _this.drag = {
                            dragging: false,
                            x: GuiUtils.getEventX(evt),
                            y: GuiUtils.getEventY(evt),
                            X: {
                                minDate: _this.axis.X.minDate ? _this.axis.X.minDate : _this.minDate,
                                maxDate: _this.axis.X.maxDate ? _this.axis.X.maxDate : _this.maxDate,
                            },
                            Y: {
                                minDate: _this.axis.Y.minDate ? _this.axis.Y.minDate : _this.minDate,
                                maxDate: _this.axis.Y.maxDate ? _this.axis.Y.maxDate : _this.maxDate,
                            }
                        }
                    }
                    var mouseleave = function(evt) {
                        if (debugMouse)
                            console.log("mouse leave");
                        _this.drag = null;
                        _this.handledClick = false;
                    }
                    var mouseup = function(evt) {
                        if (debugMouse)
                            console.log("mouse up");
                        if (_this.drag) {
                            if (_this.drag.dragging) {
                                if (debugMouse)
                                    console.log("mouse up-was dragging");
                                _this.handledClick = true;
                            }
                            _this.drag = null;
                        }
                    }
                    var mousemove = function(evt, doX, doY) {
                        if (debugMouse)
                            console.log("mouse move");
                        var drag = _this.drag;
                        if (!drag) return;
                        drag.dragging = true;
                        var x = GuiUtils.getEventX(evt);
                        var deltaX = drag.x - x;
                        var y = GuiUtils.getEventY(evt);
                        var deltaY = drag.y - y;
                        var width = $(this).width();
                        var height = $(this).height();
                        var percentX = (x - drag.x) / width;
                        var percentY = (y - drag.y) / height;
                        var ascX = _this.getXAxisAscending();
                        var ascY = _this.getXAxisAscending();
                        var diffX = (drag.X.maxDate.getTime() - drag.X.minDate.getTime()) * percentX;
                        var diffY = (drag.Y.maxDate.getTime() - drag.Y.minDate.getTime()) * percentY;

                        if (doX) {
                            _this.axis.X.minDate = new Date(drag.X.minDate.getTime() + ((ascX ? -1 : 1) * diffX));
                            _this.axis.X.maxDate = new Date(drag.X.maxDate.getTime() + ((ascX ? -1 : 1) * diffX));
                        }
                        if (doY) {
                            _this.axis.Y.minDate = new Date(drag.Y.minDate.getTime() + ((ascY ? 1 : -1) * diffY));
                            _this.axis.Y.maxDate = new Date(drag.Y.maxDate.getTime() + ((ascY ? 1 : -1) * diffY));
                        }
                        _this.makeGrid(_this.entries);
                    }
                    var mouseclick = function(evt, doX, doY) {
                        if (_this.handledClick) {
                            if (debugMouse)
                                console.log("mouse click-other click");
                            _this.handledClick = false;
                            return;
                        }
                        if (_this.drag && _this.drag.dragging) {
                            if (debugMouse)
                                console.log("mouse click-was dragging");
                            _this.drag = null;
                            return;
                        }
                        if (debugMouse)
                            console.log("mouse click");
                        _this.drag = null;
                        var action;
                        if (evt.metaKey || evt.ctrlKey) {
                            action = "reset";
                        } else {
                            var zoomOut = evt.shiftKey;
                            if (zoomOut)
                                action = "zoomout";
                            else
                                action = "zoomin";
                        }
                        _this.doZoom(action, doX, doY);
                    };

                    var mousemoveCanvas = function(evt) {
                        mousemove(evt, true, true);
                    }
                    var mousemoveX = function(evt) {
                        mousemove(evt, true, false);
                    }
                    var mousemoveY = function(evt) {
                        mousemove(evt, false, true);
                    }

                    var mouseclickCanvas = function(evt) {
                        mouseclick(evt, true, true);
                    }
                    var mouseclickX = function(evt) {
                        mouseclick(evt, true, false);
                    }
                    var mouseclickY = function(evt) {
                        mouseclick(evt, false, true);
                    }


                    _this.canvas.mousedown(mousedown);
                    _this.canvas.mouseleave(mouseleave);
                    _this.canvas.mouseup(mouseup);
                    _this.canvas.mousemove(mousemoveCanvas);
                    _this.canvas.click(mouseclickCanvas);

                    xAxis.mousedown(mousedown);
                    xAxis.mouseleave(mouseleave);
                    xAxis.mouseup(mouseup);
                    xAxis.mousemove(mousemoveX);
                    xAxis.click(mouseclickX);

                    yAxis.mousedown(mousedown);
                    yAxis.mouseleave(mouseleave);
                    yAxis.mouseup(mouseup);
                    yAxis.mousemove(mousemoveY);
                    yAxis.click(mouseclickY);

                    var links =
                        HU.image(icon_zoom, ["class", "display-grid-action", "title", "reset zoom", "action", "reset"]) +
                        HU.image(icon_zoom_in, ["class", "display-grid-action", "title", "zoom in", "action", "zoomin"]) +
                        HU.image(icon_zoom_out, ["class", "display-grid-action", "title", "zoom out", "action", "zoomout"]);
                    _this.jq(ID_LINKS).html(links);
                    $("#" + _this.getDomId(ID_GRID) + " .display-grid-action").click(function() {
                        var action = $(this).attr("action");
                        _this.doZoom(action);
                    });


                    _this.jq(ID_AXIS_LEFT).html("");
                    _this.jq(ID_AXIS_BOTTOM).html("");
                    _this.makeGrid(_this.entries);
                }
            };
            var entryList = new EntryList(this.getRamadda(), jsonUrl, myCallback, true);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            var _this = this;
            var cbx = this.jq(ID_SETTINGS + " :checkbox");
            cbx.click(function() {
                _this.setProperty($(this).attr("attr"), $(this).is(':checked'));
                _this.makeGrid(_this.entries);
            });
            var input = this.jq(ID_SETTINGS + " :input");
            input.blur(function() {
                _this.setProperty($(this).attr("attr"), $(this).val());
                _this.makeGrid(_this.entries);
            });
            input.keypress(function(event) {
                var keycode = (event.keyCode ? event.keyCode : event.which);
                if (keycode == 13) {
                    _this.setProperty($(this).attr("attr"), $(this).val());
                    _this.makeGrid(_this.entries);
                }
            });

        },
        getDialogContents: function(tabTitles, tabContents) {
            var height = "600";
            var html = "";
            html += HU.openTag("div", ["id", this.getDomId(ID_SETTINGS)]);

            html += HU.formTable();
            html += HU.formEntry("",
                HU.checkbox(this.getDomId(ID_SHOW_ICON),
                    ["attr", ID_SHOW_ICON],
                    this.getProperty(ID_SHOW_ICON, "true")) + " Show Icon" +
                "&nbsp;&nbsp;" +
                HU.checkbox(this.getDomId(ID_SHOW_NAME),
                    ["attr", ID_SHOW_NAME],
                    this.getProperty(ID_SHOW_NAME, "true")) + " Show Name");
            html += HU.formEntry("X-Axis:",
                HU.checkbox(this.getDomId(ID_XAXIS_ASCENDING),
                    ["attr", ID_XAXIS_ASCENDING],
                    this.getXAxisAscending()) + " Ascending" +
                "&nbsp;&nbsp;" +
                HU.checkbox(this.getDomId(ID_XAXIS_SCALE),
                    ["attr", ID_XAXIS_SCALE],
                    this.getXAxisScale()) + " Scale Width");
            html += HU.formEntry("Y-Axis:",
                HU.checkbox(this.getDomId(ID_YAXIS_ASCENDING),
                    ["attr", ID_YAXIS_ASCENDING],
                    this.getYAxisAscending()) + " Ascending" +
                "&nbsp;&nbsp;" +
                HU.checkbox(this.getDomId(ID_YAXIS_SCALE),
                    ["attr", ID_YAXIS_SCALE],
                    this.getYAxisScale()) + " Scale Height");

            html += HU.formEntry("Box Color:",
                HU.input(this.getDomId(ID_COLOR),
                    this.getProperty(ID_COLOR, "lightblue"),
                    ["attr", ID_COLOR]));

            html += HU.formTableClose();
            html += HU.closeTag("div");
            tabTitles.push("Entry Grid");
            tabContents.push(html);
            SUPER.getDialogContents.call(this, tabTitles, tabContents);
        },

        doZoom: function(action, doX, doY) {
            if (!Utils.isDefined(doX)) doX = true;
            if (!Utils.isDefined(doY)) doY = true;
            if (action == "reset") {
                this.axis.Y.minDate = null;
                this.axis.Y.maxDate = null;
                this.axis.X.minDate = null;
                this.axis.X.maxDate = null;
            } else {
                var zoomOut = (action == "zoomout");
                if (doX) {
                    var d1 = this.axis.X.minDate.getTime();
                    var d2 = this.axis.X.maxDate.getTime();
                    var dateRange = d2 - d1;
                    var diff = (zoomOut ? 1 : -1) * dateRange * 0.1;
                    this.axis.X.minDate = new Date(d1 - diff);
                    this.axis.X.maxDate = new Date(d2 + diff);
                }
                if (doY) {
                    var d1 = this.axis.Y.minDate.getTime();
                    var d2 = this.axis.Y.maxDate.getTime();
                    var dateRange = d2 - d1;
                    var diff = (zoomOut ? 1 : -1) * dateRange * 0.1;
                    this.axis.Y.minDate = new Date(d1 - diff);
                    this.axis.Y.maxDate = new Date(d2 + diff);
                }
            }
            this.makeGrid(this.entries);
        },
        initGrid: function(entries) {
            var _this = this;
            var items = this.canvas.find(".display-grid-entry");
            items.click(function(evt) {
                var index = parseInt($(this).attr("index"));
                entry = entries[index];
                var url = entry.getEntryUrl();
                if (_this.urlTemplate) {
                    url = _this.urlTemplate.replace("{url}", url).replace(/{entryid}/g, entry.getId()).replace(/{resource}/g, entry.getResourceUrl());
                }

                _this.handledClick = true;
                _this.drag = null;
                window.open(url, "_entry");
                //                        evt.stopPropagation();
            });
            items.mouseout(function() {
                var id = $(this).attr("entryid");
                if (id) {
                    var other = _this.canvas.find("[entryid='" + id + "']");
                    other.each(function() {
                        if ($(this).attr("itemtype") == "box") {
                            $(this).attr("prevcolor", $(this).css("background"));
                            $(this).css("background", $(this).attr("prevcolor"));
                        }
                    });
                }

                _this.gridPopup.hide();
            });
            items.mouseover(function(evt) {
                var id = $(this).attr("entryid");
                if (id) {
                    var other = _this.canvas.find("[entryid='" + id + "']");
                    other.each(function() {
                        if ($(this).attr("itemtype") == "box") {
                            $(this).attr("prevcolor", $(this).css("background"));
                            $(this).css("background", "rgba(0,0,255,0.5)");
                        }
                    });
                }
                var x = GuiUtils.getEventX(evt);
                var index = parseInt($(this).attr("index"));
                entry = entries[index];
                var thumb = entry.getThumbnail();
                var html = "";
                if (thumb) {
                    html = HU.image(thumb, ["width", "300;"]) + "<br>";
                } else if (entry.isImage()) {
                    html += HU.image(entry.getResourceUrl(), ["width", "300"]) + "<br>";
                }
                html += entry.getIconImage() + " " + entry.getName() + "<br>";
                var start = entry.getStartDate().getUTCFullYear() + "-" + Utils.padLeft(entry.getStartDate().getUTCMonth() + 1, 2, "0") + "-" + Utils.padLeft(entry.getStartDate().getUTCDate(), 2, "0");
                var end = entry.getEndDate().getUTCFullYear() + "-" + Utils.padLeft(entry.getEndDate().getUTCMonth() + 1, 2, "0") + "-" + Utils.padLeft(entry.getEndDate().getUTCDate(), 2, "0");
                html += "Date: " + start + " - " + end + " UTC";
                _this.gridPopup.html(html);
                _this.gridPopup.show();
                _this.gridPopup.position({
                    of: $(this),
                    at: "left bottom",
                    my: "left top",
                    collision: "none none"
                });
                _this.gridPopup.position({
                    of: $(this),
                    my: "left top",
                    at: "left bottom",
                    collision: "none none"
                });
            });
        },
        makeFramework: function(entries) {
            var html = "";
            var mouseInfo = "click:zoom in;shift-click:zoom out;command/ctrl click: reset";
            html += HU.openDiv(["class", "display-grid", "id", this.getDomId(ID_GRID)]);
            html += HU.div(["class", "display-grid-popup ramadda-popup"], "");
            html += HU.openTag("table", ["border", "0", "class", "", "cellspacing", "0", "cellspacing", "0", "width", "100%", "style", "height:100%;"]);
            html += HU.openTag("tr", ["valign", "bottom"]);
            html += HU.tag("td");
            html += HU.tag("td", [], HU.div(["id", this.getDomId(ID_LINKS)], ""));
            html += HU.closeTag("tr");
            html += HU.openTag("tr", ["style", "height:100%;"]);
            html += HU.openTag("td", ["style", "height:100%;"]);
            html += HU.openDiv(["class", "display-grid-axis-left ramadda-noselect", "id", this.getDomId(ID_AXIS_LEFT)]);
            html += HU.closeDiv();
            html += HU.closeDiv();
            html += HU.closeTag("td");
            html += HU.openTag("td", ["style", "height:" + this.getProperty("height", "400") + "px"]);
            html += HU.openDiv(["class", "display-grid-canvas ramadda-noselect", "id", this.getDomId(ID_CANVAS)]);
            html += HU.closeDiv();
            html += HU.closeDiv();
            html += HU.closeTag("td");
            html += HU.closeTag("tr");
            html += HU.openTag("tr", []);
            html += HU.tag("td", ["width", "100"], "&nbsp;");
            html += HU.openTag("td", []);
            html += HU.div(["class", "display-grid-axis-bottom ramadda-noselect", "title", mouseInfo, "id", this.getDomId(ID_AXIS_BOTTOM)], "");
            html += HU.closeTag("table");
            html += HU.closeTag("td");
            return html;
        },


        getXAxisType: function() {
            return this.getProperty(ID_XAXIS_TYPE, "date");
        },
        getYAxisType: function() {
            return this.getProperty(ID_YAXIS_TYPE, "month");
        },
        getXAxisAscending: function() {
            return this.getProperty(ID_XAXIS_ASCENDING, true);
        },
        getYAxisAscending: function() {
            return this.getProperty(ID_YAXIS_ASCENDING, true);
        },
        getXAxisScale: function() {
            return this.getProperty(ID_XAXIS_SCALE, true);
        },
        getYAxisScale: function() {
            return this.getProperty(ID_YAXIS_SCALE, false);
        },


        makeGrid: function(entries) {
            var showIcon = this.getProperty(ID_SHOW_ICON, true);
            var showName = this.getProperty(ID_SHOW_NAME, true);

            if (!this.minDate) {
                var minDate = null;
                var maxDate = null;
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    minDate = minDate == null ? entry.getStartDate() : (minDate.getTime() > entry.getStartDate().getTime() ? entry.getStartDate() : minDate);
                    maxDate = maxDate == null ? entry.getEndDate() : (maxDate.getTime() < entry.getEndDate().getTime() ? entry.getEndDate() : maxDate);
                }
                this.minDate = new Date(Date.UTC(minDate.getUTCFullYear(), 0, 1));
                this.maxDate = new Date(Date.UTC(maxDate.getUTCFullYear() + 1, 0, 1));
            }

            var axis = {
                width: this.canvas.width(),
                height: this.canvas.height(),
                Y: {
                    vertical: true,
                    axisType: this.getYAxisType(),
                    ascending: this.getYAxisAscending(),
                    scale: this.getYAxisScale(),
                    skip: 1,
                    maxTicks: Math.ceil(this.canvas.height() / 80),
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                    ticks: [],
                    lines: "",
                    html: "",
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                },
                X: {
                    vertical: false,
                    axisType: this.getXAxisType(),
                    ascending: this.getXAxisAscending(),
                    scale: this.getXAxisScale(),
                    skip: 1,
                    maxTicks: Math.ceil(this.canvas.width() / 80),
                    minDate: this.minDate,
                    maxDate: this.maxDate,
                    ticks: [],
                    lines: "",
                    html: ""
                }
            }
            if (!this.axis) {
                this.axis = axis;
            } else {
                if (this.axis.X.minDate) {
                    axis.X.minDate = this.axis.X.minDate;
                    axis.X.maxDate = this.axis.X.maxDate;
                } else {
                    this.axis.X.minDate = axis.X.minDate;
                    this.axis.X.maxDate = axis.X.maxDate;
                }
                if (this.axis.Y.minDate) {
                    axis.Y.minDate = this.axis.Y.minDate;
                    axis.Y.maxDate = this.axis.Y.maxDate;
                } else {
                    this.axis.Y.minDate = axis.Y.minDate;
                    this.axis.Y.maxDate = axis.Y.maxDate;
                }
            }

            if (axis.Y.axisType == "size") {
                this.calculateSizeAxis(axis.Y);
            } else if (axis.Y.axisType == "date") {
                this.calculateDateAxis(axis.Y);
            } else {
                this.calculateMonthAxis(axis.Y);
            }
            for (var i = 0; i < axis.Y.ticks.length; i++) {
                var tick = axis.Y.ticks[i];
                var style = (axis.Y.ascending ? "bottom:" : "top:") + tick.percent + "%;";
                var style = "bottom:" + tick.percent + "%;";
                var lineClass = tick.major ? "display-grid-hline-major" : "display-grid-hline";
                axis.Y.lines += HU.div(["style", style, "class", lineClass], " ");
                axis.Y.html += HU.div(["style", style, "class", "display-grid-axis-left-tick"], tick.label + " " + HU.div(["class", "display-grid-htick"], ""));
            }

            if (axis.X.axisType == "size") {
                this.calculateSizeAxis(axis.X);
            } else if (axis.X.axisType == "date") {
                this.calculateDateAxis(axis.X);
            } else {
                this.calculateMonthAxis(axis.X);
            }
            for (var i = 0; i < axis.X.ticks.length; i++) {
                var tick = axis.X.ticks[i];
                if (tick.percent > 0) {
                    var lineClass = tick.major ? "display-grid-vline-major" : "display-grid-vline";
                    axis.X.lines += HU.div(["style", "left:" + tick.percent + "%;", "class", lineClass], " ");
                }
                axis.X.html += HU.div(["style", "left:" + tick.percent + "%;", "class", "display-grid-axis-bottom-tick"], HU.div(["class", "display-grid-vtick"], "") + " " + tick.label);
            }

            var items = "";
            var seen = {};
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                var vInfo = this[axis.Y.calculatePercent].call(this, entry, axis.Y);
                var xInfo = this[axis.X.calculatePercent].call(this, entry, axis.X);
                if (vInfo.p1 < 0) {
                    vInfo.p2 = vInfo.p2 + vInfo.p1;
                    vInfo.p1 = 0;
                }
                if (vInfo.p1 + vInfo.p2 > 100) {
                    vInfo.p2 = 100 - vInfo.p1;
                }

                var style = "";
                var pos = "";

                if (axis.X.ascending) {
                    style += "left:" + xInfo.p1 + "%;";
                    pos += "left:" + xInfo.p1 + "%;";
                } else {
                    style += "right:" + xInfo.p1 + "%;";
                    pos += "left:" + (100 - xInfo.p2) + "%;";
                }

                if (axis.X.scale) {
                    if (xInfo.delta > 1) {
                        style += "width:" + xInfo.delta + "%;";
                    } else {
                        style += "width:" + this.getProperty("fixedWidth", "5") + "px;";
                    }
                }


                var namePos = pos;
                if (axis.Y.ascending) {
                    style += " bottom:" + vInfo.p2 + "%;";
                    pos += " bottom:" + vInfo.p2 + "%;";
                    namePos += " bottom:" + vInfo.p2 + "%;";
                } else {
                    style += " top:" + vInfo.p2 + "%;";
                    pos += " top:" + vInfo.p2 + "%;";
                    namePos += " top:" + vInfo.p2 + "%;";
                    namePos += "margin-top:-15px;"
                }
                if (axis.Y.scale) {
                    if (vInfo.p2 > 1) {
                        style += "height:" + vInfo.delta + "%;";
                    } else {
                        style += "height:" + this.getProperty("fixedHeight", "5") + "px;";
                    }
                }

                if (entry.getName().includes("rilsd")) {
                    console.log("pos:" + namePos);
                }
                if (showIcon) {
                    items += HU.div(["class", "display-grid-entry-icon display-grid-entry", "entryid", entry.getId(), "index", i, "style", pos], entry.getIconImage());
                }
                var key = Math.round(xInfo.p1) + "---" + Math.round(vInfo.p1);
                if (showName && !seen[key]) {
                    seen[key] = true;
                    var name = entry.getName().replace(/ /g, "&nbsp;");
                    items += HU.div(["class", "display-grid-entry-text display-grid-entry", "entryid", entry.getId(), "index", i, "style", namePos], name);
                }
                var boxStyle = style + "background:" + this.getProperty(ID_COLOR, "lightblue");
                items += HU.div(["class", "display-grid-entry-box display-grid-entry", "itemtype", "box", "entryid", entry.getId(), "style", boxStyle, "index", i], "");
            }
            this.jq(ID_AXIS_LEFT).html(axis.Y.html);
            this.jq(ID_CANVAS).html(axis.Y.lines + axis.X.lines + items);
            this.jq(ID_AXIS_BOTTOM).html(axis.X.html);
            this.initGrid(entries);
        },
        calculateSizeAxis: function(axisInfo) {
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            for (var i = 0; i < this.entries.length; i++) {
                var entry = this.entries[i];
                min = Math.min(min, entry.getSize());
                max = Math.max(max, entry.getSize());
            }
        },
        checkOrder: function(axisInfo, percents) {
            /*
            if(!axisInfo.ascending) {
                percents.p1 = 100-percents.p1;
                percents.p2 = 100-percents.p2;
                var tmp  =percents.p1;
                percents.p1=percents.p2;
                percents.p2=tmp;
            }
            */
            return {
                p1: percents.p1,
                p2: percents.p2,
                delta: Math.abs(percents.p2 - percents.p1)
            };
        },
        calculateDatePercent: function(entry, axisInfo) {
            var p1 = 100 * (entry.getStartDate().getTime() - axisInfo.min) / axisInfo.range;
            var p2 = 100 * (entry.getEndDate().getTime() - axisInfo.min) / axisInfo.range;
            return this.checkOrder(axisInfo, {
                p1: p1,
                p2: p2,
                delta: Math.abs(p2 - p1)
            });
        },
        calculateMonthPercent: function(entry, axisInfo) {
            var d1 = entry.getStartDate();
            var d2 = entry.getEndDate();
            var t1 = new Date(Date.UTC(1, d1.getUTCMonth(), d1.getUTCDate()));
            var t2 = new Date(Date.UTC(1, d2.getUTCMonth(), d2.getUTCDate()));
            var p1 = 100 * ((t1.getTime() - axisInfo.min) / axisInfo.range);
            var p2 = 100 * ((t2.getTime() - axisInfo.min) / axisInfo.range);
            if (entry.getName().includes("rilsd")) {
                console.log("t1:" + t1);
                console.log("t2:" + t2);
                console.log("before:" + p1 + " " + p2);
            }
            return this.checkOrder(axisInfo, {
                p1: p1,
                p2: p2,
                delta: Math.abs(p2 - p1)
            });
        },
        calculateMonthAxis: function(axisInfo) {
            axisInfo.calculatePercent = "calculateMonthPercent";
            axisInfo.minDate = new Date(Date.UTC(0, 11, 15));
            axisInfo.maxDate = new Date(Date.UTC(1, 11, 31));
            axisInfo.min = axisInfo.minDate.getTime();
            axisInfo.max = axisInfo.maxDate.getTime();
            axisInfo.range = axisInfo.max - axisInfo.min;
            var months = Utils.getMonthShortNames();
            for (var month = 0; month < months.length; month++) {
                var t1 = new Date(Date.UTC(1, month));
                var percent = (axisInfo.maxDate.getTime() - t1.getTime()) / axisInfo.range;
                if (axisInfo.ascending)
                    percent = 1 - percent;
                axisInfo.ticks.push({
                    percent: 100 * percent,
                    label: months[month],
                    major: false
                });
            }
        },
        calculateDateAxis: function(axisInfo) {
            axisInfo.calculatePercent = "calculateDatePercent";
            var numYears = axisInfo.maxDate.getUTCFullYear() - axisInfo.minDate.getUTCFullYear();
            var years = numYears;
            axisInfo.type = "year";
            axisInfo.skip = Math.max(1, Math.floor(numYears / axisInfo.maxTicks));
            if ((numYears / axisInfo.skip) <= (axisInfo.maxTicks / 2)) {
                var numMonths = 0;
                var tmp = new Date(axisInfo.minDate.getTime());
                while (tmp.getTime() < axisInfo.maxDate.getTime()) {
                    Utils.incrementMonth(tmp);
                    numMonths++;
                }
                axisInfo.skip = Math.max(1, Math.floor(numMonths / axisInfo.maxTicks));
                axisInfo.type = "month";
                if ((numMonths / axisInfo.skip) <= (axisInfo.maxTicks / 2)) {
                    var tmp = new Date(axisInfo.minDate.getTime());
                    var numDays = 0;
                    while (tmp.getTime() < axisInfo.maxDate.getTime()) {
                        Utils.incrementDay(tmp);
                        numDays++;
                    }
                    axisInfo.skip = Math.max(1, Math.floor(numDays / axisInfo.maxTicks));
                    axisInfo.type = "day";
                }
            }


            axisInfo.min = axisInfo.minDate.getTime();
            axisInfo.max = axisInfo.maxDate.getTime();
            axisInfo.range = axisInfo.max - axisInfo.min;
            var months = Utils.getMonthShortNames();
            var lastYear = null;
            var lastMonth = null;
            var tickDate;
            if (axisInfo.type == "year") {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear()));
            } else if (axisInfo.type == "month") {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear(), axisInfo.minDate.getUTCMonth()));
            } else {
                tickDate = new Date(Date.UTC(axisInfo.minDate.getUTCFullYear(), axisInfo.minDate.getUTCMonth(), axisInfo.minDate.getUTCDate()));
            }
            //                if(axisInfo.vertical)
            //                    console.log(axisInfo.type+" skip:" + axisInfo.skip + "   min:" + Utils.formatDateYYYYMMDD(axisInfo.minDate)+"   max:" + Utils.formatDateYYYYMMDD(axisInfo.maxDate));
            while (tickDate.getTime() < axisInfo.maxDate.getTime()) {
                var percent = (tickDate.getTime() - axisInfo.minDate.getTime()) / axisInfo.range;
                if (!axisInfo.ascending)
                    percent = (1 - percent);
                percent = 100 * percent;
                //                    console.log("    perc:"+ percent +" " + Utils.formatDateYYYYMMDD(tickDate));
                if (percent >= 0 && percent < 100) {
                    var label = "";
                    var year = tickDate.getUTCFullYear();
                    var month = tickDate.getUTCMonth();
                    var major = false;
                    if (axisInfo.type == "year") {
                        label = year;
                    } else if (axisInfo.type == "month") {
                        label = months[tickDate.getUTCMonth()];
                        if (lastYear != year) {
                            label = label + "<br>" + year;
                            lastYear = year;
                            major = true;
                        }
                    } else {
                        label = tickDate.getUTCDate();
                        if (lastYear != year || lastMonth != month) {
                            label = label + "<br>" + months[month] + " " + year;
                            lastYear = year;
                            lastMonth = month;
                            major = true;
                        }
                    }
                    axisInfo.ticks.push({
                        percent: percent,
                        label: label,
                        major: major
                    });
                }
                if (axisInfo.type == "year") {
                    Utils.incrementYear(tickDate, axisInfo.skip);
                } else if (axisInfo.type == "month") {
                    Utils.incrementMonth(tickDate, axisInfo.skip);
                } else {
                    Utils.incrementDay(tickDate, axisInfo.skip);
                }
            }

        }
    });
}


function RamaddaMetadataDisplay(displayManager, id, properties) {
    if (properties.formOpen == null) {
        properties.formOpen = false;
    }
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_METADATA, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        haveDisplayed: false,
        initDisplay: function() {
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
            SUPER.initDisplay.apply(this);
            if (this.haveDisplayed && this.entryList) {
                this.entryListChanged(this.entryList);
            }
            this.haveDisplayed = true;
        },
        entryListChanged: function(entryList) {
            this.entryList = entryList;
            var entries = this.entryList.getEntries();
            if (entries.length == 0) {
                this.writeMessage("Nothing found");
                return;
            }
            var mdtsFromEntries = [];
            var mdtmap = {};
            var tmp = {};
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                var metadata = entry.getMetadata();
                for (var j = 0; j < metadata.length; j++) {
                    var m = metadata[j];
                    if (tmp[m.type] == null) {
                        tmp[m.type] = "";
                        mdtsFromEntries.push(m.type);
                    }
                    mdtmap[metadata[j].type] = metadata[j].label;
                }
            }

            var html = "";
            html += HU.openTag(TAG_TABLE, ["id", this.getDomId("table"), ATTR_CLASS, "cell-border stripe ramadda-table", ATTR_WIDTH, "100%", "cellpadding", "5", "cellspacing", "0"]);
            html += "<thead>"
            var type = this.findEntryType(this.searchSettings.entryType);
            var typeName = "Entry";
            if (type != null) {
                typeName = type.getLabel();
            }
	    this.writeMessage(this.getResultsHeader(entries));
            var mdts = null;
            //Get the metadata types to show from either a property or
            //gather them from all of the entries
            // e.g., "project_pi,project_person,project_funding"
            var prop = this.getProperty("metadataTypes", null);
            if (prop != null) {
                mdts = prop.split(",");
            } else {
                mdts = mdtsFromEntries;
                mdts.sort();
            }

            var skip = {
                "content.pagestyle": true,
                "content.pagetemplate": true,
                "content.sort": true,
                "spatial.polygon": true,
            };
            var headerItems = [];
            headerItems.push(HU.th([], HU.b(typeName)));
            for (var i = 0; i < mdts.length; i++) {
                var type = mdts[i];
                if (skip[type]) {
                    continue;
                }
                var label = mdtmap[mdts[i]];
                if (label == null) label = mdts[i];
                headerItems.push(HU.th([], HU.b(label)));
            }
            var headerRow = HU.tr(["valign", "bottom"], HU.join(headerItems, ""));
            html += headerRow;
            html += "</thead><tbody>"
            var divider = "<div class=display-metadata-divider></div>";
            var missing = this.missingMessage;
            if (missing = null) missing = "&nbsp;";
            for (var entryIdx = 0; entryIdx < entries.length; entryIdx++) {
                var entry = entries[entryIdx];
                var metadata = entry.getMetadata();
                var row = [];
                var buttonId = this.getDomId("entrylink" + entry.getIdForDom());
                var link = entry.getLink(entry.getIconImage() + " " + entry.getName());
                row.push(HU.td([], HU.div([ATTR_CLASS, "display-metadata-entrylink"], link)));
                for (var mdtIdx = 0; mdtIdx < mdts.length; mdtIdx++) {
                    var mdt = mdts[mdtIdx];
                    if (skip[mdt]) {
                        continue;
                    }
                    var cell = null;
                    for (var j = 0; j < metadata.length; j++) {
                        var m = metadata[j];
                        if (m.type == mdt) {
                            var item = null;
                            if (m.type == "content.thumbnail" || m.type == "content.logo") {
                                var url = this.getRamadda().getRoot() + "/metadata/view/" + m.value.attr1 + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + m.id;
                                item = HU.image(url, [ATTR_WIDTH, "100"]);
                            } else if (m.type == "content.url" || m.type == "dif.related_url") {
                                var label = m.value.attr2;
                                if (label == null || label == "") {
                                    label = m.value.attr1;
                                }
                                item = HU.href(m.value.attr1, label);
                            } else if (m.type == "content.attachment") {
                                var toks = m.value.attr1.split("_file_");
                                var filename = toks[1];
                                var url = this.getRamadda().getRoot() + "/metadata/view/" + m.value.attr1 + "?element=1&entryid=" + entry.getId() + "&metadata_id=" + m.id;
                                item = HU.href(url, filename);
                            } else {
                                item = m.value.attr1;
                                //                                    console.log("Item:" + item);
                                if (m.value.attr2 && m.value.attr2.trim().length > 0) {
                                    item += " - " + m.value.attr2;
                                }
                            }
                            if (item != null) {
                                if (cell == null) {
                                    cell = "";
                                } else {
                                    cell += divider;
                                }
                                cell += HU.div([ATTR_CLASS, "display-metadata-item"], item);
                            }

                        }
                    }
                    if (cell == null) {
                        cell = missing;
                    }
                    if (cell == null) {
                        cell = "";
                    }
                    var add = HU.tag(TAG_A, [ATTR_STYLE, "color:#000;", ATTR_HREF, this.getRamadda().getRoot() + "/metadata/addform?entryid=" + entry.getId() + "&metadata_type=" + mdt,
                        "target", "_blank", "alt", "Add metadata", ATTR_TITLE, "Add metadata"
                    ], "+");
                    add = HU.div(["class", "display-metadata-table-add"], add);
                    var cellContents = add + divider;
                    if (cell.length > 0) {
                        cellContents += cell;
                    }
                    row.push(HU.td([], HU.div([ATTR_CLASS, "display-metadata-table-cell-contents"], cellContents)));
                }
                html += HU.tr(["valign", "top"], HU.join(row, ""));
                //Add in the header every 10 rows
                if (((entryIdx + 1) % 10) == 0) html += headerRow;
            }
            html += "</tbody>"
            html += HU.closeTag(TAG_TABLE);
            this.writeEntries(html, entries);
            HU.formatTable("#" + this.getDomId("table"), {
                scrollY: 400
            });
        },
    });

}




function RamaddaEntrytimelineDisplay(displayManager, id, properties) {
    if (properties.formOpen == null) {
        properties.formOpen = false;
    }
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_ENTRYTIMELINE, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        initDisplay: function() {
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
            SUPER.initDisplay.apply(this);
        },
        entryListChanged: function(entryList) {
            this.entryList = entryList;
            var entries = this.entryList.getEntries();
            var html = "";
            if (entries.length == 0) {
                this.writeMessage("Nothing found");
                return;
            }

            var data = {
                "timeline": {
                    "headline": "The Main Timeline Headline Goes here",
                    "type": "default",
                    "text": "<p>Intro body text goes here, some HTML is ok</p>",
                    "asset": {
                        "media": "http://yourdomain_or_socialmedialink_goes_here.jpg",
                        "credit": "Credit Name Goes Here",
                        "caption": "Caption text goes here"
                    },
                    "date": [{
                            "startDate": "2011,12,10",
                            "endDate": "2011,12,11",
                            "headline": "Headline Goes Here",
                            "text": "<p>Body text goes here, some HTML is OK</p>",
                            "tag": "This is Optional",
                            "classname": "optionaluniqueclassnamecanbeaddedhere",
                            "asset": {
                                "media": "http://twitter.com/ArjunaSoriano/status/164181156147900416",
                                "thumbnail": "optional-32x32px.jpg",
                                "credit": "Credit Name Goes Here",
                                "caption": "Caption text goes here"
                            }
                        }, {
                            "startDate": "2012,12,10",
                            "endDate": "2012,12,11",
                            "headline": "Headline Goes Here",
                            "text": "<p>Body text goes here, some HTML is OK</p>",
                            "tag": "This is Optional",
                            "classname": "optionaluniqueclassnamecanbeaddedhere",
                            "asset": {
                                "media": "http://twitter.com/ArjunaSoriano/status/164181156147900416",
                                "thumbnail": "optional-32x32px.jpg",
                                "credit": "Credit Name Goes Here",
                                "caption": "Caption text goes here"
                            }
                        }, {
                            "startDate": "2013,12,10",
                            "endDate": "2013,12,11",
                            "headline": "Headline Goes Here",
                            "text": "<p>Body text goes here, some HTML is OK</p>",
                            "tag": "This is Optional",
                            "classname": "optionaluniqueclassnamecanbeaddedhere",
                            "asset": {
                                "media": "http://twitter.com/ArjunaSoriano/status/164181156147900416",
                                "thumbnail": "optional-32x32px.jpg",
                                "credit": "Credit Name Goes Here",
                                "caption": "Caption text goes here"
                            }
                        }

                    ],
                    "era": [{
                            "startDate": "2011,12,10",
                            "endDate": "2011,12,11",
                            "headline": "Headline Goes Here",
                            "text": "<p>Body text goes here, some HTML is OK</p>",
                            "tag": "This is Optional"
                        }

                    ]
                }
            };


            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];

            }
            createStoryJS({
                type: 'timeline',
                width: '800',
                height: '600',
                source: data,
                embed_id: this.getDomId(ID_ENTRIES),
            });

        },
    });

}







function RamaddaEntrydisplayDisplay(displayManager, id, properties) {
    var SUPER;
    var e = new Error();

    $.extend(this, {
        sourceEntry: properties.sourceEntry
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ENTRYDISPLAY, properties));
    if (properties.sourceEntry == null && properties.entryId != null) {
        var _this = this;
        var f = async function() {
            await _this.getEntry(properties.entryId, entry => {
                _this.sourceEntry = entry;
                _this.initDisplay()
            });

        }
        f();
    }


    addRamaddaDisplay(this);
    $.extend(this, {
        selectedEntry: null,
        initDisplay: function() {
            this.createUI();
            var title = this.title;
            if (this.sourceEntry != null) {
                this.addEntryHtml(this.sourceEntry);
                var url = this.sourceEntry.getEntryUrl();

                if (title == null) {
                    title = this.sourceEntry.getName();
                }
                title = HU.tag("a", ["href", url, "title", this.sourceEntry.getName(), "alt", this.sourceEntry.getName()], title);
            } else {
                this.addEntryHtml(this.selectedEntry);
                if (title == null) {
                    title = "Entry Display";
                }
            }
            this.setDisplayTitle(title);
        },
        handleEventEntrySelection: function(source, args) {
            //Ignore select events
            if (this.sourceEntry != null) return;
            var selected = args.selected;
            var entry = args.entry;
            if (!selected) {
                if (this.selectedEntry != entry) {
                    //not mine
                    return;
                }
                this.selectedEntry = null;
                this.setContents("");
                return;
            }
            this.selectedEntry = entry;
            this.addEntryHtml(this.selectedEntry);
        },
        getEntries: function() {
            return [this.sourceEntry];
        },
        addEntryHtml: function(entry) {
            if (entry == null) {
                this.setContents("&nbsp;");
                return;
            }
            var html = this.getEntryHtml(entry, {
                showHeader: false
            });
            var height = this.getProperty("height", "400px");
            if (!height.endsWith("px")) height += "px";
            this.setContents(HU.div(["class", "display-entry-description", "style", "height:" + height + ";"],
                html));
            this.entryHtmlHasBeenDisplayed(entry);
        },
    });
}



function RamaddaEntrytitleDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        sourceEntry: properties.sourceEntry
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ENTRYDISPLAY, properties));
    if (properties.sourceEntry == null && properties.entryId != null) {
        var _this = this;
        var f = async function() {
            await _this.getEntry(properties.entryId, entry => {
                _this.sourceEntry = entry;
                _this.initDisplay()
            });
        }
        f();
    }

    let myProps = [
	{label:'Entry Title'},
	{p:'template',ex:'<b>${icon} ${name} Date: ${date} ${start_date} ${end_date} ${entry_attribute...}</b>'},
	{p:'showLink',ex:'false'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	initDisplay: function() {
            this.createUI();
	    let html = "";
	    if(this.sourceEntry) {
		let e = this.sourceEntry;
		html = this.getProperty("template","<b>${icon} ${name} Date: ${date} Sonde: ${sonde}</b>");
		html = html.replace("${name}",e.getDisplayName());
		html = html.replace("${icon}",e.getIconImage());
		html = html.replace("${date}",this.formatDate(e.getStartDate()));
		html = html.replace("${start_date}",this.formatDate(e.getStartDate()));
		html = html.replace("${end_date}",this.formatDate(e.getEndDate()));
		e.getAttributeNames().map(n=>{
		    html = html.replace("${" + n+"}",e.getAttributeValue(n));
		});
		if(this.getProperty("showLink",true)) {
		    html = HU.href(e.getEntryUrl(),html);
		}
	    }
	    this.displayHtml(html);
        },
	setEntry: function(entry) {
	    this.sourceEntry = entry;
	    this.initDisplay();
	},
        handleEventEntrySelection: function(source, args) {
        },
    });
}





function RamaddaOperandsDisplay(displayManager, id, properties) {
    var ID_SELECT = TAG_SELECT;
    var ID_SELECT1 = "select1";
    var ID_SELECT2 = "select2";
    var ID_NEWDISPLAY = "newdisplay";

    $.extend(this, new RamaddaEntryDisplay(displayManager, id, DISPLAY_OPERANDS, properties));
    addRamaddaDisplay(this);
    $.extend(this, {
        baseUrl: null,
        initDisplay: function() {
            this.createUI();
            this.baseUrl = this.getRamadda().getSearchUrl(this.searchSettings, OUTPUT_JSON);
            if (this.entryList == null) {
                this.entryList = new EntryList(this.getRamadda(), jsonUrl, this);
            }
            var html = "";
            html += HU.div([ATTR_ID, this.domId(ID_ENTRIES), ATTR_CLASS, this.getClass("entries")], "");
            this.setContents(html);
        },
        entryListChanged: function(entryList) {
            var html = "<form>";
            html += "<p>";
            html += HU.openTag(TAG_TABLE, [ATTR_CLASS, "formtable", "cellspacing", "0", "cellspacing", "0"]);
            var entries = this.entryList.getEntries();
            var get = this.getGet();

            for (var j = 1; j <= 2; j++) {
                var select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_SELECT + j)]);
                select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, ""],
                    "-- Select --");
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    var label = entry.getIconImage() + " " + entry.getName();
                    select += HU.tag(TAG_OPTION, [ATTR_TITLE, entry.getName(), ATTR_VALUE, entry.getId()],
                        entry.getName());

                }
                select += HU.closeTag(TAG_SELECT);
                html += HU.formEntry("Data:", select);
            }

            var select = HU.openTag(TAG_SELECT, [ATTR_ID, this.getDomId(ID_CHARTTYPE)]);
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "linechart"],
                "Line chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "barchart"],
                "Bar chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "barstack"],
                "Stacked bars");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "bartable"],
                "Bar table");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "piechart"],
                "Pie chart");
            select += HU.tag(TAG_OPTION, [ATTR_TITLE, "", ATTR_VALUE, "scatterplot"],
                "Scatter Plot");
            select += HU.closeTag(TAG_SELECT);
            html += HU.formEntry("Chart Type:", select);

            html += HU.closeTag(TAG_TABLE);
            html += "<p>";
            html += HU.tag(TAG_DIV, [ATTR_CLASS, "display-button", ATTR_ID, this.getDomId(ID_NEWDISPLAY)], "New Chart");
            html += "<p>";
            html += "</form>";
            this.writeEntries(html);
            var theDisplay = this;
            this.jq(ID_NEWDISPLAY).button().click(function(event) {
                theDisplay.createDisplay();
            });
        },
        createDisplay: function() {
            var entry1 = this.getEntry(this.jq(ID_SELECT1).val());
            var entry2 = this.getEntry(this.jq(ID_SELECT2).val());
            if (entry1 == null) {
                alert("No data selected");
                return;
            }
            var pointDataList = [];

            pointDataList.push(new PointData(entry1.getName(), null, null, ramaddaBaseUrl + "/entry/show?&output=points.product&product=points.json&numpoints=1000&entryid=" + entry1.getId()));
            if (entry2 != null) {
                pointDataList.push(new PointData(entry2.getName(), null, null, ramaddaBaseUrl + "/entry/show?&output=points.product&product=points.json&numpoints=1000&entryid=" + entry2.getId()));
            }

            //Make up some functions
            var operation = "average";
            var derivedData = new DerivedPointData(this.displayManager, "Derived Data", pointDataList, operation);
            var pointData = derivedData;
            var chartType = this.jq(ID_CHARTTYPE).val();
            displayManager.createDisplay(chartType, {
                "layoutFixed": false,
                "data": pointData
            });
        }

    });
}


function RamaddaRepositoriesDisplay(displayManager, id, properties) {
    RamaddaUtil.inherit(this, new RamaddaEntryDisplay(displayManager, id, DISPLAY_REPOSITORIES, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        initDisplay: function() {
            var theDisplay = this;
            this.createUI();
            var html = "";
            if (this.ramaddas.length == 0) {
                html += this.getMessage("No repositories specified");
            } else {
                html += this.getMessage("Loading repository listing");
            }
            this.numberWithTypes = 0;
            this.finishedInitDisplay = false;
            //Check for and remove the all repositories
            if (this.ramaddas.length > 1) {
                if (this.ramaddas[this.ramaddas.length - 1].getRoot() == "all") {
                    this.ramaddas.splice(this.ramaddas.length - 1, 1);
                }
            }
            for (var i = 0; i < this.ramaddas.length; i++) {
                if (i == 0) {}
                var ramadda = this.ramaddas[i];
                var types = ramadda.getEntryTypes(function(ramadda, types) {
                    theDisplay.gotTypes(ramadda, types);
                });
                if (types != null) {
                    this.numberWithTypes++;
                }
            }
            this.setDisplayTitle("Repositories");
            this.setContents(html);
            this.finishedInitDisplay = true;
            this.displayRepositories();
        },
        displayRepositories: function() {
            if (!this.finishedInitDisplay || this.numberWithTypes != this.ramaddas.length) {
                return;
            }
            var typeMap = {};
            var allTypes = [];
            var html = "";
            html += HU.openTag(TAG_TABLE, [ATTR_CLASS, "display-repositories-table", ATTR_WIDTH, "100%", ATTR_BORDER, "1", "cellspacing", "0", "cellpadding", "5"]);
            for (var i = 0; i < this.ramaddas.length; i++) {
                var ramadda = this.ramaddas[i];
                var types = ramadda.getEntryTypes();
                for (var typeIdx = 0; typeIdx < types.length; typeIdx++) {
                    var type = types[typeIdx];
                    if (typeMap[type.getId()] == null) {
                        typeMap[type.getId()] = type;
                        allTypes.push(type);
                    }
                }
            }

            html += HU.openTag(TAG_TR, ["valign", "bottom"]);
            html += HU.th([ATTR_CLASS, "display-repositories-table-header"], "Type");
            for (var i = 0; i < this.ramaddas.length; i++) {
                var ramadda = this.ramaddas[i];
                var link = HU.href(ramadda.getRoot(), ramadda.getName());
                html += HU.th([ATTR_CLASS, "display-repositories-table-header"], link);
            }
            html += "</tr>";

            var onlyCats = [];
            if (this.categories != null) {
                onlyCats = this.categories.split(",");
            }



            var catMap = {};
            var cats = [];
            for (var typeIdx = 0; typeIdx < allTypes.length; typeIdx++) {
                var type = allTypes[typeIdx];
                var row = "";
                row += "<tr>";
                row += HU.td([], HU.image(type.getIcon()) + " " + type.getLabel());
                for (var i = 0; i < this.ramaddas.length; i++) {
                    var ramadda = this.ramaddas[i];
                    var repoType = ramadda.getEntryType(type.getId());
                    var col = "";
                    if (repoType == null) {
                        row += HU.td([ATTR_CLASS, "display-repositories-table-type-hasnot"], "");
                    } else {
                        var label =
                            HU.tag(TAG_A, ["href", ramadda.getRoot() + "/search/type/" + repoType.getId(), "target", "_blank"],
                                repoType.getEntryCount());
                        row += HU.td([ATTR_ALIGN, "right", ATTR_CLASS, "display-repositories-table-type-has"], label);
                    }

                }
                row += "</tr>";

                var catRows = catMap[type.getCategory()];
                if (catRows == null) {
                    catRows = [];
                    catMap[type.getCategory()] = catRows;
                    cats.push(type.getCategory());
                }
                catRows.push(row);
            }

            for (var i = 0; i < cats.length; i++) {
                var cat = cats[i];
                if (onlyCats.length > 0) {
                    var ok = false;
                    for (var patternIdx = 0; patternIdx < onlyCats.length; patternIdx++) {
                        if (cat == onlyCats[patternIdx]) {
                            ok = true;
                            break;
                        }
                        if (cat.match(onlyCats[patternIdx])) {
                            ok = true;
                            break;

                        }
                    }
                    if (!ok) continue;

                }
                var rows = catMap[cat];
                html += "<tr>";
                html += HU.th(["colspan", "" + (1 + this.ramaddas.length)], cat);
                html += "</tr>";
                for (var row = 0; row < rows.length; row++) {
                    html += rows[row];
                }

            }


            html += HU.closeTag(HU.TAG_TABLE);
            this.setContents(html);
        },
        gotTypes: function(ramadda, types) {
            this.numberWithTypes++;
            this.displayRepositories();
        }
    });
}


var RamaddaGalleryDisplay = RamaddaEntrygalleryDisplay;

function RamaddaSimplesearchDisplay(displayManager, id, properties) {
    let SUPER;
    let myProps = [
	{label:'Simple Search'},
	{p:'resultsPosition',ex:'absolute|relative'},
	{p:'maxHeight',w:300},
	{p:'maxWidth',w:200},
	{p:'maxWidth',w:200},		
	{p:"autoSearch",w:true},
	{p:"showHeader",w:true},
	{p:"inputWidth",w:"100%"},
	{p:"entryType",w:"",tt:"Constrain search to entries of this type"},		
	{p:"entryRoot",w:"this",tt:"Constrain search to this tree"},		
    ];

    RamaddaUtil.inherit(this, SUPER = new RamaddaSearcherDisplay(displayManager, id, DISPLAY_SIMPLESEARCH, properties));
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	callNumber:1,
        haveDisplayed: false,
        selectedEntries: [],
        getSelectedEntries: function() {
            return this.selectedEntries;
        },
        initDisplay: function() {
            var _this = this;
            if (this.getIsLayoutFixed() && this.haveDisplayed) {
                return;
            }
            this.haveDisplayed = true;
            this.createUI();
            this.setContents(this.getDefaultHtml());
	    this.initHtml();
	    let input = this.jq(ID_TEXT_FIELD);
	    if(this.getAutoSearch(true)) {
		//KEY
		input.keyup(function(event) {
		    _this.getSearchSettings().skip =0;
                    _this.getSearchSettings().max = DEFAULT_MAX;
		    if($(this).val().trim()=="") {
			_this.writeMessage("");
			_this.writeEntries("");			
			if(_this.dialog) {
			    _this.dialog.remove();
			    _this.dialog = null;
			}
			return;
		    }
		    let myCallNumber = ++_this.callNumber;
		    //Wait a bit in case more keys are coming
		    setTimeout(()=>{
			if(myCallNumber == _this.callNumber) {
			    _this.submitSearchForm(true,myCallNumber);
			} else {
			}
		    },250);
		});
	    }

            this.jq(ID_SEARCH).click(function(event) {
		_this.submitSearchForm(false,++_this.callNumber);
                event.preventDefault();
            });
            this.jq(ID_FORM).submit(function(event) {
		_this.submitSearchForm(false,++_this.callNumber);
                event.preventDefault();
            });


            this.jq(ID_TEXT_FIELD).autocomplete({
                source: function(request, callback) {
                }
            });

	},
        getDefaultHtml: function() {
	    let html = this.makeSearchForm();
	    let  style="";
	    let abs = (this.getProperty("resultsPosition","absolute")=="absolute");
	    if(!abs) {
		if(this.getMaxHeight(400)) {
		    style+=HU.css("max-height",HU.getDimension(this.getMaxHeight(400)));
		} 
		if(this.getMaxWidth()) {
		    style+=HU.css("width",HU.getDimension(this.getMaxWidth(400)));
		    style+=HU.css("max-width",HU.getDimension(this.getMaxWidth(200)));
		}
		let entries = HU.div([ID,this.domId(ID_ENTRIES),CLASS,"display-simplesearch-entries",STYLE,style]);
		if (this.getShowHeader(true)) {
		    html+=  HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)]);
		}
		html+=entries;
	    }
	    return html;
	},
        makeSearchForm: function() {
            var form = HU.openTag("form", [ATTR_ID, this.getDomId(ID_FORM), "action", "#"]);
	    
	    let eg = this.getEgText();
	    let text  = this.getFormText();
	    let size = this.getPropertyInputWidth("100%");
            var textField = HU.input("", text, [STYLE, HU.css("width", size), "placeholder", eg, ATTR_CLASS, "display-search-input", ATTR_ID, this.getDomId(ID_TEXT_FIELD)]);

	    form += textField;
            form += "<input type=\"submit\" style=\"position:absolute;left:-9999px;width:1px;height:1px;\"/>";
            form += HU.closeTag("form");
	    form+=HU.div([ID,this.domId(ID_FORM)]);
            return form;
	},
	handleNoEntries: function() {
	    this.writeEntries("",[]);
            this.writeMessage("Nothing found");
            this.getDisplayManager().handleEventEntriesChanged(this, []);
	},
	writeMessage: function(msg) {
	    this.makeDialog();
	    SUPER.writeMessage.call(this,msg);
	},

	makeDialog: function() {
	    if(this.dialog && (this.dialog.parent()==null ||this.dialog.parent().length==0)) this.dialog = null;
	    if(!this.dialog) {
                let header = HU.div([ATTR_CLASS, "display-entries-results", ATTR_ID, this.getDomId(ID_RESULTS)], "&nbsp;");
                let entries= HU.div([CLASS,"display-entries-entries", ATTR_ID, this.getDomId(ID_ENTRIES)], "");		
		this.dialog = HU.makeDialog({content:header+entries,anchor:this.getContents(),
					     draggable:true,header:true});
	    } else {
		this.dialog.show();
	    }
	},	    
	writeEntries: function(msg, entries) {
	    let abs = this.getProperty("resultsPosition","absolute")=="absolute";
	    if(!abs) {
		this.jq(ID_ENTRIES).html(msg);
		return;
	    }
	    this.makeDialog();

	    if(Utils.stringDefined(msg)) {
		this.jq(ID_ENTRIES).html(msg);
		this.writeMessage(this.getResultsHeader(entries,true));
	    } else {
		this.jq(ID_ENTRIES).html("");
	    }
	},

        submitSearchForm: function(auto, callNumber) {
	    this.writeMessage(this.getWaitImage() + " " +"Searching...");
	    if(callNumber==null) callNumber = this.callNumber;
            this.haveSearched = true;
            let settings = this.getSearchSettings();
            settings.text = this.getFieldValue(this.getDomId(ID_TEXT_FIELD), settings.text);
	    settings.entryRoot = this.getProperty("entryRoot");
	    settings.entryType = this.getProperty("entryType");	    
            if (this.haveTypes) {
                settings.entryType = this.getFieldValue(this.getDomId(ID_TYPE_FIELD), settings.entryType);
            }
            let theRepository = this.getRamadda()
            let jsonUrl = this.makeSearchUrl(this.getRamadda());
            this.entryList = new EntryList(this.getRamadda(), jsonUrl);
	    let success= ()=>{
		if(this.callNumber == callNumber) {
		    this.entryListChanged(this.entryList);
		} 
	    };
	    let fail= (error)=>{
		this.writeEntries("Error:" + error);
	    };	    
	    this.entryList.doSearch(null,success,fail);
	    if(!auto)
		this.updateForSearching(jsonUrl);
        },


        makeDisplayList: function() {
            var entries = this.getSelectedEntriesFromTree();
            if (entries.length == 0) {
                return;
            }
            var props = {
                selectedEntries: entries,
                showForm: false,
                showMenu: true,
                fixedEntries: true
            };
            props.entryList = new EntryList(this.getRamadda(), "", this, false);
            props.entryList.setEntries(entries);
            this.getDisplayManager().createDisplay(DISPLAY_ENTRYLIST, props);
        },
        handleEventEntrySelection: function(source, args) {
            this.selectEntry(args.entry, args.selected);
        },
        selectEntry: function(entry, selected) {
            var changed = false;
            if (selected) {
                this.jq("entry_" + entry.getIdForDom()).addClass("ui-selected");
                var index = this.selectedEntries.indexOf(entry);
                if (index < 0) {
                    this.selectedEntries.push(entry);
                    changed = true;
                }
            } else {
                this.jq("entry_" + entry.getIdForDom()).removeClass("ui-selected");
                var index = this.selectedEntries.indexOf(entry);
                if (index >= 0) {
                    this.selectedEntries.splice(index, 1);
                    changed = true;
                }
            }
        },
        makeEntriesDisplay: function(entries) {
            return this.getEntriesTree(entries);
        },
        entryListChanged: function(entryList) {
            if (this.multiSearch) {
                this.multiSearch.count--;
            }
            SUPER.entryListChanged.apply(this, [entryList]);
            var entries = this.entryList.getEntries();
            if (entries.length == 0) {
                this.getSearchSettings().skip = 0;
                this.getSearchSettings().max = DEFAULT_MAX;
		this.handleNoEntries();
                return;
            }
            this.writeMessage(this.getResultsHeader(entries, true));
	    this.initCloser(ID_RESULTS);

            var get = this.getGet();
            this.writeHtml(ID_FOOTER_LEFT, "");
            if (this.footerRight != null) {
                this.writeHtml(ID_FOOTER_RIGHT, this.footerRight);
            }


	    let html = "";
	    let inner = "";
	    entries.forEach((entry,idx) =>{
		inner+=HU.div([CLASS,"display-simplesearch-entry"], HU.href(this.getRamadda().getEntryUrl(entry),HU.image(entry.getIconUrl()) +"  "+ entry.getName()));
	    });
//	    inner = HU.div([CLASS,"display-simplesearch-entries"],inner);
            this.writeEntries(inner, entries);
            this.getDisplayManager().handleEventEntriesChanged(this, entries);
        },

    });
}


/**
Copyright 2008-2019 Geode Systems LLC
*/


//uncomment this to add this type to the global list
//addGlobalDisplayType({type: "example", label:"Example"});


/*
  This gets created by the displayManager.createDisplay('example')
 */
function RamaddaExampleDisplay(displayManager, id, properties) {

    //Dom id for example
    //The displays use display.getDomId(ID_CLICK) to get a unique (based on the display id) id
    var ID_CLICK = "click";

    var ID_DATA = "data";

    //Create the base class
    RamaddaUtil.inherit(this, new RamaddaDisplay(displayManager, id, "example", properties));

    //Add this display to the list of global displays
    addRamaddaDisplay(this);

    //Define the methods
    RamaddaUtil.defineMembers(this, {
        //gets called by displaymanager after the displays are layed out
        initDisplay: function() {
            //Call base class to init menu, etc
            this.createUI();

            //I've been calling back to this display with the following
            //this returns "getRamaddaDisplay('" + this.getId() +"')";
            var get = this.getGet();
            var html = "<p>";
            html += HtmlUtils.onClick(get + ".click();", HtmlUtils.div([ATTR_ID, this.getDomId(ID_CLICK)], "Click me"));
            html += "<p>";
            html += HtmlUtils.div([ATTR_ID, this.getDomId(ID_DATA)], "");

            //Set the contents
            this.setContents(html);

            //Add the data
            this.updateUI();
        },
        //this tells the base display class to loadInitialData
        needsData: function() {
            return true;
        },
        //this gets called after the data has been loaded
        updateUI: function() {
            var pointData = this.getData();
            if (pointData == null) return;
            var recordFields = pointData.getRecordFields();
            var records = pointData.getRecords();
            var html = "";
            html += "#records:" + records.length;
            //equivalent to:
            //$("#" + this.getDomId(ID_DATA)).html(html);
            this.jq(ID_DATA).html(html);
        },
        //this gets called when an event source has selected a record
        handleEventRecordSelection: function(source, args) {
            //args: index, record, html
            //this.setContents(args.html);
        },
        click: function() {
            this.jq(ID_CLICK).html("Click again");
        }
    });
}/**
   Copyright 2008-2019 Geode Systems LLC
*/

const DISPLAY_MAP = "map";
const DISPLAY_MAPGRID = "mapgrid";
const DISPLAY_MAPCHART = "mapchart";
const DISPLAY_MAPARRAY = "maparray";
const DISPLAY_MAPSHRINK = "mapshrink";
const DISPLAY_MAPIMAGES = "mapimages";

let displayMapMarkers = ["marker.png", "marker-blue.png", "marker-gold.png", "marker-green.png"];
let displayMapCurrentMarker = -1;
let displayMapUrlToVectorListeners = {};
let displayMapMarkerIcons = {};



addGlobalDisplayType({
    type: DISPLAY_MAP,
    label: "Map",
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Maps of many colors",["map1.png","map2.png"],"Lots of ways to show georeferenced data - dots, heatmaps, plots, etc"),        
});

addGlobalDisplayType({
    type: DISPLAY_MAPGRID,
    label: "Map Grid",
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Schematic map grid","mapgrid.png","Can display US States or World countries"),    
});

addGlobalDisplayType({
    type: DISPLAY_MAPCHART,
    label: "Map Chart",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("2.5D display in a map","mapchart.png","Plot numeric data as heights. Can display US States, European countries or world countries"),        
});


addGlobalDisplayType({
    type: DISPLAY_MAPSHRINK,
    label: "Map Shrink",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Show values as relative size of map regions","mapshrink.png","Can display US States, European countries or world countries"),            
});


addGlobalDisplayType({
    type: DISPLAY_MAPARRAY,
    label: "Map Array",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Colored map regions displayed separately","maparray.png","Can display US States, European countries or world countries"),                
});
addGlobalDisplayType({
    type: DISPLAY_MAPIMAGES,
    label: "Map Images",
    requiresData: true,
    category:CATEGORY_MAPS,
    tooltip: makeDisplayTooltip("Display images in map regions","mapimage.png","Can display US States, European countries or world countries"),                    
});




function MapFeature(source, points) {
    RamaddaUtil.defineMembers(this, {
        source: source,
        points: points
    });
}


function RamaddaMapDisplay(displayManager, id, properties) {
    const ID_MAP = "map";
    const ID_LATFIELD = "latfield";
    const ID_LONFIELD = "lonfield";
    const ID_SIZEBY_LEGEND = "sizebylegend";
    const ID_COLORTABLE_SIDE = "colortableside";
    const ID_SHAPES = "shapes";
    const ID_HEATMAP_ANIM_LIST = "heatmapanimlist";
    const ID_HEATMAP_ANIM_PLAY = "heatmapanimplay";
    const ID_HEATMAP_ANIM_STEP = "heatmapanimstep";
    const ID_HEATMAP_TOGGLE = "heatmaptoggle";    
    const ID_REGION_SELECTOR = "regionselector";
    const ID_HTMLLAYER = "htmllayer";
    const ID_TRACK_VIEW = "trackview";

    $.extend(this, {
        showBoxes: true,
        showPercent: false,
        percentFields: null,
        kmlLayer: null,
        kmlLayerName: "",
        geojsonLayer: null,
        geojsonLayerName: "",
        theMap: null
    });

    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_MAP, properties);
    RamaddaUtil.inherit(this,SUPER);
    addRamaddaDisplay(this);
    this.defineSizeByProperties();
    let myProps = [
	{label:'Map Properties'},
	{p:'strokeWidth',d:1},
	{p:'strokeColor',d:'#000'},
	{p:"fillColor",d:"blue"},
	{p:"fillOpacity",d:0.8},
	{p:'radius',d:5,tt:"Size of the map points"},
	{p:'scaleRadius',ex:"true",tt:'Scale the radius based on # points shown'},
	{p:'radiusScale',ex:"value,size,value,size e.g.: 10000,1,8000,2,5000,3,2000,3,1000,5,500,6,250,8,100,10,50,12",tt:'Radius scale'},
	{p:'shape',d:'circle',ex:'plane|star|cross|x|square|triangle|circle|lightning|church',tt:'Use shape'},
	{p:'markerIcon',ex:"/icons/..."},
	{p:'iconSize',ex:16},
	{p:'justOneMarker',ex:"true",tt:'This is for data that is all at one point and you want to support selecting points for other displays'},	
	{p:'bounds',ex:'north,west,south,east',tt:'initial bounds'},
	{p:'gridBounds',ex:'north,west,south,east'},	
	{p:'mapCenter',ex:'lat,lon',tt:"initial position"},
	{p:'zoomLevel',ex:4,tt:"initial zoom"},
	{p:'zoomTimeout',ex:500,tt:"initial zoom timeout delay. set this if the map is in tabs, etc, and not going to the initial zoom"},
	{p:'fixedPosition',ex:true,tt:'Keep the initial position'},
	{p:'linked',ex:true,tt:"Link location with other maps"},
	{p:'linkGroup',ex:'some_name',tt:"Map groups to link with"},

	{p:'initialLocation', ex:'lat,lon',tt:"initial location"},
	{p:'defaultMapLayer',ex:'ol.openstreetmap|esri.topo|esri.street|esri.worldimagery|esri.lightgray|esri.physical|opentopo|usgs.topo|usgs.imagery|usgs.relief|osm.toner|osm.toner.lite|watercolor'},
	{p:'mapLayers',ex:'ol.openstreetmap,esri.topo,esri.street,esri.worldimagery,esri.lightgray,esri.physical,opentopo,usgs.topo,usgs.imagery,usgs.relief,osm.toner,osm.toner.lite,watercolor'},
	{p:'extraLayers',tt:'comma separated list of layers to display',
	 ex:'baselayer:goes-visible,baselayer:nexrad,geojson:US States:/resources/usmap.json:fillColor:transparent'},
	{p:'doPopup', ex:'false',tt:"Don't show popups"},
	{p:'labelField',ex:'',tt:'field to show in TOC'},
	{p:'showRegionSelector',ex:true},
	{p:'regionSelectorLabel'},	
	{p:'showBaseLayersSelect',ex:true},
	{p:'centerOnFilterChange',ex:true,tt:'Center map when the data filters change'},
	{p:'centerOnHighlight',ex:true,tt:'Center map when a record is highlighted'},
	{p:'boundsAnimation',ex:true,tt:'Animate when map is centered'},
	{p:'iconField',ex:'""',tt:'Field id for the image icon url'},
	{p:'rotateField',ex:'""',tt:'Field id for degrees rotation'},	

	{label:"Map GUI"},
	{p:'showTableOfContents',ex:'true',tt:'Show left table of contents'},
	{p:'tableOfContentsTitle'},
	{p:'showMarkersToggle',ex:'true',tt:'Show the toggle checkbox for the marker layer'},
	{p:'showMarkersToggleLabel',ex:'label',tt:'Label to use for checkbox'},
	{p:'showClipToBounds',ex:'true',tt:'Show the clip bounds checkbox'},
	{p:'clipToBounds',ex:'true',tt:'Clip to bounds'},	
	{p:'showMarkers',ex:'false',tt: 'Hide the markers'},
	{p:'showLocationSearch',ex:'true'},
	{p:'showLatLonPosition',ex:'false'},
	{p:'showLayerSwitcher',ex:'false'},
	{p:'showScaleLine',ex:'true'},
	{p:'showZoomPanControl',ex:'true'},
	{p:'showZoomOnlyControl',ex:'false'},
	{p:'enableDragPan',ex:'false'},
	{p:'showLayers',d:true,ex:'false'},



	{label:'Map Highlight'},
	{p:'showRecordSelection',ex:'false'},
	{p:'highlight',ex:'true',tt:"Show mouse over highlights"},
	{p:'displayDiv',tt:'Div id to show highlights in'},
	{p:'recordHighlightShape',ex:'circle|star|cross|x|square|triangle|circle|lightning|rectangle'},
	{p:'recordHighlightRadius',ex:'20',tt:'Radius to use to show other displays highlighted record'},
	{p:'recordHighlightStrokeWidth',ex:'2',tt:'Stroke to use to show other displays highlighted record'},
	{p:'recordHighlightStrokeColor',ex:'red',tt:'Color to use to show other displays highlighted record'},
	{p:'recordHighlightFillColor',ex:'rgba(0,0,0,0)',tt:'Fill color to use to show other displays highlighted record'},
	{p:'recordHighlightFillOpacity',ex:'0.5',tt:'Fill opacity to use to show other displays highlighted record'},
	{p:'recordHighlightVerticalLine',tt:'Draw a vertical line at the location of the selected record'},
	{p:'highlightColor',ex:'#ccc',tt:''},
	{p:'highlightStrokeWidth',ex:'2',tt:''},	
	{p:'unhighlightColor',ex:'#ccc',tt:'Fill color when records are unhighlighted with the filters'},
	{p:'unhighlightStrokeWidth',ex:'1',tt:'Stroke width for when records are unhighlighted with the filters'},
	{p:'unhighlightStrokeColor',ex:'#aaa',tt:'Stroke color for when records are unhighlighted with the filters'},
	{p:'unhighlightRadius',ex:'1',tt:'Radius for when records are highlighted with the filters'},

	{label:'Map Vectors'},
	{p:'vectorLayerStrokeColor',ex:'#000'},
	{p:'vectorLayerFillColor',ex:'#ccc'},
	{p:'vectorLayerFillOpacity',ex:'0.25'},
	{p:'vectorLayerStrokeWidth',ex:'1'},

	{label:"Map Collisions"},
	{p:'handleCollisions',ex:'true',tt:"Handle point collisions"},
	{p:'collisionFixed',d:true,ex:'false',tt:"Always show markers"},
	{p:'collisionMinPixels',d:16,ex:'16',tt:"How spread out"},
	{p:'collisionDotColor',ex:'red',tt:"Color of dot drawn at center"},
	{p:'collisionDotRadius',ex:'3',tt:"Radius of dot drawn at center"},
	{p:'collisionScaleDots',ex:'false',d:true,tt:"Scale the group dots"},					
	{p:'collisionLineColor',ex:'red',tt:"Color of line drawn at center"},


	{label:"Map Lines"},
	{p:'showSegments',ex:'true',tt:'If data has 2 lat/lon locations draw a line'},
	{p:'isPath',ex:'true',tt:'Make a path from the points'},	
	{p:'pathWidth',ex:'2'},
	{p:'pathColor',ex:'red'},	
	{p:'showPathEndPoint',ex:true},
	{p:'pathEndPointShape',ex:'arrow'},
	{p:'latField1',tt:'Field id for segments'},
	{p:'lonField1',tt:'Field id for segments'},
	{p:'latField2',tt:'Field id for segments'},
	{p:'lonField2',tt:'Field id for segments'},
	{p:'trackUrlField',ex:'field id',tt:'The data can contain a URL that points to data'},

	{label:"Map Labels"},
	{p:"labelFontColor",ex:"#000"},
	{p:"labelFontSize",ex:"12px"},
	{p:"labelFontFamily",ex:"'Open Sans', Helvetica Neue, Arial, Helvetica, sans-serif"},
	{p:"labelFontWeight",ex:"plain"},
	{p:"labelAlign",ex:"l|c|r t|m|b"},
	{p:"labelXOffset",ex:"0"},
	{p:"labelYOffset",ex:"0"},
	{p:"labelOutlineColor",ex:"#fff"},
	{p:"labelOutlineWidth",ex:"0"},


	{label:'Map Glyphs'},
	{p:'doGridPoints',ex:'true',tt:'Display a image showing shapes or bars'},
	{p:'gridWidth',ex:'800',tt:'Width of the canvas'},
	{label:'label glyph',p:"glyph1",ex:"type:label,pos:sw,dx:10,dy:-10,label:field_colon_ ${field}_nl_field2_colon_ ${field2}"},
	{label:'rect glyph', p:"glyph1",ex:"type:rect,pos:sw,dx:10,dy:0,colorBy:field,width:150,height:100"},
	{label:'circle glyph',p:"glyph1",ex:"type:circle,pos:n,dx:10,dy:-10,fill:true,colorBy:field,width:20,baseWidth:5,sizeBy:field"},
	{label:'3dbar glyph', p:"glyph1",ex:"type:3dbar,pos:sw,dx:10,dy:-10,height:30,width:8,baseHeight:5,sizeBy:field"},
	{label:'gauge glyph',p:"glyph1",ex:"type:gauge,color:#000,pos:sw,width:50,height:50,dx:10,dy:-10,sizeBy:field,sizeByMin:0"},

	{label:'Heatmap'},
	{p:'doHeatmap',ex:'true',tt:'Grid the data into an image'},
	{p:'hmShowPoints',ex:'true',tt:'Also show the map points'},
	{p:'hmShowReload',ex:'true',tt:''},
	{p:'hmShowGroups',ex:'true',tt:''},
	{p:'showPoints',ex:'true',tt:'Also show the map points'},
	{p:'hmBounds',ex:'north,west,south,east',tt:''},
	{p:'htmlLayerField'},
	{p:'htmlLayerShape',ex:'barchart|piechart'},	
	{p:'htmlLayerWidth',ex:'30'},
	{p:'htmlLayerHeight',ex:'15'},
	{p:'htmlLayerStyle',ex:'css style'},
	{p:'htmlLayerScale',ex:'2:0.75,3:1,4:2,5:3,6:4,7:6',tt:'zoomlevel:scale,...'},
	{p:'cellShape',ex:'rect|3dbar|circle|vector'},
	{p:'cellColor',ex:'color'},
	{p:'cellFilled',ex:true},
	{p:'cellSize',ex:'8'},
	{p:'cellSizeH',ex:'20',tt:'Base value to scale by to get height'},
	{p:'cellSizeHBase',ex:'0',tt:'Extra height value'},
	{p:'angleBy',ex:'field',tt:'field for angle of vectors'},
	{p:'hmOperator',ex:'count|average|min|max'},
	{p:'hmAnimationSleep',ex:'1000'},
	{p:'hmReloadOnZoom',ex:'true'},
	{p:'reloadOnZoom',ex:'true'},	
	{p:'hmGroupByDate',ex:'true|day|month|year|decade',tt:'Group heatmap images by date'}, 
	{p:'hmGroupBy',ex:'field id',tt:'Field to group heatmap images'}, 
	{p:'hmLabelPrefix'},
	{p:'hmShowToggle'},
	{p:'hmToggleLabel'},
	{p:'boundsScale',ex:'0.1',tt:'Scale up the map bounds'},
	{p:'hmFilter',ex:'average5|average9|average25|gauss9|gauss25',tt:'Apply filter to image'},
	{p:'hmFilterPasses',ex:'1'},
	{p:'hmFilterThreshold',ex:'1'},
	{p:'hmCountThreshold',ex:'1'},
    ];
    
    displayDefineMembers(this, myProps, {
        mapBoundsSet: false,
        features: [],
        myMarkers: {},
        mapEntryInfos: {},
	tracks:{},
        initDisplay: function() {
            SUPER.initDisplay.call(this);
	    if(!HU.documentReady) {
		$( document ).ready(()=> {
		    if(this.map) {
			setTimeout(()=>{
			    this.callingUpdateSize = true;
			    this.map.getMap().updateSize();
			    this.callingUpdateSize = false;
			},50);
		    }
		});
	    }
            var _this = this;
            var html = "";
            var extraStyle="";
            var height = this.getProperty("height", 300);
            if (height < 0) {
		height = (-height)+"%";
	    }
	    height = HU.getDimension(height);
            extraStyle += HU.css(HEIGHT, height);

	    let map =HU.div([ATTR_CLASS, "display-map-map ramadda-expandable-target", STYLE,
			     extraStyle, ATTR_ID, this.domId(ID_MAP)]);

            this.setContents(map);

            if (!this.map) {
                this.createMap();
            } else {
                this.map.setMapDiv(this.domId(ID_MAP));
            }

	    let legendSide = this.getProperty("sizeByLegendSide");
	    if(legendSide) {
		let legend = HU.div([ID,this.domId(ID_SIZEBY_LEGEND)]);
		if(legendSide=="top") {
		    this.jq(ID_TOP).append(legend);
		} else if(legendSide=="left") {
		    this.jq(ID_LEFT).append(legend);
		} else if(legendSide=="right") {
		    this.jq(ID_RIGHT).append(legend);
		} else if(legendSide=="bottom") {
		    this.jq(ID_BOTTOM).append(legend);
		} else {
		    console.log("Unknown legend side:" + legendSide);
		}
	    }


	    this.startProgress();
            if (!this.haveCalledUpdateUI) {
                var callback = function() {
                    _this.updateUI();
                }
                setTimeout(callback, 1);
            }
        },
        checkLayout: function() {
            if (!this.map) {
                return;
            }
            var d = this.jq(ID_MAP);
            if (d.width() > 0 && this.lastWidth != d.width() && this.map) {
                this.lastWidth = d.width();
                this.map.getMap().updateSize();
            }
	    if(!this.setMapLocationAndZoom && this.mapParams) {
		this.setMapLocationAndZoom = true;
		if(this.mapParams.initialZoom>=0) {
		    this.map.getMap().zoomTo(this.mapParams.initialZoom);
		}
		if(this.mapParams.initialLocation) {
		    let loc = MapUtils.createLonLat(this.mapParams.initialLocation.lon, this.mapParams.initialLocation.lat);
		    this.map.setCenter(loc);
		}

	    }
        },

	handlePopup: function(feature, popup) {
	    if(!this.trackUrlField) return;
	    let func = ()=>{
		if(feature.record) {
		    if(this.tracks[feature.record.getId()]) {
			this.removeTrack(feature.record);
		    } else {
			let url = feature.record.getValue(this.trackUrlField.getIndex());
			$.getJSON(url, data=>{this.loadTrack(feature.record, data)}).fail(err=>{console.log("url failed:" + url +"\n" + err)});
		    }
		}
	    };
	    this.jq(ID_TRACK_VIEW).click(func);
	    this.jq(ID_TRACK_VIEW+"_1").click(func);	    
	},
	macroHook: function(record, token,value) {
	    if(!this.trackUrlField) {
		return null;
	    }
	    if(token.tag!=this.trackUrlField.getId()) {
		return null;
	    }
	    if(String(value).trim().length==0) return "";
	    this.currentPopupRecord = record;
	    let haveTrack = this.tracks[record.getId()]!=null;
	    let label =haveTrack?"Remove track":(token.attrs["label"] ||  "View track");
	    return SPACE + HU.span([CLASS,"ramadda-clickable",ID,this.domId(ID_TRACK_VIEW)],label);
	}, 
	getRecordUrlHtml: function(attrs, field, record) {
	    this.currentPopupRecord = record;
	    if(!this.trackUrlField || this.trackUrlField.getId()!=field.getId()) {
		return SUPER.getRecordUrlHtml.call(this, attrs, field, record);
	    }
	    let value = record.getValue(field.getIndex());
	    let haveTrack = this.tracks[record.getId()]!=null;
	    let label = haveTrack?"Remove track":(attrs[field.getId()+".label"] || "View track");
	    return  HU.span([CLASS,"ramadda-clickable",ID,this.domId(ID_TRACK_VIEW+"_1")],label);
	},
	removeTrack:function(record) {
	    if(this.tracks[record.getId()]) {
		this.map.removePolygon(this.tracks[record.getId()]);
		this.tracks[record.getId()] = null;
	    }
	    this.jq(ID_TRACK_VIEW).html("View track");
	    this.jq(ID_TRACK_VIEW+"_1").html("View track");
	    let item = this.jq(ID_LEFT).find(HU.attrSelect(RECORD_ID,record.getId()));
	    item.removeClass("display-map-toc-item-on");
	},
	loadTrack: function(record, data) {
            let newData = makePointData(data, null,this,"");
	    let points = RecordUtil.getPoints(newData.getRecords(),{});
	    let feature = this.markers?this.markers[record.getId()]:null;
	    let item = this.jq(ID_LEFT).find(HU.attrSelect(RECORD_ID,record.getId()));
	    record.trackData = newData;
	    item.addClass("display-map-toc-item-on");
	    try {
		record.setLocation(points[0].y, points[0].x);
		let loc =  new OpenLayers.LonLat(points[0].x, points[0].y);
		loc = this.map.transformLLPoint(loc);
		if(feature)
		    feature.move(loc);
	    } catch(err) {
		console.log(err);
	    }

	    let bounds = {};
	    let attrs = {
		strokeColor:this.getStrokeColor("blue"),
		strokeWidth:this.getStrokeWidth(1)
	    };
            let polygon = this.map.addPolygon("", "", points, attrs);
	    polygon.record = record;
	    this.tracks[record.getId()]=polygon;
	    if(polygon.geometry) {
		this.map.zoomToExtent(polygon.geometry.getBounds());
	    }
	    this.map.closePopup();
	    setTimeout(()=>{
		this.getDisplayManager().notifyEvent("handleEventDataSelection", this, {data:newData});
	    },100);
	},
        createMap: function() {
            let _this = this;
            var params = {
                defaultMapLayer: this.getDefaultMapLayer(map_default_layer),
		showLayerSwitcher: this.getShowLayerSwitcher(true),
		showScaleLine: this.getShowScaleLine(false),
		showLatLonPosition: this.getShowLatLonPosition(true),
		showZoomPanControl: this.getShowZoomPanControl(false),
		showZoomOnlyControl: this.getShowZoomOnlyControl(true),
		enableDragPan: this.getEnableDragPan(true),
		highlightColor: this.getHighlightColor("blue"),
		highlightStrokeWidth: this.getHighlightStrokeWidth(1)
            };
	    this.mapParams = params;
            var displayDiv = this.getProperty("displayDiv", null);
            if (displayDiv) {
                params.displayDiv = displayDiv;
		params.displayDivSticky = this.getProperty("displayDivSticky", false);
            }
            if (!this.getShowLocationSearch(true)) {
                params.showLocationSearch = false;
            }
            var mapLayers = this.getMapLayers(null);
            if (mapLayers) {
                params.mapLayers = [mapLayers];
            }

	    params.linked = this.getLinked(false);
	    params.linkGroup = this.getLinkGroup(null);

	    this.hadInitialPosition = false;
            if (this.getProperty("latitude")) {
		this.hadInitialPosition = true;
                params.initialLocation = {lon:+this.getProperty("longitude", -105),
					  lat:+this.getProperty("latitude", 40)};
	    }
	    if(this.getMapCenter()) {
		this.hadInitialPosition = true;
		[lat,lon] =  this.getMapCenter().split(",");
                params.initialLocation = {lon:lon,lat:lat};
	    }

	    if(this.getZoomLevel()) {
		this.hadInitialPosition = true;
                params.initialZoom = +this.getZoomLevel();
		params.initialZoomTimeout = this.getZoomTimeout();
	    }

            this.map = this.getProperty("theMap", null);
            if (this.map) {
                this.map.setMapDiv(this.domId(ID_MAP));
            } else {
		if(this.getInitialLocation()) {
		    let toks = this.getInitialLocation().split(",");
		    params.initialLocation = {
			lat:+toks[0],
			lon:+toks[1]
		    }
		}
                this.map = new RepositoryMap(this.domId(ID_MAP), params);
		//Set this so there is no popup on the off feature
		this.map.textGetter = (layer,feature) =>{
		    return null;
		};
                this.lastWidth = this.jq(ID_MAP).width();
            }

	    if(!this.getShowMarkers(this.getProperty("markersVisibility", true))) {
		this.map.getMarkersLayer().setVisibility(false);
	    }

            if (this.doDisplayMap()) {
                this.map.setDefaultCanSelect(false);
            }
            this.map.initMap(false);
            this.map.addRegionSelectorControl(function(bounds) {
                _this.getDisplayManager().handleEventMapBoundsChanged(this, bounds, true);
            });
	    this.map.popupHandler = (feature,popup) =>{
		this.handlePopup(feature, popup);
	    };
	    this.map.addFeatureSelectHandler(feature=>{
		this.lastFeatureSelectTime = new Date();
		if(feature.collisionInfo)  {
		    if(this.getCollisionFixed()) return;
		    let info = feature.collisionInfo;
		    info.visible = !info.visible;
		    this.styleCollisionDot(feature);
		    feature.layer.drawFeature(feature, feature.style);
		    //These are the spokes
		    info.features.forEach(f=>{
			f.featureVisible = info.visible;
			this.map.checkFeatureVisible(f,true);
		    });
		    info.records.forEach(record=>{
			let layoutInfo = this.displayInfo[record.getId()];
			if(!layoutInfo) {
			    return;
			}
			layoutInfo.features.forEach(f=>{
			    f.featureVisible = info.visible;
			    this.map.checkFeatureVisible(f,true);
			});
		    });
		}
		if(feature.record) {
		    this.propagateEventRecordSelection({record:feature.record});
		}
		if(feature.record && !this.map.doPopup && this.getProperty("showRecordSelection", true)) {
		    this.highlightPoint(feature.record.getLatitude(),feature.record.getLongitude(),true,false);
		}
		if(feature.record && this.getProperty("shareSelected")) {
		    let idField = this.getFieldById(null,"id");
		    if(idField) {
			ramaddaDisplaySetSelectedEntry(feature.record.getValue(idField.getIndex()),this.getDisplayManager().getDisplays());
		    }
		}
	    });

            this.map.addFeatureHighlightHandler((feature, highlight)=>{
		if(feature.record) {
		    if(this.lastHighlightedRecord) {
			var args = {highlight:false,record: this.lastHighlightedRecord};
			this.getDisplayManager().notifyEvent("handleEventRecordHighlight", this, args);
			if (this.getAnimationEnabled()) {
			    this.getAnimation().handleEventRecordHighlight(this, args);
			}
			this.lastHighlightedRecord = null;
		    }
		    if(highlight) {
			this.lastHighlightedRecord = feature.record;
		    }
		    var args = {highlight:highlight,record: feature.record};
		    this.getDisplayManager().notifyEvent("handleEventRecordHighlight", this, args);
		    if (this.getAnimationEnabled()) {
			this.getAnimation().handleEventRecordHighlight(this, args);
		    }
		}

	    });

	    this.map.highlightBackgroundColor=this.getProperty("highlighBackgroundColor","#fff");
	    this.map.doPopup = this.getProperty("doPopup",true);
            this.map.addClickHandler(this.domId(ID_LONFIELD), this
				     .domId(ID_LATFIELD), null, this);

            this.map.getMap().events.register("updatesize", "", ()=>{
		if(!this.callingUpdateSize) {
		    _this.updateHtmlLayers();
		}
            });



            this.map.getMap().events.register("zoomend", "", ()=>{
                _this.mapBoundsChanged();
		_this.checkHeatmapReload();
		_this.updateHtmlLayers();
		if(!this.haveAddPoints) return;
		if(this.getHandleCollisions()) {
		    this.haveCalledUpdateUI = false;
                    this.updateUI();
		}
            });
	    this.createTime = new Date();
            this.map.getMap().events.register("moveend", "", ()=> {
                _this.mapBoundsChanged();
		_this.checkHeatmapReload();
            });

	    let hasLoc = Utils.isDefined(this.getZoomLevel())   ||
		Utils.isDefined(this.getMapCenter()) ||
		this.hadInitialPosition;
	    
            if (this.getPropertyBounds() ||this.getPropertyGridBounds() ) {
		this.hadInitialPosition = true;
                let toks = this.getPropertyBounds(this.getGridBounds("")).split(",");
                if (toks.length == 4) {
                    if (this.getProperty("showBounds", false)) {
                        var attrs = {};
                        if (this.getProperty("boundsColor")) {
                            attrs.strokeColor = this.getProperty("boundsColor", "");
                        }
                        this.map.addRectangle("bounds", parseFloat(toks[0]), parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]), attrs, "");
                    }
		    if(!hasLoc)
			this.setInitMapBounds(parseFloat(toks[0]), parseFloat(toks[1]), parseFloat(toks[2]), parseFloat(toks[3]));
                }
            }

	    
	    var boundsAnimation = this.getProperty("boundsAnimation");

	    if(boundsAnimation) {
		this.didAnimationBounds = false;
                let animationBounds = boundsAnimation.split(",");
                if (animationBounds.length == 4) {
		    var pause = parseFloat(this.getProperty("animationPause","1000"));
		    HU.callWhenScrolled(this.domId(ID_MAP),()=>{
			if(_this.didAnimationBounds) {
			    return;
			}
			_this.didAnimationBounds = true;
			var a = animationBounds;
			var b = MapUtils.createBounds(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]),parseFloat(a[0]));
			_this.map.animateViewToBounds(b);
		    },pause);
		}
            }


            var currentFeatures = this.features;
            this.features = [];
            for (var i = 0; i < currentFeatures.length; i++) {
                this.addFeature(currentFeatures[i]);
            }
            var entries = this.getDisplayManager().collectEntries();
            for (var i = 0; i < entries.length; i++) {
                var pair = entries[i];
                this.handleEventEntriesChanged(pair.source, pair.entries);
            }


            if (this.layerEntries) {
                var selectCallback = function(layer) {
                    _this.handleLayerSelect(layer);
                }
                var unselectCallback = function(layer) {
                    _this.handleLayerUnselect(layer);
                }
                var toks = this.layerEntries.split(",");
                for (var i = 0; i < toks.length; i++) {
                    var tok = toks[i];
                    var url = ramaddaBaseUrl + "/entry/show?output=shapefile.kml&entryid=" + tok;
		    console.log("kml layer");
                    this.map.addKMLLayer("layer", url, true, selectCallback, unselectCallback);
                    //TODO: Center on the kml
                }
            }


	    for(var markerIdx=1;true;markerIdx++) {
		let marker = this.getProperty("marker" + markerIdx);
		if(!marker) break;
		let props = {};
		if(marker.startsWith("base64:")) {
		    marker = window.atob(marker.substring(7));
		}
		if (marker.indexOf("{") == 0) {
		    props = JSON.parse(marker);
		} else {
		    let [lat,lon,text] = marker.split(",");
		    props.lat = lat;props.lon = lon; props.text = text;
		}
		let point = new OpenLayers.LonLat(parseFloat(props.lon), parseFloat(props.lat));
		if(props.size==null || props.size=="") props.size=16;
		let type = props.type || "icon"

		
		let attrs = props;
		attrs.pointRadius=props.size||"16";
		attrs.labelYOffset = -8-attrs.pointRadius;
		/*
		if(!props.description) props.description = "";
		if(!Utils.isAnonymous()) {
		    props.description +="<br>" + "edit";
		}
		*/

		if(type == "icon") {
		    let icon = props.icon || "/markers/marker-red.png";
		    //addMarker:  function(id, location, iconUrl, markerName, text, parentId, size, yoffset, canSelect) {
		    this.map.addMarker("", point,icon,props.description,props.description,"",parseFloat(props.size||"16"),null,true,attrs);
		} else {
		    //addPoint:  function(id, point, attrs, text, notReally, textGetter)
		    attrs.fillColor=attrs.fillColor||"blue";
		    attrs.strokeWidth=attrs.strokeWidth||"1";		    
		    attrs.graphicName=type;
		    if(type=="none") {
			attrs.graphicName = "circle";
			attrs.pointRadius=0;
			attrs.fillColor="transparent";
		    }
		    this.map.addPoint("", point, attrs, props.description);
		    if(attrs.graphicName!="circle") 
			this.map.addPoint("", point, {pointRadius:attrs.pointRadius, strokeColor:"transparent", fillColor:"transparent"},props.description);
		}
		this.map.doPopup=true;
	    }




	    this.getProperty("extraLayers","").split(",").forEach(tuple=>{
		if(tuple.trim().length==0) return;
		let toks = tuple.split(":");
		toks = toks.map(tok=>{return tok.replace(/_semicolon_/g,":")});
		let getUrl = url =>{
		    if(url.startsWith("resources")) {
			url = ramaddaBaseUrl +"/" + url;
		    } else if(url.startsWith("/resources")) {
			url = ramaddaBaseUrl + url;			
		    } else    if(!url.startsWith("/") && !url.startsWith("http")) {
			url = ramaddaBaseUrl +"/entry/get?entryid=" + url;
		    }
		    return url;
		};

		let type = toks[0];
		if(type=="baselayer") {
		    let layer = this.map.getBaseLayer(toks[1]);
		    if(!layer) {
			console.log("Could not find base layer:" + toks[1]);
		    } else {
			layer.setVisibility(true);
		    }
		} else 	if(type=="geojson" || type=="kml") {
		    let name = toks[1];		
		    let url = getUrl(toks[2]);
//		    console.log("Adding geojson:" + url);
		    let args = {
			fillColor:'transparent',
		    }
		    for(let i=3;i<toks.length;i+=2) {
			args[toks[i]] = toks[i+1];
		    }
		    //(name, url, canSelect, selectCallback, unselectCallback, args, loadCallback, zoomToExtent)
		    if(type=="kml") {
			this.map.addKmlLayer(name, url, false, null, null, args, null);
		    } else {
			this.map.addGeoJsonLayer(name, url, false, null, null, args, null);
		    }
		} else if(type=="wms") {
		    let name = toks[1];
		    let url = toks[2];
		    let layer=toks[3];
                    this.map.addWMSLayer(name,url,layer, false,true);
		  //  "wms:ESRI Aeronautical,https://wms.chartbundle.com/mp/service,sec",
		} else {
		    console.log("Unknown map type:" + type)
		}
	    });


            if (this.getShowLayers()) {
		//do this later so the map displays its initial location OK
		setTimeout(()=>{
                    if (_this.getProperty("kmlLayer")) {
			var url = ramaddaBaseUrl + "/entry/show?output=shapefile.kml&entryid=" + _this.getProperty("kmlLayer");
			_this.addBaseMapLayer(url, true);
                    }
                    if (_this.getProperty("geojsonLayer")) {
			url = _this.getRamadda().getEntryDownloadUrl(_this.getProperty("geojsonLayer"));
			_this.addBaseMapLayer(url, false);
                    }
		},500);
            }
        },
        getBounds: function() {
	    return this.map.getBounds();
	},
        addBaseMapLayer: function(url, isKml) {
            let _this = this;
            mapLoadInfo = displayMapUrlToVectorListeners[url];
            if (mapLoadInfo == null) {
                mapLoadInfo = {
                    otherMaps: [],
                    layer: null
                };
                let selectFunc = function(layer) {
                    _this.mapFeatureSelected(layer);
                }
		//Don't do this for now as its handled elsewhere?
		selectFunc = null;
                let hasBounds = this.getProperty("bounds") != null ||
		    Utils.isDefined(this.getProperty("zoomLevel"))   ||
		    Utils.isDefined(this.getProperty("mapCenter"));
		let attrs =   {
                    strokeColor: this.getProperty("vectorLayerStrokeColor","#000"),
		    fillColor:this.getProperty("vectorLayerFillColor","#ccc"),
		    fillOpacity:this.getProperty("vectorLayerFillOpacity",0.25),
                    strokeWidth: this.getProperty("vectorLayerStrokeWidth",1),
		}
                if (isKml)
                    this.map.addKMLLayer(this.getProperty("kmlLayerName"), url, this.doDisplayMap(), selectFunc, null, attrs,
					 function(map, layer) {
					     _this.baseMapLoaded(layer, url);
					 }, !hasBounds);
                else
                    this.map.addGeoJsonLayer(this.getProperty("geojsonLayerName"), url, this.doDisplayMap(), selectFunc, null, attrs,
					     function(map, layer) {
						 _this.baseMapLoaded(layer, url);
					     }, !hasBounds);
            } else if (mapLoadInfo.layer) {
                this.cloneLayer(mapLoadInfo.layer);
            } else {
                this.map.showLoadingImage();
                mapLoadInfo.otherMaps.push(this);
            }
        },
        mapFeatureSelected: function(layer) {
            if (!this.getPointData()) {
                return;
            }
            this.map.onFeatureSelect(layer);
            if (!Utils.isDefined(layer.feature.record)) {
                return;
            }
            this.propagateEventRecordSelection({
                record: layer.feature.record
            });
        },
	showVectorLayer:true,
	toggleVectorLayer: function() {
	    this.showVectorLayer = !this.showVectorLayer;
            if(this.vectorLayer != null) {
		this.vectorLayer.setVisibility(this.showVectorLayer);
	    }
	    this.haveCalledUpdateUI = false;
	    this.updateUI();
	},
        doDisplayMap: function() {
            if (!this.getShowLayers()) return false;
            if (!this.getProperty("displayAsMap", true)) return false;
            if(this.getProperty("kmlLayer") || this.getProperty("geojsonLayer")) {
		return this.showVectorLayer;
	    }
        },
        cloneLayer: function(layer) {
            let _this = this;
            this.map.hideLoadingImage();
            layer = layer.clone();
            var features = layer.features;
            var clonedFeatures = [];
            for (var j = 0; j < features.length; j++) {
                feature = features[j];
                feature = feature.clone();
                if (feature.style) {
                    oldStyle = feature.style;
                    feature.style = {};
                    for (var a in oldStyle) {
                        feature.style[a] = oldStyle[a];
                    }
                }
                feature.layer = layer;
                clonedFeatures.push(feature);
            }
            layer.removeAllFeatures();
            this.map.getMap().addLayer(layer);
            layer.addFeatures(clonedFeatures);
            this.vectorLayer = layer;
            this.applyVectorMap();
            this.map.addSelectCallback(layer, this.doDisplayMap(), function(layer) {
                _this.mapFeatureSelected(layer);
            });
        },
        handleEventPointDataLoaded: function(source, pointData) {
        },
        handleEventFieldsSelected: function(source, fields) {
	    if(this.getProperty("selectedFieldIsColorBy") && fields.length>0) {
		this.colorByFieldChanged(fields[0]);
	    }
        },
        baseMapLoaded: function(layer, url) {
            this.vectorLayer = layer;
            this.applyVectorMap();
            mapLoadInfo = displayMapUrlToVectorListeners[url];
            if (mapLoadInfo) {
                mapLoadInfo.layer = layer;
                for (var i = 0; i < mapLoadInfo.otherMaps.length; i++) {
                    mapLoadInfo.otherMaps[i].cloneLayer(layer);
                }
                mapLoadInfo.otherMaps = [];
            }
        },
        handleLayerSelect: function(layer) {
            var args = this.layerSelectArgs;
            if (!this.layerSelectPath) {
                if (!args) {
                    this.map.onFeatureSelect(layer);
                    return;
                }
                //If args was defined then default to search
                this.layerSelectPath = "/search/do";
            }
            var url = ramaddaBaseUrl + this.layerSelectPath;
            if (args) {
                var toks = args.split(",");
                for (var i = 0; i < toks.length; i++) {
                    var tok = toks[i];
                    var toktoks = tok.split(":");
                    var urlArg = toktoks[0];
                    var layerField = toktoks[1];
                    var attrs = layer.feature.attributes;
                    var fieldValue = null;
                    for (var attr in attrs) {
                        var attrName = "" + attr;
                        if (attrName == layerField) {
                            var attrValue = null;
                            if (typeof attrs[attr] == 'object' || typeof attrs[attr] == 'Object') {
                                var o = attrs[attr];
                                attrValue = o["value"];
                            } else {
                                attrValue = attrs[attr];
                            }
                            url = HU.appendArg(url, urlArg, attrValue);
                            url = url.replace("${" + urlArg + "}", attrValue);
                        }
                    }
                }
            }
            url = HU.appendArg(url, "output", "json");
            var entryList = new EntryList(this.getRamadda(), url, null, false);
            entryList.doSearch(this);
            this.getEntryList().showMessage("Searching", HU.div([ATTR_STYLE, HU.css("margin","20px")], this.getWaitImage()));
        },
        getEntryList: function() {
            if (!this.entryListDisplay) {
                var props = {
                    showMenu: true,
                    showTitle: true,
                    showDetails: true,
                    layoutHere: false,
                    showForm: false,
                    doSearch: false,
                };
                var id = this.getUniqueId("display");
                this.entryListDisplay = new RamaddaEntrylistDisplay(this.getDisplayManager(), id, props);
                this.getDisplayManager().addDisplay(this.entryListDisplay);
            }
            return this.entryListDisplay;
        },
        entryListChanged: function(entryList) {
            var entries = entryList.getEntries();
            this.getEntryList().entryListChanged(entryList);
        },
        handleLayerUnselect: function(layer) {
            this.map.onFeatureUnselect(layer);
        },
        addMapLayer: function(source, props) {
            var _this = this;
            var entry = props.entry;
            if (!this.addedLayers) this.addedLayers = {};
            if (this.addedLayers[entry.getId()]) {
                var layer = this.addedLayers[entry.getId()];
                if (layer) {
                    this.map.removeKMLLayer(layer);
                    this.addedLayers[entry.getId()] = null;
                }
                return;
            }

            var type = entry.getType().getId();
            if (type == "geo_shapefile" || type == "geo_geojson") {
                var bounds = MapUtils.createBounds(entry.getWest(), entry.getSouth(), entry.getEast(), entry.getNorth());
                if (bounds.left < -180 || bounds.right > 180 || bounds.bottom < -90 || bounds.top > 90) {
                    bounds = null;
                }

                var selectCallback = function(layer) {
                    _this.handleLayerSelect(layer);
                }
                var unselectCallback = function(layer) {
                    _this.handleLayerUnselect(layer);
                }
                var layer;
                if (type == "geo_geojson") {
                    var url = entry.getRamadda().getEntryDownloadUrl(entry);
                    layer = this.map.addGeoJsonLayer(this.getProperty("geojsonLayerName"), url, this.doDisplayMap(), selectCallback, unselectCallback, null, null, true);
                } else {
                    var url = ramaddaBaseUrl + "/entry/show?output=shapefile.kml&entryid=" + entry.getId();
                    layer = this.map.addKMLLayer(entry.getName(), url, true, selectCallback, unselectCallback, null, null, true);
                }
                this.addedLayers[entry.getId()] = layer;
                return;
            }

            var baseUrl = entry.getAttributeValue("base_url");
            if (!Utils.stringDefined(baseUrl)) {
                console.log("No base url:" + entry.getId());
                return;
            }
            var layer = entry.getAttributeValue("layer_name");
            if (layer == null) {
                layer = entry.getName();
            }
            this.map.addWMSLayer(entry.getName(), baseUrl, layer, false);
        },
        mapBoundsChanged: function() {
            let bounds = this.map.getMap().calculateBounds().transform(this.map.sourceProjection,
								       this.map.displayProjection);
            this.getDisplayManager().handleEventMapBoundsChanged(this, bounds);

	    if(this.clipToView || this.getClipToBounds()) {
		if(this.lastUpdateTime) {
		    let now = new Date();
		    if(now.getTime()-this.lastUpdateTime.getTime()>1000) {
			this.haveCalledUpdateUI = false;
			this.clipBounds = true;
			this.updatingFromClip = true;
			this.updateUI();
		    }
		}
	    }

        },
        addFeature: function(feature) {
            this.features.push(feature);
            feature.line = this.map.addPolygon("lines_" +
					       feature.source.getId(), RecordUtil
					       .clonePoints(feature.points), null);
        },
        getContentsDiv: function() {
            let html =  HU.div([ATTR_CLASS, "display-contents", ID,
			   this.domId(ID_DISPLAY_CONTENTS)], "");
	    return html;
        },
	removeHighlight: function() {
	    if(this.highlightMarker) {
		this.map.removePoint(this.highlightMarker);
		this.map.removeMarker(this.highlightMarker);
		this.map.removePolygon(this.highlightMarker);		
		this.highlightMarker = null;
	    }
	},
	highlightPoint: function(lat,lon,highlight,andCenter) {
	    if(!this.map) return;
	    this.removeHighlight();
	    if(highlight) {
		var point = new OpenLayers.LonLat(lon,lat);
                var attrs = {
                    pointRadius: parseFloat(this.getProperty("recordHighlightRadius", +this.getPropertyRadius(6)+8)),
                    stroke: true,
                    strokeColor: this.getProperty("recordHighlightStrokeColor", "#000"),
                    strokeWidth: parseFloat(this.getProperty("recordHighlightStrokeWidth", 2)),
		    fillColor: this.getProperty("recordHighlightFillColor", "#ccc"),
		    fillOpacity: parseFloat(this.getProperty("recordHighlightFillOpacity", 0.5)),
                };
		if(this.getProperty("recordHighlightUseMarker",false)) {
		    var size = +this.getProperty("recordHighlightRadius", +this.getRadius(24));
		    this.highlightMarker = this.map.addMarker("pt-" + i, point, null, "pt-" + i,null,null,size);
		} else 	if(this.getProperty("recordHighlightVerticalLine",false)) {
		    let points = [];
                    points.push(new OpenLayers.Geometry.Point(lon,0));
		    points.push(new OpenLayers.Geometry.Point(lon,80));
                    this.highlightMarker = this.map.addPolygon(id, "highlight", points, attrs, null);
		} else {
		    attrs.graphicName = this.getProperty("recordHighlightShape");
		    this.highlightMarker =  this.map.addPoint("highlight", point, attrs);
		}
		if(andCenter && this.getProperty("centerOnHighlight",false)) {
		    this.map.setCenter(point);
		}
	    }
	},


        handleEventEntryMouseover: function(source, args) {
            if (!this.map) {
                return;
            }
            id = args.entry.getId() + "_mouseover";
            attrs = {
                lineColor: "red",
                fillColor: "red",
                fillOpacity: 0.5,
                lineOpacity: 0.5,
                doCircle: true,
                lineWidth: 1,
                fill: true,
                circle: {
                    lineColor: "black"
                },
                polygon: {
                    lineWidth: 4,
                }
            }
            this.addOrRemoveEntryMarker(id, args.entry, true, attrs);
        },
        handleEventEntryMouseout: function(source, args) {
            if (!this.map) {
                return;
            }
            id = args.entry.getId() + "_mouseover";
            this.addOrRemoveEntryMarker(id, args.entry, false);
        },
        handleEventAreaClear: function() {
            if (!this.map) {
                return;
            }
            this.map.clearRegionSelector();
        },
        handleClick: function(theMap, event, lon, lat) {
	    if(this.lastFeatureSelectTime) {
		let diff = new Date().getTime()-this.lastFeatureSelectTime.getTime();
		this.lastFeatureSelectTime = null;
		if(diff<1000) {
//		    console.log("too soon to handle click");
		    return;
		}
	    }

	    if(event.shiftKey) {
		if(Utils.isAnonymous()) return;
		let text = prompt("Marker text", "");
		if(!text) return;
		let url = ramaddaBaseUrl +"/metadata/addform?entryid=" + this.getProperty("entryId")+"&metadata_type=map_marker&metadata_attr1=" +
		    encodeURIComponent(text) +"&metadata_attr2=" + lat +"," + lon; 
		window.location = url;
		return
	    }

            if (!this.map) {
                return;
            }
            if (this.doDisplayMap()) {
                return;
            }
            var justOneMarker = this.getProperty("justOneMarker",false);
            if(justOneMarker) {
                var pointData = this.getPointData();
                if(pointData) {
                    pointData.handleEventMapClick(this, this, lon, lat);
		    this.getDisplayManager().notifyEvent("handleEventMapClick", this, {lat:lat,lon:lon});
                }
            }


	    if(!this.records) return;
	    let indexObj = [];
            let closest = RecordUtil.findClosest(this.records, lon, lat, indexObj);
            if (!closest) return;
	    this.propagateEventRecordSelection({record: closest});

	    //If we are highlighting a record then change the marker
	    if(this.highlightMarker) {
		this.highlightPoint(closest.getLatitude(),closest.getLongitude(),true,false);
	    }
	    
	    let fields = this.getFieldsByIds(null, this.getProperty("filterFieldsToPropagate"));
	    fields.map(field=>{
		let args = {
		    property: PROP_FILTER_VALUE,
		    fieldId:field.getId(),
		    value:closest.getValue(field.getIndex())
		};
		this.propagateEvent("handleEventPropertyChanged", args);
	    });
        },

        getPosition: function() {
            var lat = $("#" + this.domId(ID_LATFIELD)).val();
            var lon = $("#" + this.domId(ID_LONFIELD)).val();
            if (lat == null)
                return null;
            return [lat, lon];
        },

        haveInitBounds: false,
        setInitMapBounds: function(north, west, south, east) {
            if (!this.map) return;
            if (this.haveInitBounds) return;
            this.haveInitBounds = true;
            this.map.centerOnMarkers(new OpenLayers.Bounds(west, south, east,
							   north),true);
        },

        sourceToEntries: {},
        handleEventEntriesChanged: function(source, entries) {
            if (!this.map) {
                return;
            }
            //debug
            if (source == this.lastSource) {
                this.map.clearSelectionMarker();
            }
            if ((typeof source.forMap) != "undefined" && !source.forMap) {
                return;
            }
            var oldEntries = this.sourceToEntries[source.getId()];
            if (oldEntries != null) {
                for (var i = 0; i < oldEntries.length; i++) {
                    var id = source.getId() + "_" + oldEntries[i].getId();
                    this.addOrRemoveEntryMarker(id, oldEntries[i], false);
                }
            }

            this.sourceToEntries[source.getId()] = entries;

            var markers = new OpenLayers.Layer.Markers("Markers");
            var lines = new OpenLayers.Layer.Vector("Lines", {});
            var north = -90,
                west = 180,
                south = 90,
                east = -180;
            var didOne = false;
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                var id = source.getId() + "_" + entry.getId();
                var mapEntryInfo = this.addOrRemoveEntryMarker(id, entries[i], true);
                if (entry.hasBounds()) {
                    if (entry.getNorth() > 90 ||
                        entry.getSouth() < -90 ||
                        entry.getEast() > 180 ||
                        entry.getWest() < -180) {
                        console.log("bad bounds on entry:" + entry.getName() + " " +
				    entry.getNorth() + " " +
				    entry.getSouth() + " " +
				    entry.getEast() + " " +
				    entry.getWest());
                        continue;
                    }

                    north = Math.max(north, entry.getNorth());
                    south = Math.min(south, entry.getSouth());
                    east = Math.max(east, entry.getEast());
                    west = Math.min(west, entry.getWest());
                    didOne = true;
                }
            }
            var bounds = (didOne ? MapUtils.createBounds(west, south, east, north) : null);
            //debug                    this.map.centerOnMarkers(bounds, true);
        },
        handleEventEntrySelection: function(source, args) {
            if (!this.map) {
                return;
            }
            var _this = this;
            var entry = args.entry;
            if (entry == null) {
                this.map.clearSelectionMarker();
                return;
            }
            var selected = args.selected;

            if (!entry.hasLocation()) {
                return;
            }
        },
        addOrRemoveEntryMarker: function(id, entry, add, args) {
            if (!args) {
                args = {};
            }
            var dflt = {
                lineColor: entry.lineColor,
                fillColor: entry.lineColor,
                lineWidth: entry.lineWidth,
                doCircle: false,
                doRectangle: this.showBoxes,
                fill: false,
                fillOpacity: 0.75,
                pointRadius: 12,
                polygon: {},
                circle: {}
            }
            dfltPolygon = {}
            dfltCircle = {}
            $.extend(dflt, args);
            if (!dflt.lineColor) dflt.lineColor = "blue";

            $.extend(dfltPolygon, dflt);
            if (args.polygon)
                $.extend(dfltPolygon, args.polygon);
            $.extend(dfltCircle, dflt);
            if (args.circle)
                $.extend(dfltCircle, args.circle);

            var mapEntryInfo = this.mapEntryInfos[id];
            if (!add) {
                if (mapEntryInfo != null) {
                    mapEntryInfo.removeFromMap(this.map);
                    this.mapEntryInfos[id] = null;
                }
            } else {
                if (mapEntryInfo == null) {
                    mapEntryInfo = new MapEntryInfo(entry);
                    this.mapEntryInfos[id] = mapEntryInfo;
                    if (entry.hasBounds() && dflt.doRectangle) {
                        var attrs = {};
                        mapEntryInfo.rectangle = this.map.addRectangle(id,
								       entry.getNorth(), entry.getWest(), entry
								       .getSouth(), entry.getEast(), attrs);
                    }
                    var latitude = entry.getLatitude();
                    var longitude = entry.getLongitude();
                    if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) {
                        return;
                    }
                    var point = new OpenLayers.LonLat(longitude, latitude);
                    if (dflt.doCircle) {
                        attrs = {
                            pointRadius: dfltCircle.pointRadius,
                            stroke: true,
                            strokeColor: dfltCircle.lineColor,
                            strokeWidth: dfltCircle.lineWidth,
                            fillColor: dfltCircle.fillColor,
                            fillOpacity: dfltCircle.fillOpacity,
                            fill: dfltCircle.fill,
                        };
                        mapEntryInfo.circle = this.map.addPoint(id, point, attrs);
                    } else {
                        mapEntryInfo.marker = this.map.addMarker(id, point, entry.getIconUrl(), "", this.getEntryHtml(entry));
                    }
                    if (entry.polygon) {
                        var points = []
                        for (var i = 0; i < entry.polygon.length; i += 2) {
                            points.push(new OpenLayers.Geometry.Point(entry.polygon[i + 1], entry.polygon[i]));
                        }
                        var attrs = {
                            strokeColor: dfltPolygon.lineColor,
                            strokeWidth: Utils.isDefined(dfltPolygon.lineWidth) ? dfltPolygon.lineWidth : 2
                        };
                        mapEntryInfo.polygon = this.map.addPolygon(id, entry.getName(), points, attrs, mapEntryInfo.marker);
                    }
                    var _this = this;
                    if (mapEntryInfo.marker) {
                        mapEntryInfo.marker.entry = entry;
                        mapEntryInfo.marker.ramaddaClickHandler = function(marker) {
                            _this.handleMapClick(marker);
                        };
                        if (this.handledMarkers == null) {
                            this.map.centerToMarkers();
                            this.handledMarkers = true;
                        }
                    }
                }
                return mapEntryInfo;
            }
        },
        handleMapClick: function(marker) {
            if (this.selectedMarker != null) {
                this.getDisplayManager().handleEventEntrySelection(this, {
                    entry: this.selectedMarker.entry,
                    selected: false
                });
            }
            this.getDisplayManager().handleEventEntrySelection(this, {
                entry: marker.entry,
                selected: true
            });
            this.selectedMarker = marker;
        },
        applyVectorMap: function(force, textGetter, args) {
            if (!force && this.vectorMapApplied) {
                return;
            }
            if (!this.doDisplayMap() || !this.vectorLayer || !this.points) {
                return;
            }
	    
	    if(!args) args = {};
	    let debug = false;
	    if(debug) console.log("applyVectorMap");
	    if(!textGetter) textGetter  = this.textGetter;

	    let linkField=this.getFieldById(null,this.getProperty("linkField"));
	    let linkFeature=this.getProperty("linkFeature");
            let features = this.vectorLayer.features.slice();
            let allFeatures = features.slice();
	    let recordToFeature = {};
	    if(debug) console.log("\t#features:" + features.length);


	    this.points.forEach(point=>{
		let record = point.record;
		let feature = record.getDisplayProperty(this,"feature");
		if(feature)  recordToFeature[record.getId()] = feature;
	    });



	    if(linkFeature && linkField) {
		var recordMap = {};
		this.points.forEach(p=>{
		    var record = p.record;
		    if(record) {
			var tuple = record.getData();
			var value = tuple[linkField.getIndex()];
			value  = value.toString().trim();
			record.linkValue = value;
			recordMap[value] = record;
		    }
		});

		features.forEach(feature=>{
		    let attrs = feature.attributes;
		    let ok = false;
		    for (let attr in attrs) {
			if(linkFeature==attr) {
			    ok  = true;
			    let value = this.map.getAttrValue(attrs, attr);
			    let debug = false;
			    if(value) {
				if(debug)
				    console.log("\tbefore");
				value = value.toString().trim();
				feature.linkValue = value;
				record = recordMap[value];
				if(record) {
				    if(debug)
					console.log("\tAdding:" + value+": " + record.getId());
				    recordToFeature[record.getId()] = feature;
				} else {
				    if(debug)
					console.log("\tCould not find record:" + value.replace(/ /g,"X") +":");
				}
				if(debug)
				    console.log("\tAFter");
			    } else {
				console.log("no attr value");
			    }
			    
			}
		    }
		    if(!ok) console.log("No ATTR found");
		});
	    }

	    let j=0;
	    features.forEach((feature,idx)=>{
		feature.wasPruned = feature.pruned;
		feature.pruned = false;
		feature.newStyle=null;
		if(feature.style) {
		    feature.style.display ="inline-block";
		}
		feature.featureIndex = j++;
		feature.featureMatched = false;
		feature.pointCount = 0;
		feature.circles = [];
		if(feature.style)feature.style.balloonStyle = null;
	    });

            this.vectorMapApplied = true;

	    let maxExtent = null;
	    let doCount = this.getProperty("colorByCount",false);
	    let matchedFeatures = [];
	    let seen = {};
	    let maxCnt = -1;
	    let minCnt = -1;

	    this.points.forEach(point=>{
                if (point.style && point.style.display == "none") return;
		let record = point.record;
                let center = point.center;
		let tmp = {index:-1,maxExtent: maxExtent};
		let matchedFeature = recordToFeature[record.getId()];
		if(matchedFeature) {
		    matchedFeature.featureMatched = true;
		    if (matchedFeature.geometry) {
			if (maxExtent === null) {
			    maxExtent = new OpenLayers.Bounds();
			}
			maxExtent.extend(matchedFeature.geometry.getBounds());
		    } else {
			//console.log("no geometry:" + matchedFeature.CLASS_NAME);
		    }
		}  else {
                    matchedFeature = this.findContainingFeature(features, center,tmp,false);
		}
		if(!matchedFeature) {
		    return;
		}
		record.setDisplayProperty(this,"feature",matchedFeature);
		if(!point.colorByColor && point.hasColorByValue && isNaN(point.colorByValue)) {
		    return;
		}
		maxExtent = tmp.maxExtent;
		if(!seen[matchedFeature.featureIndex]) {
		    seen[matchedFeature.featureIndex] = true;
		    matchedFeatures.push(matchedFeature); 
		}
		matchedFeature.circles.push(point);
		matchedFeature.record = record;
		matchedFeature.textGetter=textGetter;
		if(doCount) {
		    matchedFeature.pointCount++;
		    maxCnt = maxCnt==-1?matchedFeature.pointCount:Math.max(maxCnt, matchedFeature.pointCount);
		    minCnt = minCnt==-1?matchedFeature.pointCount:Math.min(minCnt, matchedFeature.pointCount);
		} else {
		    if(tmp.index>=0)
			features.splice(tmp.index, 1);
		}
	    });



	    if(!doCount) {
		for(let i=0;i<matchedFeatures.length;i++) {
		    let matchedFeature = matchedFeatures[i];
		    style = matchedFeature.style;
		    if (!style) style = {
			"stylename": "from display",
		    };
		    style.display = null;
		    let newStyle = {};
		    $.extend(newStyle,style);
		    let circle = matchedFeature.circles[0];
		    $.extend(newStyle, circle.style);
		    matchedFeature.newStyle=newStyle;
		    matchedFeature.popupText = circle.text;
		    matchedFeature.dataIndex = i;
		}
	    }


	    let prune = this.getProperty("pruneFeatures", false);
	    if(doCount) {
		let colors = this.getColorTable(true);
		if (colors == null) {
		    colors = Utils.ColorTables.grayscale.colors;
		}
		let range = maxCnt-minCnt;
		let labelSuffix = this.getProperty("doCountLabel","points");
		for (let j = 0; j < features.length; j++) {
		    let feature = features[j];
		    let percent = range==0?0:(feature.pointCount - minCnt) /range;
                    let index = parseInt(percent * colors.length);
                    if (index >= colors.length) index = colors.length - 1;
                    else if (index < 0) index = 0;
		    let color= colors[index];
		    let style = feature.style;
		    if (!style) style = {
			"stylename": "from display",
		    };
		    let newStyle = {};
		    $.extend(newStyle,style);
		    $.extend(newStyle,{
			fillColor: color,
			"fillOpacity": 0.75,
			"strokeWidth": 1,
		    });

		    if(feature.pointCount==0) {
			//TODO: what to do with no count features?
			if(prune === true) {
			    newStyle.display = "none";
			}
		    }
		    feature.newStyle = newStyle;
		    feature.dataIndex = j;
		    feature.popupText = HU.div([],feature.pointCount +SPACE + labelSuffix);
		}
		this.displayColorTable(colors, ID_COLORTABLE, minCnt,maxCnt,{});
	    } else {
		if(prune) {
		    for (let i = 0; i < features.length; i++) {
			let feature = features[i];
			if(feature.featureMatched) {
			    continue;
			}
			let style = feature.style;
			if (!style) style = {
			    "stylename": "from display"
			};
			let newStyle = {};
			$.extend(newStyle,style);
			newStyle.display= "none";
			feature.pruned = true;
			feature.newStyle = newStyle;
		    }
		}
	    }

	    let redrawCnt = 0;
	    allFeatures.forEach((feature,idx)=>{
		if(!feature.newStyle) feature.newStyle={};

//		if(!feature.featureMatched)
//		    feature.newStyle.fillColor="green";


		if(feature.wasPruned && !feature.pruned ||
		   !feature.style ||
		   (feature.newStyle.display && 
		    feature.newStyle.display=="none" &&
		    feature.newStyle.display!=feature.style.display) ||
		   feature.style.fillColor!=feature.newStyle.fillColor) {
		    feature.style = feature.newStyle;
		    if(!feature.style.fillColor) {
			feature.style.fillColor = "rgba(230,230,230,0.5)";
			feature.style.strokeColor = "rgba(200,200,200,0.5)";
			feature.style.strokeWidth=1;
		    }
		    redrawCnt++;
		    this.vectorLayer.drawFeature(feature);
		}
		feature.newStyle = null;
	    });
//	    console.log("redraw:" + redrawCnt);

            if (!args.dontSetBounds && maxExtent && !this.hadInitialPosition && this.getCenterOnFilterChange(true)) {
//		console.log("max:" + this.map.transformProjBounds(maxExtent));
		this.map.zoomToExtent(maxExtent, true);
	    }
	    if(!this.getProperty("fixedPosition",false))  {
		this.hadInitialPosition    = false;
	    }

        },
	findContainingFeature: function(features, center, info,debug) {
//	    debug=true;
	    let matchedFeature = null;
            for (let j = 0; j < features.length; j++) {
                let feature = features[j];
                let geometry = feature.geometry;
                if (!geometry) {
		    if(debug) console.log("\tno geometry")
                    continue;
                }
                bounds = geometry.getBounds();
                if (!bounds.contains(center.x, center.y)) {
		    //		    if(debug) console.log("\tnot in bounds:" + bounds)
                    continue;
                }
		if(debug) console.log("\tfindContainingFeature:" + center.x+" " + center.y);
                if (geometry.components) {
		    if(debug) console.log("\thas components:" +geometry.components.length);
                    geometry.components.every(comp=> {
                        bounds = comp.getBounds();
                        if (!bounds.contains(center.x, center.y)) {
			    if(debug) console.log("\t\tnot contain:" + bounds + " " + comp.CLASS_NAME);
			    return true;
                        }
			if(!comp.containsPoint) {
			    if(debug) console.log("\t\tunknown geometry:" + comp.CLASS_NAME);
			    return true;
			}
			if(debug) console.log("\t\tcontains:" + comp.containsPoint(center));
                        if (comp.containsPoint(center)) {
                            matchedFeature = feature;
			    if (feature.geometry) {
				if (info.maxExtent === null) {
				    info.maxExtent = new OpenLayers.Bounds();
				}
				info.maxExtent.extend(feature.geometry.getBounds());
			    }
                            info.index = j;
			    return false;
                        }
			return true;
                    });
		}
		if(matchedFeature) return matchedFeature;
                if (!geometry.containsPoint) {
                    if(debug && !geometry.components) 
			console.log("unknown geometry:" + geometry.CLASS_NAME);
                    continue;
                }
                if (geometry.containsPoint(center)) {
		    if (info.maxExtent === null) {
			info.maxExtent = new OpenLayers.Bounds();
		    }
		    info.maxExtent.extend(geometry.getBounds());
                    matchedFeature = feature;
                    info.index = j;
                    break;
                }
	    }
	    return matchedFeature;
	},
        needsData: function() {
            return true;
        },
	animationStart:function(animation) {
	    if(this.points) {
                for (var i = 0; i < this.points.length; i++) {
                    var point = this.points[i];
                    point.style.display = 'none';
                }
	    }
            if (this.map.circles)
                this.map.circles.redraw();

	},
        handleDateRangeChanged: function(source, prop) {
	    this.getAnimation().setDateRange(prop.minDate, prop.maxDate);
	    this.applyDateRange();
	},
       	animationApply: function(animation) {
	    SUPER.animationApply.call(this,animation,true);
	    this.applyDateRange();
	},
       	applyDateRange: function() {
	    var animation = this.getAnimation();
            var windowStart = animation.begin.getTime();
            var windowEnd = animation.end.getTime();
            var atLoc = {};
	    if(this.lines==null) return
            for (var i = 0; i < this.lines.length; i++) {
                var line = this.lines[i];
                if (line.date < windowStart || line.date > windowEnd) {
                    line.style.display = 'none';
                    continue;
                }
                line.style.display = 'inline';
	    }

            for (var i = 0; i < this.points.length; i++) {
                let point = this.points[i];
                if (point.date < windowStart || point.date > windowEnd) {
                    point.style.display = 'none';
                    continue;
                }
                if (atLoc[point.location]) {
                    var other = atLoc[point.location];
                    if (other.date < point.date) {
                        atLoc[point.location] = point;
                        other.style.display = 'none';
                        point.style.display = 'inline';
                    } else {
                        point.style.display = 'none';
                    }
                    continue;
                }
                atLoc[point.location] = point;
                point.style.display = 'inline';
            }

            if (this.map.circles)
                this.map.circles.redraw();
            if (this.map.lines)
                this.map.lines.redraw();

	    if (this.map.lines)
                this.map.lines.redraw();
	    if (this.map.markers)
                this.map.markers.redraw();



            this.applyVectorMap(true, this.textGetter);
	},
        showAllPoints: function() {
	    if(this.lines) {
		for (var i = 0; i < this.lines.length; i++) {
		    let line = this.lines[i];
		    line.style.display = 'inline';
		}
		if (this.map.lines)
		    this.map.lines.redraw();
	    }
            if (!this.points) return;
            for (let i = 0; i < this.points.length; i++) {
                let point = this.points[i];
                point.style.display = 'inline';
            }
            if (this.map.circles)
                this.map.circles.redraw();
            this.applyVectorMap(true);
        },

	colorByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("colorBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({fieldChanged:true});
	},
	sizeByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("sizeBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({fieldChanged:true});
	},
	dataFilterChanged: function(args) {
	    if(!args) args = {};
	    this.vectorMapApplied  = false;
	    this.updateUI({source:args.source, dataFilterChanged:true, dontSetBounds:true,  reload:true,callback: ()=>{
		if(args.source=="animation") return;
		if(this.getCenterOnFilterChange(false)) {
		    if (this.vectorLayer && this.showVectorLayer) {
			this.map.zoomToLayer(this.vectorLayer,1.2);
		    } else if(this.lastImageLayer) {
			this.map.zoomToLayer(this.lastImageLayer);
		    } else {
			//true -> Just markers
			this.map.centerOnMarkers(null, false, true);
		    }
		}
	    }});
	},
	requiresGeoLocation: function() {
	    if(this.shapesField && this.shapesTypeField) return false;
	    return true;
	},
	addFilters: function(filters) {
	    SUPER.addFilters.call(this, filters);
	    filters.push(new BoundsFilter(this));
	},
	getHeader2:function() {
	    let html = SUPER.getHeader2.call(this);
	    if(this.getProperty("showClipToBounds")) {
		this.clipToView=false;
		html =  HU.div([STYLE,HU.css("display","inline-block","cursor","pointer","padding","1px","border","1px solid rgba(0,0,0,0)"), TITLE,"Clip to view", ID,this.domId("clip")],HU.getIconImage("fa-map"))+SPACE2+ html;
	    }
	    if(this.getProperty("showMarkersToggle")) {
		let dflt = this.getProperty("markersVisibility", true);
		html += HU.checkbox("",[ID,this.domId("showMarkersToggle")],dflt) +" " +
		    this.getProperty("showMarkersToggleLabel","Show Markers") +SPACE2;
	    }

	    if(this.getProperty("showBaseLayersSelect",false)) {
		if(this.map.baseLayers) {
		    let items = [];
		    let on = false;
		    for(a in this.map.baseLayers) {
			let layer = this.map.baseLayers[a];
			if(!layer.isBaseLayer) continue;
			if(layer.getVisibility()) on = a;
			items.push([a,layer.name]);
		    }
		    html += HU.span([TITLE,"Choose base layer", CLASS,"display-filter"],  HU.select("",[ID,this.domId("baselayers")],items,on));
		}
	    }

	    if(this.getProperty("showVectorLayerToggle",false)) {
		html += HU.checkbox("",[ID,this.domId("showVectorLayerToggle")],!this.showVectorLayer) +" " +
		    this.getProperty("showVectorLayerToggleLabel","Show Points") +SPACE4;
	    }
	    html += HU.span([ID,this.domId("locations")]);

	    return html;
	},
	locationMenuCnt:0,
	addLocationMenu:function(data) {
	    let html = "";
	    let idx = this.locationMenuCnt++;
	    html += HU.div([CLASS,"ramadda-menu-button ramadda-clickable bold",ID,this.domId("location_" + idx)],"Select " + (data.label||data.name)) +SPACE;
	    this.map.appendToolbar(html);
//	    this.jq("locations").append(html);
	    let _this = this;
	    this.jq("location_" + idx).click(function() {
		let inner = "";
		data.locations.sort((a,b)=>{
		    return a.name.localeCompare(b.name);
		});
		data.locations.forEach(loc=>{
		    if(Utils.isDefined(loc.latitude)) {
			inner+=HU.div([CLASS,"ramadda-clickable ramadda-hoverable", "latitude",loc.latitude,"longitude",loc.longitude,CLASS,"display-map-location"], loc.name);
		    } else if(Utils.isDefined(loc.north)) {
			inner+=HU.div([CLASS,"ramadda-clickable ramadda-hoverable", "north",loc.north,"west",loc.west,"south",loc.south,"east",loc.east, CLASS,"display-map-location"], loc.name);
		    }
		});
		inner = HU.div([ID,_this.domId("locationmenu"),STYLE,HU.css("max-height","200px","overflow-y","auto","padding","5px")],inner);
		let dialog = HU.makeDialog({content:inner,my:"left top",at:"left bottom",anchor:$(this),draggable:false,header:false});
		_this.jq("locationmenu").find(".ramadda-clickable").click(function() {
		    if($(this).attr("longitude")) {
			let point = MapUtils.createLonLat(+$(this).attr("longitude"),+$(this).attr("latitude"));
			_this.map.getMap().zoomTo(9);
			_this.map.setCenter(point);
		    } else {
			_this.map.setViewToBounds(new RamaddaBounds(+$(this).attr("north"),+$(this).attr("west"),+$(this).attr("south"),+$(this).attr("east")));
		    }
		    dialog.remove();
		});
	    });
	},
	initHeader2:function() {
	    let _this = this;
	    this.jq("baselayers").change(function() {
		let on = $(this).val();
		for(let id in _this.map.baseLayers) {
		    if(id==on) {
			_this.map.getMap().setBaseLayer(_this.map.baseLayers[id]);
			break;
		    }
		}
	    });


	    this.getProperty("locations","").split(",").forEach(url=>{
		url  =url.trim();
		if(url.length==0) return;
		if(!url.startsWith("/") && !url.startsWith("http")) {
		    url = ramaddaBaseUrl + "/resources/" +url;			
		}
		let success = (data) =>{data=JSON.parse(data);this.addLocationMenu(data);};
		let fail = err=>{console.log("Error loading location json:" + url+"\n" + err);}
		Utils.doFetch(url, success,fail,null);	    
	    });


	    this.jq("showMarkersToggle").change(function() {
		_this.map.setPointsVisibility($(this).is(':checked'));
	    });
	    this.jq("showVectorLayerToggle").change(function() {
		_this.toggleVectorLayer();
	    });
	    
	    this.jq("clip").click(function(e){
		_this.clipToView = !_this.clipToView;
		if(!_this.clipToView) {
		    $(this).css("border","1px solid rgba(0,0,0,0)");
		    _this.clipToView = false;
		    return;
		}
		$(this).css("border","1px solid #aaa");
		_this.haveCalledUpdateUI = false;
		_this.clipBounds = true;
		_this.updateUI();
	    });
	},

	handleNoData: function(pointData,reload) {
	    this.jq(ID_PAGE_COUNT).html("");
            this.addPoints([],[],[]);
	    this.setMessage(this.getNoDataMessage());
	},
	setErrorMessage: function(msg) {
	    if(this.map)
		this.map.setProgress(HU.div([ATTR_CLASS, "display-map-message"], msg));
	    else
		SUPER.setErrorMessage.call(this,msg);
	},
	setMessage: function(msg) {
	    if(this.map) {
		this.map.setProgress(HU.div([ATTR_CLASS, "display-map-message"], msg));
	    }
	},
	setMapLabel: function(msg) {
	    if(this.map)
		this.map.setLabel(HU.div([ATTR_CLASS, "display-map-message"], msg));
	},	
	startProgress: function() {
	    this.setMessage(this.getProperty("loadingMessage","Creating map..."));
	},
	clearProgress: function() {
	    if(this.errorMessage) {
		this.errorMessage = null;
		return;
	    }
	    if(this.map)
		this.map.setProgress("");
	},
	loadShapes: function(records) {
            let baseStyle = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style['default']);
	    $.extend(baseStyle,{
                strokeColor: this.getProperty("vectorLayerStrokeColor","#000"),
		fillColor:this.getProperty("vectorLayerFillColor","#ccc"),
		fillOpacity:this.getProperty("vectorLayerFillOpacity",0.25),
                strokeWidth: this.getProperty("vectorLayerStrokeWidth",1),
		cursor:'pointer'
	    });

	    if(this.coordinateFeatures) {
		this.map.getLinesLayer().removeFeatures(this.coordinateFeatures);
	    }
	    let textGetter = (f)=>{
		if(f.record) {
                    return  this.getRecordHtml(f.record, null, this.getProperty("tooltip"));
		}
		return "NONE";
	    };
	    this.coordinateFeatures = [];
	    let createFeature=(record, polygon) =>{
		let sitePoints = [];
		polygon.forEach(pair=>{
		    let point = new OpenLayers.Geometry.Point(pair[0],pair[1]);
		    let projPoint = this.map.transformLLPoint(point);
		    sitePoints.push(projPoint);
		});
		let linearRing = new OpenLayers.Geometry.LinearRing(sitePoints);
		let geometry = new OpenLayers.Geometry.Polygon([linearRing]);
		let polygonFeature = new OpenLayers.Feature.Vector(geometry, null, baseStyle);
		this.map.getLinesLayer().addFeatures([polygonFeature]);
		this.coordinateFeatures.push(polygonFeature);
		polygonFeature.record = record;
		polygonFeature.textGetter = textGetter;
		return polygonFeature;
	    };
	    records.forEach((r,idx)=>{
		let type = r.getValue(this.shapesTypeField.getIndex());		
		let shapesString= r.getValue(this.shapesField.getIndex());
		let shapes = JSON.parse(shapesString);
		if(type=="MultiPolygon") {
		    for(let i=0;i<shapes.length;i++) {
			let c2 = shapes[i];
			for(let j=0;j<c2.length;j++) {
			    createFeature(r, c2[j]);
			}
		    }
		} else if(type=="Polygon") {
		    for(let i=0;i<shapes.length;i++) {
			createFeature(r, shapes[i]);
		    }
		} else {
		    console.log("Unknown geometry:" + type);
		}
	    });

	},	    
	toggleTrack:function(record,item) {
	    let marker = this.markers?this.markers[record.getId()]:null;
	    if(this.tracks[record.getId()]) {
		if(item)item.removeClass("display-map-toc-item-on");
		this.map.removePolygon(this.tracks[record.getId()]);
		this.tracks[record.getId()] = null;
		if(item) {
		    item.attr(TITLE,"Click to view; Double-click to view track");
		}
	    } else {
		if(item) {
		    item.addClass("display-map-toc-item-on");
		    item.attr(TITLE,"Click to view; Double-click to remove track");
		}
		let url = record.getValue(this.trackUrlField.getIndex());
		if(url!="")
		    $.getJSON(url, data=>{this.loadTrack(record, data)}).fail(err=>{console.log("url failed:" + url +"\n" + err)});
	    }
	    this.map.setCenter(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude()));
	},
	makeToc:function(records) {
	    let labelField = this.getFieldById(null,this.getProperty("labelField","name"));
	    if(!labelField) labelField = this.getFieldByType(null,"string");
	    if(labelField) {
		let html = "";
		let iconField = this.getFieldById(null,"icon");
		records.forEach((record,idx)=>{
		    let title = "View record";
		    if(this.trackUrlField) title = "Click to view; Double-click to view track";
		    let clazz = "ramadda-clickable  display-map-toc-item ramadda-noselect";
		    let value = labelField.getValue(record);
		    if(!iconField) {
			clazz+=" ramadda-nav-list-link ";
		    } else {
			value = HU.getIconImage(iconField.getValue(record,icon_blank16),["width",16]) + SPACE + value;
		    }
		    html+= HU.span([TITLE, title, CLASS,clazz,RECORD_ID,record.getId(),RECORD_INDEX,idx], value);
		});

		html = HU.div([CLASS, "display-map-toc",STYLE,HU.css("max-height","calc(" +this.getHeightForStyle()+" - 1em)"),ID, this.domId("toc")],html);
		let title = this.getProperty("tableOfContentsTitle","");
		if(title) html = HU.center(HU.b(title)) + html;
		this.jq(ID_LEFT).html(html);
		let _this = this;
		let items = this.jq(ID_LEFT).find(".display-map-toc-item");
		this.makeTooltips(items,records);
		items.click(function() {
		    let idx = $(this).attr(RECORD_INDEX);
		    let record = records[idx];
		    if(!record) return;
		    _this.highlightPoint(record.getLatitude(), record.getLongitude(),true, false);
		    _this.map.setCenter(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude()));
		    if(record.trackData) {
			setTimeout(()=>{
			    _this.getDisplayManager().notifyEvent("handleEventDataSelection", _this, {data:record.trackData});
			},100);
		    }
		});

		items.dblclick(function() {
		    _this.removeHighlight();
		    let idx = $(this).attr(RECORD_INDEX);
		    let record = records[idx];
		    if(!record) return;
		    if(_this.trackUrlField) {
			let url = record.getValue(_this.trackUrlField.getIndex());
			if(url && url.length>0) {
			    _this.toggleTrack(record,$(this));
			    return;
			}
		    } 
		    _this.map.setCenter(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude()));
		});
	    }
	},	    

        updateUI: function(args) {
	    if(!args) args={};
	    let debug = false;
	    this.lastUpdateTime = null;
            SUPER.updateUI.call(this,args);
            if (this.haveCalledUpdateUI || !this.getDisplayReady() ||!this.hasData() || !this.getProperty("showData", true)) {
		if(debug) console.log("map.updateUI have called:" + this.haveCalledUI +" ready:" + this.getDisplayReady() +" has data:" + this.hasData() +" showData:" +this.getProperty("showData", true));
                return;
            }
            let pointData = this.getPointData();

	    //Set the shapes Fields here before filter data so we can accept non georeferenced data
	    this.shapesField = this.getFieldById(null,this.getProperty("shapesField"));
	    this.shapesTypeField = this.getFieldById(null,this.getProperty("shapesTypeField"));

	    this.trackUrlField  =  this.getFieldById(null,this.getProperty("trackUrlField"));

            let records = this.records =  this.filterData();
	    if(this.shapesTypeField && this.shapesField) {
		this.setProperty("tooltipNotFields",this.shapesTypeField.getId()+"," + this.shapesField);
		this.loadShapes(records);
	    }

	    if(debug) console.log("displaymap.updateUI reload=" +args.reload);
            if (records == null) {
		if(debug) console.log("\tno data");
                return;
            }

	    if(this.getShowTableOfContents(false)) {
		this.makeToc(records);
	    }
 
	    if(!this.updatingFromClip) {
		//stop the flash
		if(args.source!="animation")
		    this.setMessage(args.dataFilterChanged|| args.fieldChanged|| args.reload?"Reloading map...":"Creating map...");
	    }
	    this.updatingFromClip = false;

	    setTimeout(()=>{
		try {
		    this.updateUIInner(args, pointData, records,debug);
		    if(args.callback)args.callback();
		} catch(exc) {
		    console.log(exc)
		    console.log(exc.stack);
		    this.setMessage("Error:" + exc);
		    return;
		}
		this.clearProgress();
	    });

	},
	updateUIInner: function(args, pointData, records, debug) {
	    let _this = this;
	    var t1= new Date();
	    debug = debug || displayDebug.displayMapUpdateUI;
	    if(debug) console.log("displaymap.updateUIInner:" + records.length);
	    this.haveCalledUpdateUI = true;



	    if(this.getProperty("showRegionSelector")) {
		//Fetch the regions
		if(!ramaddaMapRegions) {
		    var jqxhr = $.getJSON(ramaddaBaseUrl +"/regions.json", data=> {
			if (GuiUtils.isJsonError(data)) {
			    console.log("Error fetching regions");
			    ramaddaMapRegions=[];
			    return;
			}
			ramaddaMapRegions=data;
		    });
		}		    
		let label = this.getProperty("regionSelectorLabel") || HU.getIconImage("fa-globe-americas");
		let button = HU.div([CLASS,"ramadda-menu-button ramadda-clickable",  TITLE,"Select region", ID,this.domId("selectregion")],label)+SPACE2;
		this.writeHeader(ID_HEADER2_PREPREFIX, button);
		this.jq("selectregion").click(function() {
		    let id = _this.domId(ID_REGION_SELECTOR);
		    let groups = {};
		    ramaddaMapRegions.forEach((r,idx)=>{
			//skip world as its a dup
			if(r.name == "World") return
			let group = r.group;
			if(group.toLowerCase()=="model regions") group="Regions";
			let name = r.name.replace(/ /g,"&nbsp;");
			let item = HU.div([CLASS,"ramadda-menu-item", "idx",idx],name);
			if(!groups[group]) groups[group] = "";
			groups[group] +=item;});
		    let html = "<table width=100%><tr valign=top>";
		    Object.keys(groups).forEach(group=>{
			html+= HU.td([STYLE,HU.css()], HU.div([STYLE,HU.css("font-weight","bold","border-bottom","1px solid #ccc","margin-right","5px")], Utils.camelCase(group))+HU.div([STYLE,HU.css("max-height","200px","overflow-y","auto", "margin-right","10px")], groups[group]));
		    });
		    html+="</tr></table>"
		    //set the global 
		    let popup = HtmlUtils.setPopupObject(HtmlUtils.getTooltip());
		    html = HU.div([ID,id],html);
		    popup.html(HU.div([CLASS, "ramadda-popup-inner"], html));
		    popup.show();
		    popup.position({
			of: $(this),
			my: "left top",
			at: "left bottom",
		    });
		    _this.jq(ID_REGION_SELECTOR).find(".ramadda-menu-item").click(function() {
			let region = ramaddaMapRegions[+$(this).attr("idx")];
			HtmlUtils.hidePopupObject();
			_this.map.setViewToBounds(new RamaddaBounds(region.north, region.west, region.south, region.east));
		    });
		});
	    }

            let pointBounds = {};
            let points = RecordUtil.getPoints(records, pointBounds);

	    if(this.clipBounds) {
		this.clipBounds = false;
		let clipRecords = false;
		if(this.lastPointBounds && this.lastPointBounds!=pointBounds) {
		    clipRecords = true;
		}
		this.lastPointBounds = pointBounds;
		if(clipRecords) {
		    let viewbounds = this.map.getMap().calculateBounds().transform(this.map.sourceProjection, this.map.displayProjection);
		    let tmpRecords =records.filter(r=>{
			return viewbounds.containsLonLat(new OpenLayers.LonLat(r.getLongitude(),r.getLatitude()));
		    });
		    //		console.log("clipped records:" + tmpRecords.length);
		    this.records = records = tmpRecords;
		    pointBounds = {};
		    points = RecordUtil.getPoints(records, pointBounds);
		}
	    }




            let fields = pointData.getRecordFields();
            let showSegments = this.getProperty("showSegments", false);
	    if(records.length!=0) {
		if (!isNaN(pointBounds.north)) {
		    this.initBounds = pointBounds;
		    if(!showSegments && !this.hadInitialPosition && !args.dontSetBounds) {
			if(!args.dataFilterChanged || this.getCenterOnFilterChange(true)) {
			    this.setInitMapBounds(pointBounds.north, pointBounds.west, pointBounds.south,
						  pointBounds.east);
			}
		    }
		}
	    }
	    if (this.map == null) {
		return;
	    }
	    if(this.highlightMarker) {
		this.map.removePoint(this.highlightMarker);
		this.map.removeMarker(this.highlightMarker);
		this.highlightMarker = null;
	    }
	    this.map.clearSeenMarkers();
	    var t2= new Date();
//	    debug = true;
	    if(debug) console.log("displaymap calling addPoints");
            this.addPoints(records,fields,points,pointBounds,debug);
	    var t3= new Date();
            this.addLabels(records,fields,points);
            this.applyVectorMap(true, this.textGetter,args);
	    var t4= new Date();
	    if(debug) Utils.displayTimes("time pts=" + points.length,[t2,t3], true);
	    this.lastUpdateTime = new Date();
	},
	heatmapCnt:0,
	animationApply: function(animation, skipUpdateUI) {
//	    console.log("map.applyAnimation:" +this.heatmapVisible);
 	    if(!this.heatmapLayers || !this.heatmapVisible) {
//		console.log("map.applyAnimation-1");
		SUPER.animationApply.call(this, animation, skipUpdateUI);
		return;
	    }
	    let onDate=null;
	    //	    console.log("displaymap.animationApply:" + animation.begin + " " +animation.end);
	    let onLayer = null;
	    let offLayers = [];
	    this.heatmapLayers.every(layer=>{
		if(!layer.date) return true;
		if(layer.date.getTime()>= animation.begin.getTime() && layer.date.getTime()<= animation.end.getTime()) {
		    onDate = layer.date;
		    onLayer = layer;
		    layer.setVisibility(true);
		} else {
		    if(layer.getVisibility()) 
			offLayers.push(layer);
		}
		return true;
	    })
	    offLayers.forEach(layer=>{
		layer.setVisibility(false);
	    });
	    console.log("map.applyAnimation-2:" + onDate);
 	    if(!onDate) {
		SUPER.animationApply.call(this, animation, skipUpdateUI);
	    }
	    if(onLayer!=null)
		this.setMapLabel(onLayer.heatmapLabel);
	},
        setDateRange: function(min, max) {
	    //Not sure why we do this
	    if(this.getProperty("doGridPoints",false)|| this.getProperty("doHeatmap",false)) {
		SUPER.setDateRange.call(this, min,max);
	    } else {
		SUPER.setDateRange.call(this, min,max);
	    }
	},
	showColorTable: function(colorBy) {
	    colorBy.displayColorTable(null,true);
	    this.callingUpdateSize = true;
	    this.map.getMap().updateSize();
	    this.callingUpdateSize = false;
	},

	applyHeatmapAnimation: function(index) {
	    this.jq(ID_HEATMAP_ANIM_LIST)[0].selectedIndex = index;
	    let offLayers = [];
	    this.heatmapLayers.forEach((layer,idx)=>{
		if(index==idx)
		    layer.setVisibility(true);
		else
		    offLayers.push(layer);
	    });
	    offLayers.forEach(layer=>{
		layer.setVisibility(false);
	    });
	    this.setMapLabel(this.heatmapLayers[index].heatmapLabel);

	},
	stepHeatmapAnimation: function(){
	    let index = this.jq(ID_HEATMAP_ANIM_LIST)[0].selectedIndex;
	    index++;
	    if(index>=this.heatmapLayers.length) {
		index =0;
	    }
	    this.applyHeatmapAnimation(index);
	    if(this.heatmapPlayingAnimation) {
		setTimeout(()=>{
		    this.stepHeatmapAnimation();
		},this.getHmAnimationSleep(1000));
	    }
	},
	checkHeatmapReload:function() {
//	    return
	    if(!this.getHmReloadOnZoom(this.getReloadOnZoom(false))) return;
	    let now = new Date ();
	    //Don't do this the first couple of seconds after we've been created
	    if(now.getTime()-this.createTime.getTime()<3000) return;
	    let diff = 0;
	    if(this.checkHeatmapReloadTime) {
		diff = now.getTime()-this.checkHeatmapReloadTime.getTime();
	    }
	    this.checkHeatmapReloadTime = now;
	    if(diff<1000) {
		if(!this.checkHeatmapReloadPending) {
		    this.checkHeatmapReloadPending = true;
		    setTimeout(()=>{
			this.checkHeatmapReloadPending = false;
			this.checkHeatmapReload();
		    },1100)
		}
		return;
	    }
	    this.checkHeatmapReloadTime = null;
	    this.reloadHeatmap = true;
	    this.haveCalledUpdateUI = false;
	    this.updateUI();
	},
	createHeatmap(records, fields, bounds) {
	    let debug = displayDebug.displayMapCreateMap;
	    if(debug) console.log("createHeatmap");
	    let colorBy = this.getColorByInfo(records, null,null,null,["hmColorBy","colorBy",""]);
	    let angleBy = this.getColorByInfo(records, "angleBy",null,null,["hmAngleBy","angleBy",""]);
	    let lengthBy = this.getColorByInfo(records, "lengthBy",null,null,["hmLengthBy","lengthBy",""]);
	    if(!angleBy.isEnabled()) angleBy = colorBy;
	    if(!lengthBy.isEnabled()) lengthBy=null;
	    records = records || this.filterData();
	    if(this.getHmBounds()) {
		let toks = this.getHmBounds().split(",");
		bounds = new RamaddaBounds(+toks[0],+toks[1], +toks[2],+toks[3]);
	    }
	    let mapBounds = this.map.getBounds();
	    bounds = bounds ||  RecordUtil.getBounds(records);
	    bounds = RecordUtil.convertBounds(mapBounds);

 	    if(this.heatmapLayers) {
		try {
		    this.heatmapLayers.every(layer=>{
			this.map.removeLayer(layer);
			return true;
		    });
		} catch(exc) {
		    console.log(exc);
		}
	    }
	    this.heatmapLayers = [];
	    if(records.length==0) {
		this.errorMessage = this.getNoDataMessage();
		this.setMessage(this.errorMessage);
		return
	    }
	    if(this.reloadHeatmap) {
		this.reloadHeatmap = false;
		bounds = new RamaddaBounds(this.map.getBounds());
		records = RecordUtil.subset(records, bounds);
//		bounds =  RecordUtil.getBounds(records);
	    }
	    bounds = RecordUtil.expandBounds(bounds,this.getProperty("boundsScale",0.05));

	    let dfltArgs = this.getDefaultGridByArgs();
	    let ratio = (bounds.east-bounds.west)/(bounds.north-bounds.south);
	    let w = Math.round(this.getProperty("gridWidth",800));
	    let h = Math.round(w/ratio);
	    let groupByField = this.getFieldById(null,this.getHmGroupBy());
	    let groupByDate = this.getHmGroupByDate();
	    if(debug) console.log("\tcalling groupBy");
	    let t1 = new Date();
	    let groups = (groupByField || groupByDate)?RecordUtil.groupBy(records, this, groupByDate, groupByField):null;
	    let t2 = new Date();
	    //	    Utils.displayTimes("make groups",[t1,t2],true);
	    if(debug) console.log("\tdone calling groupBy");
	    if(groups == null || groups.max == 0) {
		doTimes = false;
		groups= {
		    max:records.length,
		    values:["none"],
		    map:{none:records}
		}
	    }
	    //	    if(debug) console.log("\tdone calling groupBy count="+ groups.values.length);
	    let recordCnt = groups.max;
 	    if(dfltArgs.cellSize==0) {
		let sqrt = Math.sqrt(recordCnt);
		let size = Math.round(w/sqrt);
		dfltArgs.cellSizeX = dfltArgs.cellSizeY = dfltArgs.cellSize = size;
	    } else if(String(dfltArgs.cellSize).endsWith("%")) {
		dfltArgs.cellSize =dfltArgs.cellSizeX =  dfltArgs.cellSizeY = Math.floor(parseFloat(dfltArgs.cellSize.substring(0,dfltArgs.cellSize.length-1))/100*w);
	    }
	    let args =$.extend({colorBy:colorBy,angleBy:angleBy,lengthBy:lengthBy,w:w,h:h,bounds:bounds,forMercator:true},
			       dfltArgs);
	    if(debug) {
		console.log("#records:" + records.length+" dim:" + w +" " +h + " #records:" + records.length +" cell:" + dfltArgs.cellSizeX + " #records:" + records.length +" bounds:" + bounds);
	    }
	    let labels = [];
	    let labelPrefix = this.getHmLabelPrefix("${field}-");
	    groups.values.every((value,idx)=>{
		let recordsAtTime = groups.map[value];
		if(debug)
		    console.log("group:" + value +" #:" + groups.map[value].length);
		let img = Gfx.gridData(this.getId(),fields, recordsAtTime,args);
//		$("#testimg").html(HU.image(img,[WIDTH,"100%", STYLE,"border:1px solid blue;"]));
		let label = value=="none"?"Heatmap": labelPrefix +" " +groups.labels[idx];
		label = label.replace("${field}",colorBy.field?colorBy.field.getLabel():"");
		labels.push(label);
//		console.log("B:" + bounds);
		let layer = this.map.addImageLayer("heatmap"+(this.heatmapCnt++), label, "", img, idx==0, bounds.north, bounds.west, bounds.south, bounds.east,w,h, { 
		    isBaseLayer: false,
		});
		this.map.getMap().setLayerIndex(layer, 1000);
		layer.heatmapLabel = label;
		if(groupByDate) {
		    if(value.getTime)
			layer.date = value;
		}
		this.heatmapLayers.push(layer);
		return true;
	    });
	    if(this.getHmShowGroups(true) && this.heatmapLayers.length>1 && !this.getAnimationEnabled()) {
		this.heatmapPlayingAnimation = false;
		let controls =  "";
		if(!groupByField) 
		    controls+=HU.div([ID,this.domId(ID_HEATMAP_ANIM_PLAY),STYLE,HU.css("display","inline-block"),TITLE,"Play/Stop Animation"],
				     HU.getIconImage("fa-play",[CLASS,"display-anim-button"]));
		controls += HU.div([ID,this.domId(ID_HEATMAP_ANIM_STEP),STYLE,HU.css("display","inline-block"),TITLE,"Step"],
 				   HU.getIconImage("fa-step-forward",[CLASS,"display-anim-button"]));
		
		controls += HU.div([STYLE,HU.css("display","inline-block","margin-left","5px","margin-right","5px")], HU.select("",[ID,this.domId(ID_HEATMAP_ANIM_LIST)],labels));
		this.writeHeader(ID_HEADER2_PREPREFIX, controls);
		let _this = this;
		this.jq(ID_HEATMAP_ANIM_LIST).change(function() {
		    let index = $(this)[0].selectedIndex;
		    _this.applyHeatmapAnimation(index);
		});
		this.jq(ID_HEATMAP_ANIM_PLAY).click(function() {
		    _this.heatmapPlayingAnimation = !_this.heatmapPlayingAnimation;
		    let icon = _this.heatmapPlayingAnimation?"fa-stop":"fa-play";
		    $(this).html(HU.getIconImage(icon,[CLASS, "display-anim-button"]));
		    if(_this.heatmapPlayingAnimation) {
			_this.stepHeatmapAnimation();
		    }
		});
		this.jq(ID_HEATMAP_ANIM_STEP).click(function() {
		    _this.heatmapPlayingAnimation = false;
		    let icon = _this.heatmapPlayingAnimation?"fa-stop":"fa-play";
		    _this.jq(ID_HEATMAP_ANIM_PLAY).html(HU.getIconImage(icon,[CLASS,"display-anim-button"]));
		    _this.stepHeatmapAnimation();
		});

	    }
	    if(groups.values[0]!="none") {
		this.setMapLabel(labels[0]);
	    }
	    this.showColorTable(colorBy);
	    if(this.getHmShowToggle() || this.getHmShowReload()) {
		let cbx = this.jq(ID_HEATMAP_TOGGLE);
		let reload =  HU.getIconImage("fa-sync",[CLASS,"display-anim-button",TITLE,"Reload heatmap", ID,this.domId("heatmapreload")])+SPACE2;
		this.heatmapVisible= cbx.length==0 ||cbx.is(':checked');

		this.writeHeader(ID_HEADER2_PREFIX,
				 reload + HU.checkbox("",[ID,this.domId(ID_HEATMAP_TOGGLE)],this.heatmapVisible) +SPACE +
				 this.getHmToggleLabel("Toggle Heatmap") +SPACE2);
		let _this = this;
		this.jq("heatmapreload").click(()=> {
		    this.reloadHeatmap = true;
		    this.haveCalledUpdateUI = false;
		    this.updateUI();
		});
		this.jq(ID_HEATMAP_TOGGLE).change(function() {
		    if(_this.heatmapLayers)  {
			let visible = $(this).is(':checked');
			_this.heatmapVisible  = visible;
			_this.heatmapLayers.forEach(layer=>layer.setVisibility(visible));
			_this.map.setPointsVisibility(!visible);
		    }
		});
	    }
	},

	updateHtmlLayers: function() {
	    if(this.htmlLayerInfo) {
		this.createHtmlLayer(this.htmlLayerInfo.records, this.htmlLayerInfo.fields);
	    }
	},
	updateHtmlLayer:function() {
	    if(!this.htmlLayer) return;
	    if(!this.htmlLayerId) {
		this.htmlLayerId =this.getUniqueId(ID_HTMLLAYER);
		let vp  = this.map.getMap().getViewport();
		vp = $(vp).children()[0];
		$(vp).css("display","relative");
		$(vp).append(HU.div([CLASS,"display-map-htmllayer", ID,this.htmlLayerId]));
	    }
	    $("#"+ this.htmlLayerId).html(this.htmlLayer);
	},
        createHtmlLayer: function(records, fields) {
	    let htmlLayerField = this.getFieldById(fields,this.getHtmlLayerField());
	    this.htmlLayerInfo = {
		records:records,
		fields:fields,
	    };
	    this.htmlLayer = "";
	    let w = this.getHtmlLayerWidth(30);
	    let h = this.getHtmlLayerHeight(15);
	    let shape = this.getHtmlLayerShape("barchart");
	    if(shape=="barchart")
		this.setProperty("colorBy",htmlLayerField.getId());
	    if(this.getHtmlLayerScale()) {
		let zooms = [];		
		this.getHtmlLayerScale().split(",").forEach(t=>{
		    zooms.push(t.split(":"));
		});
		//3:0.5,4:1,5:2
		let zoom = this.map.map.getZoom();
		let scale = 1.0;
		if(zooms.length==1 && zooms[0].length==1) {
		    scale=zooms[0][0];
		} else {
		    zooms.every(t=>{
			scale=t[1];
			if(t[0] >= zoom) {
			    return false;
			}
			return true;
		    });
		}
		w*=scale;h*=scale;
	    }
	    let style = this.getHtmlLayerStyle("");
	    let infos = [];
	    let allData = this.getColumnValues(records, htmlLayerField);
	    let groups = RecordUtil.groupBy(records, this, false,"latlon");
	    let container = $($(this.map.getMap().getViewport()).children()[0]);
	    let cleft = +container.css("left").replace("px","");
	    let ctop = +container.css("top").replace("px","");
	    let hoverW = w*3;
	    let hoverH = h*3;
	    let layerRecords = [];

	    groups.values.forEach((value,idx)=>{
		let recordsAtTime = groups.map[value];
		let data = [];
		layerRecords.push(recordsAtTime[0]);
		recordsAtTime.forEach((r,idx)=>{
		    data.push(r.getValue(htmlLayerField.getIndex()));
		});
		let record = recordsAtTime[0];
		let px = this.map.getMap().getPixelFromLonLat(this.map.transformLLPoint(new OpenLayers.LonLat(record.getLongitude(),record.getLatitude())));
		let id = this.getId() +"_sl"+ idx;
		let hid = id +"_hover";
		let html = 
		    HU.div([ID,id,  CLASS,'display-map-html-item',STYLE,style +HU.css('line-height','0px','z-index','1000','position','absolute','left', (px.x-w/2-cleft) +'px','top', (px.y-h/2-ctop)+'px')]) +
		    HU.div([ID,hid, RECORD_INDEX, idx,TITLE,"", CLASS,'display-map-html-hitem', STYLE,style +HU.css('display','none','line-heigh','0px','z-index','1001','position','absolute','left', (px.x-hoverW/2-cleft) +'px','top', (px.y-hoverH/2-ctop)+'px')]);
		this.htmlLayer += html;
		infos.push({
		    id:id,
		    hoverId: hid,
		    data:data,
		    records: recordsAtTime
		});
	    });
	    this.updateHtmlLayer();
            let colorBy = this.getColorByInfo(records);
	    infos.forEach((info,idx)=>{
		if(shape == "pie" || shape == "piechart") {
		    [0,1].forEach((cid,idx)=>{
			let id = HU.getUniqueId("pie");
			let cw = idx==0?w:hoverW;
			let ch = idx==0?h:hoverH;
			let pie = HU.tag('canvas',[STYLE,HU.css('cursor','pointer'),ID,id ,WIDTH,cw,HEIGHT, ch]);
			if(idx==0)
			    $("#" + info.id).html(pie);
			else
			    $("#" + info.hoverId).html(pie);
			let canvas = document.getElementById(id);
			let color = colorBy&& colorBy.isEnabled()?colorBy.getColor(info.data[0]):this.getFillColor("#619FCA");
			var ctx = canvas.getContext("2d");
			if(idx==1) {
			    ctx.fillStyle= '#fff';
			    ctx.beginPath();
			    ctx.moveTo(cw/2,ch/2);
			    ctx.arc(cw/2,ch/2, cw/2-2, 0-Math.PI/2, 2*Math.PI);
			    ctx.closePath();
			    ctx.fill();
			}
			ctx.beginPath();
			ctx.moveTo(cw/2,ch/2);
			ctx.arc(cw/2,ch/2, cw/2-2, 0-Math.PI/2, info.data[0]*2 * Math.PI-Math.PI/2);
			ctx.lineTo(cw/2,ch/2);
			ctx.closePath();
			ctx.strokeStyle= this.getStrokeColor("#888");
			ctx.fillStyle= color;
			ctx.fill();
			ctx.stroke();
			ctx.beginPath();
			ctx.arc(cw/2,ch/2, cw/2-2, 0, 2 * Math.PI);
			ctx.closePath();
			ctx.stroke();
		    });
		} else {
		    drawSparkLine(this,"#"+ info.id,w,h,info.data,info.records,allData.min,allData.max,colorBy);
		    $('#' + info.hoverId).css('background','#fff').css('border','1px solid #ccc');
		    drawSparkLine(this,"#"+ info.hoverId,hoverW,hoverH,info.data,info.records,allData.min,allData.max,colorBy);		    
		}
	    });
	    let items = this.find(".display-map-html-item");
	    let hitems = this.find(".display-map-html-hitem");
	    this.makeTooltips(hitems, layerRecords);

	    items.mouseenter(function() {
		$(this).css('display','none');
		$("#"+$(this).attr(ID)+"_hover").fadeIn(1000);
		
	    });
	    hitems.mouseleave(function() {
		$("#"+ $(this).attr(ID).replace('_hover','')).css('display','block');
		$(this).css('display','none');
	    });
	    if(colorBy.hasField()) {
		this.showColorTable(colorBy);
	    }
	},
        addPoints: function(records, fields, points,bounds,debug) {
	    if(this.getDoGridPoints()|| this.getDoHeatmap(false)) {
		if(this.getHmShowPoints() || this.getShowPoints()) {
		    this.createPoints(records, fields, points, bounds,debug);
		    if(this.getHmShowToggle(false) && this.map.circles) {
			this.map.setPointsVisibility(false);
		    }
		}
		this.createHeatmap(records, fields, bounds);
		return;
	    }
	    if(this.getHtmlLayerField()) {
		this.createHtmlLayer(records, fields);
		return;
	    }
	    this.createPoints(records, fields, points, bounds,debug);
	},
	styleCollisionDot:function(dot) {
	    let collisionFixed = this.getCollisionFixed();
	    let dotColor = this.getProperty("collisionDotColor","#0");
	    let dotRadius = this.getProperty("collisionDotRadius",5);
	    if(!collisionFixed) {
		if(dot.collisionInfo.visible)  {
		    dotRadius = 5;
		    dotColor = "#000";
		    dotColor = this.getProperty("collisionDotColorOn","#000");
		} else {
		    if(this.getPropertyCollisionScaleDots()) {
			dotRadius = Math.min(dot.collisionInfo.numRecords*3,24);
		    } else {
//			dotRadius =5;
		    }
		    dotColor = this.getProperty("collisionDotColorOff","#CD5C5C");
		}
	    }
	    dot.style.fillColor=dotColor;
	    dot.style.pointRadius=dotRadius;
	},
        createPoints: function(records, fields, points,bounds, debug) {
	    let t1  =new Date();
	    debug = debug ||displayDebug.displayMapAddPoints;
	    let features = [];
            let colorBy = this.getColorByInfo(records);
	    let cidx=0
	    let polygonField = this.getFieldById(fields, this.getProperty("polygonField"));
	    let polygonColorTable = this.getColorTable(true, "polygonColorTable",null);
	    let latlon = this.getProperty("latlon",true);
            let source = this;
            let radius = +this.getPropertyRadius(8);
	    let highlightRecords = this.getFilterHighlight();
	    let unhighlightFillColor = this.getUnhighlightColor();
	    let unhighlightStrokeWidth = this.getProperty("unhighlightStrokeWidth",0);
	    let unhighlightStrokeColor = this.getProperty("unhighlightStrokeColor","#aaa");
	    let unhighlightRadius = this.getProperty("unhighlightRadius",-1);
	    this.markers = {};


	    if(this.getPropertyScaleRadius()) {
		let seen ={};
		let numLocs = 0;
		points.every(p=>{
		    if(!seen[p]) {
			numLocs++;
			seen[p] = true;
		    }
		    return true;
		});
		let radiusScale = this.getPropertyRadiusScale();
		if(radiusScale) {
		    radiusScale = radiusScale.split(",").map(t=>{return +t;});
		} else  {
		    radiusScale =[15000,2,10000,2,6000,3,4500,4,3500,5,2600,6,1300,7,800,8,300,9,275,10,250,11,225,12,175,13,125,14,100,15,50,16];
		}
		let maxRadius = radiusScale[radiusScale.length-1];
		let delta  = radius-maxRadius;
//		console.log("max:" + maxRadius +" delta:" + delta);
		radius=radiusScale[1];
		for(let i=0;i<radiusScale.length;i+=2) {
		    if(numLocs<+radiusScale[i]) {
			radius = +radiusScale[i+1];
		    }
		}
		radius+=delta;
		if(radius<=0) radius = 2;
		console.log("#records:" + numLocs +" " +records.length + " radius:" + radius);
	    }




            let strokeWidth = +this.getPropertyStrokeWidth();
            let strokeColor = this.getPropertyStrokeColor();
            let sizeByAttr = this.getDisplayProp(source, "sizeBy", null);
            let isTrajectory = this.getDisplayProp(source, "isTrajectory", false);
            if (isTrajectory) {
                let attrs = {
                    strokeWidth: 2,
                    strokeColor: "blue"
                }
		if(points.length==1) {
		    this.map.addPoint(ID,  points[0], attrs, null);
		} else {
                    this.map.addPolygon(ID, "", points, attrs, null);
		}
                return;
            }

            let latField1 = this.getFieldById(fields, this.getProperty("latField1"));
            let latField2 = this.getFieldById(fields, this.getProperty("latField2"));
            let lonField1 = this.getFieldById(fields, this.getProperty("lonField1"));
            let lonField2 = this.getFieldById(fields, this.getProperty("lonField2"));
            let sizeSegments = this.getProperty("sizeSegments", false);
            let sizeEndPoints = this.getProperty("sizeEndPoints", true);
            let showEndPoints = this.getProperty("showEndPoints", false);
            let endPointSize = parseInt(this.getProperty("endPointSize", "4"));
            let dfltEndPointSize = endPointSize;
            let segmentWidth = parseInt(this.getProperty("segmentWidth", "1"));
            let dfltSegmentWidth = segmentWidth;
            let showPoints = this.getProperty("showPoints", true);
            let lineColor = this.getProperty("lineColor", "green");
	    let lineCap = this.getProperty('lineCap', 'round');

            let iconField = this.getFieldById(fields, this.getProperty("iconField"));
            let rotateField = this.getFieldById(fields, this.getProperty("rotateField"));	    
	    let markerIcon = this.getProperty("markerIcon",this.getProperty("pointIcon"));
	    if(markerIcon && markerIcon.startsWith("/")) {
                markerIcon =  ramaddaBaseUrl + markerIcon;
	    }
	    let usingIcon = markerIcon || iconField;
            let iconSize = parseFloat(this.getProperty("iconSize",32));
	    let iconMap = this.getIconMap();


	    let dfltShape = this.getProperty("defaultShape",null);
	    let dfltShapes = ["circle","triangle","star",  "square", "cross","x", "lightning","rectangle","church"];
	    let dfltShapeIdx=0;
	    let shapeBy = {
		id: this.getDisplayProp(source, "shapeBy", null),
		field:null,
		map: {}
	    }


	    if(this.getDisplayProp(source, "shapeByMap", null)) {
		this.getDisplayProp(source, "shapeByMap", null).split(",").forEach((pair)=>{
		    let tuple = pair.split(":");
		    shapeBy.map[tuple[0]] = tuple[1];
		})
	    }


	    let sizeBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records);
            for (let i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (field.getId() == shapeBy.id || ("#" + (i + 1)) == shapeBy.id) {
                    shapeBy.field = field;
		    if (field.isString()) shapeBy.isString = true;
                }
            }
            shapeBy.index = shapeBy.field != null ? shapeBy.field.getIndex() : -1;


            if (this.getProperty("showColorByMenu", false) && colorBy.field && !this.madeColorByMenu) {
                this.madeColorByMenu = true;
                let menu = HU.open(SELECT,[CLASS,'ramadda-pulldown',ID,this.domId("colorByMenu")]);
                for (let i = 0; i < fields.length; i++) {
                    let field = fields[i];
                    if (!field.isNumeric() || field.isFieldGeo()) continue;
                    let extra = "";
                    if (colorBy.field.getId() == field.getId()) extra = "selected ";
                    menu += "<option value='" + field.getId() + "' " + extra + ">" + field.getLabel() + "</option>\n";
                }
                menu += HU,close(SELECT);
                this.writeHtml(ID_TOP_RIGHT, "Color by: " + menu);
                this.jq("colorByMenu").change(() => {
                    let value = this.jq("colorByMenu").val();
                    this.vectorMapApplied = false;
		    this.haveCalledUpdateUI = false;
                    this.setProperty("colorBy", value);
                    this.updateUI();
                });
            }



	    let dateMin = null;
	    let dateMax = null;

	    let dates = [];
            let justOneMarker = this.getPropertyJustOneMarker();


            for (let i = 0; i < records.length; i++) {
                let pointRecord = records[i];
		dates.push(pointRecord.getDate());
                if (dateMin == null) {
                    dateMin = pointRecord.getDate();
                    dateMax = pointRecord.getDate();
                } else {
                    let date = pointRecord.getDate();
                    if (date) {
                        if (date.getTime() < dateMin.getTime())
                            dateMin = date;
                        if (date.getTime() > dateMax.getTime())
                            dateMax = date;
                    }
                }
	    }


            if (dateMax) {
		if (this.getAnimationEnabled()) {
		    //TODO: figure out when to call this. We want to update the animation if it was from a filter change
		    //but not from an animation change. Hummmm.
		    //this.getAnimation().init(dateMin, dateMax,records);
		}
            }



            if (this.points) {
		this.points.forEach(point=>{
		    if(point.isMarker)
			this.map.removeMarker(point);
		    else
			this.map.removePoint(point);
		});
                this.points = [];
            }



            if (this.lines) {
                for (let i = 0; i < this.lines.length; i++)
                    this.map.removePolygon(this.lines[i]);
                this.lines = [];
            }


            if (!this.points) {
                this.points = [];
                this.lines = [];
            }


            let dontAddPoint = this.doDisplayMap();
            let didColorBy = false;
            let seen = {};
	    let xnct =0;
	    let lastPoint;
	    let pathAttrs ={
		strokeColor: this.getProperty("pathColor",lineColor),
		strokeWidth: this.getProperty("pathWidth",1)
	    };


	    let fillColor = this.getPropertyFillColor();
	    let fillOpacity =  this.getPropertyFillOpacity();
	    let isPath = this.getProperty("isPath", false);
	    let groupByField = this.getFieldById(null,this.getProperty("groupByField"));
	    let groups;
	    if(groupByField)
		groups =  RecordUtil.groupBy(records, this, false, groupByField);
	    

	    let showSegments = this.getProperty("showSegments", false);
	    let tooltip = this.getProperty("tooltip");
	    let highlight = this.getProperty("highlight");
	    let highlightTemplate = this.getProperty("highlightTemplate");
	    if(highlightTemplate)
		highlight=true;
	    
	    let highlightWidth = this.getProperty("highlightWidth",200);
	    let highlightHeight = this.getProperty("highlightHeight",-1);
	    let highlightSize = null;
	    if(highlightHeight>0) {
	    	highlightSize = new OpenLayers.Size(highlightWidth,highlightHeight);
	    }


	    let addedPoints = [];
	    let textGetter = this.textGetter = f=>{
		if(f.record) {
                    return  this.getRecordHtml(f.record, fields, tooltip);
		}
		return null;
	    };
	    let highlightGetter = f=>{
		if(f.record) {
                    return   HU.div([STYLE,HU.css('background','#fff')],this.getRecordHtml(f.record, fields, highlightTemplate|| tooltip));
		}
		return null;
	    };	    
	    this.haveAddPoints = true;
	    let displayInfo = this.displayInfo = {};
	    records.forEach(record=>{
		let recordLayout = displayInfo[record.getId()] = {
		    features:[],
		    visible:true
		}
		if(!record.point) {
		    recordLayout.x = record.getLongitude();
		    recordLayout.y = record.getLatitude();
		} else {
		    recordLayout.x = record.point.x;
		    recordLayout.y = record.point.y;
		}
	    });


	    if(this.getPropertyHandleCollisions()) {
		//TODO: labels
		let doLabels = this.getProperty("collisionLabels",false);
		if(doLabels &!this.map.collisionLabelsLayer) {
		    this.map.collisionLabelsLayer = new OpenLayers.Layer.Vector("Collision Labels", {
			styleMap: new OpenLayers.StyleMap({'default':{
                            label : "${label}"
			}}),
                    });
		    this.map.addVectorLayer(this.map.collisionLabelsLayer, true);
                    this.map.collisionLabelsLayer.setZIndex(100);
		}


		let mapBounds = this.map.getBounds();
		let mapW = mapBounds.right-mapBounds.left;
		let divW  = $("#" + this.getProperty(PROP_DIVID)).width();
		let pixelsPer = divW/mapW;
		let scaleFactor = 360/pixelsPer;
		let baseOffset = mapW*0.025;
		let offset = 0;
		let cnt = 0;
		let minPixels = this.getProperty("collisionMinPixels",16);
		//figure out the offset but use cnt so we don't go crazy
		while(pixelsPer*offset<minPixels && cnt<100) {
		    offset+=baseOffset;
		    cnt++;
		}
		let lineWidth = this.getProperty("collisionLineWidth","2");				
		let lineColor = this.getProperty("collisionLineColor","#000");
		//		console.log("checking collisions:" + mapBounds +" offset:" + offset);
		let seen1={};
//		let decimals =  parseFloat(this.getProperty("collisionRound",1));
		let decimals = -1;
		let pixels = [6,12,24,48,96,192];
		for(let i=0;i<pixels.length;i++) {
		    if(pixelsPer<pixels[i]) break;
		    decimals++;
		}
//		console.log(pixelsPer  +" decimals:" + decimals);
		let rnd = (v)=>{
		    if(decimals>0)
			return Math.floor(v * decimals + 0.5) / decimals;
		    v= Math.round(v);
		    if(decimals<0)
			if (v%2 != 0)
			    v--;
		    return v;
		};
		let getPoint = (p=>{
		    let lat = rnd(p.y);
		    let lon = rnd(p.x);
		    return new OpenLayers.Geometry.Point(lon,lat);
		});
		let recordInfo = {};
		records.forEach(record=>{
		    let recordLayout = displayInfo[record.getId()];
		    recordLayout.rpoint = getPoint(recordLayout);
		    if(seen1[recordLayout.rpoint]) {
			seen1[recordLayout.rpoint]++;
		    } else {
			seen1[recordLayout.rpoint]=1;
		    }
		});
		let collisionState= this.collisionState = {};
		let collisionVisible = this.getPropertyCollisionFixed();


		records.forEach((record,idx)=>{
		    let recordLayout = displayInfo[record.getId()];
		    let point = recordLayout;
		    let rpoint = recordLayout.rpoint;
		    if(rpoint ==null) return;
		    if(seen1[rpoint]==1) {
			return;
		    } 
		    let cntAtPoint = seen1[rpoint];
		    let anglePer = 360/cntAtPoint;
//		    if(cntAtPoint==2)
//			anglePer = 135;
		    let info = collisionState[rpoint];
		    if(!info) {
			info = collisionState[rpoint]={
			    dot:null,
			    numRecords:seen1[rpoint],
			    records:[],
			    features:[],
			    visible: collisionVisible
			};
		    }
		    recordLayout.visible = info.visible;
		    info.records.push(record);
		    let cnt = info.records.length;
		    let ep = Utils.rotate(rpoint.x,rpoint.y,rpoint.x,rpoint.y-offset,cnt*anglePer-180,true);
		    let line = this.map.addLine("line-" + idx, "", rpoint.y,rpoint.x, ep.y,ep.x, {strokeColor:lineColor,strokeWidth:lineWidth});
		    if(!info.visible) {
			line.featureVisible = false;
			this.map.checkFeatureVisible(line,true);
		    }
		    if(!info.dot)  {
			info.dot = this.map.addPoint("dot-" + idx, rpoint, {});
			info.dot.collisionInfo  = info;
			this.styleCollisionDot(info.dot);
                        this.points.push(info.dot);
		    }
		    info.features.push(line);
		    this.lines.push(line);
		    point.x=ep.x;
		    point.y=ep.y;
		});
	    }

	    let t2  =new Date();
//	    Utils.displayTimes("map points 1:",[t1,t2], true);

	    let t3,t4,t5,t6;
	    let i=0;
	    let sizeByFunc = function(percent, size) {
                if (sizeEndPoints &&!isNaN(percent)) {
		    endPointSize = dfltEndPointSize + parseInt(10 * percent);
                }
                if (sizeSegments) {
		    if(isNaN(percent)) {
			segmentWidth = dfltSegmentWidth + size;
		    } else {
			segmentWidth = dfltSegmentWidth + parseInt(10 * percent);
			segmentWidth=size;
			if(segmentWidth==0 || isNaN(segmentWidth)) segmentWidth=1;
		    }
                }
	    };


	    if(isPath && groups) {
		let i=0;
		groups.values.forEach(value=>{
		    let firstRecord = null;
		    let lastRecord = null;
		    let secondRecord = null;		    
		    groups.map[value].forEach(record=>{
			if(!firstRecord) firstRecord=record;
			i++;
			if(lastRecord) {
			    pathAttrs.strokeColor = colorBy.getColorFromRecord(record, pathAttrs.strokeColor);
			    let line = this.map.addLine("line-" + i, "", lastRecord.getLatitude(), lastRecord.getLongitude(), record.getLatitude(),record.getLongitude(),pathAttrs);
			    this.lines.push(line);
			    line.record=record;
			    line.textGetter=textGetter;
			}
			secondRecord = lastRecord;
			lastRecord = record;
			if(secondRecord) {
/*
			    var angleDeg = Utils.getBearing({x:lastRecord.getLongitude(),
							   
							   y:lastRecord.getLatitude()},
							  {x:secondRecord.getLongitude(),
							   y:secondRecord.getLatitude()});							  
//			    let endPoint = this.map.addPoint("endpoint", {x:lastRecord.getLongitude(),y:lastRecord.getLatitude()}, {fillColor:"red",strokeColor:"#000",pointRadius:6,graphicName:"arrow",rotation:angleDeg}, null);
//                            this.points.push(endPoint);
*/
			}

		    });
		    if(lastRecord) {
			let color=  colorBy.getColorFromRecord(lastRecord, pathAttrs.strokeColor);
			if(secondRecord && this.getProperty("showPathEndPoint",false)) {
			    let shape = this.getProperty("pathEndPointShape",null);
			    var angleDeg = Utils.getBearing({lon:secondRecord.getLongitude(),
							     lat:secondRecord.getLatitude()},
							    {lon:lastRecord.getLongitude(),
							     lat:lastRecord.getLatitude()});							  
			    let endPoint = this.map.addPoint("endpoint", {x:lastRecord.getLongitude(),y:lastRecord.getLatitude()}, {fillColor:color,strokeColor:"#000",pointRadius:6,graphicName:shape,rotation:angleDeg}, null);
                            this.points.push(endPoint);
			}
			if(this.getProperty("showPathStartPoint",false)) {
			    let endPoint = this.map.addPoint("startpoint", {x:firstRecord.getLongitude(),y:firstRecord.getLatitude()}, {fillColor:color,pointRadius:2}, null);
                            this.points.push(endPoint);
			}			
		    }
		});

	    }


	    let colorByEnabled = colorBy.isEnabled();
	    let graphicName = this.getPropertyShape();
	    let didMarker = false;
	    records.forEach(record=>{
		i++;
		let recordLayout = displayInfo[record.getId()];
		if(!recordLayout) return;
		let point  = recordLayout;
		if(!point) {
                    point = new OpenLayers.Geometry.Point(record.getLongitude(), record.getLatitude());
		} else {
		    if(!Utils.isDefined(point.x) || !Utils.isDefined(point.y)) return;
		}


		if(justOneMarker) {
		    debug = false;
		    if(didMarker) {
			if(debug)
			    console.log("didMarker");
			return;
		    }
                    this.map.removeMarker(this.justOneMarker);
                    if(!isNaN(point.x) && !isNaN(point.y)) {
			didMarker = true;
                        this.justOneMarker= this.map.addMarker(id, [point.x,point.y], null, "", "");
			if(debug) console.log("\tadding justOneMarker had initial position:" + this.hadInitialPosition);
			if(!this.hadInitialPosition) {
			    let loc = MapUtils.createLonLat(point.x,point.y);
			    if(debug) console.log("\tsetting center:" + loc);
			    this.map.setCenter(loc);
			}
                        return;
                    } else {
			return;
                    }
                }

                let values = record.getData();
                let props = {
                    pointRadius: radius,
                    strokeWidth: strokeWidth,
                    strokeColor: strokeColor,
		    fillColor: fillColor,
		    fillOpacity: fillOpacity
                };

		if(shapeBy.field) {
		    let gv = values[shapeBy.index];
		    if(gv)  {
			if(!Utils.isDefined(shapeBy.map[gv])) {
			    if(dfltShape) {
				shapeBy.map[gv] = dfltShape;
			    } else {
				if(dfltShapeIdx>=dfltShapes.length)
				    dfltShapeIdx = 0;
				shapeBy.map[gv] = dfltShapes[dfltShapeIdx++];
			    }
			}
			if(Utils.isDefined(shapeBy.map[gv])) {
			    props.graphicName = shapeBy.map[gv];
			}
			
		    }
		}

                segmentWidth = dfltSegmentWidth;
                props.pointRadius = sizeBy.getSize(values, props.pointRadius,sizeByFunc);
		if(props.pointRadius<0) return;


		if(isNaN(props.pointRadius) || props.pointRadius == 0) props.pointRadius= radius;
		let hasColorByValue = false;
		let colorByValue;
		let colorByColor;
		let theColor =  null;
		if(colorBy.compareFields.length>0) {
		    let maxColor = null;
		    let maxValue = 0;
		    colorBy.compareFields.forEach((f,idx)=>{
			let value = record.getData()[f.getIndex()];
			if(idx==0 || value>maxValue) {
			    maxColor = colorBy.colors[idx];
			    maxValue = value;
			}
		    });
		    colorByValue = maxValue;
		    theColor = maxColor;
		} else {
		    if(colorByEnabled) {
			let value = record.getData()[colorBy.index];
			colorByValue = value;
			theColor =  colorBy.getColorFromRecord(record, theColor);
		    }
                }

		if(theColor) {
                    didColorBy = true;
		    hasColorByValue  = true;
		    colorByColor = props.fillColor = colorBy.convertColor(theColor, colorByValue);
		}

		if(highlightRecords && !record.isHighlight(this)) {
		    props.fillColor =  unhighlightFillColor;
		    props.strokeColor =  unhighlightStrokeColor;
		    props.strokeWidth=unhighlightStrokeWidth;
		    if(unhighlightRadius>0)
			props.pointRadius = unhighlightRadius;
		}

		if(polygonField) {
		    let s = values[polygonField.getIndex()];
		    let delimiter;
		    console.log("p:" + polygonField);
		    [";",","].forEach(d=>{
			if(s.indexOf(d)>=0) delimiter = d;
		    });
		    let toks  = s.split(delimiter);
		    let polygonProps ={};
		    $.extend(polygonProps,props);
		    if(polygonProps.strokeWidth==0)
			polygonProps.strokeWidth=1;
		    if(polygonColorTable) {
			if(cidx>=polygonColorTable.length) cidx=0;
			polygonProps.strokeColor=polygonColorTable[cidx++];
		    }
		    for(let pIdx=2;pIdx<toks.length;pIdx+=2) {
			let p = [];
			let lat1 = parseFloat(toks[pIdx-2]);
			let lon1 = parseFloat(toks[pIdx-1]);
			let lat2 = parseFloat(toks[pIdx]);
			let lon2 = parseFloat(toks[pIdx+1]);
			if(!latlon) {
			    let tmp =lat1;
			    lat1=lon1;
			    lon1=tmp;
			    tmp =lat2;
			    lat2=lon2;
			    lon2=tmp;
			}
			p.push(new OpenLayers.Geometry.Point(lon1,lat1));
			p.push(new OpenLayers.Geometry.Point(lon2,lat2));
			let poly = this.map.addPolygon("polygon" + pIdx, "",p,polygonProps);
			poly.textGetter = textGetter;
			poly.record = record;
			let recordDate = record.getDate();
			if (recordDate) {
			    poly.date = recordDate.getTime();
			}
			this.lines.push(poly);
		    }
		}


                if (showSegments && latField1 && latField2 && lonField1 && lonField2) {
                    let lat1 = values[latField1.getIndex()];
                    let lat2 = values[latField2.getIndex()];
                    let lon1 = values[lonField1.getIndex()];
                    let lon2 = values[lonField2.getIndex()];
                    let attrs = {};
                    if (props.fillColor)
                        attrs.strokeColor = props.fillColor;
                    else
                        attrs.strokeColor = lineColor;
		    attrs.strokeLinecap = lineCap;
		    attrs.strokeColor =   colorBy.getColorFromRecord(record, attrs.strokeColor);
                    attrs.strokeWidth = segmentWidth;
		    let line = this.map.addLine("line-" + i, "", lat1, lon1, lat2, lon2, attrs);
		    line.record = record;
		    line.textGetter = textGetter;
		    if(highlight) {
			line.highlightTextGetter = highlightGetter;
			line.highlightSize = highlightSize;
		    }	
		    line.record = record;
                    this.lines.push(line);
                    if (showEndPoints) {
                        let pointProps = {};
                        $.extend(pointProps, props);
                        pointProps.fillColor = attrs.strokeColor;
                        pointProps.strokeColor = attrs.strokeColor;
                        pointProps.pointRadius = dfltEndPointSize;
                        pointProps.pointRadius = endPointSize;
                        let p1 = new OpenLayers.LonLat(lon1, lat1);
                        let p2 = new OpenLayers.LonLat(lon2, lat2);
                        if (!Utils.isDefined(seen[p1])) {
                            seen[p1] = true;
			    let pt1 =this.map.addPoint("endpt-" + i, p1, pointProps);
			    pt1.record = record;
			    pt1.textGetter = textGetter;
                            this.points.push(pt1);
                        }
                        if (!Utils.isDefined(seen[p2])) {
                            seen[p2] = true;
                            let pt2 = this.map.addPoint("endpt2-" + i, p2, pointProps);
			    pt2.record = record;
			    pt2.textGetter = textGetter;
                            this.points.push(pt2);
                        }

                    }
		}


                if (showPoints) {
                    //We do this because openlayers gets really slow when there are lots of features at one point
		    let key = point.x*10000 + point.y;
		    if (!seen[key]) {
			seen[key] = 1;
		    }  else {
//			console.log(this.formatDate(record.getDate()) +" " + record.getLatitude() + " " + seen[key]);
			if (seen[key] > 500) {
			    return;
			}
			seen[key]++;
		    }

		    let mapPoint=null;
		    let mapPoints =recordLayout.features;
		    //marker
		    if(usingIcon) {
			if(iconField) {
			    let tuple = record.getData();
			    let icon = tuple[iconField.getIndex()];
			    if(iconMap) {
				icon = iconMap[icon];
				if(!icon) icon = this.getMarkerIcon();
			    }
			    let size = iconSize;
			    if(sizeBy.index>=0) {
				size = props.pointRadius;
			    }
			    mapPoint = this.map.addMarker("pt-" + i, point, icon, "pt-" + i,null,null,size);
			    mapPoint.isMarker = true;
			    mapPoints.push(mapPoint);
			    this.markers[record.getId()] = mapPoint;
			} else  {
			    let attrs = {
			    }
			    if(rotateField) attrs.rotation = record.getValue(rotateField.getIndex());
			    mapPoint = this.map.addMarker("pt-" + i, point, markerIcon, "pt-" + i,null,null,props.pointRadius,null,null,attrs);
			    mapPoint.isMarker = true;
			    mapPoints.push(mapPoint);
			    this.markers[record.getId()] = mapPoint;
			}
		    } 


		    if(!usingIcon || colorByEnabled)  {
			if(!props.graphicName)
			    props.graphicName = graphicName;
			if(rotateField) props.rotation = record.getValue(rotateField.getIndex());
			props.pointRadius= radius;
			props.fillColor =   colorBy.getColorFromRecord(record, props.fillColor);
			if(radius>0) {
			    mapPoint = this.map.addPoint("pt-" + i, point, props, null, dontAddPoint);
			    if(mapPoint) {
				this.markers[record.getId()] = mapPoint;
				mapPoints.push(mapPoint);
			    }
			}
		    }
		    if(isPath && !groups && lastPoint) {
			pathAttrs.strokeColor = colorBy.getColorFromRecord(record, pathAttrs.strokeColor);
			this.lines.push(this.map.addLine("line-" + i, "", lastPoint.y, lastPoint.x, point.y,point.x,pathAttrs));
		    }
		    lastPoint = point;
		    if(features) {
			mapPoints.forEach(f=>{features.push(f);});
		    }
                    let date = record.getDate();
		    mapPoints.forEach(mapPoint=>{
			if(highlight) {
			    mapPoint.highlightTextGetter = highlightGetter;
			    mapPoint.highlightSize = highlightSize;
			}
			mapPoint.record = record;
			mapPoint.textGetter = textGetter;
			mapPoint.hasColorByValue = hasColorByValue;
		 	mapPoint.colorByValue= colorByValue;
			mapPoint.colorByColor = colorByColor;
			if (date) {
			    mapPoint.date = date.getTime();
			}
			this.points.push(mapPoint);
			if(!recordLayout.visible) {
			    mapPoint.featureVisible = false;
			    this.map.checkFeatureVisible(mapPoint,true);
			}
		    });
		}
	    });

	    if(records.length>0 && this.getProperty("selectFirstRecord")&& !this.haveSelectedFirstRecord) {
		this.haveSelectedFirstRecord = true;
		let record = records[0];
		this.propagateEventRecordSelection({record:record});
		let displayDiv = this.getProperty("displayDiv", null);
		if(displayDiv && this.textGetter) {
		    $("#" + displayDiv).html(this.textGetter({record:record}));
		}
		let marker =  this.markers[record.getId()];
		if(marker) {
		    this.map.handleFeatureclick(null,marker);
		}
	    }



	    t3  =new Date();
//	    Utils.displayTimes("map points 2:",[t2,t3], true);
	    if (showSegments) {
		this.map.centerOnMarkers();
	    }

//Don't think we have to do this here. Saves lots of draw time
//	    if(this.map.circles)
//		this.map.circles.redraw();



	    let legendSide = this.getProperty("sizeByLegendSide");
	    if(legendSide) {
		let legend = sizeBy.getLegend(5,fillColor,legendSide=="left" || legendSide=="right");
		if(legend !="") {
		    let style = this.getProperty("sizeByLegendStyle");
		    if(style) legend = HU.div([STYLE,style],legend);
		    this.jq(ID_SIZEBY_LEGEND).html(legend);
		    this.callingUpdateSize = true;
		    this.map.getMap().updateSize();
		    this.callingUpdateSize = false;
		}
	    }
	    this.jq(ID_BOTTOM).append(HU.div([ID,this.domId(ID_SHAPES)]));
		    if (didColorBy) {
		this.showColorTable(colorBy);
            }

	    if(iconField&& iconMap) {
		let html = "";
		for(a in iconMap) {
		    html+=HU.image(iconMap[a],["width","32"]) +" " + a+" ";
		}
		this.jq(ID_SHAPES).html(HU.center(html));
	    }

	    if(shapeBy.field) {
		let shapes = shapeBy.field.getLabel()+": ";
		for(v in shapeBy.map) {
		    let shape = shapeBy.map[v];
		    if(shape=="circle") shape=HU.getIconImage("fa-circle");
		    else if(shape=="square") shape=HU.getIconImage("fa-square");		    
		    else if(shape=="rectangle") shape=HU.getIconImage("fa-square");		    
		    else if(shape=="star") shape=HU.getIconImage("fa-star");		    
		    else if(shape=="triangle") shape=HU.getIconImage("/icons/triangle.png",["width","16px"]);		    
		    else if(shape=="lightning") shape=HU.getIconImage("/icons/lightning.png",["width","16px"]);		    
		    else if(shape=="cross") shape=HU.getIconImage("/icons/cross.png",["width","16px"]);		    
		    else if(shape=="church") shape=HU.getIconImage("fa-cross");
		    shapes+=shape+" " + v +SPACE2;
		}
		this.jq(ID_SHAPES).html(HU.center(shapes));
	    }

	    if (this.getProperty("animationTakeStep", false)) {
		this.getAnimation().doNext();
	    }

        },

        addLabels:function(records, fields, points) {
            let labelTemplate = this.getProperty("labelTemplate");
            if(!labelTemplate) return;
	    if(labelTemplate) {
		labelTemplate = labelTemplate.replace(/_nl_/g,"\n");
		if(!this.map.labelLayer) {
		    this.map.labelLayer = new OpenLayers.Layer.Vector("Labels", {
			styleMap: new OpenLayers.StyleMap({'default':{
                            label : labelTemplate,
                            fontColor: this.getProperty("labelFontColor","#000"),
                            fontSize: this.getProperty("labelFontSize","12px"),
                            fontFamily: this.getProperty("labelFontFamily","'Open Sans', Helvetica Neue, Arial, Helvetica, sans-serif"),
                            fontWeight: this.getProperty("labelFontWeight","plain"),
                            labelAlign: this.getProperty("labelAlign","lb"),
                            labelXOffset: this.getProperty("labelXOffset","0"),
                            labelYOffset: this.getProperty("labelYOffset","0"),
                            labelOutlineColor:this.getProperty("labelOutlineColor","#fff"),
                            labelOutlineWidth: this.getProperty("labelOutlineWidth","0"),
			    labelSelect:true,
			}}),
                    });
		    this.map.addVectorLayer(this.map.labelLayer, true);
                    this.map.labelLayer.setZIndex(100);
		}
	    }



	    var features =  [];
            var seen = {};
	    var colorBy = this.getProperty("colorBy");
	    var sizeBy = this.getProperty("sizeBy");
            for (var i = 0; i < records.length; i++) {
		var record = records[i];
                var point = record.point;
		//For now just set the lat/lon
		point = {x:record.getLongitude(),y:record.getLatitude()};
                var center = new OpenLayers.Geometry.Point(point.x, point.y);
                center.transform(this.map.displayProjection, this.map.sourceProjection);
                var tuple = record.getData();
                var pointFeature = new OpenLayers.Feature.Vector(center);
                pointFeature.noSelect = true;
                pointFeature.attributes = {
                };
                pointFeature.attributes[RECORD_INDEX] = (i+1);
                for (var fieldIdx = 0;fieldIdx < fields.length; fieldIdx++) {
                    var field = fields[fieldIdx];
                    pointFeature.attributes[field.getId()] = field.getValue(record);
		    if(colorBy && field.getId() == colorBy) {
			pointFeature.attributes["colorBy"] = field.getValue(record);
		    }
		    if(sizeBy && field.getId() == sizeBy) {
			pointFeature.attributes["sizeBy"] = field.getValue(record);
		    }
                }
                features.push(pointFeature);
	    }
	    if(this.labelFeatures)
		this.map.labelLayer.removeFeatures(this.labelFeatures);
            this.map.labelLayer.addFeatures(features);
	    this.labelFeatures = features;
	    $("#" + this.map.labelLayer.id).css("z-index",900);
        },


        handleEventRemoveDisplay: function(source, display) {
            if (!this.map) {
                return;
            }
            var mapEntryInfo = this.mapEntryInfos[display];
            if (mapEntryInfo != null) {
                mapEntryInfo.removeFromMap(this.map);
            }
            var feature = this.findFeature(display, true);
            if (feature != null) {
                if (feature.line != null) {
                    this.map.removePolygon(feature.line);
                }
            }
        },
        findFeature: function(source, andDelete) {
            for (var i in this.features) {
                var feature = this.features[i];
                if (feature.source == source) {
                    if (andDelete) {
                        this.features.splice(i, 1);
                    }
                    return feature;
                }
            }
            return null;
        },

        getMarkerIcon: function() {
            if (this.getProperty("markerIcon")) {
                var icon = this.getProperty("markerIcon");
                if (icon.startsWith("/"))
                    return ramaddaBaseUrl + icon;
                else
                    return icon;
            }
            displayMapCurrentMarker++;
            if (displayMapCurrentMarker >= displayMapMarkers.length) displayMapCurrentMarker = 0;
            return ramaddaBaseUrl + "/lib/openlayers/v2/img/" + displayMapMarkers[displayMapCurrentMarker];
        },
	highlightMarker:null,
        handleEventRecordHighlight: function(source, args) {
	    SUPER.handleEventRecordHighlight.call(this,source,args);
	    this.highlightPoint(args.record.getLatitude(),args.record.getLongitude(),args.highlight,true);
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
            if (!this.map) {
                return;
            }
	    args.highlight = true;
            if (!this.getProperty("showRecordSelection", true)) {
		return;
	    }
	    this.handleEventRecordHighlight(source,args);
	    return;
            var record = args.record;
            if (record.hasLocation()) {
                var latitude = record.getLatitude();
                var longitude = record.getLongitude();
                if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) return;
                var point = new OpenLayers.LonLat(longitude, latitude);
                var marker = this.myMarkers[source];
                if (marker != null) {
                    this.map.removeMarker(marker);
                }
                var icon = displayMapMarkerIcons[source];
                if (icon == null) {
                    icon = this.getMarkerIcon();
                    displayMapMarkerIcons[source] = icon;
                }
                this.myMarkers[source] = this.map.addMarker(source.getId(), point, icon, "", args.html, null, 24);
            }
        }
    });
}

function MapEntryInfo(entry) {
    RamaddaUtil.defineMembers(this, {
        entry: entry,
        marker: null,
        rectangle: null,
        removeFromMap: function(map) {
            if (this.marker != null) {
                map.removeMarker(this.marker);
            }
            if (this.rectangle != null) {
                map.removePolygon(this.rectangle);
            }
            if (this.polygon != null) {
                map.removePolygon(this.polygon);
            }
            if (this.circle != null) {
                map.removePoint(this.circle);
            }
        }

    });
}


function RamaddaMapgridDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_MAPGRID, properties);
    let myProps = [
	{label:'Grid Map Attributes'},
	{p:'localeField',ex:''},
	{p:'grid',ex:'countries|us'},
	{p:'cellSize',ex:'30',tt:'use 0 for flexible width'},
	{p:'cellHeight',ex:'30'},
	{p:'showCellLabel',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        displayData: function(reload) {
	    this.updateUI();
	},
	handleEventFieldsSelected: function(source, fields) {
	    if(this.getProperty("selectedFieldIsColorBy") && fields.length>0) {
		this.colorByFieldChanged(fields[0]);
	    }
        },
	colorByFieldChanged:function(field) {
	    this.haveCalledUpdateUI = false;
	    this.setProperty("colorBy", field);
	    this.vectorMapApplied  = false;
	    this.updateUI({colorByFieldChanged:true});
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
            let fields = this.getData().getNonGeoFields();
	    let localeField = this.getFieldById(fields,this.getProperty("localeField","state"));
	    if(localeField==null) {
		localeField = this.getFieldById(fields,"state");
	    }
	    let minx = Number.MAX_VALUE;
	    let miny = Number.MAX_VALUE;
	    let maxx = Number.MIN_VALUE;
	    let maxy = Number.MIN_VALUE;
	    let map = {};
	    let grid = this.getProperty("grid","us")=="countries"?this.countries:this.states;

	    grid.forEach(o=>{
		minx = Math.min(minx,o.x);
		maxx = Math.max(maxx,o.x);
		miny = Math.min(miny,o.y);
		maxy = Math.max(maxy,o.y);
		map[this.domId("cell_" +o.x+ "_"+o.y)] = o;
	    });

            let colorBy = this.getColorByInfo(records);
	    let sparkLinesColorBy = this.getColorByInfo(records,"sparklineColorBy");
	    let strokeColorBy = this.getColorByInfo(records,"strokeColorBy","strokeColorByMap");
	    let sparkLineField = this.getFieldById(fields,this.getProperty("sparklineField"));
	    let table =HU.open(TABLE,[WIDTH,"100%"]);
	    let width = this.getProperty("cellWidth", this.getProperty("cellSize",0));
	    let height = this.getProperty("cellHeight",width);
	    if(height==0) height=30;
	    let showLabel  = this.getProperty("showCellLabel",true);
	    let cellStyle  = this.getProperty("cellStyle","");
	    let cellMap = {};
	    for(let y=1;y<=maxy;y++) {
		table+=HU.open(TR);
		for(let x=1;x<=maxx;x++) {
		    let id = this.domId("cell_" +x+ "_"+y);
		    let o = map[id];
		    let extra = " id='" + id +"' ";
		    let style = HU.css('position','relative','margin','1px','vertical-align','center','text-align','center',HEIGHT, height+"px");
		    if(width>0) style+=HU.css(WIDTH,width+'px');
		    let c = "";
		    if(o) {
			style+="background:#ccc;" + cellStyle;
			if(!sparkLineField) {
			    extra += " title='" + o.name +"' ";
			}
			extra += HU.attr(CLASS,'display-mapgrid-cell');
			c = HU.div([STYLE,HU.css('padding-left','3px')], (showLabel?o.codes[0]:""));
			o.codes.forEach(c=>cellMap[c] = id);
			cellMap[o.name] = id;
		    }
		    let td = HU.td([],"<div " + extra +" style='" + style +"'>" + c+"</div>");
		    table+=td;
		}
		table+=HU.close(TR);
	    }
	    table +=HU.tr([],HU.td(["colspan", maxx],"<br>" +   HU.div([ID,this.domId(ID_COLORTABLE)])));
	    table+=HU.close(TABLE);
	    this.setContents(HU.center(table));

	    let states = [];
	    let stateData = this.stateData = {
	    }
	    let minData = 0;
	    let maxData = 0;
	    let seen = {};
	    let contents = this.getContents();
	    for(let i=0;i<records.length;i++) {
		let record = records[i]; 
		let tuple = record.getData();
		let state = tuple[localeField.getIndex()];
		let cellId = cellMap[state];
		if(!cellId) {
		    cellId = cellMap[state.toUpperCase()];
		}
		if(!cellId) {
		    //		    console.log("Could not find cell:" + state);
		    continue;
		}
		$("#"+cellId).attr(RECORD_INDEX,i);

		if(!stateData[state]) {
		    states.push(state);
		    stateData[state] = {
			cellId: cellId,
			data:[],
			records:[]
		    }
		}
		if(sparkLineField) {
		    let value = record.getValue(sparkLineField.getIndex());
		    if(!isNaN(value)) {
			minData = i==0?value:Math.min(minData, value);
			maxData = i==0?value:Math.max(maxData, value);
			stateData[state].data.push(value);
			stateData[state].records.push(record);
		    }
		}

		let colorByEnabled = colorBy.isEnabled();

		//TODO: sort the state data on time
                if (colorByEnabled) {
                    let value = record.getData()[colorBy.index];
		    let color = colorBy.getColorFromRecord(record);
		    let cell = contents.find("#" + cellId);
		    cell.css("background",color);
		    let foreground = Utils.getForegroundColor(color);
		    if(foreground) {
			cell.css('color', foreground);
		    }
		    cell.attr(RECORD_INDEX,i);
                }
		if (strokeColorBy.isEnabled()) {
                    let value = record.getData()[strokeColorBy.index];
		    let color = strokeColorBy.getColor(value, record);
		    let cell = contents.find("#" + cellId);
		    cell.css("border-color",color);
		    cell.css("border-width","2px");
                }
	    }

	    if(sparkLineField) {
		let vOffset = 0;
		states.forEach((state,idx)=>{
		    let s = stateData[state];
		    let innerId = s.cellId+"_inner";
		    let cellWidth = width;
		    if(cellWidth==0) {
			cellWidth = $("#" + s.cellId).width();
		    }
		    let style = HU.css(WIDTH,cellWidth+'px',HEIGHT, (height-vOffset) +'px','position','absolute','left','0px','top', vOffset+'px');
		    let innerDiv = HU.div([ID, innerId, STYLE,style]);
		    $("#" + s.cellId).append(innerDiv);
		    drawSparkLine(this, "#"+innerId,cellWidth,height-vOffset,s.data,s.records,minData,maxData,sparkLinesColorBy);
		});
	    }

	    this.makePopups(contents.find(".display-mapgrid-cell"), records);
	    let _this = this;
	    contents.find(".display-mapgrid-cell").click(function() {
		let record = records[$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });	
	    if(!sparkLineField) {
		this.makeTooltips(contents.find(".display-mapgrid-cell"), records, null, "${default}");
	    }
            if (colorBy.index >= 0) {
		colorBy.displayColorTable();
	    }
	    if (sparkLinesColorBy.index >= 0) {
		sparkLinesColorBy.displayColorTable();
	    }
	},

        handleEventRecordSelection: function(source, args) {
	    let contents = this.getContents();
	    if(this.selectedCell) {
		this.selectedCell.css("border",this.selectedBorder);
	    }
	    let index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    this.selectedCell = contents.find(HU.attrSelect(RECORD_INDEX, index));
	    this.selectedBorder = this.selectedCell.css("border");
	    this.selectedCell.css("border","1px solid red");
	},

	states:  [
	    {name:"Alaska",codes:["AK"],x:2,y:1},
	    {name:"Hawaii",codes:["HI"],x:2,y:8},
	    {name:"Washington",codes:["WA"],x:3,y:3},
	    {name:"Oregon",codes:["OR"],x:3,y:4},
	    {name:"California",codes:["CA"],x:3,y:5},
	    {name:"Idaho",codes:["ID"],x:4,y:3},
	    {name:"Nevada",codes:["NV"],x:4,y:4},
	    {name:"Utah",codes:["UT"],x:4,y:5},
	    {name:"Arizona",codes:["AZ"],x:4,y:6},
	    {name:"Montana",codes:["MT"],x:5,y:3},
	    {name:"Wyoming",codes:["WY"],x:5,y:4},
	    {name:"Colorado",codes:["CO"],x:5,y:5},
	    {name:"New Mexico",codes:["NM"],x:5,y:6},
	    {name:"North Dakota",codes:["ND"],x:6,y:3},
	    {name:"South Dakota",codes:["SD"],x:6,y:4},
	    {name:"Nebraska",codes:["NE"],x:6,y:5},
	    {name:"Kansas",codes:["KS"],x:6,y:6},
	    {name:"Oklahoma",codes:["OK"],x:6,y:7},
	    {name:"Texas",codes:["TX"],x:6,y:8},
	    {name:"Minnesota",codes:["MN"],x:7,y:3},
	    {name:"Iowa",codes:["IA"],x:7,y:4},
	    {name:"Missouri",codes:["MO"],x:7,y:5},
	    {name:"Arkansas",codes:["AR"],x:7,y:6},
	    {name:"Louisiana",codes:["LA"],x:7,y:7},
	    {name:"Illinois",codes:["IL"],x:8,y:3},
	    {name:"Indiana",codes:["IN"],x:8,y:4},
	    {name:"Kentucky",codes:["KY"],x:8,y:5},
	    {name:"Tennessee",codes:["TN"],x:8,y:6},
	    {name:"Mississippi",codes:["MS"],x:8,y:7},
	    {name:"Wisconsin",codes:["WI"],x:9,y:2},
	    {name:"Ohio",codes:["OH"],x:9,y:4},
	    {name:"West Virginia",codes:["WV"],x:9,y:5},
	    {name:"North Carolina",codes:["NC"],x:9,y:6},
	    {name:"Alabama",codes:["AL"],x:9,y:7},
	    {name:"Michigan",codes:["MI"],x:9,y:3},
	    {name:"Pennsylvania",codes:["PA"],x:10,y:4},
	    {name:"Virginia",codes:["VA"],x:10,y:5},
	    {name:"South Carolina",codes:["SC"],x:10,y:6},
	    {name:"Georgia",codes:["GA"],x:10,y:7},
	    {name:"New York",codes:["NY"],x:11,y:3},
	    {name:"New Jersey",codes:["NJ"],x:11,y:4},
	    {name:"Maryland",codes:["MD"],x:11,y:5},
	    {name:"DC",codes:["DC"],x:11,y:6},
	    {name:"Florida",codes:["FL"],x:11,y:8},
	    {name:"Vermont",codes:["VT"],x:12,y:2},
	    {name:"Rhode Island",codes:["RI"],x:12,y:3},
	    {name:"Connecticut",codes:["CT"],x:12,y:4},
	    {name:"Delaware",codes:["DE"],x:12,y:5},
	    {name:"Maine",codes:["ME"],x:13,y:1},
	    {name:"New Hampshire",codes:["NH"],x:13,y:2},
	    {name:"Massachusetts",codes:["MA"],x:13,y:3},
	],
	countries:
	[
	    {
		"name": "Afghanistan",
		"codes": [
		    "AF",
		    "AFG",
		    "004",
		    "ISO 3166-2:AF"
		],
		"x": 22,
		"y": 8
	    },
	    {
		"name": "Albania",
		"codes": [
		    "AL",
		    "ALB",
		    "008",
		    "ISO 3166-2:AL"
		],
		"x": 15,
		"y": 9
	    },
	    {
		"name": "Algeria",
		"codes": [
		    "DZ",
		    "DZA",
		    "012",
		    "ISO 3166-2:DZ"
		],
		"x": 13,
		"y": 11
	    },
	    {
		"name": "Angola",
		"codes": [
		    "AO",
		    "AGO",
		    "024",
		    "ISO 3166-2:AO"
		],
		"x": 13,
		"y": 17
	    },
	    {
		"name": "Antarctica",
		"codes": [
		    "AQ",
		    "ATA",
		    "010",
		    "ISO 3166-2:AQ"
		],
		"x": 15,
		"y": 23
	    },
	    {
		"name": "Antigua & Barbuda",
		"codes": [
		    "AG",
		    "ATG",
		    "028",
		    "ISO 3166-2:AG"
		],
		"x": 7,
		"y": 4
	    },
	    {
		"name": "Argentina",
		"codes": [
		    "AR",
		    "ARG",
		    "032",
		    "ISO 3166-2:AR"
		],
		"x": 6,
		"y": 14
	    },
	    {
		"name": "Armenia",
		"codes": [
		    "AM",
		    "ARM",
		    "051",
		    "ISO 3166-2:AM"
		],
		"x": 20,
		"y": 6
	    },
	    {
		"name": "Australia",
		"codes": [
		    "AU",
		    "AUS",
		    "036",
		    "ISO 3166-2:AU"
		],
		"x": 24,
		"y": 19
	    },
	    {
		"name": "Austria",
		"codes": [
		    "AT",
		    "AUT",
		    "040",
		    "ISO 3166-2:AT"
		],
		"x": 15,
		"y": 6
	    },
	    {
		"name": "Azerbaijan",
		"codes": [
		    "AZ",
		    "AZE",
		    "031",
		    "ISO 3166-2:AZ"
		],
		"x": 21,
		"y": 7
	    },
	    {
		"name": "Bahamas",
		"codes": [
		    "BS",
		    "BHS",
		    "044",
		    "ISO 3166-2:BS"
		],
		"x": 4,
		"y": 2
	    },
	    {
		"name": "Bahrain",
		"codes": [
		    "BH",
		    "BHR",
		    "048",
		    "ISO 3166-2:BH"
		],
		"x": 20,
		"y": 9
	    },
	    {
		"name": "Bangladesh",
		"codes": [
		    "BD",
		    "BGD",
		    "050",
		    "ISO 3166-2:BD"
		],
		"x": 23,
		"y": 8
	    },
	    {
		"name": "Barbados",
		"codes": [
		    "BB",
		    "BRB",
		    "052",
		    "ISO 3166-2:BB"
		],
		"x": 8,
		"y": 6
	    },
	    {
		"name": "Belarus",
		"codes": [
		    "BY",
		    "BLR",
		    "112",
		    "ISO 3166-2:BY"
		],
		"x": 17,
		"y": 4
	    },
	    {
		"name": "Belgium",
		"codes": [
		    "BE",
		    "BEL",
		    "056",
		    "ISO 3166-2:BE"
		],
		"x": 13,
		"y": 5
	    },
	    {
		"name": "Belize",
		"codes": [
		    "BZ",
		    "BLZ",
		    "084",
		    "ISO 3166-2:BZ"
		],
		"x": 2,
		"y": 3
	    },
	    {
		"name": "Benin",
		"codes": [
		    "BJ",
		    "BEN",
		    "204",
		    "ISO 3166-2:BJ"
		],
		"x": 15,
		"y": 14
	    },
	    {
		"name": "Bhutan",
		"codes": [
		    "BT",
		    "BTN",
		    "064",
		    "ISO 3166-2:BT"
		],
		"x": 24,
		"y": 7
	    },
	    {
		"name": "Bolivia",
		"codes": [
		    "BO",
		    "BOL",
		    "068",
		    "ISO 3166-2:BO"
		],
		"x": 6,
		"y": 11
	    },
	    {
		"name": "Bosnia & Herzegovina",
		"codes": [
		    "BA",
		    "BIH",
		    "070",
		    "ISO 3166-2:BA"
		],
		"x": 15,
		"y": 7
	    },
	    {
		"name": "Botswana",
		"codes": [
		    "BW",
		    "BWA",
		    "072",
		    "ISO 3166-2:BW"
		],
		"x": 15,
		"y": 18
	    },
	    {
		"name": "Brazil",
		"codes": [
		    "BR",
		    "BRA",
		    "076",
		    "ISO 3166-2:BR"
		],
		"x": 8,
		"y": 11
	    },
	    {
		"name": "Brunei Darussalam",
		"codes": [
		    "BN",
		    "BRN",
		    "096",
		    "ISO 3166-2:BN"
		],
		"x": 25,
		"y": 12
	    },
	    {
		"name": "Bulgaria",
		"codes": [
		    "BG",
		    "BGR",
		    "100",
		    "ISO 3166-2:BG"
		],
		"x": 17,
		"y": 7
	    },
	    {
		"name": "Burkina Faso",
		"codes": [
		    "BF",
		    "BFA",
		    "854",
		    "ISO 3166-2:BF"
		],
		"x": 13,
		"y": 13
	    },
	    {
		"name": "Burundi",
		"codes": [
		    "BI",
		    "BDI",
		    "108",
		    "ISO 3166-2:BI"
		],
		"x": 15,
		"y": 16
	    },
	    {
		"name": "Cambodia",
		"codes": [
		    "KH",
		    "KHM",
		    "116",
		    "ISO 3166-2:KH"
		],
		"x": 25,
		"y": 10
	    },
	    {
		"name": "Cameroon",
		"codes": [
		    "CM",
		    "CMR",
		    "120",
		    "ISO 3166-2:CM"
		],
		"x": 14,
		"y": 15
	    },
	    {
		"name": "Canada",
		"codes": [
		    "CA",
		    "CAN",
		    "124",
		    "ISO 3166-2:CA"
		],
		"x": 1,
		"y": 1
	    },
	    {
		"name": "Cabo Verde",
		"codes": [
		    "CV",
		    "CPV",
		    "132",
		    "ISO 3166-2:CV"
		],
		"x": 10,
		"y": 15
	    },
	    {
		"name": "Central African Republic",
		"codes": [
		    "CF",
		    "CAF",
		    "140",
		    "ISO 3166-2:CF"
		],
		"x": 16,
		"y": 14
	    },
	    {
		"name": "Chad",
		"codes": [
		    "TD",
		    "TCD",
		    "148",
		    "ISO 3166-2:TD"
		],
		"x": 14,
		"y": 13
	    },
	    {
		"name": "Chile",
		"codes": [
		    "CL",
		    "CHL",
		    "152",
		    "ISO 3166-2:CL"
		],
		"x": 6,
		"y": 13
	    },
	    {
		"name": "China",
		"codes": [
		    "CN",
		    "CHN",
		    "156",
		    "ISO 3166-2:CN"
		],
		"x": 24,
		"y": 6
	    },
	    {
		"name": "Colombia",
		"codes": [
		    "CO",
		    "COL",
		    "170",
		    "ISO 3166-2:CO"
		],
		"x": 5,
		"y": 9
	    },
	    {
		"name": "Comoros",
		"codes": [
		    "KM",
		    "COM",
		    "174",
		    "ISO 3166-2:KM"
		],
		"x": 18,
		"y": 18
	    },
	    {
		"name": "Congo",
		"codes": [
		    "CG",
		    "COG",
		    "178",
		    "ISO 3166-2:CG"
		],
		"x": 14,
		"y": 16
	    },
	    {
		"name": "Congo (Democratic Republic of the)",
		"codes": [
		    "CD",
		    "COD",
		    "180",
		    "ISO 3166-2:CD"
		],
		"x": 15,
		"y": 15
	    },
	    {
		"name": "Costa Rica",
		"codes": [
		    "CR",
		    "CRI",
		    "188",
		    "ISO 3166-2:CR"
		],
		"x": 3,
		"y": 7
	    },
	    {
		"name": "Cte d'Ivoire",
		"codes": [
		    "CI",
		    "CIV",
		    "384",
		    "ISO 3166-2:CI"
		],
		"x": 12,
		"y": 15
	    },
	    {
		"name": "Croatia",
		"codes": [
		    "HR",
		    "HRV",
		    "191",
		    "ISO 3166-2:HR"
		],
		"x": 14,
		"y": 7
	    },
	    {
		"name": "Cuba",
		"codes": [
		    "CU",
		    "CUB",
		    "192",
		    "ISO 3166-2:CU"
		],
		"x": 4,
		"y": 3
	    },
	    {
		"name": "Cyprus",
		"codes": [
		    "CY",
		    "CYP",
		    "196",
		    "ISO 3166-2:CY"
		],
		"x": 17,
		"y": 10
	    },
	    {
		"name": "Czech Republic",
		"codes": [
		    "CZ",
		    "CZE",
		    "203",
		    "ISO 3166-2:CZ"
		],
		"x": 15,
		"y": 5
	    },
	    {
		"name": "Denmark",
		"codes": [
		    "DK",
		    "DNK",
		    "208",
		    "ISO 3166-2:DK"
		],
		"x": 14,
		"y": 3
	    },
	    {
		"name": "Djibouti",
		"codes": [
		    "DJ",
		    "DJI",
		    "262",
		    "ISO 3166-2:DJ"
		],
		"x": 17,
		"y": 13
	    },
	    {
		"name": "Dominica",
		"codes": [
		    "DM",
		    "DMA",
		    "212",
		    "ISO 3166-2:DM"
		],
		"x": 7,
		"y": 7
	    },
	    {
		"name": "Dominican Republic",
		"codes": [
		    "DO",
		    "DOM",
		    "214",
		    "ISO 3166-2:DO"
		],
		"x": 6,
		"y": 4
	    },
	    {
		"name": "Ecuador",
		"codes": [
		    "EC",
		    "ECU",
		    "218",
		    "ISO 3166-2:EC"
		],
		"x": 5,
		"y": 10
	    },
	    {
		"name": "Egypt",
		"codes": [
		    "EG",
		    "EGY",
		    "818",
		    "ISO 3166-2:EG"
		],
		"x": 16,
		"y": 11
	    },
	    {
		"name": "El Salvador",
		"codes": [
		    "SV",
		    "SLV",
		    "222",
		    "ISO 3166-2:SV"
		],
		"x": 1,
		"y": 5
	    },
	    {
		"name": "Equatorial Guinea",
		"codes": [
		    "GQ",
		    "GNQ",
		    "226",
		    "ISO 3166-2:GQ"
		],
		"x": 13,
		"y": 16
	    },
	    {
		"name": "Eritrea",
		"codes": [
		    "ER",
		    "ERI",
		    "232",
		    "ISO 3166-2:ER"
		],
		"x": 16,
		"y": 13
	    },
	    {
		"name": "Estonia",
		"codes": [
		    "EE",
		    "EST",
		    "233",
		    "ISO 3166-2:EE"
		],
		"x": 17,
		"y": 2
	    },
	    {
		"name": "Ethiopia",
		"codes": [
		    "ET",
		    "ETH",
		    "231",
		    "ISO 3166-2:ET"
		],
		"x": 17,
		"y": 14
	    },
	    {
		"name": "Fiji",
		"codes": [
		    "FJ",
		    "FJI",
		    "242",
		    "ISO 3166-2:FJ"
		],
		"x": 27,
		"y": 19
	    },
	    {
		"name": "Finland",
		"codes": [
		    "FI",
		    "FIN",
		    "246",
		    "ISO 3166-2:FI"
		],
		"x": 17,
		"y": 1
	    },
	    {
		"name": "France",
		"codes": [
		    "FR",
		    "FRA",
		    "250",
		    "ISO 3166-2:FR"
		],
		"x": 12,
		"y": 5
	    },
	    {
		"name": "Gabon",
		"codes": [
		    "GA",
		    "GAB",
		    "266",
		    "ISO 3166-2:GA"
		],
		"x": 14,
		"y": 17
	    },
	    {
		"name": "Gambia",
		"codes": [
		    "GM",
		    "GMB",
		    "270",
		    "ISO 3166-2:GM"
		],
		"x": 12,
		"y": 12
	    },
	    {
		"name": "Georgia",
		"codes": [
		    "GE",
		    "GEO",
		    "268",
		    "ISO 3166-2:GE"
		],
		"x": 21,
		"y": 6
	    },
	    {
		"name": "Germany",
		"codes": [
		    "DE",
		    "DEU",
		    "276",
		    "ISO 3166-2:DE"
		],
		"x": 14,
		"y": 4
	    },
	    {
		"name": "Ghana",
		"codes": [
		    "GH",
		    "GHA",
		    "288",
		    "ISO 3166-2:GH"
		],
		"x": 13,
		"y": 14
	    },
	    {
		"name": "Greece",
		"codes": [
		    "GR",
		    "GRC",
		    "300",
		    "ISO 3166-2:GR"
		],
		"x": 16,
		"y": 9
	    },
	    {
		"name": "Greenland",
		"codes": [
		    "GL",
		    "GRL",
		    "304",
		    "ISO 3166-2:GL"
		],
		"x": 8,
		"y": 1
	    },
	    {
		"name": "Grenada",
		"codes": [
		    "GD",
		    "GRD",
		    "308",
		    "ISO 3166-2:GD"
		],
		"x": 7,
		"y": 8
	    },
	    {
		"name": "Guatemala",
		"codes": [
		    "GT",
		    "GTM",
		    "320",
		    "ISO 3166-2:GT"
		],
		"x": 1,
		"y": 4
	    },
	    {
		"name": "Guinea",
		"codes": [
		    "GN",
		    "GIN",
		    "324",
		    "ISO 3166-2:GN"
		],
		"x": 11,
		"y": 14
	    },
	    {
		"name": "Guinea-Bissau",
		"codes": [
		    "GW",
		    "GNB",
		    "624",
		    "ISO 3166-2:GW"
		],
		"x": 11,
		"y": 13
	    },
	    {
		"name": "Guyana",
		"codes": [
		    "GY",
		    "GUY",
		    "328",
		    "ISO 3166-2:GY"
		],
		"x": 6,
		"y": 10
	    },
	    {
		"name": "Haiti",
		"codes": [
		    "HT",
		    "HTI",
		    "332",
		    "ISO 3166-2:HT"
		],
		"x": 5,
		"y": 4
	    },
	    {
		"name": "Honduras",
		"codes": [
		    "HN",
		    "HND",
		    "340",
		    "ISO 3166-2:HN"
		],
		"x": 2,
		"y": 5
	    },
	    {
		"name": "Hungary",
		"codes": [
		    "HU",
		    "HUN",
		    "348",
		    "ISO 3166-2:HU"
		],
		"x": 16,
		"y": 6
	    },
	    {
		"name": "Iceland",
		"codes": [
		    "IS",
		    "ISL",
		    "352",
		    "ISO 3166-2:IS"
		],
		"x": 10,
		"y": 1
	    },
	    {
		"name": "India",
		"codes": [
		    "IN",
		    "IND",
		    "356",
		    "ISO 3166-2:IN"
		],
		"x": 22,
		"y": 9
	    },
	    {
		"name": "Indonesia",
		"codes": [
		    "ID",
		    "IDN",
		    "360",
		    "ISO 3166-2:ID"
		],
		"x": 25,
		"y": 13
	    },
	    {
		"name": "Iran (Islamic Republic of)",
		"codes": [
		    "IR",
		    "IRN",
		    "364",
		    "ISO 3166-2:IR"
		],
		"x": 20,
		"y": 8
	    },
	    {
		"name": "Iraq",
		"codes": [
		    "IQ",
		    "IRQ",
		    "368",
		    "ISO 3166-2:IQ"
		],
		"x": 20,
		"y": 7
	    },
	    {
		"name": "Ireland",
		"codes": [
		    "IE",
		    "IRL",
		    "372",
		    "ISO 3166-2:IE"
		],
		"x": 10,
		"y": 4
	    },
	    {
		"name": "Israel",
		"codes": [
		    "IL",
		    "ISR",
		    "376",
		    "ISO 3166-2:IL"
		],
		"x": 18,
		"y": 10
	    },
	    {
		"name": "Italy",
		"codes": [
		    "IT",
		    "ITA",
		    "380",
		    "ISO 3166-2:IT"
		],
		"x": 13,
		"y": 7
	    },
	    {
		"name": "Jamaica",
		"codes": [
		    "JM",
		    "JAM",
		    "388",
		    "ISO 3166-2:JM"
		],
		"x": 4,
		"y": 4
	    },
	    {
		"name": "Japan",
		"codes": [
		    "JP",
		    "JPN",
		    "392",
		    "ISO 3166-2:JP"
		],
		"x": 27,
		"y": 6
	    },
	    {
		"name": "Jordan",
		"codes": [
		    "JO",
		    "JOR",
		    "400",
		    "ISO 3166-2:JO"
		],
		"x": 18,
		"y": 8
	    },
	    {
		"name": "Kazakhstan",
		"codes": [
		    "KZ",
		    "KAZ",
		    "398",
		    "ISO 3166-2:KZ"
		],
		"x": 24,
		"y": 5
	    },
	    {
		"name": "Kenya",
		"codes": [
		    "KE",
		    "KEN",
		    "404",
		    "ISO 3166-2:KE"
		],
		"x": 17,
		"y": 15
	    },
	    {
		"name": "Kiribati",
		"codes": [
		    "KI",
		    "KIR",
		    "296",
		    "ISO 3166-2:KI"
		],
		"x": 27,
		"y": 17
	    },
	    {
		"name": "North Korea",
		"codes": [
		    "KP",
		    "PRK",
		    "408",
		    "ISO 3166-2:KP"
		],
		"x": 25,
		"y": 6
	    },
	    {
		"name": "South Korea",
		"codes": [
		    "KR",
		    "KOR",
		    "410",
		    "ISO 3166-2:KR"
		],
		"x": 25,
		"y": 7
	    },
	    {
		"name": "Kosovo",
		"codes": [
		    "XK",
		    "XKX",
		    "383",
		    "ISO 3166-2:XK"
		],
		"x": 16,
		"y": 8
	    },
	    {
		"name": "Kuwait",
		"codes": [
		    "KW",
		    "KWT",
		    "414",
		    "ISO 3166-2:KW"
		],
		"x": 19,
		"y": 8
	    },
	    {
		"name": "Kyrgyzstan",
		"codes": [
		    "KG",
		    "KGZ",
		    "417",
		    "ISO 3166-2:KG"
		],
		"x": 23,
		"y": 6
	    },
	    {
		"name": "Lao People's Democratic Republic",
		"codes": [
		    "LA",
		    "LAO",
		    "418",
		    "ISO 3166-2:LA"
		],
		"x": 25,
		"y": 9
	    },
	    {
		"name": "Latvia",
		"codes": [
		    "LV",
		    "LVA",
		    "428",
		    "ISO 3166-2:LV"
		],
		"x": 17,
		"y": 3
	    },
	    {
		"name": "Lebanon",
		"codes": [
		    "LB",
		    "LBN",
		    "422",
		    "ISO 3166-2:LB"
		],
		"x": 18,
		"y": 9
	    },
	    {
		"name": "Lesotho",
		"codes": [
		    "LS",
		    "LSO",
		    "426",
		    "ISO 3166-2:LS"
		],
		"x": 17,
		"y": 19
	    },
	    {
		"name": "Liberia",
		"codes": [
		    "LR",
		    "LBR",
		    "430",
		    "ISO 3166-2:LR"
		],
		"x": 12,
		"y": 14
	    },
	    {
		"name": "Libya",
		"codes": [
		    "LY",
		    "LBY",
		    "434",
		    "ISO 3166-2:LY"
		],
		"x": 15,
		"y": 11
	    },
	    {
		"name": "Lithuania",
		"codes": [
		    "LT",
		    "LTU",
		    "440",
		    "ISO 3166-2:LT"
		],
		"x": 16,
		"y": 4
	    },
	    {
		"name": "Luxembourg",
		"codes": [
		    "LU",
		    "LUX",
		    "442",
		    "ISO 3166-2:LU"
		],
		"x": 13,
		"y": 6
	    },
	    {
		"name": "Macedonia",
		"codes": [
		    "MK",
		    "MKD",
		    "807",
		    "ISO 3166-2:MK"
		],
		"x": 17,
		"y": 8
	    },
	    {
		"name": "Madagascar",
		"codes": [
		    "MG",
		    "MDG",
		    "450",
		    "ISO 3166-2:MG"
		],
		"x": 19,
		"y": 19
	    },
	    {
		"name": "Malawi",
		"codes": [
		    "MW",
		    "MWI",
		    "454",
		    "ISO 3166-2:MW"
		],
		"x": 15,
		"y": 17
	    },
	    {
		"name": "Malaysia",
		"codes": [
		    "MY",
		    "MYS",
		    "458",
		    "ISO 3166-2:MY"
		],
		"x": 24,
		"y": 11
	    },
	    {
		"name": "Maldives",
		"codes": [
		    "MV",
		    "MDV",
		    "462",
		    "ISO 3166-2:MV"
		],
		"x": 21,
		"y": 12
	    },
	    {
		"name": "Mali",
		"codes": [
		    "ML",
		    "MLI",
		    "466",
		    "ISO 3166-2:ML"
		],
		"x": 14,
		"y": 12
	    },
	    {
		"name": "Malta",
		"codes": [
		    "MT",
		    "MLT",
		    "470",
		    "ISO 3166-2:MT"
		],
		"x": 11,
		"y": 8
	    },
	    {
		"name": "Marshall Islands",
		"codes": [
		    "MH",
		    "MHL",
		    "584",
		    "ISO 3166-2:MH"
		],
		"x": 26,
		"y": 15
	    },
	    {
		"name": "Mauritania",
		"codes": [
		    "MR",
		    "MRT",
		    "478",
		    "ISO 3166-2:MR"
		],
		"x": 11,
		"y": 12
	    },
	    {
		"name": "Mauritius",
		"codes": [
		    "MU",
		    "MUS",
		    "480",
		    "ISO 3166-2:MU"
		],
		"x": 19,
		"y": 20
	    },
	    {
		"name": "Mexico",
		"codes": [
		    "MX",
		    "MEX",
		    "484",
		    "ISO 3166-2:MX"
		],
		"x": 1,
		"y": 3
	    },
	    {
		"name": "Micronesia (Federated States of)",
		"codes": [
		    "FM",
		    "FSM",
		    "583",
		    "ISO 3166-2:FM"
		],
		"x": 26,
		"y": 16
	    },
	    {
		"name": "Moldova (Republic of)",
		"codes": [
		    "MD",
		    "MDA",
		    "498",
		    "ISO 3166-2:MD"
		],
		"x": 18,
		"y": 5
	    },
	    {
		"name": "Mongolia",
		"codes": [
		    "MN",
		    "MNG",
		    "496",
		    "ISO 3166-2:MN"
		],
		"x": 25,
		"y": 5
	    },
	    {
		"name": "Montenegro",
		"codes": [
		    "ME",
		    "MNE",
		    "499",
		    "ISO 3166-2:ME"
		],
		"x": 15,
		"y": 8
	    },
	    {
		"name": "Morocco",
		"codes": [
		    "MA",
		    "MAR",
		    "504",
		    "ISO 3166-2:MA"
		],
		"x": 12,
		"y": 11
	    },
	    {
		"name": "Mozambique",
		"codes": [
		    "MZ",
		    "MOZ",
		    "508",
		    "ISO 3166-2:MZ"
		],
		"x": 16,
		"y": 17
	    },
	    {
		"name": "Myanmar",
		"codes": [
		    "MM",
		    "MMR",
		    "104",
		    "ISO 3166-2:MM"
		],
		"x": 24,
		"y": 8
	    },
	    {
		"name": "Namibia",
		"codes": [
		    "NA",
		    "NAM",
		    "516",
		    "ISO 3166-2:NA"
		],
		"x": 15,
		"y": 19
	    },
	    {
		"name": "Nauru",
		"codes": [
		    "NR",
		    "NRU",
		    "520",
		    "ISO 3166-2:NR"
		],
		"x": 26,
		"y": 17
	    },
	    {
		"name": "Nepal",
		"codes": [
		    "NP",
		    "NPL",
		    "524",
		    "ISO 3166-2:NP"
		],
		"x": 23,
		"y": 9
	    },
	    {
		"name": "Netherlands",
		"codes": [
		    "NL",
		    "NLD",
		    "528",
		    "ISO 3166-2:NL"
		],
		"x": 13,
		"y": 4
	    },
	    {
		"name": "New Zealand",
		"codes": [
		    "NZ",
		    "NZL",
		    "554",
		    "ISO 3166-2:NZ"
		],
		"x": 26,
		"y": 21
	    },
	    {
		"name": "Nicaragua",
		"codes": [
		    "NI",
		    "NIC",
		    "558",
		    "ISO 3166-2:NI"
		],
		"x": 2,
		"y": 6
	    },
	    {
		"name": "Niger",
		"codes": [
		    "NE",
		    "NER",
		    "562",
		    "ISO 3166-2:NE"
		],
		"x": 15,
		"y": 12
	    },
	    {
		"name": "Nigeria",
		"codes": [
		    "NG",
		    "NGA",
		    "566",
		    "ISO 3166-2:NG"
		],
		"x": 13,
		"y": 15
	    },
	    {
		"name": "Norway",
		"codes": [
		    "NO",
		    "NOR",
		    "578",
		    "ISO 3166-2:NO"
		],
		"x": 15,
		"y": 1
	    },
	    {
		"name": "Oman",
		"codes": [
		    "OM",
		    "OMN",
		    "512",
		    "ISO 3166-2:OM"
		],
		"x": 19,
		"y": 11
	    },
	    {
		"name": "Pakistan",
		"codes": [
		    "PK",
		    "PAK",
		    "586",
		    "ISO 3166-2:PK"
		],
		"x": 21,
		"y": 8
	    },
	    {
		"name": "Palau",
		"codes": [
		    "PW",
		    "PLW",
		    "585",
		    "ISO 3166-2:PW"
		],
		"x": 25,
		"y": 16
	    },
	    {
		"name": "Panama",
		"codes": [
		    "PA",
		    "PAN",
		    "591",
		    "ISO 3166-2:PA"
		],
		"x": 4,
		"y": 8
	    },
	    {
		"name": "Papua New Guinea",
		"codes": [
		    "PG",
		    "PNG",
		    "598",
		    "ISO 3166-2:PG"
		],
		"x": 25,
		"y": 17
	    },
	    {
		"name": "Paraguay",
		"codes": [
		    "PY",
		    "PRY",
		    "600",
		    "ISO 3166-2:PY"
		],
		"x": 6,
		"y": 12
	    },
	    {
		"name": "Peru",
		"codes": [
		    "PE",
		    "PER",
		    "604",
		    "ISO 3166-2:PE"
		],
		"x": 5,
		"y": 11
	    },
	    {
		"name": "Philippines",
		"codes": [
		    "PH",
		    "PHL",
		    "608",
		    "ISO 3166-2:PH"
		],
		"x": 26,
		"y": 11
	    },
	    {
		"name": "Poland",
		"codes": [
		    "PL",
		    "POL",
		    "616",
		    "ISO 3166-2:PL"
		],
		"x": 15,
		"y": 4
	    },
	    {
		"name": "Portugal",
		"codes": [
		    "PT",
		    "PRT",
		    "620",
		    "ISO 3166-2:PT"
		],
		"x": 11,
		"y": 6
	    },
	    {
		"name": "Qatar",
		"codes": [
		    "QA",
		    "QAT",
		    "634",
		    "ISO 3166-2:QA"
		],
		"x": 19,
		"y": 10
	    },
	    {
		"name": "Romania",
		"codes": [
		    "RO",
		    "ROU",
		    "642",
		    "ISO 3166-2:RO"
		],
		"x": 17,
		"y": 6
	    },
	    {
		"name": "Russian Federation",
		"codes": [
		    "RU",
		    "RUS",
		    "643",
		    "ISO 3166-2:RU"
		],
		"x": 25,
		"y": 4
	    },
	    {
		"name": "Rwanda",
		"codes": [
		    "RW",
		    "RWA",
		    "646",
		    "ISO 3166-2:RW"
		],
		"x": 16,
		"y": 16
	    },
	    {
		"name": "St. Kitts & Nevis",
		"codes": [
		    "KN",
		    "KNA",
		    "659",
		    "ISO 3166-2:KN"
		],
		"x": 6,
		"y": 5
	    },
	    {
		"name": "St. Lucia",
		"codes": [
		    "LC",
		    "LCA",
		    "662",
		    "ISO 3166-2:LC"
		],
		"x": 7,
		"y": 5
	    },
	    {
		"name": "St. Vincent & the Grenadines",
		"codes": [
		    "VC",
		    "VCT",
		    "670",
		    "ISO 3166-2:VC"
		],
		"x": 7,
		"y": 6
	    },
	    {
		"name": "Samoa",
		"codes": [
		    "WS",
		    "WSM",
		    "882",
		    "ISO 3166-2:WS"
		],
		"x": 28,
		"y": 18
	    },
	    {
		"name": "Sao Tome and Principe",
		"codes": [
		    "ST",
		    "STP",
		    "678",
		    "ISO 3166-2:ST"
		],
		"x": 11,
		"y": 16
	    },
	    {
		"name": "Saudi Arabia",
		"codes": [
		    "SA",
		    "SAU",
		    "682",
		    "ISO 3166-2:SA"
		],
		"x": 19,
		"y": 9
	    },
	    {
		"name": "Senegal",
		"codes": [
		    "SN",
		    "SEN",
		    "686",
		    "ISO 3166-2:SN"
		],
		"x": 13,
		"y": 12
	    },
	    {
		"name": "Serbia",
		"codes": [
		    "RS",
		    "SRB",
		    "688",
		    "ISO 3166-2:RS"
		],
		"x": 16,
		"y": 7
	    },
	    {
		"name": "Seychelles",
		"codes": [
		    "SC",
		    "SYC",
		    "690",
		    "ISO 3166-2:SC"
		],
		"x": 18,
		"y": 17
	    },
	    {
		"name": "Sierra Leone",
		"codes": [
		    "SL",
		    "SLE",
		    "694",
		    "ISO 3166-2:SL"
		],
		"x": 12,
		"y": 13
	    },
	    {
		"name": "Singapore",
		"codes": [
		    "SG",
		    "SGP",
		    "702",
		    "ISO 3166-2:SG"
		],
		"x": 24,
		"y": 13
	    },
	    {
		"name": "Slovakia",
		"codes": [
		    "SK",
		    "SVK",
		    "703",
		    "ISO 3166-2:SK"
		],
		"x": 16,
		"y": 5
	    },
	    {
		"name": "Slovenia",
		"codes": [
		    "SI",
		    "SVN",
		    "705",
		    "ISO 3166-2:SI"
		],
		"x": 14,
		"y": 6
	    },
	    {
		"name": "Solomon Islands",
		"codes": [
		    "SB",
		    "SLB",
		    "090",
		    "ISO 3166-2:SB"
		],
		"x": 26,
		"y": 18
	    },
	    {
		"name": "Somalia",
		"codes": [
		    "SO",
		    "SOM",
		    "706",
		    "ISO 3166-2:SO"
		],
		"x": 18,
		"y": 14
	    },
	    {
		"name": "South Africa",
		"codes": [
		    "ZA",
		    "ZAF",
		    "710",
		    "ISO 3166-2:ZA"
		],
		"x": 16,
		"y": 20
	    },
	    {
		"name": "South Sudan",
		"codes": [
		    "SS",
		    "SSD",
		    "728",
		    "ISO 3166-2:SS"
		],
		"x": 15,
		"y": 13
	    },
	    {
		"name": "Spain",
		"codes": [
		    "ES",
		    "ESP",
		    "724",
		    "ISO 3166-2:ES"
		],
		"x": 12,
		"y": 6
	    },
	    {
		"name": "Sri Lanka",
		"codes": [
		    "LK",
		    "LKA",
		    "144",
		    "ISO 3166-2:LK"
		],
		"x": 22,
		"y": 11
	    },
	    {
		"name": "Sudan",
		"codes": [
		    "SD",
		    "SDN",
		    "729",
		    "ISO 3166-2:SD"
		],
		"x": 16,
		"y": 12
	    },
	    {
		"name": "Suriname",
		"codes": [
		    "SR",
		    "SUR",
		    "740",
		    "ISO 3166-2:SR"
		],
		"x": 7,
		"y": 11
	    },
	    {
		"name": "Swaziland",
		"codes": [
		    "SZ",
		    "SWZ",
		    "748",
		    "ISO 3166-2:SZ"
		],
		"x": 16,
		"y": 19
	    },
	    {
		"name": "Sweden",
		"codes": [
		    "SE",
		    "SWE",
		    "752",
		    "ISO 3166-2:SE"
		],
		"x": 16,
		"y": 1
	    },
	    {
		"name": "Switzerland",
		"codes": [
		    "CH",
		    "CHE",
		    "756",
		    "ISO 3166-2:CH"
		],
		"x": 14,
		"y": 5
	    },
	    {
		"name": "Syria",
		"codes": [
		    "SY",
		    "SYR",
		    "760",
		    "ISO 3166-2:SY"
		],
		"x": 19,
		"y": 7
	    },
	    {
		"name": "Tajikistan",
		"codes": [
		    "TJ",
		    "TJK",
		    "762",
		    "ISO 3166-2:TJ"
		],
		"x": 23,
		"y": 7
	    },
	    {
		"name": "Tanzania",
		"codes": [
		    "TZ",
		    "TZA",
		    "834",
		    "ISO 3166-2:TZ"
		],
		"x": 17,
		"y": 16
	    },
	    {
		"name": "Thailand",
		"codes": [
		    "TH",
		    "THA",
		    "764",
		    "ISO 3166-2:TH"
		],
		"x": 24,
		"y": 10
	    },
	    {
		"name": "Timor-Leste",
		"codes": [
		    "TL",
		    "TLS",
		    "626",
		    "ISO 3166-2:TL"
		],
		"x": 25,
		"y": 14
	    },
	    {
		"name": "Togo",
		"codes": [
		    "TG",
		    "TGO",
		    "768",
		    "ISO 3166-2:TG"
		],
		"x": 14,
		"y": 14
	    },
	    {
		"name": "Tonga",
		"codes": [
		    "TO",
		    "TON",
		    "776",
		    "ISO 3166-2:TO"
		],
		"x": 28,
		"y": 19
	    },
	    {
		"name": "Trinidad & Tobago",
		"codes": [
		    "TT",
		    "TTO",
		    "780",
		    "ISO 3166-2:TT"
		],
		"x": 7,
		"y": 9
	    },
	    {
		"name": "Tunisia",
		"codes": [
		    "TN",
		    "TUN",
		    "788",
		    "ISO 3166-2:TN"
		],
		"x": 14,
		"y": 11
	    },
	    {
		"name": "Turkey",
		"codes": [
		    "TR",
		    "TUR",
		    "792",
		    "ISO 3166-2:TR"
		],
		"x": 18,
		"y": 7
	    },
	    {
		"name": "Turkmenistan",
		"codes": [
		    "TM",
		    "TKM",
		    "795",
		    "ISO 3166-2:TM"
		],
		"x": 22,
		"y": 7
	    },
	    {
		"name": "Tuvalu",
		"codes": [
		    "TV",
		    "TUV",
		    "798",
		    "ISO 3166-2:TV"
		],
		"x": 27,
		"y": 18
	    },
	    {
		"name": "Uganda",
		"codes": [
		    "UG",
		    "UGA",
		    "800",
		    "ISO 3166-2:UG"
		],
		"x": 16,
		"y": 15
	    },
	    {
		"name": "Ukraine",
		"codes": [
		    "UA",
		    "UKR",
		    "804",
		    "ISO 3166-2:UA"
		],
		"x": 17,
		"y": 5
	    },
	    {
		"name": "United Arab Emirates",
		"codes": [
		    "AE",
		    "ARE",
		    "784",
		    "ISO 3166-2:AE"
		],
		"x": 20,
		"y": 10
	    },
	    {
		"name": "Great Britain and Northern Ireland",
		"codes": [
		    "GB",
		    "GBR",
		    "826",
		    "ISO 3166-2:GB"
		],
		"x": 11,
		"y": 4
	    },
	    {
		"name": "United States of America",
		"codes": [
		    "US",
		    "USA",
		    "840",
		    "ISO 3166-2:US"
		],
		"x": 1,
		"y": 2
	    },
	    {
		"name": "Uruguay",
		"codes": [
		    "UY",
		    "URY",
		    "858",
		    "ISO 3166-2:UY"
		],
		"x": 7,
		"y": 12
	    },
	    {
		"name": "Uzbekistan",
		"codes": [
		    "UZ",
		    "UZB",
		    "860",
		    "ISO 3166-2:UZ"
		],
		"x": 22,
		"y": 6
	    },
	    {
		"name": "Vanuatu",
		"codes": [
		    "VU",
		    "VUT",
		    "548",
		    "ISO 3166-2:VU"
		],
		"x": 26,
		"y": 19
	    },
	    {
		"name": "Venezuela",
		"codes": [
		    "VE",
		    "VEN",
		    "862",
		    "ISO 3166-2:VE"
		],
		"x": 6,
		"y": 9
	    },
	    {
		"name": "Viet Nam",
		"codes": [
		    "VN",
		    "VNM",
		    "704",
		    "ISO 3166-2:VN"
		],
		"x": 26,
		"y": 9
	    },
	    {
		"name": "Yemen",
		"codes": [
		    "YE",
		    "YEM",
		    "887",
		    "ISO 3166-2:YE"
		],
		"x": 18,
		"y": 11
	    },
	    {
		"name": "Zambia",
		"codes": [
		    "ZM",
		    "ZMB",
		    "894",
		    "ISO 3166-2:ZM"
		],
		"x": 14,
		"y": 18
	    },
	    {
		"name": "Zimbabwe",
		"codes": [
		    "ZW",
		    "ZWE",
		    "716",
		    "ISO 3166-2:ZW"
		],
		"x": 16,
		"y": 18
	    }
	]
    })}




const ID_BASEMAP = "basemap";
function RamaddaBasemapDisplay(displayManager, id, type, properties) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    let myProps = [
	{label:'Base map properties'},
	{p:'regionField',ex:''},
	{p:'valueField',ex:''},
	{p:'mapFile',ex:'usmap.json|countries.json',d:"usmap.json"},
	{p:'skipRegions',ex:'Alaska,Hawaii'},
	{p:'pruneMissing',ex:'true'},				
	{p:'mapBackground',ex:'transparent'},
	{p:'transforms',ex:"Alaska,0.4,30,-40;Hawaii,2,50,5;Region,scale,offsetX,offsetY"},
	{p:'prunes',ex:'Alaska,100;Region,maxCount'},
	{p:'mapWidth',ex:'600'},
	{p:'mapHeight',ex:'400'},
	{p:'maxLon'},
	{p:'minLon'},
	{p:'maxLat'},
	{p:'minLat'},			
	{p:"strokeColor"},
	{p:"strokeWidth"},
	{p:"highlightStrokeColor"},
	{p:"highlightStrokeWidth"},
	{p:"highlightFill"},
	{p:"missingFill"},			
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        checkLayout: function() {
            this.updateUI();
        },
        makeMap: function() {
	},
	makePoly:function(polygon) {
	    let poly = [];
	    polygon.forEach(point=>{
		let lon = point[0];
		let lat = point[1];
		if(isNaN(lon) || isNaN(lat)) return;
		poly.push({x:lon,y:lat});
	    });
	    return poly;
	},
	findValues:function(region, valueMap) {
	    if(valueMap[region]) return valueMap[region];
	    let values = null;
	    if(!this.aliasMap[region]) {
		return null;
	    }
	    this.aliasMap[region].forEach(alias=>{
		if(valueMap[alias]) values = valueMap[alias];
	    });
	    return values;
	},
	makeValueMap: function(records,needsValue) {
	    let regionField=this.getFieldById(null,this.getPropertyRegionField());
	    let valueField=this.getFieldById(null,this.getPropertyValueField());	    
	    if(!regionField) {
                this.displayError("No region field specified");
		return null
	    }
	    if(!valueField && needsValue) {
                this.displayError("No value field specified");
		return null
	    }	    
	    if(valueField) {
		if(this.getProperty("colorBy")==null) this.setProperty("colorBy",valueField.getId());
		if(this.getProperty("sizeBy")==null) this.setProperty("sizeBy",valueField.getId());	    
	    }
	    let valueMap = {};
	    this.valueRange = {
		min: null,
		max:null
	    };
	    this.idToRecord = {};
	    records.forEach(record=>{
		let region = record.getValue(regionField.getIndex());
		this.idToRecord[record.getId()] = record;
		let values  = valueMap[region] = {
		    record:record
		}
		if(valueField) { 
		    let value = record.getValue(valueField.getIndex());
		    values.value = value;
		    this.valueRange.min = this.valueRange.min===null?value:Math.min(value,this.valueRange.min);
		    this.valueRange.max = this.valueRange.max===null?value:Math.max(value,this.valueRange.max);
		}
	    });
	    if(valueField) {
		records.forEach(record=>{
		    let region = record.getValue(regionField.getIndex());
		    let values  = valueMap[region];
		    let value = values.value
		    let percent = (value-this.valueRange.min)/(this.valueRange.max-this.valueRange.min);
		    values.percent = percent;
		});
	    }
	    return valueMap;
	},
	writeMap:function(skipHeight)  {
	    let width = this.getMapWidth(this.getProperty("width",800));
	    let css = HU.css(BACKGROUND,this.getMapBackground("transparent"),WIDTH,HU.getDimension(width));
	    let height;
	    if(!skipHeight) {
		height = this.getMapHeight(this.getProperty("height"));
		let mw = this.mapRange.maxLon-this.mapRange.minLon;
		let mh = this.mapRange.maxLat-this.mapRange.minLat;
		if(!height)
		    height = mh/mw*width;
		if(isNaN(height)) height=400; 
		css+=HU.css(HEIGHT,HU.getDimension(height));
	    }
	    
	    this.mapRange.maxLon= this.getPropertyMaxLon(this.mapRange.maxLon);
	    this.mapRange.minLon= this.getPropertyMinLon(this.mapRange.minLon);
	    this.mapRange.maxLat= this.getPropertyMaxLat(this.mapRange.maxLat);
	    this.mapRange.minLat= this.getPropertyMinLat(this.mapRange.minLat);	    	    
	    this.setContents(HU.div([ID,this.domId(ID_BASEMAP),STYLE,css]));
	    if(isNaN(width)) {
		width = this.getContents().width();
	    }
	    return [width,height];

	},
	makeSvg: function(width,height) {
	    const svg = d3.select("#" + this.domId(ID_BASEMAP)).append('svg')
		  .attr('width', width)
		  .attr('height', height)
		  .append('g')
	    let padx = 0;
	    let pady = padx;
	    let scaleX  = d3.scaleLinear().domain([this.mapRange.minLon, this.mapRange.maxLon]).range([padx, width-padx]);
	    let scaleY  = d3.scaleLinear().domain([this.mapRange.maxLat, this.mapRange.minLat]).range([pady, height-pady]);
	    return [svg,scaleX,scaleY];
	},

	clearTooltip: function() {
	    if(this.tooltipDiv)
		this.tooltipDiv.style("opacity", 0);
	},
	makeTooltipDiv: function() {
	    if(!this.tooltipDiv) {
		this.tooltipDiv = d3.select("body").append("div")
		    .attr("class", "ramadda-shadow-box  display-tooltip")
		    .style("opacity", 0)
		    .style("position", "absolute")
		    .style("background", "#fff")
	    }
	    this.clearTooltip();
	    return this.tooltipDiv;
	},
	addEvents:function(polys, idToRecord, tooltipDiv) {
	    idToRecord  = idToRecord|| this.idToRecord;
	    tooltipDiv = tooltipDiv || this.makeTooltipDiv();
	    let _this = this;
	    let tooltip = this.getProperty("tooltip");
	    polys.on('click', function (d, i) {
		let poly = d3.select(this);
		let record = idToRecord[poly.attr(RECORD_ID)];
		if(record)
		    _this.propagateEventRecordSelection({record: record});
	    });
	    polys.on('mouseover', function (d, i) {
		let poly = d3.select(this);
		let record = idToRecord[poly.attr(RECORD_ID)];
		poly.attr("lastStroke",poly.attr("stroke"))
		    .attr("lastFill",poly.attr("fill"));
		poly.attr("stroke",_this.getPropertyHighlightStrokeColor("blue")).attr("stroke-width",_this.getPropertyHighlightStrokeWidth(1))
		    .attr("fill",_this.getPropertyHighlightFill("blue"));
		if(!tooltip) return;
		let regionName = poly.attr("regionName");
		let tt = null;
		if(!record) {
		    tt = regionName;
		    console.log("no record found for region:" +regionName);
		} else {
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		    tt =  _this.getRecordHtml(record,null,tooltip);
		}
		if(tt) {
		    _this.tooltipDiv.html(tt)
			.style("left", (d3.event.pageX + 10) + "px")
			.style("top", (d3.event.pageY + 20) + "px");
		    _this.tooltipDiv.style("opacity", 1);
		    //For now don't transition as it seems to screw up
		    //subsequent mouse overs
		    return;
		    _this.tooltipDiv.transition()
			.delay(500)
			.duration(500)
			.style("opacity", 1);
		}
	    });
	    polys.on('mouseout', function (d, i) {
//		_this.tooltipDiv.transition();
		let poly = d3.select(this);
		poly.attr("stroke",poly.attr("lastStroke"))
		    .attr("fill",poly.attr("lastFill"))
		    .attr("stroke-width",1);
		_this.tooltipDiv.style("opacity", 0);
	    });
	},
        updateUI: function() {
	    this.clearTooltip();
	    if(!this.mapJson) {
		if(!this.gettingFile) {
		    this.gettingFile = true;
		    let mapFile = this.getPropertyMapFile();
		    if(!mapFile.startsWith("/") && !mapFile.startsWith("http")) {
			mapFile =ramaddaBaseUrl +"/resources/" + mapFile;
		    }
		    var jqxhr = $.getJSON(mapFile, (data) =>{
			this.mapJson = data;
			this.regionNames=[];
			this.makeRegions();
			this.updateUI();
		    });
		}
		return;
	    }
	    if(!this.regions) {
		if(!this.makeRegions()) return;
	    }
	    this.makeMap();
	},
	makeRegions:function() {
	    let debug = this.getProperty("debug");
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let allRegions = {};
	    if(this.getData()==null) {
		return false;
	    }
	    let allRecords = this.getData().getRecords()
	    let regionField=this.getFieldById(null,this.getPropertyRegionField());
	    if(regionField==null) {
		this.displayError("No region field");
		return false;
	    }
	    allRecords.forEach(record=>{
		let v = record.getValue(regionField.getIndex());
//		console.log("data region:" + v);
		allRegions[v] = true;
	    });
	    this.regions = {};
	    this.mapRange  = {
		minLon:null,
		maxLon:null,
		minLat:null,
		maxLat:null
	    };
	    let transforms = {}
	    let prunes = {}	    
	    this.getPropertyTransforms("").split(";").map(t=>t.split(",")).forEach(tuple=>{
		let region = tuple[0];
		transforms[region] = {
		    scale:tuple[1]!=null?+tuple[1]:1,
		    dx:tuple[2]!=null?+tuple[2]:0,
		    dy:tuple[3]!=null?+tuple[3]:0}
	    });

	    this.getPropertyPrunes("").split(";").map(t=>t.split(",")).forEach(tuple=>{
		let region = tuple[0];
		prunes[region] =  +tuple[1];
	    });

	    let tfunc=(region,polygon)=>{
		let prune = prunes[region];
		if(prune>0) {
		    if(polygon.length<prune) return null;
		}

		let transform = transforms[region];
		if(!transform) 
		    return polygon;
		let bounds = Utils.getBounds(polygon);
		let centerx = bounds.minx + (bounds.maxx-bounds.minx)/2;
		let centery = bounds.miny + (bounds.maxy-bounds.miny)/2;		
		polygon.map(pair=>{
		    pair[0]= (pair[0]-centerx)*transform.scale+centerx;
		    pair[1]= (pair[1]-centery)*transform.scale+centery;		    		    
		    pair[0] += transform.dx;
		    pair[1] += transform.dy;
		    return pair;
		});
		return polygon;		
	    };
	    
	    this.skipRegions = this.getPropertySkipRegions("").split(",").map(r=>r.replace(/_comma_/g,","));
	    let features = this.mapJson.geojson;
	    if(!features)
		features = this.mapJson.features;

	    this.aliasMap = {};
	    features.forEach(blob=>{
		let region = blob.properties.name || blob.properties.name_long || blob.properties.NAME || blob.properties.ADMIN; 
		let aliases = [region];
		//Some hacks
		if(region=="United States of America") aliases.push("United States");
		if(region=="United Republic of Tanzania") aliases.push("Tanzania");
		if(region=="Democratic Republic of the Congo") aliases.push("Democratic Republic of Congo");
		if(region=="Czech Rep.") aliases.push("Czech Republic");
		if(region=="Bosnia and Herz.") aliases.push("Bosnia and Herzegovina");
		this.aliasMap[region] = aliases;
		if(blob.properties.ISO_A3)
		    aliases.push(blob.properties.ISO_A3);
		if(blob.properties.STUSPS)
		    aliases.push(blob.properties.STUSPS);
		if(blob.properties.STATEFP)
		    aliases.push(blob.properties.STATEFP);		
		if(!blob.geometry) {
		    if(debug)
			console.log(region +" no geometry");
		    return;
		}
		if(debug)
		    console.log("region:" + region);
		let ok = true;
		aliases.forEach(alias=>{
		    if(this.skipRegions.includes(alias)) ok = false;});
		if(!ok) {
		    return;
		}
		ok = false;
		aliases.forEach(alias=>{
		    if(allRegions[alias]) {
			ok =true;
		    }});
		if(!ok) console.log("Missing data for map region:" + region);
		if(pruneMissing && !ok) return;
		this.regionNames.push(region);
		let coords = blob.geometry.coordinates;
		let info = {
		    name:region,
		    aliases: aliases,
		    polygons:[],
		    bounds:null
		};
		aliases.forEach(alias=>{
		    this.regions[alias] = info;
		});
		if(blob.geometry.type  == "MultiPolygon") {
		    coords.forEach(group=>{
			group.forEach(polygon=>{
			    polygon  = tfunc(region,polygon);
			    if(polygon)info.polygons.push(polygon);
			});
		    });
		} else {
		    coords.forEach(polygon=>{
			info.polygons.push(tfunc(region,polygon));
		    });
		}
		info.polygons.forEach(polygon=>{
		    polygon.forEach(point=>{
			let lon = point[0];
			let lat = point[1];
			if(isNaN(lon) || isNaN(lat)) return;
			this.mapRange.minLon= this.mapRange.minLon===null?lon:Math.min(this.mapRange.minLon,lon);
			this.mapRange.maxLon= this.mapRange.maxLon===null?lon:Math.max(this.mapRange.maxLon,lon);
			this.mapRange.minLat= this.mapRange.minLat===null?lat:Math.min(this.mapRange.minLat,lat);
			this.mapRange.maxLat= this.mapRange.maxLat===null?lat:Math.max(this.mapRange.maxLat,lat);						
		    });
		});
		let bounds = null;
		info.polygons.forEach(polygon=>{
		    bounds = Utils.mergeBounds(bounds, Utils.getBounds(polygon));
		});
		info.bounds = bounds;
	    });
	    return true;
	},
	
    });
}


function RamaddaMapchartDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPCHART, properties);
    let myProps = [
	{label:'Map chart Properties'},
	{p:'maxLayers',ex:'10'},
	{p:'translateX',ex:'0'},
	{p:'translateY',ex:'0'},	
	{p:'skewX',ex:'-10'},
	{p:'skewY',ex:'0'},	
	{p:'rotate',ex:'10'},
	{p:'scale',ex:'0'},
	{p:'fillColor',ex:'red'},
	{p:'blur',ex:'4'},			
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let allRecords = this.getData().getRecords()
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let maxLayers = +this.getPropertyMaxLayers(20);
	    Object.keys(valueMap).forEach(region=>{
		let values = valueMap[region];
		values.layers = Math.round(values.percent*(maxLayers-1))+1;
	    });
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);
	    SU.transform(svg,SU.translate(width/2, height/2), SU.scale(0.9), SU.rotate(this.getPropertyRotate(0)), SU.translate(-width/2,-height/2), SU.translate(this.getPropertyTranslateX(30),this.getPropertyTranslateY(0)), SU.skewX(this.getPropertySkewX(-10)), SU.scale(this.getPropertyScale(1)));
	    var defs = svg.append("defs");
	    SU.makeBlur(svg,"blur", this.getPropertyBlur(3));
	    for(let layer=0;layer<maxLayers;layer++) {
		this.regionNames.forEach(region=>{
		    let values= this.findValues(region, valueMap);
		    let maxLayer = 1;
		    let value = NaN;
		    let missing = values==null;
		    let record = null;
		    if(!missing) {
			maxLayer = values.layers;
			value = values.value;
			record = values.record;
		    } else {
			if(pruneMissing) return;
			maxLayer = 1;
			if(layer>0) return;
		    }
		    let recordId = record?record.getId():"";
		    if(!Utils.isDefined(maxLayer)) maxLayer = 1;
		    if(layer>maxLayer) return;
		    this.regions[region].polygons.forEach(polygon=>{
			let uid = HtmlUtils.getUniqueId();
			let poly = this.makePoly(polygon);
			let fillColor = "transparent";
			if(missing) {
			    fillColor = "#ccc";
			    lineColor="#000" 
			} else {
			    if(layer==maxLayer-1) {
				fillColor = this.colorBy.getColor(value);
				lineColor  = Utils.pSBC(0.1,fillColor);
			    } else {
				lineColor  = Utils.pSBC(-0.3,this.colorBy.getColor(value));
			    }
			}
			if(missing) {
			    svg.selectAll(region+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
				.attr("regionName",region)
				.attr("fill","#ccc")
		    		.attr("stroke-width",1)
			    	.attr("stroke","black");
			    return;
			}
			if(layer==0) {
			    svg.selectAll(region+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
		    		.attr("stroke-width",3)
				.attr("stroke","black")
				.style("filter","url(#blur)");
			}
			let polys = 
			    svg.selectAll(region+uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill",fillColor)
			    .attr("opacity",1)
			    .attr("stroke",lineColor)
			    .attr("stroke-width",1)
			    .style("cursor", "pointer")
			    .attr(RECORD_ID,recordId);
			this.addEvents(polys);
		    });
		});
	    }
	    this.colorBy.displayColorTable();
	}
    });
}



function RamaddaMaparrayDisplay(displayManager, id, properties) {
    const ID_MAPBLOCK = "mapblock";
    const ID_MAPLABEL = "maplabel";        
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPARRAY, properties);
    let myProps = [
	{label:'Map array properties'},
	{p:'blockWidth',ex:''},
	{p:'sortByValue',ex:'true'},
	{p:'fillColor',ex:'red'},
	{p:'showValue',ex:'true'},	
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let allRecords = this.getData().getRecords()
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap(true);
	    let blockWidth= this.getPropertyBlockWidth(75);
	    let blockHeight= blockWidth;
	    let pruneMissing = this.getPropertyPruneMissing(true);
	    let sortedRegions = this.regionNames;
	    if(this.getPropertySortByValue(true)) {
		sortedRegions.sort((a,b)=>{
		    return valueMap[a].value-valueMap[b].value;
		});
	    } else {
		sortedRegions.sort();
	    }

	    let html = "";
	    sortedRegions.forEach((region,idx)=>{
		html+= HU.div([CLASS,"display-maparray-block"],
			      HU.div([CLASS,"display-maparray-header"],region) +
			      HU.div([ID,this.domId(ID_MAPBLOCK+"_"+idx),CLASS,"display-maparray-map",STYLE,HU.css(WIDTH,blockWidth+"px",HEIGHT,blockHeight+"px")]) +
			      HU.div([ID,this.domId(ID_MAPLABEL+"_"+idx),"display-maparray-label"]));			      


		    
	    });
	    this.jq(ID_BASEMAP).html(html+"<p>");

	    let showValue = this.getPropertyShowValue(true);

	    sortedRegions.forEach((region,idx)=>{
		let info = this.regions[region];
		let svg = d3.select("#" + this.domId(ID_MAPBLOCK+"_"+idx)).append('svg')
		    .attr('width', blockWidth)
		    .attr('height', blockHeight)
		    .append('g')
		let padx=5;
		let pady=5;
		let mapWidth = info.bounds.getWidth();
		let mapHeight = info.bounds.getHeight();
		let scaleX;
		let scaleY;
		if(mapWidth>mapHeight) {
		    scaleX= d3.scaleLinear().domain([info.bounds.minx, info.bounds.maxx]).range([0, blockWidth-padx]);
		    scaleY= d3.scaleLinear().domain([info.bounds.maxy, info.bounds.miny]).range([0, (mapHeight/mapWidth)*blockHeight-pady]);
		} else {
		    scaleX= d3.scaleLinear().domain([info.bounds.minx, info.bounds.maxx]).range([0, (mapWidth/mapHeight)*blockWidth-padx]);
		    scaleY= d3.scaleLinear().domain([info.bounds.maxy, info.bounds.miny]).range([0, blockHeight-pady]);
		}
		let values = valueMap[region];
		let value = NaN;
		let missing = values==null;
		let record = null;
		if(!missing) {
		    value = values.value;
		    record = values.record;
		    if(showValue) {
			this.jq(ID_MAPLABEL+"_"+idx).html(value);
		    }
		} else {
		    if(pruneMissing) return;
		}

		let recordId = record?record.getId():"";
		info.polygons.forEach(polygon=>{
		    let uid = HtmlUtils.getUniqueId();
		    let poly = this.makePoly(polygon);
		    let fillColor = "transparent";
		    if(missing) {
			fillColor = "#ccc";
			lineColor="#000" 
		    } else {
			fillColor = this.colorBy.getColor(value);
			lineColor = "#ccc";
		    }
		    if(missing) {
			svg.selectAll(region+uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill","#ccc")
		    	    .attr("stroke-width",1)
			    .attr("stroke","black");
			return;
		    }
		    let polys = 
			svg.selectAll(region+uid)
			.data([poly])
			.enter().append("polygon")
			.attr("points",function(d) { 
			    return d.map(d=>{return [+scaleX(d.x),+scaleY(d.y)].join(",");}).join(" ");
			})
			.attr("fill",fillColor)
			.attr("opacity",1)
			.attr("stroke",lineColor)
			.attr("stroke-width",1)
			.style("cursor", "pointer")
			.attr(RECORD_ID,recordId);
		    this.addEvents(polys);
		});
	    });
	    this.colorBy.displayColorTable();
	}
    });
}




function RamaddaMapshrinkDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPSHRINK, properties);
    let myProps = [
	{label:'Map shrink Properties'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    let allRecords = this.getData().getRecords()
	    let pruneMissing = this.getPropertyPruneMissing(false);
	    let valueMap = this.makeValueMap(records,true);
	    if(!valueMap) return;
	    let sizeBy = new SizeBy(this, allRecords);
	    this.colorBy = this.getColorByInfo(allRecords);
	    let [width,height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);

	    for(let layer=0;layer<2;layer++) {
		this.regionNames.forEach(region=>{
		    let values= this.findValues(region, valueMap);
		    let value = NaN;
		    let missing = values==null;
		    let record = null;
		    if(!missing) {
			value = values.value;
			record = values.record;
		    } else {
			if(pruneMissing) return;
			if(layer>0) return;
		    }
		    let recordId = record?record.getId():"";
		    this.regions[region].polygons.forEach(polygon=>{
			let uid = HtmlUtils.getUniqueId();
			let poly = this.makePoly(polygon);
			let fillColor = "red";
			let transform  = "";
			lineColor="#000" 
			if(layer==0) {
			    fillColor = "#fff";
			} else {
			    lineColor="transparent" 
			    fillColor = this.colorBy.getColor(value);
			    let bounds = Utils.getBounds(polygon);
			    let center = bounds.getCenter();
			    let p=0;
			    let sizeByFunc = function(p, size) {
				percent = p;
				return percent;
			    }
			    sizeBy.getSizeFromValue(value,sizeByFunc);
			    transform = SU.translate(scaleX(center.x),scaleY(center.y)) + SU.scale(percent) + SU.translate(-scaleX(center.x),-scaleY(center.y))
			}
			if(missing) {
			    svg.selectAll(region+"base"+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
				})
				.attr("fill","#ccc")
		    		.attr("stroke-width",1)
			    	.attr("stroke","black");
			    return;
			}
			if(layer==0) {
			    svg.selectAll(region+"base"+uid)
				.data([poly])
				.enter().append("polygon")
				.attr("points",function(d) { 
				    return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(","); }).join(" ");
				})
		    		.attr("stroke-width",1)
				.attr("stroke","black")
				.attr('transform',transform);
			}
			let polys = 
			    svg.selectAll(region+uid)
			    .data([poly])
			    .enter().append("polygon")
			    .attr("points",function(d) { 
				return  d.map(d=>{return [-layer+scaleX(d.x),-layer+scaleY(d.y)].join(",");}).join(" ");
			    })
			    .attr("fill",fillColor)
			    .attr("opacity",1)
			    .attr("stroke",lineColor)
			    .attr("stroke-width",1)
			    .attr('transform',transform)
			    .style("cursor", "pointer")
			    .attr(RECORD_ID,recordId);
			if(layer==1)
			    this.addEvents(polys);
		    });
		});
	    }
	    this.colorBy.displayColorTable();
	}
    });
}


function RamaddaMapimagesDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaBasemapDisplay(displayManager, id, DISPLAY_MAPIMAGES, properties);
    let myProps = [
	{label:'Map Images Properties'},
	{p:'imageField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getHeightForStyle: function(dflt) {
	    return null;
	},
	addMacroAttributes:function(macros,row,attrs) {
	    SUPER.addMacroAttributes.call(this,macros,row,attrs);
	    if(!this.imageField) return;
	    let f = this.imageField;
	    let value = row[f.getIndex()];
	    let imageAttrs = [];
	    let tokenAttrs  = macros.getAttributes("imageField_image");
	    let width = tokenAttrs?tokenAttrs["width"]:null;
	    if(width) {
		imageAttrs.push("width");
		imageAttrs.push(width);
	    } else if(this.getProperty("imageWidth")) {
		imageAttrs.push("width");
		imageAttrs.push(this.getProperty("imageWidth")); 
	    } else  {
		imageAttrs.push("width");
		imageAttrs.push("100%");
	    }
	    imageAttrs.push("style");
	    imageAttrs.push("vertical-align:top");
	    let img =  HU.image(value, imageAttrs);
	    attrs["imageField" +"_image"] =  img;
	    attrs["imageField" +"_url"] =  value;
	},
        makeMap: function() {
            let records = this.filterData();
            if (!records) {
                return;
            }
	    this.imageField = this.getFieldById(null,this.getPropertyImageField());	    
	    if(this.imageField == null) {
		this.imageField =  this.getFieldByType(null, "image");
	    }
	    if(this.imageField==null) {
                this.displayError("No image fields");
		return
	    }
	    let valueMap = this.makeValueMap(records);
	    if(!valueMap) return;
	    Object.keys(valueMap).forEach(region=>{
		let values = valueMap[region];
		values.image = values.record.getValue(this.imageField.getIndex());
	    });
	    let [width, height] = this.writeMap();
	    let [svg, scaleX, scaleY] = this.makeSvg(width,height);
	    var defs = svg.append("defs");
	    this.regionNames.forEach((region,idx)=>{
		let values= this.findValues(region, valueMap);
		let recordId = values!=null?values.record.getId():"";
		this.regions[region].polygons.forEach(polygon=>{
		    let uid = HtmlUtils.getUniqueId();
		    if(values!=null) {
			defs.append("svg:pattern")
			    .attr("id", "bgimage"+ uid)
			    .attr("x", "1")
			    .attr("y", "1")
			    .attr("width", "100%")
		            .attr("height", "100%")
			    .attr("patternContentUnits","objectBoundingBox")
			    .append("svg:image")
			    .attr("xlink:href", values.image)
			    .attr("preserveAspectRatio","none")
			    .attr("width", 1)
			    .attr("height", 1)
			    .attr("x", "0")
			    .attr("y", "0");
		    }
		    let polys = svg.selectAll(region+"base"+uid)
			.data([this.makePoly(polygon)])
			.enter().append("polygon")
			.attr("regionName",region)
			.attr("points",function(d) { 
			    return d.map(d=>{return [scaleX(d.x),scaleY(d.y)].join(",");}).join(" ");
			})
			.attr(RECORD_ID,recordId)
		    	.attr("stroke-width",this.getPropertyStrokeWidth(1))
			.attr("stroke",this.getPropertyStrokeColor("#000"));
		    if(values!=null)
			polys.style("fill", "url(#bgimage"+ uid+")")
		    else
			polys.style("fill",this.getPropertyMissingFill("#fff"));
		    this.addEvents(polys);
		});
	    });
	}
    });
}
/*
  Copyright 2008-2019 Geode Systems LLC
*/

const DISPLAY_GRAPH = "graph";
const DISPLAY_TREE = "tree";
const DISPLAY_ORGCHART = "orgchart";
const DISPLAY_TIMELINE = "timeline";
const DISPLAY_HOURS = "hours";
const DISPLAY_BLANK = "blank";
const DISPLAY_PRE = "pre";
const DISPLAY_HTMLTABLE = "htmltable";
const DISPLAY_RECORDS = "records";
const DISPLAY_TSNE = "tsne";
const DISPLAY_HEATMAP = "heatmap";
const DISPLAY_CROSSTAB = "crosstab";
const DISPLAY_CORRELATION = "correlation";
const DISPLAY_RANKING = "ranking";
const DISPLAY_STATS = "stats";
const DISPLAY_COOCCURENCE = "cooccurence";
const DISPLAY_BOXTABLE = "boxtable";
const DISPLAY_DATATABLE = "datatable";
const DISPLAY_PERCENTCHANGE = "percentchange";
const DISPLAY_SPARKLINE = "sparkline";
const DISPLAY_POINTIMAGE = "pointimage";
const DISPLAY_CANVAS = "canvas";
const DISPLAY_FIELDTABLE = "fieldtable";
const DISPLAY_DATEGRID = "dategrid";

addGlobalDisplayType({
    type: DISPLAY_RANKING,
    label: "Ranking",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Show fields ordered by values","ranking.png")                            
});
addGlobalDisplayType({
    type: DISPLAY_CORRELATION,
    label: "Correlation",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip(null,"correlation.png")                            
});
addGlobalDisplayType({
    type: DISPLAY_CROSSTAB,
    label: "Crosstab",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Cross Tabulation","crosstab.png")                                
});

addGlobalDisplayType({
    type: DISPLAY_STATS,
    label: "Stats Table",
    requiresData: false,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Statistical Summary","stats.png"),
});
addGlobalDisplayType({
    type: DISPLAY_RECORDS,
    label: "Records",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Displays records as text","records.png")
});
addGlobalDisplayType({
    type: DISPLAY_TSNE,
    label: "TSNE",
    requiresData: true,
    forUser: false,
    category: CATEGORY_MISC
});
addGlobalDisplayType({
    type: DISPLAY_HEATMAP,
    label: "Heatmap",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Table showing colored fields","heatmap.png"),    
});
addGlobalDisplayType({
    type: DISPLAY_GRAPH,
    label: "Graph",
    requiresData: true,
    forUser: true,
    category: CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Display a force-directed graph","graph.png")
});

addGlobalDisplayType({
    type: DISPLAY_PERCENTCHANGE,
    label: "Percent Change",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Percent Change","percentchange.png","Show percent change over a given time in a text template")    
});

addGlobalDisplayType({
    type: DISPLAY_SPARKLINE,
    label: "Sparkline",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Embed little sparkline plots in text","sparkline.png"),    
});

addGlobalDisplayType({
    type: DISPLAY_CANVAS,
    label: "Canvas",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Draw records into a canvas","canvas.png"),        
});

addGlobalDisplayType({
    type: DISPLAY_POINTIMAGE,
    label: "Point Image",
    requiresData: true,
    forUser: true,
    category: CATEGORY_IMAGES,
    tooltip: makeDisplayTooltip("Embed 2D images into text","pointimage.png"),            
});
addGlobalDisplayType({
    type: DISPLAY_FIELDTABLE,
    label: "Field Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip(null,"fieldtable.png"),
});
addGlobalDisplayType({
    type: DISPLAY_TREE,
    forUser: true,
    label: "Tree",
    requiresData: false,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"tree.png")                                    
});

addGlobalDisplayType({
    type: DISPLAY_ORGCHART,
    label: "Org Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"orgchart.png")                                
});

addGlobalDisplayType({
    type: DISPLAY_TIMELINE,
    label: "Timeline",
    requiresData: true,
    forUser: true,
    category:  CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Timeline showing text and images","timeline.png")
});
addGlobalDisplayType({
    type: DISPLAY_HOURS,
    label: "Hours",
    requiresData: true,
    forUser: true,
    category:  CATEGORY_MISC,
    tooltip: makeDisplayTooltip("Hourly timeline","timeline.png","Show data by the day and hour")    
});
addGlobalDisplayType({
    type: DISPLAY_BLANK,
    label: "Blank",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CONTROLS,
    tooltip: makeDisplayTooltip("Shows no data",null,"Useful for just showing filters, etc")                                                
});
addGlobalDisplayType({
    type: DISPLAY_PRE,
    label: "Preformat",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Shows records in an HTML PRE tag",null,"Useful for looking at the data")                                                
});
addGlobalDisplayType({
    type: DISPLAY_HTMLTABLE,
    label: "HTML Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Shows records in an HTML table",null,"Useful for looking at the data")                                                    
});
addGlobalDisplayType({
    type: DISPLAY_COOCCURENCE,
    label: "Cooccurence",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Cooccurence Table","cooccurrence.png","Tabular plot showing number of records that share values from two fields"),    

});
addGlobalDisplayType({
    type: DISPLAY_BOXTABLE,
    label: "Box Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Box Table","boxtable.png","Shows number of records that share the same category field value"),    
});
addGlobalDisplayType({
    type: DISPLAY_DATATABLE,
    label: "Data Table",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Data Table",["datatable1.png","datatable2.png"],"Selectable record grouping. Can be colored or show pie charts"),        
});
addGlobalDisplayType({
    type: DISPLAY_DATEGRID,
    label: "Date Grid",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TABLE,
    tooltip: makeDisplayTooltip("Date Grid",["dategrid.png"],"Show records grouped by category and date"),        
});





function RamaddaGraphDisplay(displayManager, id, properties) {
    const ID_GRAPH = "graph";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_GRAPH, properties);
    if(!window["ForceGraph"]) {
	Utils.importJS("https://unpkg.com/force-graph");
    }
    let myProps = [
	{label:'Graph'},
	 {p:'sourceField',ex:''},
	 {p:'targetField',ex:''},
	 {p:'nodeBackground',ex:'#ccc'},
	 {p:'drawCircle',ex:'true'},
	 {p:'nodeWidth',ex:'10'},
	 {p:'linkColor',ex:'red'},
	 {p:'linkWidth',ex:'3'},
	 {p:'linkDash',ex:'5'},
	 {p:'linkWidth',ex:'3'},
	 {p:'arrowLength',ex:'6'},
	 {p:'arrowColor',ex:'green'},
	 {p:'directionalParticles',ex:'2'}
    ]


    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	callbackWaiting:false,
        updateUI: function() {
            if(!window["ForceGraph"]) {
		if(!this.callbackWaiting) {
		    this.callbackWaiting = true;
                    setTimeout(()=>{
			this.callbackWaiting = false;
			this.updateUI()
		    },100);
		}
                return;
            }
	    let graphData = null;
	    let html = HU.div([ID, this.domId(ID_GRAPH)]);
	    this.setContents(html);
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let seenNodes = {};
	    let nodes = [];
	    let links = [];
	    let valueFields   = this.getFieldsByIds(null, this.getProperty("valueFields","",true));
	    let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    if(!labelField) {
		let strings = this.getFieldsByType(null, "string");
		if(strings.length>0) labelField = strings[0];
	    }
	    let sourceField = this.getFieldById(null, this.getProperty("sourceField","source"));
	    let targetField = this.getFieldById(null, this.getProperty("targetField","target"));
	    let textTemplate = this.getProperty("tooltip","${default}");
	    if(valueFields.length>0) {
		let seenValue = {};
		records.map((r,index)=>{
		    let label  = labelField?r.getValue(labelField.getIndex()):index;
		    let tooltip =  this.getRecordHtml(r, null, textTemplate);
		    nodes.push({id:index,label:label,tooltip:tooltip});
		    valueFields.map(f=>{
			let value = r.getValue(f.getIndex());
			if(!seenValue[value+"_" + f.getId()]) {
			    seenValue[value+"_" + f.getId()] = true;
			    nodes.push({id:value, isValue:true});
			}
			links.push({source:value, target: index});
		    });
		});
	    } else if(sourceField!=null && targetField!=null) {
		records.map(r=>{
		    let source = r.getValue(sourceField.getIndex());
		    let target = r.getValue(targetField.getIndex());
		    if(!seenNodes[source]) {
			seenNodes[source] = true;
			nodes.push({id:source,tooltip:source});
		    }
		    if(!seenNodes[target]) {
			seenNodes[target] = true;
			nodes.push({id:target,tooltip:target});
		    }
		    links.push({source:source, target: target});
		});
	    } else {
		this.setDisplayMessage("No source/target fields specified");
		return;
	    }
	    graphData = {
		nodes: nodes,
		links: links
	    };

	    /*
	      links = [];
	      gGraphData.edges.forEach(e=>{
	      links.push({source:e.from,target:e.to});
	      });

	      graphData = {
	      nodes:gGraphData.nodes,
	      links: links
	      }
	    */
	    const nodeBackground = this.getProperty("nodeBackground",'rgba(255, 255, 255, 0.8)');
	    const linkColor = this.getProperty("linkColor","#ccc");
	    const drawCircle = this.getProperty("drawCircle",false);
	    const linkWidth = +this.getProperty("linkWidth",1);
	    const linkDash = +this.getProperty("linkDash",-1);
	    const drawText = this.getProperty("drawText",true);
	    const nodeWidth = this.getProperty("nodeWidth",10);
	    const elem = document.getElementById(this.domId(ID_GRAPH));
	    const graph = ForceGraph()(elem).graphData(graphData);
	    graph.nodeCanvasObject((node, ctx, globalScale) => {
		let label = node.label;
		if(!label) label = node.id;
		const fontSize = 12/globalScale;
		ctx.font = fontSize +"px Sans-Serif";
		let textWidth = ctx.measureText(label).width;
		if(!drawText)
		    textWidth=nodeWidth;
		if(node.isValue) {
		    let bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2+2); 
		    ctx.lineWidth = 1;
		    ctx.strokeStyle = "#000";
		    ctx.fillStyle = "#fff";
		    ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
		    ctx.strokeRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
		} else  {
		    let dim = [textWidth, fontSize].map(n => n + fontSize * 0.2+2); 
		    ctx.fillStyle = nodeBackground;
		    ctx.strokeStyle = "#000";
		    if(drawCircle) {
			ctx.beginPath();
			ctx.arc(node.x, node.y, dim[0]/2, 0, 2 * Math.PI);
			ctx.fill(); 
		    } else {
			ctx.fillRect(node.x - dim[0] / 2, node.y - dim[1] / 2, ...dim);
			ctx.strokeRect(node.x - dim[0] / 2, node.y - dim[1] / 2, ...dim);
		    }
		}
		if(drawText) {
		    ctx.textAlign = 'center';
		    ctx.textBaseline = 'middle';
		    ctx.fillStyle = "black";
		    ctx.fillText(label, node.x, node.y);
		}
	    });

	    //	    graph.linkCanvasObjectMode('replace');
	    /*
	      graph.linkCanvasObject((link, ctx) => {
	      if(linkDash>0)
	      ctx.setLineDash([linkDash, linkDash]);
	      ctx.lineWidth = linkWidth;
	      ctx.strokeStyle = linkColor;
	      ctx.moveTo(link.source.x, link.source.y);
	      ctx.lineTo(link.target.x, link.target.y);
	      (link === graphData.links[graphData.links.length - 1]) && ctx.stroke();
	      });*/
	    //	    graph.linkAutoColorBy(d => gData.nodes[d.source].group);
	    if(this.getWidth())
		graph.width(this.getWidth());
	    if(this.getHeight())
		graph.height(this.getHeight());
	    graph.nodeLabel(node => node.tooltip?node.tooltip:null)
	    graph.linkWidth(+this.getProperty("linkWidth",4));
	    graph.linkColor(this.getProperty("linkColor","#000"));
	    if(this.getProperty("arrowColor")) {
		graph.linkDirectionalArrowColor(this.getProperty("arrowColor"));
	    }
	    if(this.getProperty("arrowLength")) {
		graph.linkDirectionalArrowLength(+this.getProperty("arrowLength"));
		graph.linkDirectionalArrowRelPos(+this.getProperty("arrowPosition",0.9));
	    }

	    if(this.getProperty("directionalParticles")) {
		graph.linkDirectionalParticles(+this.getProperty("directionalParticles"));
	    }
	}
    })
}


function RamaddaTreeDisplay(displayManager, id, properties) {
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_TREE, properties);
    let myProps = [
	{label:'Tree'},
	 {p:'maxDepth',ex:'3'},
	 {p:'showDetails',ex:'false'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	countToRecord: {},
        needsData: function() {
            return true;
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
	    let roots=null;
	    try {
		roots = this.makeTree(records);
	    } catch(error) {
                this.setDisplayMessage(error.toString());
		return;
	    }

	    let html = "";
	    let baseId = this.domId("node");
	    let cnt=0;
	    let depth = 0;
	    let maxDepth = +this.getProperty("maxDepth",10);
	    let template = this.getProperty("recordTemplate","${default}");
	    let showDetails = this.getProperty("showDetails",true);
	    let _this =this;
	    let func = function(node) {
		cnt++;
		if(node.record) {
		    _this.countToRecord[cnt] = node.record;
		}
		depth++;
		let on = node.children.length>0 && depth<=maxDepth;
		let details = null;
		if(showDetails && node.record) {
		    details = _this.getRecordHtml(node.record,null, template);
		    if(details == "") details = null;
		}
		let image = "";
		if(node.children.length>0 || details) {
		    image = HU.image(on?icon_downdart:icon_rightdart,[ID,baseId+"_toggle_image" + cnt]) + " ";
		}
		html+=HU.div([CLASS,"display-tree-toggle",ID,baseId+"_toggle" + cnt,"toggle-state",on,"block-count",cnt], image +  node.label);
		html+=HU.open(DIV,[ID, baseId+"_block"+cnt,CLASS,"display-tree-block",STYLE,HU.css('display', (on?"block":"none"))]);
		if(details && details!="") {
		    if(node.children.length>0) {
			html+= HU.div([CLASS,"display-tree-toggle-details",ID,baseId+"_toggle_details" + cnt,"toggle-state",false,"block-count",cnt], HU.image(icon_rightdart,[ID,baseId+"_toggle_details_image" + cnt]) + " Details");
			html+=HU.div([ID, baseId+"_block_details"+cnt,CLASS,"display-tree-block",STYLE,HU.css('display','none')],details);
		    } else {
			html+=details;
		    }
		}
		
		if(node.children.length>0) {
		    node.children.map(func);
		}
		depth--;
		html+=HU.close(DIV);
	    }
	    //	    console.log("roots:" + roots.length);
	    roots.map(func);
	    this.myRecords = [];
            this.displayHtml(html);
	    this.find(".display-tree-toggle").click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		let cnt = $(this).attr("block-count");
		let block = $("#"+ baseId+"_block"+cnt);
		let img = $("#"+ baseId+"_toggle_image"+cnt);
		$(this).attr("toggle-state",state);
		if(state)  {
		    block.css("display","block");
		    img.attr("src",icon_downdart);
		} else {
		    block.css("display","none");
		    img.attr("src",icon_rightdart);
		}
		let record = _this.countToRecord[cnt];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    this.find(".display-tree-toggle-details").click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		let cnt = $(this).attr("block-count");
		let block = $("#"+ baseId+"_block_details"+cnt);
		let img = $("#"+ baseId+"_toggle_details_image"+cnt);
		$(this).attr("toggle-state",state);
		if(state)  {
		    block.css("display","block");
		    img.attr("src",icon_downdart);
		} else {
		    block.css("display","none");
		    img.attr("src",icon_rightdart);
		}
	    });
        },
    });
}



function OrgchartDisplay(displayManager, id, properties) {
    const ID_ORGCHART = "orgchart";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_ORGCHART, properties);
    let myProps = [
	{label:'Orgchart'},
	{p:'labelField',ex:''},
	{p:'parentField',ex:''},
	{p:'idField',ex:''},
	{p:'treeRoot',ex:'some label'},
	{p:'treeTemplate',ex:''},
	{p:'treeNodeSize',ex:'small|medium|large'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER,myProps, {
        handleEventRecordSelection: function(source, args) {},
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    if(!waitOnGoogleCharts(this, ()=>{
		this.updateUI();
	    })) {
		return;
	    }
            this.displayHtml(HU.div([ID,this.domId(ID_ORGCHART)],""));
	    if(this.jq(ID_ORGCHART).length==0) {
		setTimeout(()=>this.updateUI(),1000);
		return;
	    }
	    let roots=null;
	    try {
		roots = this.makeTree();
	    } catch(error) {
                this.setDisplayMessage(error.toString());
		return;
	    }
	    if(roots==null) return;

	    let data = new google.visualization.DataTable();
            data.addColumn('string', 'Name');
            data.addColumn('string', 'Parent');
            data.addColumn('string', 'ToolTip');
	    let rows = [];
	    let cnt=0;
	    let func = function(node) {
		cnt++;
		let value = node.label;
		if(node.display) {
		    value = {'v':node.label,f:node.display};
		}
		let row = [value, node.parent?node.parent.label:"",node.tooltip||""];
		rows.push(row);
		if(node.children.length>0) {
		    node.children.map(func);
		}
		if(node.record) {
		    //		    _this.countToRecord[cnt] = node.record;
		}
	    }
	    roots.map(func);
            data.addRows(rows);
            let chart = new google.visualization.OrgChart(document.getElementById(this.domId(ID_ORGCHART)));
            // Draw the chart, setting the allowHtml option to true for the tooltips.
            chart.draw(data, {'allowHtml':true,'allowCollapse':true,
			      'size':this.getProperty("treeNodeSize","medium")});
	}
    });
}


function RamaddaTimelineDisplay(displayManager, id, properties) {
    const ID_TIMELINE = "timeline";
    if(!properties.height) properties.height=400;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TIMELINE, properties);
    let myProps = [
	{label:'Timeline'},
	{p:'titleField',ex:''},
	{p:'imageField',ex:''},
	{p:'textTemplate',ex:''},
	{p:'startDateField',ex:''},
	{p:'endDateField',ex:''},
	{p:'startAtSlide',ex:'0'},
	{p:'startAtEnd',ex:'true'},
	{p:'scaleFactor',ex:'10'},
	{p:'initialZoom',ex:'10'},	
	{p:'navHeight',ex:'150'},
	{p:'backgroundColor',ex:'#ccc'},
	{p:'groupField',ex:''},
	{p:'urlField',ex:''},
	{p:'timeTo',ex:'year|day|hour|second'},
	{p:'justTimeline',wikiVaklue:"true"},
	{p:'hideBanner',ex:"true"},
    ];

    Utils.importJS(ramaddaBaseUrl+"/lib/timeline3/timeline.js");
    let css = "https://cdn.knightlab.com/libs/timeline3/latest/css/timeline.css";
    //    css =  ramaddaBaseUrl+"/lib/timeline3/timeline.css";
    $(HU.tag('link',['rel','stylesheet','href', css,'type','text/css'] )).appendTo("head");
   
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	loadCnt:0,
	timelineLoaded: false,
        checkLayout: function() {
	    //Update the ui when the tab this is in is activated
	    this.updateUI();
	},
	updateUI: function() {
	    if(!this.timelineLoaded) {
		try {
		    let tmp =  TL.Timeline;
		    this.timelineLoaded = true;
		} catch(err) {
		    if(this.loadCnt++<100) {
			setTimeout(()=>this.updateUI(),100);
			return;
		    }
		}
	    }
	    if(!this.timelineLoaded) {
		this.setDisplayMessage("Could not load timeline");
		return;
	    }
            let records = this.filterData();
	    if(records==null) return;
	    let timelineId = this.domId(ID_TIMELINE);
	    let html = HU.cssTag("h2 a, h2 a:visited, h2 a:link {color:#c34528;}");
	    html+=HU.div([ID,timelineId]);
	    this.setContents(html);
	    this.timelineReady = false;
	    let opts = {
		timenav_position: this.getProperty("timelinePosition","bottom"),
//		debug:true,
		start_at_end: this.getPropertyStartAtEnd(false),
		start_at_slide: this.getPropertyStartAtSlide(0),
		timenav_height: this.getPropertyNavHeight(150),
		menubar_height:100,
		gotoCallback: (slide)=>{
		    if(this.timelineReady) {
			let record = records[slide];
			if(record) {
		    this.propagateEventRecordSelection({record: record});
			}
		    }
		}
            };
	    if(this.getPropertyBackgroundColor())
		opts.default_bg_color = this.getPropertyBackgroundColor();
	    if(this.getPropertyScaleFactor(0))
		opts.scale_factor = this.getPropertyScaleFactor();
	    if(this.getPropertyInitialZoom(0))
		opts.scale_factor = this.getPropertyInitialZoom();

	    let json = {};
	    let events = [];
	    json.events = events;
	    let titleField = this.getFieldById(null,this.getPropertyTitleField());
	    if(titleField==null) {
		titleField = this.getFieldById(null, "title");
	    }
	    if(titleField==null) {
		titleField = this.getFieldById(null, "name");
	    }

	    let startDateField = this.getFieldById(null,this.getPropertyStartDateField());
	    if(!startDateField) startDateField = this.getFieldByType(null,"date");
	    let endDateField = this.getFieldById(null,this.getPropertyEndDateField());
	    let imageField = this.getFieldById(null,this.getPropertyImageField());
	    let groupField = this.getFieldById(null,this.getPropertyGroupField());
	    let urlField = this.getFieldById(null,this.getPropertyUrlField());
	    let textTemplate = this.getPropertyTextTemplate("${default}");
	    let timeTo = this.getPropertyTimeTo("day");
	    let showYears = this.getProperty("showYears",false);
	    this.recordToIndex = {};
	    for(let i=0;i<records.length;i++) {
		let record = records[i]; 
		this.recordToIndex[record.getId()] = i;
		let tuple = record.getData();
		let event = {
		};	
		let headline = titleField? tuple[titleField.getIndex()]:" record:" + (i+1);
		let debug = false;
		let text =  this.getRecordHtml(record, null, textTemplate,debug);
		if(urlField) {
		    let url  = record.getValue(urlField.getIndex());
//		    text = HU.href(url,text);
		    headline = HU.href(url,headline);
		}

		event.text = {
		    headline: headline,
		    text:text
		};
		if(groupField) {
		    event.group = record.getValue(groupField.getIndex());
		}

		if(imageField) {
		    event.media = {
			url:record.getValue(imageField.getIndex())
		    };
		    if(urlField) {
			event.media.link = record.getValue(urlField.getIndex());
			event.media.link_target = "_timelinemedia";
		    }
		}
		let startDate =this.getDate(startDateField? tuple[startDateField.getIndex()]: record.getTime());
		if (showYears) {
		    event.start_date = {
			year: startDate.year
		    }
		} else {
		    event.start_date  = startDate;
		    if(endDateField) {
			event.end_date = tuple[endDateField.getIndex()];
		    }
		}
		//		console.log(JSON.stringify(event));
		events.push(event);
	    }
	    this.timeline = new TL.Timeline(timelineId,json,opts);
	    if(this.getPropertyHideBanner(false)) {
		this.jq(ID_TIMELINE).find(".tl-storyslider").css("display","none");
	    }
	    this.jq(ID_TIMELINE).find(".tl-text").css("padding","0px");
	    this.jq(ID_TIMELINE).find(".tl-slide-content").css("padding","0px 0px");
	    //	    this.jq(ID_TIMELINE).find(".tl-slide-content").css("width","100%");
	    this.jq(ID_TIMELINE).find(".tl-slidenav-description").css("display","none");
	    this.timelineReady = true;

	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let index = this.recordToIndex[args.record.getId()];
	    if(!Utils.isDefined(index)) return;
	    this.timeline.goTo(index);
	},
	getDate: function(time) {
	    let timeTo = this.getPropertyTimeTo("day");
	    let dt =  {year: time.getUTCFullYear()};
	    if(timeTo!="year") {
		dt.month = time.getUTCMonth()+1;
		if(timeTo!="month") {
		    dt.day = time.getUTCDate();
		    if(timeTo!="day") {
			dt.hour = time.getHours();
			dt.minute = time.getMinutes();
			if(timeTo!="hour") {
			    dt.second = time.getSeconds();
			}
		    }
		}
	    }
	    return dt;
	}
    });
}

function RamaddaHoursDisplay(displayManager, id, properties) {
    const ID_TIMELINE = "timeline";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HOURS, properties);
    const BOX_COLOR = "lightblue";
    const MULTI_ID = "multiid";
  
    let myProps = [
	{label:'Hours'},
	{p:'dateField',ex:''},
	{p:'boxWidth',ex:''},
	{p:'boxColor',ex:'blue'},	
	{p:'rowBackground',ex:''},
	{p:'dayLabelStyle',ex:''},
	{p:'fillHours',ex:'false'},			
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
            let records = this.filterData();
	    if(records==null) return;
	    let _this =this;
	    let html = "";
	    let dateField = this.getFieldById(null,this.getPropertyDateField());
	    let days = [];
	    let dayToHours = {};
	    let dateFormat = this.getProperty("dateFormat","mdy");
	    this.recordToIndex = {};
	    let timeZoneOffset = +this.getProperty("timeZoneOffset",0);
	    records.forEach((record,idx)=>{
		this.recordToIndex[record.getId()] = idx;
		let dttm0 =dateField? recordtuple[dateField.getIndex()]: record.getTime();
		let dttm = dttm0;
		let newHours = dttm.getUTCHours()+timeZoneOffset;
		dttm = new Date(Date.UTC(dttm.getUTCFullYear(),dttm.getUTCMonth(),dttm.getUTCDate(),newHours));
		let hour = +dttm.getUTCHours();
		let dayDate = new Date(Date.UTC(dttm.getUTCFullYear(),dttm.getUTCMonth(),dttm.getUTCDate()));
		let dayInfo = dayToHours[dayDate];

		if(!dayInfo) {
		    dayInfo = dayToHours[dayDate] = {
			dttm:dttm,
			hours:[],
			minutesCount:{},
			hourToRecords:{},
			minHour: hour,
			maxHour:hour
		    };
		    days.push(dayDate);
		}
		dayInfo.minHour = Math.min(dayInfo.minHour,hour);
		dayInfo.maxHour = Math.max(dayInfo.maxHour,hour);		
		let minutes = dttm0.getMinutes();
		let key  = hour+"_"+minutes;
		if(!dayInfo.minutesCount[key]) dayInfo.minutesCount[key] = 0;
		dayInfo.minutesCount[key]++;
		if(!dayInfo.hourToRecords[hour]) {
		    dayInfo.hours.push(hour);
		    dayInfo.hourToRecords[hour] = [];
		}
		dayInfo.hourToRecords[hour].push(record);
	    });
	    Utils.sortDates(days);
	    html = HU.open("div",[STYLE,"position:relative;"]) + HU.open("table",["width","100%"]);
	    let boxWidth = this.getPropertyBoxWidth(10);
	    let boxColor = this.getPropertyBoxColor(BOX_COLOR);
	    let extra = "";
	    days.forEach(day=>{
		let dayInfo = dayToHours[day];
		if(this.getPropertyFillHours(true)) {
		    for(let i=dayInfo.minHour;i<dayInfo.maxHour;i++) {
			if(!dayInfo.hourToRecords[i]) {
			    dayInfo.hours.push(i);
			    dayInfo.hourToRecords[i] = [];
			}
		    }
		}
		let dayLabel = Utils.formatDateWithFormat(day,dateFormat,true);
		html +=  HU.tr([STYLE,"border-bottom:1px solid #ccc;"],HU.tds([],["",HU.div([CLASS,"display-hours-label"], dayLabel),"#"]));
		let multiCount = 0;
		Utils.sortNumbers(dayInfo.hours).forEach(hour=>{
		    let row = "<tr style='border-top:1px solid #ccc;'>";
//		    if(hour!=9) return
		    let hourLabel  = HU.div([STYLE,this.getPropertyDayLabelStyle("")], Utils.formatHour(hour));
		    row += HU.td([WIDTH,"10","align","right"],hourLabel);
		    row += HU.open("td",[STYLE,HU.css('background','#efefef'),WIDTH,"100%"]);
		    row += HU.open("div",[STYLE, HU.css(HEIGHT,"100%",POSITION,"relative",WIDTH,"100%",BACKGROUND,this.getPropertyRowBackground("#eee"))]);
		    row += "&nbsp;";
		    let displayed = {};
		    let didOne= false;
		    dayInfo.hourToRecords[hour].forEach(record=>{
			let dttm =dateField? record.getValue(dateField.getIndex()): record.getTime();
			let minutes = dttm.getMinutes();
			//pad a bit on the left
			let left =  Math.round(minutes/61.0*100)+"%";
			let key = hour+"_"+minutes;
			if(dayInfo.minutesCount[key]>1) {
			    if(!displayed[minutes])  {
				let multiId = this.domId("multi"+ (multiCount++));
				displayed[minutes] = {
				    multiid:multiId,
				    contents:""};
				row+= HU.div([ID,multiId, TITLE,"Click to view multiples","dttm",dayInfo.dttm.getTime(), "hour",hour,"minute",minutes, STYLE, HU.css('top','0px','left',left),CLASS,'display-hours-box-multi'],dayInfo.minutesCount[key]);
			    }
			    displayed[minutes].contents +=
				HU.div([MULTI_ID,displayed[minutes].multiid,RECORD_ID, record.getId(), RECORD_INDEX,_this.recordToIndex[record.getId()],
					TITLE,"",STYLE,
					HU.css(WIDTH,boxWidth+"px",BACKGROUND,boxColor),
					CLASS,'display-hours-box'],"");
			} else {
			    let css = HU.css("position","absolute","top","0px",WIDTH,boxWidth+"px",'background',boxColor,'left',left);
			    row+= HU.div([RECORD_ID, record.getId(), RECORD_INDEX,_this.recordToIndex[record.getId()],
					  TITLE,"",STYLE, css,CLASS,'display-hours-box']);
			}
			didOne=true;
		    });
		    for(minute in displayed) {
			let id = dayInfo.dttm.getTime()+"_" + hour +"_"+minute;
			extra+=HU.div([ID,this.domId(id), CLASS,"display-hours-box-extra"],displayed[minute].contents);
		    }
		    row+="</div></td>";
		    row+=HU.td([],dayInfo.hourToRecords[hour].length);
		    row +="</tr>"
 		    if(didOne) html+=row;
		});
	    });
	    html+="</table>";
	    html+=extra;
	    html+="&nbsp;</div>";
	    this.setContents(html);
	    this.multis = this.find(".display-hours-box-multi");
	    this.multis.click(function() {
		let id = $(this).attr("dttm")+"_" + $(this).attr("hour") +"_"+$(this).attr("minute");
		let div = _this.jq(id);
		if($(this).attr("showing")=="true") {
		    div.hide();
		    $(this).css("border","1px solid #ccc");
		    $(this).attr("showing",false);
		    return;
		}
		$(this).css("border","1px solid " + HIGHLIGHT_COLOR);
		$(this).attr("showing",true);
		div.show();
		div.position({
                    of: $(this),
                    my: "left top",
                    at: "left bottom+2",
                    collision: "none none"
		});
	    });
	    this.boxes = this.find(".display-hours-box");
	    this.boxes.click(function() {
		let state = (/true/i).test($(this).attr("toggle-state"));
		state = !state;
		_this.boxes.css("background",BOX_COLOR);
		if(state)  {
		    $(this).css("background",HIGHLIGHT_COLOR);
		}
		let record = records[+$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({record: record});
		}
	    });
	    this.makeTooltips(this.boxes,records,null,null,false);
	},
        handleEventRecordSelection: function(source, args) {
	    if(!args.record) return;
	    let select = ".display-hours-box[" + RECORD_ID +"='" + args.record.getId()+"']";
	    let box = this.find(select);
	    if(box.length) {
		this.boxes.css("background",BOX_COLOR);
		this.multis.css("background","#efefef");		
		let multiId = 	box.attr(MULTI_ID);
		if(multiId) {
		    let multi = this.find("#" + multiId);
		    if(multi.length>0) {
			box = multi;
			box.css("background",HIGHLIGHT_COLOR);
		    }
		}
		
		box.css("background",HIGHLIGHT_COLOR);
		HU.scrollVisible(this.getContents(), box);
	    }
	},
    });
}





function RamaddaBlankDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width='100%';
    properties.showMenu = false;
    properties.showTitle = false;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_BLANK, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    this.setContents("");
	    if(!records) return;
	    let colorBy = this.getColorByInfo(records);
	    if(colorBy.index>=0) {
		records.map(record=>{
		    color =  colorBy.getColor(record.getData()[colorBy.index], record);
		});
		colorBy.displayColorTable();
	    }
	}});
}


function RamaddaPreDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_PRE, properties);
    let myProps = [
	{label:'Pre'},
	{p:'numRecords',ex:'100',d:1000},
	{p:'includeGeo',ex:'true',d:true},	
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) {
		this.setContents("No records yet");		
		return;
	    }
            let pointData = this.dataCollection.getList()[0];
            let fields = pointData.getRecordFields();
	    let numRecords = this.getNumRecords();
	    let includeGeo = this.getIncludeGeo();
	    let html ="Number of records:" + records.length+"<pre>";
	    fields.forEach((f,idx)=>{
		if(idx>0) html+=", ";
		html+=f.getId() +"[" + f.getType()+"]";
	    });
	    if(includeGeo) html+=", latitude, longitude";
	    html+="\n";
	    records.every((r,idx)=>{
		if(numRecords>-1 && idx>numRecords) return false;
		let d = r.getData();
		d = d.map(d=>{
		    if(d.getTime) return this.formatDate(d);
		    return d;
		});
		html+="#" + idx+": ";
		html+=d.join(", ");
		if(includeGeo) {
		    html+=", " + r.getLatitude() +"," + r.getLongitude();
		}
		html+="\n";
		return true;
	    });
	    html+="</pre>"
	    this.setContents(html);
	}});
}



function RamaddaHtmltableDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HTMLTABLE, properties);
    let myProps = [
	{label:'Html Table'},
	{p:'numRecords',ex:'100',d:1000},
	{p:'includeGeo',ex:'true',d:false},
	{p:'includeDate',ex:'true',d:true},		
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	displayData: function() {
	    this.updateUI();
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) {
		this.setDisplayMessage("No records yet");		
		return;
	    }
            let pointData = this.dataCollection.getList()[0];
            let fields = pointData.getRecordFields();
            let selectedFields = this.getSelectedFields();
	    fields= (selectedFields && selectedFields.length>0)?selectedFields:fields;
	    let numRecords = this.getNumRecords();
	    let includeGeo = this.getIncludeGeo();
	    let includeDate = this.getIncludeGeo();	    
	    let html ="Number of records:" + records.length+"<table width=100% border=0>";
	    html+="<tr valign=top><td></td>";
	    let headerAttrs = [STYLE,"white-space:nowrap;background:#efefef;margin:1px;padding:3px; font-weight:bold;"];
	    if(includeDate) html+=HU.td(HU.div(headerAttrs,"Date"));
	    fields.forEach((f,idx)=>{
		html+=HU.td([],HU.div(headerAttrs,f.getId() +"[" + f.getType()+"]"));
	    });
	    if(includeGeo) html+=HU.td(HU.div(headerAttrs,"latitude")) + HU.td([],HU.div(headerAttrs,"longitude"));
	    html+="</tr>";
	    records.every((r,idx)=>{
		if(numRecords>-1 && idx>numRecords) return false;
		let d = r.getData();
		d = d.map(d=>{
		    if(d.getTime) return this.formatDate(d);
		    return d;
		});
		let clazz = (idx%2)?"ramadda-row-odd":"ramadda-row-even";
		html+="<tr valign=top class=" + clazz+"><td>#" + idx+": </td>";
		if(includeDate) {
		    html+=HU.td([],this.formatDate(r.getDate()));
		}
		fields.forEach(f=>{
		    let v = d[f.getIndex()]
		    v = String(v);
		    if(v.length>500) {
			v = HU.div([STYLE,"max-height:200px;overflow-y:auto;"],v);
		    }
		    html+=HU.td([],v);
		});
		if(includeGeo) {
		    html+=HU.td([],r.getLatitude()) +HU.td([],r.getLongitude());
		}
		html+="</tr>";
		return true;
	    });
	    html+="</table>";
	    this.setContents(html);
	}});
}





function RamaddaTsneDisplay(displayManager, id, properties) {
    const ID_CANVAS = "tsnecanvas";
    const ID_DETAILS = "tsnedetails";
    const ID_RUN = "tsnerun";
    const ID_RESET = "tsnereset";
    const ID_STEP = "tsnestep";
    const ID_SEARCH = "tsnesearch";
    $.extend(this, {
        colorTable: "red_white_blue",
        colorByMin: "-1",
        colorByMax: "1",
        height: "500px;"
    });

    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_TSNE, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        nameToIndex: {},
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        updateUI: async function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            await Utils.importJS(ramaddaBaseUrl + "/lib/tsne.js");
            //Height is the height of the overall display including the menu bar
            let height = this.getProperty("height",400);
            if (String(height).endsWith("px")) height = String(height).replace("px", "");
            height = parseInt(height);
            //            height-=30;
            let details = HU.div([STYLE, HU.css('height', height + 'px','max-height', height + "px"), CLASS, "display-tnse-details", ID, this.domId(ID_DETAILS)], "");
            let canvas = HU.div([CLASS, "display-tnse-canvas-outer", STYLE, HU.css('height', height + 'px')], HU.div([CLASS, "display-tnse-canvas", ID, this.domId(ID_CANVAS)], ""));
            let buttons = HU.div([ID, this.domId(ID_RUN), CLASS, "ramadda-button", "what", "run"], "Stop") + SPACE +
                HU.div([ID, this.domId(ID_STEP), CLASS, "ramadda-button", "what", "step"], "Step") + SPACE +
                HU.div([ID, this.domId(ID_RESET), CLASS, "ramadda-button", "what", "reset"], "Reset") + SPACE +
                HU.input("", "", [ID, this.domId(ID_SEARCH), "placeholder", "search"]);

            buttons = HU.div([CLASS, "display-tnse-toolbar"], buttons);
            this.jq(ID_TOP_LEFT).append(buttons);
            this.setContents(HU.table([WIDTH,'100%'], HU.tr(['valign','top'], HU.td(['width','80%'], canvas) + HU.td(['width','20%'], details))));
            this.search = this.jq(ID_SEARCH);
            this.search.keyup(e => {
                let v = this.search.val().trim();
                this.canvas.find(".display-tnse-mark").removeClass("display-tnse-highlight");
                if (v == "") return;
                v = v.toLowerCase();
                for (name in this.nameToIndex) {
                    if (name.toLowerCase().startsWith(v)) {
                        this.jq("element-" + this.nameToIndex[name]).addClass("display-tnse-highlight");
                    }
                }
            });
            this.details = this.jq(ID_DETAILS);
            this.reset = this.jq(ID_RESET);
            this.step = this.jq(ID_STEP);
            this.step.button().click(() => {
                this.running = false;
                this.run.html(this.running ? "Stop" : "Run");
                this.takeStep();
            });
            this.reset.button().click(() => {
                this.start();
            });
            this.run = this.jq(ID_RUN);
            this.run.button().click(() => {
                this.running = !this.running;
                if (this.running) this.takeStep();
                this.run.html(this.running ? "Stop" : "Run");
            });
            this.canvas = this.jq(ID_CANVAS);
            this.running = true;
            this.start();
        },
        start: function() {
            this.canvas.html("");
            this.haveStepped = false;
            this.dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            if (!this.fields) {
                this.fields = this.getSelectedFields([]);
                if (this.fields.length == 0) this.fields = allFields;
                let strings = this.getFieldsByType(this.fields, "string");
                if (strings.length > 0)
                    this.textField = strings[0];
            }
            let data = [];
            for (let rowIdx = 1; rowIdx < this.dataList.length; rowIdx++) {
                let tuple = this.getDataValues(this.dataList[rowIdx]);
                let nums = [];
                for (let i = 0; i < this.fields.length; i++) {
                    if (this.fields[i].isNumeric()){
                        let v = tuple[this.fields[i].getIndex()];
                        if(isNaN(v)) v = 0;
                        nums.push(v);
                    }
                }
                data.push(nums);
            }

            let opt = {}
            opt.epsilon = 10; // epsilon is learning rate
            opt.perplexity = 30; // how many neighbors each point influences
            opt.dim = 2; // dimensionality of the embedding (2 = default)
            this.tsne = new tsnejs.tSNE(opt);
            this.tsne.initDataRaw(data);
            this.takeStep();
        },
        takeStep: function() {
            let numSteps = 10;
            for (let step = 0; step < numSteps; step++) {
                this.tsne.step();
            }

            let pts = this.tsne.getSolution();
            let minx, miny, maxx, maxy;
            for (let i = 0; i < pts.length; i++) {
                if (i == 0) {
                    maxx = minx = pts[i][0];
                    maxy = miny = pts[i][1];
                } else {
                    maxx = Math.max(maxx, pts[i][0]);
                    minx = Math.min(minx, pts[i][0]);
                    maxy = Math.max(maxy, pts[i][1]);
                    miny = Math.min(miny, pts[i][1]);
                }
            }
            let sleep = 250;
            for (let i = 0; i < pts.length; i++) {
                let x = pts[i][0];
                let y = pts[i][1];
                let px = 100 * (x - minx) / (maxx - minx);
                let py = 100 * (y - miny) / (maxy - miny);
                if (!this.haveStepped) {
                    let title = "";
                    if (this.textField) {
                        let tuple = this.getDataValues(this.dataList[i]);
                        title = tuple[this.textField.getIndex()];
                    }
                    if (title.length > 10) {
                        title.length = 10;
                    }
                    this.nameToIndex[title] = i;
                    this.canvas.append(HU.div([TITLE, title, "index", i, ID, this.domId("element-" + i), CLASS, "display-tnse-mark", STYLE, HU.css('left', px + '%', 'top',py +'%')], title));
                } else {
                    this.jq("element-" + i).animate({
                        left: px + "%",
                        top: py + "%"
                    }, sleep, "linear");
                }

            }
            let _this = this;
            if (!this.haveStepped) {
                this.canvas.find(".display-tnse-mark").click(function(e) {
                    let index = parseInt($(this).attr("index"));
                    if (index < 0 || index >= _this.dataList.length) return;
                    let tuple = _this.getDataValues(_this.dataList[index]);
                    let details = HU.open(TABLE,[CLASS,'formtable',WIDTH,'100%']);
                    for (let i = 0; i < _this.fields.length; i++) {
                        let field = _this.fields[i];
                        details += HU.tr([],HU.td(['align','right', CLASS,'formlabel'], field.getLabel() + ':') + HU.td([],tuple[field.getIndex()]));
                    }
                    details += HU.close(TABLE);
                    _this.details.html(details);
                });
            }
            if (!this.haveStepped) {
                //                this.haveStepped = true;
                //                this.takeStep();
                //                return;
            }
            this.haveStepped = true;
            if (this.running)
                setTimeout(() => this.takeStep(), sleep);
        },
    });
}


function RamaddaHeatmapDisplay(displayManager, id, properties) {
    $.extend(this, {
        colorTable: "red_white_blue",
    });
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_HEATMAP, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        "map-display": false,
        needsData: function() {
            return true;
        },
        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            let tmp = HU.formTable();
            let colorTable = this.getColorTableName();
            let ct = HU.open('select',[ID,this.domId("colortable")]);
            for (table in Utils.ColorTable) {
                if (table == colorTable)
                    ct += HU.tag('option',['selected',null], table);
                else
                    ct += HU.tag('option',[], table);
            }
            ct += HU.close('select');
            tmp += HU.formEntry("Color Table:", ct);
            tmp += HU.formEntry("Color By Range:", HU.input("", this.colorByMin, ["size", "7", ATTR_ID, this.domId("colorbymin")]) + " - " +
				HU.input("", this.colorByMax, ["size", "7", ATTR_ID, this.domId("colorbymax")]));
            tmp += HU.close(TABLE);
            menuItems.push(tmp);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function() {
                _this.colorByMin = _this.jq("colorbymin").val();
                _this.colorByMax = _this.jq("colorbymax").val();
                _this.updateUI();

            };
            let func2 = function() {
                _this.colorTable = _this.jq("colortable").val();
                _this.updateUI();

            };
            this.jq("colorbymin").blur(updateFunc);
            this.jq("colorbymax").blur(updateFunc);
            this.jq("colortable").change(func2);
        },

        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        getContentsStyle: function() {
            let height = this.getProperty("height", -1);
            if (height > 0) {
                return " height:" + height + "px; " + " max-height:" + height + "px; overflow-y: auto;";
            }
            return "";
        },
        updateUI: function(pointData) {
            let _this = this;
            if (!haveGoogleChartsLoaded()) {
                let func = function() {
                    _this.updateUI();
                }
                this.setDisplayMessage(this.getLoadingMessage());
                setTimeout(func, 1000);
                return;
            }

            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let dataList = this.getStandardData(null, {
                includeIndex: true
            });
            let header = this.getDataValues(dataList[0]);
            let showIndex = this.getProperty("showIndex", true);
            let showValue = this.getProperty("showValue", true);
            let textColor = this.getProperty("textColor", "black");

            let cellHeight = this.getProperty("cellHeight", null);
            let extraTdStyle = "";
            if (this.getProperty("showBorder")) {
                extraTdStyle = HU.css("border-bottom","1px #666 solid");
            }

            let extraCellStyle = "";
            if (cellHeight)
                extraCellStyle += HU.css("height", cellHeight + "px","max-height", cellHeight + "px","min-height", cellHeight + "px");

            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);

            if (fields.length == 0) fields = allFields;
            let html = "";
            let colors = null;
            let colorByMin = null;
            let colorByMax = null;
            if (Utils.stringDefined(this.getProperty("colorByMins"))) {
                colorByMin = [];
                let c = this.getProperty("colorByMins").split(",");
                for (let i = 0; i < c.length; i++) {
                    colorByMin.push(parseFloat(c[i]));
                }
            }
            if (Utils.stringDefined(this.getProperty("colorByMaxes"))) {
                colorByMax = [];
                let c = this.getProperty("colorByMaxes").split(",");
                for (let i = 0; i < c.length; i++) {
                    colorByMax.push(parseFloat(c[i]));
                }
            }

            if (Utils.stringDefined(this.getProperty("colorTables"))) {
                let c = this.getProperty("colorTables").split(",");
                colors = [];
                for (let i = 0; i < c.length; i++) {
                    let name = c[i];
                    if (name == "none") {
                        colors.push(null);
                        continue;
                    }
                    let ct = Utils.getColorTable(name, true);
                    //                        console.log("ct:" + name +" " +(ct!=null));
                    colors.push(ct);
                }
            } else {
                colors = [this.getColorTable(true)];
            }
            let mins = null;
            let maxs = null;
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let row = this.getDataValues(dataList[rowIdx]);
                if (mins == null) {
                    mins = [];
                    maxs = [];
                    for (let colIdx = 1; colIdx < row.length; colIdx++) {
                        mins.push(Number.MAX_VALUE);
                        maxs.push(Number.MIN_VALUE);
                    }
                }

                for (let colIdx = 0; colIdx < fields.length; colIdx++) {
                    let field = fields[colIdx];
                    //Add one to the field index to account for the main time index
                    let index = field.getIndex() + 1;
                    if (!field || !field.isFieldNumeric() || field.isFieldGeo()) continue;

                    let value = row[index];
                    if (value == Number.POSITIVE_INFINITY || isNaN(value) || !Utils.isNumber(value) || !Utils.isDefined(value) || value == null) {
                        continue;
                    }
                    mins[colIdx] = Math.min(mins[colIdx], value);
                    maxs[colIdx] = Math.max(maxs[colIdx], value);
                }
            }

            html += HU.open(TABLE, ["border", "0", CLASS, "display-heatmap"]);
            html += HU.open(TR,[VALIGN,'bottom']);
            if (showIndex) {
                html += HU.td([ALIGN,'center'], HU.div([CLASS, "display-heatmap-heading-top"], header[0]));
            }
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let field = fields[fieldIdx];
                if ((!field.isFieldNumeric() || field.isFieldGeo())) continue;
                html += HU.td([ALIGN,'center'], HU.div([CLASS, "display-heatmap-heading-top"], field.getLabel()));
            }
            html += HU.close(TR);

            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let row = this.getDataValues(dataList[rowIdx]);
                let index = row[0];
                //check if its a date
                if (index.f) {
                    index = index.f;
                }
                let rowLabel = index;
                html += HU.open('tr',['valign','center']);
                if (showIndex) {
                    html += HU.td([CLASS, "display-heatmap-heading-side", STYLE, extraCellStyle + extraTdStyle], rowLabel);
                }
                let colCnt = 0;
                for (let colIdx = 0; colIdx < fields.length; colIdx++) {
                    let field = fields[colIdx];
                    //Add one to the field index to account for the main time index
                    let index = field.getIndex() + 1;
                    if (!field || !field.isFieldNumeric() || field.isFieldGeo()) continue;
                    let style = "";
                    let value = row[index];
                    let min = mins[colIdx];
                    let max = maxs[colIdx];
                    if (colorByMin && colCnt < colorByMin.length)
                        min = colorByMin[colCnt];
                    if (colorByMax && colCnt < colorByMax.length)
                        max = colorByMax[colCnt];


                    let ok = min != max && !(value == Number.POSITIVE_INFINITY || isNaN(value) || !Utils.isNumber(value) || !Utils.isDefined(value) || value == null);
                    let title = header[0] + ": " + rowLabel + " - " + field.getLabel() + ": " + value;
                    if (ok && colors != null) {
                        let ct = colors[Math.min(colCnt, colors.length - 1)];
                        if (ct) {
                            let percent = (value - min) / (max - min);
                            let ctIndex = parseInt(percent * ct.length);
                            if (ctIndex >= ct.length) ctIndex = ct.length - 1;
                            else if (ctIndex < 0) ctIndex = 0;
                            style = "background-color:" + ct[ctIndex] + ";";
                        }
                    }
                    let number;
                    if (!ok) {
                        number = "-";
                    } else {
                        number = Utils.formatNumber(value)
                    }
                    if (!showValue) number = ""; 
                    html += HU.td(["valign", "center", "align", "right", STYLE, style + extraCellStyle + extraTdStyle, CLASS, "display-heatmap-cell"], HU.div([TITLE, title, STYLE, extraCellStyle + HU.css('color',textColor)], number));
                    colCnt++;
                }
                html += HU.close(TR);
            }
            html += HU.close(TABLE);
            this.setContents(html);
            this.initTooltip();

        },
    });
}


function RamaddaRankingDisplay(displayManager, id, properties) {
    const ID_TABLE = "rankingtable";
    $.extend(this, {
	height: "500px",
        sortAscending:false,
    });
    if(properties.sortAscending) this.sortAscending = "true" == properties.sortAscending;
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RANKING, properties);
    let myProps = [
	{label:'Ranking'},
	{p:'sortField',ex:''},
	{p:'nameFields',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            let records = this.records =  this.filterData();
            if (records == null) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);
            if (fields.length == 0) fields = allFields;
            let numericFields = this.getFieldsByType(fields, "numeric");
            let sortField = this.getFieldById(numericFields, this.getProperty("sortField","",true));
            if (numericFields.length == 0) {
                this.setContents("No fields specified");
                return;
            }
            if (!sortField) {
                sortField = numericFields[0];
            }
            if (!sortField) {
                this.setDisplayMessage("No fields specified");
                return;
            }

            let stringFields = this.getFieldsByIds(allFields, this.getProperty("nameFields","",true));
            if(stringFields.length==0) {
		let tmp = this.getFieldById(allFields, this.getProperty("nameField","",true));
		if(tmp) stringFields.push(tmp);
	    }
            if(stringFields.length==0) {
                let stringField = this.getFieldByType(allFields, "string");
		if(stringField) stringFields.push(stringField);
	    }
            let menu = HU.open("select",[CLASS,'ramadda-pulldown',ID, this.domId("sortfields")]);
            for (let i = 0; i < numericFields.length; i++) {
                let field = numericFields[i];
                let extra = "";
                if (field.getId() == sortField.getId()) extra = " selected ";
                menu += HU.tag('option',['value', field.getId(), extra,null], field.getLabel());
            }
            menu += HU.close('select');
	    let top ="";
	    top += HU.span([ID,this.domId("sort")], HU.getIconImage(this.sortAscending?"fa-sort-up":"fa-sort-down", [STYLE,HU.css('cursor','pointer'),TITLE,"Change sort order"]));
            if (this.getProperty("showRankingMenu", true)) {
                top+= " " + HU.div([STYLE,HU.css('display','inline-block'), CLASS,"display-filterby"],menu);
            }
	    this.jq(ID_TOP_LEFT).html(top);
	    this.jq("sort").click(()=>{
		this.sortAscending= !this.sortAscending;
		if(this.sortAscending) 
		    this.jq("sort").html(HU.getIconImage("fa-sort-up", [STYLE,HU.css('cursor','pointer')]));
		else
		    this.jq("sort").html(HU.getIconImage("fa-sort-down", [STYLE,HU.css('cursor','pointer')]));
		this.updateUI();
	    });
            let html = "";
            html += HU.open(DIV, [STYLE, HU.css('max-height','100%','overflow-y','auto')]);
            html += HU.open(TABLE, [ID, this.domId(ID_TABLE)]);
            let tmp = [];
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let obj = dataList[rowIdx];
                obj.originalRow = rowIdx;
                tmp.push(obj);
            }

	    let includeNaN = this.getProperty("includeNaN",false);
	    if(!includeNaN) {
		let tmp2 = [];
		tmp.map(r=>{
		    let t = this.getDataValues(r);
		    let v = t[sortField.getIndex()];
		    if(!isNaN(v)) tmp2.push(r);
		});
		tmp = tmp2;
	    }
            let cnt = 0;
	    let highlight = this.getFilterHighlight();
	    let sorter = (a,b)=>{
		let r1 = a.record;
		let r2 = b.record;
		let h1 = r1.isHighlight(this);
		let h2 = r2.isHighlight(this);
		if(highlight) {
		    if(h1 && !h2) return 1;
		    if(!h1 && h2) return -1;
		}
                let t1 = this.getDataValues(a);
                let t2 = this.getDataValues(b);
                let v1 = t1[sortField.getIndex()];
                let v2 = t2[sortField.getIndex()];
                if (v1 < v2) return -1;
                if (v1 > v2) return 1;
                return 0;
	    };
            tmp.sort((a, b) => {
		let v = sorter(a,b);
		if(v==0) return 0;
		if(this.sortAscending) return v;
		return  -v;
            });


            for (let rowIdx = 0; rowIdx < tmp.length; rowIdx++) {
                let obj = tmp[rowIdx];
                let tuple = this.getDataValues(obj);
                let label = "";
                stringFields.map(f=>{
		    label += tuple[f.getIndex()]+" ";
		});

                label = label.trim();
		value = tuple[sortField.getIndex()];
                if (isNaN(value) || value === null) {
		    if(!includeNaN) continue;
		    value = "NA";
		} else {
		    value = this.formatNumber(value);
		}
		html += HU.tr([VALIGN,'top',CLASS,'display-ranking-row','what',obj.originalRow],
			      HU.td([],'#' + (rowIdx + 1)) + HU.td([],SPACE + label) +HU.td([ALIGN,'right'], SPACE +
											    value));
            }
            html += HU.close(TABLE);
            html += HU.close(DIV);
            this.setContents(html);
            let _this = this;
            this.jq(ID_TABLE).find(".display-ranking-row").click(function(e) {
                _this.getDisplayManager().propagateEventRecordSelection(_this, _this.getPointData(), {
                    index: parseInt($(this).attr("what")) - 1
                });
            });
	    HU.initSelect(this.jq("sortfields"));
            this.jq("sortfields").change(function() {
                _this.setProperty("sortField", $(this).val());
                _this.updateUI();
            });
        },
    });
}



function RamaddaCrosstabDisplay(displayManager, id, properties) {
    const ID_TABLE = "crosstab";
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CROSSTAB, properties);
    defineDisplay(addRamaddaDisplay(this), SUPER, [], {
        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let allFields = this.dataCollection.getList()[0].getRecordFields();
	    let enums = [];
	    allFields.map(field=>{
		let label = field.getLabel();
		if(label.length>30) label = label.substring(0,29);
		enums.push([field.getId(),label]);
	    });
	    let select = HU.span([CLASS,"display-filterby"],
				 "Display: " + HU.select("",[STYLE,"", ID,this.domId("crosstabselect")],enums,
							 this.getProperty("column", "", true)));


            this.setContents(select+HU.div([ID,this.domId(ID_TABLE)]));
	    let _this = this;
	    this.jq("crosstabselect").change(function() {
		_this.setProperty("column", $(this).val());
		_this.makeTable();
	    });
	    this.makeTable();
	},
	makeTable: function() {
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
	    let col =  this.getFieldById(null, this.getProperty("column", "", true));
	    let rows =  this.getFieldsByIds(null, this.getProperty("rows", null, true));
	    if(!col) col  = allFields[0];
	    if(rows.length==0) rows  = allFields;

            let html = HU.open(TABLE, ["border", "1px", "bordercolor", "#ccc", CLASS, "display-crosstab", "cellspacing", "1", "cellpadding", "2"]);
	    let total = dataList.length-1;
	    let cnt =0;
	    rows.map((row)=>{
		if(row.getId()==col.getId()) return;
		cnt++;
		let colValues = [];
		let rowValues = [];
		let count ={};
		let rowcount ={};
		let colcount ={};
		for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
		    let tuple = this.getDataValues(dataList[rowIdx]);
		    let colValue = (""+tuple[col.getIndex()]).trim();
		    let rowValue = (""+tuple[row.getIndex()]).trim();
		    let key = colValue+"--" + rowValue;
		    if(colValues.indexOf(colValue)<0) colValues.push(colValue);
		    if(rowValues.indexOf(rowValue)<0) rowValues.push(rowValue);
		    if (!(rowValue in rowcount)) {
			rowcount[rowValue] = 0;
		    }
		    rowcount[rowValue]++;
		    if (!(key in count)) {
			count[key] = 0;
		    }
		    count[key]++;
		}
		colValues.sort();
		rowValues.sort();
		if(cnt==1)
		    html+=HU.tr([],HU.td()+ HU.td([ALIGN,'center',CLASS,'display-crosstab-header','colspan',colValues.length], col.getLabel()) +HU.td([],SPACE));
		html+=HU.open(TR,[VALIGN,'bottom',CLASS,'display-crosstab-header-row'],HU.td([CLASS,'display-crosstab-header'],row.getLabel()));
		for(let j=0;j<colValues.length;j++) {
		    let colValue = colValues[j];
		    html+=HU.td([],(colValue==""?"&lt;blank&gt;":colValue));
		}
		html+=HU.td([],HU.b('Total'));
		html+=HU.close(TR);
		for(let i=0;i<rowValues.length;i++) {
		    let rowValue = rowValues[i];
		    html+=HU.open(TR);
		    html+=HU.td([], (rowValue==""?"&lt;blank&gt;":rowValue));
		    for(let j=0;j<colValues.length;j++) {
			let colValue = colValues[j];
			let key = colValue+"--" + rowValue;
			if(Utils.isDefined(count[key])) {
			    let perc = Math.round(count[key]/total*100) +"%";
			    html+=HU.td([ALIGN,'right'], count[key] +"&nbsp;(" + perc+")");
			} else {
			    html+=HU.td([],SPACE);
			}
		    }
		    let perc = Math.round(rowcount[rowValue]/total*100) +"%";
		    html+=HU.td([ALIGN,'right'], rowcount[rowValue] +SPACE +'(' + perc+')');
		    html+=HU.close(TR);
		}
	    });
            html += HU.close(TABLE);
	    this.jq(ID_TABLE).html(html);
        },
    });
}




function RamaddaCorrelationDisplay(displayManager, id, properties) {
    const ID_SLIDER_LOW = "sliderlow";
    const ID_SLIDER_LOW_MIN = "sliderlowmin";
    const ID_SLIDER_LOW_MAX = "sliderlowmax"
    const ID_SLIDER_HIGH = "sliderhigh";
    const ID_SLIDER_HIGH_MIN = "sliderhighmin";
    const ID_SLIDER_HIGH_MAX = "sliderhighmax"    
    const ID_TABLE = "table";
    const ID_LASTROW = "lastrow";
    $.extend(this, {
        colorTable: "red_white_blue",
        colorByMin: "-1",
        colorByMax: "1",
    });

    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CORRELATION, properties);
    let myProps = [
	{label:'Correlation'},
	{p:'showSelectSlider',ex:'false'},
	{p:'range.low.min',ex:'-1'},
	{p:'range.low.max',ex:'0'},
	{p:'range.high.min',ex:'0'},
	{p:'range.high.max',ex:'1'},
	{p:'short',ex:'true',tt:'Abbreviated display'},
	{p:'showValue',ex:'false',tt:'Show the values'},
	{p:'useId ',ex:' true',tt:'Use field id instead of label'},
	{p:'useIdTop',ex:'true',tt:'Use field id for top header'},
	{p:'useIdSide ',ex:'true',tt:'Use field id for side header'},
	{p:'labelStyle',ex:'',tt:'CSS style for labels'}

    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        "map-display": false,
        needsData: function() {
            return true;
        },


        getMenuItems: function(menuItems) {
            SUPER.getMenuItems.call(this, menuItems);
            let get = this.getGet();
            let tmp = HU.formTable();
            let colorTable = this.getColorTableName();
            let ct = HU.open('select',[ID,this.domId("colortable")]);
            for (table in Utils.ColorTables) {
                if (table == colorTable)
                    ct += HU.tag('option',['selected',null],table);
                else
                    ct += HU.tag('option',[], table);
            }
            ct += HU.close('select');
            tmp += HU.formEntry("Color Bar:", ct);
            tmp += HU.formEntry("Color By Range:", HU.input("", this.colorByMin, ["size", "7", ATTR_ID, this.domId("colorbymin")]) + " - " +
				HU.input("", this.colorByMax, ["size", "7", ATTR_ID, this.domId("colorbymax")]));
            tmp += HU.close(TABLE);
            menuItems.push(tmp);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
            let _this = this;
            let updateFunc = function() {
                _this.colorByMin = _this.jq("colorbymin").val();
                _this.colorByMax = _this.jq("colorbymax").val();
                _this.updateUI();

            };
            let func2 = function() {
                _this.colorTable = _this.jq("colortable").val();
                _this.updateUI();

            };
            this.jq("colorbymin").blur(updateFunc);
            this.jq("colorbymax").blur(updateFunc);
            this.jq("colortable").change(func2);
        },

        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        fieldSelectionChanged: function() {
            this.updateUI();
        },
        updateUI: function(pointData) {
            SUPER.updateUI.call(this, pointData);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    let _this  = this;
	    let html = "";
	    this.range = {
		low:{
		    min:this.getProperty("range.low.min",-1),
		    max:this.getProperty("range.low.max",0)
		},
		high: {
		    min:this.getProperty("range.high.min",0),
		    max:this.getProperty("range.high.max",1)
		}
	    }
	    if(this.getProperty("showSelectSlider",true)) {
		let lowSlider = HU.div([STYLE,HU.css('display','inline-block')],"Low Range" + HU.tag(BR) + 
				       HU.div([ID,this.gid(ID_SLIDER_LOW_MIN),STYLE,HU.css(WIDTH,'50px','display','inline-block','text-align','right','margin-right','15px')],this.range.low.min) +
				       HU.div([STYLE,HU.css(HEIGHT,'20px','display','inline-block',WIDTH,'200px','background','#A6A6FF'), ID,this.gid(ID_SLIDER_LOW)]) +
				       HU.div([ID,this.gid(ID_SLIDER_LOW_MAX),STYLE,HU.css('text-align','left','width','50px','display','inline-block','margin-left','15px')],this.range.low.max));
		let highSlider = HU.div(["display","inline-block;"], "High Range" + HU.tag(BR) + 
					HU.div([ID,this.gid(ID_SLIDER_HIGH_MIN),STYLE,HU.css('width','50px','display','inline-block','text-align','right', 'margin-right','15px')],this.range.high.min) +
					HU.div([STYLE,HU.css(HEIGHT,'20px','display','inline-block','width','200px','background','#FD9596'), ID,this.gid(ID_SLIDER_HIGH)]) +
					HU.div([ID,this.gid(ID_SLIDER_HIGH_MAX),STYLE,HU.css('text-align','left','width','50px','display','inline-block','margin-left','15px')],this.range.high.max));


		html +=HU.center(HU.hrow(lowSlider, highSlider));
	    }
	    html +=HU.div([ID,this.domId(ID_TABLE)]);
            this.setContents(html);
	    this.makeTable();
	    if(this.getProperty("showSelectSlider",true)) {
		this.jq(ID_SLIDER_LOW).slider({
		    range: true,
		    min: 0,
		    max: 100,
		    values:[(this.range.low.min+1)*100,(this.range.low.max+1)*100],
		    slide: function( event, ui ) {
			let v1 = -1+ui.values[0]/100;
			let v2 = -1+ui.values[1]/100;
			_this.jq(ID_SLIDER_LOW_MIN).html(v1==-1?-1:number_format(v1,3));
			_this.jq(ID_SLIDER_LOW_MAX).html(v2==0?0:number_format(v2,3));
		    },
		    stop: function(event,ui) {
			_this.range.low.min =   -1+2*ui.values[0]/100;
			_this.range.low.max  = -1+2*ui.values[1]/100;
			_this.makeTable();
		    }
		});
		this.jq(ID_SLIDER_HIGH).slider({
		    range: true,
		    min: 0,
		    max: 100,
		    values:[this.range.high.min*100,this.range.high.max*100],
		    slide: function( event, ui ) {
			let v1 = ui.values[0]/100;
			let v2 = ui.values[1]/100;
			_this.jq(ID_SLIDER_HIGH_MIN).html(v1==0?0:number_format(v1,3));
			_this.jq(ID_SLIDER_HIGH_MAX).html(v2==1?1:number_format(v2,3));

		    },
		    stop: function(event,ui) {
			_this.range.high.min =  ui.values[0]/100;
			_this.range.high.max  = ui.values[1]/100;
			_this.makeTable();
		    }
		});


		
	    }
            this.initTooltip();
            this.displayManager.propagateEventRecordSelection(this,
							      this.dataCollection.getList()[0], {
								  index: 0
							      });
        },
	makeTable: function() {
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            let fields = this.getSelectedFields([]);
            if (fields.length == 0) fields = allFields;
            let fieldCnt = 0;
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let field1 = fields[fieldIdx];
                if (!field1.isFieldNumeric() || field1.isFieldGeo()) continue;
                fieldCnt++;
            }

            let html = HU.open(TABLE, ["cellspacing","0","cellpadding", "0", "border", "0", CLASS, "display-correlation", "width", "100%"]);
            let col1Width = 10 + "%";
            let width = 90 / fieldCnt + "%";
            html += HU.open(TR,["valign","bottom"]) + HU.td([CLASS,"display-heading","width", col1Width],SPACE);

            let short = this.getProperty("short", fieldCnt > 8);
            let showValue = this.getProperty("showValue", !short);
            let useId = this.getProperty("useId", true);
            let useIdTop = this.getProperty("useIdTop", useId);
            let useIdSide = this.getProperty("useIdSide", useId);
	    let labelStyle = this.getProperty("labelStyle","");
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let field1 = fields[fieldIdx];
                if (!field1.isFieldNumeric() || field1.isFieldGeo()) continue;
                let label = useIdTop ? field1.getId() : field1.getLabel();
                if (short) label = "";
		label = label.replace(/\/ +/g,"/").replace(/ +\//g,"/");
		
		label = HU.span([STYLE,labelStyle], label);

                html += HU.td(["colfield", field1.getId(), "align","center","width",width],
			      HU.div([CLASS, "display-correlation-heading display-correlation-heading-top"], label));
            }
            html += HU.close(TR);
            let colors = null;
            colorByMin = parseFloat(this.colorByMin);
            colorByMax = parseFloat(this.colorByMax);
	    //            colors =  this.addAlpha(this.getColorTable(true),0.75);
	    colors =  this.getColorTable(true);
            for (let fieldIdx1 = 0; fieldIdx1 < fields.length; fieldIdx1++) {
                let field1 = fields[fieldIdx1];
                if (!field1.isFieldNumeric() || field1.isFieldGeo()) continue;
                let label = useIdSide ? field1.getId() : field1.getLabel();
		label.replace(/ /g, SPACE);
		label = HU.span([STYLE,labelStyle], label);
                html += HU.open(TR, ["valign","center"]);
		html += HU.td(["rowfield",field1.getId(),CLASS, "display-correlation-heading"],  HU.div([CLASS, "display-correlation-heading-side"], label));
                let rowName = field1.getLabel();
                for (let fieldIdx2 = 0; fieldIdx2 < fields.length; fieldIdx2++) {
                    let field2 = fields[fieldIdx2];
                    if (!field2.isFieldNumeric() || field2.isFieldGeo()) continue;
                    let colName = field2.getLabel();
                    let t1 = 0;
                    let t2 = 0;
                    let cnt = 0;

                    for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                        let tuple = this.getDataValues(dataList[rowIdx]);
                        let v1 = tuple[field1.getIndex()];
                        let v2 = tuple[field2.getIndex()];
                        t1 += v1;
                        t2 += v2;
                        cnt++;
                    }
                    let avg1 = t1 / cnt;
                    let avg2 = t2 / cnt;
                    let sum1 = 0;
                    let sum2 = 0;
                    let sum3 = 0;
                    for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                        let tuple = this.getDataValues(dataList[rowIdx]);
                        let v1 = tuple[field1.getIndex()];
                        let v2 = tuple[field2.getIndex()];
                        sum1 += (v1 - avg1) * (v2 - avg2);
                        sum2 += (v1 - avg1) * (v1 - avg1);
                        sum3 += (v2 - avg2) * (v2 - avg2);
                    }
                    r = sum1 / Math.sqrt(sum2 * sum3);
		    let ok = r<0?
			(r>=this.range.low.min && r<=this.range.low.max):
			(r>=this.range.high.min && r<=this.range.high.max);
                    let style = "";
                    if (ok && colors != null) {
                        let percent = (r - colorByMin) / (colorByMax - colorByMin);
                        let index = parseInt(percent * colors.length);
                        if (index >= colors.length) index = colors.length - 1;
                        else if (index < 0) index = 0;
                        style = "background-color:" + colors[index];
                    }
                    let value = r.toFixed(3);
                    let label = value;
                    if (!showValue || short) label = SPACE;
		    let cellContents = "";
		    if(ok) {
			cellContents = HU.div([CLASS, "display-correlation-element", TITLE, "&rho;(" + rowName + "," + colName + ") = " + value], label);
		    }

                    html += HU.td(["colfield", field2.getId(), "rowfield",field1.getId(), CLASS,"display-correlation-cell","align", "right", STYLE,style], cellContents);
                }
                html += HU.close(TR);
            }
            html += HU.tr([],HU.td([]) + HU.td(['colspan',(fieldCnt + 1)], HU.div([ID, this.domId(ID_LASTROW)], "")));
            html += HU.close(TABLE);
	    this.jq(ID_TABLE).html(html);
	    let _this = this;
	    let selectedRow;
	    let selectedCol;
	    this.jq(ID_TABLE).find("td").click(function() {
		let rowField = _this.getFieldById(null, $(this).attr("rowfield"));
		let colField = _this.getFieldById(null, $(this).attr("colfield"));
		let tds = _this.jq(ID_TABLE).find("td");
		if(rowField) {
		    tds.removeClass("display-correlation-row-cell-highlight");
		    if(rowField != selectedRow) {
			selectedRow = rowField;
			_this.jq(ID_TABLE).find(".display-correlation-cell[rowfield='" + rowField.getId()+"']").addClass("display-correlation-row-cell-highlight");
		    }  else {
			selectedRow = null;
		    }

		}
		if(colField) {
		    tds.removeClass("display-correlation-col-cell-highlight");
		    if(colField != selectedCol) {
			selectedCol = colField;
			_this.jq(ID_TABLE).find(".display-correlation-cell[colfield='" + colField.getId()+"']").addClass("display-correlation-col-cell-highlight");
		    }  else {
			selectedCol = null;
		    }



		}

	    });
	    this.displayColorTable(colors, ID_LASTROW, colorByMin, colorByMax);
	}
    });
}








function RamaddaRecordsDisplay(displayManager, id, properties, type) {
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, DISPLAY_RECORDS, properties);
    let myProps = [
	{label:'Records'},
	{p:'maxHeight',ex:'400px'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {

        needsData: function() {
            return true;
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        defaultSelectedToAll: function() {
            return true;
        },
        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        updateUI: function(reload) {
            SUPER.updateUI.call(this,reload);
            let records = this.filterData();
            if (!records) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
	    this.records = records;
	    let _this = this;
            let fields = this.getSelectedFields(this.getData().getRecordFields());
            let html = "";
            for (let rowIdx = 0; rowIdx < records.length; rowIdx++) {
		let div = "";
                let tuple = this.getDataValues(records[rowIdx]);
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    let v = tuple[field.getIndex()];
		    if(v.getTime) v = this.formatDate(v);
                    div += HU.b(field.getLabel()) + ": " + v + "<br>" +"\n";
                }
                html += HU.div([CLASS,"display-records-record",RECORD_INDEX,rowIdx,RECORD_ID, records[rowIdx].getId()], div);
            }
            let height = this.getProperty("maxHeight", "400px");
            if (!height.endsWith("px")) {
                height = height + "px";
            }
            this.setContents(HU.div([STYLE, HU.css('max-height', height,'overflow-y','auto')], html));
	    this.find(".display-records-record").click(function() {
		let record = _this.records[$(this).attr(RECORD_INDEX)];
		if(record) {
		    _this.propagateEventRecordSelection({highlight:true,record: record});
		}

	    });
        },
        handleEventRecordSelection: function(source, args) {
            //                this.lastHtml = args.html;
            //                this.setContents(args.html);
        }
    });
}


function RamaddaStatsDisplay(displayManager, id, properties, type) {
    let dflt = Utils.isDefined(properties["showDefault"]) ? properties["showDefault"] : true;
    $.extend(this, {
        showMin: dflt,
        showMax: dflt,
        showAverage: dflt,
        showStd: dflt,
        showCount: dflt,
        showTotal: dflt,
        showPercentile: dflt,
        showMissing: dflt,
        showUnique: dflt,
        showType: dflt,
        showText: dflt,
    });
    const SUPER = new RamaddaFieldsDisplay(displayManager, id, type || DISPLAY_STATS, properties);
    if (!type)
        addRamaddaDisplay(this);
    let myProps = [
	{label:'Summary Statistics'},
	{p:'showMin',ex:'true'},
	{p:'showMax',ex:'true'},
        {p:'showAverage',ex:'true'},
        {p:'showStd',ex:'true'},
        {p:'showPercentile',ex:'true'},
        {p:'showCount',ex:'true'},
        {p:'showTotal',ex:'true'},
        {p:'showPercentile',ex:'true'},
        {p:'showMissing',ex:'true'},
        {p:'showUnique',ex:'true'},
        {p:'showType',ex:'true'},
        {p:'showText',ex:'true'},
	{p:'doValueSelection',ex:'true'}

    ];

    defineDisplay(this, SUPER, myProps, {
        "map-display": false,
        needsData: function() {
            return true;
            //                return this.getProperty("loadData", false) || this.getCreatedInteractively();
        },
        handleEventPointDataLoaded: function(source, pointData) {
            if (!this.needsData()) {
                if (this.dataCollection == null) {
                    this.dataCollection = source.dataCollection;
                    this.updateUI();
                }
            }
        },
        getDefaultSelectedFields: function(fields, dfltList) {
            if (dfltList != null && dfltList.length > 0) {
                return dfltList;
            }
            let tuples = this.getStandardData(null, {
                includeIndex: false
            });
            let justOne = (tuples.length == 2);

            //get the numeric fields
            let l = [];
            for (i = 0; i < fields.length; i++) {
                let field = fields[i];
                if (!justOne && (!this.showText && !field.isNumeric())) continue;
                let lbl = field.getLabel().toLowerCase();
                if (lbl.indexOf("latitude") >= 0 || lbl.indexOf("longitude") >= 0) {
                    continue;
                }
                l.push(field);
            }
            return l;
        },

        getFieldsToSelect: function(pointData) {
            return pointData.getRecordFields();
        },
        defaultSelectedToAll: function() {
            return true;
        },
        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        updateUI: function(args) {
            SUPER.updateUI.call(this,args);
            if (!this.hasData()) {
                this.setDisplayMessage(this.getLoadingMessage());
                return;
            }
            let dataList = this.getStandardData(null, {
                includeIndex: false
            });
            let allFields = this.dataCollection.getList()[0].getRecordFields();
            this.allFields = allFields;
            let fields = this.getSelectedFields([]);
            let fieldMap = {};
            let stats = [];
            let justOne = (dataList.length == 2);
            for (let rowIdx = 1; rowIdx < dataList.length; rowIdx++) {
                let tuple = this.getDataValues(dataList[rowIdx]);
                if (rowIdx == 1) {
                    for (let col = 0; col < tuple.length; col++) {
                        stats.push({
                            isNumber: false,
                            count: 0,
                            min: Number.MAX_SAFE_INTEGER,
                            uniqueMap: {},
                            unique: 0,
                            std: 0,
                            max: Number.MIN_SAFE_INTEGER,
                            total: 0,
                            numMissing: 0,
                            numNotMissing: 0,
                            type: null,
                            values: []
                        });
                    }
                }
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    let col = field.getIndex()
                    stats[col].type = field.getType();
                    let v = tuple[col];
                    if (v) {
                        if (!Utils.isDefined(stats[col].uniqueMap[v])) {
                            stats[col].uniqueMap[v] = 1;
                            stats[col].unique++;
                        } else {
                            stats[col].uniqueMap[v]++;
                        }
                    }
                    stats[col].isNumber = field.isNumeric();
                    stats[col].count++;
                    if (v == null) {
                        stats[col].numMissing++;
                    } else {
                        stats[col].numNotMissing++;
                    }
                    if (v && (typeof v == 'number')) {
                        let label = field.getLabel().toLowerCase();
                        if (label.indexOf("latitude") >= 0 || label.indexOf("longitude") >= 0) {
			    continue;
                        }
                        stats[col].total += v;
                        stats[col].max = Math.max(stats[col].max, v);
                        stats[col].min = Math.min(stats[col].min, v);
                        stats[col].values.push(v);
                    }
                }
            }


            if (this.showUnique) {
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    let col = field.getIndex();
                    stats[col].uniqueMax = 0;
                    stats[col].uniqueValue = "";
                    for (let v in stats[col].uniqueMap) {
                        let count = stats[col].uniqueMap[v];
                        if (count > stats[col].uniqueMax) {
                            stats[col].uniqueMax = count;
                            stats[col].uniqueValue = v;
                        }
                    }
                }
            }

            if (this.showStd) {
                for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                    let field = fields[fieldIdx];
                    let col = field.getIndex();
                    let values = stats[col].values;
                    if (values.length > 0) {
                        let average = stats[col].total / values.length;
                        let stdTotal = 0;
                        for (let i = 0; i < values.length; i++) {
                            let diff = values[i] - average;
                            stdTotal += diff * diff;
                        }
                        let mean = stdTotal / values.length;
                        stats[col].std = Math.sqrt(mean);
                    }
                }
            }
            let border = (justOne ? "0" : "1");
            let html = HU.open(TABLE, ["border", border, "bordercolor", "#ccc", CLASS, "display-stats", "cellspacing", "1", "cellpadding", "5"]);
            let dummy = [SPACE];
            if (!justOne) {
                header = [""];
                if (this.getProperty("showCount", dflt)) {
                    header.push("Count");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showMin", dflt)) {
                    header.push("Min");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showPercentile", dflt)) {
                    header.push("25%");
                    dummy.push(SPACE);
                    header.push("50%");
                    dummy.push(SPACE);
                    header.push("75%");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showMax", dflt)) {
                    header.push("Max");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showTotal", dflt)) {
                    header.push("Total");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showAverage", dflt)) {
                    header.push("Average");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showStd", dflt)) {
                    header.push("Std");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showUnique", dflt)) {
                    header.push("# Unique");
                    dummy.push(SPACE);
                    header.push("Top");
                    dummy.push(SPACE);
                    header.push("Freq.");
                    dummy.push(SPACE);
                }
                if (this.getProperty("showMissing", dflt)) {
                    header.push("Not&nbsp;Missing");
                    dummy.push(SPACE);
                    header.push("Missing");
                    dummy.push(SPACE);
                }
                html += HU.tr(["valign", "bottom"], HU.tds([CLASS, "display-stats-header", "align", "center"], header));
            }
            let cats = [];
            let catMap = {};
	    let doValueSelection = this.getProperty("doValueSelection", false);
            for (let fieldIdx = 0; fieldIdx < fields.length; fieldIdx++) {
                let field = fields[fieldIdx];
                let col = field.getIndex();
                field = allFields[col];
                let right = "";
                let total = SPACE;
                let _label = field.getLabel().toLowerCase();
                let avg = stats[col].numNotMissing == 0 ? "NA" : this.formatNumber(stats[col].total / stats[col].numNotMissing);
                //Some guess work about when to show a total
                if (_label.indexOf("%") < 0 && _label.indexOf("percent") < 0 && _label.indexOf("median") < 0) {
                    total = this.formatNumber(stats[col].total);
                }
                if (justOne) {
                    right = HU.tds(["xalign", "right"], [this.formatNumber(stats[col].min)]);
                    continue;
                }
                let values = [];
                if (!stats[col].isNumber && this.getProperty("showText", dflt)) {
                    if (this.getProperty("showCount", dflt))
                        values.push(stats[col].count);
                    if (this.getProperty("showMin", dflt))
                        values.push("-");
                    if (this.getProperty("showPercentile", dflt)) {
                        values.push("-");
                        values.push("-");
                        values.push("-");
                    }
                    if (this.getProperty("showMax", dflt))
                        values.push("-");
                    values.push("-");
                    if (this.getProperty("showAverage", dflt)) {
                        values.push("-");
                    }
                    if (this.getProperty("showStd", dflt)) {
                        values.push("-");
                    }
                    if (this.getProperty("showUnique", dflt)) {
                        values.push(stats[col].unique);
                        values.push(stats[col].uniqueValue);
                        values.push(stats[col].uniqueMax);
                    }
                    if (this.getProperty("showMissing", dflt)) {
                        values.push(stats[col].numNotMissing);
                        values.push(stats[col].numMissing);
                    }
                } else {
                    if (this.getProperty("showCount", dflt)) {
                        values.push(stats[col].count);
                    }
                    if (this.getProperty("showMin", dflt)) {
			let s=this.formatNumber(stats[col].min);
                        values.push(s);
                    }
                    if (this.getProperty("showPercentile", dflt)) {
                        let range = stats[col].max - stats[col].min;
			let tmp =p=> {
                            let s = this.formatNumber(stats[col].min + range * p);
			    if(doValueSelection) {
				s = HU.span([CLASS,"display-stats-value","data-type", "percentile","data-value", p],s);
			    }
                            values.push(s);
			}
			let percs = [.25,.5,.75];
			percs.map(v=>tmp(v));
                    }
                    if (this.getProperty("showMax", dflt)) {
			let s=this.formatNumber(stats[col].max);
                        values.push(s);
                    }
                    if (this.getProperty("showTotal", dflt)) {
                        values.push(total);
                    }
                    if (this.getProperty("showAverage", dflt)) {
                        values.push(avg);
                    }
                    if (this.getProperty("showStd", dflt)) {
                        values.push(this.formatNumber(stats[col].std));
                    }
                    if (this.getProperty("showUnique", dflt)) {
                        values.push(stats[col].unique);
                        if (Utils.isNumber(stats[col].uniqueValue)) {
                            values.push(this.formatNumber(stats[col].uniqueValue));
                        } else {
                            values.push(stats[col].uniqueValue);
                        }
                        values.push(stats[col].uniqueMax);
                    }
                    if (this.getProperty("showMissing", dflt)) {
                        values.push(stats[col].numNotMissing);
                        values.push(stats[col].numMissing);
                    }
                }
                right = HU.tds(["align", "right"], values);
                let align = (justOne ? "right" : "left");
                let label = field.getLabel();
                let toks = label.split("!!");
                let tooltip = "";
                tooltip += field.getId();
                if (field.description && field.description != "") {
                    tooltip += "\n" + field.description + "\n";
                }
                label = toks[toks.length - 1];
                if (field.unit && field.unit != "")
                    label = label + " [" + field.unit + "]";
                if (justOne) {
                    label += ":";
                }
                label = label.replace(/ /g, SPACE)
                let row = HU.tr([], HU.td(["align", align], field.getTypeLabel() +SPACE + HU.b(HU.span([TITLE, tooltip], label))) + right);
                if (justOne) {
                    html += row;
                } else {
                    html += row;
                }
            }
            html += HU.close(TABLE);
            this.setContents(html);
            this.initTooltip();

	    if(doValueSelection) {
		let values = this.find(".display-stats-value");
		values.each(function() {
		    let type  = $(this).attr("data-type");
		    let value  = $(this).attr("data-value");
		    let links = SPACE + HU.getIconImage("fa-less-than",[TITLE,"Filter other displays",
									CLASS,"display-stats-value-link","data-type",type,"data-value",value],
							[STYLE,HU.css('font-size','8pt')]);

		    $(this).append(links);
		});
		values = this.find(".display-stats-value-link");
		values.each(function() {
		    
		});



	    }


            //always propagate the event when loaded
	    let record = this.dataCollection.getList()[0];
	    this.displayManager.propagateEventRecordSelection(this,
							      record, {
								  index: 0
							      });
        },
        handleEventRecordSelection: function(source, args) {
            //                this.lastHtml = args.html;
            //                this.setContents(args.html);
        }
    });
}



function RamaddaCooccurenceDisplay(displayManager, id, properties) {
    const ID_TABLE = "table";
    const ID_HEADER = "coocheader";
    const ID_SORTBY = "sortby";
    const SUPER = new RamaddaDisplay(displayManager, id, DISPLAY_COOCCURENCE, properties);
    let myProps = [
	{label:'Cooccurence'},
	{p:'sourceField',ex:''},
	{p:'targetField',ex:''},
	{p:'colorBy',ex:''},
	{p:'directed',ex:'false'},
	{p:'missingBackground',ex:'#eee'},
	{p:'showSortBy',ex:'false'},
	{p:'sortBy',ex:'weight'},
	{p:'minWeight',ex:''},
	{p:'topSpace',ex:'50px'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },

	getHeader2:function() {
	    let html = SUPER.getHeader2.call(this);
	    let weightField = this.getFieldById(null, this.getProperty("colorBy","weight"));
	    if(weightField && this.getProperty("showSortBy",true)) {
		let enums = [["name","Name"],["weight","Weight"]];
		html +=  HU.div([STYLE,HU.css('display','inline-block')], "Sort by: " + HU.select("",[ID,this.domId(ID_SORTBY)],enums,this.getProperty("sortBy","")))+SPACE2;
		
	    }
	    return html;

	}, 
	initHeader2:function() {
	    let _this = this;
	    this.jq(ID_SORTBY).change(function() {
		_this.setProperty("sortBy",$(this).val());
		_this.updateUI();
	    });
	},
        updateUI: function() {
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let html = HU.div([ID, this.domId(ID_HEADER)]) +
		HU.div([ID, this.domId(ID_TABLE)]);
	    this.setContents(html);


	    let sourceField = this.getFieldById(null, this.getProperty("sourceField","source"));
	    let targetField = this.getFieldById(null, this.getProperty("targetField","target"));
	    let weightField = this.getFieldById(null, this.getProperty("colorBy","weight"));

	    if(sourceField==null || targetField==null) {
		this.setDisplayMessage("No source/target fields specified");
		return;
	    }
	    let colors = this.getColorTable();
	    if(!colors) colors = Utils.getColorTable("blues",true);
	    let colorBy = this.getColorByInfo(records,null,null,colors);
	    let names = {};
	    let nameList = [];
	    let sources = [];
	    let targets = [];
	    let links={};
	    let maxWeight = 0;
	    let sortBy  = this.getProperty("sortBy","name");
	    let directed = this.getProperty("directed",true);
	    let missing = -999999;

	    records.map(r=>{
		let source = r.getValue(sourceField.getIndex());
		let target = r.getValue(targetField.getIndex());
		let weight = missing;
		if(weightField) {
		    weight = r.getValue(weightField.getIndex());
		    maxWeight = Math.max(maxWeight, weight);
		}
		sources.push({name:source,weight:weight});
		targets.push({name:target,weight:weight});
		if(!directed) {
		    sources.push({name:target,weight:weight});
		    targets.push({name:source,weight:weight});
		    
		}
		links[source+"--" + target] = weight;
	    });
	    maxWeight = this.getProperty("maxWeight", maxWeight);
	    let sortFunc =(a,b)=>{
		if(sortBy == "name" || sortBy=="") {
		    return a.name.localeCompare(b.name);
		} else {
		    return b.weight-a.weight;
		}} 
	    sources.sort(sortFunc);
	    targets.sort(sortFunc);
	    let minWeight = this.getProperty("minWeight",missing);
	    let seen = {}
	    let tmp =[];
	    let pruneFunc = t=>{
		if(minWeight!=missing) {
		    if(t.weight==missing || t.weight<minWeight) return;
		}
		if(!seen[t.name]) {
		    seen[t.name]=true;
		    tmp.push(t.name);
		}
	    }
	    sources.map(pruneFunc);
	    sources=tmp;
	    seen = {}
	    tmp =[];
	    targets.map(pruneFunc);
	    targets = tmp;

	    let table = HU.div([STYLE,HU.css('margin-top',this.getProperty("topSpace","100px"))]) +
		HU.open(TABLE,[STYLE,HU.css('height','100%'), CLASS,'display-cooc-table', 'order',0]);
	    table += HU.open(TR,['valign','bottom']) + HU.td(['border','none']);
	    targets.map(target=>{
		target = target.replace(/ /g,SPACE).replace(/-/g,SPACE);
		table += HU.td([STYLE,HU.css('border','none'), "width","6"],HU.div([CLASS,"display-cooc-colheader"], target));
	    });

	    let missingBackground  = this.getProperty("missingBackground","#eee");
	    sources.map(source=>{
		let label =  source.replace(/ /g,SPACE);
		table += HU.open(TR,['valign','bottom']) +HU.td([STYLE,HU.css('border','none'), 'align','right'], HU.div([CLASS,"display-cooc-rowheader"], label));
		targets.map(target=>{
		    let weight = links[source+"--" + target];
		    if(!directed && !Utils.isDefined(weight))
			weight = links[target+"--" + source];
		    let style="";
		    if(weight) {
			if(weight == missing || maxWeight == 0) 
			    style = HU.css('background','#ccc');
			else {
			    if(colorBy.index>=0) {
				color =  colorBy.getColor(weight);
				style = HU.css('background',color);
			    }
			    //			    let percent = weight/maxWeight;
			    //			    let index = parseInt(percent*colors.length);
			    // 			    if(index>=colors.length) index=colors.length-1;
			    //			    style = "background:" + colors[index]+";";
			}
		    }  else {
			style = HU.css('background', missingBackground);
		    }
		    table+=HU.td([TITLE,source+" -> " + target+(weight>0?" " + weight:""), "width","3"],HU.div([CLASS,"display-cooc-cell",STYLE,style+HU.css('height','100%')],SPACE));
		});
		table+= HU.close(TR);
	    });

	    table+=HU.close(TR,TABLE);
	    table+=HU.div([STYLE,HU.css('margin','5px')]);
	    this.jq(ID_TABLE).html(table);
	    colorBy.displayColorTable();

	}
    })
}



function RamaddaBoxtableDisplay(displayManager, id, properties) {
    const ID_HEADER = "coocheader";
    const ID_SORTBY = "sortby";
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_BOXTABLE, properties);
    let myProps = [
	{label:'Color Boxes'},
	{p:'categoryField',ex:''},
	{p:'colorBy',ex:''},
	{p:'tableWidth',ex:'300'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },

        updateUI: function() {
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let categoryField = this.getFieldById(null, this.getProperty("categoryField","category"));
	    if(categoryField==null) {
		this.setDisplayMessage("No category field field specified");
		return;
	    }
	    let colors = this.getColorTable();
	    if(!colors) colors = Utils.getColorTable("blues",true);
	    let colorBy = this.getColorByInfo(records,null,null,colors);
	    let catMap =  {};
	    let cats = [];
	    records.forEach(r=>{
		let category = r.getValue(categoryField.getIndex());
		let value = colorBy.index>=0?r.getValue(colorBy.index):0;
		let list = catMap[category] && catMap[category].list;
		if(!list) {
		    list = [];
		    catMap[category] = {list:list, max:0};
		    cats.push(category);
		}
		catMap[category].max = Math.max(catMap[category].max,value);
		list.push(r);
	    });
	    let html = HU.open(TABLE,[CLASS,'display-colorboxes-table','cellpadding',5]);
	    let tableWidth=this.getProperty("tableWidth",300);
	    cats.sort((a,b)=>{
		return catMap[b].max - catMap[a].max;
	    });

	    cats.forEach(cat=>{
		let length = catMap[cat].list.length;
		let label = HU.span(["field-id",categoryField.getId(),
				     "field-value",cat], cat);
		let row = HU.open(TR,['valign','top'],HU.td(['align','right',CLASS,'display-colorboxes-header'],label+ "("+length+")"));
		row+=	  HU.open(TD,[WIDTH,'${tableWidth}']);
		if(colorBy.index) {
		    catMap[cat].list.sort((a,b)=>{
			return b.getData()[colorBy.index]-a.getData()[colorBy.index];
		    });
		}
		catMap[cat].list.map((record,idx)=>{
		    let color = "#ccc";
		    if(colorBy.index) {
			color =  colorBy.getColor(record.getData()[colorBy.index], record) || color;
		    }
		    row +=HU.div([TITLE,"",RECORD_ID, record.getId(), CLASS,"display-colorboxes-box",STYLE,HU.css('background', color)],"");
		});
		row+=HU.close(TD,TR);
		html+=row;
	    });

	    html +=HU.close(TABLE);
            this.displayHtml(html);
	    colorBy.displayColorTable(500);
	    if(!this.getProperty("tooltip"))
		this.setProperty("tooltip","${default}");
	    this.makeTooltips(this.find(".display-colorboxes-box"),records);
	    this.addFieldClickHandler(null, records);
	}
    })
}



function RamaddaPercentchangeDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_PERCENTCHANGE, properties);
    let myProps = [
	{label:'Percent Change'},
	{p:'template',ex:'${date1} ${date2} ${value1} ${value2} ${percent} ${per_hour} ${per_day} ${per_week} ${per_month} ${per_year}'},
	{p:'fieldLabel',ex:''},
	{p:'sortFields',ex:'false'},
	{p:'highlightPercent',ex:'50'},
	{p:'highlightPercentPositive',ex:'50'},
	{p:'highlightPercentNegative',ex:'-50'},
	{p:'highlightColor',ex:''},
	{p:'highlightColorPositive',ex:''},
	{p:'highlightColorNegative',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
            let allFields = this.getData().getRecordFields();
            let fields = this.getSelectedFields(allFields);
	    fields = this.getFieldsByType(fields, "numeric");
	    let  record1 = records[0];
	    let  record2 = records[records.length-1];
	    let template = this.getProperty("template",null);
	    let headerTemplate = this.getProperty("headerTemplate","");
	    let footerTemplate = this.getProperty("footerTemplate","");
	    let date1 = record1.getDate();
	    let date2 = record2.getDate();
	    let label1 ="Start Value";
	    let label2 ="End Value";
	    let hours = 1;
	    let days = 1;
	    let years = 1;
	    let months = 1;
	    if(date1)
		label1 = this.formatDate(date1);
	    if(date2)
		label2 = this.formatDate(date2);
	    if(date1 && date2) {
		let diff = date2.getTime() - date1.getTime();
		days = diff/1000/60/60/24;
		hours = days*24;
		years = days/365;
		months = years*12;
	    }
            let html =  "";
	    if(template) {
		html= headerTemplate;
	    } else {
		html += HU.open(TABLE, [CLASS, "stripe nowrap ramadda-table", ID, this.domId("percentchange")]);
		html += HU.open(THEAD, []);
		html += "\n";
		html += HU.tr([], HU.th([STYLE,HU.css('text-align','center')], this.getProperty("fieldLabel", "Field")) + HU.th([STYLE,HU.css('text-align','center')], label1) + HU.th([STYLE,HU.css('text-align','center')], label2)
			      + HU.th([STYLE,HU.css('text-align','center')], "Percent Change"));
		html += HU.close(THEAD);
		html += HU.open(TBODY, []);
	    }
	    let tuples= [];
	    fields.map(f=>{
		let val1 = 0;
		for(let i=0;i<records.length;i++) {
		    let val = records[i].getValue(f.getIndex());
		    if(!isNaN(val)) {
			val1 = val;
			break;
		    }
		}
		
		let val2 = 0;
		for(let i=records.length-1;i>=0;i--) {
		    let val = records[i].getValue(f.getIndex());
		    if(!isNaN(val)) {
			val2 = val;
			break;
		    }
		}

		let percent = parseInt(1000*(val2-val1)/val1)/10;
		//		val1 = record1.getValue(f.getIndex());
		//		val2 = record2.getValue(f.getIndex());
		tuples.push({field:f,val1:val1,val2:val2,percent:percent});
	    });

	    if(this.getProperty("sortFields",true)) {
		tuples.sort((a,b)=>{
		    return -(a.percent-b.percent);
		})
	    }
	    let highlightPercent = this.getProperty("highlightPercent",NaN);
	    let highlightPercentPositive = this.getProperty("highlightPercentPositive",highlightPercent);
	    let highlightPercentNegative = this.getProperty("highlightPercentNegative",-highlightPercent);
	    let highlightColor = this.getProperty("highlightColor","#ccc"||"#FFFEEC");
	    let posColor = this.getProperty("highlightColorPositive",highlightColor);
	    let negColor = this.getProperty("highlightColorNegative",highlightColor);
	    tuples.map(t=>{
		if(template) {
		    let h = template.replace("${field}", t.field.getLabel()).replace("${value1}",this.formatNumber(t.val1)).replace("${value2}",this.formatNumber(t.val2)).replace("${percent}",this.formatNumber(t.percent)).replace("${date1}",label1).replace("${date2}",label2).replace("${difference}", this.formatNumber(t.val2-t.val1));
		    
		    h = h.replace(/\${per_hour}/g,this.formatNumber(t.percent/hours));
		    h = h.replace(/\${per_day}/g,this.formatNumber(t.percent/days));
		    h = h.replace(/\${per_week}/g,this.formatNumber(t.percent/(days/7)));
		    h = h.replace(/\${per_month}/g,this.formatNumber(t.percent/months));
		    h = h.replace(/\${per_year}/g,this.formatNumber(t.percent/years));
		    html+=h;
		} else {
		    let style = "";
		    if(!isNaN(highlightPercentPositive))
			if(t.percent>highlightPercentPositive)
			    style += HU.css('background', posColor);
		    if(!isNaN(highlightPercentNegative))
			if(t.percent<highlightPercentNegative)
			    style += HU.css('background', negColor);
		    
		    html += HU.tr([STYLE,style], HU.td([], t.field.getLabel()) + 
				  HU.td(["align","right"], this.formatNumber(t.val1)) +
				  HU.td(["align","right"], this.formatNumber(t.val2))
				  + HU.td(["align","right"], t.percent+"%"));
		}
	    });

	    if(template) {
		html+= footerTemplate;
	    } else {
		html += HU.close(TBODY);
		html += HU.close(TABLE);
	    }
	    this.setContents(html); 
            HU.formatTable("#" + this.domId("percentchange"), {ordering:true
								  //scrollY: this.getProperty("tableSummaryHeight", tableHeight)
								 });
	},
    })
}



function RamaddaDatatableDisplay(displayManager, id, properties) {
    const SUPER  = new RamaddaDisplay(displayManager, id, DISPLAY_DATATABLE, properties);
    let myProps = [
	{label:'Data Table'},
	{p:'columnSelector',ex:'date_day|date_hour|date_dow|date_month|date_year'},
	{p:'selectors',ex:'date_day,date_hour,date_dow,date_month,date_year,date_fieldid'},
	{p:'columnSelector',ex:'date_day|date_hour|date_dow|date_month'},
	{p:'rowSelector',ex:'date_day|date_hour|date_dow|date_month'},
	{p:'checkedIcon',ex:'fa-checked'},
	{p:'checkedTooltipHeader',ex:'${numberChecked}'},
	{p:'dataCheckers',ex:'match|notmatch|lessthan|greaterthan|equals|notequals(field=field,value=value,label=label,enabled=false) '}, 
	{p:'showColumnSelector',ex:'false'},
	{p:'showRowSelector',ex:'false'},
	{p:'showValues',ex:'false'},
	{p:'showColors',ex:'false'},
	{p:'showRowTotals',ex:'false'},
	{p:'showColumnTotals',ex:'false'},
	{p:'slantHeader',ex:'true'}
	];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
        updateUI: function() {
            this.setDisplayMessage(this.getLoadingMessage());
	    let records = this.filterData();
	    if (!records) {
                return;
	    }  
	    let colors = this.getColorTable(true);
	    if (!colors) colors = Utils.getColorTable("blues",true);
	    let checkers = this.getDataFilters(this.getProperty("dataCheckers"));
	    let cells = {};
	    let countFields= this.getFieldsByIds(null, this.getProperty("countFields"));

	    let selectors;
	    let fieldMap = {};
	    if(this.getProperty("selectors")) {
		selectors = [];
		let labels = {"date_day":"Day","date_dow":"Day of Week","date_hour":"Hour","date_month":"Month","date_year":"Year"};
		this.getProperty("selectors").split(",").map(s=>{
		    let label = labels[s];
		    if(!label) {
			let field = this.getFieldById(null,s);
			if(field) {
			    label = field.getLabel();
			    fieldMap[s] = field;
			}
		    }
		    if(label) 
			selectors.push([s,label]);
		});
	    } else {
		selectors  =   [["date_day","Day"],["date_dow","Day of Week"],["date_hour","Hour"],["date_month","Month"],["date_year","Year"]];
	    }

	    let columnSelector = this.getProperty("columnSelector",selectors[0][0]);
	    let rowSelector = this.getProperty("rowSelector",selectors[1][0]);
	    let getValues =(s=>{
		let values = [];
		if(s =="date_dow") {
		    Utils.dayNamesShortShort.map((d,i)=>{
			values.push({id:i,label:d});
		    });
		}  else if(s =="date_hour") {
		    let tmp =["12&nbsp;AM","1","2","3","4","5","6","7","8","9","10","11",
			      "12&nbsp;PM","1","2","3","4","5","6","7","8","9","10","11"];
		    for(let i=0;i<24;i++)
			values.push({id:i,label:tmp[i]});
		}  else if(s =="date_day") {
		    for(let day=1;day<=31;day++)
			values.push({id:day,label:String(day)});
		}  else if(s =="date_month") {
		    Utils.monthNames.map((m,i)=>{
			values.push({id:i,label:m});
		    });
		}  else if(s =="date_year") {
		    let years =[];
		    let seen = {};
		    records.map(r=>{
			let year = r.getDate().getUTCFullYear();
			if(!seen[year]) {
			    years.push(year);
			    seen[year] = true;
			}
		    });
		    years.sort();
		    years.map((y,i)=>{
			values.push({id:y,label:String(y)});
		    });
		} else {
		    let field = fieldMap[s];
		    if(field) {
			let seen = {};
			let isNumber = false;
			this.getColumnValues(records, field).values.map(d=>{
			    isNumber = Utils.isNumber(d);
			    if(!Utils.isDefined(seen[d])) {
				seen[d] = true;
				values.push({id:d,label:String(d)});
			    }
			});
			values.sort((a,b) =>{
			    if(isNumber) {
				return a.id-b.id;
			    }
			    return a.label.localeCompare(b.label);
			});
		    }
		}
		return values;
	    });
	    let columns =getValues(columnSelector);
	    let rows =getValues(rowSelector);
	    let getId =((s,r,l)=>{
		if(s =="date_dow")  {
		    return l[r.getDate().getDay()].id;
		} else if(s =="date_hour") {
		    return l[r.getDate().getUTCHours()].id;
		} else if(s =="date_day") {
		    return  l[r.getDate().getUTCDate()-1].id;
		} else if(s =="date_month") {
		    return  l[r.getDate().getUTCMonth()].id;
		} else if(s =="date_year") {
		    return r.getDate().getUTCFullYear();
		} else {
		    let field = fieldMap[s];
		    if(field) {
			return r.getValue(field.getIndex());
		    }
		}
		return "null";
	    });

	    records.map((r,i)=>{
		let row =getId(rowSelector,r,rows);
		let column =getId(columnSelector,r,columns);
		let key = row+"-" +column;
		let cell = cells[key];
		if(!cell) {
		    cell = cells[key]={
			checked:[],
			row:row,
			column:column,
			count:0,
			records:[],
			countFields:{}
		    };
		    countFields.forEach(f=>{
			cell.countFields[f.getId()] = {
			    values:[],
			    counts:{}
			};
		    });
		}

		if(checkers && checkers.length>0) {
		    if(this.checkDataFilters(checkers, r)) {
			cell.checked.push(r);
		    }
		}

		countFields.forEach(f=>{
		    //f=>in_or_out
		    let v = r.getValue(f.getIndex());
		    //v=incoming or outgoing
		    let cf = cell.countFields[f.getId()];
		    if(!cf.counts[v]) {
			cf.counts[v] = 0;
			cf.values.push(v);
		    }
		    cf.counts[v]++;
		});
		cell.count++;
		cell.records.push(r);
	    });


	    let min = 0;
	    let max  = 0;
	    let cnt = 0;
	    for(a in cells) {
		let cell = cells[a];
		min = cnt==0?cell.count:Math.min(cell.count,min);
		max = cnt==0?cell.count:Math.max(cell.count,max);
		cnt++;
		//		console.log("cell: "+ cell.row +" " + cell.column +" #:" + cell.count);
		countFields.forEach(f=>{
		    let cf = cell.countFields[f.getId()];
		    cf.values.sort();
		    cf.values.forEach(v=>{
			//			console.log("\t" + v +" = " + cf.counts[v] +" " + cell.row +" " + cell.column);
		    });
		    
		});
	    }


	    let showValues = this.getProperty("showValues", true);
	    let showColors = this.getProperty("showColors", true);
	    let cellCount = columns.length;
	    let maxRowValue = 0;
	    let maxColumnValue = 0;
	    let columnTotals = {};
	    let rowTotals = {};
	    rows.map(row=>{
		let rowTotal = 0;
		columns.map(column=>{
		    let key = row.id +"-" +column.id;
		    if(cells[key]) {
			rowTotal+=cells[key].count;
		    }
		});
		rowTotals[row.id] = rowTotal;
		maxRowValue = Math.max(maxRowValue, rowTotal);
	    });
	    columns.map(column=>{
		let columnTotal = 0;
		rows.map(row=>{
		    let key = row.id +"-" +column.id;
		    if(cells[key]) {
			columnTotal+=cells[key].count;
		    }
		});
		columnTotals[column.id] = columnTotal;
		maxColumnValue = Math.max(maxColumnValue, columnTotal);
	    });

	    let showRowTotals = this.getProperty("showRowTotals",true);
	    let showColumnTotals = this.getProperty("showColumnTotals",true);
	    let width = Math.round(100/cellCount);
	    let table = "";
	    table+=HU.open('tr',['valign','bottom']) + HU.td([],"");
	    let needToRotate = this.getProperty("slantHeader",false);
	    let topSpace = 0;
	    columns.map(column=>{
		let label = column.label;
		if(label.length>15) {
		    needToRotate = true;
		    topSpace = Math.max(topSpace,Math.round(label.length*3));
		    topSpace = 80;
		}
	    });
	    
	    columns.map(column=>{
		let label = column.label;
		if(needToRotate) {
		    if(label.length>20) {
			label = label.substring(0,20)+"...";
		    }
		    label = label.replace(/ /g,SPACE).replace("-",SPACE);
		    label = HU.div(["tootltip",column.label,CLASS,"display-datatable-header-slant"],label);
		}		    
		table+=HU.td([CLASS,'display-datatable-header','align','center'],label);
	    });
	    table+=HU.close(TR);

	    rows.map(row=>{
		let name = HU.div([],row.label.replace(/ /g,SPACE));
		table+=HU.open(TR) + HU.td([CLASS,"display-datatable-name","align","right", "width","100"],name);
		columns.map(column=>{
		    let key = row.id+"-" +column.id;		    
		    let inner = "";
		    let style = "";
		    let marker = "";
		    let cell = cells[key];
		    let extra1 = "";
		    let extra2 = "";
		    if(cell) {
			if(showValues) 
			    inner = HU.div([CLASS,"display-datatable-value"],cell.count);
			extra2 = HU.div(["data-key",key,CLASS,"display-datatable-counts"]);
			if(cell.checked.length) {
			    extra1= HU.getIconImage(this.getProperty("checkedIcon","fa-check"),[TITLE,"","data-key",key,CLASS,"display-datatable-checked"]);
			}
			if(showColors) {
                            let percent = (cell.count - min) / (max - min);
                            let ctIndex = parseInt(percent * colors.length);
                            if (ctIndex >= colors.length) ctIndex = colors.length - 1;
                            else if (ctIndex < 0) ctIndex = 0;
                            style = HU.css('background-color', colors[ctIndex]);
			}
		    }
		    let cellHtml = extra1 +extra2+inner;
		    table += HU.td([CLASS,'display-datatable-cell','align','right', STYLE,style,'width',width +'%'], cellHtml);
		});
		if(showRowTotals) {
		    let total = rowTotals[row.id];
		    let dim = Math.round(total/maxRowValue*100);
		    let bar = HU.div([CLASS, "display-datatable-summary-row",STYLE,HU.css('width', dim+'px')],total);
		    table += HU.td([WIDTH,100,"valign","top"],bar);
		}
		table += HU.close(TR);
	    });
	    if(showColumnTotals) {
		table+=HU.open(TR,['valign','top']) + HU.td();
		columns.map(column=>{
		    let total = columnTotals[column.id];
		    let dim = Math.round(total/maxColumnValue*100);
		    let bar = HU.div([CLASS, "display-datatable-summary-column",STYLE,HU.css('height', dim+'px')],total);
		    table += HU.td([],bar);

		});
	    }
	    table+=HU.close(TR);
	    table+=HU.open(TR,[],HU.td());
	    table+=HU.td(['colspan',cellCount,CLASS,'display-datatable-footer','align','center',ID,this.domId("ct")]);
	    table+=HU.close(TR,TABLE);

	    if(topSpace>0) {
		table  = HU.div([STYLE,HU.css('margin-top', topSpace+'px')], table);
	    }

	    let html ="";	
	    let headerRow = HU.open(TR);
	    if(this.getProperty("showRowSelector",true)) {
		headerRow+=  HU.td([CLASS,"display-datatable-selector","width","align","center"],HU.select("",[ID,this.domId("rowSelector")],
											     selectors,
												rowSelector,15));
	    }
	    if(this.getProperty("showColumnSelector",true)) {
		headerRow+=  HU.td(["colspan",columns.length, CLASS,"display-datatable-selector","width","90%","align","center"],  HU.select("",[ID,this.domId("columnSelector")],
														selectors,
														columnSelector));
	    }

	    let mainTable = HU.open(TABLE,[STYLE,HU.css('font-size', this.getProperty("fontSize",'8pt')),CLASS,'display-colorboxes-table', 'cellpadding',0,'cellspacing',0,  WIDTH,'100%']);
	    mainTable+=HU.tr([],headerRow);
	    mainTable+=table;
//	    html+=header;
	    html+=mainTable;

	    this.setContents(html);


	    let _this = this;
	    this.jq("rowSelector").change(function() {
		_this.setProperty("rowSelector",$(this).val());
		_this.updateUI();
	    });	    
	    this.jq("columnSelector").change(function() {
		_this.setProperty("columnSelector",$(this).val());
		_this.updateUI();
	    });

	    let pieWidth=this.getProperty("pieWidth", 30);
	    this.find(".display-datatable-counts").each(function() {
		let key = $(this).attr("data-key");	
		let cell = cells[key];
		countFields.forEach(f=>{
		    let html = f.getLabel()+HU.tag(BR);
		    let cf = cell.countFields[f.getId()];
		    let data=[];
		    cf.values.forEach(v=>{
			data.push([v,cf.counts[v]]);
			html+= v +":" + cf.counts[v]+SPACE + HU.tag(BR);
		    });
		    let id = _this.domId(cell.row+"-"+cell.column+"-" + f.getId());
		    $(this).append(HU.div([CLASS,"display-datatable-piechart",ID,id,TITLE,"", STYLE,HU.css(WIDTH, pieWidth+'px',HEIGHT, pieWidth+'px')]));
		    drawPieChart(_this, "#"+id,pieWidth,pieWidth,data);
		    $("#" + id).tooltip({
			content: function() {
			    return html;
			}
		    });
		});
	    });
	    

	    this.find(".display-datatable-checked").tooltip({
		content: function() {
		    let key = $(this).attr("data-key");	
		    let cell = cells[key];
		    let checked = cell.checked;
		    if(checked.length) {
			let tooltip = _this.getProperty("tooltip","${default}");
			if(tooltip =="") return null;
			let tt = _this.getProperty("checkedTooltipHeader",HU.b('#Items: ${numberChecked}') +HU.close(BR));
			tt = tt.replace("${numberChecked}", checked.length);
			checked.map(r=>{
			    if(tt!="") tt += HU.open(DIV,[CLASS,'ramadda-hline']);
			    tt+= _this.getRecordHtml(r,null,tooltip);
			});
			return HU.div([CLASS, "display-datatable-tooltip"],tt);
		    }
		    return null;

		},
	    });
	    if(showColors) {
		this.displayColorTable(colors, "ct", min,max,{});
	    }
	},
    })
}


function RamaddaSparklineDisplay(displayManager, id, properties) {
    const ID_INNER = "inner";
    if(!properties.groupBy)
	properties.displayInline = true;
    if(!Utils.isDefined(properties.showDisplayTop))
	properties.showDisplayTop = false;
    if(!Utils.isDefined(properties.showDisplayBottom))
	properties.showDisplayBottom = false;

    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_SPARKLINE, properties);
    let myProps = [
	{label:'Sparkline'},
	{p:'showDate',ex:'true'},
	{p:'showMin',ex:'true'},
	{p:'showMax',ex:'true'},
	{p:'labelStyle',ex:''},			
	{p:'sparklineWidth',d:60},
	{p:'sparklineHeight',d:20},
	{p:'sparklineLineColor',ex:'#000'},
	{p:'sparklineBarColor',ex:'MediumSeaGreen'},
	{p:'sparklineCircleColor',ex:'#000'},
	{p:'sparklineCircleRadius',ex:'1'},
	{p:'sparklineLineWidth',ex:'1'},
	{p:'sparklineShowLines',ex:'true'},
	{p:'sparklineShowBars',ex:'true'},
	{p:'sparklineShowCircles',ex:'true'},
	{p:'sparklineShowEndPoints',ex:'true'},
	{p:'sparklineEndPointRadius',ex:'2'},
	{p:'sparklineEndPoint1Color',ex:''},
	{p:'sparklineEndPoint1Color',ex:'steelblue'},
	{p:'sparklineEndPointRadius',ex:'2'},
	{p:'sparklineEndPoint2Color',ex:''},
	{p:'sparklineEndPoint2Color',ex:'tomato'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	//Overwrite so we just have undecorated text
        getLoadingMessage: function(msg) {
	    return "Loading...";
	},
	updateUI: function() {
	    let w = this.getPropertySparklineWidth(60);
	    let h = this.getPropertySparklineHeight(20);
	    let records = this.filteredRecords = this.filterData();
	    if(!records) return;



	    let field = this.getFieldById(null, this.getProperty("field"));
	    if(field==null) {
		this.setDisplayMessage("No field specified");
		return;
	    }
	    let t1 = new Date();

	    let showDate = this.getPropertyShowDate();
	    let id = this.domId(ID_INNER);
	    let colorBy = this.getColorByInfo(records);
	    let groupByField = this.getFieldById(null,this.getProperty("groupBy"));
	    let groups = groupByField?RecordUtil.groupBy(records, this, null, groupByField):null;
	    let col = this.getColumnValues(records, field);
	    let min = col.min;
	    let max = col.max;
	    if(this.getProperty("useAllRecords")) {
		let col2 = this.getColumnValues(this.getRecords(), field);
		min  = col2.min;
		max = col2.max;
	    }

	    if(groups) {
		let labelPosition = this.getProperty("labelPosition","bottom");
		html = HU.div([ID,this.domId(ID_INNER)]);
		this.setContents(html); 
		groups.values.forEach((value,idx)=>{
		    let grecords = groups.map[value];
		    let gid = id+"_"+ +idx;
		    let c = HU.div([CLASS,"display-sparkline-sparkline",ID,gid,STYLE,HU.css('width', w+'px','height', h+  'px')]);
		    let label = HU.div([CLASS,"display-sparkline-header"], value);
		    if(labelPosition == "top")
			c = label + HU.tag(BR) + c;
		    else if(labelPosition == "bottom")
			c =  c + HU.tag(BR) + label;
		    $("#"+id).append(HU.div([STYLE,HU.css('display','inline-block','margin','4px')],c));
		    let gcol = this.getColumnValues(grecords, field);
		    drawSparkLine(this, "#"+gid,w,h,gcol.values,grecords,min,max,colorBy);
		});		
	    } else {
		html = HU.div([CLASS,"display-sparkline-sparkline",ID,this.domId(ID_INNER),STYLE,HU.css('width', w+'px','height', h+'px')]);
		if(showDate) {
		    html = HU.div([CLASS,"display-sparkline-date"],this.formatDate(records[0].getTime())) + html+
			HU.div([CLASS,"display-sparkline-date"],this.formatDate(records[records.length-1].getTime()))
		}
		let left = this.getProperty("showMin")? HU.div([CLASS,"display-sparkline-value",STYLE, this.getPropertyLabelStyle("")],this.formatNumber(col.values[0])):"";
		let right = this.getProperty("showMax",true)? HU.div([CLASS,"display-sparkline-value",STYLE, this.getPropertyLabelStyle("")],this.formatNumber(col.values[col.values.length-1])):"";
		if(left!=""  || right!="")
		    html = HU.leftCenterRight(left,html,right,"1%","99%","1%",null,"padding:2px 2px;");
		this.setContents(html); 
		drawSparkLine(this, "#"+id,w,h,col.values,records,min,max,colorBy);
	    }
	    let t2 = new Date();
//	    Utils.displayTimes("sparkline",[t1,t2],true);

	}
    });
}


function RamaddaPointimageDisplay(displayManager, id, properties) {
    if(!properties.width) properties.width="200";
    properties.displayInline = true;
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_POINTIMAGE, properties);
    let myProps = [
	{label:'Point Image'},
	{p:'cellShape',ex:'rect|circle'},
	{p:'cellSize',ex:'4'},
	{p:'cellFilled',ex:'false'},
	{p:'cellColor',ex:'false'},
	{p:'doHeatmap',ex:'true'},
	{p:'padding',ex:'5'},
	{p:'borderColor',ex:'#ccc'},
	{p:'showTooltips',ex:'false'},
	{p:'colorBy',ex:''}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER,myProps, {
        needsData: function() {
            return true;
        },
        getLoadingMessage: function(msg) {
	    return "Loading...";
	},
	findClosest: function(records, e) {
	    let closest = null;
	    let minDistace = 0;
	    let cnt = 0;
	    let seen = {};
	    //	    console.log("find closest");
	    records.map((r,i) =>{
		let coords = r[this.getId()+"_coordinates"]
		let dx = coords.x-e.offsetX;
		let dy = coords.y-e.offsetY;
		let d = Math.sqrt(dx*dx+dy*dy);
		//		if(!seen[r.getValue(0)]) {
		//		    console.log("\t" +r.getValue(0) +" cx:" + coords.x +" cy:" + coords.y+" ex:" + e.offsetX +" ey:" + e.offsetY +" dx:" +dx +" dy:" +dy +" d:" + d);
		//		    seen[r.getValue(0)]  =true;
		//		}
		if(i==0) {
		    closest = r;
		    minDistance=d;
		} else {
		    if(d<minDistance) {
			minDistance = d;
			closest=r;
			//			console.log("\tclosest:" + minDistance +" " + r.getValue(0));
		    }
		}
	    });
	    return closest;
	},
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    if(this.getProperty("borderColor")) {
		$("#"+this.getProperty(PROP_DIVID)).css("border","1px solid " + this.getProperty("borderColor"));
	    }
	    let bounds ={};
	    RecordUtil.getPoints(records, bounds);
	    let ratio = (bounds.east-bounds.west)/(bounds.north-bounds.south);
	    let style = this.getProperty("padding")?HU.css('padding',+this.getProperty("padding")+"px") : "";
	    let html = HU.div([ID,this.domId("inner"),STYLE,style]);
	    this.setContents(html); 
	    let pad = 10;
	    let w = Math.round(this.jq("inner").width());
	    let h = Math.round(w/ratio);
            let divid = this.getProperty(PROP_DIVID);
	    //	    $("#"+ divid).css("height",h+pad);
	    html = HU.div([ID,this.domId("inner"),STYLE,HU.css('width', w +'height', h+'px') + style]);
	    html = HU.div([ID,this.domId("inner")]);
	    //this.getContents().css("height",h+pad);
	    this.setContents(html); 
	    let colorBy = this.getColorByInfo(records);
	    bounds = RecordUtil.expandBounds(bounds,0.1);
	    let args =$.extend({colorBy:colorBy, w:w, h:h,cell3D:this.getProperty("cell3D"),bounds:bounds},
			       this.getDefaultGridByArgs());

	    args.doHeatmap=true;
	    let fields = this.getFields();
	    let img = Gfx.gridData(this.getId(),fields, records,args);
	    this.jq("inner").html(HU.image(img,[TITLE,"",ID,this.domId("image")]));
	    this.jq("inner").append(HU.div([ID,this.domId("tooltip"),STYLE,HU.css('z-index:','2000','display','none','position','absolute','background','#fff','border','1px solid #ccc','padding','0px')]));
	    let _this = this;
	    if(this.getProperty("showTooltips",true)) {
		this.jq("image").mouseout(function( event ) {
		    _this.jq("tooltip").hide();
		});
		this.jq("image").mousemove(function( event ) {
		    let closest = _this.findClosest(records,event);
		    if(closest) {
			let html =  HU.div([STYLE,HU.css('max-height','400px','overflow-y','auto')], _this.getRecordHtml(closest));
			_this.jq("tooltip").html(html);
			_this.jq("tooltip").show();
		    }
		});
	    }
	    this.jq("image").click(e=> {
		_this.mouseEvent = event;
		let closest = this.findClosest(records,e);
		if(closest)
		    this.propagateEventRecordSelection({record: closest});
	    });
	}
    });
}


function RamaddaCanvasDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_CANVAS, properties);
    let myProps = [
	{label:'Canvas'},
	{p:'canvasWidth',d:100,ex:"100",tt:'Canvas width'},
	{p:'canvasHeight',d:100,ex:"100",tt:'Canvas height'},
	{p:'canvasStyle',d:"",ex:"",tt:'Canvas CSS style'},
	{p:'titleTemplate',tt:'Template to show as title'},
	{p:'topTitleTemplate',tt:'Template to show as top title'},	
	{p:'urlField',tt:'Url Field'},
	{p:'iconField',tt:'Icon Field'},
	{p:'highlightStyle',tt:'Highlight Style'},
	{p:'unHighlightStyle',tt:'Unhighlight Style'},	
	{p:'canvasOrigin',d:"sw",ex:"center",tt:'Origin point for drawing glyphs'},
	{label:'label glyph',p:"glyph1",ex:"type:label,pos:sw,dx:10,dy:-10,label:field_colon_ ${field}_nl_field2_colon_ ${field2}"},
	{label:'rect glyph', p:"glyph1",ex:"type:rect,pos:sw,dx:10,dy:0,colorBy:field,width:150,height:100"},
	{label:'circle glyph',p:"glyph1",ex:"type:circle,pos:n,dx:10,dy:-10,fill:true,colorBy:field,width:20,baseWidth:5,sizeBy:field"},
	{label:'3dbar glyph', p:"glyph1",ex:"type:3dbar,pos:sw,dx:10,dy:-10,height:30,width:8,baseHeight:5,sizeBy:field"},
	{label:'gauge glyph',p:"glyph1",ex:"type:gauge,color:#000,pos:sw,width:50,height:50,dx:10,dy:-10,sizeBy:field,sizeByMin:0"},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let _this = this;
	    let records = this.filterData();
	    let fields = this.getFields();
	    if(!records) return;
	    if(records.length==0) {
		this.setDisplayMessage(this.getNoDataMessage());
		return;
	    }
	    let style = this.getPropertyCanvasStyle("");
	    let highlightStyle = this.getPropertyHighlightStyle("");
	    let unHighlightStyle = this.getPropertyUnHighlightStyle("");
	    let columns = this.getProperty("columns");
	    let html = "";
	    let canvasWidth = this.getPropertyCanvasWidth();
	    let canvasHeight = this.getPropertyCanvasHeight();
	    let titleTemplate= this.getPropertyTitleTemplate();
	    let topTitleTemplate= this.getPropertyTopTitleTemplate();
	    let urlField = this.getFieldById(null,this.getPropertyUrlField());
	    let iconField = this.getFieldById(null,this.getPropertyIconField());	    
	    let doingHighlight = this.getFilterHighlight();
	    records.forEach((record,idx)=>{
		let highlight =  record.isHighlight(this);
		let cid = this.domId("canvas_" + idx);
		let canvasClass = "display-canvas-canvas";
		let canvasStyle = style;
		if(doingHighlight) {
		    if(highlight) {
			canvasClass+= " display-canvas-canvas-highlight ";
			canvasStyle+= " " + highlightStyle;
		    } else {
			canvasClass+= " display-canvas-canvas-unhighlight ";
			canvasStyle+= " " + unHighlightStyle;
		    }
		}

		let c = HU.tag("canvas",[CLASS,canvasClass, STYLE,canvasStyle, 
					 WIDTH,canvasWidth,HEIGHT,canvasHeight,ID,cid]);
		let icon = iconField? HU.image(record.getValue(iconField.getIndex()))+"&nbsp;":"";
		let topTitle  = topTitleTemplate?
		    HU.div([CLASS,"display-canvas-title"],
			   icon+this.getRecordHtml(record, null, topTitleTemplate)):icon;
		let title  = titleTemplate?
		    HU.div([CLASS,"display-canvas-title"], 
			   this.getRecordHtml(record, null, titleTemplate)):"";	
		let div =  HU.div([TITLE,"",CLASS,"display-canvas-block", RECORD_INDEX,idx,RECORD_ID, record.getId()], topTitle+c+title);
		if(urlField) {
		    let url = record.getValue(urlField.getIndex());
		    if(Utils.stringDefined(url))
			div = HU.href(url,div);
		}
		html+=div;
	    });
	    this.setContents(html);
	    let glyphs=[];
	    let cnt = 1;
	    while(cnt<11) {
		let attr = this.getProperty("glyph" + (cnt++));
		if(!attr)
		    continue;
		glyphs.push(new Glyph(this,1.0, fields,records,{
		    canvasWidth:canvasWidth,
		    canvasHeight: canvasHeight
		},attr));
	    }
	    let opts = {};
	    let originX = 0;
	    let originY=this.getPropertyCanvasOrigin()=="center"?canvasHeight/2:canvasHeight;
	    records.forEach((record,idx)=>{
		let cid = this.domId("canvas_" + idx);
		let canvas = document.getElementById(cid);
		let ctx = canvas.getContext("2d");
		glyphs.forEach(glyph=>{
		    glyph.draw(opts, canvas, ctx, originX,originY,{record:record});
		});
	    });
	    let blocks = this.find(".display-canvas-block");
	    this.makeTooltips(blocks,records,null,"${default}");
	}
    });
}


function RamaddaFieldtableDisplay(displayManager, id, properties) {
    const ID_TABLE = "fieldtable";
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_FIELDTABLE, properties);
    let myProps = [
	{label:'Field Table'},
	{p:'field',ex:''},
	{p:'labelField',ex:'field'},
	{p:'columnWidth',ex:'150'},
	{p:'tableHeight',ex:'300'},
	{p:'markerShape',ex:'circle|rect|triangle|bar|arrow|dart|bar'},
	{p:'markerSize',ex:'16'},
	{p:'markerFill',ex:'#64CDCC'},
	{p:'markerStroke',ex:'#000'}
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
	    if(fields.length==0) 
		fields = this.getFieldsByType(null, "numeric");
	    let labelField = this.getFieldById(null, this.getProperty("labelField"));
	    if(!labelField) labelField = this.getFieldsByType(null, "string")[0];
	    let html = HU.open(TABLE,[CLASS, "", "border",0,ID,this.domId(ID_TABLE)]);
	    html += HU.open(THEAD);
	    let width = this.getProperty("columnWidth",150)
	    html += HU.open(TR,[]);
	    html+=HU.td(["width",width],
			HU.div([CLASS,"display-fieldtable-header"],labelField?labelField.getLabel():""));
	    let columns = {};
	    fields.forEach(f=>{
		columns[f.getId()] = this.getColumnValues(records, f);
	    });

	    fields.forEach(f=>{
		html+=HU.th(["width",width],HU.div([CLASS,"display-fieldtable-header"],f.getLabel()));
	    });
	    html += HU.close(TR,THEAD);
	    html += HU.open(TBODY);


	    let shape = this.getProperty("markerShape","bar");
	    let canvasInfo = [];
	    let colorBys = {};
	    let cnt = 0;
	    let cw = this.getProperty("markerSize",16);

	    fields.forEach(f=>{
		colorBys[f.getId()] = this.getColorByInfo(records,f);
	    });

	    records.forEach((r,idx)=>{
		let label  = labelField?r.getValue(labelField.getIndex()):"#"+(idx+1);
		let hdrAttrs = [CLASS,"display-fieldtable-rowheader"];
		if(labelField) {
		    hdrAttrs.push("field-id");
		    hdrAttrs.push(labelField.getId());
		    hdrAttrs.push("field-value");
		    hdrAttrs.push(r.getValue(labelField.getIndex()));
		}
		html += HU.open(TR,["valign","center",RECORD_INDEX,idx,RECORD_ID, r.getId(),CLASS,"display-fieldtable-row"]);
		html+=HU.td([STYLE,HU.css('vertical-align','center'),'align','right'],HU.div(hdrAttrs,label));
		fields.forEach(f=>{
		    let v = r.getValue(f.getIndex());
		    let c = columns[f.getId()];
		    let contents = "";
		    if(isNaN(v) || c.min == c.max) return;
		    let perc = 100*(v-c.min)/(c.max-c.min);
		    let cid = this.domId("cid" + (cnt++));
		    let cinfo = {
			id: cid,
			v: v,
			percent: perc,
			field:f,
			record:r,
			colorBy: colorBys[f.getId()]
		    };
		    canvasInfo.push(cinfo);
		    let canvasWidth = cw;
		    let left =  perc+"%";
		    if(shape == "bar") {
			canvasWidth = perc*width;
			left = 0;
		    }
		    let cstyle = HU.css('position','absolute','top','0%','left',left,'margin-top','-' + (cw/2)+'px');
		    let inner = HU.tag("canvas",[TITLE,"Value:" + v +"   Range:" + c.min +" - " + c.max,STYLE,cstyle, 
						 "width",canvasWidth,"height",cw,ID,cid]);
		    contents +=HU.div([STYLE,HU.css('position','absolute','left','0px','right', cw+'px')],
				      inner);
		    html+=HU.td(["data-order", v, STYLE,HU.css('vertical-align','middle'),ALIGN,"right",TITLE, "Range:" + c.min +" - " + c.max],HU.div([STYLE,"position:relative;width:"+width+"px;" + "height:1px;margin-left:10px; margin-right:10px;border:1px solid #ccc;"],contents));
		    
		});
		html += HU.close(TR);
	    });

	    html += HU.close(TBODY);
	    html += HU.open(TFOOT);
	    html+=HU.open(TR);
	    html+=HU.td([],"");
	    fields.forEach((f,idx)=>{
		html+=HU.td([],HU.div([STYLE,HU.css('max-width', width+'px','overflow-x','auto'),ID, this.domId("footer-" + idx)],""));
	    });
	    html+=HU.close(TR);
	    html += HU.close(TFOOT);

	    html+=HU.close(TABLE);
	    this.setContents(html); 
	    let opts = {
		ordering:true
	    };
	    if(this.getProperty("tableHeight")) {
		opts.scrollY = this.getProperty("tableHeight");
	    }
	    if(this.getProperty("showColorTable")) {
		fields.forEach((f,idx)=>{
		    let colorBy = colorBys[f.getId()];
		    if(colorBy.index<0) return;
		    let domId = "footer-" + idx;
		    colorBy.displayColorTable(null,false,domId);
		});
	    }

            HU.formatTable("#" + this.domId(ID_TABLE), opts);
	    let rows = this.find(".display-fieldtable-row");
	    this.addFieldClickHandler(null, records,true);
	    let markerFill = this.getProperty("markerFill","#64CDCC");
	    let markerStroke = this.getProperty("markerStroke","#000");
	    canvasInfo.forEach(c=>{
		let canvas = document.getElementById(c.id);
		let ctx = canvas.getContext("2d");
		ctx.strokeStyle =markerStroke;
		ctx.fillStyle=c.colorBy.getColorFromRecord(c.record, markerFill);
		if(shape=="circle") {
		    ctx.beginPath();
		    ctx.arc(cw/2, cw/2, cw/2, 0, 2 * Math.PI);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="rect") {
		    ctx.fillRect(0,0,cw,cw);
		    ctx.strokeRect(0,0,cw,cw);
		} else if(shape=="bar") {
		    ctx.fillRect(0,0,c.percent/100*width,cw);
		    ctx.strokeRect(0,0,c.percent/100*width,cw);
		} else if(shape=="line") {
		    ctx.fillRect(cw/2-2,0,4,cw);
		} else if(shape=="triangle") {
		    ctx.beginPath();
		    ctx.moveTo(cw/2,0);
		    ctx.lineTo(cw,cw);
		    ctx.lineTo(0,cw);
		    ctx.lineTo(cw/2,0);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="dart") {
		    ctx.beginPath();
		    ctx.moveTo(1,0);
		    ctx.lineTo(cw-1,0);
		    ctx.lineTo(cw/2,cw/2);
		    ctx.lineTo(1,0);
		    ctx.fill();
		    ctx.stroke();
		} else if(shape=="arrow") {
		    ctx.beginPath();
		    ctx.moveTo(0,0);
		    ctx.lineTo(cw/2,cw/2);
		    ctx.lineTo(cw-1,0);
		    ctx.stroke();

		}
		
	    });

	}
    });
}



function RamaddaDotstackDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, "dotstack", properties);
    let myProps = [
	{label:'Dot Stack'},
	{p:'categoryField',ex:'field'},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let idToIndex = {};
	    records.forEach((r,idx)=>{
		idToIndex[r.getId()] = idx;
	    });
	    let hor = this.getProperty("orientation","horizontal") == "horizontal";
	    let categoryField = this.getFieldById(null, this.getProperty("categoryField"));
	    let html = "";
	    let groups = RecordUtil.groupBy(records, this, null, categoryField);
	    let colorBy = this.getColorByInfo(records);
	    let w = this.getProperty("boxWidth",4);
	    let cols = this.getProperty("boxColumns",10);
	    let xcnt = 0;
	    groups.values.sort((a,b)=>{
		return groups.map[b].length-groups.map[a].length;
	    });

	    groups.values.forEach((value,idx)=>{
		let rows = [];
		let row = [];
		rows.push(row);
		let grecords = groups.map[value];
		let col=0;
		grecords.forEach(r=>{
		    if(row.length>cols) {
			row=[];
			rows.push(row);
		    }
		    let c = colorBy.getColorFromRecord(r,"blue");
		    let box = HU.div(
			[TITLE,"", RECORD_ID, r.getId(),RECORD_INDEX,idToIndex[r.getId()],CLASS, "display-dotstack-dot",STYLE,HU.css('width', w+'px','height', w +'px','background', c)],"");
		    row.push(box);
		});
		html += HU.open(DIV,[CLASS,"display-dotstack-block"]);
		html+=HU.div([],this.getProperty("labelTemplate","${count}").replace("${count}", grecords.length));
		html += HU.open(TABLE);
		for(let i=rows.length-1;i>=0;i--) {
		    html += HU.tr([],HU.tds([],rows[i]));
		}
		html += HU.close(TABLE);
		html +=value;
		html += HU.close(DIV);
	    });
	    this.setContents(html); 
	    let dots = this.find(".display-dotstack-dot");
	    this.addFieldClickHandler(dots,records,false);
	    this.makeTooltips(dots,records,null,"${default}");
	    if(this.getProperty("tableHeight")) {
		opts.scrollY = this.getProperty("tableHeight");
	    }
	    if(this.getProperty("showColorTable")) {
		colorBy.displayColorTable(null,false,domId);
	    }
	}
    });
}


function RamaddaDotbarDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, "dotbar", properties);
    $.extend(this, SUPER);
    addRamaddaDisplay(this);
    let myProps = [
	{label:'Dot Bar'},
	{p:'keyField'},
	{p:'dotSize',d:16}
    ];
    this.defineSizeByProperties();
    defineDisplay(this, SUPER, myProps, {
        needsData: function() {
            return true;
        },
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let keyField = this.getFieldById(null,this.getPropertyKeyField());
	    let fields = this.getFieldsByIds(null,this.getPropertyFields());
 	    if(fields.length==0) {
		fields = this.getPointData().getRecordFields();
	    }
	    let dotSize = this.getPropertyDotSize();
	    let sizeBy = new SizeBy(this, this.getProperty("sizeByAllRecords",true)?this.getData().getRecords():records);
	    let size = dotSize;
	    let cols = {};
	    let html = HU.open(TABLE,['width','100%']);
	    let t1 = new Date();
	    let selectedRecord;
	    let maxHeight = dotSize;
	    if(sizeBy.field)
		maxHeight=2*sizeBy.getMaxSize();
	    fields.forEach((f,idx)=>{
		if(!f.isFieldNumeric()) return;


		let cb = new  ColorByInfo(this,  fields, records, null,null, null, null,f);
		let cid = this.domId("dots"+idx);
		let column = this.getColumnValues(records, f);
		html += HU.open(TR, [VALIGN,'center']);
		html += HU.td([WIDTH,'10%', ALIGN,'right'],  HU.div([STYLE,HU.css('margin-right','8px')], f.getLabel().replace(/ /g,SPACE)));
		html += HU.td([ALIGN,'right',WIDTH,'5%'],HU.div([STYLE, 'margin-right:10px;'],this.formatNumber(column.min)));
		html +=HU.open(TD);
		html+= HU.open(DIV,[STYLE, HU.css(HEIGHT,HU.getDimension(maxHeight), WIDTH,'100%','position','relative','margin-top','4px')]);
		html+=HU.div([STYLE,HU.css('position','absolute','left','0px','right','0px','top','50%','border-top','1px solid #ccc')]);
		html+=SPACE;
		records.forEach((r,idx2)=>{
		    let v = r.getValue(f.getIndex());
		    let c = cb.getColor(v,r);
		    let darkC = Utils.pSBC(-0.25,c);
		    if(column.min == column.max) return;
		    let perc = (v-column.min)/(column.max-column.min);
		    let clazz = 'display-dotbar-dot';
		    let selected = false;
		    let style = "";
		    if(keyField && this.selectedKey) {
			if(this.selectedKey == r.getValue(keyField.getIndex())) {
			    selected = true;
			}
		    } else if(idx2==this.selectedIndex) {
			selected = true;
		    }
		    let dotBorder = "2px solid " + darkC;
		    if(this.selectedIndex>=0) {
			if(!selected) {
			    dotBorder = "1px solid " + darkC;
			    c = "rgba(200,200,200,0.2)";
			} else {
			    dotBorder = "1px solid #000";
			}
		    }
		    if(selected) {
			selectedRecord = r;
			clazz += " display-dotbar-dot-select";
		    } else {
			if(this.getFilterHighlight()) {
			    if(!r.isHighlight(this)) {
				style = HU.css('z-index','10','border','1px solid #aaa');
			    }
			}
		    }
		    perc *=100;
		    let size = dotSize;
		    if(sizeBy.field) {
			size  = 2*sizeBy.getSize(r.getData(), dotSize);
			if(size<0) return;
			style+=HU.css(HEIGHT,HU.getDimension(size),WIDTH,HU.getDimension(size));
		    }
		    let top = maxHeight/2-size/2;
		    html +=  HU.span([RECORD_INDEX,idx2,RECORD_ID, r.getId(),CLASS,clazz,STYLE,HU.css('border',dotBorder, "background",c,"position",'absolute','top',HU.getDimension(top),'left', perc+'%')+style, RECORD_INDEX,idx2, TITLE,""]); 
		});

		html += HU.close(DIV,TD);
		html += HU.td([WIDTH, (dotSize*2)]);
		html += HU.td([ALIGN,"right", WIDTH,"5%"],HU.div([STYLE,HU.css('margin-left','10px')],this.formatNumber(column.max)));
		html+=HU.close(TR);
	    });
	    let t2 = new Date();
	    html+=HU.close(TABLE);
	    this.setContents(html); 
	    let t3 = new Date();
	    let dots = this.find(".display-dotbar-dot");
	    let t4 = new Date();
	    let _this = this;
	    dots.mouseleave(function() {
		dots.removeClass("display-dotbar-dot-highlight");
	    });
	    dots.mouseover(function() {
		let idx = $(this).attr(RECORD_INDEX);
		dots.removeClass("display-dotbar-dot-highlight");
		_this.find("[" + RECORD_INDEX+"=\"" + idx+"\"]").addClass( "display-dotbar-dot-highlight");
	    });
	    dots.click(function() {
		let idx = $(this).attr(RECORD_INDEX);
		let record = records[idx];
		if(!record) return;
		dots.removeClass("display-dotbar-dot-select");
		if(_this.selectedIndex ==  idx) {
		    _this.selectedIndex =  -1;
		    _this.updateUI();
		    return;
		}
		_this.selectedIndex =  idx;
		if(keyField)
		    _this.selectedKey = record.getValue(keyField.getIndex());
		_this.find("[" + RECORD_INDEX+"=\"" + idx+"\"]").addClass( "display-dotbar-dot-select");
		_this.hadClick = true;
		_this.propagateEventRecordSelection({record: record});
		_this.updateUI();
	    });	    //Do this later so other displays get this after they apply their data filter change
	    if(selectedRecord){
		setTimeout(()=>{
		    this.propagateEventRecordSelection({record: selectedRecord});
		},10);
	    }
	    this.makeTooltips(dots,records,null);
	    let t5 = new Date();
	    //	    Utils.displayTimes("t",[t1,t2,t3,t4,t5]);

	}
    });
}




function RamaddaDategridDisplay(displayManager, id, properties) {
    const SUPER =  new RamaddaFieldsDisplay(displayManager, id, DISPLAY_DATEGRID, properties);
    $.extend(this, SUPER);
    addRamaddaDisplay(this);
    let myProps = [
	{label:'Date Box'},
	{p:'groupField'},
	{p:'boxSize',d:16},
	{p:'showStats',w:'true',d:true,tt:'show starts per row'},
	{p:'showTotal',w:'true',d:true,tt:'show the totals'},
	{p:'showMin',w:'true',d:true,tt:'show min'},
	{p:'showMax',w:'true',d:true,tt:'show max'},
	{p:'showAverage',w:'true',d:false,tt:'show average'},				
	{p:'leftWidth',tt:'width of left column',d:'100px'},
	{p:'rightWidth',tt:'width of right column',d:'100px'},
 	{p:'leftLabel',tt:'Label for the left column'},
 	{p:'rightLabel',tt:'Label for the left column',d:'Total/Min/Max'},	
	{p:'dateHeaderStyle',tt:'Style to use for the date header'},
	{p:'dateStride',d:-1,tt:'The stride in hours to display the date label'},	
	{p:'numLabels',d:8,tt:'Hour many date labels to show if no dateStride given'},	
	{p:'boxStyle',tt:'Style to use for color boxes'},
	{p:'leftStyle',tt:'Style to use for left column'},
	{p:'rightStyle',tt:'Style to use for right column'},			

    ];
    this.defineSizeByProperties();
    defineDisplay(this, SUPER, myProps, {
	updateUI: function() {
	    let records = this.filterData();
	    if(!records) return;
	    let groupField = this.getFieldById(null,this.getPropertyGroupField());
	    let size = this.getBoxSize();
	    let cats =[];
	    let colorBy = this.getColorByInfo(records);
	    let minDate= null, maxDate=null;
	    records.forEach(r=>{
		if(!minDate) {
		    minDate = maxDate = r.getDate();
		} else {
		    let d = r.getDate();
		    minDate = d.getTime()<minDate.getTime()?d:minDate;
		    maxDate = d.getTime()>maxDate.getTime()?d:maxDate;		    
		}
		let v = r.getValue(groupField.getIndex());
		let cat = cats[v];
		if(cat == null) {
		    cat = {
			records:[]
		    };
		    cats[v] = cat;
		}
		cat.records.push(r);
	    });
	    if(!this.dateFormat)
		this.dateFormat =  this.getProperty("dateFormat", "ddd mm/dd");
	    let showStats = this.getShowStats();
	    let leftWidth = HU.getDimension(this.getLeftWidth());
	    let rightWidth = HU.getDimension(this.getRightWidth());	    
	    let html = "";
	    let width = 400;
	    let dateRange = maxDate.getTime()-minDate.getTime();

	    let scaleX = d=>{
		return  (d.getTime()-minDate.getTime())/dateRange;
	    };
	    let height = "1.5em";
	    html="<div class=display-dategrid-table><table width=100% border=0 cellpadding=0 cellspacing=0>";

	    html+="<tr><td width='" + leftWidth+"'>" + HU.div([CLASS,"display-dategrid-header"],this.getLeftLabel(groupField.getLabel())) +"</td>";
	    let dateHeaderStyle = this.getDateHeaderStyle("background:#eee;border-bottom:1px solid #888;");
	    let boxStyle = this.getBoxStyle("");
	    let leftStyle = this.getLeftStyle("");
	    let rightStyle = this.getRightStyle("");	    	    
	    let dateHeader = HU.open("div",[CLASS,'display-dategrid-dateheader',STYLE,dateHeaderStyle]) + SPACE;
	    let date  = minDate;
	    let dateStride = this.getDateStride(-1);
	    let dateDelta;
	    if(dateStride>0) {
		dateDelta = dateStride*1000*60*60;
	    } else {
		let hours = Math.round((maxDate.getTime()- minDate.getTime())/1000/60/60);
		let numLabels = this.getNumLabels();
		let hoursPerLabel =Math.round(hours/numLabels);
		dateDelta = hoursPerLabel*1000*60*60;
	    }
	    let rem =  minDate.getTime()%dateDelta;
	    date = new Date(minDate.getTime()-rem+dateDelta);

	    while(date.getTime()<=maxDate.getTime()) {
		let perc = (100*scaleX(date))+"%";
		let style = HU.css("left",perc,"top","0%","transform","translate(-50%, 0%)");
		dateHeader+=HU.div([CLASS,"display-dategrid-header display-dategrid-date",STYLE,style],this.formatDate(date))+"\n";

		date = new Date(date.getTime() +dateDelta);
	    }
	    dateHeader +="</div>";

	    html+=HU.td([],dateHeader);
	    if(showStats) {
		let dflt = [];
		if(this.getShowTotal()) dflt.push("Total");
		if(this.getShowMin()) dflt.push("Min");
		if(this.getShowMax()) dflt.push("Max");
		if(this.getShowAverage()) dflt.push("Avg");
		html+="<td width='" + rightWidth + "'>" + HU.div([CLASS,"display-dategrid-header display-dategrid-stats"], this.getRightLabel(Utils.join(dflt,"/"))) +"</td>";
	    }
	    html +="</tr>"
	    Object.keys(cats).sort(v=>{
		let cat = cats[v];
		let row = HU.open("div",[CLASS,"display-dategrid-row", STYLE,HU.css('height',height)]);
		let sorted = cat.records.sort((a,b)=>{
		    return a.getTime()-b.getTime();
		});
		let total = 0;
		let min=NaN;
		let max=NaN;
		
		for(let i=0;i<sorted.length;i++) {
		    let r = sorted[i];
		    let perc = scaleX(r.getDate());
		    let next = sorted[i+1];
		    let boxWidth="10p";
		    let right = perc+0.05;
		    if(next) {
			let nperc = scaleX(next.getDate());
			let diff = nperc - perc;
			right = (1-nperc);
		    }
		    perc = 100*perc+"%";
		    right = 100*right+"%";
		    let color =  colorBy.getColorFromRecord(r);
		    let cv = r.getValue(colorBy.index);
		    if(!isNaN(cv)) {
			total+=cv;
			min = isNaN(min)?cv:Math.min(min,cv);
			max = isNaN(max)?cv:Math.max(max,cv);			
		    }
		    row+=HU.div(["foo","bar", RECORD_ID,r.getId(),CLASS,"display-dategrid-box",TITLE,cv,STYLE,HU.css("left",perc,"right",right, "height",height,"background",color)+boxStyle],"&nbsp;");
		}
		row+="</div>\n";
		html+="<tr><td width='"+ leftWidth+"'>" +HU.div([STYLE,leftStyle,CLASS,"display-dategrid-rowlabel"], v)+"</td><td>" + row +"</td>"
		if(showStats) {
		    let stats = [];
		    if(this.getShowTotal())
			stats.push(this.formatNumber(total));
		    if(this.getShowMin())
			stats.push(this.formatNumber(min));
		    if(this.getShowMax())
			stats.push(this.formatNumber(max));
		    if(this.getShowAverage())
			stats.push(this.formatNumber(total/sorted.length));		    		    		    
		    html+=HU.td(["nowrap","true"],HU.div([STYLE, rightStyle,CLASS,"display-dategrid-stats"],Utils.join(stats,SPACE)));
		}
		html+="</tr>";
	    });
	    html += "</table></div>";
	    this.setContents(html); 
	    this.boxes = this.find(".display-dategrid-box");
	    this.addFieldClickHandler(this.boxes, records,false);
	    this.makeTooltips(this.boxes,records,null);
	    this.recordMap = this.makeIdToRecords(records);
	    this.records = records;
	    colorBy.displayColorTable();
	},
        handleEventRecordSelection: function(source, args) {
	    SUPER.handleEventRecordSelection.call(this, source, args);
	    if(!this.boxes) {
		return;
	    }
	    let matched = [];
	    let record = this.recordMap[args.record.getId()];
	    if(record) {
		matched.push(record);
	    } else {
		matched = this.findMatchingDates(args.record.getDate(), this.filteredRecords);
	    }
	    if(matched.length==0) {
		console.log("none");
		return;
	    }
	    this.boxes.removeClass("display-dategrid-box-highlight");
	    let boxMap ={};
	    this.boxes.each(function() {
		boxMap[$(this).attr(RECORD_ID)] = $(this);
	    });
	    matched.forEach(record=>{
		let box =  boxMap[record.getId()];
		if(box) box.addClass("display-dategrid-box-highlight");
	    });


	}
    });
}

/**
Copyright 2008-2019 Geode Systems LLC
*/



function RamaddaXlsDisplay(displayManager, id, properties) {

    var COORD_X = "xaxis";
    var COORD_Y = "yaxis";
    var COORD_GROUP = "group";


    var ID_SEARCH = "search";
    var ID_SEARCH_PREFIX = "table";
    var ID_SEARCH_EXTRA = "searchextra";
    var ID_SEARCH_HEADER = "searchheader";
    var ID_RESULTS = "results";
    var ID_DOWNLOADURL = "downloadurl";
    var ID_CONTENTS = "tablecontents";
    var ID_SEARCH_DIV = "searchdiv";
    var ID_SEARCH_FORM = "searchform";
    var ID_SEARCH_TEXT = "searchtext";
    var ID_TABLE_HOLDER = "tableholder";
    var ID_TABLE = "table";
    var ID_CHARTTOOLBAR = "charttoolbar";
    var ID_CHART = "chart";

    RamaddaUtil.inherit(this, new RamaddaDisplay(displayManager, id, "xls", properties));
    addRamaddaDisplay(this);


    this.url = properties.url;
    this.tableProps = {
        fixedRowsTop: 0,
        fixedColumnsLeft: 0,
        rowHeaders: true,
        colHeaders: true,
        headers: null,
        skipRows: 0,
        skipColumns: 0,
    };
    if (properties != null) {
        $.extend(this.tableProps, properties);
    }


    RamaddaUtil.defineMembers(this, {
        initDisplay: function() {
            this.createUI();
            this.setDisplayTitle("Table Data");
            var body =
                HtmlUtils.div(["id", this.getDomId(ID_SEARCH_HEADER)]) +
                HtmlUtils.div(["id", this.getDomId(ID_TABLE_HOLDER)]) +
                HtmlUtils.div(["id", this.getDomId(ID_CHARTTOOLBAR)]) +
                HtmlUtils.div(["id", this.getDomId(ID_CHART)]);
            this.setContents(body);
            this.loadTableData(this.url);
        },
    });


    RamaddaUtil.defineMembers(this, {
        currentSheet: 0,
        currentData: null,
        columnLabels: null,
        startRow: 0,
        groupIndex: -1,
        xAxisIndex: -1,
        yAxisIndex: -1,
        header: null,
        cellSelected: function(row, col) {
            this.startRow = row;
            if (this.jq("params-xaxis-select").attr("checked")) {
                this.xAxisIndex = col;
            } else if (this.jq("params-group-select").attr("checked")) {
                this.groupIndex = col;
            } else {
                this.yAxisIndex = col;
            }
            var label = "";
            var p1 = "";
            var p2 = "";

            this.setAxisLabel(COORD_X, this.getHeading(this.xAxisIndex, true));
            this.setAxisLabel(COORD_GROUP, this.getHeading(this.groupIndex, true));
            this.setAxisLabel(COORD_Y, this.getHeading(this.yAxisIndex, true));
        },
        getAxisLabelId: function(root) {
            return "params-" + root + "-label"
        },
        setAxisLabel: function(fieldId, lbl) {
            fieldId = this.getAxisLabelId(fieldId);
            var id = HtmlUtils.getUniqueId();
            if (lbl.length > 25) {
                lbl = lbl.substring(0, 25) + "...";
            }
            if (lbl.trim() != "") {
                lbl = HtmlUtils.span(["id", id, "class", "ramadda-tag-box"], "&nbsp;&nbsp;" + lbl + "&nbsp;&nbsp;");
            }
            this.jq(fieldId).html(lbl);
        },
        loadSheet: function(sheetIdx) {

            var all = $("[id^=" + this.getDomId("sheet_") + "]");
            var sel = $("#" + this.getDomId("sheet_") + sheetIdx);

            all.css('font-weight', 'normal');
            sel.css('font-weight', 'bold');

            all.css('border', '1px #ccc solid');
            sel.css('border', '1px #666 solid');

            this.currentSheet = sheetIdx;
            var sheet = this.sheets[sheetIdx];
	    let rows;
            if (sheet) {
                rows = sheet.rows.slice(0);
                if (rows.length > 0) {
                    this.header = rows[0];
                }
            }

	    if(!rows) {
		this.displayHtml(this.getMessage("No data"));
		return;
	    }
            var html = "";
            var _this = this;
            var args = {
                contextMenu: true,
                stretchH: 'all',
                colHeaders: true,
                rowHeaders: true,
                minSpareRows: 1,
                afterSelection: function() {
                    if (arguments.length > 2) {
                        for (var i = 0; i < arguments.length; i++) {
                            //                                console.log("a[" + i +"]=" + arguments[i]);
                        }
                        var row = arguments[0];
                        var col = arguments[1];
                        _this.cellSelected(row, col);
                    }
                },
            };
            $.extend(args, this.tableProps);
            if (this.tableProps.useFirstRowAsHeader) {
                var headers = rows[0];
                args.colHeaders = headers;
                rows = rows.splice(1);
            }
            for (var i = 0; i < this.tableProps.skipRows; i++) {
                rows = rows.splice(1);
            }

            if (rows.length == 0) {
                this.displayMessage("No data found");
                this.jq(ID_RESULTS).html("");
                return;
            }

            this.jq(ID_RESULTS).html("Found: " + rows.length);
            args.data = rows;
            this.currentData = rows;

            if (this.tableProps.headers != null) {
                args.colHeaders = this.tableProps.headers;
            }

            if (this.getProperty("showTable", true)) {
                this.jq(ID_TABLE).handsontable(args);
            }

        },
        getDataForSheet: function(sheetIdx, args) {
            var sheet = this.sheets[sheetIdx];
            var rows = sheet.rows.slice(0);
            if (rows.length > 0) {
                this.header = rows[0];
            }

            if (this.tableProps.useFirstRowAsHeader) {
                var headers = rows[0];
                if (args) {
                    args.colHeaders = headers;
                }
                rows = rows.splice(1);
            }
            for (var i = 0; i < this.tableProps.skipRows; i++) {
                rows = rows.splice(1);
            }
            return rows;
        },

        makeChart: function(chartType, props) {
            if (typeof google == 'undefined') {
                this.jq(ID_CHART).html("No google chart available");
                return;
            }

            if (props == null) props = {};
            var xAxisIndex = Utils.getDefined(props.xAxisIndex, this.xAxisIndex);
            var groupIndex = Utils.getDefined(props.groupIndex, this.groupIndex);
            var yAxisIndex = Utils.getDefined(props.yAxisIndex, this.yAxisIndex);

            //                console.log("y:" + yAxisIndex +" props:" + props.yAxisIndex);

            if (yAxisIndex < 0) {
                alert("You must select a y-axis field.\n\nSelect the desired axis with the radio button.\n\nClick the column in the table to chart.");
                return;
            }

            var sheetIdx = this.currentSheet;
            if (!(typeof props.sheet == "undefined")) {
                sheetIdx = props.sheet;
            }

            var rows = this.getDataForSheet(sheetIdx);
            if (rows == null) {
                this.jq(ID_CHART).html("There is no data");
                return;
            }


            //remove the first header row
            var rows = rows.slice(1);

            for (var i = 0; i < this.startRow - 1; i++) {
                rows = rows.slice(1);
            }

            var subset = [];
            console.log("x:" + xAxisIndex + " " + " y:" + yAxisIndex + " group:" + groupIndex);
            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var row = [];
                var idx = 0;
                if (xAxisIndex >= 0) {
                    row.push(rows[rowIdx][xAxisIndex]);
                } else {
                    row.push(rowIdx);
                }
                if (yAxisIndex >= 0) {
                    row.push(rows[rowIdx][yAxisIndex]);
                }
                subset.push(row);
                if (rowIdx < 2)
                    console.log("row:" + row);
            }
            rows = subset;

            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                var cols = rows[rowIdx];


                for (var colIdx = 0; colIdx < cols.length; colIdx++) {
                    var value = cols[colIdx] + "";
                    cols[colIdx] = parseFloat(value.trim());
                }
            }


            var lbl1 = this.getHeading(xAxisIndex, true);
            var lbl2 = this.getHeading(yAxisIndex, true);
            var lbl3 = this.getHeading(groupIndex, true);
            this.columnLabels = [lbl1, lbl2];


            var labels = this.columnLabels != null ? this.columnLabels : ["Field 1", "Field 2"];
            rows.splice(0, 0, labels);
            /*
            for(var rowIdx=0;rowIdx<rows.length;rowIdx++) {
                var cols = rows[rowIdx];
                var s = "";
                for(var colIdx=0;colIdx<cols.length;colIdx++) {
                    if(colIdx>0)
                        s += ", ";
                    s += "'" +cols[colIdx]+"'" + " (" + (typeof cols[colIdx]) +")";
                }
                console.log(s);
                if(rowIdx>5) break;
            }
            */

            var dataTable = google.visualization.arrayToDataTable(rows);
            var chartOptions = {};
            var width = "95%";
            $.extend(chartOptions, {
                legend: {
                    position: 'top'
                },
            });

            if (this.header != null) {
                if (xAxisIndex >= 0) {
                    chartOptions.hAxis = {
                        title: this.header[xAxisIndex]
                    };
                }
                if (yAxisIndex >= 0) {
                    chartOptions.vAxis = {
                        title: this.header[yAxisIndex]
                    };
                }
            }

            var chartDivId = HtmlUtils.getUniqueId();
            var divAttrs = ["id", chartDivId];
            if (chartType == "scatterplot") {
                divAttrs.push("style");
                divAttrs.push("width: 450px; height: 450px;");
            }
            this.jq(ID_CHART).append(HtmlUtils.div(divAttrs));

            if (chartType == "barchart") {
                chartOptions.chartArea = {
                    left: 75,
                    top: 10,
                    height: "60%",
                    width: width
                };
                chartOptions.orientation = "horizontal";
                this.chart = new google.visualization.BarChart(document.getElementById(chartDivId));
            } else if (chartType == "table") {
                this.chart = new google.visualization.Table(document.getElementById(chartDivId));
            } else if (chartType == "motion") {
                this.chart = new google.visualization.MotionChart(document.getElementById(chartDivId));
            } else if (chartType == "scatterplot") {
                chartOptions.chartArea = {
                    left: 50,
                    top: 30,
                    height: 400,
                    width: 400
                };
                chartOptions.legend = 'none';
                chartOptions.axisTitlesPosition = "in";
                this.chart = new google.visualization.ScatterChart(document.getElementById(chartDivId));
            } else {
                $.extend(chartOptions, {
                    lineWidth: 1
                });
                chartOptions.chartArea = {
                    left: 75,
                    top: 10,
                    height: "60%",
                    width: width
                };
                this.chart = new google.visualization.LineChart(document.getElementById(chartDivId));
            }
            if (this.chart != null) {
                this.chart.draw(dataTable, chartOptions);
            }
        },

        addNewChartListener: function(makeChartId, chartType) {
            var _this = this;
            $("#" + makeChartId + "-" + chartType).button().click(function(event) {
                console.log("make chart:" + chartType);
                _this.makeChart(chartType);
            });
        },

        makeSheetButton: function(id, index) {
            var _this = this;
            $("#" + id).button().click(function(event) {
                _this.loadSheet(index);
            });
        },
        clear: function() {
            this.jq(ID_CHART).html("");
            this.startRow = 0;
            this.groupIndex = -1;
            this.xAxisIndex = -1;
            this.yAxisIndex = -1;
            this.setAxisLabel(COORD_GROUP, "");
            this.setAxisLabel(COORD_X, "");
            this.setAxisLabel(COORD_Y, "");
        },
        getHeading: function(index, doField) {
            if (index < 0) return "";
            if (this.header != null && index >= 0 && index < this.header.length) {
                var v = this.header[index];
                v = v.trim();
                if (v.length > 0) return v;
            }
            if (doField)
                return "Field " + (index + 1);
            return "";
        },
        showTableData: function(data) {
            var _this = this;

            this.data = data;
            this.sheets = this.data.sheets;
            this.columns = data.columns;



            var buttons = "";
            for (var sheetIdx = 0; sheetIdx < this.sheets.length; sheetIdx++) {
                var id = this.getDomId("sheet_" + sheetIdx);
                buttons += HtmlUtils.div(["id", id, "class", "ramadda-xls-button-sheet"],
                    this.sheets[sheetIdx].name);

                buttons += "\n";
            }

            var weight = "12";

            var tableHtml = "<table width=100% style=\"max-width:1000px;\" > ";
            if (this.sheets.length > 1) {
                weight = "10";
            }

            tableHtml += "<tr valign=top>";

            if (this.sheets.length > 1) {
                //                    tableHtml += HtmlUtils.openTag(["class","col-md-2"]);
                tableHtml += HtmlUtils.td(["width", "140"], HtmlUtils.div(["class", "ramadda-xls-buttons"], buttons));
                weight = "10";
            }


            var makeChartId = HtmlUtils.getUniqueId();

            var tableWidth = this.getProperty("tableWidth", "");
            var tableHeight = this.getProperty("tableHeight", "500px");

            var style = "";
            if (tableWidth != "") {
                style += " width:" + tableWidth + ";";
            }
            style += " height: " + tableHeight + ";";
            style += " overflow: auto;";
            tableHtml += HtmlUtils.td([], HtmlUtils.div(["id", this.getDomId(ID_TABLE), "class", "ramadda-xls-table", "style", style]));


            tableHtml += "</tr>";
            tableHtml += "</table>";

            var chartToolbar = "";
            var chartTypes = ["barchart", "linechart", "scatterplot"];
            for (var i = 0; i < chartTypes.length; i++) {
                chartToolbar += HtmlUtils.div(["id", makeChartId + "-" + chartTypes[i], "class", "ramadda-xls-button"], "Make " + chartTypes[i]);
                chartToolbar += "&nbsp;";
            }

            chartToolbar += "&nbsp;";
            chartToolbar += HtmlUtils.div(["id", this.getDomId("removechart"), "class", "ramadda-xls-button"], "Clear Charts");


            chartToolbar += "<p>";
            chartToolbar += "<form>Fields: ";
            chartToolbar += "<input type=radio checked name=\"param\" id=\"" + this.getDomId("params-yaxis-select") + "\"> y-axis:&nbsp;" +
                HtmlUtils.div(["id", this.getDomId("params-yaxis-label"), "style", "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "&nbsp;&nbsp;&nbsp;";
            chartToolbar += "<input type=radio  name=\"param\" id=\"" + this.getDomId("params-xaxis-select") + "\"> x-axis:&nbsp;" +
                HtmlUtils.div(["id", this.getDomId("params-xaxis-label"), "style", "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "&nbsp;&nbsp;&nbsp;";
            chartToolbar += "<input type=radio  name=\"param\" id=\"" + this.getDomId("params-group-select") + "\"> group:&nbsp;" +
                HtmlUtils.div(["id", this.getDomId("params-group-label"), "style", "border-bottom:1px #ccc dotted;min-width:10em;display:inline-block;"], "");

            chartToolbar += "</form>";

            if (this.getProperty("showSearch", true)) {
                var results = HtmlUtils.div(["style", "display:inline-block;", "id", this.getDomId(ID_RESULTS)], "");
                var download = HtmlUtils.div(["style", "display:inline-block;", "id", this.getDomId(ID_DOWNLOADURL)]);
                var searchDiv = HtmlUtils.div(["id", this.getDomId(ID_SEARCH_DIV), "class", "ramadda-xls-search-form"]);


                var search = "";
                search += HtmlUtils.openTag("form", ["action", "#", "id", this.getDomId(ID_SEARCH_FORM)]);
                search += HtmlUtils.image(icon_tree_closed, ["id", this.getDomId(ID_SEARCH + "_open")]);
                search += "\n";
                search += HtmlUtils.input(ID_SEARCH_TEXT, this.jq(ID_SEARCH_TEXT).val(), ["size", "60", "id", this.getDomId(ID_SEARCH_TEXT), "placeholder", "Search"]);
                search += "<input type=submit name='' style='display:none;'>";

                search += HtmlUtils.openTag("div", ["id", this.getDomId(ID_SEARCH_EXTRA), "class", "ramadda-xls-search-extra"], "");
                if (this.columns) {
                    var extra = HtmlUtils.openTag("table", ["class", "formtable"]);
                    for (var i = 0; i < this.columns.length; i++) {
                        var col = this.columns[i];
                        var id = ID_SEARCH_PREFIX + "_" + col.name;
                        var widget = HtmlUtils.input(id, this.jq(id).val(), ["id", this.getDomId(id), "placeholder", "Search"]);
                        extra += HtmlUtils.formEntry(col.name.replace("_", " ") + ":", widget);
                    }
                    extra += HtmlUtils.closeTag("table");
                    search += extra;
                }


                if (this.searchFields) {
                    var extra = HtmlUtils.openTag("table", ["class", "formtable"]);
                    for (var i = 0; i < this.searchFields.length; i++) {
                        var col = this.searchFields[i];
                        var id = ID_SEARCH_PREFIX + "_" + col.name;
                        var widget = HtmlUtils.input(id, this.jq(id).val(), ["id", this.getDomId(id), "placeholder", "Search"]);
                        extra += HtmlUtils.formEntry(col.label + ":", widget);
                    }
                    extra += HtmlUtils.closeTag("table");
                    search += extra;
                }




                search += "\n";
                search += HtmlUtils.closeTag("div");
                search += "\n";
                search += HtmlUtils.closeTag("form");

                this.jq(ID_SEARCH_HEADER).html(HtmlUtils.leftRight(searchDiv, results + " " + download));

                this.jq(ID_SEARCH_DIV).html(search);

                if (!this.extraOpen) {
                    this.jq(ID_SEARCH_EXTRA).hide();
                }


                this.jq(ID_SEARCH + "_open").button().click(function(event) {
                    _this.jq(ID_SEARCH_EXTRA).toggle();
                    _this.extraOpen = !_this.extraOpen;
                    if (_this.extraOpen) {
                        _this.jq(ID_SEARCH + "_open").attr("src", icon_tree_open);
                    } else {
                        _this.jq(ID_SEARCH + "_open").attr("src", icon_tree_closed);
                    }
                });

            }


            if (this.getProperty("showTable", true)) {
                this.jq(ID_TABLE_HOLDER).html(tableHtml);
                chartToolbar += "<br>";
                if (this.getProperty("showChart", true)) {
                    this.jq(ID_CHARTTOOLBAR).html(chartToolbar);
                }
            }

            if (this.getProperty("showSearch", true)) {
                this.jq(ID_SEARCH_FORM).submit(function(event) {
                    event.preventDefault();
                    _this.loadTableData(_this.url, "Searching...");
                });
                this.jq(ID_SEARCH_TEXT).focus();
                this.jq(ID_SEARCH_TEXT).select();
            }


            for (var i = 0; i < chartTypes.length; i++) {
                this.addNewChartListener(makeChartId, chartTypes[i]);
            }
            this.jq("removechart").button().click(function(event) {
                _this.clear();
            });

            for (var sheetIdx = 0; sheetIdx < this.sheets.length; sheetIdx++) {
                var id = this.getDomId("sheet_" + sheetIdx);
                this.makeSheetButton(id, sheetIdx);
            }
            var sheetIdx = 0;
            var rx = /sheet=([^&]+)/g;
            var arr = rx.exec(window.location.search);
            if (arr) {
                sheetIdx = arr[1];
            }
            this.loadSheet(sheetIdx);


            if (this.defaultCharts) {
                for (var i = 0; i < this.defaultCharts.length; i++) {
                    var dflt = this.defaultCharts[i];
                    this.makeChart(dflt.type, dflt);
                }
            }
            this.setAxisLabel("params-yaxis-label", this.getHeading(this.yAxisIndex, true));

            this.displayDownloadUrl();

        },
        displayMessage: function(msg, icon) {
            if (!icon) {
                icon = icon_information;
            }
            var html = HtmlUtils.hbox([HtmlUtils.image(icon, ["align", "left"]),
                HtmlUtils.inset(msg, 10, 10, 5, 10)]);
            html = HtmlUtils.div(["class", "note"], html);
            this.jq(ID_TABLE_HOLDER).html(html);
        },
        displayDownloadUrl: function() {
            var url = this.lastUrl;
            if (url == null) {
                this.jq(ID_DOWNLOADURL).html("");
                return
            }
            url = url.replace("xls_json", "media_tabular_extractsheet");
            url += "&execute=true";
            var img = HtmlUtils.image(ramaddaBaseUrl + "/icons/xls.png", ["title", "Download XLSX"]);
            this.jq(ID_DOWNLOADURL).html(HtmlUtils.href(url, img));
        },
        loadTableData: function(url, message) {
            this.url = url;
            if (!message) message = this.getLoadingMessage();
            this.displayMessage(message, icon_progress);
            var _this = this;

            var text = this.jq(ID_SEARCH_TEXT).val();
            if (text && text != "") {
                url = url + "&table.text=" + encodeURIComponent(text);
            }
            if (this.columns) {
                for (var i = 0; i < this.columns.length; i++) {
                    var col = this.columns[i];
                    var id = ID_SEARCH_PREFIX + "_" + col.name;
                    var text = this.jq(id).val();
                    if (text) {
                        url = url + "&table." + col.name + "=" + encodeURIComponent(text);
                    }
                }
            }

            if (this.searchFields) {
                for (var i = 0; i < this.searchFields.length; i++) {
                    var col = this.searchFields[i];
                    var id = ID_SEARCH_PREFIX + "_" + col.name;
                    var text = this.jq(id).val();
                    if (text) {
                        url = url + "&table." + col.name + "=" + encodeURIComponent(text);
                    }
                }
            }



            console.log("url:" + url);
            this.lastUrl = url;

            var jqxhr = $.getJSON(url, function(data) {
                    if (GuiUtils.isJsonError(data)) {
                        _this.displayMessage("Error: " + data.error);
                        return;
                    }
                    _this.showTableData(data);
                })
                .fail(function(jqxhr, textStatus, error) {
                    var err = textStatus + ", " + error;
                    _this.displayMessage("An error occurred: " + error);
                    console.log("JSON error:" + err);
                });
        }
    });

}
/**
   Copyright 2008-2019 Geode Systems LLC
*/


const DISPLAY_PLOTLY_RADAR = "radar";
const DISPLAY_PLOTLY_WINDROSE = "windrose";
const DISPLAY_PLOTLY_DENSITY = "density";
const DISPLAY_PLOTLY_DOTPLOT = "dotplot";
const DISPLAY_PLOTLY_SPLOM = "splom";
const DISPLAY_PLOTLY_PROFILE = "profile";
const DISPLAY_PLOTLY_3DSCATTER = "3dscatter";
const DISPLAY_PLOTLY_3DMESH = "3dmesh";
const DISPLAY_PLOTLY_TREEMAP = "ptreemap";
const DISPLAY_PLOTLY_TERNARY = "ternary";
const DISPLAY_PLOTLY_SUNBURST= "sunburst";
const DISPLAY_PLOTLY_TEXTCOUNT = "textcount";
const DISPLAY_PLOTLY_COMBOCHART = "combochart";
const DISPLAY_PLOTLY_PARCOORDS = "parcoords";

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_RADAR,
    label: "Radar",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_WINDROSE,
    label: "Wind Rose",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_SUNBURST,
    label: "Sunburst",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip(null,"sunburst.png")                            
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_DENSITY,
    label: "Density",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_COMBOCHART,
    label: "Combo Chart",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"combochart.png")                        
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_PARCOORDS,
    label: "Parallel Coords",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_DOTPLOT,
    label: "Dot Plot",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"dotplot.png")                    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_SPLOM,
    label: "Splom",
    requiresData: true,
    forUser: true,
    category: CATEGORY_RADIAL_ETC,
    tooltip: makeDisplayTooltip("A scatterplot matrix","splom.png")    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_3DSCATTER,
    label: "3D Scatter",
    requiresData: true,
    forUser: false,
    category: CATEGORY_RADIAL_ETC
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_PROFILE,
    label: "Profile",
    requiresData: true,
    forUser: true,
    category: CATEGORY_CHARTS,
    tooltip: makeDisplayTooltip(null,"profile.png")                    
});
addGlobalDisplayType({
    type: DISPLAY_PLOTLY_3DMESH,
    label: "3D Mesh",
    requiresData: false,
    forUser: false,
    category: CATEGORY_RADIAL_ETC
});

addGlobalDisplayType({
    type: DISPLAY_PLOTLY_TEXTCOUNT,
    label: "Text Count",
    requiresData: true,
    forUser: true,
    category: CATEGORY_TEXT,
    tooltip: makeDisplayTooltip("Shows counts of certain patterns","textcount.png","Given a text field show the number of <br>times certain word patterns occur")                                    
});

//Ternary doesn't work
//addGlobalDisplayType({type: DISPLAY_PLOTLY_TERNARY, label:"Ternary",requiresData:true,forUser:true,category:CATEGORY_RADIAL_ETC});
//Treempap doesn't work
//addGlobalDisplayType({type: DISPLAY_PLOTLY_PTREEMAP, label:"Tree Map",requiresData:true,forUser:true,category:CATEGORY_RADIAL_ETC});


function RamaddaPlotlyDisplay(displayManager, id, type, properties) {
    const ID_PLOTY = "plotly";
    let SUPER = new RamaddaFieldsDisplay(displayManager, id, type, properties);
    //Dynamically load plotly
    if(!window.Plotly) {
	let url = ramaddaBaseUrl+"/lib/plotly/plotly-latest.min.js";
        var imports = "<script src='" + url+"'></script>";
        $(imports).appendTo("head");
    }
    RamaddaUtil.inherit(this, SUPER);
    RamaddaUtil.defineMembers(this, {
	getRequirement:function() {
	    return "Plotly";
	},
        needsData: function() {
            return true;
        },
        setDimensions: function(layout, widthDelta) {
            //                var width  = parseInt(this.getProperty("width","400").replace("px","").replace("%",""));
            var height = parseInt(this.getProperty("height", "400").replace("px", "").replace("%", ""));
            //                layout.width = width-widthDelta;
            layout.height = height;
	    if(!layout.margin) layout.margin={};
	    [["l","marginLeft"],["r","marginRight"],["t","marginTop"],["b","marginBottom"]].map(t=>{
		if(Utils.isDefined(this.getProperty(t[1])))
		    layout.margin[t[0]]  = this.getProperty(t[1]);
	    });

        },
        pointDataLoaded: function(pointData, url, reload) {
            SUPER.pointDataLoaded.call(this, pointData, url, reload);
	    /*
              if (this.dataCollection)
              this.displayManager.propagateEventRecordSelection(this,
              this.dataCollection.getList()[0], {
              index: 0
              });
	    */

        },
        displayData: function() {
            this.updateUI();
        },
        pageHasLoaded: function() {
            SUPER.pageHasLoaded.call(this);
            this.updateUI();
        },

        fieldSelectionChanged: function() {
            SUPER.fieldSelectionChanged.call(this);
            this.updateUI();
        },
        makeAxis: function(title, tickangle) {
            return {
                title: title,
                titlefont: {
                    size: 20
                },
                tickangle: tickangle,
                tickfont: {
                    size: 15
                },
                tickcolor: 'rgba(0,0,0,0)',
                ticklen: 5,
                showline: true,
                showgrid: true
            };
        },
        getDisplayStyle: function() {
            return "";
        },
        makePlot: function(data, layout) {
            this.clearHtml();
	    let html = 
		HtmlUtils.div(["id",this.getDomId(ID_HEADER)],"") +
		HtmlUtils.div(["id", this.getDomId("tmp"), "style", this.getDisplayStyle()], "") +
		HtmlUtils.div(["id",this.getDomId(ID_FOOTER)],"");
	    this.setContents(html);
            //For some reason plotly won't display repeated times in the DISPLAY div
            var plot = Plotly.plot(this.getDomId("tmp"), data, layout,{displayModeBar: false});
            var myPlot = document.getElementById(this.getDomId("tmp"));
	    if(myPlot) {
		this.addEvents(plot, myPlot);
	    }
	    return myPlot;
        },
        handleClickEvent: function(data) {
	    if(data.points && data.points.length>0) {
		let record = data.points[0].record;
		if(!record) {
		    var index = data.points[0].pointIndex;
		    record = this.indexToRecord[index];
		}
		//		console.log("index:" + index +" record:"+  record);
		if(record) {
		    this.propagateEventRecordSelection({record: record});
		}
	    }
	},
        addEvents: function(plot, myPlot) {
	    let _this = this;
            myPlot.on('plotly_click', function(data) {
		_this.handleClickEvent(data);
            });

	}
    });
}



function RamaddaRadialDisplay(displayManager, id, type, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, type, properties));
    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'barpolar';
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) {
                return;
            }
            var fields = this.getSelectedFields(this.getData().getRecordFields());
	    var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
	    var theta;
	    var thetaType;
	    if(this.getProperty("useDates")) {
		var tmp = this.getDateValues(records);
		theta=[];
		var dateFormat = this.getProperty("dateFormat", "yyyyMMdd");
		thetaType = "category";
		tmp.map(d=>{
		    theta.push(Utils.formatDateWithFormat(d,dateFormat));
		});
	    } else {
		var thetaField = this.getFieldById(null, this.getProperty("thetaField"));
		if (thetaField) {
		    theta = this.getColumnValues(records, thetaField).values;
		}
	    }
            var values = [];
            var min = Number.MAX_VALUE;
            var max = Number.MIN_VALUE;
            var plotData = [];
            for (var i = 0; i < numericFields.length; i++) {
                var field = numericFields[i];
                var column = this.getColumnValues(records, field);
		if(!theta) {
		    theta = [];
		    var cnt = 0;
		    for(var cnt=0;cnt<column.values.length;cnt++)
			theta.push(cnt*360/column.values.length);
		}
                min = Math.min(min, column.min);
                max = Math.max(max, column.max);
		var values = column.values;
                plotData.push({
                    type: this.getPlotType(),
                    r: values,
                    theta: theta,
                    fill: 'toself',
                    name: field.getLabel(),
                });
            }

            layout = {
                polar: {
                    angularaxis: {
			type:"category"
		    },
                    radialaxis: {
                        visible: true,
                        range: [min, max]
                    }
                },
            }
	    if(thetaType) {
		layout.polar.angularaxis  ={
		    type:thetaType
		};
	    }
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}

function RamaddaRadarDisplay(displayManager, id, properties) {
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaRadialDisplay(displayManager, id, DISPLAY_PLOTLY_RADAR, properties));

    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'scatterpolar';
        },
    });
    addRamaddaDisplay(this);
}

function RamaddaWindroseDisplay(displayManager, id, properties) {
    var SUPER;
    RamaddaUtil.inherit(this, SUPER = new RamaddaRadialDisplay(displayManager, id, DISPLAY_PLOTLY_WINDROSE, properties));
    RamaddaUtil.defineMembers(this, {
        getPlotType: function() {
            return 'barpolar';
        },
    });
    addRamaddaDisplay(this);
}




function RamaddaDensityDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "600px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_DENSITY, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var numericFields = this.getFieldsByType(fields, "numeric");
            if (numericFields.length < 2) {
                this.displayError("No numeric fields specified");
                return;
            }

            var x = this.getColumnValues(records, numericFields[0]);
            var y = this.getColumnValues(records, numericFields[1]);
            var markers = {
                x: x.values,
                y: y.values,
                mode: 'markers',
                name: "",
                marker: {
                    color: this.getProperty("pointColor", 'rgb(102,0,0)'),
                    size: parseInt(this.getProperty("markerSize", "4")),
                    opacity: 0.4
                },
                type: 'scatter'
            };
            var density = {
                x: x.values,
                y: y.values,
                name: 'density',
                ncontours: 20,
                colorscale: 'Hot',
                reversescale: true,
                type: 'histogram2dcontour'
            };
            var plotData = [];
            if (this.getProperty("showDensity", true))
                plotData.push(density);
            if (this.getProperty("showPoints", true))
                plotData.push(markers);
            var layout = {
                showlegend: true,
                autosize: true,
                margin: {
                    t: 50
                },
                hovermode: 'closest',
                bargap: 0,
                xaxis: {
                    domain: [x.min, x.max],
                    showline: this.getProperty("showLines", true),
                    showgrid: this.getProperty("showLines", true),
                    title: fields[0].getLabel()
                },
                yaxis: {
                    domain: [y.min, y.max],
                    showline: this.getProperty("showLines", true),
                    showgrid: this.getProperty("showLines", true),
                    title: fields[1].getLabel()
                },
            };
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}


function RamaddaPlotly3DDisplay(displayManager, id, type, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, type, properties));

    RamaddaUtil.defineMembers(this, {
        addEvents: function(plot, myPlot) {
            myPlot.on('plotly_click', function() {
                //                        alert('You clicked this Plotly chart!');
            });
        },

        getDisplayStyle: function() {
            return "border: 1px #ccc solid;";
        },
        get3DType: function() {
            //                'mesh3d'
            return 'scatter3d';
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var stringField = this.getFieldByType(fields, "string");
            var fields = this.getFieldsByType(fields, "numeric");
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length < 3) {
                this.displayError("Don't have 3 numeric fields specified");
                return;
            }
            var x = this.getColumnValues(records, fields[0]);
            var y = this.getColumnValues(records, fields[1]);
            var z = this.getColumnValues(records, fields[2]);

            var trace1 = {
                x: x.values,
                y: y.values,
                z: z.values,
                mode: 'markers',
                marker: {
                    size: 12,
                    line: {
                        color: 'rgba(217, 217, 217, 0.14)',
                        width: 0.5
                    },
                    opacity: 0.8
                },
                type: this.get3DType()
            };


            var plotData = [trace1];


            var layout = {
                scene: {
                    xaxis: {
                        backgroundcolor: "rgb(200, 200, 230)",
                        gridcolor: "rgb(255, 255, 255)",
                        showbackground: true,
                        zerolinecolor: "rgb(255, 255, 255)",
                        title: fields[0].getLabel(),
                    },
                    yaxis: {
                        backgroundcolor: "rgb(230, 200,230)",
                        gridcolor: "rgb(255, 255, 255)",
                        showbackground: true,
                        zerolinecolor: "rgb(255, 255, 255)",
                        title: fields[1].getLabel(),
                    },
                    zaxis: {
                        backgroundcolor: "rgb(230, 230,200)",
                        gridcolor: "rgb(255, 255, 255)",
                        showbackground: true,
                        zerolinecolor: "rgb(255, 255, 255)",
                        title: fields[2].getLabel(),
                    }
                },
                margin: {
                    l: 0,
                    r: 0,
                    b: 50,
                    t: 50,
                    pad: 4
                },
            };
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}


function Ramadda3dmeshDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "100%",
        height: "100%",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotly3DDisplay(displayManager, id, DISPLAY_PLOTLY_3DMESH, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        get3DType: function() {
            return 'mesh3d';
        },
    });
}



function Ramadda3dscatterDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "100%",
        height: "100%",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotly3DDisplay(displayManager, id, DISPLAY_PLOTLY_3DSCATTER, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        get3DType: function() {
            return 'scatter3d';
        },
    });
}



function RamaddaSunburstDisplay(displayManager, id, properties) {
    $.extend(this, {
        width: "500",
        height: "500",
    });
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_SUNBURST, properties);
    let myProps = [
	{label:'Sunburst Display'},
	{p:'parentField',ex:''},
	{p:'labelField',ex:''},
	{p:'idField',ex:''},
	{p:'valueField',ex:''},
	{p:'nodeFields',ex:''},
	{p:'treeRoot',ex:'some label'},
	{p:'doTopColors',ex:'true'},
    ];

    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDisplayStyle: function() {
            return "";
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var parentField = this.getFieldById(null, this.getProperty("parentField"));
	    var valueField = this.getFieldById(null, this.getProperty("valueField"));
	    var labelField = this.getFieldById(null, this.getProperty("labelField"));
	    let roots=null;
	    try {
		roots = this.makeTree();
	    } catch(error) {
                this.setContents(this.getMessage(error.toString()));
		return;
	    }

	    let ids = [];
	    let labels = [];
	    let parentNodes= [];

	    let parents = [];
	    let values=[];
	    //descend and calculate values
	    let calcValue = function(node) {
		if(node.children.length==0) {
		    if(node.record) {
			var value = node.record.getValue(valueField.getIndex());
			node.value = value;
			return value;
		    }
		    return 0;
		}
		let sum = 0;
		node.children.map(child=>{
		    sum += calcValue(child);
		});
		node.value = sum;
		if(node.record){
		    node.record.setValue(valueField.getIndex(),sum);
		}
		return sum;
	    }
	    if(valueField) {
		roots.map(calcValue);
	    }
	    this.myRecords = [];
	    let recordList =  this.myRecords;
	    let makeList = function(node) {
		recordList.push(node.record);
		if(valueField)
		    values.push(node.value);
		parentNodes.push(node.parent);
		ids.push(node.id);
		labels.push(node.label);
		parents.push(node.parent==null?"":node.parent.id);
		node.children.map(makeList);
	    }
	    roots.map(makeList);
            var colors = this.getColorTable(true);
	    let doTopColors= this.getProperty("doTopColors",true);
	    if(!colors) {
		var colorMap = Utils.parseMap(this.getProperty("colorMap"));
		if(colorMap) {
		    colors = [];
		    let dfltIdx =0;
		    let dflt = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
		    ids.map((id,idx)=>{
			if(doTopColors && parentNodes[idx]!=null)  return;
			let color = colorMap[id];
			if(!color) {
			    color = colorMap[labels[idx]];
			}
			if(!color) {
			    if(dfltIdx>=dflt.length) dfltIdx = 0;
			    color = dflt[dfltIdx];
			    dfltIdx++;
			}
			colors.push(color);
		    });
		}
	    }

	    var data = [{
		type: "sunburst",
		ids:ids,
		labels: labels,
		parents: parents,
		outsidetextfont: {size: 20, color: "#377eb8"},
		leaf: {opacity: 0.4},
		marker: {
		    line: {width: 1}
		},
		branchvalues: 'total'
	    }];
	    if(valueField) {
		data[0].values = values;
	    }
	    var layout = {
		margin: {l: 0, r: 0, b: 0, t: 0},
		width: +this.getProperty("width"),
		height: +this.getProperty("height"),
	    };
	    if(colors) {
		if(!doTopColors) {
		    data[0].marker.colors = colors;
		} else {
		    layout.sunburstcolorway= colors;
		    layout.extendsunburstcolors= true;
		    layout.extendsunburstcolorway= true;
		}
	    }

	    var myPlot =  this.makePlot(data, layout);
	    myPlot.on('plotly_sunburstclick', d=>{this.handleSunburstClickEvent(d)});
        },
        handleSunburstClickEvent: function(data) {
	    if(!data.points || data.points.length<=0) {
		return;
	    }
	    var pointNumber = data.points[0].pointNumber;
	    var record = this.myRecords[pointNumber];
	    //	    console.log(pointNumber +" " + record);
	    if(record) {
		this.propagateEventRecordSelection({record: record});
	    }
	},

    });
}



function RamaddaTernaryDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TERNARY, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            var stringField = this.getFieldByType(fields, "string");
            var fields = this.getFieldsByType(fields, "numeric");
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }
            if (fields.length < 3) {
                this.displayError("Don't have 3 numeric fields specified");
                return;
            }

            var rawData = [];
            var a = this.getColumnValues(records, fields[0]);
            var b = this.getColumnValues(records, fields[1]);
            var c = this.getColumnValues(records, fields[2]);
            for (var i = 0; i < a.length; i++) {
                rawData.push({
                    a: 100 * a[i] / a.max,
                    b: 100 * b[i] / b.max,
                    c: 100 * c[i] / c.max,

                    label: stringField ? stringField.getLabel() : "Point " + (i + 1)
                });
            }
            var xrawData = [{
                a: 75,
                b: 25,
                c: 0,
                label: 'point 1'
            }, {
                a: 70,
                b: 10,
                c: 20,
                label: 'point 2'
            }, {
                a: 75,
                b: 20,
                c: 5,
                label: 'point 3'
            }, {
                a: 5,
                b: 60,
                c: 35,
                label: 'point 4'
            }, {
                a: 10,
                b: 80,
                c: 10,
                label: 'point 5'
            }, {
                a: 10,
                b: 90,
                c: 0,
                label: 'point 6'
            }, {
                a: 20,
                b: 70,
                c: 10,
                label: 'point 7'
            }, {
                a: 10,
                b: 20,
                c: 70,
                label: 'point 8'
            }, {
                a: 15,
                b: 5,
                c: 80,
                label: 'point 9'
            }, {
                a: 10,
                b: 10,
                c: 80,
                label: 'point 10'
            }, {
                a: 20,
                b: 10,
                c: 70,
                label: 'point 11'
            }, ];


            var plotData = [{
                type: 'scatterternary',
                mode: 'markers',
                a: rawData.map(function(d) {
                    return d.a;
                }),
                b: rawData.map(function(d) {
                    return d.b;
                }),
                c: rawData.map(function(d) {
                    return d.c;
                }),
                text: rawData.map(function(d) {
                    return d.label;
                }),
                marker: {
                    symbol: 100,
                    color: '#DB7365',
                    size: 14,
                    line: {
                        width: 2
                    }
                },
            }];
            var layout = {
                ternary: {
                    sum: 100,
                    aaxis: this.makeAxis(fields[0].getLabel(), 0),
                    baxis: this.makeAxis(fields[1].getLabel(), 45),
                    caxis: this.makeAxis(fields[2].getLabel(), -45),
                    bgcolor: '#fff1e0'
                },
                annotations: [{
                    showarrow: false,
                    text: this.getProperty("chartTitle", ""),
                    x: 1.0,
                    y: 1.3,
                    font: {
                        size: 15
                    }
                }],
                paper_bgcolor: '#fff1e0',
            };


            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}


function RamaddaDotplotDisplay(displayManager, id, properties) {

    $.extend(this, {
        width: "600px",
        height: "400px",
    });
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_DOTPLOT, properties);
    RamaddaUtil.inherit(this, SUPER);


    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        getDisplayStyle: function() {
            return "";
            return "border: 1px #ccc solid;";
        },

        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
            var pointData = this.getData();
            if (pointData == null) return;
            let allFields = pointData.getRecordFields();
            let stringField = this.getFieldByType(allFields, "string");
            if (!stringField) {
                stringField = allFields[0];
            }

            let fields = this.getFieldsByType(allFields, "numeric");
            if (fields.length == 0) {
		fields = this.getFieldsByType(allFields, "date");
	    }
            if (fields.length == 0) {
                this.displayError("No numeric fields specified");
                return;
            }

            let labels = null;
            let labelName = "";
            if (stringField) {
                labels = this.getColumnValues(records, stringField).values;
                labelName = stringField.getLabel();
            }
            var colors = this.getColorTable(true);
            if (!colors)
                colors = ['rgba(156, 165, 196, 0.95)', 'rgba(204,204,204,0.95)', 'rgba(255,255,255,0.85)', 'rgba(150,150,150,0.95)']
            var plotData = [];
            var colorBy = this.getColorByInfo(records);
	    var  didColorBy = false;
            for (i in fields) {
                var color = i >= colors.length ? colors[0] : colors[i];
                var field = fields[i];
                var values = this.getColumnValues(records, field).values;
                if (colorBy.index >= 0) {
		    color = [];
		    records.map(record=>{
			var value = record.getData()[colorBy.index];
			didColorBy = true;
			color.push(colorBy.getColor(value, record));
                    })
		}
                if (!labels) {
                    labels = [];
                    for (var j = 0; j < values.length; j++) {
                        labels.push("Point " + (j + 1));
                    }
                }
                plotData.push({
                    type: 'scatter',
                    x: values,
                    y: labels,
                    mode: 'markers',
                    name: field.getLabel(),
                    marker: {
                        color: color,
                        line: {
                            color: 'rgba(156, 165, 196, 1.0)',
                            width: 1,
                        },
                        symbol: 'circle',
                        size: 16
                    }
                });
            }



            var layout = {
                title: '',
                yaxis: {
                    title: this.getProperty("yAxisTitle", labelName),
                    showline: this.getProperty("yAxisShowLine", true),
                    showgrid: this.getProperty("yAxisShowGrid", true),
                },
                xaxis: {
                    title: this.getProperty("xAxisTitle", fields[i].getLabel()),
                    showgrid: this.getProperty("xAxisShowGrid", false),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
                },
                margin: {
                    l: this.getProperty("marginLeft", 140),
                    r: this.getProperty("marginRight", 40),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 20),
                },
                legend: {
                    font: {
                        size: 10,
                    },
                    yanchor: 'middle',
                    xanchor: 'right'
                },
                paper_bgcolor: this.getProperty("chart.fill", 'rgb(254, 247, 234)'),
                plot_bgcolor: this.getProperty("chartArea.fill", 'rgb(254, 247, 234)'),
                hovermode: 'closest'
            };
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
	    if(didColorBy) {
		colorBy.displayColorTable();
	    }

        },
    });
}


function RamaddaProfileDisplay(displayManager, id, properties) {
//    if(!properties.width) properties.width="400px";
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_PROFILE, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    this.defineProperties([
	{label:'Profile Properties'},
	{p:'indexField',d:null,ex:''},
	{p:'fields',d:null,ex:''},
	{p:'profileMode',d:'lines',ex:'lines|markers|lines+markers'},
	{p:'yAxisTitle',d:'Pressure- Digiquartz',ex:''},
	{p:'yAxisShowLine',d:'true',ex:'false'},
	{p:'yAxisShowGrid',d:'true',ex:'false'},
	{p:'xAxisTitle',d:'',ex:''},
	{p:'xAxisShowGrid',d:'true',ex:'false'},
	{p:'xAxisShowLine',d:'true',ex:'false'},
	{p:'yAxisReverse',d:false,ex:'true'},
	{p:'marginLeft',d:'60',ex:'60'},
	{p:'marginRight',d:'100',ex:'100'},
	{p:'marginBottom',d:'50',ex:'50'},
	{p:'marginTop',d:'100',ex:'100'},
	{p:'showLegend',d:'true',ex:'false'},
	{p:'legendYAnchor',d:null,ex:'top|middle|bottom'},
	{p:'legendXAnchor',d:null,ex:'right|center|left'},
	{p:'chart.fill',d:'rgb(254, 247, 234)',ex:'color'},
	{p:'chartArea.fill',d:'rgb(254, 247, 234)',ex:'color'},
	{p:'xAxis2Title',d:'Conductivity',ex:''},
    ]);

    RamaddaUtil.defineMembers(this, {
        getDisplayStyle: function() {
            return "";
        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
//	    this.writePropertyDef = "";
	    let indexField = this.getFieldById(null,this.getProperty("indexField"));
	    if(indexField==null) {
                this.setContents(this.getMessage("No indexField specified"));
		return;
	    }
            let fields = this.getSelectedFields(this.getData().getRecordFields());
            if (fields.length == 0) {
		let tmp = this.getFieldsByType(null, "numeric");
		if(tmp.length>0) fields.push(tmp[0]);
	    }
            if (fields.length == 0) {
                this.setContents(this.getMessage("No fields found"));
		return;
	    }
            let index = this.getColumnValues(records, indexField).values;
            let data = [];
            fields.forEach((field,idx)=>{
		let x = this.getColumnValues(records, field).values;
		let trace =   {
		    y: index,
		    x: x,
		    type: 'scatter',
		    mode: this.getProperty("profileMode",'lines'),
                    name: field.getLabel(),
                    marker: {
                        line: {
                            color: 'rgba(156, 165, 196, 1.0)',
                            width: 1,
                        },
                        symbol: 'circle',
                        size: 16
                    }
		};
		if(idx>0)
		    trace.xaxis="x2";
		data.push(trace);
	    });

	    let labelName = indexField.getLabel();
            let layout = {
                yaxis: {
		    autorange: this.getProperty("yAxisReverse",false)?"reversed":null,
                    title: this.getProperty("yAxisTitle", labelName),
                    showline: this.getProperty("yAxisShowLine", true),
                    showgrid: this.getProperty("yAxisShowGrid", true),
                },
                xaxis: {
                    title: this.getProperty("xAxisTitle", fields[0].getLabel()),
                    showgrid: this.getProperty("xAxisShowGrid", true),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
		},
                margin: {
                    l: this.getProperty("marginLeft", 60),
                    r: this.getProperty("marginRight", 100),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 100),
                },
                legend: {
                    font: {
                        size: 10,
                    },
                    yanchor: this.getProperty("legendYAnchor"),
                    xanchor: this.getProperty("legendXAnchor"),
                },
                showlegend: this.getProperty("showLegend",true),
                paper_bgcolor: this.getProperty("chart.fill", 'rgb(254, 247, 234)'),
		paper_bgcolor: this.getProperty("chart.fill", 'transparent'),		
                plot_bgcolor: this.getProperty("chartArea.fill", 'rgb(254, 247, 234)'),
                hovermode: 'closest'
            };
	    if(fields.length>1) {
                layout.xaxis2 =  {
		    overlaying: 'x', 
		    side: 'top',
                    title: this.getProperty("xAxis2Title", fields[1].getLabel()),
                    showgrid: this.getProperty("xAxisShowGrid", true),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)'
                };
	    }
            this.setDimensions(layout, 2);
            this.makePlot(data, layout);
	    if(this.writePropertyDef)
		console.log(this.writePropertyDef);
	    this.writePropertyDef=null;
        },
    });
}



function RamaddaSplomDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "600px",
        height: "600px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_SPLOM, properties));

    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        setDimensions: function(layout, widthDelta) {
            var width = parseInt(this.getProperty("width", "400").replace("px", "").replace("%", ""));
            var height = parseInt(this.getProperty("height", "400").replace("px", "").replace("%", ""));
            layout.width = width - widthDelta;
            layout.height = height;
        },
        makeAxis: function() {
            return {
                showline: false,
                zeroline: false,
                gridcolor: this.getProperty("gridColor", "white"),
                ticklen: 2,
                tickfont: {
                    size: this.getProperty("tickFontSize", 12)
                },
                titlefont: {
                    size: this.getProperty("titleFontSize", 12)
                }
            }
        },
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var fields = this.getSelectedFields(this.getData().getRecordFields());
            if (fields.length == 0) {
                fields = this.getData().getRecordFields();
            }
            var labels;
            if (this.getProperty("labels"))
                labels = this.getProperty("labels").split(",");

            var dataObj = {
                type: 'splom',
                dimensions: [],
                marker: {
                    size: parseInt(this.getProperty("markerSize", 5)),
                    line: {
                        color: this.getProperty("lineColor", 'white'),
                        width: 0.5
                    }
                }
            };


            var colorByField = this.getFieldById(fields, this.getProperty("colorBy"));
            var colorBy = this.getProperty("colorBy");
            if (colorBy) {
                var colorByField = this.getFieldById(fields, colorBy);
                if (colorByField) {
                    var obj = this.getColumnValues(records, colorByField);
                    var colors = this.getColorTable();
                    if (!colors) colors = Utils.getColorTable("blue_white_red");
                    var colorscale = [];
                    var min = parseFloat(this.getProperty("colorByMin", obj.min));
                    var max = parseFloat(this.getProperty("colorByMax", obj.max));
                    if (Utils.isDefined(colors.min)) {
                        var clippedColors = [];
                        for (var i = 0; i < colors.colors.length; i++) {
                            var percent = i / colors.colors.length;
                            var value = colors.min + (colors.max - colors.min) * percent;
                            if (value >= min && value <= max)
                                clippedColors.push(colors.colors[i]);
                        }
                        colors = clippedColors;
                    }
                    if (colors.colors) colors = colors.colors;
                    var range = max - min;
                    var colorValues = [];
                    for (var i = 0; i < obj.values.length; i++) {
                        var value = obj.values[i];
                        var percent = (value - min) / range;
                        colorValues.push(percent);
                    }
                    for (var i = 0; i < colors.length; i++) {
                        var value = i / colors.length;
                        var next = (i + 1) / colors.length;
                        colorscale.push([value, colors[i]]);
                        colorscale.push([next, colors[i]]);
                    }
                    dataObj.marker.color = colorValues;
                    dataObj.marker.colorscale = colorscale;
                }

                this.displayColorTable(colors, ID_DISPLAY_BOTTOM, min, max);
            }

            var stringField = this.getFieldByType(fields, "string");
            if (stringField) {
                var l = this.getColumnValues(records, stringField).values;
                dataObj.text = [];
                for (var i = 0; i < l.length; i++)
                    dataObj.text.push(stringField.getLabel() + ": " + l[i]);
            }

            var plotData = [dataObj];
            var layout = {
                autosize: false,
                hovermode: 'closest',
                dragmode: 'select',
                plot_bgcolor: this.getProperty("bgColor", 'rgba(240,240,240, 0.95)'),
                margin: {
                    l: this.getProperty("marginLeft", 140),
                    r: this.getProperty("marginRight", 40),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 20),
                },
            }

            var cnt = 0;
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (!field.isFieldNumeric()) continue;
                var values = this.getColumnValues(records, field).values;
                var label;
                if (labels && i < labels.length)
                    label = labels[i];
                else
                    label = field.getUnitLabel();
                dataObj.dimensions.push({
                    label: label,
                    values: values
                });
                var key = "axis" + (cnt == 0 ? "" : "" + (cnt + 1));
                layout["x" + key] = this.makeAxis();
                layout["y" + key] = this.makeAxis();
                cnt++;
            }
            this.setDimensions(layout, 2);
            this.makePlot(plotData, layout);
        },
    });
}



function RamaddaPTreemapDisplay(displayManager, id, properties) {
    var SUPER;
    $.extend(this, {
        width: "400px",
        height: "400px",
    });
    RamaddaUtil.inherit(this, SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TREEMAP, properties));
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
            var selectedFields = this.getSelectedFields(this.getData().getRecordFields());
            var field = this.getFieldByType(selectedFields, "numeric");
            if (!field) {
                this.displayError("No numeric field specified");
                return;
            }
            var values = this.getColumnValues(records, field).values;
            // declaring arrays
            var shapes = [];
            var annotations = [];
            var counter = 0;

            // For Hover Text
            var x_trace = [];
            var y_trace = [];
            var text = [];

            //colors
            var colors = this.getColorTable();
            if (colors.colors) colors = colors.colors;

            // Generate Rectangles using Treemap-Squared
            var rectangles = Treemap.generate(values, 100, 100);

            for (var i in rectangles) {
                var shape = {
                    type: 'rect',
                    x0: rectangles[i][0],
                    y0: rectangles[i][1],
                    x1: rectangles[i][2],
                    y1: rectangles[i][3],
                    line: {
                        width: 2
                    },
                    fillcolor: colors[counter]
                };
                shapes.push(shape);
                var annotation = {
                    x: (rectangles[i][0] + rectangles[i][2]) / 2,
                    y: (rectangles[i][1] + rectangles[i][3]) / 2,
                    text: String(values[counter]),
                    showarrow: false
                };
                annotations.push(annotation);

                // For Hover Text
                x_trace.push((rectangles[i][0] + rectangles[i][2]) / 2);
                y_trace.push((rectangles[i][1] + rectangles[i][3]) / 2);
                text.push(String(values[counter]));

                // Incrementing Counter
                counter++;
            }

            // Generating Trace for Hover Text
            var trace0 = {
                x: x_trace,
                y: y_trace,
                text: text,
                mode: 'text',
                type: 'scatter'
            };

            var layout = {
                height: 700,
                width: 700,
                shapes: shapes,
                hovermode: 'closest',
                annotations: annotations,
                xaxis: {
                    showgrid: false,
                    zeroline: false
                },
                yaxis: {
                    showgrid: false,
                    zeroline: false
                }
            };

            var data = {
                data: [trace0]
            };
            this.setDimensions(layout, 2);
            this.makePlot([trace0], layout);
        },
    });





}
function TextcountDisplay(displayManager, id, properties) {
    let SUPER  =  new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_TEXTCOUNT, properties);
    let myProps = [
	{label:'Text Count Display'},
	{p:'patterns',ex:'foo,bar'},
	{p:'labels',ex:'Foo,Bar'},
	{p:'textField',ex:''},
    ];
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
        getDialogContents: function(tabTitles, tabContents) {
	    let html = HtmlUtils.div(["id",this.getDomId("dialog_set_pattern")],"Change patterns") + "<br>" +
		HtmlUtils.textarea("",Utils.join(this.patternList||[],"\n"),["id", this.getDomId("dialog_patterns"),"rows","10"]);

	    
            tabTitles.push("Patterns");
            tabContents.push(html);
            SUPER.getDisplayDialogContents.call(this, tabTitles, tabContents);
        },
        initDialog: function() {
            SUPER.initDialog.call(this);
	    let _this = this;
            this.jq("dialog_set_pattern").button().click(function() {
		_this.patterns = _this.jq("dialog_patterns").val().trim().replace(/\n/g,",");
		_this.updateUI();
            });

        },
        updateUI: function() {
            let records = this.filterData();
            if (!records) return;
	    let patterns = this.getProperty("patterns");
	    if(patterns == null) {
		this.setContents(this.getMessage("No patterns specified"));
		return;
	    }
	    this.patternList = patterns.split(",");
	    let labels = this.getProperty("labels");
	    if(labels) {
		labels = labels.split(",");
	    }

	    this.textField = this.getFieldById(null, this.getProperty("textField"));
	    if(!this.textField) {
		this.textField = this.getFieldByType(null, "string");
	    }
	    if(!this.textField) {
		this.setContents(this.getMessage("No text field in data"));
		return;
	    }

	    let count = [];
	    let matchers = [];
	    this.patternList.map(p=>{
		count.push(0);
		matchers.push(new TextMatcher(p));
	    });

            for (var rowIdx = 0; rowIdx < records.length; rowIdx++) {
                var record = records[rowIdx];
                var row = record.getData();
		var value = record.getValue(this.textField.getIndex());
		matchers.map((m,index)=>{
		    if(m.matches(value)) {
			count[index]++;
		    }
		});
	    }

	    let data = [{
		type: 'bar',
		x: count,
		y: labels?labels:this.patternList,
		orientation: 'h',
	    }];
	    let layout = {
		margin: {
		    l: 100,
		    r: 50,
		    b: 50,
		    t: 10,
		    padding:4
		},
	    };
	    if(Utils.isDefined(this.properties.height)) {
		layout.height = +this.properties.height;
	    }

            this.makePlot(data, layout);
        },
        handleClickEvent: function(data) {
	    if(!data.points || data.points.length<=0) {
		return;
	    }
	    var pointNumber = data.points[0].pointNumber;
	    var pattern = this.patternList[pointNumber];
	    var args = {
		property: PROP_FILTER_VALUE,
		fieldId: this.textField.getId(),
		value: pattern
	    };
	    this.propagateEvent("handleEventPropertyChanged", args);
	},

    });
}



function CombochartDisplay(displayManager, id, properties) {
    let SUPER  =  new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_COMBOCHART, properties);
    let myProps = [
	{label:'Combo Chart'},
	{p:'fields',ex:''},
 	{p:'&lt;field&gt;.axisSide',ex:'right|left'},
	{p:'&lt;field&gt;.axisTitle',ex:''},
	{p:'&lt;field&gt;.chartType',ex:'scatter|bar'},
	{p:'chartType',ex:'scatter|bar'},
	{p:'&lt;field&gt;.chartColor',ex:''},
	{p:'chartType',ex:''},
	{p:'xAxisTitle',ex:''},
	{p:'xAxisShowGrid',ex:''},
	{p:'xAxisShowLine',ex:''},
	{p:'legendBackground',ex:''},
	{p:'legendBorder',ex:''},
	{p:'chartBackground',ex:''},
	{p:'plotBackground',ex:''},
	{p:'marginLeft',ex:''},
	{p:'marginRight',ex:''},
	{p:'marginBottom',ex:''},
	{p:'marginTop',ex:''},
	{p:'chartPad',ex:''},
    ];	
    defineDisplay(addRamaddaDisplay(this), SUPER, myProps, {
	updateUI: function() {
            let records = this.filterData();
            if (!records) return;
	    var layout = {
                xaxis: {
                    title: this.getProperty("xAxisTitle", "Time"),
                    showgrid: this.getProperty("xAxisShowGrid", false),
                    showline: this.getProperty("xAxisShowLine", true),
                    linecolor: 'rgb(102, 102, 102)',
                    titlefont: {
                        font: {
                            color: 'rgb(204, 204, 204)'
                        }
                    },
                    tickfont: {
                        font: {
                            color: 'rgb(102, 102, 102)'
                        }
                    },
                    autotick: true,
                    ticks: 'outside',
                    tickcolor: 'rgb(102, 102, 102)',
		  
		},
                legend: {
                    font: {
                        size: 10,
                    },
		    bgcolor: this.getProperty("legendBackground",'rgba(255,255,255,0)'),
		    bordercolor: this.getProperty("legendBorder",'rgba(255,255,255,0)'),
		    x: 0,
		    y: 1.0,

                },
		margin: {
                    l: this.getProperty("marginLeft", 50),
                    r: this.getProperty("marginRight", 50),
                    b: this.getProperty("marginBottom", 50),
                    t: this.getProperty("marginTop", 0),
		    pad: this.getProperty("chartPad", 4),
		},
		paper_bgcolor: this.getProperty("chartBackground", 'rgb(255,255,255,0)'),
		plot_bgcolor: this.getProperty("plottBackground", 'rgb(255,255,255,0)'),
	    };
	    let fields   = this.getFieldsByIds(null, this.getPropertyFields("",true));
	    var data = [];
	    var domain = [];
	    records.map((r,idx)=>{
		domain.push(r.getTime());
	    });
	    let right =  true;
	    fields.map((field,idx)=>{
		let values = this.getColumnValues(records, field).values;
		var trace = {
		    x: domain,
		    y: values,
		    name: field.getLabel(),
		    type: this.getProperty(field.getId()+".chartType",this.getProperty("chartType",'scatter')),
		    marker: {color: this.getProperty(field.getId()+".chartColor",this.getProperty("chartColor"))},
		};
		if(idx>0) {
		    trace.yaxis = "y" + (idx+1);
		}
		data.push(trace);
		var yAxisId = idx>0?"yaxis"+(idx+1):"yaxis";
		var axis = {
		    title: this.getProperty(field.getId()+".axisTitle" ,field.getLabel()), 
		    titlefont: {color: 'rgb(0,0,0)'},
		    tickfont: {color: 'rgb(0,0,0,)'},
		    side: this.getProperty(field.getId()+".axisSide",
					   this.getProperty("axisSide", right?'right':'left'))
		};
		if(idx>0)
		    axis.overlaying='y';
		layout[yAxisId] = axis;
		right = !right;
	    });
            this.setDimensions(layout);
            this.makePlot(data, layout);
	}
    });
}





function RamaddaParcoordsDisplay(displayManager, id, properties) {
    let SUPER = new RamaddaPlotlyDisplay(displayManager, id, DISPLAY_PLOTLY_PARCOORDS, properties);
    RamaddaUtil.inherit(this, SUPER);
    addRamaddaDisplay(this);
    RamaddaUtil.defineMembers(this, {
        updateUI: function() {
            var records = this.filterData();
            if (!records) return;
	    let fields   = this.getFieldsByIds(null, this.getPropertyFields(""));
            if (fields.length == 0) {
                this.displayError("No fields specified");
                return;
            }
	    let dimensions =[];
	    let maxLabelLength = this.getProperty("maxLabelLength",200/fields.length);
	    fields.map(f=>{
		let col = this.getColumnValues(records, f)
		let values = col.values;
		let ticktext = null;
		let tickvals = null;
		if(f.isString()) {
		    let tmpValues = [];
		    let seen = {};
		    ticktext =[];
		    tickvals =[];
		    let cnt = 1;
		    values.map(v=>{
			if(!seen[v]) {
			    seen[v] = cnt++;
			    ticktext.push(v);
			    tickvals.push(seen[v]);
			}
			tmpValues.push(seen[v]);
		    });
		    values = tmpValues;
		}

		let label = this.getProperty(f.getId()+".label",f.getLabel());
		if(label.length>maxLabelLength)
		    label = label.substring(0,maxLabelLength-1)+"...";
		let dim  = {
		    label:label,
		    values:values
		};
		if(this.getProperty(f.getId()+".constraintrange")) {
		    dim.constraintrange = this.getProperty(f.getId()+".constraintrange").split(",");
		}
		if(this.getProperty(f.getId()+".tickvals")) {
		    dim.tickvals = this.getProperty(f.getId()+".tickvals").split(",");
		}
		if(this.getProperty(f.getId()+".ticktext")) {
		    dim.ticktext = this.getProperty(f.getId()+".ticktext").split(",");
		} else {
		    dim.ticktext = ticktext;
		    dim.tickvals = tickvals;		    
		}
		dimensions.push(dim);
	    });

	    let color = this.getProperty("color", 'blue');
	    let colorByField = this.getFieldById(null, this.getProperty("colorBy"));
	    let line = {};
	    let ct = null;
	    let ctMin=0,ctMax=0;
            if (colorByField) {
		let colorValues =   this.getColumnValues(records, colorByField);
		ctMin = colorValues.min;
		ctMax = colorValues.max;
		line.color  = colorValues.values;
		ct = this.getColorTable(true,null,null);
		if(ct) {
		    let colors = [];
		    let step   = 1/(ct.length-1);
		    ct.map((c,idx)=>{
			let v = idx*step;
			colors.push([v,c]);
		    });
		    line.colorscale = colors;
		}
	    }

	    var trace = {
		type: 'parcoords',
		line: line,
		dimensions:dimensions,
	    };

	    var data = [trace]	    
	    let layout  = {
		margin: {
		    l:175,
		    t:50,
		    b:25
		}
	    };
	    this.setDimensions(layout, 2);
	    
            this.makePlot(data, layout);
	    if(ct)
		this.displayColorTable(ct, ID_COLORTABLE,ctMin,ctMax);

        },
    });
}
