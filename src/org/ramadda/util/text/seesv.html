Usage:
    -help  (print this help))
    -help:<topic search string>  (print help that matches topic)
Specify the input. Default is assumed to be a CSV but can support HTML, JSON, XML, Shapefile, etc.
    -delimiter <delimiter Use 'space' for space, 'tab' for tab>  (Specify the input delimiter)
    -tab  (Use tabs. A shortcut for -delimiter tab)
    -widths <widths w1,w2,...,wN>  (Columns are fixed widths)
    -quotesnotspecial  (Don't treat quotes as special characters)
    -cleaninput  (Input is one text line per row. i.e., no new lines in a data row. Setting this can improve performance on large files)
    -bom  (Input has a leading byte order mark (BOM) that should be stripped out)
    -encoding <encoding File Encoding see https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html>  (Specify the file encoding)
    -header <header Column names>  (Raw header)
    -multifiles <template File template  - ${source} ${name} ${count}>  (Treat input files separately)
    -json <arrayPath Path to the array e.g., obj1.arr[2].obj2> <objectPaths One or more paths to the objects e.g. geometry,features>  (Parse the input as json)
    -jsonvalue <columns Column names> <arrayPath Path to the array e.g., obj1.arr[2].obj2>  (Extract a value from a JSON column)
    -geojson <includePolygon Include polygon>  (Parse the input as geojson)
    -pdf  (Read input from a PDF file.)
    -xml <path Path to the elements>  (Parse the input as xml)
    -shapefile <props "addPoints true addShapes false">  (Parse the input shapefile)
    -lines  (Parse the input as text lines. Treat each line as one column)
    -htmltable <skip Number of tables to skip> <pattern Pattern to skip to> <properties Other name value args - <ul><li> numTables N:Number of tables to process. Default is 1<li> removeEntity true:remove HTML entities <li> removePattern pattern<li> extractUrls true <li> columnN.extractUrls true: N=column number<li> stripTags false: strip any HTML tags. Default =true<li> columnN.stripTags false: N=column number. Set stripTags for the column</ul>>  (Parse tables in the input html file)
    -htmlpattern <columns Column names> <startPattern> <endPattern> <pattern Row pattern. Use (...) to match columns>  (Parse the input html file)
    -harvest <pattern regexp to match>  (Harvest links in web page. This results in a 2 column dataset with fields: label,url)
    -text <comma separated header> <chunk pattern> <token pattern>  (Extract rows from the text)
    -extractpattern <comma separated header> <token pattern>  (Extract rows from the text)
    -tokenize <header header1,header2...> <pattern>  (Tokenize the input from the pattern)
    -sql <db The database id (defined in the environment)> <table Comma separate list of tables to select from> <columns Comma separated list of columns to select> <where column1:expr:value;column2:expr:value;...
e.g.: name:like:joe;age:>:60
Where expr is: =|<|>|<>|like|notlike> <properties name space value properties. e.g., join col1,col2>  (Read data from the given database)
    -synthetic <header comma separated header> <values comma separated values> <number_rows Number of rows>  (Generate an empty file with the given number of rows)
    -prune <bytes Number of leading bytes to remove>  (Prune out the first N bytes)
    -deheader  (Strip off the RAMADDA point header)
    -headernames  (Make the header proper capitalization)
    -headerids  (Clean up the header names)
    -ids  (Use canonical names)
    -cat <*.csv>  (Concat the columns in one or more csv files)
    -append <skip Number of rows to skip> <files *.csv>  (Append the files, skipping the given rows in the latter files)
    -chop <numlines Number of lines to leave> <file *.csv>  (Write out last N lines. include the header)
    -filenamepattern <pattern Pattern to match> <columnnames Comma separated list of column names>  (Extract strings from the file name and add them as new columns)

    -skiplines <lines How many raw lines to skip>  (Skip number of raw lines.)
    -maxrows <rows Number of rows>  (Set max rows to process)
    -find <columns Column indices. Can include ranges, e.g. 0-5> <pattern regexp or prefix with includes:s1,s2 to do substrings match>  (Pass through rows that the columns each match the pattern)
    -notpattern <columns Column indices. Can include ranges, e.g. 0-5> <pattern regexp or prefix with includes:s1,s2 to do substrings match>  (Pass through rows that don't match the pattern)
    -if  (Next N args specify a filter command followed by any change commands followed by an -endif.)
    -start <start pattern>  (Start at pattern in source file)
    -stop <stop pattern>  (End at pattern in source file)
    -rawlines <lines Pass through and print out rawlines unprocesed>  ()
    -inputnotcontains <filters Comma separated list of strings to filter on>  (Filter out input lines that contain any of the strings)
    -min <min # columns>  (Only pass thorough lines that have at least this number of columns. Specify blank to use the number of columns in the header)
    -max <max # columns>  (Only pass through lines that have no more than this number of columns. Specify blank to use the number of columns in the header)
    -numcolumns <number>  (Remove or add values so each row has the number of columns)
    -has <columns Column indices. Can include ranges, e.g. 0-5>  (Only pass through anything if the data has the given columns)
    -fuzzypattern <threshold Score threshold 0-100. Default:85. Higher number better match> <columns Column indices. Can include ranges, e.g. 0-5> <pattern>  (Pass through rows that the columns each fuzzily match the pattern)
    -lengthgreater <columns Column indices. Can include ranges, e.g. 0-5> <length>  (Pass through rows that the length of the columns is greater than)
    -same <column1> <column2>  (Pass through where the 2 columns have the same value)
    -notsame <column1> <column2>  (Pass through where the 2 columns don't have the same value)
    -unique <columns Column indices. Can include ranges, e.g. 0-5> <mode What type of matching is done - exact (exact match) or clean (lower case and remove whitespace) or fuzzy:threshold (do fuzzy matching with threshold from 1: no similarity to 100: exact match. use fuzzy:? to print out values)>  (Pass through unique values)
    -dups <columns Column indices. Can include ranges, e.g. 0-5>  (Pass through duplicate values)
    -sample <probablity 0-1 probability of passing through a row>  (Pass through rows based on probablity)
    -minvalue <key column> <value column>  (Pass through the row that has the min value in the group of columns defined by the key column)
    -maxvalue <key column> <value column>  (Pass through the row that has the max value in the group of columns defined by the key column)
    -eq <column> <value>  (Pass through rows that the column value equals the given value)
    -ne <column> <value>  (Pass through rows that the column value does not equal the given value)
    -gt <column> <value>  (Pass through rows that the column value is greater than the given value)
    -ge <column> <value>  (Pass through rows that the column value is greater than or equals the given value)
    -lt <column> <value>  (Pass through rows that the column value is less than the given value)
    -le <column> <value>  (Pass through rows that the column value is less than or equals the given value)
    -between <column> <min value> <max value>  (Extract rows that are within the range)
    -notbetween <column> <min value> <max value>  (Extract rows that are not within the range)
    -betweenstring <column> <start string> <end string>  (Extract rows that are between the given strings)
    -notbetweenstring <column> <start string> <end string>  (Extract rows that are between the given strings)
    -groupfilter <column key column> <value_column Value column> <operator> <value>  (One row in each group has to match)
    -before <column> <format Date Format, e.g. yyyy-MM-dd> <date> <format2 Date Format, e.g. yyyy-MM-dd>  (Pass through rows whose date is before the given date)
    -after <column> <format Date Format, e.g. yyyy-MM-dd> <date> <format2 Date Format, e.g. yyyy-MM-dd>  (Pass through rows whose date is after the given date)
    -countvalue <column> <count>  (No more than count unique values)
    -decimate <rows # of start rows to include> <skip skip factor>  (only include every <skip factor> row)
    -ifin <column Column in the file> <file The file> <column2 Column in main file>  (Pass through rows that the columns with ID is in given file)
    -ifnotin <column Column in the file> <file The file> <column2 Column in main file>  (Pass through rows that the columns with ID is not in given file)
    -ifmatchesfile <pattern Pattern template, e.g. ^${value}> <column Column in the file> <file The file> <column2 Column in main file>  (Pass through rows that the columns with ID begins with something in the given file)
    -ifnotmatchesfile <pattern Pattern template, e.g. ^${value}> <file The file> <column2 Column in main file>  (Pass through rows that the columns with ID does not begin with something in the given file)
    -skippattern <pattern>  (Skip any line that matches the pattern)
    -skip <rows How many rows to skip>  (Skip number of processed rows.)
    -ensurenumeric <columns Column indices. Can include ranges, e.g. 0-5>  (Throw error if non-numeric)
Add/remove columns, rows, restructure, etc
    -columns <columns Column indices. Can include ranges, e.g. 0-5>  (Only include the given columns)
    -notcolumns <columns Column indices. Can include ranges, e.g. 0-5>  (Don't include given columns)
    -firstcolumns <columns Column indices. Can include ranges, e.g. 0-5>  (Move columns to beginning)
    -columnsbefore <column Column to move before> <columns Columns to move>  (Move columns before the given column)
    -columnsafter <column Column to move after> <columns Columns to move>  (Move columns after given column)
    -delete <columns Column indices. Can include ranges, e.g. 0-5>  (Remove the columns)
    -cut <rows One or more rows. -1 to the end. e.g., 0-3,5,10,-1>  (Drop rows)
    -include <rows one or more rows, -1 to the end>  (Only include specified rows)
    -rows_first <columns columns to match on> <pattern Pattern>  (Move rows to the top that match the pattern)
    -rows_last <columns columns to match on> <pattern Pattern>  (Move rows to the end of list that match the pattern)
    -copy <column> <name>  (Copy column)
    -add <names Comma separated list of new column names> <values Comma separated list of new values>  (Add new columns)
    -insert <column Column to insert before> <name Name of new column> <values Single value or comma separated for multiple rows>  (Insert new column values)
    -concat <columns Column indices. Can include ranges, e.g. 0-5> <delimiter> <name Name of new colums>  (Create a new column from the given columns)
    -concatrows <num_rows Number of rows>  (Concatenate multiple rows into a single row)
    -combine <column> <delimiter> <column name New column name>  (Combine columns with the delimiter. deleting columns)
    -combineinplace <column> <delimiter> <column name New column name>  (Combine columns with the delimiter)
    -merge <columns Columns to merge> <name New column(s) name> <operator Operator>  (Apply operators to columns)
    -split <column> <delimiter What to split on> <names Comma separated new column names>  (Split the column)
    -splat <keycol Key column> <column> <delimiter> <name new column name>  (Create a new column from the values in the given column)
    -roll <columns Column indices. Can include ranges, e.g. 0-5>  (Roll columns down into rows)
    -shift <rows Rows to apply to> <column Column to start at> <count>  (Shift columns over by count for given rows)
    -slice <columns Columns to move> <dest Desc column to move to> <fill Comma separated list of values to fill out the new row>  (Slide columns down and over to append new rows to the bottom)
    -addcell <row> <column> <value>  (Add a new cell at row/column)
    -deletecell <row> <column>  (Delete cell at row/column)
    -clone <count Number of clonese>  (Clone each row N times)
    -appendrows <skip How many rows to skip> <count How many rows to merge> <delimiter How many rows to merge>  (Only include specified rows)
    -mergerows <rows 2 or more rows> <delimiter> <close>  (Merge rows)
    -rowop <keys Key columns> <values Value columns> <operator Operator>  (Apply an operator to columns and merge rows)
    -rotate  (Rotate the data)
    -flip  (Reverse the order of the rows except the header)
    -makefields <column Column to get new column header#> <value columns Columns to get values from> <unique column The unique value, e.g. date> <other columns Other columns to include>  (Make new columns from data values)
    -furl <columns Column indices. Can include ranges, e.g. 0-5> <header label> <value label>  (Use values in header to make new row)
    -explode <column>  (Make separate files based on value of column)
    -join <key columns key columns the file to join with> <value_columns value columns> <file File to join with> <source_columns source key columns> <default_value default value>  (Join the 2 files together)
    -fuzzyjoin <threshold Score threshold 0-100. Default:85. Higher number better match> <key columns Numeric column numbers of the file to join with> <value_columns numeric columns of the values to join> <file File to join with> <source_columns source key columns> <default_value default value>  (Join the 2 files together using fuzzy matching logic)
    -cross <file File to cross with>  (Make a cross product of 2 data files)
    -normal <columns Columns>  (Normalize the strings)
    -countunique <columns Column indices. Can include ranges, e.g. 0-5>  (Count number of unique values)
    -dissect <column> <pattern e.g., "(field1:.*) (field2:.*) ...">  (Make fields based on patterns)
    -keyvalue <column>  (Make fields from key/value pairs, e.g. name1=value1 name2=value2 ...)
    -firstchars <column> <name New column name> <number Number of characters>  (Extract first N characters and create new column)
    -lastchars <column> <name New column name> <number Number of characters>  (Extract last N characters and create new column)
    -between_indices <column> <name New column name> <start Start index> <end End index>  (Extract characters between the 2 indices)
    -fromheading <columns Columns of headings> <names Comma separated list of new column names> <pattern Regexp to apply to header with () defining column values>  (Extract column values from headings)

    -change <columns Column indices. Can include ranges, e.g. 0-5> <pattern> <substitution string use $1, $2, etc for pattern (...) matches>  (Change columns)
    -changerow <rows Row indices. Can include ranges, e.g. 0-5> <columns Column indices. Can include ranges, e.g. 0-5> <pattern> <substitution string use $1, $2, etc for pattern (...) matches>  (Change the values in the row/cols)
    -replace <columns Column indices. Can include ranges, e.g. 0-5> <substitution string use $1, $2, etc for pattern (...) matches
use {value} for value>  (Replace)
    -set <columns Column indices. Can include ranges, e.g. 0-5> <rows Row indices. Can include ranges, e.g. 0-5> <value>  (Write the value into the cells)
    -cleanwhitespace <columns Column indices. Can include ranges, e.g. 0-5>  (Clean whitespace)
    -macro <pattern> <template> <column label>  (Look for the pattern in the header and apply the template to make a new column, template: '{1} {2} ...', use 'none' for column name for no header)
    -setcol <column match col #> <pattern> <write column> <value>  (Write the value into the write col for rows that match the pattern)
    -copyif <columns Column indices. Can include ranges, e.g. 0-5> <pattern> <column1> <column2>  (Copy column 2 to column 3 if all of the columns match the pattern)
    -copycolumns <columns1> <columns2>  (Copy columns 1  to columns 2)
    -filldown <columns Column indices. Can include ranges, e.g. 0-5>  (Fill down with last non-null value)
    -fillacross <columns Column indices. Can include ranges, e.g. 0-5> <rows One or more rows. -1 to the end. e.g., 0-3,5,10,-1>  (Fill across with last non-null value)
    -unfill <columns Column indices. Can include ranges, e.g. 0-5>  (Set following cells to blank if the same as previous cell)
    -priorprefix <column> <pattern> <delimiter>  (Append prefix from the previous element to rows that match pattern)
    -case <column> <type>  (Change case of column - type:lower,upper,proper,capitalize)
    -toid <columns Column indices. Can include ranges, e.g. 0-5>  (Convert the column(s) into IDS (lowercase, no space, a-z0-9_))
    -padleft <columns Column indices. Can include ranges, e.g. 0-5> <character Character to pad to> <length Length>  (Pad left with given character)
    -padright <columns Column indices. Can include ranges, e.g. 0-5> <character Character to pad to> <length Length>  (Pad right with given character)
    -trim <columns Column indices. Can include ranges, e.g. 0-5>  (Trim leading and trailing white space)
    -trimquotes <columns Column indices. Can include ranges, e.g. 0-5>  (Trim leading and trailing quotes)
    -width <columns Column indices. Can include ranges, e.g. 0-5> <size>  (Limit the string size of the columns)
    -prepend <text>  (Add the text to the beginning of the file. use 
 to insert newlines)
    -pad <count> <pad string>  (Add or remove columns to achieve the count)
    -prefix <column> <prefix String to use>  (Add prefix to column)
    -suffix <column> <suffix>  (Add suffix to column)
    -subst <column_name New Column Name> <template Template - use ${column_name} ... >  (Create a new column with the template)
    -ascii <columns Column indices. Can include ranges, e.g. 0-5> <substitution string use $1, $2, etc for pattern (...) matches>  (Convert non ascii characters)
    -cleanphone <columns Column indices. Can include ranges, e.g. 0-5>  (Clean the phone number)
    -ismobile <columns Column indices. Can include ranges, e.g. 0-5>  (Add a true/false if the string is a mobile phone)
    -sms <column Phone number> <campaign Campaign> <message Message template>  (Send a text message - only for command line)
    -js <javascript>  (Define Javascript (e.g., functions) to use later in the -func call)
    -func <names New column names> <javascript javascript expression>  (Apply the javascript function. Use _colname or _col#)
    -endswith <column> <string>  (Ensure that each column ends with the string)
    -truncate <column> <max length> <suffix>  ()
    -extract <column> <pattern> <replace with use 'none' for no replacement> <name new column name>  (Extract text from column and make a new column)
    -urlarg <column> <argname URL arg name>  (Extract URL argument and make a new column)
    -extracthtml <column URL Column> <names Comma separated list of new column names> <pattern Pattern>  (Extract text from HTML)
    -htmlinfo <column URL Column>  (Extract icon and description from input URL)
    -checkmissing <column URL Column> <replace_with Replace with>  (Check for missing URL)
    -urlencode <columns Column indices. Can include ranges, e.g. 0-5>  (URL encode the columns)
    -urldecode <columns Column indices. Can include ranges, e.g. 0-5>  (URL decode the columns)
    -map <column> <new columns name> <value newvalue ...>  (Change values in column to new values)
    -format <columns Column indices. Can include ranges, e.g. 0-5> <format Decimal format  e.g. '##0.00'>  (Apply decimal format to the columns (see https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html))
    -denormalize <file From csv file> <from id idx> <from value idx> <to idx> <new col name> <mode replace add>  (Read the id,value from file and substitute the value in the dest file col idx)
    -break <label1> <label2> <columns Column indices. Can include ranges, e.g. 0-5>  (Break apart column values and make new rows)
    -makeids  (Turn the header row into IDs (lowercase, no space, a-z0-9_))
    -faker <what firstname|lastname|fullname|etc> <columns Columns to change. If none given then add the fake value>  (Fake up data. See the docs at https://ramadda.org/repository/userguide/seesv.html#-faker)
    -edit <column key column>  (Hand edit a column (command line only). ESC-stop, BLANK-skip)

    -md <columns Column indices. Can include ranges, e.g. 0-5> <type>  (Make a message digest of the column values)
    -tob64 <columns Column indices. Can include ranges, e.g. 0-5>  (Base 64 Encode)
    -fromb64 <columns Column indices. Can include ranges, e.g. 0-5>  (Base 64 Decode)
    -rot13 <columns Column indices. Can include ranges, e.g. 0-5>  (Rot 13)
    -encrypt <columns Column indices. Can include ranges, e.g. 0-5> <password>  (Encrypt using AES with SHA-256 key)
    -decrypt <columns Column indices. Can include ranges, e.g. 0-5> <password>  (Encrypt using AES with SHA-256 key)
    -uuid  (Add a UUID field)
    -number  (Add 1,2,3... as column)
    -letter  (Add 'A','B', ... as column)
    -soundex <columns Column indices. Can include ranges, e.g. 0-5>  (Generate a soundex code)
    -wikidesc <column> <suffix>  (Add a description from Wikipedia)
    -image <column> <suffix>  (Search for an image)
    -embed <url column>  (Download the URL and embed the image contents)
    -fetch <name Name of new column> <ignore_errors Ignore Errors e.g., true or false> <url URL template, e.g., https://foo.com/${column_name}>  (Fetch the URL and embed the contents)
    -imagefill <querycolumn> <suffix> <imagecolumn>  (Search for an image with the query column text if the given image column is blank. Add the given suffix to the search. )
    -download <column Column that holds the URL> <suffix File suffix>  (Download the URL)
    -gender <column>  (Figure out the gender of the name in the column)

    -indateformat <format e.g. yyyy-MM-dd HH:mm:ss> <timezone>  (Specify date format for parsing)
    -outdateformat <format e.g. yyyy-MM-dd HH:mm:ss> <timezone>  (Specify date format for formatting)
    -convertdate <column>  (Convert date)
    -adddate <date_column Date Column> <value Value Column> <value_type Value type - millisecond,second,minute,hour,hour_of_day,week,month,year>  (Add date)
    -extractdate <date column> <what What to extract, e.g., year, month, day_of_week, etc>  (Extract date)
    -formatdate <columns Column indices. Can include ranges, e.g. 0-5> <target date format>  (Format date)
    -elapsed <column>  (Calculate elapsed time (ms) between rows)
    -latest <columns Key columns> <column Date column> <format Date Format, e.g. yyyy-MM-dd>  (Pass through rows whose date is the latest in the group of rows defined by the key column)
    -datediff <column1 Column 1> <column2 Column 2> <unit Unit-milliseconds,seconds,minutes,hours,days>  (Calculate elapsed time between columns column1-column2)
    -datecompare <column1> <column2> <operator <,<=,=,!=,>=,>>  (add a true/false column comparing the date values)

    -scale <column> <delta1> <scale> <delta2>  (Set value={value+delta1}*scale+delta2)
    -makenumber <columns Column indices. Can include ranges, e.g. 0-5>  (Try to parse as number)
    -generate <label> <start> <step>  (Add row values)
    -decimals <column> <num_decimals how many decimals to round to>  (Round decimals)
    -fuzz <column> <num_places how many places to round to. use <=0 for decimals> <num_random_digits how many random digits>  (fuzz the number. if num_places less than zero than that is the # of decimals. else that is the lower digits to fuzz out)
    -ceil <columns Column indices. Can include ranges, e.g. 0-5> <value Value>  (Set the max value)
    -floor <columns Column indices. Can include ranges, e.g. 0-5> <value Value>  (Set the min value)
    -delta <key columns> <columns Column indices. Can include ranges, e.g. 0-5>  (Add column that is the delta from the previous step)
    -runningsum <columns Column indices. Can include ranges, e.g. 0-5>  (Make a running sum of the column values)
    -operator <columns Columns> <new col name> <operator Operator:+,-,*,/,%,average>  (Apply the operator to the given columns and create new one)
    -compare <column1> <column2> <operator <,<=,=,!=,>=,>>  (Add a true/false column comparing the values)
    -round <columns Column indices. Can include ranges, e.g. 0-5>  (Round the values)
    -abs <columns Column indices. Can include ranges, e.g. 0-5>  (Make absolute values)
    -clip <columns Column indices. Can include ranges, e.g. 0-5> <min> <max>  (Clip the number to within the range)
    -rand <column name> <minrange Minimum range (e.g. 0)> <maxrange Maximum range (e.g. 1)>  (make random value)
    -even <columns Column indices. Can include ranges, e.g. 0-5>  (Add true if the column starts with an even number)
    -sum <key columns> <value columns> <carry over columns>  (Sum values keying on key column value. If no value columns specified then do a count)
    -pivot <key columns Columns to key on> <column columns The columns the values of which are used to make the new columns in the result> <value column The value column> <operator The operator to apply -  count,sum,average,min,max>  (Make a pivot table)
    -summary <key columns Columns to key on> <value columns Columns to apply operators on> <carry over columns Extra columns to include> <ops any of count,sum,average,min,max>  (count/sum/average/min/max values keying on key column value. If no value columns specified then do a count)
    -histogram <column The column> <bins Comma separated set of bin values> <value columns Extra columns to sum up> <ops ops to apply to extra columns - any of count,sum,average,min,max>  (Make a histogram with the given column and bins)
    -percent <columns Columns to add>  (Add columns together. Replace with their percentage)
    -increase <column> <how far back>  (Calculate percent increase)
    -diff <column> <how far back (default 1)>  (Difference from previous value)
    -average <columns Columns> <period> <label>  (Calculate a moving average)
    -ranges <column> <name New column name> <start Numeric start of range> <size Numeric size of range>  (Create a new column with the (string) ranges where the value falls in)
    -bytes <unit> <column>  (Convert suffixed values (e.g., 2 MB) into the number)
    -column_and <name New column name> <columns Column indices. Can include ranges, e.g. 0-5>  (And values)
    -colum_nor <name New column name> <columns Column indices. Can include ranges, e.g. 0-5>  (Or values)
    -column_not <name New column name> <column>  (Not value)
    -check <columns Column indices. Can include ranges, e.g. 0-5> <what How strict>  (Check that the values are numbers)

    -geocode <columns Address columns> <prefix optional prefix e.g., state: or county: or country:> <suffix>  (Geocode using given columns)
    -geocodeifneeded <columns Address columns> <prefix optional prefix e.g., state: or county: or country:> <suffix> <latitude latitude column> <longitude longitude column>  (Geocode if needed)
    -geocodeaddressdb <columns columns> <prefix optional prefix e.g., state: or county: or country:> <suffix>  (Geocode for import into RAMADDA's DB. The lat/lon is one semi-colon delimited column)
    -geocodejoin <column key column> <csv file File to get lat/lon from> <key idx> <lat idx> <lon idx>  (Geocode with file)
    -bounds <north> <west> <south> <east>  (Geocode within bounds)
    -decodelatlon <columns Lat or Lon column>  (Decode latlon)
    -getaddress <latitude latitude column> <latitude latitude column>  (Get address from lat/lon)
    -statename <state_column State ID column>  (Add state name from state ID)
    -geoname <lookup ('counties' or 'states' or 'countries' or 'timezones')> <fields fields in shapefile> <latitude Latitude column> <longitude Longitude column>  (Look up location name)
    -geocontains <lookup ('counties' or 'states' or 'countries' or 'timezones')> <name new column name> <latitude Latitude column> <longitude Longitude column>  (Check for containment)
    -elevation <latitude Latitude column> <longitude Longitude column>  (Look up elevation(using 1/3 arc-second DEM))
    -mercator <columns x and y columns>  (Convert x/y to lon/lat)
    -region <columns Columns with state name or abbrev.>  (Add the state's region)
    -population <columns Column indices. Can include ranges, e.g. 0-5> <prefix e.g., state: or county: or city:> <suffix>  (Add in population from address)
    -neighborhood <latitude Latitude column> <longitude Longitude column> <default Default value>  (Look up neighborhood for a given location)

    -proc <columns Columns to expand with> <commands Commands. Ends with -endproc>  (Apply the commands to each of the columns)
    -sortby <columns Column to sort on> <direction Direction> <how How>  ()
    -count  (Show count)
    -alias <name Name> <alias Alias>  (Set a field alias)
    -value <name name> <value Value>  (Define a macro value for later use)
    -filepattern <name Macro name> <pattern Pattern>  (Extract a macro value from a filename)
    -changeline <from From pattern> <to To string>  (Change the line)
    -changeraw <from From pattern> <to To string>  (Change input text)
    -crop <columns Column indices. Can include ranges, e.g. 0-5> <patterns Comma separated list of patterns>  (Crop last part of string after any of the patterns)
    -strict  (Be strict on columns. any rows that are not the size of the other rows are dropped)
    -flag  (Be strict on columns. any rows that are not the size of the other rows are shown)
    -prop <property> <value start, end, etc>  (Set a property)
    -verify  (Verify that all of the rows have the same # of columns)
    -ext <program_id matches with seesv.ext.&lt;program_id&gt;=/path>  (Execute the external program)
    -exec <program_id matches with seesv.ext.&lt;program_id&gt;=/path>  (Execute the external program for every line)

    -print  (Print text output)
    -printdelim <delimiter Delimiter - ,|^ etc. Use "tab" for tab>  (Print with delimited output)
    -o <file The file>  (Write to the given file (command line only))
    -comment <comment The comment>  (Add a comment to the output)
    -outputprefix <text The text. Use '
' to add a new line. Use '_bom_' to write out the byte order mark.>  (Specify text to add to the beginning of the file)
    -highlight <columns Column indices. Can include ranges, e.g. 0-5> <color Color>  (Highlight the columns)
    -background <columns Column indices. Can include ranges, e.g. 0-5> <color Color>  (Background the columns)
    -printheader  (Print header)
    -raw  (Print the file raw)
    -table  (Print HTML table and stats)
    -cols <width Column width>  (Set the width of the columns for output. Use with -p)
    -stats  (Print summary stats)
    -torecord  (Print records)
    -script  (Generate script)
    -toxml <outer tag> <inner tag>  (Generate XML)
    -tojson  (Generate JSON)
    -tourl  (Generate DB publish urls)
    -todb <db id> <table table name> <columns database columns> <properties name value properties>  (Write to Database)
    -template <prefix> <template Use ${column_name} or indices: ${0},${1}, etc for values> <row_delimiter Output between rows> <suffix>  (Apply the template to make the output)
    -subd <columns columns to subdivide on> <ranges Comma separated ranges min1;max1;step1,min2;max2;step2> <output_template Output template - use ${ikey} or ${vkey}, e.g., grid${ikey}.csv>  (Subdivide into different files)
    -maptiles <columns lat/lon columns to subdivide on> <degrees Degrees per tile. Defaults to 1> <output_template Output template - use ${ikey} or ${vkey}, e.g., tile${vkey}.csv. Defaults to a tile${vket}.csv>  (Tile the data on lat/lon)
    -chunk <output_template Output template - use ${number}, e.g., output${number}.csv. Defaults to a output${number}.csv> <number Number of rows in each file>  (Make a number of output files with a max number of rows)
    -addheader <properties name1 value1 ... nameN valueN>  (Add the RAMADDA point properties)
    -db <properties Name value pairs:
		table.id <new id> table.name <new name> table.cansearch false table.canlist false table.icon <icon, e.g., /db/database.png>
		<column>.id <new id for column> <column>.label <new label>
		<column>.type <string|enumeration|double|int|date>
		<column>.format <yyyy MM dd HH mm ss format for dates>
		<column>.canlist false <column>.cansearch false
		install <true|false install the new db table>
		nukedb <true|false careful! this deletes any prior created dbs
	yesreallynukethewholedb true - this double checks>  (Generate the RAMADDA db xml from the header)
    -dbprops <id pattern> <suffix pattern>  (Print to stdout props for db generation)
    -write <file name template> <contents template>  (Write the contents of a row to a named file)
    -fields  (Print the fields)
    -run <Name of process directory>  ()
    -progress <rows How often to print>  (Show progress)
    -debugrows <rows # of rows>  (Debug # rows)
    -pointheader  (Generate the RAMADDA point properties)
    -args  (Generate the CSV file commands)
    -typexml <type_id Type ID, e.g.type_point_mypointdata> <type_desc Type Description>  (Generate the RAMADDA type xml)
