<html>
  <head><title>RAMADDA SeeSV</title>
</head>    
<notcl>
<style type='text/css'>
  body {font-family: Arial, sans-serif;}
  ul {margin:0px;}
  .header {margin:10px;} .header a, .command a {color:#000; text-decoration:none;}
  h2 {
      font-size:120%;
      font-weight:bold;
      margin:0px;
  }
  pre {
      border : 1px #ccc solid;
      background:rgb(245,245,245);
      padding:4px;
      border-radius: 4px;
      margin-bottom:10px;
      margin-top:5px;
      margin-left:10px;
  }
  .examples {
      max-height: 400px;
      overflow-y:auto;
  }
  .command {border : 1px #ccc solid; padding:4px; background:#E7EFF4;}
  .command-block {
      margin-left:20px;
  }
  .cmd {
      font-style:italic;
  }


</style>

<h2>RAMADDA SeeSV</h2>
<center>${header}</center>


<h2>Introduction</h2>
The RAMADDA SeeSV can be used both interactively from within RAMADDA as well as via the command line. Help with the interactive version can be viewed
<a href="https://ramadda.org/repository/userguide/etl.html">here</a>.
<p>
For brevity, in the below documentation we're assuming  that you are using an alias:
<pre>
alias seesv="sh ~/seesv/seesv.sh"  
</pre>

The examples here show the command line use. If running interactively the commands are the same form except for the seesv calls and the specification of the input file. So, for example, if you are calling the tool from the command line as:
<pre class=example>
seesv -columns column1,column2 -p file.csv > output.csv
</pre>

The corresponding commands interactively would be:
<pre class=example>
-columns column1,column2
</pre>


<h2>Install</h2>
<ul>
<li> Download the seesv.zip file from the RAMADDA <a href=https://geodesystems.com/repository/alias/release>download</a> site
<li> Unzip the file
<li> Consult the README
<li> SeeSV runs using Java 1.8 or higher. Set the JAVA environment variable to point to the java runtime.
<li> Usage:<br>seesv &lt;any number of commands&gt; -p &ltinput file&gt; &gt; output file
</ul>
<p>


<h2>Basic Use</h2>  
The general use of the SeeSV tools is as follows:
<pre class=examples>
seesv &lt;a number of processing commands&gt; &lt;some output command&gt; file.csv &gt; output.csv
#or
seesv &lt;a number of processing commands&gt; &lt;some output command&gt; -o output.csv   file.csv 

#To show help:
seesv -help

#To show help on a topic:
seesv -help:some_topic

#With no processing commands and just printing the header:
seesv -printheader file.csv

#Or a shortcut
seesv -ph file.csv

#With no processing commands and csv output:
seesv -p file.csv &gt; output.csv

#With no processing commands and a record oriented  output:
seesv -record file.csv &gt; output.csv

#With the -columns command printing csv output
seesv -columns column1,column2 -p file.csv > output.csv
</pre>



<h2>Column Identifiers</h2>  
Note: many of these commands use one or more column names from the source file. 
These column names are converted to a canonical identifier format by lower casing, changing spaces to "_" and
removing non alpha numeric characters.
So for example if your source file is:
<pre>
column 1, Column 2, Some "funny" column
 ...
</pre>
Then the column ids are:
<pre>
column_1,column_2,some_funny_column
</pre>

You can always use the <span class=cmd>-ids</span> command to list the ids
<pre class=examples>
seesv -ids -printheader test.csv
</pre>


<h2>Some Examples</h2>  
<pre class=examples>
####  selecting columns
#Subset test.csv and only include column1 and column2
seesv -columns column1,column2 -p test.csv > newtest.csv

#You can also use numeric indices - zero based
seesv -columns 0,1 -p test.csv > newtest.csv

#Specify a range of columns
#either using column names:
seesv -columns column1-columnN -p test.csv > newtest.csv
#or indices:
seesv -columns 1-5,6,7,10-15 -p test.csv > newtest.csv

#or mix and match
seesv -columns 0-1,columnA,columnB,columnF-columnZ -p test.csv > newtest.csv

#Specify a step:
#seesv -columns start-end:step

#e.g. below gives 0,3,6,9,12,15
seesv -columns 0-15:3

#include all columns except column1
seesv -notcolumns column1 -p test.csv > newtest.csv

#subset columns and then change the values 
seesv -columns column1,column2 -change column1,column2 "pattern" "new value" -p test.csv > newtest.csv

#Only include column1 and then only pass through unique values
seesv -columns column1 -unique 0 -p test.csv > newtest.csv

#Only pass throught unique values in the first column and then sort the output
seesv -columns column1 -unique 0 -sort column1 -p test.csv > newtest.csv


</pre>
