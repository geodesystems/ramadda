<html>
  <head><title>RAMADDA CSV Commands</title>
</head>    
<notcl>
<style type='text/css'>
  body {font-family: Arial, sans-serif;}
  ul {margin:0px;}
  .header {margin:10px;} .header a, .command a {color:#000; text-decoration:none;}
  h2 {
      font-size:120%;
      font-weight:bold;
      margin:0px;
  }
  pre {
      border : 1px #ccc solid;
      background:rgb(245,245,245);
      padding:4px;
      border-radius: 4px;
      margin-bottom:10px;
      margin-top:5px;
      margin-left:10px;
  }
  .examples {
      max-height: 400px;
      overflow-y:auto;
  }
  .command {border : 1px #ccc solid; padding:4px; background:#E7EFF4;}
  .command-block {
      margin-left:20px;
  }
  .cmd {
      font-style:italic;
  }


</style>

<h2>RAMADDA CSV Utils Commands</h2>
<center>${header}</center>


<h2>Introduction</h2>
The RAMADDA CSV commands can be used both interactively from within RAMADDA as well as via the command line. Help with the interactive version can be viewed
<a href="https://ramadda.org/repository/userguide/etl.html">here</a>.
The examples here show the command line use. If running interactively the commands are the same form except for the csv calls and the specification of the input file. So, for example, if you are calling the tool from the command line as:
<pre class=example>
csv -columns column1,column2 -p file.csv > output.csv
</pre>

The corresponding commands interactively would be:
<pre class=example>
-columns column1,column2
</pre>

For brevity, in the below documentation we're assuming  that you are using an alias:
<pre>
alias csv="sh ~/csvutil/csv.sh"  
</pre>

<h2>Install</h2>
<ul>
<li> Download the csvutil.zip file from the RAMADDA <a href=https://geodesystems.com/repository/alias/release>download</a> site
<li> Unzip the file
<li> Consult the README
<li> The csv utils run using Java 1.8 or higher. Set the JAVA environment variable to point to the java runtime.
<li> Usage:<br> csv &lt;any number of commands&gt; -p &ltinput file&gt; &gt; output file
</ul>
<p>


<h2>Basic Use</h2>  
The general use of the CSV tools is as follows:
<pre class=examples>
csv &lt;a number of processing commands&gt; &lt;some output command&gt; file.csv &gt; output.csv

#With no processing commands and just printing the header:
csv -printheader file.csv

#Or a shortcut
csv -ph file.csv

#With no processing commands and csv output:
csv -p file.csv &gt; output.csv

#With no processing commands and a record oriented  output:
csv -record file.csv &gt; output.csv

#With the -columns command printing csv output
csv -columns column1,column2 -p file.csv > output.csv
</pre>



<h2>Column Identifiers</h2>  
Note: many of these commands use one or more column names from the source file. 
These column names are converted to a canonical identifier format by lower casing, changing spaces to "_" and
removing non alpha numeric characters.
So for example if your source file is:
<pre>
column 1, Column 2, Some "funny" column
 ...
</pre>
Then the column ids are:
<pre>
column_1,column_2,some_funny_column
</pre>

You can always use the <span class=cmd>-ids</span> command to list the ids
<pre class=examples>
csv -ids -printheader test.csv
</pre>


<h2>Some Examples</h2>  
<pre class=examples>
####  selecting columns
#Subset test.csv and only include column1 and column2
csv -columns column1,column2 -p test.csv > newtest.csv

#You can also use numeric indices - zero based
csv -columns 0,1 -p test.csv > newtest.csv

#Specify a range of columns
#either using column names:
csv -columns column1-columnN -p test.csv > newtest.csv
#or indices:
csv -columns 1-5,6,7,10-15 -p test.csv > newtest.csv

#or mix and match
csv -columns 0-1,columnA,columnB,columnF-columnZ -p test.csv > newtest.csv

#Specify a step:
#csv -columns start-end:step

#e.g. below gives 0,3,6,9,12,15
csv -columns 0-15:3

#include all columns except column1
csv -notcolumns column1 -p test.csv > newtest.csv

#subset columns and then change the values 
csv -columns column1,column2 -change column1,column2 "pattern" "new value" -p test.csv > newtest.csv

#Only include column1 and then only pass through unique values
csv -columns column1 -unique 0 -p test.csv > newtest.csv

#Only pass throught unique values in the first column and then sort the output
csv -columns column1 -unique 0 -sort column1 -p test.csv > newtest.csv


</pre>
