<html>
<head>
<title></title>
  <link rel="stylesheet" type="text/css" href="./default.css" title="Style">

</head>

<body>
<div class="ramadda-documentation">
<div class="ramadda-doc-header">
<div style='padding-top:12px;margin-bottom:4px;'><a href="toc.html#seesv.html"><span title="Table of contents"><i  style='font-size:16pt;'  class="fa fa-list "></i></span></a> &nbsp; <a href="index.html">RAMADDA User Guide</a>  > <a href="page_datafacilities.html">Data Facilities</a>  > <a href="etl.html">ETL Tools</a> </div>
<table width=100% cellspacing=0 cellpadding=0 >
<tr valign=center><td width=25%><div class=ramadda-doc-nav-container><div class=ramadda-doc-nav><a href="etl.html"><table><td valign=center><td><span title="Previous: ETL Tools"><i  style='font-size:16pt;'  class="fa fa-caret-left "></i></span></td><td>ETL Tools</td></tr></table></a></div></div></td>
<td width=50% align=center>
<div class="ramadda-page-title"><a href="#">Section 8.0.1: </a></div>
</td>
<td align=right width=25%><div class=ramadda-doc-nav-container><div class=ramadda-doc-nav><a href="dataexample.html"><table><tr valign=center><td>Data Example</td><td><span title="Next: Data Example"><i  style='font-size:16pt;'  class="fa fa-caret-right "></i></span></td></tr></table></a> </div></div> </td>
</tr></table>
</div>

<style type="text/css">
pre {
    margin-left:15px;
}
.ramadda-lheading {
    margin-top:15px;
}
</style>

<div class="ramadda-doc-contents" style="margin-left:20px;">
Usage:
    [34m-help[0m  [36mprint this help[0m
    [34m-help:<topic search string>[0m  [36mprint help that matches topic[0m
    [34m-helppretty[0m  [36mpretty print help[0m
    [34m-version[0m  [36mprint version[0m
    [34m-commands[0m  [36mfile of commands[0m
	<[32mfile [0mThe file of commands. Any # of lines> 
[42mInput: Specify the input. Default is assumed to be a CSV but can support HTML, JSON, XML, Shapefile, etc.[0m
    [34m-delimiter[0m  [36mSpecify the input delimiter[0m
	<[32mdelimiter [0mUse 'space' for space, 'tab' for tab,'?' to guess between tab and space size=5> 
    [34m-inputcomment[0m  [36mInput comment[0m
	<[32mcomment [0m> 
    [34m-tab[0m  [36mUse tabs. A shortcut for -delimiter tab[0m
    [34m-widths[0m  [36mColumns are fixed widths[0m
	<[32mwidths [0mw1,w2,...,wN> 
    [34m-quotesnotspecial[0m  [36mDon't treat quotes as special characters[0m
    [34m-cleaninput[0m  [36mInput is one text line per row. i.e., no new lines in a data row. Setting this can improve performance on large files[0m
    [34m-bom[0m  [36mInput has a leading byte order mark (BOM) that should be stripped out[0m
    [34m-encoding[0m  [36mSpecify the file encoding[0m
	<[32mencoding [0mFile Encoding see https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html values=UTF-8,UTF-16,UTF-16BE,UTF-16LE,UTF-32,UTF-32BE,UTF-32LE,CESU-8,IBM00858,IBM437,IBM775,IBM850,IBM852,IBM855,IBM857,IBM862,IBM866,ISO-8859-1,ISO-8859-13,ISO-8859-15,ISO-8859-2,ISO-8859-4,ISO-8859-5,ISO-8859-7,ISO-8859-9,KOI8-R,KOI8-U,Not available,US-ASCII,windows-1250,windows-1251,windows-1252,windows-1253,windows-1254,windows-1257,x-IBM737,x-IBM874,x-UTF-16LE-BOM,x-UTF-32BE-BOM,x-UTF-32LE-BOM> 
    [34m-header[0m  [36mRaw header[0m
	<[32mheader [0mColumn names> 
    [34m-multifiles[0m  [36mTreat input files separately[0m
	<[32mtemplate [0mFile template  - ${file_shortname} ${file_name} ${count}> 
    [34m-json[0m  [36mParse the input as json[0m
	<[32marrayPath [0mPath to the array e.g., obj1.arr[2].obj2 label=Array path size=30> 
	<[32mobjectPaths [0mOne or more paths to the objects e.g. geometry,features label=Object paths size=30> 
    [34m-jsonjoin[0m  [36mJoin different arrays in the input JSON[0m
	<[32marrayPaths [0mcomma separated list of the array paths label=Array paths size=30> 
	<[32mkeys [0mComma separated list of keys to match on label=Keys> 
	<[32mpattern [0mOptional pattern to replace the key value with label=Pattern> 
	<[32mreplace [0mPattern replace> 
	<[32mmissing [0mMissing value> 
    [34m-jsonvalue[0m  [36mExtract a value from a JSON column[0m
	<[32mcolumns [0mColumn names> 
	<[32marrayPath [0mPath to the array e.g., obj1.arr[2].obj2 label=Array path size=30> 
    [34m-geojson[0m  [36mParse the input as geojson[0m
	<[32mincludePolygon [0mInclude polygon values=true,false> 
    [34m-pdf[0m  [36mRead input from a PDF file.[0m
    [34m-xml[0m  [36mParse the input as xml[0m
	<[32mpath [0mPath to the elements size=60> 
    [34m-shapefile[0m  [36mParse the input shapefile[0m
	<[32mprops [0m"addPoints true addShapes false"> 
    [34m-lines[0m  [36mParse the input as text lines. Treat each line as one column[0m
    [34m-htmltable[0m  [36mParse tables in the input html file[0m
	<[32mskip [0mNumber of tables to skip> 
	<[32mpattern [0mPattern to skip to size=40> 
	<[32mproperties [0mOther name value args - <ul><li> numTables N:Number of tables to process. Default is 1<li> removeEntity true:remove HTML entities <li> removePattern pattern<li> extractUrls true <li> columnN.extractUrls true: N=column number<li> stripTags false: strip any HTML tags. Default =true<li> columnN.stripTags false: N=column number. Set stripTags for the column</ul> rows=6 size=40> 
    [34m-htmlpattern[0m  [36mParse the input html file[0m
	<[32mcolumns [0mColumn names> 
	<[32mstartPattern [0m> 
	<[32mendPattern [0m> 
	<[32mpattern [0mRow pattern. Use (...) to match columns> 
    [34m-harvest[0m  [36mHarvest links in web page. This results in a 2 column dataset with fields: label,url[0m
	<[32mpattern [0mregexp to match> 
    [34m-text[0m  [36mExtract rows from the text[0m
	<[32mcomma separated header [0m> 
	<[32mchunk pattern [0m> 
	<[32mtoken pattern [0m> 
    [34m-extractpattern[0m  [36mExtract rows from the text[0m
	<[32mcomma separated header [0m> 
	<[32mtoken pattern [0m> 
    [34m-tokenize[0m  [36mTokenize the input from the pattern[0m
	<[32mheader [0mheader1,header2...> 
	<[32mpattern [0m> 
    [34m-sql[0m  [36mRead data from the given database[0m
	<[32mdb [0mThe database id (defined in the environment) values=property:seesv_dbs> 
	<[32mtable [0mComma separate list of tables to select from size=60> 
	<[32mcolumns [0mComma separated list of columns to select> 
	<[32mwhere [0mcolumn1:expr:value;column2:expr:value;...\ne.g.: name:like:joe;age:>:60\nWhere expr is: =|<|>|<>|like|notlike delimiter=; size=60> 
	<[32mproperties [0mname space value properties. e.g., join col1,col2> 
    [34m-synthetic[0m  [36mGenerate an empty file with the given number of rows[0m
	<[32mheader [0mcomma separated header> 
	<[32mvalues [0mcomma separated values> 
	<[32mnumber_rows [0mNumber of rows> 
    [34m-prune[0m  [36mPrune out the first N bytes[0m
	<[32mbytes [0mNumber of leading bytes to remove> 
    [34m-deheader[0m  [36mStrip off the RAMADDA point header[0m
    [34m-headernames[0m  [36mMake the header proper capitalization[0m
    [34m-headerids[0m  [36mClean up the header names[0m
    [34m-ids[0m  [36mUse canonical names[0m
    [34m-sheet[0m  [36mSet XLS sheet #[0m
	<[32msheet [0mSheet number> 
    [34m-cat[0m  [36mConcat the columns in one or more csv files[0m
	<[32m*.csv [0m> 
    [34m-append[0m  [36mAppend the files, skipping the given rows in the latter files[0m
	<[32mskip [0mNumber of rows to skip> 
	<[32mfiles [0m*.csv> 
    [34m-chop[0m  [36mWrite out last N lines. include the header[0m
	<[32mnumlines [0mNumber of lines to leave> 
	<[32mfile [0m*.csv> 
    [34m-filenamepattern[0m  [36mExtract strings from the file name and add them as new columns[0m
	<[32mpattern [0mPattern to match> 
	<[32mcolumnnames [0mComma separated list of column names> 
[42mFilter: [0m
    [34m-skiplines[0m  [36mSkip number of raw lines.[0m
	<[32mlines [0mHow many raw lines to skip> 
    [34m-maxrows[0m  [36mSet max rows to process[0m
	<[32mrows [0mNumber of rows> 
    [34m-match[0m  [36mPass through rows that the columns each match the pattern[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpattern [0mregexp or prefix with includes:s1,s2 to do substrings match> 
    [34m-notmatch[0m  [36mPass through rows that don't match the pattern[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpattern [0mregexp or prefix with includes:s1,s2 to do substrings match> 
    [34m-if[0m  [36mNext N args specify a filter command followed by any change commands followed by an -endif.[0m
    [34m-start[0m  [36mStart at pattern in source file[0m
	<[32mstart pattern [0m> 
    [34m-stop[0m  [36mEnd at pattern in source file[0m
	<[32mstop pattern [0m> 
    [34m-rawlines[0m 
	<[32mlines [0mPass through and print out rawlines unprocesed> 
    [34m-inputnotcontains[0m  [36mFilter out input lines that contain any of the strings[0m
	<[32mfilters [0mComma separated list of strings to filter on> 
    [34m-min[0m  [36mOnly pass thorough lines that have at least this number of columns. Specify blank to use the number of columns in the header[0m
	<[32mmin # columns [0m> 
    [34m-max[0m  [36mOnly pass through lines that have no more than this number of columns. Specify blank to use the number of columns in the header[0m
	<[32mmax # columns [0m> 
    [34m-numcolumns[0m  [36mRemove or add values so each row has the number of columns[0m
	<[32mnumber [0muse -1 to use the # of columns in the header> 
    [34m-has[0m  [36mOnly pass through anything if the data has the given columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-ifnumcolumns[0m  [36mOnly pass through rows with number of columns passing the operator[0m
	<[32moperator [0m<,<=,>,>=,=,!=> 
	<[32mnumber [0mNumber of columns> 
    [34m-fuzzypattern[0m  [36mPass through rows that the columns each fuzzily match the pattern[0m
	<[32mthreshold [0mScore threshold 0-100. Default:85. Higher number better match> 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpattern [0m> 
    [34m-lengthgreater[0m  [36mPass through rows that the length of the columns is greater than[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mlength [0m> 
    [34m-same[0m  [36mPass through where the 2 columns have the same value[0m
	<[32mcolumn1 [0m> 
	<[32mcolumn2 [0m> 
    [34m-notsame[0m  [36mPass through where the 2 columns don't have the same value[0m
	<[32mcolumn1 [0m> 
	<[32mcolumn2 [0m> 
    [34m-unique[0m  [36mPass through unique values[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mmode [0mWhat type of matching is done - exact (exact match) or clean (lower case and remove whitespace) or fuzzy:threshold (do fuzzy matching with threshold from 1: no similarity to 100: exact match. use fuzzy:? to print out values) values=exact,clean,fuzzy:threshold> 
    [34m-dups[0m  [36mPass through duplicate values[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-sample[0m  [36mPass through rows based on probablity[0m
	<[32mprobablity [0m0-1 probability of passing through a row> 
    [34m-minvalue[0m  [36mPass through the row that has the min value in the group of columns defined by the key column[0m
	<[32mkey column [0m> 
	<[32mvalue column [0m> 
    [34m-maxvalue[0m  [36mPass through the row that has the max value in the group of columns defined by the key column[0m
	<[32mkey column [0m> 
	<[32mvalue column [0m> 
    [34m-eq[0m  [36mPass through rows that the column value equals the given value[0m
	<[32mcolumn [0m> 
	<[32mvalue [0m> 
    [34m-ne[0m  [36mPass through rows that the column value does not equal the given value[0m
	<[32mcolumn [0m> 
	<[32mvalue [0m> 
    [34m-gt[0m  [36mPass through rows that the column value is greater than the given value[0m
	<[32mcolumn [0m> 
	<[32mvalue [0m> 
    [34m-ge[0m  [36mPass through rows that the column value is greater than or equals the given value[0m
	<[32mcolumn [0m> 
	<[32mvalue [0m> 
    [34m-lt[0m  [36mPass through rows that the column value is less than the given value[0m
	<[32mcolumn [0m> 
	<[32mvalue [0m> 
    [34m-le[0m  [36mPass through rows that the column value is less than or equals the given value[0m
	<[32mcolumn [0m> 
	<[32mvalue [0m> 
    [34m-between[0m  [36mExtract rows that are within the range[0m
	<[32mcolumn [0m> 
	<[32mmin value [0m> 
	<[32mmax value [0m> 
    [34m-notbetween[0m  [36mExtract rows that are not within the range[0m
	<[32mcolumn [0m> 
	<[32mmin value [0m> 
	<[32mmax value [0m> 
    [34m-betweenstring[0m  [36mExtract rows that are between the given strings[0m
	<[32mcolumn [0m> 
	<[32mstart string [0m> 
	<[32mend string [0m> 
    [34m-notbetweenstring[0m  [36mExtract rows that are between the given strings[0m
	<[32mcolumn [0m> 
	<[32mstart string [0m> 
	<[32mend string [0m> 
    [34m-groupfilter[0m  [36mOne row in each group has to match[0m
	<[32mcolumn [0mkey column> 
	<[32mvalue_column [0mValue column> 
	<[32moperator [0m values==,!=,~,<,<=,>,>=> 
	<[32mvalue [0m> 
    [34m-before[0m  [36mPass through rows whose date is before the given date[0m
	<[32mcolumn [0m> 
	<[32mdate [0m> 
    [34m-after[0m  [36mPass through rows whose date is after the given date[0m
	<[32mcolumn [0m> 
	<[32mdate [0m> 
    [34m-countvalue[0m  [36mNo more than count unique values[0m
	<[32mcolumn [0m> 
	<[32mcount [0m> 
    [34m-decimate[0m  [36monly include every <skip factor> row[0m
	<[32mrows [0m# of start rows to include> 
	<[32mskip [0mskip factor> 
    [34m-ifin[0m  [36mPass through rows that the columns with ID is in given file[0m
	<[32mcolumn [0mColumn in the file> 
	<[32mfile [0mThe file> 
	<[32mcolumn2 [0mColumn in main file> 
    [34m-ifnotin[0m  [36mPass through rows that the columns with ID is not in given file[0m
	<[32mcolumn [0mColumn in the file> 
	<[32mfile [0mThe file> 
	<[32mcolumn2 [0mColumn in main file> 
    [34m-ifmatchesfile[0m  [36mPass through rows that the columns with ID begins with something in the given file[0m
	<[32mpattern [0mPattern template, e.g. ^${value}> 
	<[32mcolumn [0mColumn in the file> 
	<[32mfile [0mThe file> 
	<[32mcolumn2 [0mColumn in main file> 
    [34m-ifnotmatchesfile[0m  [36mPass through rows that the columns with ID does not begin with something in the given file[0m
	<[32mpattern [0mPattern template, e.g. ^${value}> 
	<[32mfile [0mThe file> 
	<[32mcolumn2 [0mColumn in main file> 
    [34m-skippattern[0m  [36mSkip any line that matches the pattern[0m
	<[32mpattern [0m> 
    [34m-skiprows[0m  [36mSkip number of processed rows.[0m
	<[32mrows [0mHow many rows to skip> 
    [34m-ensurenumeric[0m  [36mThrow error if non-numeric[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
[42mSlice and Dice: Add/remove columns, rows, restructure, etc[0m
    [34m-columns[0m  [36mOnly include the given columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-notcolumns[0m  [36mDon't include given columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-firstcolumns[0m  [36mMove columns to beginning[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-lastcolumns[0m  [36mMove columns to end[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-columnsbefore[0m  [36mMove columns before the given column[0m
	<[32mcolumn [0mColumn to move before> 
	<[32mcolumns [0mColumns to move> 
    [34m-columnsafter[0m  [36mMove columns after given column[0m
	<[32mcolumn [0mColumn to move after> 
	<[32mcolumns [0mColumns to move> 
    [34m-delete[0m  [36mRemove the columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-cut[0m  [36mDrop rows[0m
	<[32mrows [0mOne or more rows. -1 to the end. e.g., 0-3,5,10,-1> 
    [34m-include[0m  [36mOnly include specified rows[0m
	<[32mrows [0mone or more rows, -1 to the end> 
    [34m-rows_first[0m  [36mMove rows to the top that match the pattern[0m
	<[32mcolumns [0mcolumns to match on> 
	<[32mpattern [0mPattern> 
    [34m-rows_last[0m  [36mMove rows to the end of list that match the pattern[0m
	<[32mcolumns [0mcolumns to match on> 
	<[32mpattern [0mPattern> 
    [34m-copy[0m  [36mCopy column[0m
	<[32mcolumn [0m> 
	<[32mname [0m> 
    [34m-add[0m  [36mAdd new columns[0m
	<[32mnames [0mComma separated list of new column names> 
	<[32mvalues [0mComma separated list of new values> 
    [34m-insert[0m  [36mInsert new column values[0m
	<[32mcolumn [0mColumn to insert before> 
	<[32mname [0mName of new column> 
	<[32mvalues [0mValue to insert. Use ${row} to add the row index> 
    [34m-concat[0m  [36mCreate a new column from the given columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mdelimiter [0m> 
	<[32mname [0mName of new colums> 
    [34m-concatrows[0m  [36mConcatenate multiple rows into a single row[0m
	<[32mnum_rows [0mNumber of rows> 
    [34m-combine[0m  [36mCombine columns with the delimiter. deleting columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mdelimiter [0m> 
	<[32mcolumn name [0mNew column name> 
    [34m-combineinplace[0m  [36mCombine columns with the delimiter[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mdelimiter [0m> 
	<[32mcolumn name [0mNew column name> 
    [34m-merge[0m  [36mApply operators to columns[0m
	<[32mcolumns [0mColumns to merge> 
	<[32mname [0mNew column(s) name> 
	<[32moperator [0mOperator values=average,min,max,count> 
    [34m-split[0m  [36mSplit the column[0m
	<[32mcolumn [0m> 
	<[32mdelimiter [0mWhat to split on> 
	<[32mnames [0mComma separated new column names> 
    [34m-splat[0m  [36mCreate a new column from the values in the given column[0m
	<[32mkeycol [0mKey column> 
	<[32mcolumn [0m> 
	<[32mdelimiter [0m> 
	<[32mname [0mnew column name> 
    [34m-roll[0m  [36mRoll columns down into rows[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-shift[0m  [36mShift columns over by count for given rows[0m
	<[32mrows [0mRows to apply to> 
	<[32mcolumn [0mColumn to start at> 
	<[32mcount [0m> 
    [34m-slice[0m  [36mSlide columns down and over to append new rows to the bottom[0m
	<[32mcolumns [0mColumns to move> 
	<[32mdest [0mDesc column to move to> 
	<[32mfill [0mComma separated list of values to fill out the new row> 
    [34m-addcell[0m  [36mAdd a new cell at row/column[0m
	<[32mrow [0m> 
	<[32mcolumn [0m> 
	<[32mvalue [0m> 
    [34m-deletecell[0m  [36mDelete cell at row/column[0m
	<[32mrow [0m> 
	<[32mcolumn [0m> 
    [34m-clone[0m  [36mClone each row N times[0m
	<[32mcount [0mNumber of clonese> 
    [34m-appendrows[0m  [36mOnly include specified rows[0m
	<[32mskip [0mHow many rows to skip> 
	<[32mcount [0mHow many rows to merge> 
	<[32mdelimiter [0mHow many rows to merge> 
    [34m-mergerows[0m  [36mMerge rows[0m
	<[32mrows [0m2 or more rows> 
	<[32mdelimiter [0m> 
	<[32mclose [0m> 
    [34m-rowop[0m  [36mApply an operator to columns and merge rows[0m
	<[32mkeys [0mKey columns> 
	<[32mvalues [0mValue columns> 
	<[32moperator [0mOperator values=average,min,max,count> 
    [34m-rotate[0m  [36mRotate the data[0m
    [34m-flip[0m  [36mReverse the order of the rows except the header[0m
    [34m-makefields[0m  [36mMake new columns from data values[0m
	<[32mcolumn [0mColumn to get new column header#> 
	<[32mvalue columns [0mColumns to get values from> 
	<[32munique column [0mThe unique value, e.g. date> 
	<[32mother columns [0mOther columns to include> 
    [34m-melt[0m  [36mUse values in header to make new row[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mheader label [0m> 
	<[32mvalue label [0m> 
    [34m-explode[0m  [36mMake separate files based on value of column[0m
	<[32mcolumn [0m> 
    [34m-join[0m  [36mJoin the 2 files together[0m
	<[32mkey columns [0mkey columns the file to join with> 
	<[32mvalue_columns [0mvalue columns> 
	<[32mfile [0mFile to join with> 
	<[32msource_columns [0msource key columns> 
	<[32mdefault_value [0mdefault value - can be a comma separated list of defaults> 
    [34m-fuzzyjoin[0m  [36mJoin the 2 files together using fuzzy matching logic[0m
	<[32mthreshold [0mScore threshold 0-100. Default:85. Higher number better match> 
	<[32mkey columns [0mNumeric column numbers of the file to join with> 
	<[32mvalue_columns [0mnumeric columns of the values to join> 
	<[32mfile [0mFile to join with> 
	<[32msource_columns [0msource key columns> 
	<[32mdefault_value [0mdefault value> 
    [34m-cross[0m  [36mMake a cross product of 2 data files[0m
	<[32mfile [0mFile to cross with> 
    [34m-normal[0m  [36mNormalize the strings[0m
	<[32mcolumns [0mColumns> 
    [34m-countunique[0m  [36mCount number of unique values[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-dissect[0m  [36mMake fields based on patterns[0m
	<[32mcolumn [0m> 
	<[32mpattern [0me.g., "(field1:.*) (field2:.*) ..." size=80> 
    [34m-keyvalue[0m  [36mMake fields from key/value pairs, e.g. name1=value1 name2=value2 ...[0m
	<[32mcolumn [0m> 
    [34m-firstchars[0m  [36mExtract first N characters and create new column[0m
	<[32mcolumn [0m> 
	<[32mname [0mNew column name> 
	<[32mnumber [0mNumber of characters> 
    [34m-lastchars[0m  [36mExtract last N characters and create new column[0m
	<[32mcolumn [0m> 
	<[32mname [0mNew column name> 
	<[32mnumber [0mNumber of characters> 
    [34m-between_indices[0m  [36mExtract characters between the 2 indices[0m
	<[32mcolumn [0m> 
	<[32mname [0mNew column name> 
	<[32mstart [0mStart index> 
	<[32mend [0mEnd index> 
    [34m-fromheading[0m  [36mExtract column values from headings[0m
	<[32mcolumns [0mColumns of headings> 
	<[32mnames [0mComma separated list of new column names> 
	<[32mpattern [0mRegexp to apply to header with () defining column values> 
[42mChange: [0m
    [34m-change[0m  [36mChange columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
	<[32msubstitution string [0muse $1, $2, etc for pattern (...) matches> 
    [34m-changerow[0m  [36mChange the values in the row/cols[0m
	<[32mrows [0mRow indices. Can include ranges, e.g. 0-5> 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
	<[32msubstitution string [0muse $1, $2, etc for pattern (...) matches> 
    [34m-replace[0m  [36mReplace[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32msubstitution string [0muse $1, $2, etc for pattern (...) matches
use {value} for value> 
    [34m-set[0m  [36mWrite the value into the cells[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mrows [0mRow indices. Can include ranges, e.g. 0-5> 
	<[32mvalue [0m> 
    [34m-cleanwhitespace[0m  [36mClean whitespace[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-macro[0m  [36mLook for the pattern in the header and apply the template to make a new column, template: '{1} {2} ...', use 'none' for column name for no header[0m
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
	<[32mtemplate [0m> 
	<[32mcolumn label [0m> 
    [34m-setcol[0m  [36mWrite the value into the write col for rows that match the pattern[0m
	<[32mcolumn [0mmatch col #> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
	<[32mwrite column [0m> 
	<[32mvalue [0m> 
    [34m-copyif[0m  [36mCopy column 2 to column 3 if all of the columns match the pattern[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
	<[32mcolumn1 [0m> 
	<[32mcolumn2 [0m> 
    [34m-copycolumns[0m  [36mCopy columns 1  to columns 2[0m
	<[32mcolumns1 [0m> 
	<[32mcolumns2 [0m> 
    [34m-filldown[0m  [36mFill down with last non-null value[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-fillacross[0m  [36mFill across with last non-null value[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mrows [0mOne or more rows. -1 to the end. e.g., 0-3,5,10,-1> 
    [34m-unfill[0m  [36mSet following cells to blank if the same as previous cell[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-priorprefix[0m  [36mAppend prefix from the previous element to rows that match pattern[0m
	<[32mcolumn [0m> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
	<[32mdelimiter [0m> 
    [34m-case[0m  [36mChange case of column - type:lower,upper,proper,capitalize[0m
	<[32mcolumn [0m> 
	<[32mtype [0m values=lower,upper,proper,capitalize> 
    [34m-toid[0m  [36mConvert the column(s) into IDS (lowercase, no space, a-z0-9_)[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-padleft[0m  [36mPad left with given character[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mcharacter [0mCharacter to pad to> 
	<[32mlength [0mLength> 
    [34m-padright[0m  [36mPad right with given character[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mcharacter [0mCharacter to pad to> 
	<[32mlength [0mLength> 
    [34m-trim[0m  [36mTrim leading and trailing white space[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-trimquotes[0m  [36mTrim leading and trailing quotes[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-width[0m  [36mLimit the string size of the columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32msize [0m> 
    [34m-prepend[0m  [36mAdd the text to the beginning of the file. use _nl_ to insert newlines[0m
	<[32mtext [0m> 
    [34m-pad[0m  [36mAdd or remove columns to achieve the count[0m
	<[32mcount [0m> 
	<[32mpad string [0m> 
    [34m-prefix[0m  [36mAdd prefix to column[0m
	<[32mcolumn [0m> 
	<[32mprefix [0mString to use> 
    [34m-suffix[0m  [36mAdd suffix to column[0m
	<[32mcolumn [0m> 
	<[32msuffix [0m> 
    [34m-subst[0m  [36mCreate a new column with the template[0m
	<[32mcolumn_name [0mNew Column Name> 
	<[32mtemplate [0mTemplate - use ${column_name} ... > 
    [34m-ascii[0m  [36mConvert non ascii characters[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32msubstitution string [0muse $1, $2, etc for pattern (...) matches> 
    [34m-cleanphone[0m  [36mClean the phone number[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-formatphone[0m  [36mFormat the phone number[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-ismobile[0m  [36mAdd a true/false if the string is a mobile phone[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-sms[0m  [36mSend a text message - only for command line[0m
	<[32mcolumn [0mPhone number> 
	<[32mcampaign [0mCampaign> 
	<[32mmessage [0mMessage template size=60 rows=6> 
    [34m-js[0m  [36mDefine Javascript (e.g., functions) to use later in the -func call[0m
	<[32mjavascript [0m rows=6> 
    [34m-func[0m  [36mApply the javascript function. Use _colname or _col#[0m
	<[32mnames [0mNew column names> 
	<[32mjavascript [0mjavascript expression size=60> 
    [34m-endswith[0m  [36mEnsure that each column ends with the string[0m
	<[32mcolumn [0m> 
	<[32mstring [0m> 
    [34m-truncate[0m 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mmax length [0m> 
	<[32msuffix [0m> 
    [34m-extract[0m  [36mExtract text from column and make a new column[0m
	<[32mcolumn [0m> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
	<[32mreplace with [0muse 'none' for no replacement> 
	<[32mname [0mnew column name> 
    [34m-urlarg[0m  [36mExtract URL argument and make a new column[0m
	<[32mcolumn [0m> 
	<[32margname [0mURL arg name> 
    [34m-extracthtml[0m  [36mExtract text from HTML[0m
	<[32mcolumn [0mURL Column> 
	<[32mnames [0mComma separated list of new column names> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
    [34m-htmlinfo[0m  [36mExtract icon and description from input URL[0m
	<[32mcolumn [0mURL Column> 
    [34m-checkmissing[0m  [36mCheck for missing URL[0m
	<[32mcolumn [0mURL Column> 
	<[32mreplace_with [0mReplace with> 
    [34m-xmlencode[0m  [36mEncode the value for XML[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-urlencode[0m  [36mURL encode the columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-urldecode[0m  [36mURL decode the columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-map[0m  [36mChange values in column to new values[0m
	<[32mcolumn [0m> 
	<[32mnew column name [0m> 
	<[32mvalue [0mold_value new_value old_value new_value> 
    [34m-format[0m  [36mApply decimal format to the columns (see https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html)[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mformat [0mDecimal format  e.g. '##0.00'> 
    [34m-denormalize[0m  [36mRead the id,value from file and substitute the value in the dest file col idx[0m
	<[32mfile [0mFrom csv file> 
	<[32mfrom id idx [0m> 
	<[32mfrom value idx [0m> 
	<[32mto idx [0m> 
	<[32mnew col name [0m> 
	<[32mmode replace add [0m> 
    [34m-break[0m  [36mBreak apart column values and make new rows[0m
	<[32mlabel1 [0m> 
	<[32mlabel2 [0m> 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-parseemail[0m  [36mParse out name and email[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-makeids[0m  [36mTurn the header row into IDs (lowercase, no space, a-z0-9_)[0m
    [34m-faker[0m  [36mFake up data. See the docs at https://ramadda.org/repository/userguide/seesv.html#-faker[0m
	<[32mwhat [0mfirstname|lastname|fullname|etc> 
	<[32mcolumns [0mColumns to change. If none given then add the fake value> 
    [34m-edit[0m  [36mHand edit a column (command line only). ESC-stop, BLANK-skip[0m
	<[32mcolumn [0mkey column> 
[42mValues: [0m
    [34m-md[0m  [36mMake a message digest of the column values[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mtype [0m values=MD5,SHA-1,SHA-256,SHA-512,SHA3-256,SHA3-512,> 
    [34m-tob64[0m  [36mBase 64 Encode[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-fromb64[0m  [36mBase 64 Decode[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-rot13[0m  [36mRot 13[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-encrypt[0m  [36mEncrypt using AES with SHA-256 key[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpassword [0m> 
    [34m-decrypt[0m  [36mEncrypt using AES with SHA-256 key[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpassword [0m> 
    [34m-uuid[0m  [36mAdd a UUID field[0m
    [34m-number[0m  [36mAdd 1,2,3... as column[0m
    [34m-letter[0m  [36mAdd 'A','B', ... as column[0m
    [34m-soundex[0m  [36mGenerate a soundex code[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-wikidesc[0m  [36mAdd a description from Wikipedia[0m
	<[32mcolumns [0mSearch string columns> 
	<[32msuffix [0mText to add after> 
    [34m-image[0m  [36mDo a Bing image Search for an image[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32msuffix [0mText to add after> 
    [34m-embed[0m  [36mDownload the URL and embed the image contents[0m
	<[32murl column [0m> 
    [34m-fetch[0m  [36mFetch the URL and embed the contents[0m
	<[32mname [0mName of new column> 
	<[32mignore_errors [0mIgnore Errors e.g., true or false> 
	<[32murl [0mURL template, e.g., https://foo.com/${column_name}> 
    [34m-imagefill[0m  [36mSearch for an image with the query column text if the given image column is blank. Add the given suffix to the search. [0m
	<[32mquerycolumn [0m> 
	<[32msuffix [0m> 
	<[32mimagecolumn [0m> 
    [34m-download[0m  [36mDownload the URL[0m
	<[32mcolumn [0mColumn that holds the URL> 
	<[32msuffix [0mFile suffix> 
    [34m-gender[0m  [36mFigure out the gender of the name in the column[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
[42mDates: [0m
    [34m-indateformats[0m  [36mSpecify one or more date formats for parsing[0m
	<[32mformat [0me.g. yyyy-MM-dd HH:mm:ss.  Use semi-colon separated formats for multiples. <a target=_help href=https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html>Help</a>> 
	<[32mtimezone [0m> 
    [34m-outdateformat[0m  [36mSpecify date format for formatting[0m
	<[32mformat [0me.g. yyyy-MM-dd HH:mm:ss. <a target=_help href=https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html>Help</a>> 
	<[32mtimezone [0m> 
    [34m-convertdate[0m  [36mConvert date[0m
	<[32mcolumns [0mColumns to convert> 
    [34m-adddate[0m  [36mAdd date[0m
	<[32mdate_column [0mDate Column> 
	<[32mvalue [0mValue Column> 
	<[32mvalue_type [0mValue type - millisecond,second,minute,hour,hour_of_day,week,month,year> 
    [34m-cleardate[0m  [36mClear date components[0m
	<[32mdate_column [0mDate Column> 
	<[32mcomponent [0mDate component values=millisecond,second,minute,hour_of_day,day_of_month,month> 
    [34m-extractdate[0m  [36mExtract date[0m
	<[32mdate column [0m> 
	<[32mwhat [0mWhat to extract, e.g., year, month, day_of_week, etc values=era,year,month,day_of_month,day_of_week,week_of_month,
day_of_week_in_month,am_pm,hour,hour_of_day,
minute,second,millisecond,days_in_year, hours_in_year, minutes_in_year,seconds_in_year> 
    [34m-formatdate[0m  [36mFormat date[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-formatdateoffset[0m  [36mFormat the date offset, e.g. the hours in year[0m
	<[32mcolumn [0m> 
	<[32mwhat [0mWhat type of offset, e.g., year, month, day_of_week, etc values=days_in_year, hours_in_year, minutes_in_year,seconds_in_year> 
    [34m-elapsed[0m  [36mCalculate elapsed time (ms) between rows[0m
	<[32mcolumn [0m> 
    [34m-msto[0m  [36mConvert milliseconds to[0m
	<[32mcolumn [0m> 
	<[32mto [0mseconds|hours|days|weeks|months|years> 
    [34m-latest[0m  [36mPass through rows whose date is the latest in the group of rows defined by the key column[0m
	<[32mcolumns [0mKey columns> 
	<[32mcolumn [0mDate column> 
	<[32mformat [0mDate Format, e.g. yyyy-MM-dd> 
    [34m-datediff[0m  [36mCalculate elapsed time between columns column1-column2[0m
	<[32mcolumn1 [0mColumn 1> 
	<[32mcolumn2 [0mColumn 2> 
	<[32munit [0mUnit-milliseconds,seconds,minutes,hours,days values=milliseconds,seconds,minutes,hours,days> 
    [34m-datecompare[0m  [36madd a true/false column comparing the date values[0m
	<[32mcolumn1 [0m> 
	<[32mcolumn2 [0m> 
	<[32moperator [0m<,<=,=,!=,>=,> values=<,<=,=,!=,>=,>> 
[42mNumeric: [0m
    [34m-scale[0m  [36mSet value={value+delta1}*scale+delta2[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mdelta1 [0m> 
	<[32mscale [0m> 
	<[32mdelta2 [0m> 
    [34m-makenumber[0m  [36mTry to parse as number[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-generate[0m  [36mAdd row values[0m
	<[32mlabel [0m> 
	<[32mstart [0m> 
	<[32mstep [0m> 
    [34m-decimals[0m  [36mRound decimals[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mnum_decimals [0mhow many decimals to round to> 
    [34m-fuzz[0m  [36mfuzz the number. if num_places less than zero than that is the # of decimals. else that is the lower digits to fuzz out[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mnum_places [0mhow many places to round to. use <=0 for decimals> 
	<[32mnum_random_digits [0mhow many random digits> 
    [34m-ceil[0m  [36mSet the max value[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mvalue [0mValue> 
    [34m-floor[0m  [36mSet the min value[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mvalue [0mValue> 
    [34m-delta[0m  [36mAdd column that is the delta from the previous step[0m
	<[32mkey columns [0m> 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-runningsum[0m  [36mMake a running sum of the column values[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-trendcounter[0m  [36mMake counter field that is incremented everytime the value column decreases[0m
	<[32mcolumn [0mThe value column> 
	<[32mname [0mName of counter column> 
    [34m-operator[0m  [36mApply the operator to the given columns and create new one[0m
	<[32mcolumns [0mColumns> 
	<[32mnew col name [0m> 
	<[32moperator [0mOperator:+,-,*,/,%,average values=+,-,*,/,%,average> 
    [34m-compare[0m  [36mAdd a true/false column comparing the values[0m
	<[32mcolumn1 [0m> 
	<[32mcolumn2 [0m> 
	<[32moperator [0m<,<=,=,!=,>=,> values=<,<=,=,!=,>=,>> 
    [34m-round[0m  [36mRound the values[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-abs[0m  [36mMake absolute values[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-clip[0m  [36mClip the number to within the range[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mmin [0m> 
	<[32mmax [0m> 
    [34m-rand[0m  [36mmake random value[0m
	<[32mcolumn name [0m> 
	<[32mminrange [0mMinimum range (e.g. 0)> 
	<[32mmaxrange [0mMaximum range (e.g. 1)> 
    [34m-even[0m  [36mAdd true if the column starts with an even number[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-sum[0m  [36mSum values keying on key column value. If no value columns specified then do a count[0m
	<[32mkey columns [0m> 
	<[32mvalue columns [0m> 
	<[32mcarry over columns [0m> 
    [34m-pivot[0m  [36mMake a pivot table[0m
	<[32mkey columns [0mColumns to key on> 
	<[32mcolumn columns [0mThe columns the values of which are used to make the new columns in the result> 
	<[32mvalue column [0mThe value column> 
	<[32moperator [0mThe operator to apply -  count,sum,average,min,max> 
    [34m-summary[0m  [36mcount/sum/average/min/max values keying on key column value. If no value columns specified then do a count[0m
	<[32mkey columns [0mColumns to key on> 
	<[32mvalue columns [0mColumns to apply operators on> 
	<[32mcarry over columns [0mExtra columns to include> 
	<[32mops [0many of count,sum,average,min,max> 
    [34m-histogram[0m  [36mMake a histogram with the given column and bins[0m
	<[32mcolumn [0mThe column> 
	<[32mbins [0mComma separated set of bin values> 
	<[32mvalue columns [0mExtra columns to sum up> 
	<[32mops [0mops to apply to extra columns - any of count,sum,average,min,max> 
    [34m-percent[0m  [36mAdd columns together. Replace with their percentage[0m
	<[32mcolumns [0mColumns to add> 
    [34m-increase[0m  [36mCalculate percent increase[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mhow far back [0m> 
    [34m-diff[0m  [36mDifference from previous value[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mhow far back (default 1) [0m> 
    [34m-average[0m  [36mCalculate a moving average[0m
	<[32mcolumns [0mColumns> 
	<[32mperiod [0m> 
	<[32mlabel [0m> 
    [34m-ranges[0m  [36mCreate a new column with the (string) ranges where the value falls in[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mname [0mNew column name> 
	<[32mstart [0mNumeric start of range> 
	<[32msize [0mNumeric size of range> 
    [34m-bytes[0m  [36mConvert suffixed values (e.g., 2 MB) into the number[0m
	<[32munit [0m values=binary,metric> 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-column_and[0m  [36mAnd values[0m
	<[32mname [0mNew column name> 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-colum_nor[0m  [36mOr values[0m
	<[32mname [0mNew column name> 
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
    [34m-column_not[0m  [36mNot value[0m
	<[32mname [0mNew column name> 
	<[32mcolumn [0m> 
    [34m-check[0m  [36mCheck that the values are numbers[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mwhat [0mHow strict values=strict,ramadda> 
[42mGeospatial: [0m
    [34m-geocode[0m  [36mGeocode using given columns[0m
	<[32mcolumns [0mAddress columns> 
	<[32mprefix [0moptional prefix e.g., state: or county: or country:> 
	<[32msuffix [0m> 
    [34m-geocodeifneeded[0m  [36mGeocode if needed[0m
	<[32mcolumns [0mAddress columns> 
	<[32mprefix [0moptional prefix e.g., state: or county: or country:> 
	<[32msuffix [0m> 
	<[32mlatitude [0mlatitude column> 
	<[32mlongitude [0mlongitude column> 
    [34m-geocodeaddressdb[0m  [36mGeocode for import into RAMADDA's DB. The lat/lon is one semi-colon delimited column[0m
	<[32mcolumns [0mcolumns> 
	<[32mprefix [0moptional prefix e.g., state: or county: or country:> 
	<[32msuffix [0m> 
    [34m-geocodejoin[0m  [36mGeocode with file[0m
	<[32mcolumn [0mkey column> 
	<[32mcsv file [0mFile to get lat/lon from> 
	<[32mkey idx [0m> 
	<[32mlat idx [0m> 
	<[32mlon idx [0m> 
    [34m-bounds[0m  [36mGeocode within bounds[0m
	<[32mnorth [0m> 
	<[32mwest [0m> 
	<[32msouth [0m> 
	<[32meast [0m> 
    [34m-decodelatlon[0m  [36mDecode latlon[0m
	<[32mcolumns [0mLat or Lon column> 
    [34m-getaddress[0m  [36mGet address from lat/lon[0m
	<[32mlatitude [0mlatitude column> 
	<[32mlatitude [0mlatitude column> 
    [34m-statename[0m  [36mAdd state name from state ID[0m
	<[32mstate_column [0mState ID column> 
    [34m-geoname[0m  [36mLook up location name[0m
	<[32mlookup [0m('counties' or 'states' or 'countries' or 'timezones')> 
	<[32mfields [0mfields in shapefile> 
	<[32mlatitude [0mLatitude column> 
	<[32mlongitude [0mLongitude column> 
    [34m-geocontains[0m  [36mCheck for containment[0m
	<[32mlookup [0m('counties' or 'states' or 'countries' or 'timezones')> 
	<[32mname [0mnew column name> 
	<[32mlatitude [0mLatitude column> 
	<[32mlongitude [0mLongitude column> 
    [34m-elevation[0m  [36mLook up elevation(using 1/3 arc-second DEM)[0m
	<[32mlatitude [0mLatitude column> 
	<[32mlongitude [0mLongitude column> 
    [34m-mercator[0m  [36mConvert x/y to lon/lat[0m
	<[32mcolumns [0mx and y columns> 
    [34m-region[0m  [36mAdd the state's region[0m
	<[32mcolumns [0mColumns with state name or abbrev.> 
    [34m-population[0m  [36mAdd in population from address[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mprefix [0me.g., state: or county: or city:> 
	<[32msuffix [0m> 
    [34m-neighborhood[0m  [36mLook up neighborhood for a given location[0m
	<[32mlatitude [0mLatitude column> 
	<[32mlongitude [0mLongitude column> 
	<[32mdefault [0mDefault value> 
[42mMisc: [0m
    [34m-apply[0m  [36mApply the commands to each of the columns[0m
	<[32mcolumns [0mColumns to expand with> 
	<[32mcommands [0mCommands. Use the macro ${column}. End with -endapply rows=6> 
    [34m-sortby[0m 
	<[32mcolumns [0mColumn to sort on> 
	<[32mdirection [0mDirection - up or down values=up,down> 
	<[32mhow [0mHow to sort - string, length, date, extract (number) values=string,number,length,date,extract> 
    [34m-count[0m  [36mShow count[0m
    [34m-alias[0m  [36mSet a field alias[0m
	<[32mname [0mName> 
	<[32malias [0mAlias> 
    [34m-value[0m  [36mDefine a macro value for later use[0m
	<[32mname [0mname> 
	<[32mvalue [0mValue> 
    [34m-filepattern[0m  [36mExtract a macro value from a filename[0m
	<[32mname [0mMacro name> 
	<[32mpattern [0mRegexp pattern. <a href=https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html target=_help>Help</a>> 
    [34m-changeline[0m  [36mChange the line[0m
	<[32mfrom [0mFrom pattern> 
	<[32mto [0mTo string> 
    [34m-changeraw[0m  [36mChange input text[0m
	<[32mfrom [0mFrom pattern> 
	<[32mto [0mTo string> 
    [34m-crop[0m  [36mCrop last part of string after any of the patterns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mpatterns [0mComma separated list of patterns> 
    [34m-strict[0m  [36mBe strict on columns. any rows that are not the size of the other rows are dropped[0m
    [34m-flag[0m  [36mBe strict on columns. any rows that are not the size of the other rows are shown[0m
    [34m-prop[0m  [36mSet a property[0m
	<[32mproperty [0m values=position> 
	<[32mvalue [0mstart, end, etc> 
    [34m-goeasy[0m  [36mGo easy on missing columns[0m
    [34m-verify[0m  [36mVerify that all of the rows have the same # of columns[0m
    [34m-ext[0m  [36mExecute the external program[0m
	<[32mprogram_id [0mmatches with seesv.ext.&lt;program_id&gt;=/path> 
    [34m-exec[0m  [36mExecute the external program for every line[0m
	<[32mprogram_id [0mmatches with seesv.ext.&lt;program_id&gt;=/path> 
[42mOutput: [0m
    [34m-print[0m  [36mPrint text output[0m
    [34m-printdelim[0m  [36mPrint with delimited output[0m
	<[32mdelimiter [0mDelimiter - ,|^ etc. Use "tab" for tab> 
    [34m-o[0m  [36mWrite to the given file (command line only)[0m
	<[32mfile [0mThe file> 
    [34m-comment[0m  [36mAdd a comment to the output[0m
	<[32mcomment [0mThe comment> 
    [34m-outputprefix[0m  [36mSpecify text to add to the beginning of the file[0m
	<[32mtext [0mThe text. Use '_nl_' to add a new line. Use '_bom_' to write out the byte order mark.> 
    [34m-highlight[0m  [36mHighlight the columns[0m
	<[32mcolumns [0mColumn indices. Can include ranges, e.g. 0-5> 
	<[32mcolor [0mColor values=red,green,yellow,blue,purple,cyan> 
    [34m-background[0m  [36mBackground the columns[0m
	<[32mcolor [0mColor values=red,green,yellow,blue,purple,cyan> 
    [34m-printheader[0m  [36mPrint header[0m
    [34m-raw[0m  [36mPrint the file raw[0m
    [34m-table[0m  [36mPrint HTML table and stats[0m
    [34m-cols[0m  [36mSet the width of the columns for output. Use with -p[0m
	<[32mwidth [0mColumn width> 
    [34m-stats[0m  [36mPrint summary stats[0m
    [34m-torecord[0m  [36mPrint records[0m
    [34m-script[0m  [36mGenerate script[0m
    [34m-toxml[0m  [36mGenerate XML[0m
	<[32mouter tag [0m> 
	<[32minner tag [0m> 
    [34m-tojson[0m  [36mGenerate JSON[0m
	<[32mkey index [0mIf defined use this as a map> 
    [34m-togeojson[0m  [36mGenerate GeoJSON[0m
	<[32mlatitude [0mlatitude column> 
	<[32mlongitude [0mlongitude column> 
	<[32mcolumns [0mproperty columns - use * for all> 
    [34m-tourl[0m  [36mGenerate DB publish urls[0m
    [34m-todb[0m  [36mWrite to Database[0m
	<[32mdb id [0m> 
	<[32mtable [0mtable name> 
	<[32mcolumns [0mdatabase columns> 
	<[32mproperties [0mname value properties> 
    [34m-template[0m  [36mApply the template to make the output[0m
	<[32mprefix [0m size=40> 
	<[32mtemplate [0mUse ${column_name} or indices: ${0},${1}, etc for values rows=6> 
	<[32mrow_delimiter [0mOutput between rows size=40> 
	<[32msuffix [0m size=40> 
    [34m-subd[0m  [36mSubdivide into different files[0m
	<[32mcolumns [0mcolumns to subdivide on> 
	<[32mranges [0mComma separated ranges min1;max1;step1,min2;max2;step2> 
	<[32moutput_template [0mOutput template - use ${ikey} or ${vkey}, e.g., grid${ikey}.csv> 
    [34m-maptiles[0m  [36mTile the data on lat/lon[0m
	<[32mcolumns [0mlat/lon columns to subdivide on> 
	<[32mdegrees [0mDegrees per tile. Defaults to 1> 
	<[32moutput_template [0mOutput template - use ${ikey} or ${vkey}, e.g., tile${vkey}.csv. Defaults to a tile${vket}.csv> 
    [34m-chunk[0m  [36mMake a number of output files with a max number of rows[0m
	<[32moutput_template [0mOutput template - use ${number}, e.g., output${number}.csv. Defaults to a output${number}.csv> 
	<[32mnumber [0mNumber of rows in each file> 
    [34m-addheader[0m  [36mAdd the RAMADDA point properties[0m
	<[32mproperties [0mname1 value1 ... nameN valueN
Set default: default.type double rows=6> 
    [34m-db[0m  [36mGenerate the RAMADDA db xml from the header. See <a class=ramadda-decor target=_help href=https://ramadda.org/repository/userguide/seesv.html#-db>Help</a>[0m
	<[32mproperties [0mName value pairs:\n		table.id &lt;new id&gt; table.name &lt;new name&gt;\ntable.cansearch false table.canlist false\ntable.icon &lt;icon&gt;, e.g., /db/database.png\n		&lt;column&gt;.id &lt;new id for column&gt; &lt;column&gt;.label &lt;new label&gt;\n		&lt;column&gt;.type &lt;string|enumeration|double|int|date|latlon&gt;\n		&lt;column&gt;.format &lt;yyyy MM dd HH mm ss format for dates&gt;\n		&lt;column&gt;.canlist false &lt;column&gt;.cansearch false\n		db.install &lt;true|false&gt; install the new db table\n		db.droptable &lt;true|false&gt; careful! this deletes any prior created dbs\n	db.yesreallydroptable true - this double checks rows=10> 
    [34m-dbprops[0m  [36mPrint to stdout props for db generation[0m
	<[32mid pattern [0m> 
	<[32msuffix pattern [0m> 
    [34m-write[0m  [36mWrite the contents of a row to a named file[0m
	<[32mfile name template [0m> 
	<[32mcontents template [0m> 
    [34m-fields[0m  [36mPrint the fields[0m
    [34m-run[0m 
	<[32mName of process directory [0m> 
    [34m-progress[0m  [36mShow progress[0m
	<[32mrows [0mHow often to print> 
    [34m-debugrows[0m  [36mDebug # rows[0m
	<[32mrows [0m# of rows> 
    [34m-pointheader[0m  [36mGenerate the RAMADDA point properties[0m
    [34m-args[0m  [36mGenerate the CSV file commands[0m
    [34m-typexml[0m  [36mGenerate the RAMADDA type xml[0m
	<[32mtype_id [0mType ID, prefix with type_, no spaces, lowercase, e.g.type_point_mypointdata> 
	<[32mtype_label [0mType Label - human readable label> 
	<[32mdatabase_columns [0mList of database columns, one per line
e.g:id,label,type,prop,value1,prop2,value1
Types can be:
string,int,double,enumeration,enumerationplus
list,latlon,latlonbox,url,date,datetime
If enumeration then define values with escaped commas - \,:<pre>fruit,Fruit,enumeration,values,banana\,apple\,orange</pre> size=40 rows=6 delimiter=;>
</div>
<p>

<p>&nbsp;<p>

<div class="ramadda-doc-footer">
<table width=100% cellspacing=0 cellpadding=0 >
<tr><td width=30%><div class=ramadda-doc-nav-container><div class=ramadda-doc-nav><a href="etl.html"><table><td valign=center><td><span title="Previous: ETL Tools"><i  style='font-size:16pt;'  class="fa fa-caret-left "></i></span></td><td>ETL Tools</td></tr></table></a></div></div></td>
<td align=right width=30%><div class=ramadda-doc-nav-container><div class=ramadda-doc-nav><a href="dataexample.html"><table><tr valign=center><td>Data Example</td><td><span title="Next: Data Example"><i  style='font-size:16pt;'  class="fa fa-caret-right "></i></span></td></tr></table></a> </div></div> </td>
</tr></table>
</div>
<p>
</div>
</body>
</html>

